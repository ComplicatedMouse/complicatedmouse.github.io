<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nn::util Namespace Reference | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenn.html">nn</a></li><li class="navelem"><a class="el" href="namespacenn_1_1util.html">util</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">nn::util Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace for the utility library.  
<a href="namespacenn_1_1util.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacenn_1_1util_1_1general"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1general.html">general</a></td></tr>
<tr class="memdesc:namespacenn_1_1util_1_1general"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the generic implementation of vector and matrix calculations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacenn_1_1util_1_1neon"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1neon.html">neon</a></td></tr>
<tr class="memdesc:namespacenn_1_1util_1_1neon"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the implementation of vector and matrix calculation using ARM NEON. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacenn_1_1util_1_1pmr"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1pmr.html">pmr</a></td></tr>
<tr class="memdesc:namespacenn_1_1util_1_1pmr"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the functionality for handling memory resources conforming to the <code>std::pmr</code> namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_accessor_base.html">AccessorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for accessors.  <a href="classnn_1_1util_1_1_accessor_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1basic__string__view.html">basic_string_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a string reference.  <a href="classnn_1_1util_1_1basic__string__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_binary_block_header.html">BinaryBlockHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This feature is read-only.  <a href="structnn_1_1util_1_1_binary_block_header.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_binary_file_header.html">BinaryFileHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This feature is read-only.  <a href="structnn_1_1util_1_1_binary_file_header.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_bin_block_signature.html">BinBlockSignature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This feature is read-only.  <a href="structnn_1_1util_1_1_bin_block_signature.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_bin_file_signature.html">BinFileSignature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This feature is read-only.  <a href="structnn_1_1util_1_1_bin_file_signature.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_bin_t_ptr.html">BinTPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This feature is read-only.  <a href="structnn_1_1util_1_1_bin_t_ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_bin_t_string.html">BinTString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This feature is read-only.  <a href="structnn_1_1util_1_1_bin_t_string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_bin_version.html">BinVersion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This feature is read-only.  <a href="structnn_1_1util_1_1_bin_version.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_bit_array.html">BitArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed length bit array.  <a href="classnn_1_1util_1_1_bit_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">BitFlagSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type for handling a POD bit flag set.  <a href="structnn_1_1util_1_1_bit_flag_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_bit_pack.html">BitPack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitfield substitution type.  <a href="structnn_1_1util_1_1_bit_pack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_byte_ptr.html">BytePtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer for byte unit access.  <a href="classnn_1_1util_1_1_byte_ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_color4f.html">Color4f</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that supports colors expressed as 32-bit floating point numbers for each of the four components.  <a href="classnn_1_1util_1_1_color4f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_color4u8.html">Color4u8</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that supports colors expressed as unsigned 8-bit integers for each of the four components.  <a href="classnn_1_1util_1_1_color4u8.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_const_byte_ptr.html">ConstBytePtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immutable pointer for byte unit access.  <a href="classnn_1_1util_1_1_const_byte_ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_float2.html">Float2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a two-dimensional vector using an array of single precision floating point numbers.  <a href="structnn_1_1util_1_1_float2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_float3.html">Float3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a three-dimensional vector using an array of single precision floating point numbers.  <a href="structnn_1_1util_1_1_float3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_float4.html">Float4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a four-dimensional vector using an array of single precision floating point numbers.  <a href="structnn_1_1util_1_1_float4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_float_column_major3x2.html">FloatColumnMajor3x2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a three-row, two-column, column-major matrix using a single precision floating point array.  <a href="structnn_1_1util_1_1_float_column_major3x2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_float_column_major4x3.html">FloatColumnMajor4x3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a four-row, three-column, column-major matrix using a single precision floating point array.  <a href="structnn_1_1util_1_1_float_column_major4x3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_float_column_major4x4.html">FloatColumnMajor4x4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a four-row, four-column, column-major matrix using a single precision floating point array.  <a href="structnn_1_1util_1_1_float_column_major4x4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_float_format.html">FloatFormat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Floating point number format.  <a href="classnn_1_1util_1_1_float_format.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_float_row_major3x2.html">FloatRowMajor3x2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a three-row, two-column, row-major matrix using a single precision floating point array.  <a href="structnn_1_1util_1_1_float_row_major3x2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_float_row_major4x3.html">FloatRowMajor4x3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a four-row, three-column, row-major matrix using a single precision floating point array.  <a href="structnn_1_1util_1_1_float_row_major4x3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_float_row_major4x4.html">FloatRowMajor4x4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a four-row, four-column, row-major matrix using a single precision floating point array.  <a href="structnn_1_1util_1_1_float_row_major4x4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_i_function.html">IFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for the abstraction of function calls.  <a href="classnn_1_1util_1_1_i_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_i_function_3_01_r_07_args_8_8_8_08_4.html">IFunction&lt; R(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of <code><a class="el" href="classnn_1_1util_1_1_i_function.html" title="Interface for the abstraction of function calls.">IFunction</a></code> that takes the function type.  <a href="classnn_1_1util_1_1_i_function_3_01_r_07_args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_intrusive_dic.html">IntrusiveDic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An intrusive dictionary.  <a href="classnn_1_1util_1_1_intrusive_dic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_intrusive_dic_base_node.html">IntrusiveDicBaseNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An intrusive dictionary node.  <a href="classnn_1_1util_1_1_intrusive_dic_base_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_intrusive_dic_base_node_traits.html">IntrusiveDicBaseNodeTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that defines the access method to an intrusive dictionary node.  <a href="classnn_1_1util_1_1_intrusive_dic_base_node_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_intrusive_dic_member_node_traits.html">IntrusiveDicMemberNodeTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that defines the access method to an intrusive dictionary node.  <a href="classnn_1_1util_1_1_intrusive_dic_member_node_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_intrusive_dic_node.html">IntrusiveDicNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An intrusive dictionary node.  <a href="classnn_1_1util_1_1_intrusive_dic_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_intrusive_list.html">IntrusiveList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrusive type list.  <a href="classnn_1_1util_1_1_intrusive_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_intrusive_list_base_node.html">IntrusiveListBaseNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrusive type list node.  <a href="classnn_1_1util_1_1_intrusive_list_base_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_intrusive_list_base_node_traits.html">IntrusiveListBaseNodeTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to define the access method to a node in an intrusive list.  <a href="classnn_1_1util_1_1_intrusive_list_base_node_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_intrusive_list_member_node_traits.html">IntrusiveListMemberNodeTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to define the access method to a node in an intrusive list.  <a href="classnn_1_1util_1_1_intrusive_list_member_node_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_intrusive_list_node.html">IntrusiveListNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrusive type list node.  <a href="classnn_1_1util_1_1_intrusive_list_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_matrix_column_major3x2f_type.html">MatrixColumnMajor3x2fType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a three-row, two-column, column-major matrix using a single precision floating point data type.  <a href="structnn_1_1util_1_1_matrix_column_major3x2f_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_matrix_column_major4x3f_type.html">MatrixColumnMajor4x3fType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a four-row, three-column, column-major matrix using a single precision floating point data type.  <a href="structnn_1_1util_1_1_matrix_column_major4x3f_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_matrix_column_major4x4f_type.html">MatrixColumnMajor4x4fType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a four-row, four-column, column-major matrix using a single precision floating point data type.  <a href="structnn_1_1util_1_1_matrix_column_major4x4f_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_matrix_row_major3x2f.html">MatrixRowMajor3x2f</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a three-row, two-column, row-major matrix using a single precision floating point data type.  <a href="classnn_1_1util_1_1_matrix_row_major3x2f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_matrix_row_major3x2f_type.html">MatrixRowMajor3x2fType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a three-row, two-column, row-major matrix using a single precision floating point data type.  <a href="structnn_1_1util_1_1_matrix_row_major3x2f_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_matrix_row_major4x3f.html">MatrixRowMajor4x3f</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a four-column, three-row, column-major matrix using a single precision floating point data type.  <a href="classnn_1_1util_1_1_matrix_row_major4x3f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_matrix_row_major4x3f_type.html">MatrixRowMajor4x3fType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a four-row, three-column, row-major matrix using a single precision floating point data type.  <a href="structnn_1_1util_1_1_matrix_row_major4x3f_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_matrix_row_major4x4f.html">MatrixRowMajor4x4f</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a four-column, four-row, column-major matrix using a single precision floating point data type.  <a href="classnn_1_1util_1_1_matrix_row_major4x4f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_matrix_row_major4x4f_type.html">MatrixRowMajor4x4fType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a four-row, four-column, row-major matrix using a single precision floating point data type.  <a href="structnn_1_1util_1_1_matrix_row_major4x4f_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_memory_splitter.html">MemorySplitter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a memory splitter.  <a href="classnn_1_1util_1_1_memory_splitter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_placement_array.html">PlacementArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed length array.  <a href="classnn_1_1util_1_1_placement_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_ptr_placement_array.html">PtrPlacementArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for fixed size pointer arrays.  <a href="classnn_1_1util_1_1_ptr_placement_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_quaternion.html">Quaternion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that expresses quaternions using a single precision floating number type.  <a href="classnn_1_1util_1_1_quaternion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_relocation_table.html">RelocationTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This feature is read-only.  <a href="structnn_1_1util_1_1_relocation_table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_res_dic.html">ResDic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This feature is read-only.  <a href="classnn_1_1util_1_1_res_dic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_res_dic_data.html">ResDicData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This feature is read-only.  <a href="structnn_1_1util_1_1_res_dic_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_res_endian.html">ResEndian</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This feature is read-only.  <a href="classnn_1_1util_1_1_res_endian.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_shared_function.html">SharedFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class template for managing <code><a class="el" href="classnn_1_1util_1_1_i_function.html" title="Interface for the abstraction of function calls.">IFunction</a></code> using a shared pointer.  <a href="classnn_1_1util_1_1_shared_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_shared_function_3_01_r_07_args_8_8_8_08_4.html">SharedFunction&lt; R(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>SharedFunction&lt;T&gt;</code>.  <a href="classnn_1_1util_1_1_shared_function_3_01_r_07_args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_streaming_decompress_zlib_context.html">StreamingDecompressZlibContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context for streaming decompression of data compressed in <code>zlib</code> format.  <a href="structnn_1_1util_1_1_streaming_decompress_zlib_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_string_pool.html">StringPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This feature is read-only.  <a href="structnn_1_1util_1_1_string_pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_tiny_mt.html">TinyMt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for generating pseudo-random numbers using TinyMT.  <a href="classnn_1_1util_1_1_tiny_mt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_typed_storage.html">TypedStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure is for allocating a region to place data with a hidden type.  <a href="structnn_1_1util_1_1_typed_storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_uint8x4.html">Uint8x4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that holds a one-dimensional array of four elements, each an 8-byte unsigned integer.  <a href="structnn_1_1util_1_1_uint8x4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_unorm8x4.html">Unorm8x4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that holds a one-dimensional array of four elements, each a normalized 8-byte unsigned integer.  <a href="structnn_1_1util_1_1_unorm8x4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_uuid.html">Uuid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a Universally Unique Identifier (UUID) that conforms to RFC 4122.  <a href="structnn_1_1util_1_1_uuid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_vector2f.html">Vector2f</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that expresses two-dimensional vectors using a single precision floating number type.  <a href="classnn_1_1util_1_1_vector2f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_vector2f_type.html">Vector2fType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a two-dimensional vector using a single precision floating point data type.  <a href="structnn_1_1util_1_1_vector2f_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_vector3f.html">Vector3f</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that expresses three-dimensional vectors using a single precision floating number type.  <a href="classnn_1_1util_1_1_vector3f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_vector3f_type.html">Vector3fType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a three-dimensional vector using a single precision floating point data type.  <a href="structnn_1_1util_1_1_vector3f_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_vector4f.html">Vector4f</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that expresses four-dimensional vectors using a single precision floating number type.  <a href="classnn_1_1util_1_1_vector4f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_vector4f_type.html">Vector4fType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a four-dimensional vector using a single precision floating point data type.  <a href="structnn_1_1util_1_1_vector4f_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9a123aed03be22d1567aeb27d70c1a56"><td class="memItemLeft" align="right" valign="top"><a id="a9a123aed03be22d1567aeb27d70c1a56"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a></td></tr>
<tr class="memdesc:a9a123aed03be22d1567aeb27d70c1a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents angles in an index that defines one circumference as <code>0x100000000</code>. <br /></td></tr>
<tr class="separator:a9a123aed03be22d1567aeb27d70c1a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2311530adea3fb605362c03b3be5482a"><td class="memItemLeft" align="right" valign="top"><a id="a2311530adea3fb605362c03b3be5482a"></a>
typedef <a class="el" href="structnn_1_1util_1_1_bin_t_ptr.html">BinTPtr</a>&lt; <a class="el" href="namespacenn_1_1util.html#a720977b9949f595d5e3e3a36e4afd0a1">BinString</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a2311530adea3fb605362c03b3be5482a">BinPtrToString</a></td></tr>
<tr class="memdesc:a2311530adea3fb605362c03b3be5482a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="structnn_1_1util_1_1_bin_t_ptr.html" title="This feature is read-only.">BinTPtr</a></code> that handles <code>BinString</code> types. <br /></td></tr>
<tr class="separator:a2311530adea3fb605362c03b3be5482a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720977b9949f595d5e3e3a36e4afd0a1"><td class="memItemLeft" align="right" valign="top"><a id="a720977b9949f595d5e3e3a36e4afd0a1"></a>
typedef <a class="el" href="structnn_1_1util_1_1_bin_t_string.html">BinTString</a>&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a720977b9949f595d5e3e3a36e4afd0a1">BinString</a></td></tr>
<tr class="memdesc:a720977b9949f595d5e3e3a36e4afd0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="structnn_1_1util_1_1_bin_t_string.html" title="This feature is read-only.">BinTString</a></code> of the character type <code>char</code>. <br /></td></tr>
<tr class="separator:a720977b9949f595d5e3e3a36e4afd0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49be54197d424ea300b187b942ed824"><td class="memItemLeft" align="right" valign="top"><a id="ac49be54197d424ea300b187b942ed824"></a>
typedef <a class="el" href="structnn_1_1util_1_1_vector4f_type.html">Vector4fType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ac49be54197d424ea300b187b942ed824">Color4fType</a></td></tr>
<tr class="memdesc:ac49be54197d424ea300b187b942ed824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expresses a color using a 32-bit floating-point number for each of the four components. <br /></td></tr>
<tr class="separator:ac49be54197d424ea300b187b942ed824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79dfd3486048d906ab2ef68bf8f9f3be"><td class="memItemLeft" align="right" valign="top"><a id="a79dfd3486048d906ab2ef68bf8f9f3be"></a>
typedef <a class="el" href="structnn_1_1util_1_1_unorm8x4.html">Unorm8x4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a79dfd3486048d906ab2ef68bf8f9f3be">Color4u8Type</a></td></tr>
<tr class="memdesc:a79dfd3486048d906ab2ef68bf8f9f3be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expresses a color using an unsigned 8-bit integer for each of the four components. <br /></td></tr>
<tr class="separator:a79dfd3486048d906ab2ef68bf8f9f3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a7e9c8b1f290aac20d7c882f20ab7c"><td class="memItemLeft" align="right" valign="top"><a id="ab0a7e9c8b1f290aac20d7c882f20ab7c"></a>
typedef <a class="el" href="structnn_1_1util_1_1_float_row_major3x2.html">FloatRowMajor3x2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ab0a7e9c8b1f290aac20d7c882f20ab7c">Float3x2</a></td></tr>
<tr class="memdesc:ab0a7e9c8b1f290aac20d7c882f20ab7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a three-row, two-column matrix using a single precision floating point array. <br /></td></tr>
<tr class="separator:ab0a7e9c8b1f290aac20d7c882f20ab7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f45cae1843465e71962a4f18f5fdb74"><td class="memItemLeft" align="right" valign="top"><a id="a1f45cae1843465e71962a4f18f5fdb74"></a>
typedef <a class="el" href="structnn_1_1util_1_1_float_row_major4x3.html">FloatRowMajor4x3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a1f45cae1843465e71962a4f18f5fdb74">Float4x3</a></td></tr>
<tr class="memdesc:a1f45cae1843465e71962a4f18f5fdb74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a four-row, three-column matrix using a single precision floating point array. <br /></td></tr>
<tr class="separator:a1f45cae1843465e71962a4f18f5fdb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb49f9abd5e4a507364789a6636faca"><td class="memItemLeft" align="right" valign="top"><a id="a3eb49f9abd5e4a507364789a6636faca"></a>
typedef <a class="el" href="structnn_1_1util_1_1_float_row_major4x4.html">FloatRowMajor4x4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a3eb49f9abd5e4a507364789a6636faca">Float4x4</a></td></tr>
<tr class="memdesc:a3eb49f9abd5e4a507364789a6636faca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a four-row, four-column matrix using a single precision floating point array. <br /></td></tr>
<tr class="separator:a3eb49f9abd5e4a507364789a6636faca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02a592887cf8bd6dca55fe851f6f729"><td class="memItemLeft" align="right" valign="top"><a id="aa02a592887cf8bd6dca55fe851f6f729"></a>
typedef <a class="el" href="classnn_1_1util_1_1_float_format.html">FloatFormat</a>&lt; 1, 5, 10 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aa02a592887cf8bd6dca55fe851f6f729">FloatFormat16</a></td></tr>
<tr class="memdesc:aa02a592887cf8bd6dca55fe851f6f729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition for 16-bit floating point numbers. <br /></td></tr>
<tr class="separator:aa02a592887cf8bd6dca55fe851f6f729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ee0c4d69245441c0ee8a498925e70c"><td class="memItemLeft" align="right" valign="top"><a id="aa9ee0c4d69245441c0ee8a498925e70c"></a>
typedef <a class="el" href="classnn_1_1util_1_1_float_format.html">FloatFormat</a>&lt; 1, 8, 23 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aa9ee0c4d69245441c0ee8a498925e70c">FloatFormat32</a></td></tr>
<tr class="memdesc:aa9ee0c4d69245441c0ee8a498925e70c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition for 32-bit floating point numbers. <br /></td></tr>
<tr class="separator:aa9ee0c4d69245441c0ee8a498925e70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30d0e9a77dc1b72739d270a2a4cb10b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structnn_1_1util_1_1_float_column_major3x2.html">FloatColumnMajor3x2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ac30d0e9a77dc1b72739d270a2a4cb10b">FloatT3x2</a></td></tr>
<tr class="memdesc:ac30d0e9a77dc1b72739d270a2a4cb10b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a three-row, two-column matrix using a single precision floating point array.  <a href="namespacenn_1_1util.html#ac30d0e9a77dc1b72739d270a2a4cb10b">More...</a><br /></td></tr>
<tr class="separator:ac30d0e9a77dc1b72739d270a2a4cb10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec387faf9cc69e9382a2a8002821f24"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structnn_1_1util_1_1_float_column_major4x3.html">FloatColumnMajor4x3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aaec387faf9cc69e9382a2a8002821f24">FloatT4x3</a></td></tr>
<tr class="memdesc:aaec387faf9cc69e9382a2a8002821f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a four-row, three-column matrix using a single precision floating point array.  <a href="namespacenn_1_1util.html#aaec387faf9cc69e9382a2a8002821f24">More...</a><br /></td></tr>
<tr class="separator:aaec387faf9cc69e9382a2a8002821f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11491fc1d12c8b6f393d794dc9737b46"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structnn_1_1util_1_1_float_column_major4x4.html">FloatColumnMajor4x4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a11491fc1d12c8b6f393d794dc9737b46">FloatT4x4</a></td></tr>
<tr class="memdesc:a11491fc1d12c8b6f393d794dc9737b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a four-row, three-column matrix using a single precision floating point array.  <a href="namespacenn_1_1util.html#a11491fc1d12c8b6f393d794dc9737b46">More...</a><br /></td></tr>
<tr class="separator:a11491fc1d12c8b6f393d794dc9737b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1037da81cd878626e7a661798f94b873"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a1037da81cd878626e7a661798f94b873">FormatStringOutputFunction</a>) (uintptr_t arg, const char *pCharacters, int count)</td></tr>
<tr class="memdesc:a1037da81cd878626e7a661798f94b873"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the callback function that receives the strings generated by <code><a class="el" href="namespacenn_1_1util.html#a54f65dcb71d5cb6e32f327ccab7f796c">FormatString</a></code> and <code><a class="el" href="namespacenn_1_1util.html#a1054c37da4a1d20fe6b0ca90a8ca351c">VFormatString</a></code>.  <a href="namespacenn_1_1util.html#a1037da81cd878626e7a661798f94b873">More...</a><br /></td></tr>
<tr class="separator:a1037da81cd878626e7a661798f94b873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad703d4cc91629b6b26764a5d1506efd8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classnn_1_1util_1_1_matrix_row_major3x2f.html">MatrixRowMajor3x2f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ad703d4cc91629b6b26764a5d1506efd8">Matrix3x2f</a></td></tr>
<tr class="memdesc:ad703d4cc91629b6b26764a5d1506efd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a three-row, two-column, row-major matrix using a single precision floating point data type.  <a href="namespacenn_1_1util.html#ad703d4cc91629b6b26764a5d1506efd8">More...</a><br /></td></tr>
<tr class="separator:ad703d4cc91629b6b26764a5d1506efd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57660aa7758ae3375aeffbd6b1424b24"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structnn_1_1util_1_1_matrix_row_major3x2f_type.html">MatrixRowMajor3x2fType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a57660aa7758ae3375aeffbd6b1424b24">Matrix3x2fType</a></td></tr>
<tr class="memdesc:a57660aa7758ae3375aeffbd6b1424b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a three-row, two-column matrix using a single precision floating point data type.  <a href="namespacenn_1_1util.html#a57660aa7758ae3375aeffbd6b1424b24">More...</a><br /></td></tr>
<tr class="separator:a57660aa7758ae3375aeffbd6b1424b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144c36edc0c1d0762f88b59f0a754b6a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classnn_1_1util_1_1_matrix_row_major4x3f.html">MatrixRowMajor4x3f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a144c36edc0c1d0762f88b59f0a754b6a">Matrix4x3f</a></td></tr>
<tr class="memdesc:a144c36edc0c1d0762f88b59f0a754b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a four-column, three-row, column-major matrix using a single precision floating point data type.  <a href="namespacenn_1_1util.html#a144c36edc0c1d0762f88b59f0a754b6a">More...</a><br /></td></tr>
<tr class="separator:a144c36edc0c1d0762f88b59f0a754b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb360b0e9579454c6af5804cc476c101"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structnn_1_1util_1_1_matrix_row_major4x3f_type.html">MatrixRowMajor4x3fType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#afb360b0e9579454c6af5804cc476c101">Matrix4x3fType</a></td></tr>
<tr class="memdesc:afb360b0e9579454c6af5804cc476c101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a four-row, three-column matrix using a single precision floating point data type.  <a href="namespacenn_1_1util.html#afb360b0e9579454c6af5804cc476c101">More...</a><br /></td></tr>
<tr class="separator:afb360b0e9579454c6af5804cc476c101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3916074464578212a8a939a4dbd08ae"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classnn_1_1util_1_1_matrix_row_major4x4f.html">MatrixRowMajor4x4f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ad3916074464578212a8a939a4dbd08ae">Matrix4x4f</a></td></tr>
<tr class="memdesc:ad3916074464578212a8a939a4dbd08ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a four-column, four-row, column-major matrix using a single precision floating point data type.  <a href="namespacenn_1_1util.html#ad3916074464578212a8a939a4dbd08ae">More...</a><br /></td></tr>
<tr class="separator:ad3916074464578212a8a939a4dbd08ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb0d5db7601e1af28a6f5b90cd5fd16"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structnn_1_1util_1_1_matrix_row_major4x4f_type.html">MatrixRowMajor4x4fType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a1bb0d5db7601e1af28a6f5b90cd5fd16">Matrix4x4fType</a></td></tr>
<tr class="memdesc:a1bb0d5db7601e1af28a6f5b90cd5fd16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a four-row, four-column matrix using a single precision floating point data type.  <a href="namespacenn_1_1util.html#a1bb0d5db7601e1af28a6f5b90cd5fd16">More...</a><br /></td></tr>
<tr class="separator:a1bb0d5db7601e1af28a6f5b90cd5fd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0393f5ea2f2d2bc1a17ff98976f4b084"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structnn_1_1util_1_1_matrix_column_major3x2f_type.html">MatrixColumnMajor3x2fType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a0393f5ea2f2d2bc1a17ff98976f4b084">MatrixT3x2fType</a></td></tr>
<tr class="memdesc:a0393f5ea2f2d2bc1a17ff98976f4b084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a three-row, two-column matrix using a single precision floating point data type.  <a href="namespacenn_1_1util.html#a0393f5ea2f2d2bc1a17ff98976f4b084">More...</a><br /></td></tr>
<tr class="separator:a0393f5ea2f2d2bc1a17ff98976f4b084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae68b9728d824289e709226f88f4326d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structnn_1_1util_1_1_matrix_column_major4x3f_type.html">MatrixColumnMajor4x3fType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aae68b9728d824289e709226f88f4326d">MatrixT4x3fType</a></td></tr>
<tr class="memdesc:aae68b9728d824289e709226f88f4326d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a four-row, three-column matrix using a single precision floating point data type.  <a href="namespacenn_1_1util.html#aae68b9728d824289e709226f88f4326d">More...</a><br /></td></tr>
<tr class="separator:aae68b9728d824289e709226f88f4326d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93b34341c777e6d93d6341520acebc8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structnn_1_1util_1_1_matrix_column_major4x4f_type.html">MatrixColumnMajor4x4fType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aa93b34341c777e6d93d6341520acebc8">MatrixT4x4fType</a></td></tr>
<tr class="memdesc:aa93b34341c777e6d93d6341520acebc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a four-row, four-column matrix using a single precision floating point data type.  <a href="namespacenn_1_1util.html#aa93b34341c777e6d93d6341520acebc8">More...</a><br /></td></tr>
<tr class="separator:aa93b34341c777e6d93d6341520acebc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ed3b5d58dc0275f9c96f4d4ec7a079"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structnn_1_1util_1_1_streaming_decompress_zlib_context.html">StreamingDecompressZlibContext</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#af2ed3b5d58dc0275f9c96f4d4ec7a079">StreamingDecompressDeflateContext</a></td></tr>
<tr class="memdesc:af2ed3b5d58dc0275f9c96f4d4ec7a079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context for streaming decompression of data compressed in <code>raw deflate</code> format.  <a href="namespacenn_1_1util.html#af2ed3b5d58dc0275f9c96f4d4ec7a079">More...</a><br /></td></tr>
<tr class="separator:af2ed3b5d58dc0275f9c96f4d4ec7a079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9beb7ac8f35cef8dd13f0416662320a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structnn_1_1util_1_1_streaming_decompress_zlib_context.html">StreamingDecompressZlibContext</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ae9beb7ac8f35cef8dd13f0416662320a">StreamingDecompressGzipContext</a></td></tr>
<tr class="memdesc:ae9beb7ac8f35cef8dd13f0416662320a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context for streaming decompression of data compressed in <code>gzip</code> format.  <a href="namespacenn_1_1util.html#ae9beb7ac8f35cef8dd13f0416662320a">More...</a><br /></td></tr>
<tr class="separator:ae9beb7ac8f35cef8dd13f0416662320a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f6a01d93a4172e07b7c0e80a680d42"><td class="memItemLeft" align="right" valign="top"><a id="a70f6a01d93a4172e07b7c0e80a680d42"></a>
typedef <a class="el" href="classnn_1_1util_1_1basic__string__view.html">basic_string_view</a>&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a70f6a01d93a4172e07b7c0e80a680d42">string_view</a></td></tr>
<tr class="memdesc:a70f6a01d93a4172e07b7c0e80a680d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">String reference where the character type is <code>char</code>. <br /></td></tr>
<tr class="separator:a70f6a01d93a4172e07b7c0e80a680d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a4a5a5a34319b208c9c23ac038d412a31"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a4a5a5a34319b208c9c23ac038d412a31">ByteOrderMark</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1util.html#a4a5a5a34319b208c9c23ac038d412a31af47a310dc26e97a75adae293e89fd52f">ByteOrderMark_Normal</a> = 0xFEFF
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1util.html#a4a5a5a34319b208c9c23ac038d412a31a59a43d310e2ac1c3f6a852eb5e2f789e">ByteOrderMark_Reverse</a> = 0xFFFE
<br />
 }</td></tr>
<tr class="memdesc:a4a5a5a34319b208c9c23ac038d412a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated type that indicates the byte order mark.  <a href="namespacenn_1_1util.html#a4a5a5a34319b208c9c23ac038d412a31">More...</a><br /></td></tr>
<tr class="separator:a4a5a5a34319b208c9c23ac038d412a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab72d7227a9a1b56f78d0caf2920478"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478a7f284c7d118115284232bd26b33c2149">CharacterEncodingResult_Success</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478aba616796fb8ce72bd5f1455c621a47b2">CharacterEncodingResult_InsufficientLength</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478aae294bb0babe7737681d80af74cef4a4">CharacterEncodingResult_InvalidFormat</a>
<br />
 }</td></tr>
<tr class="memdesc:a8ab72d7227a9a1b56f78d0caf2920478"><td class="mdescLeft">&#160;</td><td class="mdescRight">The encoding conversion result (error code).  <a href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">More...</a><br /></td></tr>
<tr class="separator:a8ab72d7227a9a1b56f78d0caf2920478"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a42e3d9b45bb488055380944fd50eeb48"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:a42e3d9b45bb488055380944fd50eeb48"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a42e3d9b45bb488055380944fd50eeb48">CanAddWithoutOverflow</a> (Int x, Int y) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a42e3d9b45bb488055380944fd50eeb48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the integer addition operation (<code><em>x</em></code> + <code><em>y</em></code>) can be performed without an overflow.  <a href="namespacenn_1_1util.html#a42e3d9b45bb488055380944fd50eeb48">More...</a><br /></td></tr>
<tr class="separator:a42e3d9b45bb488055380944fd50eeb48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6407c793283959089b9fb4699c0cfa11"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:a6407c793283959089b9fb4699c0cfa11"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a6407c793283959089b9fb4699c0cfa11">CanMultiplyWithoutOverflow</a> (Int x, Int y) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6407c793283959089b9fb4699c0cfa11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the integer multiplication operation (x * y) can be performed without an overflow.  <a href="namespacenn_1_1util.html#a6407c793283959089b9fb4699c0cfa11">More...</a><br /></td></tr>
<tr class="separator:a6407c793283959089b9fb4699c0cfa11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48caa0cf8edbb0c80d72c44b5c12e622"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:a48caa0cf8edbb0c80d72c44b5c12e622"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a48caa0cf8edbb0c80d72c44b5c12e622">CanSubtractWithoutOverflow</a> (Int x, Int y) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a48caa0cf8edbb0c80d72c44b5c12e622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the integer subtraction operation (<code><em>x</em></code> – <code><em>y</em></code>) can be performed without an overflow.  <a href="namespacenn_1_1util.html#a48caa0cf8edbb0c80d72c44b5c12e622">More...</a><br /></td></tr>
<tr class="separator:a48caa0cf8edbb0c80d72c44b5c12e622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce54d7a8842039362ff60b9a3e2b376"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a7ce54d7a8842039362ff60b9a3e2b376"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a7ce54d7a8842039362ff60b9a3e2b376">cmp_equal</a> (T t, U u) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7ce54d7a8842039362ff60b9a3e2b376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a safe comparison for type conversion of integers.  <a href="namespacenn_1_1util.html#a7ce54d7a8842039362ff60b9a3e2b376">More...</a><br /></td></tr>
<tr class="separator:a7ce54d7a8842039362ff60b9a3e2b376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bd5df913b7ea135003dadd676562e2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ab9bd5df913b7ea135003dadd676562e2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ab9bd5df913b7ea135003dadd676562e2">cmp_greater</a> (T t, U u) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab9bd5df913b7ea135003dadd676562e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a safe comparison for type conversion of integers.  <a href="namespacenn_1_1util.html#ab9bd5df913b7ea135003dadd676562e2">More...</a><br /></td></tr>
<tr class="separator:ab9bd5df913b7ea135003dadd676562e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13bf610c0f72953644cf95f356a24cc9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a13bf610c0f72953644cf95f356a24cc9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a13bf610c0f72953644cf95f356a24cc9">cmp_greater_equal</a> (T t, U u) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a13bf610c0f72953644cf95f356a24cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a safe comparison for type conversion of integers.  <a href="namespacenn_1_1util.html#a13bf610c0f72953644cf95f356a24cc9">More...</a><br /></td></tr>
<tr class="separator:a13bf610c0f72953644cf95f356a24cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69f568255b834efd162fcc0a94d3186"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ad69f568255b834efd162fcc0a94d3186"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ad69f568255b834efd162fcc0a94d3186">cmp_less</a> (T t, U u) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad69f568255b834efd162fcc0a94d3186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a safe comparison for type conversion of integers.  <a href="namespacenn_1_1util.html#ad69f568255b834efd162fcc0a94d3186">More...</a><br /></td></tr>
<tr class="separator:ad69f568255b834efd162fcc0a94d3186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0e6697ba2f6fdb58f4a65e8d350738"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:acf0e6697ba2f6fdb58f4a65e8d350738"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#acf0e6697ba2f6fdb58f4a65e8d350738">cmp_less_equal</a> (T t, U u) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acf0e6697ba2f6fdb58f4a65e8d350738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a safe comparison for type conversion of integers.  <a href="namespacenn_1_1util.html#acf0e6697ba2f6fdb58f4a65e8d350738">More...</a><br /></td></tr>
<tr class="separator:acf0e6697ba2f6fdb58f4a65e8d350738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a14e78e7feadb29e61b2d98c452777"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a85a14e78e7feadb29e61b2d98c452777"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a85a14e78e7feadb29e61b2d98c452777">cmp_not_equal</a> (T t, U u) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a85a14e78e7feadb29e61b2d98c452777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a safe comparison for type conversion of integers.  <a href="namespacenn_1_1util.html#a85a14e78e7feadb29e61b2d98c452777">More...</a><br /></td></tr>
<tr class="separator:a85a14e78e7feadb29e61b2d98c452777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89fad03d3f71a12026b6dcb2365180bb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a89fad03d3f71a12026b6dcb2365180bb"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a89fad03d3f71a12026b6dcb2365180bb">Exchange</a> (T *p, U value)</td></tr>
<tr class="memdesc:a89fad03d3f71a12026b6dcb2365180bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutes the specified value into the variable pointed to by the specified pointer, and returns the old value.  <a href="namespacenn_1_1util.html#a89fad03d3f71a12026b6dcb2365180bb">More...</a><br /></td></tr>
<tr class="separator:a89fad03d3f71a12026b6dcb2365180bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f65dcb71d5cb6e32f327ccab7f796c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a54f65dcb71d5cb6e32f327ccab7f796c">FormatString</a> (<a class="el" href="namespacenn_1_1util.html#a1037da81cd878626e7a661798f94b873">FormatStringOutputFunction</a> pOutputFunction, uintptr_t outputFunctionArg, const char *pFormat,...) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a54f65dcb71d5cb6e32f327ccab7f796c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats a string.  <a href="namespacenn_1_1util.html#a54f65dcb71d5cb6e32f327ccab7f796c">More...</a><br /></td></tr>
<tr class="separator:a54f65dcb71d5cb6e32f327ccab7f796c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df2ac5ca47857cc945af5421ea54aa5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1util_1_1_uuid.html">Uuid</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a7df2ac5ca47857cc945af5421ea54aa5">GenerateUuid</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7df2ac5ca47857cc945af5421ea54aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Universally Unique Identifier (UUID) that conforms to RFC 4122.  <a href="namespacenn_1_1util.html#a7df2ac5ca47857cc945af5421ea54aa5">More...</a><br /></td></tr>
<tr class="separator:a7df2ac5ca47857cc945af5421ea54aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a88c08c31dc52dc7c6e0bec2b517992"><td class="memTemplParams" colspan="2">template&lt;typename Destination , typename Source &gt; </td></tr>
<tr class="memitem:a8a88c08c31dc52dc7c6e0bec2b517992"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a8a88c08c31dc52dc7c6e0bec2b517992">in_range</a> (Source n) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8a88c08c31dc52dc7c6e0bec2b517992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified integer value can be represented as the specified type.  <a href="namespacenn_1_1util.html#a8a88c08c31dc52dc7c6e0bec2b517992">More...</a><br /></td></tr>
<tr class="separator:a8a88c08c31dc52dc7c6e0bec2b517992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d03a923928589295b3070211843fd3"><td class="memTemplParams" colspan="2">template&lt;typename Destination , typename Source &gt; </td></tr>
<tr class="memitem:a82d03a923928589295b3070211843fd3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a82d03a923928589295b3070211843fd3">IsIntValueRepresentable</a> (Source n) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a82d03a923928589295b3070211843fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified integer value can be represented as the specified type.  <a href="namespacenn_1_1util.html#a82d03a923928589295b3070211843fd3">More...</a><br /></td></tr>
<tr class="separator:a82d03a923928589295b3070211843fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab723010d6f6c3b24dff210397f182b4c"><td class="memTemplParams" colspan="2">template&lt;int N, typename Tag &gt; </td></tr>
<tr class="memitem:ab723010d6f6c3b24dff210397f182b4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">BitFlagSet</a>&lt; N, Tag &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ab723010d6f6c3b24dff210397f182b4c">MakeBitFlagSet</a> () noexcept</td></tr>
<tr class="memdesc:ab723010d6f6c3b24dff210397f182b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <code><a class="el" href="structnn_1_1util_1_1_bit_flag_set.html" title="A type for handling a POD bit flag set.">BitFlagSet</a></code> with all bit flags initialized to <code>false</code>.  <a href="namespacenn_1_1util.html#ab723010d6f6c3b24dff210397f182b4c">More...</a><br /></td></tr>
<tr class="separator:ab723010d6f6c3b24dff210397f182b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac768464556e17a3023cc828247c64796"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:ac768464556e17a3023cc828247c64796"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">BitFlagSet</a>&lt; N, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ac768464556e17a3023cc828247c64796">MakeBitFlagSet</a> () noexcept</td></tr>
<tr class="memdesc:ac768464556e17a3023cc828247c64796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <code><a class="el" href="structnn_1_1util_1_1_bit_flag_set.html" title="A type for handling a POD bit flag set.">BitFlagSet</a></code> with all bit flags initialized to <code>false</code>.  <a href="namespacenn_1_1util.html#ac768464556e17a3023cc828247c64796">More...</a><br /></td></tr>
<tr class="separator:ac768464556e17a3023cc828247c64796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab479f53f9fa46369401ff30a75d072fd"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:ab479f53f9fa46369401ff30a75d072fd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ab479f53f9fa46369401ff30a75d072fd">MakeIFunction</a> (F f)</td></tr>
<tr class="memdesc:ab479f53f9fa46369401ff30a75d072fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an object whose base type is the <code>IFunction&lt;&gt;</code> corresponding to the specified callable object.  <a href="namespacenn_1_1util.html#ab479f53f9fa46369401ff30a75d072fd">More...</a><br /></td></tr>
<tr class="separator:ab479f53f9fa46369401ff30a75d072fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0cf8c9c361735e4387e4274f26660fb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ad0cf8c9c361735e4387e4274f26660fb">SNPrintf</a> (char *buffer, size_t bufferLength, const char *pFormat,...) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad0cf8c9c361735e4387e4274f26660fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats a string.  <a href="namespacenn_1_1util.html#ad0cf8c9c361735e4387e4274f26660fb">More...</a><br /></td></tr>
<tr class="separator:ad0cf8c9c361735e4387e4274f26660fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d6eacc0ce84cf0853a063c37552e88"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad9d6eacc0ce84cf0853a063c37552e88"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::underlying_type&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ad9d6eacc0ce84cf0853a063c37552e88">ToUnderlying</a> (T value) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad9d6eacc0ce84cf0853a063c37552e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts an enumerated type value to base type.  <a href="namespacenn_1_1util.html#ad9d6eacc0ce84cf0853a063c37552e88">More...</a><br /></td></tr>
<tr class="separator:ad9d6eacc0ce84cf0853a063c37552e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62a4cec7b8c5f53d70d0a69d45a5079"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:ae62a4cec7b8c5f53d70d0a69d45a5079"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ae62a4cec7b8c5f53d70d0a69d45a5079">TryAddWithoutOverflow</a> (Int *pOut, Int x, Int y) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae62a4cec7b8c5f53d70d0a69d45a5079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the addition operation (<code><em>x</em></code> + <code><em>y</em></code>) in an overflow-aware manner.  <a href="namespacenn_1_1util.html#ae62a4cec7b8c5f53d70d0a69d45a5079">More...</a><br /></td></tr>
<tr class="separator:ae62a4cec7b8c5f53d70d0a69d45a5079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49533de8b6f87a0e855283aa87334f7"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:ab49533de8b6f87a0e855283aa87334f7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ab49533de8b6f87a0e855283aa87334f7">TryMultiplyWithoutOverflow</a> (Int *pOut, Int x, Int y) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab49533de8b6f87a0e855283aa87334f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an integer multiplication operation (x * y) without an overflow.  <a href="namespacenn_1_1util.html#ab49533de8b6f87a0e855283aa87334f7">More...</a><br /></td></tr>
<tr class="separator:ab49533de8b6f87a0e855283aa87334f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba14e338904f3acfd3cc93ce1859c5f"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:abba14e338904f3acfd3cc93ce1859c5f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#abba14e338904f3acfd3cc93ce1859c5f">TrySubtractWithoutOverflow</a> (Int *pOut, Int x, Int y) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:abba14e338904f3acfd3cc93ce1859c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the subtraction operation (<code><em>x</em></code> – <code><em>y</em></code>) in an overflow-aware manner.  <a href="namespacenn_1_1util.html#abba14e338904f3acfd3cc93ce1859c5f">More...</a><br /></td></tr>
<tr class="separator:abba14e338904f3acfd3cc93ce1859c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1054c37da4a1d20fe6b0ca90a8ca351c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a1054c37da4a1d20fe6b0ca90a8ca351c">VFormatString</a> (<a class="el" href="namespacenn_1_1util.html#a1037da81cd878626e7a661798f94b873">FormatStringOutputFunction</a> pOutputFunction, uintptr_t outputFunctionArg, const char *pFormat, std::va_list formatArg) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1054c37da4a1d20fe6b0ca90a8ca351c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats a string.  <a href="namespacenn_1_1util.html#a1054c37da4a1d20fe6b0ca90a8ca351c">More...</a><br /></td></tr>
<tr class="separator:a1054c37da4a1d20fe6b0ca90a8ca351c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb19ebf42335aea1037895832e167857"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#afb19ebf42335aea1037895832e167857">VSNPrintf</a> (char *buffer, size_t bufferLength, const char *pFormat, std::va_list formatArg) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:afb19ebf42335aea1037895832e167857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats a string.  <a href="namespacenn_1_1util.html#afb19ebf42335aea1037895832e167857">More...</a><br /></td></tr>
<tr class="separator:afb19ebf42335aea1037895832e167857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Trigonometric Functions</div></td></tr>
<tr class="memitem:a97ebb4e1469d08a7f51a21147375949b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a97ebb4e1469d08a7f51a21147375949b">RadianToAngleIndex</a> (float radian) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a97ebb4e1469d08a7f51a21147375949b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an angle from radians to index representation.  <a href="namespacenn_1_1util.html#a97ebb4e1469d08a7f51a21147375949b">More...</a><br /></td></tr>
<tr class="separator:a97ebb4e1469d08a7f51a21147375949b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1e7f71d2c5b0551d7b8c735d83d6a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ade1e7f71d2c5b0551d7b8c735d83d6a3">DegreeToAngleIndex</a> (float degree) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ade1e7f71d2c5b0551d7b8c735d83d6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an angle from degrees to index representation.  <a href="namespacenn_1_1util.html#ade1e7f71d2c5b0551d7b8c735d83d6a3">More...</a><br /></td></tr>
<tr class="separator:ade1e7f71d2c5b0551d7b8c735d83d6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342713848fbb4ce6750da90d297bc824"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a342713848fbb4ce6750da90d297bc824">DegreeToRadian</a> (float degree) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a342713848fbb4ce6750da90d297bc824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an angle from degrees to radian representation.  <a href="namespacenn_1_1util.html#a342713848fbb4ce6750da90d297bc824">More...</a><br /></td></tr>
<tr class="separator:a342713848fbb4ce6750da90d297bc824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32747bc56d48f93666e0548ef312585"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ab32747bc56d48f93666e0548ef312585">RadianToDegree</a> (float radian) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab32747bc56d48f93666e0548ef312585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an angle from radian to degrees representation.  <a href="namespacenn_1_1util.html#ab32747bc56d48f93666e0548ef312585">More...</a><br /></td></tr>
<tr class="separator:ab32747bc56d48f93666e0548ef312585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b160179ea31b4eaf41284e73b925f6a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a6b160179ea31b4eaf41284e73b925f6a">AngleIndexToRadian</a> (<a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a> angleIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6b160179ea31b4eaf41284e73b925f6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an angle from index to radian representation.  <a href="namespacenn_1_1util.html#a6b160179ea31b4eaf41284e73b925f6a">More...</a><br /></td></tr>
<tr class="separator:a6b160179ea31b4eaf41284e73b925f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cc37b32cbeec92b9ad379e0e8a7a53"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a07cc37b32cbeec92b9ad379e0e8a7a53">AngleIndexToDegree</a> (<a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a> angleIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a07cc37b32cbeec92b9ad379e0e8a7a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an angle from index to degrees representation.  <a href="namespacenn_1_1util.html#a07cc37b32cbeec92b9ad379e0e8a7a53">More...</a><br /></td></tr>
<tr class="separator:a07cc37b32cbeec92b9ad379e0e8a7a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115590ce3ee8638bc4a1c7e561b58209"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a115590ce3ee8638bc4a1c7e561b58209">SinEst</a> (float radian) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a115590ce3ee8638bc4a1c7e561b58209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the sine value by polynomial approximation.  <a href="namespacenn_1_1util.html#a115590ce3ee8638bc4a1c7e561b58209">More...</a><br /></td></tr>
<tr class="separator:a115590ce3ee8638bc4a1c7e561b58209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd65f177dec24038d8e796993dd6f19"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#abdd65f177dec24038d8e796993dd6f19">SinTable</a> (<a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a> angleIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:abdd65f177dec24038d8e796993dd6f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the sine value by table lookup.  <a href="namespacenn_1_1util.html#abdd65f177dec24038d8e796993dd6f19">More...</a><br /></td></tr>
<tr class="separator:abdd65f177dec24038d8e796993dd6f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68268124ed7f0d8881db3fcebd01687f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a68268124ed7f0d8881db3fcebd01687f">CosEst</a> (float radian) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a68268124ed7f0d8881db3fcebd01687f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the cosine value by polynomial approximation.  <a href="namespacenn_1_1util.html#a68268124ed7f0d8881db3fcebd01687f">More...</a><br /></td></tr>
<tr class="separator:a68268124ed7f0d8881db3fcebd01687f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ba79c433fb71aa611fbead84b2c5a3"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a90ba79c433fb71aa611fbead84b2c5a3">CosTable</a> (<a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a> angleIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a90ba79c433fb71aa611fbead84b2c5a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the cosine value by table lookup.  <a href="namespacenn_1_1util.html#a90ba79c433fb71aa611fbead84b2c5a3">More...</a><br /></td></tr>
<tr class="separator:a90ba79c433fb71aa611fbead84b2c5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ba5bc072eae44853ce61976d55b001"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a32ba5bc072eae44853ce61976d55b001">SinCosEst</a> (float *pOutSin, float *pOutCos, float radian) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a32ba5bc072eae44853ce61976d55b001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the sine and cosine value by polynomial approximation.  <a href="namespacenn_1_1util.html#a32ba5bc072eae44853ce61976d55b001">More...</a><br /></td></tr>
<tr class="separator:a32ba5bc072eae44853ce61976d55b001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168e5f5b41ec5ecd60c6f88b6aea163e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a168e5f5b41ec5ecd60c6f88b6aea163e">SinCosTable</a> (float *pOutSin, float *pOutCos, <a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a> angleIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a168e5f5b41ec5ecd60c6f88b6aea163e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the sine and cosine value by table lookup.  <a href="namespacenn_1_1util.html#a168e5f5b41ec5ecd60c6f88b6aea163e">More...</a><br /></td></tr>
<tr class="separator:a168e5f5b41ec5ecd60c6f88b6aea163e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdc076bfbd01224d54074c1f312165b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a0cdc076bfbd01224d54074c1f312165b">TanEst</a> (float radian) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0cdc076bfbd01224d54074c1f312165b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the tangent value by polynomial approximation.  <a href="namespacenn_1_1util.html#a0cdc076bfbd01224d54074c1f312165b">More...</a><br /></td></tr>
<tr class="separator:a0cdc076bfbd01224d54074c1f312165b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ac3cee8ff11403595c42268db119ff"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ab8ac3cee8ff11403595c42268db119ff">TanTable</a> (<a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a> angleIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab8ac3cee8ff11403595c42268db119ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the tangent value by table lookup.  <a href="namespacenn_1_1util.html#ab8ac3cee8ff11403595c42268db119ff">More...</a><br /></td></tr>
<tr class="separator:ab8ac3cee8ff11403595c42268db119ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2699f371e3d783b78039ec8ac527de7b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a2699f371e3d783b78039ec8ac527de7b">AtanEst</a> (float x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2699f371e3d783b78039ec8ac527de7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the cotangent value by polynomial approximation.  <a href="namespacenn_1_1util.html#a2699f371e3d783b78039ec8ac527de7b">More...</a><br /></td></tr>
<tr class="separator:a2699f371e3d783b78039ec8ac527de7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f23a5881abd9cc0bea5d1373a5f11e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a1f23a5881abd9cc0bea5d1373a5f11e6">AtanTable</a> (float x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1f23a5881abd9cc0bea5d1373a5f11e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the cotangent value by table lookup.  <a href="namespacenn_1_1util.html#a1f23a5881abd9cc0bea5d1373a5f11e6">More...</a><br /></td></tr>
<tr class="separator:a1f23a5881abd9cc0bea5d1373a5f11e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7efae0dfa5a73c71deeadd9665477d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a0a7efae0dfa5a73c71deeadd9665477d">Atan2Est</a> (float y, float x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0a7efae0dfa5a73c71deeadd9665477d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the cotangent value by polynomial approximation.  <a href="namespacenn_1_1util.html#a0a7efae0dfa5a73c71deeadd9665477d">More...</a><br /></td></tr>
<tr class="separator:a0a7efae0dfa5a73c71deeadd9665477d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c57759e10ba45d38bb7377edd0115a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a9c57759e10ba45d38bb7377edd0115a3">Atan2Table</a> (float y, float x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9c57759e10ba45d38bb7377edd0115a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the cotangent value by table lookup.  <a href="namespacenn_1_1util.html#a9c57759e10ba45d38bb7377edd0115a3">More...</a><br /></td></tr>
<tr class="separator:a9c57759e10ba45d38bb7377edd0115a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c37527d1019f795ee78f5b51e9cd66"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a04c37527d1019f795ee78f5b51e9cd66">AsinEst</a> (float x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a04c37527d1019f795ee78f5b51e9cd66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the arctangent value by polynomial approximation.  <a href="namespacenn_1_1util.html#a04c37527d1019f795ee78f5b51e9cd66">More...</a><br /></td></tr>
<tr class="separator:a04c37527d1019f795ee78f5b51e9cd66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6f39eabcabdbeaed5c5eeecd012a81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aae6f39eabcabdbeaed5c5eeecd012a81">AsinTable</a> (float x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aae6f39eabcabdbeaed5c5eeecd012a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the arctangent value by table lookup.  <a href="namespacenn_1_1util.html#aae6f39eabcabdbeaed5c5eeecd012a81">More...</a><br /></td></tr>
<tr class="separator:aae6f39eabcabdbeaed5c5eeecd012a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69079f75685a291d46ba591ddb60bbd"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#af69079f75685a291d46ba591ddb60bbd">AcosEst</a> (float x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af69079f75685a291d46ba591ddb60bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the arccosine value by polynomial approximation.  <a href="namespacenn_1_1util.html#af69079f75685a291d46ba591ddb60bbd">More...</a><br /></td></tr>
<tr class="separator:af69079f75685a291d46ba591ddb60bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b10c3b5e379f2215fe0e65428e8543"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a13b10c3b5e379f2215fe0e65428e8543">AcosTable</a> (float x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a13b10c3b5e379f2215fe0e65428e8543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the arccosine value by table lookup.  <a href="namespacenn_1_1util.html#a13b10c3b5e379f2215fe0e65428e8543">More...</a><br /></td></tr>
<tr class="separator:a13b10c3b5e379f2215fe0e65428e8543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Math Utilities</div></td></tr>
<tr class="memitem:aee333695e4a66942a628f67d238c5fb3"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aee333695e4a66942a628f67d238c5fb3">Rcp</a> (float x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aee333695e4a66942a628f67d238c5fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the inverse.  <a href="namespacenn_1_1util.html#aee333695e4a66942a628f67d238c5fb3">More...</a><br /></td></tr>
<tr class="separator:aee333695e4a66942a628f67d238c5fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb31608117aba6428f8ad885f520594"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a6eb31608117aba6428f8ad885f520594"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a6eb31608117aba6428f8ad885f520594">RcpLowPrecision</a> (float x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6eb31608117aba6428f8ad885f520594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the inverse.  <a href="namespacenn_1_1util.html#a6eb31608117aba6428f8ad885f520594">More...</a><br /></td></tr>
<tr class="separator:a6eb31608117aba6428f8ad885f520594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2724ddb1495e6daec879773fdd3fe8"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a0c2724ddb1495e6daec879773fdd3fe8">Rsqrt</a> (float x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0c2724ddb1495e6daec879773fdd3fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the inverse of the square root.  <a href="namespacenn_1_1util.html#a0c2724ddb1495e6daec879773fdd3fe8">More...</a><br /></td></tr>
<tr class="separator:a0c2724ddb1495e6daec879773fdd3fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bcdeefaffc5e1034d28f7a0be702075"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a3bcdeefaffc5e1034d28f7a0be702075"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a3bcdeefaffc5e1034d28f7a0be702075">RsqrtLowPrecision</a> (float x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3bcdeefaffc5e1034d28f7a0be702075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the inverse of the square root Applies the correction the specified number of times.  <a href="namespacenn_1_1util.html#a3bcdeefaffc5e1034d28f7a0be702075">More...</a><br /></td></tr>
<tr class="separator:a3bcdeefaffc5e1034d28f7a0be702075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d2e581fa3899d8d501a038439df039"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a43d2e581fa3899d8d501a038439df039">AreEqualAbs</a> (float x, float y, float absError) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a43d2e581fa3899d8d501a038439df039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an equivalence test using an absolute error.  <a href="namespacenn_1_1util.html#a43d2e581fa3899d8d501a038439df039">More...</a><br /></td></tr>
<tr class="separator:a43d2e581fa3899d8d501a038439df039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2aa31b9b31c32958457d65f11b7987"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a7b2aa31b9b31c32958457d65f11b7987">AreEqualRelative</a> (float x, float y, float relativeError) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7b2aa31b9b31c32958457d65f11b7987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an equivalence test using relative error.  <a href="namespacenn_1_1util.html#a7b2aa31b9b31c32958457d65f11b7987">More...</a><br /></td></tr>
<tr class="separator:a7b2aa31b9b31c32958457d65f11b7987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41b86bc679691f454362ad06c268cb4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aa41b86bc679691f454362ad06c268cb4">AreEqual</a> (float x, float y, float error) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa41b86bc679691f454362ad06c268cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an equivalence test using absolute or relative error.  <a href="namespacenn_1_1util.html#aa41b86bc679691f454362ad06c268cb4">More...</a><br /></td></tr>
<tr class="separator:aa41b86bc679691f454362ad06c268cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Bit Operation Functions</div></td></tr>
<tr class="memitem:a442cc38c3c616eee03f1b66743376fa3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a442cc38c3c616eee03f1b66743376fa3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a442cc38c3c616eee03f1b66743376fa3">reverse_bits</a> (T x, int subword_bits=1, int num_swar_words=1) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a442cc38c3c616eee03f1b66743376fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Treats the value as a bit array and inverts the bit order.  <a href="namespacenn_1_1util.html#a442cc38c3c616eee03f1b66743376fa3">More...</a><br /></td></tr>
<tr class="separator:a442cc38c3c616eee03f1b66743376fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec88a4a55dad4af44a729577bb2798f9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec88a4a55dad4af44a729577bb2798f9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aec88a4a55dad4af44a729577bb2798f9">reverse_bytes</a> (T x, int subword_bytes=1, int num_swar_words=1) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aec88a4a55dad4af44a729577bb2798f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Treats the value as a byte array and inverts the byte order.  <a href="namespacenn_1_1util.html#aec88a4a55dad4af44a729577bb2798f9">More...</a><br /></td></tr>
<tr class="separator:aec88a4a55dad4af44a729577bb2798f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861c56e3f44d1b1d2cd238efffb5c566"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a861c56e3f44d1b1d2cd238efffb5c566"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a861c56e3f44d1b1d2cd238efffb5c566">is_aligned</a> (T x, size_t align) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a861c56e3f44d1b1d2cd238efffb5c566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the value fits the specified alignment.  <a href="namespacenn_1_1util.html#a861c56e3f44d1b1d2cd238efffb5c566">More...</a><br /></td></tr>
<tr class="separator:a861c56e3f44d1b1d2cd238efffb5c566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275a3c89db5d0ab915559d8a85f9cbdd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a275a3c89db5d0ab915559d8a85f9cbdd"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a275a3c89db5d0ab915559d8a85f9cbdd">align_up</a> (T x, size_t align) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a275a3c89db5d0ab915559d8a85f9cbdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds up a value so that it fits the specified alignment.  <a href="namespacenn_1_1util.html#a275a3c89db5d0ab915559d8a85f9cbdd">More...</a><br /></td></tr>
<tr class="separator:a275a3c89db5d0ab915559d8a85f9cbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7655ccdb1f67a75ae553c06dec485b3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac7655ccdb1f67a75ae553c06dec485b3"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ac7655ccdb1f67a75ae553c06dec485b3">align_down</a> (T x, size_t align) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac7655ccdb1f67a75ae553c06dec485b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds down a value so that it fits the specified alignment.  <a href="namespacenn_1_1util.html#ac7655ccdb1f67a75ae553c06dec485b3">More...</a><br /></td></tr>
<tr class="separator:ac7655ccdb1f67a75ae553c06dec485b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb809a8e954ba2fc39656ecae6678a9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2eb809a8e954ba2fc39656ecae6678a9"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a2eb809a8e954ba2fc39656ecae6678a9">rstls1b</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2eb809a8e954ba2fc39656ecae6678a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns the least significant 1 bit off.  <a href="namespacenn_1_1util.html#a2eb809a8e954ba2fc39656ecae6678a9">More...</a><br /></td></tr>
<tr class="separator:a2eb809a8e954ba2fc39656ecae6678a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8866603a7784a4f22e559dd68000b1d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac8866603a7784a4f22e559dd68000b1d"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ac8866603a7784a4f22e559dd68000b1d">setls0b</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac8866603a7784a4f22e559dd68000b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns the least significant 0 bit on.  <a href="namespacenn_1_1util.html#ac8866603a7784a4f22e559dd68000b1d">More...</a><br /></td></tr>
<tr class="separator:ac8866603a7784a4f22e559dd68000b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176ee70c2615c58d6d847f799d09d269"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a176ee70c2615c58d6d847f799d09d269"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a176ee70c2615c58d6d847f799d09d269">rstt1</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a176ee70c2615c58d6d847f799d09d269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns the least significant contiguous 1 bits off.  <a href="namespacenn_1_1util.html#a176ee70c2615c58d6d847f799d09d269">More...</a><br /></td></tr>
<tr class="separator:a176ee70c2615c58d6d847f799d09d269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9afe44169cc12424c76a39802f7466c2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9afe44169cc12424c76a39802f7466c2"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a9afe44169cc12424c76a39802f7466c2">sett0</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9afe44169cc12424c76a39802f7466c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns the least significant contiguous 0 bits on.  <a href="namespacenn_1_1util.html#a9afe44169cc12424c76a39802f7466c2">More...</a><br /></td></tr>
<tr class="separator:a9afe44169cc12424c76a39802f7466c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84ef386689dc5a13122b41e5e98ddfb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae84ef386689dc5a13122b41e5e98ddfb"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ae84ef386689dc5a13122b41e5e98ddfb">isols1b</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae84ef386689dc5a13122b41e5e98ddfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the least significant 1 bit.  <a href="namespacenn_1_1util.html#ae84ef386689dc5a13122b41e5e98ddfb">More...</a><br /></td></tr>
<tr class="separator:ae84ef386689dc5a13122b41e5e98ddfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8365af3d7513b7f0722e3e8cb7914fc9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8365af3d7513b7f0722e3e8cb7914fc9"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a8365af3d7513b7f0722e3e8cb7914fc9">isols0b</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8365af3d7513b7f0722e3e8cb7914fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the least significant 0 bit.  <a href="namespacenn_1_1util.html#a8365af3d7513b7f0722e3e8cb7914fc9">More...</a><br /></td></tr>
<tr class="separator:a8365af3d7513b7f0722e3e8cb7914fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e94fbf3801cdcc9b0858fa47da13ff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab8e94fbf3801cdcc9b0858fa47da13ff"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ab8e94fbf3801cdcc9b0858fa47da13ff">maskt1</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab8e94fbf3801cdcc9b0858fa47da13ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the least significant contiguous 1 bits.  <a href="namespacenn_1_1util.html#ab8e94fbf3801cdcc9b0858fa47da13ff">More...</a><br /></td></tr>
<tr class="separator:ab8e94fbf3801cdcc9b0858fa47da13ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e78c1e6a9d8e1762feee41e8d371fae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9e78c1e6a9d8e1762feee41e8d371fae"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a9e78c1e6a9d8e1762feee41e8d371fae">maskt0</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9e78c1e6a9d8e1762feee41e8d371fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the least significant contiguous 0 bits.  <a href="namespacenn_1_1util.html#a9e78c1e6a9d8e1762feee41e8d371fae">More...</a><br /></td></tr>
<tr class="separator:a9e78c1e6a9d8e1762feee41e8d371fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4a7f29daa34673f422f59dd5676d61"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5c4a7f29daa34673f422f59dd5676d61"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a5c4a7f29daa34673f422f59dd5676d61">maskt1ls0b</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5c4a7f29daa34673f422f59dd5676d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the least significant contiguous 0 bits and the least significant 1 bit.  <a href="namespacenn_1_1util.html#a5c4a7f29daa34673f422f59dd5676d61">More...</a><br /></td></tr>
<tr class="separator:a5c4a7f29daa34673f422f59dd5676d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a877edfa35460f2ee3ee65e7c5ebef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a20a877edfa35460f2ee3ee65e7c5ebef"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a20a877edfa35460f2ee3ee65e7c5ebef">maskt0ls1b</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a20a877edfa35460f2ee3ee65e7c5ebef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the least significant contiguous 0 bits and the least significant 1 bit.  <a href="namespacenn_1_1util.html#a20a877edfa35460f2ee3ee65e7c5ebef">More...</a><br /></td></tr>
<tr class="separator:a20a877edfa35460f2ee3ee65e7c5ebef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4261256ed6137be521e732071fb8b85c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4261256ed6137be521e732071fb8b85c"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a4261256ed6137be521e732071fb8b85c">popcount</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4261256ed6137be521e732071fb8b85c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of 1 bits.  <a href="namespacenn_1_1util.html#a4261256ed6137be521e732071fb8b85c">More...</a><br /></td></tr>
<tr class="separator:a4261256ed6137be521e732071fb8b85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09155ce274d53c9d706169219629cee4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a09155ce274d53c9d706169219629cee4"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a09155ce274d53c9d706169219629cee4">cntl0</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a09155ce274d53c9d706169219629cee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of contiguous bits set to <code>0</code>, starting from the most significant bit (MSB).  <a href="namespacenn_1_1util.html#a09155ce274d53c9d706169219629cee4">More...</a><br /></td></tr>
<tr class="separator:a09155ce274d53c9d706169219629cee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4642bc633f78d038517013a18982c8ff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4642bc633f78d038517013a18982c8ff"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a4642bc633f78d038517013a18982c8ff">cntt0</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4642bc633f78d038517013a18982c8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of contiguous bits set to <code>0</code>, starting from the least significant bit (LSB).  <a href="namespacenn_1_1util.html#a4642bc633f78d038517013a18982c8ff">More...</a><br /></td></tr>
<tr class="separator:a4642bc633f78d038517013a18982c8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4feb9f54abaf03efac1882558b18124"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad4feb9f54abaf03efac1882558b18124"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ad4feb9f54abaf03efac1882558b18124">ispow2</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad4feb9f54abaf03efac1882558b18124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified value is a power of two.  <a href="namespacenn_1_1util.html#ad4feb9f54abaf03efac1882558b18124">More...</a><br /></td></tr>
<tr class="separator:ad4feb9f54abaf03efac1882558b18124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860cd0664ce80ad4e4e35216bbd6d730"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a860cd0664ce80ad4e4e35216bbd6d730"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a860cd0664ce80ad4e4e35216bbd6d730">floorp2</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a860cd0664ce80ad4e4e35216bbd6d730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the largest power of two that is less than the specified value.  <a href="namespacenn_1_1util.html#a860cd0664ce80ad4e4e35216bbd6d730">More...</a><br /></td></tr>
<tr class="separator:a860cd0664ce80ad4e4e35216bbd6d730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015b53fd16251a5c66d7ccd4311fb271"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a015b53fd16251a5c66d7ccd4311fb271"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a015b53fd16251a5c66d7ccd4311fb271">ceilp2</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a015b53fd16251a5c66d7ccd4311fb271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the smallest power of two that is greater than the specified value.  <a href="namespacenn_1_1util.html#a015b53fd16251a5c66d7ccd4311fb271">More...</a><br /></td></tr>
<tr class="separator:a015b53fd16251a5c66d7ccd4311fb271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd03e3714423c80630b178f82d9d66b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a2bd03e3714423c80630b178f82d9d66b"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a2bd03e3714423c80630b178f82d9d66b">DivideUp</a> (T x, U divider) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2bd03e3714423c80630b178f82d9d66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds up the value and divides the value by the specified value.  <a href="namespacenn_1_1util.html#a2bd03e3714423c80630b178f82d9d66b">More...</a><br /></td></tr>
<tr class="separator:a2bd03e3714423c80630b178f82d9d66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Text Encoding Conversion</div></td></tr>
<tr class="memitem:ac299aadfc2d647eddfb7b48a002497d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ac299aadfc2d647eddfb7b48a002497d4">ConvertStringUtf8ToUtf16Native</a> (uint16_t *pDst, int dstLength, const char *pSrc, int srcLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac299aadfc2d647eddfb7b48a002497d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from UTF-8 to UTF-16.  <a href="namespacenn_1_1util.html#ac299aadfc2d647eddfb7b48a002497d4">More...</a><br /></td></tr>
<tr class="separator:ac299aadfc2d647eddfb7b48a002497d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a92f19acba9dae9f4320f851f806a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a88a92f19acba9dae9f4320f851f806a6">ConvertStringUtf8ToUtf16Native</a> (char16_t *pDst, int dstLength, const char *pSrc, int srcLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a88a92f19acba9dae9f4320f851f806a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from UTF-8 to UTF-16.  <a href="namespacenn_1_1util.html#a88a92f19acba9dae9f4320f851f806a6">More...</a><br /></td></tr>
<tr class="separator:a88a92f19acba9dae9f4320f851f806a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6dd6d63f9069c568f4f9e0a41171c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#acb6dd6d63f9069c568f4f9e0a41171c2">ConvertStringUtf8ToUtf16Native</a> (uint16_t *pDst, int dstLength, const char *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acb6dd6d63f9069c568f4f9e0a41171c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from UTF-8 to UTF-16.  <a href="namespacenn_1_1util.html#acb6dd6d63f9069c568f4f9e0a41171c2">More...</a><br /></td></tr>
<tr class="separator:acb6dd6d63f9069c568f4f9e0a41171c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97139df706fd2cd0c3a8ce755937bc24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a97139df706fd2cd0c3a8ce755937bc24">ConvertStringUtf8ToUtf16Native</a> (char16_t *pDst, int dstLength, const char *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a97139df706fd2cd0c3a8ce755937bc24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from UTF-8 to UTF-16.  <a href="namespacenn_1_1util.html#a97139df706fd2cd0c3a8ce755937bc24">More...</a><br /></td></tr>
<tr class="separator:a97139df706fd2cd0c3a8ce755937bc24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7633254c8910e4e0b191121feddd95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a0f7633254c8910e4e0b191121feddd95">ConvertStringUtf16NativeToUtf8</a> (char *pDst, int dstLength, const uint16_t *pSrc, int srcLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0f7633254c8910e4e0b191121feddd95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from UTF-16 to UTF-8.  <a href="namespacenn_1_1util.html#a0f7633254c8910e4e0b191121feddd95">More...</a><br /></td></tr>
<tr class="separator:a0f7633254c8910e4e0b191121feddd95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0fb7f6e5c70fe4ffab9b7c891631c59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ac0fb7f6e5c70fe4ffab9b7c891631c59">ConvertStringUtf16NativeToUtf8</a> (char *pDst, int dstLength, const char16_t *pSrc, int srcLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac0fb7f6e5c70fe4ffab9b7c891631c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from UTF-16 to UTF-8.  <a href="namespacenn_1_1util.html#ac0fb7f6e5c70fe4ffab9b7c891631c59">More...</a><br /></td></tr>
<tr class="separator:ac0fb7f6e5c70fe4ffab9b7c891631c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0256928bab392ea72f8d15e3ec6efb7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a0256928bab392ea72f8d15e3ec6efb7f">ConvertStringUtf16NativeToUtf8</a> (char *pDst, int dstLength, const uint16_t *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0256928bab392ea72f8d15e3ec6efb7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from UTF-16 to UTF-8.  <a href="namespacenn_1_1util.html#a0256928bab392ea72f8d15e3ec6efb7f">More...</a><br /></td></tr>
<tr class="separator:a0256928bab392ea72f8d15e3ec6efb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64657a9f5c8c791f28227cca1ed94adc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a64657a9f5c8c791f28227cca1ed94adc">ConvertStringUtf16NativeToUtf8</a> (char *pDst, int dstLength, const char16_t *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a64657a9f5c8c791f28227cca1ed94adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from UTF-16 to UTF-8.  <a href="namespacenn_1_1util.html#a64657a9f5c8c791f28227cca1ed94adc">More...</a><br /></td></tr>
<tr class="separator:a64657a9f5c8c791f28227cca1ed94adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c6fd4c3ccbb9129b10e6f2f9bed339"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a05c6fd4c3ccbb9129b10e6f2f9bed339">GetLengthOfConvertedStringUtf8ToUtf16Native</a> (int *pOutLength, const char *pSrc, int srcLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a05c6fd4c3ccbb9129b10e6f2f9bed339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the length of a conversion result array necessary for conversion from UTF-8 to UTF-16.  <a href="namespacenn_1_1util.html#a05c6fd4c3ccbb9129b10e6f2f9bed339">More...</a><br /></td></tr>
<tr class="separator:a05c6fd4c3ccbb9129b10e6f2f9bed339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3722383bf1e035087c9705999921063d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a3722383bf1e035087c9705999921063d">GetLengthOfConvertedStringUtf8ToUtf16Native</a> (int *pOutLength, const char *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3722383bf1e035087c9705999921063d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the length of a conversion result array necessary for conversion from UTF-8 to UTF-16.  <a href="namespacenn_1_1util.html#a3722383bf1e035087c9705999921063d">More...</a><br /></td></tr>
<tr class="separator:a3722383bf1e035087c9705999921063d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdffba72eb466818e238d6ebb53b0dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a1fdffba72eb466818e238d6ebb53b0dc">GetLengthOfConvertedStringUtf16NativeToUtf8</a> (int *pOutLength, const uint16_t *pSrc, int srcLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1fdffba72eb466818e238d6ebb53b0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the length of a conversion result array necessary for conversion from UTF-16 to UTF-8.  <a href="namespacenn_1_1util.html#a1fdffba72eb466818e238d6ebb53b0dc">More...</a><br /></td></tr>
<tr class="separator:a1fdffba72eb466818e238d6ebb53b0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe7be5c20e746d26c8c86b622b26970"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a0fe7be5c20e746d26c8c86b622b26970">GetLengthOfConvertedStringUtf16NativeToUtf8</a> (int *pOutLength, const char16_t *pSrc, int srcLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0fe7be5c20e746d26c8c86b622b26970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the length of a conversion result array necessary for conversion from UTF-16 to UTF-8.  <a href="namespacenn_1_1util.html#a0fe7be5c20e746d26c8c86b622b26970">More...</a><br /></td></tr>
<tr class="separator:a0fe7be5c20e746d26c8c86b622b26970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4f67839157ed13cea7790274ef9159"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a8d4f67839157ed13cea7790274ef9159">GetLengthOfConvertedStringUtf16NativeToUtf8</a> (int *pOutLength, const uint16_t *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8d4f67839157ed13cea7790274ef9159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the length of a conversion result array necessary for conversion from UTF-16 to UTF-8.  <a href="namespacenn_1_1util.html#a8d4f67839157ed13cea7790274ef9159">More...</a><br /></td></tr>
<tr class="separator:a8d4f67839157ed13cea7790274ef9159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663506d271287d754a734254fbc75470"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a663506d271287d754a734254fbc75470">GetLengthOfConvertedStringUtf16NativeToUtf8</a> (int *pOutLength, const char16_t *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a663506d271287d754a734254fbc75470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the length of a conversion result array necessary for conversion from UTF-16 to UTF-8.  <a href="namespacenn_1_1util.html#a663506d271287d754a734254fbc75470">More...</a><br /></td></tr>
<tr class="separator:a663506d271287d754a734254fbc75470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eec880cf5a71dfc8c3f4e0d7d8f2b4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a0eec880cf5a71dfc8c3f4e0d7d8f2b4f">ConvertStringUtf8ToUtf32</a> (uint32_t *pDst, int dstLength, const char *pSrc, int srcLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0eec880cf5a71dfc8c3f4e0d7d8f2b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from UTF-8 to UTF-32.  <a href="namespacenn_1_1util.html#a0eec880cf5a71dfc8c3f4e0d7d8f2b4f">More...</a><br /></td></tr>
<tr class="separator:a0eec880cf5a71dfc8c3f4e0d7d8f2b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bdd2e92a6e03988b48744a44f0b2d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a94bdd2e92a6e03988b48744a44f0b2d4">ConvertStringUtf8ToUtf32</a> (char32_t *pDst, int dstLength, const char *pSrc, int srcLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a94bdd2e92a6e03988b48744a44f0b2d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from UTF-8 to UTF-32.  <a href="namespacenn_1_1util.html#a94bdd2e92a6e03988b48744a44f0b2d4">More...</a><br /></td></tr>
<tr class="separator:a94bdd2e92a6e03988b48744a44f0b2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420f497d6459647978b4fe9c04f654b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a420f497d6459647978b4fe9c04f654b9">ConvertStringUtf8ToUtf32</a> (uint32_t *pDst, int dstLength, const char *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a420f497d6459647978b4fe9c04f654b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from UTF-8 to UTF-32.  <a href="namespacenn_1_1util.html#a420f497d6459647978b4fe9c04f654b9">More...</a><br /></td></tr>
<tr class="separator:a420f497d6459647978b4fe9c04f654b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01449386a421139fb3e5701c7830392c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a01449386a421139fb3e5701c7830392c">ConvertStringUtf8ToUtf32</a> (char32_t *pDst, int dstLength, const char *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a01449386a421139fb3e5701c7830392c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from UTF-8 to UTF-32.  <a href="namespacenn_1_1util.html#a01449386a421139fb3e5701c7830392c">More...</a><br /></td></tr>
<tr class="separator:a01449386a421139fb3e5701c7830392c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b7a0702ee0d55a13723e23d44cb408"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a86b7a0702ee0d55a13723e23d44cb408">ConvertStringUtf32ToUtf8</a> (char *pDst, int dstLength, const uint32_t *pSrc, int srcLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a86b7a0702ee0d55a13723e23d44cb408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from UTF-32 to UTF-8.  <a href="namespacenn_1_1util.html#a86b7a0702ee0d55a13723e23d44cb408">More...</a><br /></td></tr>
<tr class="separator:a86b7a0702ee0d55a13723e23d44cb408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d150d70e6129b98681547bad34f528"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a11d150d70e6129b98681547bad34f528">ConvertStringUtf32ToUtf8</a> (char *pDst, int dstLength, const char32_t *pSrc, int srcLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a11d150d70e6129b98681547bad34f528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from UTF-32 to UTF-8.  <a href="namespacenn_1_1util.html#a11d150d70e6129b98681547bad34f528">More...</a><br /></td></tr>
<tr class="separator:a11d150d70e6129b98681547bad34f528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de5dec6adb8e4760e49502991983e7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a6de5dec6adb8e4760e49502991983e7b">ConvertStringUtf32ToUtf8</a> (char *pDst, int dstLength, const uint32_t *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6de5dec6adb8e4760e49502991983e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from UTF-32 to UTF-8.  <a href="namespacenn_1_1util.html#a6de5dec6adb8e4760e49502991983e7b">More...</a><br /></td></tr>
<tr class="separator:a6de5dec6adb8e4760e49502991983e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb941ac26afd099e06988f32df6418c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aacb941ac26afd099e06988f32df6418c">ConvertStringUtf32ToUtf8</a> (char *pDst, int dstLength, const char32_t *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aacb941ac26afd099e06988f32df6418c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from UTF-32 to UTF-8.  <a href="namespacenn_1_1util.html#aacb941ac26afd099e06988f32df6418c">More...</a><br /></td></tr>
<tr class="separator:aacb941ac26afd099e06988f32df6418c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42be4f290225031ea8dafefed8571c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aa42be4f290225031ea8dafefed8571c5">GetLengthOfConvertedStringUtf8ToUtf32</a> (int *pOutLength, const char *pSrc, int srcLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa42be4f290225031ea8dafefed8571c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the length of a conversion result array necessary for conversion from UTF-8 to UTF-32.  <a href="namespacenn_1_1util.html#aa42be4f290225031ea8dafefed8571c5">More...</a><br /></td></tr>
<tr class="separator:aa42be4f290225031ea8dafefed8571c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2095df7e200b19b396b87856c884ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a1d2095df7e200b19b396b87856c884ac">GetLengthOfConvertedStringUtf8ToUtf32</a> (int *pOutLength, const char *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1d2095df7e200b19b396b87856c884ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the length of a conversion result array necessary for conversion from UTF-8 to UTF-32.  <a href="namespacenn_1_1util.html#a1d2095df7e200b19b396b87856c884ac">More...</a><br /></td></tr>
<tr class="separator:a1d2095df7e200b19b396b87856c884ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7245d2828f892a9cd8f9fd95f48370a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a7245d2828f892a9cd8f9fd95f48370a8">GetLengthOfConvertedStringUtf32ToUtf8</a> (int *pOutLength, const uint32_t *pSrc, int srcLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7245d2828f892a9cd8f9fd95f48370a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the length of a conversion result array necessary for conversion from UTF-32 to UTF-8.  <a href="namespacenn_1_1util.html#a7245d2828f892a9cd8f9fd95f48370a8">More...</a><br /></td></tr>
<tr class="separator:a7245d2828f892a9cd8f9fd95f48370a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8ee9328e7adbbd05e11b2dbbfaf5aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#abe8ee9328e7adbbd05e11b2dbbfaf5aa">GetLengthOfConvertedStringUtf32ToUtf8</a> (int *pOutLength, const char32_t *pSrc, int srcLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:abe8ee9328e7adbbd05e11b2dbbfaf5aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the length of a conversion result array necessary for conversion from UTF-32 to UTF-8.  <a href="namespacenn_1_1util.html#abe8ee9328e7adbbd05e11b2dbbfaf5aa">More...</a><br /></td></tr>
<tr class="separator:abe8ee9328e7adbbd05e11b2dbbfaf5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68dd5a2f5c5ddfbb416ea6f6f434f7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ad68dd5a2f5c5ddfbb416ea6f6f434f7c">GetLengthOfConvertedStringUtf32ToUtf8</a> (int *pOutLength, const uint32_t *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad68dd5a2f5c5ddfbb416ea6f6f434f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the length of a conversion result array necessary for conversion from UTF-32 to UTF-8.  <a href="namespacenn_1_1util.html#ad68dd5a2f5c5ddfbb416ea6f6f434f7c">More...</a><br /></td></tr>
<tr class="separator:ad68dd5a2f5c5ddfbb416ea6f6f434f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93876bebf406297e7b8422d8eaf6c2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#af93876bebf406297e7b8422d8eaf6c2f">GetLengthOfConvertedStringUtf32ToUtf8</a> (int *pOutLength, const char32_t *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af93876bebf406297e7b8422d8eaf6c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the length of a conversion result array necessary for conversion from UTF-32 to UTF-8.  <a href="namespacenn_1_1util.html#af93876bebf406297e7b8422d8eaf6c2f">More...</a><br /></td></tr>
<tr class="separator:af93876bebf406297e7b8422d8eaf6c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c37393525e5cd94e22abe476c261c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ae3c37393525e5cd94e22abe476c261c9">ConvertCharacterUtf8ToUtf16Native</a> (uint16_t *pDst, const char *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae3c37393525e5cd94e22abe476c261c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a single character from UTF-8 to UTF-16.  <a href="namespacenn_1_1util.html#ae3c37393525e5cd94e22abe476c261c9">More...</a><br /></td></tr>
<tr class="separator:ae3c37393525e5cd94e22abe476c261c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883fcd9c7fee7e390cc8039f175f7d81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a883fcd9c7fee7e390cc8039f175f7d81">ConvertCharacterUtf8ToUtf16Native</a> (char16_t *pDst, const char *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a883fcd9c7fee7e390cc8039f175f7d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a single character from UTF-8 to UTF-16.  <a href="namespacenn_1_1util.html#a883fcd9c7fee7e390cc8039f175f7d81">More...</a><br /></td></tr>
<tr class="separator:a883fcd9c7fee7e390cc8039f175f7d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac706453bef5ce6867499d41bff823a0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ac706453bef5ce6867499d41bff823a0b">ConvertCharacterUtf16NativeToUtf8</a> (char *pDst, const uint16_t *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac706453bef5ce6867499d41bff823a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a single character from UTF-16 to UTF-8.  <a href="namespacenn_1_1util.html#ac706453bef5ce6867499d41bff823a0b">More...</a><br /></td></tr>
<tr class="separator:ac706453bef5ce6867499d41bff823a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8357717235709d3c38484e0a0eec89ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a8357717235709d3c38484e0a0eec89ed">ConvertCharacterUtf16NativeToUtf8</a> (char *pDst, const char16_t *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8357717235709d3c38484e0a0eec89ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a single character from UTF-16 to UTF-8.  <a href="namespacenn_1_1util.html#a8357717235709d3c38484e0a0eec89ed">More...</a><br /></td></tr>
<tr class="separator:a8357717235709d3c38484e0a0eec89ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec102fea3e52b0d8ec9ce743f3156dd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aec102fea3e52b0d8ec9ce743f3156dd6">ConvertCharacterUtf8ToUtf32</a> (uint32_t *pDst, const char *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aec102fea3e52b0d8ec9ce743f3156dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a single character from UTF-8 to UTF-32.  <a href="namespacenn_1_1util.html#aec102fea3e52b0d8ec9ce743f3156dd6">More...</a><br /></td></tr>
<tr class="separator:aec102fea3e52b0d8ec9ce743f3156dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633fedda1fc644c208cec4de6d2d619a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a633fedda1fc644c208cec4de6d2d619a">ConvertCharacterUtf8ToUtf32</a> (char32_t *pDst, const char *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a633fedda1fc644c208cec4de6d2d619a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a single character from UTF-8 to UTF-32.  <a href="namespacenn_1_1util.html#a633fedda1fc644c208cec4de6d2d619a">More...</a><br /></td></tr>
<tr class="separator:a633fedda1fc644c208cec4de6d2d619a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af955318b43cb855889cfce8799ae61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a8af955318b43cb855889cfce8799ae61">ConvertCharacterUtf32ToUtf8</a> (char *pDst, uint32_t src) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8af955318b43cb855889cfce8799ae61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a single character from UTF-32 to UTF-8.  <a href="namespacenn_1_1util.html#a8af955318b43cb855889cfce8799ae61">More...</a><br /></td></tr>
<tr class="separator:a8af955318b43cb855889cfce8799ae61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad163f7a39131c5a224ddb3e09050243"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aad163f7a39131c5a224ddb3e09050243">ConvertCharacterUtf32ToUtf8</a> (char *pDst, char32_t src) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aad163f7a39131c5a224ddb3e09050243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a single character from UTF-32 to UTF-8.  <a href="namespacenn_1_1util.html#aad163f7a39131c5a224ddb3e09050243">More...</a><br /></td></tr>
<tr class="separator:aad163f7a39131c5a224ddb3e09050243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae443a8ae5dbbb92d7f03fb2fba373ea3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ae443a8ae5dbbb92d7f03fb2fba373ea3">PickOutCharacterFromUtf8String</a> (char *pChar, const char **pStr) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae443a8ae5dbbb92d7f03fb2fba373ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a single character from a UTF-8 string and increments the pointer.  <a href="namespacenn_1_1util.html#ae443a8ae5dbbb92d7f03fb2fba373ea3">More...</a><br /></td></tr>
<tr class="separator:ae443a8ae5dbbb92d7f03fb2fba373ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Compression Sample</div></td></tr>
<tr class="memitem:ae0290996b2f08a558763e919ca74fd0f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ae0290996b2f08a558763e919ca74fd0f">CompressZlib</a> (size_t *pOutSize, void *pDst, size_t dstSize, const void *pSrc, size_t srcSize, void *pWork, size_t workSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae0290996b2f08a558763e919ca74fd0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs <code>deflate</code> compression in <code>zlib</code> format.  <a href="namespacenn_1_1util.html#ae0290996b2f08a558763e919ca74fd0f">More...</a><br /></td></tr>
<tr class="separator:ae0290996b2f08a558763e919ca74fd0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a092e78b92cadba899c2abbc486f899"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a9a092e78b92cadba899c2abbc486f899">CompressZlib</a> (size_t *pOutSize, void *pDst, size_t dstSize, const void *pSrc, size_t srcSize, void *pWork, size_t workSize, int memLevel, int compressionLevel) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9a092e78b92cadba899c2abbc486f899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs <code>deflate</code> compression in <code>zlib</code> format with the specified compression level and memory usage level.  <a href="namespacenn_1_1util.html#a9a092e78b92cadba899c2abbc486f899">More...</a><br /></td></tr>
<tr class="separator:a9a092e78b92cadba899c2abbc486f899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eaf5623ce101256fc619f5b5a03491c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a1eaf5623ce101256fc619f5b5a03491c">CompressGzip</a> (size_t *pOutSize, void *pDst, size_t dstSize, const void *pSrc, size_t srcSize, void *pWork, size_t workSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1eaf5623ce101256fc619f5b5a03491c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs <code>deflate</code> compression in <code>Gzip</code> format.  <a href="namespacenn_1_1util.html#a1eaf5623ce101256fc619f5b5a03491c">More...</a><br /></td></tr>
<tr class="separator:a1eaf5623ce101256fc619f5b5a03491c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda6da1a7c7bb62667781877ec8521a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#abda6da1a7c7bb62667781877ec8521a9">CompressGzip</a> (size_t *pOutSize, void *pDst, size_t dstSize, const void *pSrc, size_t srcSize, void *pWork, size_t workSize, int memLevel, int compressionLevel) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:abda6da1a7c7bb62667781877ec8521a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs <code>deflate</code> compression in <code>gzip</code> format with the specified compression level and memory usage level.  <a href="namespacenn_1_1util.html#abda6da1a7c7bb62667781877ec8521a9">More...</a><br /></td></tr>
<tr class="separator:abda6da1a7c7bb62667781877ec8521a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394f55bc3df26d704f0fa46644aeee07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a394f55bc3df26d704f0fa46644aeee07">CompressDeflate</a> (size_t *pOutSize, void *pDst, size_t dstSize, const void *pSrc, size_t srcSize, void *pWork, size_t workSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a394f55bc3df26d704f0fa46644aeee07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs <code>deflate</code> compression in <code>raw deflate</code> format.  <a href="namespacenn_1_1util.html#a394f55bc3df26d704f0fa46644aeee07">More...</a><br /></td></tr>
<tr class="separator:a394f55bc3df26d704f0fa46644aeee07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d02db25df3c786d3b84160a71a4ca4c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a0d02db25df3c786d3b84160a71a4ca4c">CompressDeflate</a> (size_t *pOutSize, void *pDst, size_t dstSize, const void *pSrc, size_t srcSize, void *pWork, size_t workSize, int memLevel, int compressionLevel) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0d02db25df3c786d3b84160a71a4ca4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs <code>deflate</code> compression in <code>raw deflate</code> format with the specified compression level and memory usage level.  <a href="namespacenn_1_1util.html#a0d02db25df3c786d3b84160a71a4ca4c">More...</a><br /></td></tr>
<tr class="separator:a0d02db25df3c786d3b84160a71a4ca4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Decompression</div></td></tr>
<tr class="memitem:af08749f6d24d2bf7d577a253fa2d3c59"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#af08749f6d24d2bf7d577a253fa2d3c59">GetGzipDecompressedSize</a> (const void *pSrc, size_t srcSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af08749f6d24d2bf7d577a253fa2d3c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the precompression size of data compressed in <code>gzip</code> format.  <a href="namespacenn_1_1util.html#af08749f6d24d2bf7d577a253fa2d3c59">More...</a><br /></td></tr>
<tr class="separator:af08749f6d24d2bf7d577a253fa2d3c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef5750312d89f54f3e11496c3414ef7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a5ef5750312d89f54f3e11496c3414ef7">DecompressZlib</a> (void *pDst, size_t dstSize, const void *pSrc, size_t srcSize, void *pWork, size_t workSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5ef5750312d89f54f3e11496c3414ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs <code>deflate</code> decompression in <code>zlib</code> format.  <a href="namespacenn_1_1util.html#a5ef5750312d89f54f3e11496c3414ef7">More...</a><br /></td></tr>
<tr class="separator:a5ef5750312d89f54f3e11496c3414ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0dd598671e1a5e68b15f48e4b02045"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a8d0dd598671e1a5e68b15f48e4b02045">DecompressGzip</a> (void *pDst, size_t dstSize, const void *pSrc, size_t srcSize, void *pWork, size_t workSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8d0dd598671e1a5e68b15f48e4b02045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs <code>deflate</code> decompression in <code>Gzip</code> format.  <a href="namespacenn_1_1util.html#a8d0dd598671e1a5e68b15f48e4b02045">More...</a><br /></td></tr>
<tr class="separator:a8d0dd598671e1a5e68b15f48e4b02045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24276fbb8f0d3892fdd9b076078d690"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aa24276fbb8f0d3892fdd9b076078d690">DecompressDeflate</a> (void *pDst, size_t dstSize, const void *pSrc, size_t srcSize, void *pWork, size_t workSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa24276fbb8f0d3892fdd9b076078d690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs <code>deflate</code> decompression in <code>raw deflate</code> format.  <a href="namespacenn_1_1util.html#aa24276fbb8f0d3892fdd9b076078d690">More...</a><br /></td></tr>
<tr class="separator:aa24276fbb8f0d3892fdd9b076078d690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Endian Conversion</div></td></tr>
<tr class="memitem:a56e0e9db954e75303566caf960d8934f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a56e0e9db954e75303566caf960d8934f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a56e0e9db954e75303566caf960d8934f">SwapEndian</a> (T *pData) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a56e0e9db954e75303566caf960d8934f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the endian.  <a href="namespacenn_1_1util.html#a56e0e9db954e75303566caf960d8934f">More...</a><br /></td></tr>
<tr class="separator:a56e0e9db954e75303566caf960d8934f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11528ff78b0c478ba7980afb1fb758ac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a11528ff78b0c478ba7980afb1fb758ac"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a11528ff78b0c478ba7980afb1fb758ac">LoadEndianReversed</a> (const T *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a11528ff78b0c478ba7980afb1fb758ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the endian and loads data from memory.  <a href="namespacenn_1_1util.html#a11528ff78b0c478ba7980afb1fb758ac">More...</a><br /></td></tr>
<tr class="separator:a11528ff78b0c478ba7980afb1fb758ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc3f4e75adbd4dd9a3aaeb81fabb7a4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5cc3f4e75adbd4dd9a3aaeb81fabb7a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a5cc3f4e75adbd4dd9a3aaeb81fabb7a4">StoreEndianReversed</a> (T *pDst, T src) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5cc3f4e75adbd4dd9a3aaeb81fabb7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the endian and writes data to memory.  <a href="namespacenn_1_1util.html#a5cc3f4e75adbd4dd9a3aaeb81fabb7a4">More...</a><br /></td></tr>
<tr class="separator:a5cc3f4e75adbd4dd9a3aaeb81fabb7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93bc440e1aa171900411796a54701ac7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a93bc440e1aa171900411796a54701ac7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a93bc440e1aa171900411796a54701ac7">LoadBigEndian</a> (const T *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a93bc440e1aa171900411796a54701ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads big endian data from memory.  <a href="namespacenn_1_1util.html#a93bc440e1aa171900411796a54701ac7">More...</a><br /></td></tr>
<tr class="separator:a93bc440e1aa171900411796a54701ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502929487c357dad5613feb3cc1d8ca1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a502929487c357dad5613feb3cc1d8ca1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a502929487c357dad5613feb3cc1d8ca1">StoreBigEndian</a> (T *pDst, T src) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a502929487c357dad5613feb3cc1d8ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to memory in big endian.  <a href="namespacenn_1_1util.html#a502929487c357dad5613feb3cc1d8ca1">More...</a><br /></td></tr>
<tr class="separator:a502929487c357dad5613feb3cc1d8ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1fe27e9543f7398c23221c9dc7f86f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abe1fe27e9543f7398c23221c9dc7f86f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#abe1fe27e9543f7398c23221c9dc7f86f">LoadLittleEndian</a> (const T *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:abe1fe27e9543f7398c23221c9dc7f86f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads little endian data from memory.  <a href="namespacenn_1_1util.html#abe1fe27e9543f7398c23221c9dc7f86f">More...</a><br /></td></tr>
<tr class="separator:abe1fe27e9543f7398c23221c9dc7f86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2462759e94b37f3c9dfb92406fbc4ec9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2462759e94b37f3c9dfb92406fbc4ec9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a2462759e94b37f3c9dfb92406fbc4ec9">StoreLittleEndian</a> (T *pDst, T src) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2462759e94b37f3c9dfb92406fbc4ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to memory in little endian.  <a href="namespacenn_1_1util.html#a2462759e94b37f3c9dfb92406fbc4ec9">More...</a><br /></td></tr>
<tr class="separator:a2462759e94b37f3c9dfb92406fbc4ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d638b63760707ce1d5e68c886cb59b5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6d638b63760707ce1d5e68c886cb59b5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a6d638b63760707ce1d5e68c886cb59b5">FromLittleEndian</a> (T var) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6d638b63760707ce1d5e68c886cb59b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts little-endian values to the platform's endianness.  <a href="namespacenn_1_1util.html#a6d638b63760707ce1d5e68c886cb59b5">More...</a><br /></td></tr>
<tr class="separator:a6d638b63760707ce1d5e68c886cb59b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0e81838fd1a4bf14aba90338f0a926"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2f0e81838fd1a4bf14aba90338f0a926"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a2f0e81838fd1a4bf14aba90338f0a926">ToLittleEndian</a> (T var) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2f0e81838fd1a4bf14aba90338f0a926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts data to little-endian values.  <a href="namespacenn_1_1util.html#a2f0e81838fd1a4bf14aba90338f0a926">More...</a><br /></td></tr>
<tr class="separator:a2f0e81838fd1a4bf14aba90338f0a926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0e01c015d468b75a416b0724531c27"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3e0e01c015d468b75a416b0724531c27"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a3e0e01c015d468b75a416b0724531c27">FromBigEndian</a> (T var) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3e0e01c015d468b75a416b0724531c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts big-endian values to the platform's endianness.  <a href="namespacenn_1_1util.html#a3e0e01c015d468b75a416b0724531c27">More...</a><br /></td></tr>
<tr class="separator:a3e0e01c015d468b75a416b0724531c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85cf0675a6b6235b4662135ab00f7a44"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a85cf0675a6b6235b4662135ab00f7a44"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a85cf0675a6b6235b4662135ab00f7a44">ToBigEndian</a> (T var) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a85cf0675a6b6235b4662135ab00f7a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts data to big-endian values.  <a href="namespacenn_1_1util.html#a85cf0675a6b6235b4662135ab00f7a44">More...</a><br /></td></tr>
<tr class="separator:a85cf0675a6b6235b4662135ab00f7a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Hash Functions</div></td></tr>
<tr class="memitem:aa65007834da7227e3fa016d111683e73"><td class="memItemLeft" align="right" valign="top">constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aa65007834da7227e3fa016d111683e73">GenerateFarmHash64</a> (const uint8_t *pData, size_t dataSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa65007834da7227e3fa016d111683e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a 64-bit <code>FarmHash</code>.  <a href="namespacenn_1_1util.html#aa65007834da7227e3fa016d111683e73">More...</a><br /></td></tr>
<tr class="separator:aa65007834da7227e3fa016d111683e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions for SharedFunction</div></td></tr>
<tr class="memitem:a354c1fa1e2628d64eecabed732ea0565"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Args&gt; </td></tr>
<tr class="memitem:a354c1fa1e2628d64eecabed732ea0565"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a354c1fa1e2628d64eecabed732ea0565">swap</a> (<a class="el" href="classnn_1_1util_1_1_shared_function.html">SharedFunction</a>&lt; R(Args...)&gt; &amp;lhs, <a class="el" href="classnn_1_1util_1_1_shared_function.html">SharedFunction</a>&lt; R(Args...)&gt; &amp;rhs) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a354c1fa1e2628d64eecabed732ea0565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the call target.  <a href="namespacenn_1_1util.html#a354c1fa1e2628d64eecabed732ea0565">More...</a><br /></td></tr>
<tr class="separator:a354c1fa1e2628d64eecabed732ea0565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5b33d314ee9cb1f8997bd9042d322d"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Args&gt; </td></tr>
<tr class="memitem:a1a5b33d314ee9cb1f8997bd9042d322d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a1a5b33d314ee9cb1f8997bd9042d322d">operator==</a> (const <a class="el" href="classnn_1_1util_1_1_shared_function.html">SharedFunction</a>&lt; R(Args...)&gt; &amp;lhs, std::nullptr_t) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1a5b33d314ee9cb1f8997bd9042d322d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the object does not have a call target.  <a href="namespacenn_1_1util.html#a1a5b33d314ee9cb1f8997bd9042d322d">More...</a><br /></td></tr>
<tr class="separator:a1a5b33d314ee9cb1f8997bd9042d322d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500fce66bd4061a998d68741f1603d75"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Args&gt; </td></tr>
<tr class="memitem:a500fce66bd4061a998d68741f1603d75"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a500fce66bd4061a998d68741f1603d75">operator==</a> (std::nullptr_t, const <a class="el" href="classnn_1_1util_1_1_shared_function.html">SharedFunction</a>&lt; R(Args...)&gt; &amp;rhs) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a500fce66bd4061a998d68741f1603d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the object does not have a call target.  <a href="namespacenn_1_1util.html#a500fce66bd4061a998d68741f1603d75">More...</a><br /></td></tr>
<tr class="separator:a500fce66bd4061a998d68741f1603d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2100d89100fd38c89ed6fdead21fa2"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Args&gt; </td></tr>
<tr class="memitem:a7d2100d89100fd38c89ed6fdead21fa2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a7d2100d89100fd38c89ed6fdead21fa2">operator!=</a> (const <a class="el" href="classnn_1_1util_1_1_shared_function.html">SharedFunction</a>&lt; R(Args...)&gt; &amp;lhs, std::nullptr_t) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7d2100d89100fd38c89ed6fdead21fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the object has a call target.  <a href="namespacenn_1_1util.html#a7d2100d89100fd38c89ed6fdead21fa2">More...</a><br /></td></tr>
<tr class="separator:a7d2100d89100fd38c89ed6fdead21fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8d169338e0f0ec77f92d586379311a"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Args&gt; </td></tr>
<tr class="memitem:a5e8d169338e0f0ec77f92d586379311a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a5e8d169338e0f0ec77f92d586379311a">operator!=</a> (std::nullptr_t, const <a class="el" href="classnn_1_1util_1_1_shared_function.html">SharedFunction</a>&lt; R(Args...)&gt; &amp;rhs) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5e8d169338e0f0ec77f92d586379311a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the object has a call target.  <a href="namespacenn_1_1util.html#a5e8d169338e0f0ec77f92d586379311a">More...</a><br /></td></tr>
<tr class="separator:a5e8d169338e0f0ec77f92d586379311a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Streaming Decompression Sample</div></td></tr>
<tr class="memitem:a95a0c92775590454820ac267996f2461"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a95a0c92775590454820ac267996f2461">InitializeStreamingDecompressZlibContext</a> (<a class="el" href="structnn_1_1util_1_1_streaming_decompress_zlib_context.html">StreamingDecompressZlibContext</a> *pContext) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a95a0c92775590454820ac267996f2461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the context for streaming decompression in <code>zlib</code> format.  <a href="namespacenn_1_1util.html#a95a0c92775590454820ac267996f2461">More...</a><br /></td></tr>
<tr class="separator:a95a0c92775590454820ac267996f2461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c59c5b4e3d814b813abf54a60ea4ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a64c59c5b4e3d814b813abf54a60ea4ec">InitializeStreamingDecompressGzipContext</a> (<a class="el" href="namespacenn_1_1util.html#ae9beb7ac8f35cef8dd13f0416662320a">StreamingDecompressGzipContext</a> *pContext) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a64c59c5b4e3d814b813abf54a60ea4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the context for streaming decompression in <code>Gzip</code> format.  <a href="namespacenn_1_1util.html#a64c59c5b4e3d814b813abf54a60ea4ec">More...</a><br /></td></tr>
<tr class="separator:a64c59c5b4e3d814b813abf54a60ea4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871190073dcf972d7212fe860883f208"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a871190073dcf972d7212fe860883f208">InitializeStreamingDecompressDeflateContext</a> (<a class="el" href="namespacenn_1_1util.html#af2ed3b5d58dc0275f9c96f4d4ec7a079">StreamingDecompressDeflateContext</a> *pContext) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a871190073dcf972d7212fe860883f208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the context for streaming decompression in <code>raw deflate</code> format.  <a href="namespacenn_1_1util.html#a871190073dcf972d7212fe860883f208">More...</a><br /></td></tr>
<tr class="separator:a871190073dcf972d7212fe860883f208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7545b1458e6ce1847a83d1a04d21cb7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a7545b1458e6ce1847a83d1a04d21cb7a">StreamingDecompressZlib</a> (size_t *pOutDstSize, size_t *pOutConsumedSrcSize, void *pDst, size_t dstSize, const void *pSrc, size_t srcSize, <a class="el" href="structnn_1_1util_1_1_streaming_decompress_zlib_context.html">StreamingDecompressZlibContext</a> *pContext) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7545b1458e6ce1847a83d1a04d21cb7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs streaming <code>deflate</code> decompression in <code>zlib</code> format.  <a href="namespacenn_1_1util.html#a7545b1458e6ce1847a83d1a04d21cb7a">More...</a><br /></td></tr>
<tr class="separator:a7545b1458e6ce1847a83d1a04d21cb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19480f506b13f96d397ab207377809f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ae19480f506b13f96d397ab207377809f">StreamingDecompressGzip</a> (size_t *pOutDstSize, size_t *pOutConsumedSrcSize, void *pDst, size_t dstSize, const void *pSrc, size_t srcSize, <a class="el" href="namespacenn_1_1util.html#ae9beb7ac8f35cef8dd13f0416662320a">StreamingDecompressGzipContext</a> *pContext) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae19480f506b13f96d397ab207377809f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs streaming <code>deflate</code> decompression in <code>Gzip</code> format.  <a href="namespacenn_1_1util.html#ae19480f506b13f96d397ab207377809f">More...</a><br /></td></tr>
<tr class="separator:ae19480f506b13f96d397ab207377809f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4538c0f548daf8eb7a9be82f0d05db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a0f4538c0f548daf8eb7a9be82f0d05db">StreamingDecompressDeflate</a> (size_t *pOutDstSize, size_t *pOutConsumedSrcSize, void *pDst, size_t dstSize, const void *pSrc, size_t srcSize, <a class="el" href="namespacenn_1_1util.html#af2ed3b5d58dc0275f9c96f4d4ec7a079">StreamingDecompressDeflateContext</a> *pContext) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0f4538c0f548daf8eb7a9be82f0d05db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs streaming <code>deflate</code> decompression in <code>raw deflate</code> format.  <a href="namespacenn_1_1util.html#a0f4538c0f548daf8eb7a9be82f0d05db">More...</a><br /></td></tr>
<tr class="separator:a0f4538c0f548daf8eb7a9be82f0d05db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">String Operations Functions</div></td></tr>
<tr class="memitem:a449ac1aeee3544e5fa3ad081df39a0c5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a449ac1aeee3544e5fa3ad081df39a0c5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a449ac1aeee3544e5fa3ad081df39a0c5">ToLower</a> (T c) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a449ac1aeee3544e5fa3ad081df39a0c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an uppercase character into lowercase.  <a href="namespacenn_1_1util.html#a449ac1aeee3544e5fa3ad081df39a0c5">More...</a><br /></td></tr>
<tr class="separator:a449ac1aeee3544e5fa3ad081df39a0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45834f1f0a1e7dbe85de32821bac35fc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a45834f1f0a1e7dbe85de32821bac35fc"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a45834f1f0a1e7dbe85de32821bac35fc">ToUpper</a> (T c) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a45834f1f0a1e7dbe85de32821bac35fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a lowercase character into uppercase.  <a href="namespacenn_1_1util.html#a45834f1f0a1e7dbe85de32821bac35fc">More...</a><br /></td></tr>
<tr class="separator:a45834f1f0a1e7dbe85de32821bac35fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a369852b1204085d96a7cc4f26c880b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9a369852b1204085d96a7cc4f26c880b"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a9a369852b1204085d96a7cc4f26c880b">Strlcpy</a> (T *pOutDst, const T *pSrc, int count) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9a369852b1204085d96a7cc4f26c880b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies strings, accounting for the number of elements in the copy destination buffer and termination.  <a href="namespacenn_1_1util.html#a9a369852b1204085d96a7cc4f26c880b">More...</a><br /></td></tr>
<tr class="separator:a9a369852b1204085d96a7cc4f26c880b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67392e3b18c74ee4ee9c90b8191e554"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae67392e3b18c74ee4ee9c90b8191e554"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ae67392e3b18c74ee4ee9c90b8191e554">Strnlen</a> (const T *pStr, int count) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae67392e3b18c74ee4ee9c90b8191e554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of characters, including the number of buffer elements and the terminator.  <a href="namespacenn_1_1util.html#ae67392e3b18c74ee4ee9c90b8191e554">More...</a><br /></td></tr>
<tr class="separator:ae67392e3b18c74ee4ee9c90b8191e554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9687192252f37e1984e628b8bf796e22"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9687192252f37e1984e628b8bf796e22"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a9687192252f37e1984e628b8bf796e22">Strncmp</a> (const T *pStr1, const T *pStr2, int count) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9687192252f37e1984e628b8bf796e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares strings, taking into account the number of elements in the buffer and the terminator.  <a href="namespacenn_1_1util.html#a9687192252f37e1984e628b8bf796e22">More...</a><br /></td></tr>
<tr class="separator:a9687192252f37e1984e628b8bf796e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3e455c0d7f8cafe6f97ea27940db7f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aad3e455c0d7f8cafe6f97ea27940db7f"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aad3e455c0d7f8cafe6f97ea27940db7f">Strnicmp</a> (const T *pStr1, const T *pStr2, int count) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aad3e455c0d7f8cafe6f97ea27940db7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares strings, ignoring the case but taking into account the number of elements in the buffer and the terminator.  <a href="namespacenn_1_1util.html#aad3e455c0d7f8cafe6f97ea27940db7f">More...</a><br /></td></tr>
<tr class="separator:aad3e455c0d7f8cafe6f97ea27940db7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ec4ff5da8ddd7de157ae929f839938"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a11ec4ff5da8ddd7de157ae929f839938"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a11ec4ff5da8ddd7de157ae929f839938">Strnstr</a> (const T *pStr1, const T *pStr2, int count) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a11ec4ff5da8ddd7de157ae929f839938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the location of a partial string.  <a href="namespacenn_1_1util.html#a11ec4ff5da8ddd7de157ae929f839938">More...</a><br /></td></tr>
<tr class="separator:a11ec4ff5da8ddd7de157ae929f839938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4b52209632a67c5642c794d6eec9e7"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aae4b52209632a67c5642c794d6eec9e7">Memmem</a> (const void *pHaystack, size_t haystackLength, const void *pNeedle, size_t needleLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aae4b52209632a67c5642c794d6eec9e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the location of a partial string.  <a href="namespacenn_1_1util.html#aae4b52209632a67c5642c794d6eec9e7">More...</a><br /></td></tr>
<tr class="separator:aae4b52209632a67c5642c794d6eec9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">TypedStorage Functions</div></td></tr>
<tr class="memitem:af9bcb6a04353d44c401b747d2ce7f812"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af9bcb6a04353d44c401b747d2ce7f812"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#af9bcb6a04353d44c401b747d2ce7f812">Get</a> (<a class="el" href="structnn_1_1util_1_1_typed_storage.html">TypedStorage</a>&lt; T, sizeof(T), std::alignment_of&lt; T &gt;::value &gt; &amp;storage)</td></tr>
<tr class="memdesc:af9bcb6a04353d44c401b747d2ce7f812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference to the actual type from the specified region.  <a href="namespacenn_1_1util.html#af9bcb6a04353d44c401b747d2ce7f812">More...</a><br /></td></tr>
<tr class="separator:af9bcb6a04353d44c401b747d2ce7f812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8769650838b44c09ff5c036f7050bc35"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8769650838b44c09ff5c036f7050bc35"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a8769650838b44c09ff5c036f7050bc35">Get</a> (const <a class="el" href="structnn_1_1util_1_1_typed_storage.html">TypedStorage</a>&lt; T, sizeof(T), std::alignment_of&lt; T &gt;::value &gt; &amp;storage)</td></tr>
<tr class="memdesc:a8769650838b44c09ff5c036f7050bc35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference to the actual type from the specified region.  <a href="namespacenn_1_1util.html#a8769650838b44c09ff5c036f7050bc35">More...</a><br /></td></tr>
<tr class="separator:a8769650838b44c09ff5c036f7050bc35"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad88fffd214c821216806be73ef63704c"><td class="memItemLeft" align="right" valign="top"><a id="ad88fffd214c821216806be73ef63704c"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ad88fffd214c821216806be73ef63704c">CompressDeflateWorkBufferSizeDefault</a> = <a class="el" href="namespacenn_1_1util.html#aa4dcb222bce2eb1d5209d12dad071028">CompressZlibWorkBufferSizeDefault</a></td></tr>
<tr class="memdesc:ad88fffd214c821216806be73ef63704c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant that defines the size (in bytes) of the working buffer required by the <code><a class="el" href="namespacenn_1_1util.html#a394f55bc3df26d704f0fa46644aeee07" title="Performs deflate compression in raw deflate format.">CompressDeflate()</a></code> function that does not specify the compression level or the memory usage level. <br /></td></tr>
<tr class="separator:ad88fffd214c821216806be73ef63704c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a13350e1e0d435dccc7128af110815e"><td class="memItemLeft" align="right" valign="top"><a id="a2a13350e1e0d435dccc7128af110815e"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a2a13350e1e0d435dccc7128af110815e">CompressGzipWorkBufferSizeDefault</a> = <a class="el" href="namespacenn_1_1util.html#aa4dcb222bce2eb1d5209d12dad071028">CompressZlibWorkBufferSizeDefault</a></td></tr>
<tr class="memdesc:a2a13350e1e0d435dccc7128af110815e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant that defines the size (in bytes) of the working buffer required by the <code><a class="el" href="namespacenn_1_1util.html#a1eaf5623ce101256fc619f5b5a03491c" title="Performs deflate compression in Gzip format.">CompressGzip()</a></code> function that does not specify the compression level or the memory usage level. <br /></td></tr>
<tr class="separator:a2a13350e1e0d435dccc7128af110815e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4dcb222bce2eb1d5209d12dad071028"><td class="memItemLeft" align="right" valign="top"><a id="aa4dcb222bce2eb1d5209d12dad071028"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aa4dcb222bce2eb1d5209d12dad071028">CompressZlibWorkBufferSizeDefault</a> = 268096</td></tr>
<tr class="memdesc:aa4dcb222bce2eb1d5209d12dad071028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant that defines the size (in bytes) of the working buffer required by the <code><a class="el" href="namespacenn_1_1util.html#ae0290996b2f08a558763e919ca74fd0f" title="Performs deflate compression in zlib format.">CompressZlib()</a></code> function that does not specify the compression level or the memory usage level. <br /></td></tr>
<tr class="separator:aa4dcb222bce2eb1d5209d12dad071028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf5d72895f77ce0053fabf25e2f91f8"><td class="memItemLeft" align="right" valign="top"><a id="afcf5d72895f77ce0053fabf25e2f91f8"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#afcf5d72895f77ce0053fabf25e2f91f8">DecompressDeflateWorkBufferSize</a> = <a class="el" href="namespacenn_1_1util.html#ac41cb5e81653f3eecbe0a898da550b86">DecompressZlibWorkBufferSize</a></td></tr>
<tr class="memdesc:afcf5d72895f77ce0053fabf25e2f91f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant that defines the size (in bytes) of the working buffer required by <code><a class="el" href="namespacenn_1_1util.html#aa24276fbb8f0d3892fdd9b076078d690" title="Performs deflate decompression in raw deflate format.">DecompressDeflate()</a></code>. <br /></td></tr>
<tr class="separator:afcf5d72895f77ce0053fabf25e2f91f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad5f8ed7845391894b9fe69be1f9a30"><td class="memItemLeft" align="right" valign="top"><a id="afad5f8ed7845391894b9fe69be1f9a30"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#afad5f8ed7845391894b9fe69be1f9a30">DecompressGzipWorkBufferSize</a> = <a class="el" href="namespacenn_1_1util.html#ac41cb5e81653f3eecbe0a898da550b86">DecompressZlibWorkBufferSize</a></td></tr>
<tr class="memdesc:afad5f8ed7845391894b9fe69be1f9a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant that defines the size (in bytes) of the working buffer required by <code><a class="el" href="namespacenn_1_1util.html#a8d0dd598671e1a5e68b15f48e4b02045" title="Performs deflate decompression in Gzip format.">DecompressGzip()</a></code>. <br /></td></tr>
<tr class="separator:afad5f8ed7845391894b9fe69be1f9a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41cb5e81653f3eecbe0a898da550b86"><td class="memItemLeft" align="right" valign="top"><a id="ac41cb5e81653f3eecbe0a898da550b86"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ac41cb5e81653f3eecbe0a898da550b86">DecompressZlibWorkBufferSize</a> = 7160</td></tr>
<tr class="memdesc:ac41cb5e81653f3eecbe0a898da550b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant that defines the size (in bytes) of the working buffer required by <code><a class="el" href="namespacenn_1_1util.html#a5ef5750312d89f54f3e11496c3414ef7" title="Performs deflate decompression in zlib format.">DecompressZlib()</a></code>. <br /></td></tr>
<tr class="separator:ac41cb5e81653f3eecbe0a898da550b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325b9b74fce32f090061ebdefb9b024b"><td class="memItemLeft" align="right" valign="top"><a id="a325b9b74fce32f090061ebdefb9b024b"></a>
const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a325b9b74fce32f090061ebdefb9b024b">FloatPi</a></td></tr>
<tr class="memdesc:a325b9b74fce32f090061ebdefb9b024b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the value of pi (π) using a <code><em>float</em></code> type. <br /></td></tr>
<tr class="separator:a325b9b74fce32f090061ebdefb9b024b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963d22246b0f42a3b519e03f6e3701e2"><td class="memItemLeft" align="right" valign="top"><a id="a963d22246b0f42a3b519e03f6e3701e2"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a963d22246b0f42a3b519e03f6e3701e2">Utf8CodePointByteSizeMax</a> = 4</td></tr>
<tr class="memdesc:a963d22246b0f42a3b519e03f6e3701e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant representing the maximum number of bytes for a single UTF-8 code point. <br /></td></tr>
<tr class="separator:a963d22246b0f42a3b519e03f6e3701e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for the utility library. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a1037da81cd878626e7a661798f94b873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1037da81cd878626e7a661798f94b873">&#9670;&nbsp;</a></span>FormatStringOutputFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* nn::util::FormatStringOutputFunction)(uintptr_t arg, const char *pCharacters, int count)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the callback function that receives the strings generated by <code><a class="el" href="namespacenn_1_1util.html#a54f65dcb71d5cb6e32f327ccab7f796c">FormatString</a></code> and <code><a class="el" href="namespacenn_1_1util.html#a1054c37da4a1d20fe6b0ca90a8ca351c">VFormatString</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>A user-defined parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pCharacters</td><td>The generated string. Not NULL-terminated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of characters that <em>pCharacters</em> points to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>pCharacters</em></code> is not a null pointer. </dd>
<dd>
<code><em>count</em></code> &gt; <code>0</code>. </dd>
<dd>
<code><em>pCharacters</em></code> points to the <code>char</code> type array with the same number of non-null character elements as <code><em>count</em></code>.</dd></dl>
<p> <b>Details</b> <br  />
The generated string is divided into multiple blocks of one or more characters, and these blocks are passed to this function one at a time, in order from the top. This function must not throw an exception. </p>

</div>
</div>
<a id="a57660aa7758ae3375aeffbd6b1424b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57660aa7758ae3375aeffbd6b1424b24">&#9670;&nbsp;</a></span>Matrix3x2fType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structnn_1_1util_1_1_matrix_row_major3x2f_type.html">MatrixRowMajor3x2fType</a> <a class="el" href="namespacenn_1_1util.html#a57660aa7758ae3375aeffbd6b1424b24">nn::util::Matrix3x2fType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents a three-row, two-column matrix using a single precision floating point data type. </p>
<p> <b>Details</b> <br  />
 Type that provides vector and matrix calculations.</p>
<p>We assume that calculations that use this type will switch to an implementation that uses the SIMD unit in environments that can use the SIMD unit. A generic environment is provided for environments in which the SIMD unit cannot be used.</p>
<dl class="section attention"><dt>Attention</dt><dd>This type is optimized for calculations. As a result, it can differ based on memory layout, size, and environment. For this reason, <b>direct access to internal elements is prohibited.</b> To access elements, use dedicated macros and functions.</dd>
<dd>
Because calculations within the SIMD are to be optimized, this type calculates memory alignment. <b>When allocating this type in memory, make sure that it meets the required alignment.</b> The required alignment may differ for each internal implementation. Each implementation enumerates the required alignment.<ul>
<li>General purpose implementation version: 16 byte</li>
<li>NEON implementation version: 8 byte</li>
</ul>
</dd></dl>
<p>The general purpose implementation version specifies an alignment that can satisfy the required alignment of all other SIMD implementations. </p>

</div>
</div>
<a id="afb360b0e9579454c6af5804cc476c101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb360b0e9579454c6af5804cc476c101">&#9670;&nbsp;</a></span>Matrix4x3fType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structnn_1_1util_1_1_matrix_row_major4x3f_type.html">MatrixRowMajor4x3fType</a> <a class="el" href="namespacenn_1_1util.html#afb360b0e9579454c6af5804cc476c101">nn::util::Matrix4x3fType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents a four-row, three-column matrix using a single precision floating point data type. </p>
<p> <b>Details</b> <br  />
 Type that provides vector and matrix calculations.</p>
<p>We assume that calculations that use this type will switch to an implementation that uses the SIMD unit in environments that can use the SIMD unit. A generic environment is provided for environments in which the SIMD unit cannot be used.</p>
<dl class="section attention"><dt>Attention</dt><dd>This type is optimized for calculations. As a result, it can differ based on memory layout, size, and environment. For this reason, <b>direct access to internal elements is prohibited.</b> To access elements, use dedicated macros and functions.</dd>
<dd>
Because calculations within the SIMD are to be optimized, this type calculates memory alignment. <b>When allocating this type in memory, make sure that it meets the required alignment.</b> The required alignment may differ for each internal implementation. Each implementation enumerates the required alignment.<ul>
<li>General purpose implementation version: 16 byte</li>
<li>NEON implementation version: 16 byte</li>
</ul>
</dd></dl>
<p>The general purpose implementation version specifies an alignment that can satisfy the required alignment of all other SIMD implementations. </p>

</div>
</div>
<a id="a1bb0d5db7601e1af28a6f5b90cd5fd16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb0d5db7601e1af28a6f5b90cd5fd16">&#9670;&nbsp;</a></span>Matrix4x4fType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structnn_1_1util_1_1_matrix_row_major4x4f_type.html">MatrixRowMajor4x4fType</a> <a class="el" href="namespacenn_1_1util.html#a1bb0d5db7601e1af28a6f5b90cd5fd16">nn::util::Matrix4x4fType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents a four-row, four-column matrix using a single precision floating point data type. </p>
<p> <b>Details</b> <br  />
 Type that provides vector and matrix calculations.</p>
<p>We assume that calculations that use this type will switch to an implementation that uses the SIMD unit in environments that can use the SIMD unit. A generic environment is provided for environments in which the SIMD unit cannot be used.</p>
<dl class="section attention"><dt>Attention</dt><dd>This type is optimized for calculations. As a result, it can differ based on memory layout, size, and environment. For this reason, <b>direct access to internal elements is prohibited.</b> To access elements, use dedicated macros and functions.</dd>
<dd>
Because calculations within the SIMD are to be optimized, this type calculates memory alignment. <b>When allocating this type in memory, make sure that it meets the required alignment.</b> The required alignment may differ for each internal implementation. Each implementation enumerates the required alignment.<ul>
<li>General purpose implementation version: 16 byte</li>
<li>NEON implementation version: 16 byte</li>
</ul>
</dd></dl>
<p>The general purpose implementation version specifies an alignment that can satisfy the required alignment of all other SIMD implementations. </p>

</div>
</div>
<a id="ac30d0e9a77dc1b72739d270a2a4cb10b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30d0e9a77dc1b72739d270a2a4cb10b">&#9670;&nbsp;</a></span>FloatT3x2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structnn_1_1util_1_1_float_column_major3x2.html">FloatColumnMajor3x2</a> <a class="el" href="namespacenn_1_1util.html#ac30d0e9a77dc1b72739d270a2a4cb10b">nn::util::FloatT3x2</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents a three-row, two-column matrix using a single precision floating point array. </p>
<p>This memory layout reverses the row and column major properties of <code><a class="el" href="namespacenn_1_1util.html#ab0a7e9c8b1f290aac20d7c882f20ab7c" title="Represents a three-row, two-column matrix using a single precision floating point array.">nn::util::Float3x2</a></code>. </p>

</div>
</div>
<a id="aaec387faf9cc69e9382a2a8002821f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec387faf9cc69e9382a2a8002821f24">&#9670;&nbsp;</a></span>FloatT4x3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structnn_1_1util_1_1_float_column_major4x3.html">FloatColumnMajor4x3</a> <a class="el" href="namespacenn_1_1util.html#aaec387faf9cc69e9382a2a8002821f24">nn::util::FloatT4x3</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents a four-row, three-column matrix using a single precision floating point array. </p>
<p>This memory layout reverses the row and column major properties of <code><a class="el" href="namespacenn_1_1util.html#a1f45cae1843465e71962a4f18f5fdb74" title="Represents a four-row, three-column matrix using a single precision floating point array.">nn::util::Float4x3</a></code>. </p>

</div>
</div>
<a id="a11491fc1d12c8b6f393d794dc9737b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11491fc1d12c8b6f393d794dc9737b46">&#9670;&nbsp;</a></span>FloatT4x4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structnn_1_1util_1_1_float_column_major4x4.html">FloatColumnMajor4x4</a> <a class="el" href="namespacenn_1_1util.html#a11491fc1d12c8b6f393d794dc9737b46">nn::util::FloatT4x4</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents a four-row, three-column matrix using a single precision floating point array. </p>
<p>This memory layout reverses the row and column major properties of <code><a class="el" href="namespacenn_1_1util.html#a3eb49f9abd5e4a507364789a6636faca" title="Represents a four-row, four-column matrix using a single precision floating point array.">nn::util::Float4x4</a></code>. </p>

</div>
</div>
<a id="a0393f5ea2f2d2bc1a17ff98976f4b084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0393f5ea2f2d2bc1a17ff98976f4b084">&#9670;&nbsp;</a></span>MatrixT3x2fType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structnn_1_1util_1_1_matrix_column_major3x2f_type.html">MatrixColumnMajor3x2fType</a> <a class="el" href="namespacenn_1_1util.html#a0393f5ea2f2d2bc1a17ff98976f4b084">nn::util::MatrixT3x2fType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents a three-row, two-column matrix using a single precision floating point data type. </p>
<p>This memory layout reverses the row and column major properties of <code><a class="el" href="namespacenn_1_1util.html#a57660aa7758ae3375aeffbd6b1424b24" title="Represents a three-row, two-column matrix using a single precision floating point data type.">nn::util::Matrix3x2fType</a></code>.</p>
<p> <b>Details</b> <br  />
 Type that provides vector and matrix calculations.</p>
<p>We assume that calculations that use this type will switch to an implementation that uses the SIMD unit in environments that can use the SIMD unit. A generic environment is provided for environments in which the SIMD unit cannot be used.</p>
<dl class="section attention"><dt>Attention</dt><dd>This type is optimized for calculations. As a result, it can differ based on memory layout, size, and environment. For this reason, <b>direct access to internal elements is prohibited.</b> To access elements, use dedicated macros and functions.</dd>
<dd>
Because calculations within the SIMD are to be optimized, this type calculates memory alignment. <b>When allocating this type in memory, make sure that it meets the required alignment.</b> The required alignment may differ for each internal implementation. Each implementation enumerates the required alignment.<ul>
<li>General purpose implementation version: 16 byte</li>
<li>NEON implementation version: 16 byte</li>
</ul>
</dd></dl>
<p>The general purpose implementation version specifies an alignment that can satisfy the required alignment of all other SIMD implementations. </p>

</div>
</div>
<a id="aae68b9728d824289e709226f88f4326d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae68b9728d824289e709226f88f4326d">&#9670;&nbsp;</a></span>MatrixT4x3fType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structnn_1_1util_1_1_matrix_column_major4x3f_type.html">MatrixColumnMajor4x3fType</a> <a class="el" href="namespacenn_1_1util.html#aae68b9728d824289e709226f88f4326d">nn::util::MatrixT4x3fType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents a four-row, three-column matrix using a single precision floating point data type. </p>
<p>This memory layout reverses the row and column major properties of <code><a class="el" href="namespacenn_1_1util.html#afb360b0e9579454c6af5804cc476c101" title="Represents a four-row, three-column matrix using a single precision floating point data type.">nn::util::Matrix4x3fType</a></code>.</p>
<p> <b>Details</b> <br  />
 Type that provides vector and matrix calculations.</p>
<p>We assume that calculations that use this type will switch to an implementation that uses the SIMD unit in environments that can use the SIMD unit. A generic environment is provided for environments in which the SIMD unit cannot be used.</p>
<dl class="section attention"><dt>Attention</dt><dd>This type is optimized for calculations. As a result, it can differ based on memory layout, size, and environment. For this reason, <b>direct access to internal elements is prohibited.</b> To access elements, use dedicated macros and functions.</dd>
<dd>
Because calculations within the SIMD are to be optimized, this type calculates memory alignment. <b>When allocating this type in memory, make sure that it meets the required alignment.</b> The required alignment may differ for each internal implementation. Each implementation enumerates the required alignment.<ul>
<li>General purpose implementation version: 16 byte</li>
<li>NEON implementation version: 16 byte</li>
</ul>
</dd></dl>
<p>The general purpose implementation version specifies an alignment that can satisfy the required alignment of all other SIMD implementations. </p>

</div>
</div>
<a id="aa93b34341c777e6d93d6341520acebc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93b34341c777e6d93d6341520acebc8">&#9670;&nbsp;</a></span>MatrixT4x4fType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structnn_1_1util_1_1_matrix_column_major4x4f_type.html">MatrixColumnMajor4x4fType</a> <a class="el" href="namespacenn_1_1util.html#aa93b34341c777e6d93d6341520acebc8">nn::util::MatrixT4x4fType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents a four-row, four-column matrix using a single precision floating point data type. </p>
<p>This memory layout reverses the row and column major properties of <code><a class="el" href="namespacenn_1_1util.html#a1bb0d5db7601e1af28a6f5b90cd5fd16" title="Represents a four-row, four-column matrix using a single precision floating point data type.">nn::util::Matrix4x4fType</a></code>.</p>
<p> <b>Details</b> <br  />
 Type that provides vector and matrix calculations.</p>
<p>We assume that calculations that use this type will switch to an implementation that uses the SIMD unit in environments that can use the SIMD unit. A generic environment is provided for environments in which the SIMD unit cannot be used.</p>
<dl class="section attention"><dt>Attention</dt><dd>This type is optimized for calculations. As a result, it can differ based on memory layout, size, and environment. For this reason, <b>direct access to internal elements is prohibited.</b> To access elements, use dedicated macros and functions.</dd>
<dd>
Because calculations within the SIMD are to be optimized, this type calculates memory alignment. <b>When allocating this type in memory, make sure that it meets the required alignment.</b> The required alignment may differ for each internal implementation. Each implementation enumerates the required alignment.<ul>
<li>General purpose implementation version: 16 byte</li>
<li>NEON implementation version: 16 byte</li>
</ul>
</dd></dl>
<p>The general purpose implementation version specifies an alignment that can satisfy the required alignment of all other SIMD implementations. </p>

</div>
</div>
<a id="ad703d4cc91629b6b26764a5d1506efd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad703d4cc91629b6b26764a5d1506efd8">&#9670;&nbsp;</a></span>Matrix3x2f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classnn_1_1util_1_1_matrix_row_major3x2f.html">MatrixRowMajor3x2f</a> <a class="el" href="namespacenn_1_1util.html#ad703d4cc91629b6b26764a5d1506efd8">nn::util::Matrix3x2f</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Class representing a three-row, two-column, row-major matrix using a single precision floating point data type. </p>
<p> <b>Details</b> <br  />
 Type that provides vector and matrix calculations.</p>
<p>Utility class that inherits <code><a class="el" href="structnn_1_1util_1_1_matrix_row_major3x2f_type.html" title="Represents a three-row, two-column, row-major matrix using a single precision floating point data typ...">nn::util::MatrixRowMajor3x2fType</a></code> and adds a member function.</p>
<p>We assume that calculations that use this type will switch to an implementation that uses the SIMD unit in environments that can use the SIMD unit. A generic environment is provided for environments in which the SIMD unit cannot be used.</p>
<dl class="section attention"><dt>Attention</dt><dd>This type is optimized for calculations. As a result, it can differ based on memory layout, size, and environment. For this reason, <b>direct access to internal elements is prohibited.</b> To access elements, use dedicated macros and functions.</dd>
<dd>
Because calculations within the SIMD are to be optimized, this type <b>must be aligned to 16 bytes</b>. When allocating this type in memory, make sure that it meets the required alignment. </dd></dl>

</div>
</div>
<a id="a144c36edc0c1d0762f88b59f0a754b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144c36edc0c1d0762f88b59f0a754b6a">&#9670;&nbsp;</a></span>Matrix4x3f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classnn_1_1util_1_1_matrix_row_major4x3f.html">MatrixRowMajor4x3f</a> <a class="el" href="namespacenn_1_1util.html#a144c36edc0c1d0762f88b59f0a754b6a">nn::util::Matrix4x3f</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Class representing a four-column, three-row, column-major matrix using a single precision floating point data type. </p>
<p> <b>Details</b> <br  />
 Type that provides vector and matrix calculations.</p>
<p>Utility class that inherits <code><a class="el" href="structnn_1_1util_1_1_matrix_row_major4x3f_type.html" title="Represents a four-row, three-column, row-major matrix using a single precision floating point data ty...">nn::util::MatrixRowMajor4x3fType</a></code> and that adds a member function.</p>
<p>We assume that calculations that use this type will switch to an implementation that uses the SIMD unit in environments that can use the SIMD unit. A generic environment is provided for environments in which the SIMD unit cannot be used.</p>
<dl class="section attention"><dt>Attention</dt><dd>This type is optimized for calculations. As a result, it can differ based on memory layout, size, and environment. For this reason, <b>direct access to internal elements is prohibited.</b> To access elements, use dedicated macros and functions.</dd>
<dd>
Because calculations within the SIMD are to be optimized, this type <b>must be aligned to 16 bytes</b>. When allocating this type in memory, make sure that it meets the required alignment. </dd></dl>

</div>
</div>
<a id="ad3916074464578212a8a939a4dbd08ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3916074464578212a8a939a4dbd08ae">&#9670;&nbsp;</a></span>Matrix4x4f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classnn_1_1util_1_1_matrix_row_major4x4f.html">MatrixRowMajor4x4f</a> <a class="el" href="namespacenn_1_1util.html#ad3916074464578212a8a939a4dbd08ae">nn::util::Matrix4x4f</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Class representing a four-column, four-row, column-major matrix using a single precision floating point data type. </p>
<p> <b>Details</b> <br  />
 Type that provides vector and matrix calculations.</p>
<p>Utility class that inherits <code><a class="el" href="structnn_1_1util_1_1_matrix_row_major4x4f_type.html" title="Represents a four-row, four-column, row-major matrix using a single precision floating point data typ...">nn::util::MatrixRowMajor4x4fType</a></code> and that adds a member function.</p>
<p>We assume that calculations that use this type will switch to an implementation that uses the SIMD unit in environments that can use the SIMD unit. A generic environment is provided for environments in which the SIMD unit cannot be used.</p>
<dl class="section attention"><dt>Attention</dt><dd>This type is optimized for calculations. As a result, it can differ based on memory layout, size, and environment. For this reason, <b>direct access to internal elements is prohibited.</b> To access elements, use dedicated macros and functions.</dd>
<dd>
Because calculations within the SIMD are to be optimized, this type <b>must be aligned to 16 bytes</b>. When allocating this type in memory, make sure that it meets the required alignment. </dd></dl>

</div>
</div>
<a id="ae9beb7ac8f35cef8dd13f0416662320a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9beb7ac8f35cef8dd13f0416662320a">&#9670;&nbsp;</a></span>StreamingDecompressGzipContext</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structnn_1_1util_1_1_streaming_decompress_zlib_context.html">StreamingDecompressZlibContext</a> <a class="el" href="namespacenn_1_1util.html#ae9beb7ac8f35cef8dd13f0416662320a">nn::util::StreamingDecompressGzipContext</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Context for streaming decompression of data compressed in <code>gzip</code> format. </p>
<p> <b>Details</b> <br  />
 Context for streaming decompression of data compressed in <code>gzip</code> format. Do not access the member variables directly. Due to the large size, take note of the stack size before placing this on the stack. This structure must be 8-byte aligned. </p>

</div>
</div>
<a id="af2ed3b5d58dc0275f9c96f4d4ec7a079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ed3b5d58dc0275f9c96f4d4ec7a079">&#9670;&nbsp;</a></span>StreamingDecompressDeflateContext</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structnn_1_1util_1_1_streaming_decompress_zlib_context.html">StreamingDecompressZlibContext</a> <a class="el" href="namespacenn_1_1util.html#af2ed3b5d58dc0275f9c96f4d4ec7a079">nn::util::StreamingDecompressDeflateContext</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Context for streaming decompression of data compressed in <code>raw deflate</code> format. </p>
<p> <b>Details</b> <br  />
 Context for streaming decompression of data compressed in <code>raw deflate</code> format. Do not access the member variables directly. Due to the large size, take note of the stack size before placing this on the stack. This structure must be 8-byte aligned. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a4a5a5a34319b208c9c23ac038d412a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a5a5a34319b208c9c23ac038d412a31">&#9670;&nbsp;</a></span>ByteOrderMark</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1util.html#a4a5a5a34319b208c9c23ac038d412a31">nn::util::ByteOrderMark</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerated type that indicates the byte order mark. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4a5a5a34319b208c9c23ac038d412a31af47a310dc26e97a75adae293e89fd52f"></a>ByteOrderMark_Normal&#160;</td><td class="fielddoc"><p>The normal byte order mark. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4a5a5a34319b208c9c23ac038d412a31a59a43d310e2ac1c3f6a852eb5e2f789e"></a>ByteOrderMark_Reverse&#160;</td><td class="fielddoc"><p>The byte order mark with reversed endianness. </p>
</td></tr>
</table>

</div>
</div>
<a id="a8ab72d7227a9a1b56f78d0caf2920478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab72d7227a9a1b56f78d0caf2920478">&#9670;&nbsp;</a></span>CharacterEncodingResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">nn::util::CharacterEncodingResult</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The encoding conversion result (error code). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8ab72d7227a9a1b56f78d0caf2920478a7f284c7d118115284232bd26b33c2149"></a>CharacterEncodingResult_Success&#160;</td><td class="fielddoc"><p>Converted normally. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8ab72d7227a9a1b56f78d0caf2920478aba616796fb8ce72bd5f1455c621a47b2"></a>CharacterEncodingResult_InsufficientLength&#160;</td><td class="fielddoc"><p>The conversion result array was not long enough. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8ab72d7227a9a1b56f78d0caf2920478aae294bb0babe7737681d80af74cef4a4"></a>CharacterEncodingResult_InvalidFormat&#160;</td><td class="fielddoc"><p>An unconvertible character was detected. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a97ebb4e1469d08a7f51a21147375949b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ebb4e1469d08a7f51a21147375949b">&#9670;&nbsp;</a></span>RadianToAngleIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a> nn::util::RadianToAngleIndex </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radian</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an angle from radians to index representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">radian</td><td>Angle (in radians).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. </dd></dl>

</div>
</div>
<a id="ade1e7f71d2c5b0551d7b8c735d83d6a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade1e7f71d2c5b0551d7b8c735d83d6a3">&#9670;&nbsp;</a></span>DegreeToAngleIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a> nn::util::DegreeToAngleIndex </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>degree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an angle from degrees to index representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">degree</td><td>Angle (in degrees).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. </dd></dl>

</div>
</div>
<a id="a342713848fbb4ce6750da90d297bc824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a342713848fbb4ce6750da90d297bc824">&#9670;&nbsp;</a></span>DegreeToRadian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::DegreeToRadian </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>degree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an angle from degrees to radian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">degree</td><td>Angle (in degrees).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_edit_8cpp-example.html#a95">G3dDemo/Edit.cpp</a>, <a class="el" href="_g3d_demo_2_nns_g3d_simple_8cpp-example.html#a8">G3dDemo/NnsG3dSimple.cpp</a>, <a class="el" href="_g3d_demo_2_outline_8cpp-example.html#a11">G3dDemo/Outline.cpp</a>, <a class="el" href="_g3d_demo_2_parallel_8cpp-example.html#a7">G3dDemo/Parallel.cpp</a>, <a class="el" href="_g3d_demo_2_shape_animation_8cpp-example.html#a161">G3dDemo/ShapeAnimation.cpp</a>, <a class="el" href="_g3d_demo_2_simple_8cpp-example.html#a268">G3dDemo/Simple.cpp</a>, <a class="el" href="_g3d_demo_2_skeletal_animation_8cpp-example.html#a40">G3dDemo/SkeletalAnimation.cpp</a>, <a class="el" href="_g3d_demo_2_tessellation_8cpp-example.html#a73">G3dDemo/Tessellation.cpp</a>, <a class="el" href="_g3d_demo_2_town_8cpp-example.html#a97">G3dDemo/Town.cpp</a>, <a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__game_8cpp-example.html#a19">HidControllerSequence/HidControllerSequence_Game.cpp</a>, <a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__title_8cpp-example.html#a22">HidControllerSequence/HidControllerSequence_Title.cpp</a>, <a class="el" href="_vfx_manual_emitter_set_2main_8cpp-example.html#a38">VfxManualEmitterSet/main.cpp</a>, and <a class="el" href="_vfx_simple_2main_8cpp-example.html#a105">VfxSimple/main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab32747bc56d48f93666e0548ef312585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab32747bc56d48f93666e0548ef312585">&#9670;&nbsp;</a></span>RadianToDegree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::RadianToDegree </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radian</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an angle from radian to degrees representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">radian</td><td>Angle (in radians).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_vfx_simple_2main_8cpp-example.html#a106">VfxSimple/main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a6b160179ea31b4eaf41284e73b925f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b160179ea31b4eaf41284e73b925f6a">&#9670;&nbsp;</a></span>AngleIndexToRadian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::AngleIndexToRadian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a>&#160;</td>
          <td class="paramname"><em>angleIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an angle from index to radian representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">angleIndex</td><td>Angle (in index representation).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. </dd></dl>

</div>
</div>
<a id="a07cc37b32cbeec92b9ad379e0e8a7a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07cc37b32cbeec92b9ad379e0e8a7a53">&#9670;&nbsp;</a></span>AngleIndexToDegree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::AngleIndexToDegree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a>&#160;</td>
          <td class="paramname"><em>angleIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an angle from index to degrees representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">angleIndex</td><td>Angle (in index representation).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. </dd></dl>

</div>
</div>
<a id="a115590ce3ee8638bc4a1c7e561b58209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115590ce3ee8638bc4a1c7e561b58209">&#9670;&nbsp;</a></span>SinEst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::SinEst </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radian</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the sine value by polynomial approximation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">radian</td><td>Angle (in radians).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__game_8cpp-example.html#a18">HidControllerSequence/HidControllerSequence_Game.cpp</a>, <a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__title_8cpp-example.html#a21">HidControllerSequence/HidControllerSequence_Title.cpp</a>, and <a class="el" href="_vfx_manual_emitter_set_2main_8cpp-example.html#a39">VfxManualEmitterSet/main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="abdd65f177dec24038d8e796993dd6f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd65f177dec24038d8e796993dd6f19">&#9670;&nbsp;</a></span>SinTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::SinTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a>&#160;</td>
          <td class="paramname"><em>angleIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the sine value by table lookup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">angleIndex</td><td>Angle (in index representation).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. </dd></dl>

</div>
</div>
<a id="a68268124ed7f0d8881db3fcebd01687f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68268124ed7f0d8881db3fcebd01687f">&#9670;&nbsp;</a></span>CosEst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::CosEst </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radian</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the cosine value by polynomial approximation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">radian</td><td>Angle (in radians).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_vfx_manual_emitter_set_2main_8cpp-example.html#a40">VfxManualEmitterSet/main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a90ba79c433fb71aa611fbead84b2c5a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ba79c433fb71aa611fbead84b2c5a3">&#9670;&nbsp;</a></span>CosTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::CosTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a>&#160;</td>
          <td class="paramname"><em>angleIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the cosine value by table lookup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">angleIndex</td><td>Angle (in index representation).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. </dd></dl>

</div>
</div>
<a id="a32ba5bc072eae44853ce61976d55b001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ba5bc072eae44853ce61976d55b001">&#9670;&nbsp;</a></span>SinCosEst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::util::SinCosEst </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pOutSin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pOutCos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the sine and cosine value by polynomial approximation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSin</td><td>Location to store the sine value. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutCos</td><td>Location to store the cosine value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radian</td><td>Angle (in radians). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_atk_sound3_d_2_atk_sound3_d_8cpp-example.html#a12">AtkSound3D/AtkSound3D.cpp</a>, and <a class="el" href="_vfx_simple_2main_8cpp-example.html#a104">VfxSimple/main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a168e5f5b41ec5ecd60c6f88b6aea163e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168e5f5b41ec5ecd60c6f88b6aea163e">&#9670;&nbsp;</a></span>SinCosTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::util::SinCosTable </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pOutSin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pOutCos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a>&#160;</td>
          <td class="paramname"><em>angleIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the sine and cosine value by table lookup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSin</td><td>Location to store the sine value. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutCos</td><td>Location to store the cosine value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angleIndex</td><td>Angle (in index representation). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cdc076bfbd01224d54074c1f312165b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cdc076bfbd01224d54074c1f312165b">&#9670;&nbsp;</a></span>TanEst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::TanEst </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radian</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the tangent value by polynomial approximation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">radian</td><td>Angle (in radians).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_parallel_8cpp-example.html#a6">G3dDemo/Parallel.cpp</a>, and <a class="el" href="_g3d_demo_2_town_8cpp-example.html#a306">G3dDemo/Town.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab8ac3cee8ff11403595c42268db119ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ac3cee8ff11403595c42268db119ff">&#9670;&nbsp;</a></span>TanTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::TanTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a>&#160;</td>
          <td class="paramname"><em>angleIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the tangent value by table lookup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">angleIndex</td><td>Angle (in index representation).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. </dd></dl>

</div>
</div>
<a id="a2699f371e3d783b78039ec8ac527de7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2699f371e3d783b78039ec8ac527de7b">&#9670;&nbsp;</a></span>AtanEst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::AtanEst </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the cotangent value by polynomial approximation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Tangent value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. </dd></dl>

</div>
</div>
<a id="a1f23a5881abd9cc0bea5d1373a5f11e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f23a5881abd9cc0bea5d1373a5f11e6">&#9670;&nbsp;</a></span>AtanTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a> nn::util::AtanTable </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the cotangent value by table lookup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Tangent value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. </dd></dl>

</div>
</div>
<a id="a0a7efae0dfa5a73c71deeadd9665477d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7efae0dfa5a73c71deeadd9665477d">&#9670;&nbsp;</a></span>Atan2Est()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::Atan2Est </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the cotangent value by polynomial approximation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Value Y. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Value X.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. </dd></dl>

</div>
</div>
<a id="a9c57759e10ba45d38bb7377edd0115a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c57759e10ba45d38bb7377edd0115a3">&#9670;&nbsp;</a></span>Atan2Table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a> nn::util::Atan2Table </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the cotangent value by table lookup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Value Y. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Value X.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. </dd></dl>

</div>
</div>
<a id="a04c37527d1019f795ee78f5b51e9cd66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c37527d1019f795ee78f5b51e9cd66">&#9670;&nbsp;</a></span>AsinEst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::AsinEst </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the arctangent value by polynomial approximation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Tangent value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. </dd></dl>

</div>
</div>
<a id="aae6f39eabcabdbeaed5c5eeecd012a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae6f39eabcabdbeaed5c5eeecd012a81">&#9670;&nbsp;</a></span>AsinTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a> nn::util::AsinTable </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the arctangent value by table lookup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Tangent value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. </dd></dl>

</div>
</div>
<a id="af69079f75685a291d46ba591ddb60bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69079f75685a291d46ba591ddb60bbd">&#9670;&nbsp;</a></span>AcosEst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::AcosEst </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the arccosine value by polynomial approximation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Cosine value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. </dd></dl>

</div>
</div>
<a id="a13b10c3b5e379f2215fe0e65428e8543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b10c3b5e379f2215fe0e65428e8543">&#9670;&nbsp;</a></span>AcosTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a> nn::util::AcosTable </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the arccosine value by table lookup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Cosine value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. </dd></dl>

</div>
</div>
<a id="aee333695e4a66942a628f67d238c5fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee333695e4a66942a628f67d238c5fb3">&#9670;&nbsp;</a></span>Rcp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::Rcp </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the inverse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_skeletal_animation_8cpp-example.html#a29">G3dDemo/SkeletalAnimation.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a6eb31608117aba6428f8ad885f520594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb31608117aba6428f8ad885f520594">&#9670;&nbsp;</a></span>RcpLowPrecision()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::RcpLowPrecision </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the inverse. </p>
<p>Applies the correction the specified number of times. Has lower precision than <code><a class="el" href="namespacenn_1_1util.html#aee333695e4a66942a628f67d238c5fb3" title="Finds the inverse.">Rcp()</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>Number of times to apply correction</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Value.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
 Depending on the platform, you may be able to trade precision for a faster execution speed. This function is provided to allow optimization in those cases. </p>

</div>
</div>
<a id="a0c2724ddb1495e6daec879773fdd3fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2724ddb1495e6daec879773fdd3fe8">&#9670;&nbsp;</a></span>Rsqrt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::Rsqrt </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the inverse of the square root. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. </dd></dl>

</div>
</div>
<a id="a3bcdeefaffc5e1034d28f7a0be702075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bcdeefaffc5e1034d28f7a0be702075">&#9670;&nbsp;</a></span>RsqrtLowPrecision()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::RsqrtLowPrecision </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the inverse of the square root Applies the correction the specified number of times. </p>
<p>Has lower precision than <code><a class="el" href="namespacenn_1_1util.html#a0c2724ddb1495e6daec879773fdd3fe8" title="Finds the inverse of the square root.">Rsqrt()</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>Number of times to apply correction</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result.</dd></dl>
<p> <b>Details</b> <br  />
 Depending on the platform, you may be able to trade precision for a faster execution speed. This function is provided to allow optimization in those cases. </p>

</div>
</div>
<a id="a43d2e581fa3899d8d501a038439df039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d2e581fa3899d8d501a038439df039">&#9670;&nbsp;</a></span>AreEqualAbs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::AreEqualAbs </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>absError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an equivalence test using an absolute error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Value 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Value 2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">absError</td><td>Allowable error range by absolute error.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000013">Return Values:</a></b></dt><dd><p class="startdd"><b>true</b> The values are equal. <br  />
 </p>
<p class="enddd"><b>false</b> The values are not equal. </p>
</dd></dl>

</div>
</div>
<a id="a7b2aa31b9b31c32958457d65f11b7987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b2aa31b9b31c32958457d65f11b7987">&#9670;&nbsp;</a></span>AreEqualRelative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::AreEqualRelative </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>relativeError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an equivalence test using relative error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Value 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Value 2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relativeError</td><td>Allowable error range by relative error.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000014">Return Values:</a></b></dt><dd><p class="startdd"><b>true</b> The values are equal. <br  />
 </p>
<p class="enddd"><b>false</b> The values are not equal. </p>
</dd></dl>

</div>
</div>
<a id="aa41b86bc679691f454362ad06c268cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa41b86bc679691f454362ad06c268cb4">&#9670;&nbsp;</a></span>AreEqual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::AreEqual </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an equivalence test using absolute or relative error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Value 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Value 2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error</td><td>Allowable error range by absolute or relative error.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000015">Return Values:</a></b></dt><dd><p class="startdd"><b>true</b> The values are equal. <br  />
 </p>
<p class="enddd"><b>false</b> The values are not equal.</p>
</dd></dl>
<p> <b>Details</b> <br  />
 I both value 1 and value 2 are less than 1, it is handled as an absolute error. If any of the values are greater than 1, it is handled as a relative error in the equivalence test. </p>

</div>
</div>
<a id="ab723010d6f6c3b24dff210397f182b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab723010d6f6c3b24dff210397f182b4c">&#9670;&nbsp;</a></span>MakeBitFlagSet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename Tag &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">BitFlagSet</a>&lt;N, Tag&gt; nn::util::MakeBitFlagSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a <code><a class="el" href="structnn_1_1util_1_1_bit_flag_set.html" title="A type for handling a POD bit flag set.">BitFlagSet</a></code> with all bit flags initialized to <code>false</code>. </p>
<p> <b>Details</b> <br  />
 This function allocates an automatic variable and returns a copy of it by value. Note the large stack size when the <code><em>N</em></code> value is large.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns a bit flag set with all of the bit flags set to <code>false</code>. </dd></dl>

</div>
</div>
<a id="ac768464556e17a3023cc828247c64796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac768464556e17a3023cc828247c64796">&#9670;&nbsp;</a></span>MakeBitFlagSet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">BitFlagSet</a>&lt;N, void&gt; nn::util::MakeBitFlagSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a <code><a class="el" href="structnn_1_1util_1_1_bit_flag_set.html" title="A type for handling a POD bit flag set.">BitFlagSet</a></code> with all bit flags initialized to <code>false</code>. </p>
<p> <b>Details</b> <br  />
 This function allocates an automatic variable and returns a copy of it by value. Note the large stack size when the <code><em>N</em></code> value is large.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns a bit flag set with all of the bit flags set to <code>false</code>. </dd></dl>

</div>
</div>
<a id="a442cc38c3c616eee03f1b66743376fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a442cc38c3c616eee03f1b66743376fa3">&#9670;&nbsp;</a></span>reverse_bits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::reverse_bits </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subword_bits</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_swar_words</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Treats the value as a bit array and inverts the bit order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The numerical value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The value to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subword_bits</td><td>The unit of the bit order to flip. The default is <code>1</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_swar_words</td><td>The number of groups that bit arrays are split into. The default is <code>1</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>- <code>0</code> &lt; <code><em>num_swar_words</em></code> &lt;= <a class="el" href="nn___macro_8h.html#a23315db1de12907672e0e65f9211dda0">NN_BITSIZEOF</a>( <code><em>T</em></code> ).<ul>
<li><code><a class="el" href="nn___macro_8h.html#a23315db1de12907672e0e65f9211dda0">NN_BITSIZEOF(T )</a></code> % <code><em>num_swar_words</em></code> == <code>0</code>.</li>
<li><code>0</code> &lt; <code><em>subword_bits</em></code> &lt;= <a class="el" href="nn___macro_8h.html#a23315db1de12907672e0e65f9211dda0">NN_BITSIZEOF</a>( <code><em>T</em></code> ).</li>
<li>( <code><a class="el" href="nn___macro_8h.html#a23315db1de12907672e0e65f9211dda0">NN_BITSIZEOF(T)</a></code> / <code><em>num_swar_words</em></code> ) % <code><em>subword_bits</em></code> == <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The bit array is split into <code><em>num_swar_words</em></code> groups. Within these groups, <code>subword_bits</code> subgroups of bits are made, and the order of subgroups is flipped. The order of the group does not change, and the bit order within the subgroups does not change.</p>
<p>Example: An 8-bit array of ABCDEFGH results in the following.</p><ul>
<li><code>reverse_bits(ABCDEFGH)</code> -&gt; <code>HGFEDCBA</code></li>
<li><code>reverse_bits(ABCDEFGH, 1, 2)</code> -&gt; <code>DCBAHGFE</code></li>
<li><code>reverse_bits(ABCDEFGH, 1, 4)</code> -&gt; <code>BADCFEHG</code></li>
<li><code>reverse_bits(ABCDEFGH, 2, 1)</code> -&gt; <code>GHEFCDAB</code></li>
<li><code>reverse_bits(ABCDEFGH, 2, 2)</code> -&gt; <code>CDABGHEF</code></li>
<li><code>reverse_bits(ABCDEFGH, 4, 1)</code> -&gt; <code>EFGHABCD</code> </li>
</ul>

</div>
</div>
<a id="aec88a4a55dad4af44a729577bb2798f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec88a4a55dad4af44a729577bb2798f9">&#9670;&nbsp;</a></span>reverse_bytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::reverse_bytes </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subword_bytes</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_swar_words</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Treats the value as a byte array and inverts the byte order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The numerical value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The value to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subword_bytes</td><td>The unit of the byte order to flip. The default is <code>1</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_swar_words</td><td>The number of groups that byte arrays are split into. The default is <code>1</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>- <code>0</code> &lt; <code><em>num_swar_words</em></code> &lt;= <code>sizeof( <em>T</em> )</code>.<ul>
<li>sizeof(<code>T</code>) % <code><em>num_swar_words</em></code> == <code>0</code>.</li>
<li><code>0</code> &lt; <code><em>subword_bytes</em></code> &lt;= <code>sizeof( <em>T</em> )</code>.</li>
<li>( sizeof(<code>T</code>) / <code><em>num_swar_words</em></code> ) % <code><em>subword_bytes</em></code> == <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The byte array is split into <code><em>num_swar_words</em></code> groups. Within these groups, <code>subword_bytes</code> subgroups of bytes are made, and the order of subgroups is flipped. The order of the group does not change, and the byte order within the subgroups does not change.</p>
<p>Example: An 8-byte array of ABCDEFGH results in the following.</p><ul>
<li><code>reverse_bytes(ABCDEFGH)</code> -&gt; <code>HGFEDCBA</code></li>
<li><code>reverse_bytes(ABCDEFGH, 1, 2)</code> -&gt; <code>DCBAHGFE</code></li>
<li><code>reverse_bytes(ABCDEFGH, 1, 4)</code> -&gt; <code>BADCFEHG</code></li>
<li><code>reverse_bytes(ABCDEFGH, 2, 1)</code> -&gt; <code>GHEFCDAB</code></li>
<li><code>reverse_bytes(ABCDEFGH, 2, 2)</code> -&gt; <code>CDABGHEF</code></li>
<li><code>reverse_bytes(ABCDEFGH, 4, 1)</code> -&gt; <code>EFGHABCD</code> </li>
</ul>

</div>
</div>
<a id="a861c56e3f44d1b1d2cd238efffb5c566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861c56e3f44d1b1d2cd238efffb5c566">&#9670;&nbsp;</a></span>is_aligned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool nn::util::is_aligned </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the value fits the specified alignment. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The numerical value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The value to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">align</td><td>The alignment to specify. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>align</em></code> must be a power of 2. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a94">AudioMemoryPool/AudioMemoryPool.cpp</a>, and <a class="el" href="_gfx_primitive_renderer_2_gfx_primitive_renderer_8cpp-example.html#a213">GfxPrimitiveRenderer/GfxPrimitiveRenderer.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a275a3c89db5d0ab915559d8a85f9cbdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a275a3c89db5d0ab915559d8a85f9cbdd">&#9670;&nbsp;</a></span>align_up()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T nn::util::align_up </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds up a value so that it fits the specified alignment. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The numerical value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The value to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">align</td><td>The alignment to specify. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>align</em></code> must be a power of 2. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a80">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a46">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a56">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a62">AudioOut/AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_2_audio_out_with_resampler_8cpp-example.html#a60">AudioOutWithResampler/AudioOutWithResampler.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a78">AudioSink/AudioSink.cpp</a>, <a class="el" href="_codec_aac_decoder_2_codec_aac_decoder_8cpp-example.html#a29">CodecAacDecoder/CodecAacDecoder.cpp</a>, <a class="el" href="_ec_purchased_event_2_main_8cpp-example.html#a2">EcPurchasedEvent/Main.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#a42">FontDemo/Main.cpp</a>, <a class="el" href="_framework_demo_2_main_8cpp-example.html#a29">FrameworkDemo/Main.cpp</a>, <a class="el" href="_g3d_demo_2_shape_animation_8cpp-example.html#a69">G3dDemo/ShapeAnimation.cpp</a>, <a class="el" href="_gfx_primitive_renderer_2_gfx_primitive_renderer_8cpp-example.html#a40">GfxPrimitiveRenderer/GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_gfx_shader_compile_2_gfx_shader_compile_8cpp-example.html#a28">GfxShaderCompile/GfxShaderCompile.cpp</a>, <a class="el" href="_gfx_simple_2_gfx_simple_8cpp-example.html#a38">GfxSimple/GfxSimple.cpp</a>, <a class="el" href="_gfx_simple_compute_2_gfx_simple_compute_8cpp-example.html#a23">GfxSimpleCompute/GfxSimpleCompute.cpp</a>, <a class="el" href="_hid_gesture_2_hid_gesture__main_8cpp-example.html#a2">HidGesture/HidGesture_Main.cpp</a>, <a class="el" href="_hid_keyboard_and_mouse_2_hid_keyboard_and_mouse__main_8cpp-example.html#a19">HidKeyboardAndMouse/HidKeyboardAndMouse_Main.cpp</a>, <a class="el" href="_hid_npad_six_axis_sensor_2_hid_npad_six_axis_sensor__main_8cpp-example.html#a72">HidNpadSixAxisSensor/HidNpadSixAxisSensor_Main.cpp</a>, <a class="el" href="_hid_simple_2_hid_simple__main_8cpp-example.html#a12">HidSimple/HidSimple_Main.cpp</a>, <a class="el" href="_hid_vibration_generator_2_hid_vibration_generator_8cpp-example.html#a43">HidVibrationGenerator/HidVibrationGenerator.cpp</a>, <a class="el" href="_hid_vibration_player_2_hid_vibration_player_8cpp-example.html#a34">HidVibrationPlayer/HidVibrationPlayer.cpp</a>, <a class="el" href="_imgui_demo_2_imgui_demo_8cpp-example.html#a51">ImguiDemo/ImguiDemo.cpp</a>, <a class="el" href="_imgui_simple_2_imgui_simple_8cpp-example.html#a27">ImguiSimple/ImguiSimple.cpp</a>, <a class="el" href="_mii_compressed_texture_2_mii_compressed_texture_8cpp-example.html#a55">MiiCompressedTexture/MiiCompressedTexture.cpp</a>, <a class="el" href="_mii_database_2_mii_database_8cpp-example.html#a53">MiiDatabase/MiiDatabase.cpp</a>, <a class="el" href="_mii_dynamic_mask_2_mii_dynamic_mask_8cpp-example.html#a56">MiiDynamicMask/MiiDynamicMask.cpp</a>, <a class="el" href="_mii_g3d_headwear_2_mii_g3d_headwear_8cpp-example.html#a323">MiiG3dHeadwear/MiiG3dHeadwear.cpp</a>, <a class="el" href="_mii_g3d_simple_2_mii_g3d_simple_8cpp-example.html#a308">MiiG3dSimple/MiiG3dSimple.cpp</a>, <a class="el" href="_mii_headwear_example_2_mii_headwear_example_8cpp-example.html#a68">MiiHeadwearExample/MiiHeadwearExample.cpp</a>, <a class="el" href="_mii_mip_map_2_mii_mip_map_8cpp-example.html#a52">MiiMipMap/MiiMipMap.cpp</a>, <a class="el" href="_mii_premultiplied_alpha_icon_2_mii_premultiplied_alpha_icon_8cpp-example.html#a67">MiiPremultipliedAlphaIcon/MiiPremultipliedAlphaIcon.cpp</a>, <a class="el" href="_mii_shader_example_2_mii_shader_example_8cpp-example.html#a56">MiiShaderExample/MiiShaderExample.cpp</a>, <a class="el" href="_mii_simple_2_mii_simple_8cpp-example.html#a53">MiiSimple/MiiSimple.cpp</a>, <a class="el" href="_mii_simple_icon_2_mii_simple_icon_8cpp-example.html#a67">MiiSimpleIcon/MiiSimpleIcon.cpp</a>, <a class="el" href="_mii_simple_icon_body_2_mii_simple_icon_body_8cpp-example.html#a67">MiiSimpleIconBody/MiiSimpleIconBody.cpp</a>, <a class="el" href="_mii_simple_variable_icon_body_2_mii_simple_variable_icon_body_8cpp-example.html#a69">MiiSimpleVariableIconBody/MiiSimpleVariableIconBody.cpp</a>, <a class="el" href="_mii_system_resource_2_mii_system_resource_8cpp-example.html#a53">MiiSystemResource/MiiSystemResource.cpp</a>, <a class="el" href="_mii_transparent_adjuster_2_mii_transparent_adjuster_8cpp-example.html#a67">MiiTransparentAdjuster/MiiTransparentAdjuster.cpp</a>, <a class="el" href="_multi_program_application_2_main_2_main_8cpp-example.html#a2">MultiProgramApplication/Main/Main.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_graphics_context_8cpp-example.html#a25">NvnSimple/NvnSimpleSharedLib/GraphicsContext.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_graphics_memory_pool_8cpp-example.html#a10">NvnSimple/NvnSimpleSharedLib/GraphicsMemoryPool.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_graphics_shader_8cpp-example.html#a25">NvnSimple/NvnSimpleSharedLib/GraphicsShader.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_simple_text_renderer_8cpp-example.html#a9">NvnSimple/NvnSimpleSharedLib/SimpleTextRenderer.cpp</a>, <a class="el" href="_nvn_simple02_world_space_triangles_2_world_space_triangles_8cpp-example.html#a2">NvnSimple02WorldSpaceTriangles/WorldSpaceTriangles.cpp</a>, <a class="el" href="_nvn_simple03_textured_cube_2_textured_cube_8cpp-example.html#a2">NvnSimple03TexturedCube/TexturedCube.cpp</a>, <a class="el" href="_nvn_simple07_dynamic_resolution_2_dynamic_resolution_8cpp-example.html#a2">NvnSimple07DynamicResolution/DynamicResolution.cpp</a>, <a class="el" href="_nvn_tutorial_2_tutorial_base_class_8_nx_8cpp-example.html#a1">NvnTutorial/TutorialBaseClass.Nx.cpp</a>, <a class="el" href="_pcm_basic_2_pcm_basic_8cpp-example.html#a11">PcmBasic/PcmBasic.cpp</a>, <a class="el" href="_swkbd_simple_2_swkbd_simple_8cpp-example.html#a2">SwkbdSimple/SwkbdSimple.cpp</a>, <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#a58">Ui2dDemo/Main.cpp</a>, <a class="el" href="_ui2d_viewer_simple_2main_8cpp-example.html#a158">Ui2dViewerSimple/main.cpp</a>, <a class="el" href="_vfx_custom_shader_2main_8cpp-example.html#a11">VfxCustomShader/main.cpp</a>, <a class="el" href="_vi_timestamp_2_vi_timestamp_8cpp-example.html#a10">ViTimestamp/ViTimestamp.cpp</a>, <a class="el" href="_vk_simple_2_vk_simple_8cpp-example.html#a19">VkSimple/VkSimple.cpp</a>, and <a class="el" href="_web_socket_chat_2_web_socket_chat_8cpp-example.html#a45">WebSocketChat/WebSocketChat.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac7655ccdb1f67a75ae553c06dec485b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7655ccdb1f67a75ae553c06dec485b3">&#9670;&nbsp;</a></span>align_down()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T nn::util::align_down </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds down a value so that it fits the specified alignment. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The numerical value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The value to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">align</td><td>The alignment to specify. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>align</em></code> must be a power of 2. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_fs_file_data_cache_2_fs_global_file_data_cache_default_disabled_2_fs_global_file_data_cache_default_disabled_8cpp-example.html#a4">FsFileDataCache/FsGlobalFileDataCacheDefaultDisabled/FsGlobalFileDataCacheDefaultDisabled.cpp</a>, <a class="el" href="_fs_file_data_cache_2_fs_global_file_data_cache_manually_enabled_2_fs_global_file_data_cache_manually_enabled_8cpp-example.html#a4">FsFileDataCache/FsGlobalFileDataCacheManuallyEnabled/FsGlobalFileDataCacheManuallyEnabled.cpp</a>, <a class="el" href="_fs_file_data_cache_2_fs_individual_file_data_cache_2_fs_individual_file_data_cache_8cpp-example.html#a29">FsFileDataCache/FsIndividualFileDataCache/FsIndividualFileDataCache.cpp</a>, <a class="el" href="_gfx_primitive_renderer_2_gfx_primitive_renderer_8cpp-example.html#a44">GfxPrimitiveRenderer/GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_mii_compressed_texture_2_mii_compressed_texture_8cpp-example.html#a31">MiiCompressedTexture/MiiCompressedTexture.cpp</a>, <a class="el" href="_mii_database_2_mii_database_8cpp-example.html#a29">MiiDatabase/MiiDatabase.cpp</a>, <a class="el" href="_mii_dynamic_mask_2_mii_dynamic_mask_8cpp-example.html#a32">MiiDynamicMask/MiiDynamicMask.cpp</a>, <a class="el" href="_mii_headwear_example_2_mii_headwear_example_8cpp-example.html#a44">MiiHeadwearExample/MiiHeadwearExample.cpp</a>, <a class="el" href="_mii_mip_map_2_mii_mip_map_8cpp-example.html#a28">MiiMipMap/MiiMipMap.cpp</a>, <a class="el" href="_mii_premultiplied_alpha_icon_2_mii_premultiplied_alpha_icon_8cpp-example.html#a45">MiiPremultipliedAlphaIcon/MiiPremultipliedAlphaIcon.cpp</a>, <a class="el" href="_mii_shader_example_2_mii_shader_example_8cpp-example.html#a32">MiiShaderExample/MiiShaderExample.cpp</a>, <a class="el" href="_mii_simple_2_mii_simple_8cpp-example.html#a29">MiiSimple/MiiSimple.cpp</a>, <a class="el" href="_mii_simple_icon_2_mii_simple_icon_8cpp-example.html#a45">MiiSimpleIcon/MiiSimpleIcon.cpp</a>, <a class="el" href="_mii_simple_icon_body_2_mii_simple_icon_body_8cpp-example.html#a45">MiiSimpleIconBody/MiiSimpleIconBody.cpp</a>, <a class="el" href="_mii_simple_variable_icon_body_2_mii_simple_variable_icon_body_8cpp-example.html#a47">MiiSimpleVariableIconBody/MiiSimpleVariableIconBody.cpp</a>, <a class="el" href="_mii_system_resource_2_mii_system_resource_8cpp-example.html#a29">MiiSystemResource/MiiSystemResource.cpp</a>, <a class="el" href="_mii_transparent_adjuster_2_mii_transparent_adjuster_8cpp-example.html#a45">MiiTransparentAdjuster/MiiTransparentAdjuster.cpp</a>, and <a class="el" href="_os_user_exception_handler_sample_8cpp-example.html#a35">OsUserExceptionHandlerSample.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a2eb809a8e954ba2fc39656ecae6678a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb809a8e954ba2fc39656ecae6678a9">&#9670;&nbsp;</a></span>rstls1b()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T nn::util::rstls1b </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turns the least significant 1 bit off. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The numerical value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The value to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result.</dd></dl>
<p> <b>Details</b> <br  />
 Example: 1100 1100 -&gt; 1100 1000 </p>

</div>
</div>
<a id="ac8866603a7784a4f22e559dd68000b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8866603a7784a4f22e559dd68000b1d">&#9670;&nbsp;</a></span>setls0b()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T nn::util::setls0b </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turns the least significant 0 bit on. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The numerical value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The value to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result.</dd></dl>
<p> <b>Details</b> <br  />
 Example: 0011 0011 -&gt; 0011 0111 </p>

</div>
</div>
<a id="a176ee70c2615c58d6d847f799d09d269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176ee70c2615c58d6d847f799d09d269">&#9670;&nbsp;</a></span>rstt1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T nn::util::rstt1 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turns the least significant contiguous 1 bits off. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The numerical value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The value to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result.</dd></dl>
<p> <b>Details</b> <br  />
 Example: 0011 0011 -&gt; 0011 0000 </p>

</div>
</div>
<a id="a9afe44169cc12424c76a39802f7466c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9afe44169cc12424c76a39802f7466c2">&#9670;&nbsp;</a></span>sett0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T nn::util::sett0 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turns the least significant contiguous 0 bits on. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The numerical value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The value to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result.</dd></dl>
<p> <b>Details</b> <br  />
 Example: 1100 1100 -&gt; 1100 1111 </p>

</div>
</div>
<a id="ae84ef386689dc5a13122b41e5e98ddfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84ef386689dc5a13122b41e5e98ddfb">&#9670;&nbsp;</a></span>isols1b()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T nn::util::isols1b </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the least significant 1 bit. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The numerical value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The value to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result.</dd></dl>
<p> <b>Details</b> <br  />
 Example: 1100 1100 -&gt; 0000 0100 </p>

</div>
</div>
<a id="a8365af3d7513b7f0722e3e8cb7914fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8365af3d7513b7f0722e3e8cb7914fc9">&#9670;&nbsp;</a></span>isols0b()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T nn::util::isols0b </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the least significant 0 bit. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The numerical value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The value to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result.</dd></dl>
<p> <b>Details</b> <br  />
 Example: 0011 0011 -&gt; 0000 0100 </p>

</div>
</div>
<a id="ab8e94fbf3801cdcc9b0858fa47da13ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e94fbf3801cdcc9b0858fa47da13ff">&#9670;&nbsp;</a></span>maskt1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T nn::util::maskt1 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the least significant contiguous 1 bits. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The numerical value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The value to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result.</dd></dl>
<p> <b>Details</b> <br  />
 Example: 0011 0011 -&gt; 0000 0011 </p>

</div>
</div>
<a id="a9e78c1e6a9d8e1762feee41e8d371fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e78c1e6a9d8e1762feee41e8d371fae">&#9670;&nbsp;</a></span>maskt0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T nn::util::maskt0 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the least significant contiguous 0 bits. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The numerical value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The value to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result.</dd></dl>
<p> <b>Details</b> <br  />
 Example: 1100 1100 -&gt; 0000 0011 </p>

</div>
</div>
<a id="a5c4a7f29daa34673f422f59dd5676d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c4a7f29daa34673f422f59dd5676d61">&#9670;&nbsp;</a></span>maskt1ls0b()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T nn::util::maskt1ls0b </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the least significant contiguous 0 bits and the least significant 1 bit. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The numerical value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The value to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result.</dd></dl>
<p> <b>Details</b> <br  />
 Example: 0011 0011 -&gt; 0000 0111 </p>

</div>
</div>
<a id="a20a877edfa35460f2ee3ee65e7c5ebef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a877edfa35460f2ee3ee65e7c5ebef">&#9670;&nbsp;</a></span>maskt0ls1b()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T nn::util::maskt0ls1b </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the least significant contiguous 0 bits and the least significant 1 bit. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The numerical value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The value to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result.</dd></dl>
<p> <b>Details</b> <br  />
 Example: 1100 1100 -&gt; 0000 0111 </p>

</div>
</div>
<a id="a4261256ed6137be521e732071fb8b85c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4261256ed6137be521e732071fb8b85c">&#9670;&nbsp;</a></span>popcount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int nn::util::popcount </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counts the number of 1 bits. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The numerical value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The value to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. </dd></dl>

</div>
</div>
<a id="a09155ce274d53c9d706169219629cee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09155ce274d53c9d706169219629cee4">&#9670;&nbsp;</a></span>cntl0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int nn::util::cntl0 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of contiguous bits set to <code>0</code>, starting from the most significant bit (MSB). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The numerical value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The value to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. <code>cntl0(0)</code> returns the bit size of <code><em>T</em></code>. </dd></dl>

</div>
</div>
<a id="a4642bc633f78d038517013a18982c8ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4642bc633f78d038517013a18982c8ff">&#9670;&nbsp;</a></span>cntt0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int nn::util::cntt0 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of contiguous bits set to <code>0</code>, starting from the least significant bit (LSB). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The numerical value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The value to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. <code>cntt0(0)</code> returns the bit size of <code><em>T</em></code>. </dd></dl>

</div>
</div>
<a id="ad4feb9f54abaf03efac1882558b18124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4feb9f54abaf03efac1882558b18124">&#9670;&nbsp;</a></span>ispow2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool nn::util::ispow2 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the specified value is a power of two. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The numerical value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The value to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if <code><em>x</em></code> is a positive exponent of two. Returns <code>false</code> if <code><em>x</em></code> is <code>0</code>. </dd></dl>

</div>
</div>
<a id="a860cd0664ce80ad4e4e35216bbd6d730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860cd0664ce80ad4e4e35216bbd6d730">&#9670;&nbsp;</a></span>floorp2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T nn::util::floorp2 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the largest power of two that is less than the specified value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The numerical value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The value to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>x</em></code> &gt; <code>0</code>. </dd></dl>

</div>
</div>
<a id="a015b53fd16251a5c66d7ccd4311fb271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015b53fd16251a5c66d7ccd4311fb271">&#9670;&nbsp;</a></span>ceilp2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T nn::util::ceilp2 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the smallest power of two that is greater than the specified value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The numerical value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The value to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>x</em></code> &gt; <code>0</code>. </dd></dl>

</div>
</div>
<a id="a2bd03e3714423c80630b178f82d9d66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd03e3714423c80630b178f82d9d66b">&#9670;&nbsp;</a></span>DivideUp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T nn::util::DivideUp </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>divider</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds up the value and divides the value by the specified value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Dividend data type. </td></tr>
    <tr><td class="paramname">U</td><td>Divisor data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Dividend. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">divider</td><td>Divisor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>x</em></code> &gt;= <code>0</code>.</li>
<li><code><em>divider</em></code> &gt; <code>0</code>.</li>
<li><code><em>x</em></code> + <code><em>divider</em></code> - <code>1</code> &lt;= <code>std::numeric_limits&lt;decltype(T(0)+U(0))&gt;::max()</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac299aadfc2d647eddfb7b48a002497d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac299aadfc2d647eddfb7b48a002497d4">&#9670;&nbsp;</a></span>ConvertStringUtf8ToUtf16Native() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertStringUtf8ToUtf16Native </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts from UTF-8 to UTF-16. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Conversion result array. No terminating character is added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstLength</td><td>The length of the conversion result array. The length of the <code>*<em>pDst</em></code> type conversion (buffer size divided by type size). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcLength</td><td>The length of the conversion source array. The length of the <code>*<em>pSrc</em></code> type conversion (buffer size divided by type size).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000016">Return Values:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - Converted normally. <br  />
 </p>
<p class="interdd"><b>CharacterEncodingResult_InsufficientLength</b> - The conversion result array was not long enough. <br  />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - A character that cannot be converted was detected. </p>
</dd></dl>
<p> <b>Details</b> <br  />
 Processes the amount of data specified by <code><em>srcLength</em></code>, regardless of whether the conversion source array includes a terminating character. Note that the terminating character is not added to the end of <code><em>pDst</em></code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_util_convert_sjis_2_util_convert_sjis_8cpp-example.html#a4">UtilConvertSjis/UtilConvertSjis.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a88a92f19acba9dae9f4320f851f806a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a92f19acba9dae9f4320f851f806a6">&#9670;&nbsp;</a></span>ConvertStringUtf8ToUtf16Native() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">nn::util::CharacterEncodingResult</a> nn::util::ConvertStringUtf8ToUtf16Native </td>
          <td>(</td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts from UTF-8 to UTF-16. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Conversion result array. No terminating character is added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstLength</td><td>The length of the conversion result array. The length of the <code>*<em>pDst</em></code> type conversion (buffer size divided by type size). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcLength</td><td>The length of the conversion source array. The length of the <code>*<em>pSrc</em></code> type conversion (buffer size divided by type size).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000017">Return Values:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - Converted normally. <br  />
 </p>
<p class="interdd"><b>CharacterEncodingResult_InsufficientLength</b> - The conversion result array was not long enough. <br  />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - A character that cannot be converted was detected. </p>
</dd></dl>
<p> <b>Details</b> <br  />
 Processes the amount of data specified by <code><em>srcLength</em></code>, regardless of whether the conversion source array includes a terminating character. Note that the terminating character is not added to the end of <code><em>pDst</em></code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Can write to [<code><em>pDst</em></code>, <code><em>pDst</em></code> + <code><em>dstLength</em></code>) </dd>
<dd>
<code><em>dstLength</em></code> &gt;= <code>0</code> </dd>
<dd>
Can read [<code><em>pSrc</em></code>, <code><em>pSrc</em></code> + <code><em>srcLength</em></code>) </dd>
<dd>
<code><em>srcLength</em></code> &gt;= <code>0</code> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Converted data is written to [<code><em>pDst</em></code>, <code><em>pDst</em></code> + <code><em>dstLength</em></code>)</dd></dl>
<p> <b>Details</b> <br  />
The character encoding of the specified string is: converted from UTF-8 to UTF-16LE in a little endian environment converted from UTF-8 to UTF-16BE in a big endian environment A termination character is not attached. The UTF-16 handled here contains a surrogate pair. The length of the converted array can be found by using <code><a class="el" href="namespacenn_1_1util.html#a05c6fd4c3ccbb9129b10e6f2f9bed339">GetLengthOfConvertedStringUtf8ToUtf16Native</a></code>. </p>

</div>
</div>
<a id="acb6dd6d63f9069c568f4f9e0a41171c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6dd6d63f9069c568f4f9e0a41171c2">&#9670;&nbsp;</a></span>ConvertStringUtf8ToUtf16Native() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertStringUtf8ToUtf16Native </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts from UTF-8 to UTF-16. </p>
<p>Convert everything up to the terminating character. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Conversion result array. A terminating character is appended. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstLength</td><td>The length of the conversion result array. The length of the <code>*<em>pDst</em></code> type conversion (buffer size divided by type size). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000018">Return Values:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - Converted normally. <br  />
 </p>
<p class="interdd"><b>CharacterEncodingResult_InsufficientLength</b> - The conversion result array was not long enough. <br  />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - A character that cannot be converted was detected. </p>
</dd></dl>
<p> <b>Details</b> <br  />
 If <code><em>pSrc</em></code> is a proper convertible string, the conversion process proceeds until the appearance of the terminating character. Note that the terminating character is added to the end of <code><em>pDst</em></code>. </p>

</div>
</div>
<a id="a97139df706fd2cd0c3a8ce755937bc24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97139df706fd2cd0c3a8ce755937bc24">&#9670;&nbsp;</a></span>ConvertStringUtf8ToUtf16Native() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertStringUtf8ToUtf16Native </td>
          <td>(</td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts from UTF-8 to UTF-16. </p>
<p>Convert everything up to the terminating character. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Conversion result array. A terminating character is appended. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstLength</td><td>The length of the conversion result array. The length of the <code>*<em>pDst</em></code> type conversion (buffer size divided by type size). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000019">Return Values:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - Converted normally. <br  />
 </p>
<p class="interdd"><b>CharacterEncodingResult_InsufficientLength</b> - The conversion result array was not long enough. <br  />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - A character that cannot be converted was detected. </p>
</dd></dl>
<p> <b>Details</b> <br  />
 If <code><em>pSrc</em></code> is a proper convertible string, the conversion process proceeds until the appearance of the terminating character. Note that the terminating character is added to the end of <code><em>pDst</em></code>. </p>

</div>
</div>
<a id="a0f7633254c8910e4e0b191121feddd95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7633254c8910e4e0b191121feddd95">&#9670;&nbsp;</a></span>ConvertStringUtf16NativeToUtf8() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertStringUtf16NativeToUtf8 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts from UTF-16 to UTF-8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Conversion result array. No terminating character is added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstLength</td><td>The length of the conversion result array. The length of the <code>*<em>pDst</em></code> type conversion (buffer size divided by type size). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcLength</td><td>The length of the conversion source array. The length of the <code>*<em>pSrc</em></code> type conversion (buffer size divided by type size).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000020">Return Values:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - Converted normally. <br  />
 </p>
<p class="interdd"><b>CharacterEncodingResult_InsufficientLength</b> - The conversion result array was not long enough. <br  />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - A character that cannot be converted was detected. </p>
</dd></dl>
<p> <b>Details</b> <br  />
 Processes the amount of data specified by <code><em>srcLength</em></code>, regardless of whether the conversion source array includes a terminating character. Note that the terminating character is not added to the end of <code><em>pDst</em></code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_util_convert_sjis_2_util_convert_sjis_8cpp-example.html#a3">UtilConvertSjis/UtilConvertSjis.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac0fb7f6e5c70fe4ffab9b7c891631c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0fb7f6e5c70fe4ffab9b7c891631c59">&#9670;&nbsp;</a></span>ConvertStringUtf16NativeToUtf8() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">nn::util::CharacterEncodingResult</a> nn::util::ConvertStringUtf16NativeToUtf8 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts from UTF-16 to UTF-8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Conversion result array. No terminating character is added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstLength</td><td>The length of the conversion result array. The length of the <code>*<em>pDst</em></code> type conversion (buffer size divided by type size). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcLength</td><td>The length of the conversion source array. The length of the <code>*<em>pSrc</em></code> type conversion (buffer size divided by type size).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000021">Return Values:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - Converted normally. <br  />
 </p>
<p class="interdd"><b>CharacterEncodingResult_InsufficientLength</b> - The conversion result array was not long enough. <br  />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - A character that cannot be converted was detected. </p>
</dd></dl>
<p> <b>Details</b> <br  />
 Processes the amount of data specified by <code><em>srcLength</em></code>, regardless of whether the conversion source array includes a terminating character. Note that the terminating character is not added to the end of <code><em>pDst</em></code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Can write to [<code><em>pDst</em></code>, <code><em>pDst</em></code> + <code><em>dstLength</em></code>) </dd>
<dd>
<code><em>dstLength</em></code> &gt;= <code>0</code> </dd>
<dd>
Can read [<code><em>pSrc</em></code>, <code><em>pSrc</em></code> + <code><em>srcLength</em></code>) </dd>
<dd>
<code><em>srcLength</em></code> &gt;= <code>0</code> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Converted data is written to [<code><em>pDst</em></code>, <code><em>pDst</em></code> + <code><em>dstLength</em></code>)</dd></dl>
<p> <b>Details</b> <br  />
The character encoding of the specified string is: converted from UTF-16LE to UTF-8 in a little endian environment converted from UTF-16BE to UTF-8 in a big endian environment A termination character is not attached. The UTF-16 handled here contains a surrogate pair. The length of the converted array can be found by using <code><a class="el" href="namespacenn_1_1util.html#a1fdffba72eb466818e238d6ebb53b0dc">GetLengthOfConvertedStringUtf16NativeToUtf8</a></code>. </p>

</div>
</div>
<a id="a0256928bab392ea72f8d15e3ec6efb7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0256928bab392ea72f8d15e3ec6efb7f">&#9670;&nbsp;</a></span>ConvertStringUtf16NativeToUtf8() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertStringUtf16NativeToUtf8 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts from UTF-16 to UTF-8. </p>
<p>Convert everything up to the terminating character. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Conversion result array. A terminating character is appended. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstLength</td><td>The length of the conversion result array. The length of the <code>*<em>pDst</em></code> type conversion (buffer size divided by type size). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000022">Return Values:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - Converted normally. <br  />
 </p>
<p class="interdd"><b>CharacterEncodingResult_InsufficientLength</b> - The conversion result array was not long enough. <br  />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - A character that cannot be converted was detected. </p>
</dd></dl>
<p> <b>Details</b> <br  />
 If <code><em>pSrc</em></code> is a proper convertible string, the conversion process proceeds until the appearance of the terminating character. Note that the terminating character is added to the end of <code><em>pDst</em></code>. </p>

</div>
</div>
<a id="a64657a9f5c8c791f28227cca1ed94adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64657a9f5c8c791f28227cca1ed94adc">&#9670;&nbsp;</a></span>ConvertStringUtf16NativeToUtf8() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertStringUtf16NativeToUtf8 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts from UTF-16 to UTF-8. </p>
<p>Convert everything up to the terminating character. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Conversion result array. A terminating character is appended. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstLength</td><td>The length of the conversion result array. The length of the <code>*<em>pDst</em></code> type conversion (buffer size divided by type size). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000023">Return Values:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - Converted normally. <br  />
 </p>
<p class="interdd"><b>CharacterEncodingResult_InsufficientLength</b> - The conversion result array was not long enough. <br  />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - A character that cannot be converted was detected. </p>
</dd></dl>
<p> <b>Details</b> <br  />
 If <code><em>pSrc</em></code> is a proper convertible string, the conversion process proceeds until the appearance of the terminating character. Note that the terminating character is added to the end of <code><em>pDst</em></code>. </p>

</div>
</div>
<a id="a05c6fd4c3ccbb9129b10e6f2f9bed339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c6fd4c3ccbb9129b10e6f2f9bed339">&#9670;&nbsp;</a></span>GetLengthOfConvertedStringUtf8ToUtf16Native() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">nn::util::CharacterEncodingResult</a> nn::util::GetLengthOfConvertedStringUtf8ToUtf16Native </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the length of a conversion result array necessary for conversion from UTF-8 to UTF-16. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutLength</td><td>The array length needed to write the string to the conversion result array. The terminating character is not included. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcLength</td><td>The length of the conversion source array. The length of the <code>*<em>pSrc</em></code> type conversion (buffer size divided by type size).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000024">Return Values:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - Converted normally. <br  />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - A character that cannot be converted was detected. </p>
</dd></dl>
<p> <b>Details</b> <br  />
 Processes the amount of data specified by <code><em>srcLength</em></code>, regardless of whether the conversion source array includes a terminating character. Note that if the array that is the source for the conversion does not end with the terminating character, <code><em>pOutLength</em></code> is the length of the array not including the terminating character.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>pOutLength</em></code> != <code>nullptr</code> </dd>
<dd>
Can read [<code><em>pSrc</em></code>, <code><em>pSrc</em></code> + <code><em>srcLength</em></code>) </dd>
<dd>
<code><em>srcLength</em></code> &gt;= <code>0</code> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>*<em>pOutLength</em></code> &gt;= <code>0</code> </dd></dl>

</div>
</div>
<a id="a3722383bf1e035087c9705999921063d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3722383bf1e035087c9705999921063d">&#9670;&nbsp;</a></span>GetLengthOfConvertedStringUtf8ToUtf16Native() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::GetLengthOfConvertedStringUtf8ToUtf16Native </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the length of a conversion result array necessary for conversion from UTF-8 to UTF-16. </p>
<p>Everything up to the terminating character is included. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutLength</td><td>The array length needed to write the string to the conversion result array. The terminating character is not included. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000025">Return Values:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - Converted normally. <br  />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - A character that cannot be converted was detected. </p>
</dd></dl>
<p> <b>Details</b> <br  />
 If <code><em>pSrc</em></code> is a proper convertible string, the obtained length is the length until the appearance of the terminating character. Note that <code><em>pOutLength</em></code> is the length of the array not including the terminating character. </p>

</div>
</div>
<a id="a1fdffba72eb466818e238d6ebb53b0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fdffba72eb466818e238d6ebb53b0dc">&#9670;&nbsp;</a></span>GetLengthOfConvertedStringUtf16NativeToUtf8() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::GetLengthOfConvertedStringUtf16NativeToUtf8 </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the length of a conversion result array necessary for conversion from UTF-16 to UTF-8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutLength</td><td>The array length needed to write the string to the conversion result array. The terminating character is not included. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcLength</td><td>The length of the conversion source array. The length of the <code>*<em>pSrc</em></code> type conversion (buffer size divided by type size).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000026">Return Values:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - Converted normally. <br  />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - A character that cannot be converted was detected. </p>
</dd></dl>
<p> <b>Details</b> <br  />
 Processes the amount of data specified by <code><em>srcLength</em></code>, regardless of whether the conversion source array includes a terminating character. Note that if the array that is the source for the conversion does not end with the terminating character, <code><em>pOutLength</em></code> is the length of the array not including the terminating character. </p>

</div>
</div>
<a id="a0fe7be5c20e746d26c8c86b622b26970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe7be5c20e746d26c8c86b622b26970">&#9670;&nbsp;</a></span>GetLengthOfConvertedStringUtf16NativeToUtf8() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">nn::util::CharacterEncodingResult</a> nn::util::GetLengthOfConvertedStringUtf16NativeToUtf8 </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the length of a conversion result array necessary for conversion from UTF-16 to UTF-8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutLength</td><td>The array length needed to write the string to the conversion result array. The terminating character is not included. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcLength</td><td>The length of the conversion source array. The length of the <code>*<em>pSrc</em></code> type conversion (buffer size divided by type size).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000027">Return Values:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - Converted normally. <br  />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - A character that cannot be converted was detected. </p>
</dd></dl>
<p> <b>Details</b> <br  />
 Processes the amount of data specified by <code><em>srcLength</em></code>, regardless of whether the conversion source array includes a terminating character. Note that if the array that is the source for the conversion does not end with the terminating character, <code><em>pOutLength</em></code> is the length of the array not including the terminating character.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>pOutLength</em></code> != <code>nullptr</code> </dd>
<dd>
Can read [<code><em>pSrc</em></code>, <code><em>pSrc</em></code> + <code><em>srcLength</em></code>) </dd>
<dd>
<code><em>srcLength</em></code> &gt;= <code>0</code> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>*<em>pOutLength</em></code> &gt;= <code>0</code> </dd></dl>

</div>
</div>
<a id="a8d4f67839157ed13cea7790274ef9159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d4f67839157ed13cea7790274ef9159">&#9670;&nbsp;</a></span>GetLengthOfConvertedStringUtf16NativeToUtf8() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::GetLengthOfConvertedStringUtf16NativeToUtf8 </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the length of a conversion result array necessary for conversion from UTF-16 to UTF-8. </p>
<p>Everything up to the terminating character is included. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutLength</td><td>The array length needed to write the string to the conversion result array. The terminating character is not included. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000028">Return Values:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - Converted normally. <br  />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - A character that cannot be converted was detected. </p>
</dd></dl>
<p> <b>Details</b> <br  />
 If <code><em>pSrc</em></code> is a proper convertible string, the obtained length is the length until the appearance of the terminating character. Note that <code><em>pOutLength</em></code> is the length of the array not including the terminating character. </p>

</div>
</div>
<a id="a663506d271287d754a734254fbc75470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a663506d271287d754a734254fbc75470">&#9670;&nbsp;</a></span>GetLengthOfConvertedStringUtf16NativeToUtf8() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::GetLengthOfConvertedStringUtf16NativeToUtf8 </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the length of a conversion result array necessary for conversion from UTF-16 to UTF-8. </p>
<p>Everything up to the terminating character is included. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutLength</td><td>The array length needed to write the string to the conversion result array. The terminating character is not included. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000029">Return Values:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - Converted normally. <br  />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - A character that cannot be converted was detected. </p>
</dd></dl>
<p> <b>Details</b> <br  />
 If <code><em>pSrc</em></code> is a proper convertible string, the obtained length is the length until the appearance of the terminating character. Note that <code><em>pOutLength</em></code> is the length of the array not including the terminating character. </p>

</div>
</div>
<a id="a0eec880cf5a71dfc8c3f4e0d7d8f2b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eec880cf5a71dfc8c3f4e0d7d8f2b4f">&#9670;&nbsp;</a></span>ConvertStringUtf8ToUtf32() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertStringUtf8ToUtf32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts from UTF-8 to UTF-32. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Conversion result array. No terminating character is added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstLength</td><td>The length of the conversion result array. The length of the <code>*<em>pDst</em></code> type conversion (buffer size divided by type size). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcLength</td><td>The length of the conversion source array. The length of the <code>*<em>pSrc</em></code> type conversion (buffer size divided by type size).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000030">Return Values:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - Converted normally. <br  />
 </p>
<p class="interdd"><b>CharacterEncodingResult_InsufficientLength</b> - The conversion result array was not long enough. <br  />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - A character that cannot be converted was detected. </p>
</dd></dl>
<p> <b>Details</b> <br  />
 Processes the amount of data specified by <code><em>srcLength</em></code>, regardless of whether the conversion source array includes a terminating character. Note that the terminating character is not added to the end of <code><em>pDst</em></code>. </p>

</div>
</div>
<a id="a94bdd2e92a6e03988b48744a44f0b2d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94bdd2e92a6e03988b48744a44f0b2d4">&#9670;&nbsp;</a></span>ConvertStringUtf8ToUtf32() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertStringUtf8ToUtf32 </td>
          <td>(</td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts from UTF-8 to UTF-32. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Conversion result array. No terminating character is added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstLength</td><td>The length of the conversion result array. The length of the <code>*<em>pDst</em></code> type conversion (buffer size divided by type size). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcLength</td><td>The length of the conversion source array. The length of the <code>*<em>pSrc</em></code> type conversion (buffer size divided by type size).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000031">Return Values:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - Converted normally. <br  />
 </p>
<p class="interdd"><b>CharacterEncodingResult_InsufficientLength</b> - The conversion result array was not long enough. <br  />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - A character that cannot be converted was detected. </p>
</dd></dl>
<p> <b>Details</b> <br  />
 Processes the amount of data specified by <code><em>srcLength</em></code>, regardless of whether the conversion source array includes a terminating character. Note that the terminating character is not added to the end of <code><em>pDst</em></code>. </p>

</div>
</div>
<a id="a420f497d6459647978b4fe9c04f654b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420f497d6459647978b4fe9c04f654b9">&#9670;&nbsp;</a></span>ConvertStringUtf8ToUtf32() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertStringUtf8ToUtf32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts from UTF-8 to UTF-32. </p>
<p>Convert everything up to the terminating character. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Conversion result array. A terminating character is appended. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstLength</td><td>The length of the conversion result array. The length of the <code>*<em>pDst</em></code> type conversion (buffer size divided by type size). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000032">Return Values:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - Converted normally. <br  />
 </p>
<p class="interdd"><b>CharacterEncodingResult_InsufficientLength</b> - The conversion result array was not long enough. <br  />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - A character that cannot be converted was detected. </p>
</dd></dl>
<p> <b>Details</b> <br  />
 If <code><em>pSrc</em></code> is a proper convertible string, the conversion process proceeds until the appearance of the terminating character. Note that the terminating character is added to the end of <code><em>pDst</em></code>. </p>

</div>
</div>
<a id="a01449386a421139fb3e5701c7830392c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01449386a421139fb3e5701c7830392c">&#9670;&nbsp;</a></span>ConvertStringUtf8ToUtf32() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertStringUtf8ToUtf32 </td>
          <td>(</td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts from UTF-8 to UTF-32. </p>
<p>Convert everything up to the terminating character. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Conversion result array. A terminating character is appended. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstLength</td><td>The length of the conversion result array. The length of the <code>*<em>pDst</em></code> type conversion (buffer size divided by type size). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000033">Return Values:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - Converted normally. <br  />
 </p>
<p class="interdd"><b>CharacterEncodingResult_InsufficientLength</b> - The conversion result array was not long enough. <br  />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - A character that cannot be converted was detected. </p>
</dd></dl>
<p> <b>Details</b> <br  />
 If <code><em>pSrc</em></code> is a proper convertible string, the conversion process proceeds until the appearance of the terminating character. Note that the terminating character is added to the end of <code><em>pDst</em></code>. </p>

</div>
</div>
<a id="a86b7a0702ee0d55a13723e23d44cb408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b7a0702ee0d55a13723e23d44cb408">&#9670;&nbsp;</a></span>ConvertStringUtf32ToUtf8() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertStringUtf32ToUtf8 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts from UTF-32 to UTF-8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Conversion result array. No terminating character is added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstLength</td><td>The length of the conversion result array. The length of the <code>*<em>pDst</em></code> type conversion (buffer size divided by type size). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcLength</td><td>The length of the conversion source array. The length of the <code>*<em>pSrc</em></code> type conversion (buffer size divided by type size).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000034">Return Values:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - Converted normally. <br  />
 </p>
<p class="interdd"><b>CharacterEncodingResult_InsufficientLength</b> - The conversion result array was not long enough. <br  />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - A character that cannot be converted was detected. </p>
</dd></dl>
<p> <b>Details</b> <br  />
 Processes the amount of data specified by <code><em>srcLength</em></code>, regardless of whether the conversion source array includes a terminating character. Note that the terminating character is not added to the end of <code><em>pDst</em></code>. </p>

</div>
</div>
<a id="a11d150d70e6129b98681547bad34f528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d150d70e6129b98681547bad34f528">&#9670;&nbsp;</a></span>ConvertStringUtf32ToUtf8() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertStringUtf32ToUtf8 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts from UTF-32 to UTF-8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Conversion result array. No terminating character is added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstLength</td><td>The length of the conversion result array. The length of the <code>*<em>pDst</em></code> type conversion (buffer size divided by type size). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcLength</td><td>The length of the conversion source array. The length of the <code>*<em>pSrc</em></code> type conversion (buffer size divided by type size).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000035">Return Values:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - Converted normally. <br  />
 </p>
<p class="interdd"><b>CharacterEncodingResult_InsufficientLength</b> - The conversion result array was not long enough. <br  />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - A character that cannot be converted was detected. </p>
</dd></dl>
<p> <b>Details</b> <br  />
 Processes the amount of data specified by <code><em>srcLength</em></code>, regardless of whether the conversion source array includes a terminating character. Note that the terminating character is not added to the end of <code><em>pDst</em></code>. </p>

</div>
</div>
<a id="a6de5dec6adb8e4760e49502991983e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de5dec6adb8e4760e49502991983e7b">&#9670;&nbsp;</a></span>ConvertStringUtf32ToUtf8() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertStringUtf32ToUtf8 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts from UTF-32 to UTF-8. </p>
<p>Convert everything up to the terminating character. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Conversion result array. A terminating character is appended. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstLength</td><td>The length of the conversion result array. The length of the <code>*<em>pDst</em></code> type conversion (buffer size divided by type size). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000036">Return Values:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - Converted normally. <br  />
 </p>
<p class="interdd"><b>CharacterEncodingResult_InsufficientLength</b> - The conversion result array was not long enough. <br  />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - A character that cannot be converted was detected. </p>
</dd></dl>
<p> <b>Details</b> <br  />
 If <code><em>pSrc</em></code> is a proper convertible string, the conversion process proceeds until the appearance of the terminating character. Note that the terminating character is added to the end of <code><em>pDst</em></code>. </p>

</div>
</div>
<a id="aacb941ac26afd099e06988f32df6418c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb941ac26afd099e06988f32df6418c">&#9670;&nbsp;</a></span>ConvertStringUtf32ToUtf8() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertStringUtf32ToUtf8 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts from UTF-32 to UTF-8. </p>
<p>Convert everything up to the terminating character. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Conversion result array. A terminating character is appended. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstLength</td><td>The length of the conversion result array. The length of the <code>*<em>pDst</em></code> type conversion (buffer size divided by type size). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000037">Return Values:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - Converted normally. <br  />
 </p>
<p class="interdd"><b>CharacterEncodingResult_InsufficientLength</b> - The conversion result array was not long enough. <br  />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - A character that cannot be converted was detected. </p>
</dd></dl>
<p> <b>Details</b> <br  />
 If <code><em>pSrc</em></code> is a proper convertible string, the conversion process proceeds until the appearance of the terminating character. Note that the terminating character is added to the end of <code><em>pDst</em></code>. </p>

</div>
</div>
<a id="aa42be4f290225031ea8dafefed8571c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa42be4f290225031ea8dafefed8571c5">&#9670;&nbsp;</a></span>GetLengthOfConvertedStringUtf8ToUtf32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::GetLengthOfConvertedStringUtf8ToUtf32 </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the length of a conversion result array necessary for conversion from UTF-8 to UTF-32. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutLength</td><td>The array length needed to write the string to the conversion result array. The terminating character is not included. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcLength</td><td>The length of the conversion source array. The length of the <code>*<em>pSrc</em></code> type conversion (buffer size divided by type size).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000038">Return Values:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - Converted normally. <br  />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - A character that cannot be converted was detected. </p>
</dd></dl>
<p> <b>Details</b> <br  />
 Processes the amount of data specified by <code><em>srcLength</em></code>, regardless of whether the conversion source array includes a terminating character. Note that if the array that is the source for the conversion does not end with the terminating character, <code><em>pOutLength</em></code> is the length of the array not including the terminating character. </p>

</div>
</div>
<a id="a1d2095df7e200b19b396b87856c884ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d2095df7e200b19b396b87856c884ac">&#9670;&nbsp;</a></span>GetLengthOfConvertedStringUtf8ToUtf32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::GetLengthOfConvertedStringUtf8ToUtf32 </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the length of a conversion result array necessary for conversion from UTF-8 to UTF-32. </p>
<p>Everything up to the terminating character is included. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutLength</td><td>The array length needed to write the string to the conversion result array. The terminating character is not included. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000039">Return Values:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - Converted normally. <br  />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - A character that cannot be converted was detected. </p>
</dd></dl>
<p> <b>Details</b> <br  />
 If <code><em>pSrc</em></code> is a proper convertible string, the obtained length is the length until the appearance of the terminating character. Note that <code><em>pOutLength</em></code> is the length of the array not including the terminating character. </p>

</div>
</div>
<a id="a7245d2828f892a9cd8f9fd95f48370a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7245d2828f892a9cd8f9fd95f48370a8">&#9670;&nbsp;</a></span>GetLengthOfConvertedStringUtf32ToUtf8() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::GetLengthOfConvertedStringUtf32ToUtf8 </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the length of a conversion result array necessary for conversion from UTF-32 to UTF-8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutLength</td><td>The array length needed to write the string to the conversion result array. The terminating character is not included. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcLength</td><td>The length of the conversion source array. The length of the <code>*<em>pSrc</em></code> type conversion (buffer size divided by type size).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000040">Return Values:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - Converted normally. <br  />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - A character that cannot be converted was detected. </p>
</dd></dl>
<p> <b>Details</b> <br  />
 Processes the amount of data specified by <code><em>srcLength</em></code>, regardless of whether the conversion source array includes a terminating character. Note that if the array that is the source for the conversion does not end with the terminating character, <code><em>pOutLength</em></code> is the length of the array not including the terminating character. </p>

</div>
</div>
<a id="abe8ee9328e7adbbd05e11b2dbbfaf5aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe8ee9328e7adbbd05e11b2dbbfaf5aa">&#9670;&nbsp;</a></span>GetLengthOfConvertedStringUtf32ToUtf8() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::GetLengthOfConvertedStringUtf32ToUtf8 </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the length of a conversion result array necessary for conversion from UTF-32 to UTF-8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutLength</td><td>The array length needed to write the string to the conversion result array. The terminating character is not included. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcLength</td><td>The length of the conversion source array. The length of the <code>*<em>pSrc</em></code> type conversion (buffer size divided by type size).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000041">Return Values:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - Converted normally. <br  />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - A character that cannot be converted was detected. </p>
</dd></dl>
<p> <b>Details</b> <br  />
 Processes the amount of data specified by <code><em>srcLength</em></code>, regardless of whether the conversion source array includes a terminating character. Note that if the array that is the source for the conversion does not end with the terminating character, <code><em>pOutLength</em></code> is the length of the array not including the terminating character. </p>

</div>
</div>
<a id="ad68dd5a2f5c5ddfbb416ea6f6f434f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad68dd5a2f5c5ddfbb416ea6f6f434f7c">&#9670;&nbsp;</a></span>GetLengthOfConvertedStringUtf32ToUtf8() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::GetLengthOfConvertedStringUtf32ToUtf8 </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the length of a conversion result array necessary for conversion from UTF-32 to UTF-8. </p>
<p>Everything up to the terminating character is included. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutLength</td><td>The array length needed to write the string to the conversion result array. The terminating character is not included. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000042">Return Values:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - Converted normally. <br  />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - A character that cannot be converted was detected. </p>
</dd></dl>
<p> <b>Details</b> <br  />
 If <code><em>pSrc</em></code> is a proper convertible string, the obtained length is the length until the appearance of the terminating character. Note that <code><em>pOutLength</em></code> is the length of the array not including the terminating character. </p>

</div>
</div>
<a id="af93876bebf406297e7b8422d8eaf6c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af93876bebf406297e7b8422d8eaf6c2f">&#9670;&nbsp;</a></span>GetLengthOfConvertedStringUtf32ToUtf8() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::GetLengthOfConvertedStringUtf32ToUtf8 </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the length of a conversion result array necessary for conversion from UTF-32 to UTF-8. </p>
<p>Everything up to the terminating character is included. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutLength</td><td>The array length needed to write the string to the conversion result array. The terminating character is not included. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000043">Return Values:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - Converted normally. <br  />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - A character that cannot be converted was detected. </p>
</dd></dl>
<p> <b>Details</b> <br  />
 If <code><em>pSrc</em></code> is a proper convertible string, the obtained length is the length until the appearance of the terminating character. Note that <code><em>pOutLength</em></code> is the length of the array not including the terminating character. </p>

</div>
</div>
<a id="ae3c37393525e5cd94e22abe476c261c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c37393525e5cd94e22abe476c261c9">&#9670;&nbsp;</a></span>ConvertCharacterUtf8ToUtf16Native() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertCharacterUtf8ToUtf16Native </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a single character from UTF-8 to UTF-16. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Conversion result character. Pass in a buffer with room for two arrays. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source character. Pass in a buffer with room for four arrays.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. </dd></dl>

</div>
</div>
<a id="a883fcd9c7fee7e390cc8039f175f7d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883fcd9c7fee7e390cc8039f175f7d81">&#9670;&nbsp;</a></span>ConvertCharacterUtf8ToUtf16Native() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertCharacterUtf8ToUtf16Native </td>
          <td>(</td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a single character from UTF-8 to UTF-16. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Conversion result character. Pass in a buffer with room for two arrays. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source character. Pass in a buffer with room for four arrays.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. </dd></dl>

</div>
</div>
<a id="ac706453bef5ce6867499d41bff823a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac706453bef5ce6867499d41bff823a0b">&#9670;&nbsp;</a></span>ConvertCharacterUtf16NativeToUtf8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertCharacterUtf16NativeToUtf8 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a single character from UTF-16 to UTF-8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Conversion result character. Pass in a buffer with room for four arrays. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source character. Pass in a buffer with room for two arrays.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. </dd></dl>

</div>
</div>
<a id="a8357717235709d3c38484e0a0eec89ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8357717235709d3c38484e0a0eec89ed">&#9670;&nbsp;</a></span>ConvertCharacterUtf16NativeToUtf8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertCharacterUtf16NativeToUtf8 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a single character from UTF-16 to UTF-8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Conversion result character. Pass in a buffer with room for four arrays. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source character. Pass in a buffer with room for two arrays.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. </dd></dl>

</div>
</div>
<a id="aec102fea3e52b0d8ec9ce743f3156dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec102fea3e52b0d8ec9ce743f3156dd6">&#9670;&nbsp;</a></span>ConvertCharacterUtf8ToUtf32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertCharacterUtf8ToUtf32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a single character from UTF-8 to UTF-32. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Conversion result character. Pass in a buffer with room for one array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source character. Pass in a buffer with room for four arrays.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_font_8cpp-example.html#a16">NvnSimple/NvnSimpleSharedLib/Font.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a633fedda1fc644c208cec4de6d2d619a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a633fedda1fc644c208cec4de6d2d619a">&#9670;&nbsp;</a></span>ConvertCharacterUtf8ToUtf32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertCharacterUtf8ToUtf32 </td>
          <td>(</td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a single character from UTF-8 to UTF-32. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Conversion result character. Pass in a buffer with room for one array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Conversion source character. Pass in a buffer with room for four arrays.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. </dd></dl>

</div>
</div>
<a id="a8af955318b43cb855889cfce8799ae61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af955318b43cb855889cfce8799ae61">&#9670;&nbsp;</a></span>ConvertCharacterUtf32ToUtf8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertCharacterUtf32ToUtf8 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a single character from UTF-32 to UTF-8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Conversion result character. Pass in a buffer with room for four arrays. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Conversion source character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. </dd></dl>

</div>
</div>
<a id="aad163f7a39131c5a224ddb3e09050243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad163f7a39131c5a224ddb3e09050243">&#9670;&nbsp;</a></span>ConvertCharacterUtf32ToUtf8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertCharacterUtf32ToUtf8 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a single character from UTF-32 to UTF-8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Conversion result character. Pass in a buffer with room for four arrays. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Conversion source character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. </dd></dl>

</div>
</div>
<a id="ae443a8ae5dbbb92d7f03fb2fba373ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae443a8ae5dbbb92d7f03fb2fba373ea3">&#9670;&nbsp;</a></span>PickOutCharacterFromUtf8String()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::PickOutCharacterFromUtf8String </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pChar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>pStr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a single character from a UTF-8 string and increments the pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pChar</td><td>A 4-byte buffer that stores the character that was split off. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pStr</td><td>A string to split off. After splitting, the pointer for a single character is incremented.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_font_8cpp-example.html#a14">NvnSimple/NvnSimpleSharedLib/Font.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae0290996b2f08a558763e919ca74fd0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0290996b2f08a558763e919ca74fd0f">&#9670;&nbsp;</a></span>CompressZlib() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::CompressZlib </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pWork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>workSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs <code>deflate</code> compression in <code>zlib</code> format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSize</td><td>Data size after compression. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Pointer to the buffer where the compressed data is written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstSize</td><td>Size of the buffer pointed to by <code><em>pDst</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Pointer to the buffer storing the data to compress. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcSize</td><td>Size of the data to compress. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pWork</td><td>Pointer to the working buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">workSize</td><td>Size of the working buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether compression was successful. If the process fails, increase the output buffer size and try again.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>pWork</em></code> has at least <code>CompressZlibWorkBufferSizeDefault</code> bytes of space.</dd></dl>
<p> <b>Details</b> <br  />
 This function uses <code>zlib</code> to perform <code>deflate</code> compression in <code>zlib</code> format. <code>zlib</code> is an open source library that compresses and decompresses data using the <code>deflate</code> algorithm. It is distributed at <a href="http://www.zlib.net/">http://www.zlib.net/</a>. This function sets the <code>zlib</code> compression level to <code>6</code> (<code>Z_DEFAULT_COMPRESSION</code>) and the memory consumption (<code><em>memLevel</em></code>) to <code>8</code>. This function compresses everything at the same time without dividing the input data or output buffer. A <code>zlib</code> format header and footer are appended to the beginning and end of the data compressed by this function. The data can be extracted using the <code><a class="el" href="namespacenn_1_1util.html#a5ef5750312d89f54f3e11496c3414ef7">DecompressZlib()</a></code> function. You cannot get the precompressed size from compressed data that was compressed by this function. Keep the precompressed data size separately. This function can handle a data size of up to 4 GB. </p>

</div>
</div>
<a id="a9a092e78b92cadba899c2abbc486f899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a092e78b92cadba899c2abbc486f899">&#9670;&nbsp;</a></span>CompressZlib() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::CompressZlib </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pWork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>workSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>memLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compressionLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs <code>deflate</code> compression in <code>zlib</code> format with the specified compression level and memory usage level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSize</td><td>Data size after compression. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Pointer to the buffer where the compressed data is written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstSize</td><td>Size of the buffer pointed to by <code><em>pDst</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Pointer to the buffer storing the data to compress. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcSize</td><td>Size of the data to compress. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pWork</td><td>Pointer to the working buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">workSize</td><td>Size of the working buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memLevel</td><td>Memory consumption. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compressionLevel</td><td>Compression level.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether compression was successful. If the process fails, increase the output buffer size and try again.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>pWork</em></code> has at least <code>NN_UTIL_CALCULATE_COMPRESS_ZLIB_WORKBUFFER_SIZE(<em>memLevel</em>)</code> bytes of space. <code>1</code> &lt;= <code><em>memLevel</em></code> &amp;&amp; <code><em>memLevel</em></code> &lt;= <code>9</code>. <code>0</code> &lt;= <code><em>compressLevel</em></code> &amp;&amp; <code><em>compressLevel</em></code> &lt;= <code>9</code>.</dd></dl>
<p> <b>Details</b> <br  />
 This function is an overloaded function that specifies the compression level and memory consumption level used by <code><a class="el" href="namespacenn_1_1util.html#ae0290996b2f08a558763e919ca74fd0f" title="Performs deflate compression in zlib format.">CompressZlib()</a></code>. In this function, you can specify the memory consumption and the compression level. The memory consumption can be set to a value between 1 and 9, where a larger value uses more memory to improve the compression ratio and compression speed. The compression level can be set to a value between 0 and 9, where a smaller value generally results in shorter compression time and a larger value results in smaller compressed data sizes. Specify a value of <code>0</code> for no compression. </p>

</div>
</div>
<a id="a1eaf5623ce101256fc619f5b5a03491c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eaf5623ce101256fc619f5b5a03491c">&#9670;&nbsp;</a></span>CompressGzip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::CompressGzip </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pWork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>workSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs <code>deflate</code> compression in <code>Gzip</code> format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSize</td><td>Data size after compression. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Pointer to the buffer where the compressed data is written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstSize</td><td>Size of the buffer pointed to by <code><em>pDst</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Pointer to the buffer storing the data to compress. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcSize</td><td>Size of the data to compress. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pWork</td><td>Pointer to the working buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">workSize</td><td>Size of the working buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether compression was successful. If the process fails, increase the output buffer size and try again.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>pWork</em></code> has at least <code>CompressGzipWorkBufferSizeDefault</code> bytes of space.</dd></dl>
<p> <b>Details</b> <br  />
 This function uses <code>zlib</code> to perform <code>deflate</code> compression in <code>Gzip</code> format. <code>zlib</code> is an open source library that compresses and decompresses data using the <code>deflate</code> algorithm. It is distributed at <a href="http://www.zlib.net/">http://www.zlib.net/</a>. This function sets the <code>zlib</code> compression level to <code>6</code> (<code>Z_DEFAULT_COMPRESSION</code>) and the memory consumption (<code><em>memLevel</em></code>) to <code>8</code>. This function compresses everything at the same time without dividing the input data or output buffer. A <code>gzip</code> format header and footer are appended to the beginning and end of the data compressed by this function. The data can be extracted using the <code><a class="el" href="namespacenn_1_1util.html#a8d0dd598671e1a5e68b15f48e4b02045">DecompressGzip()</a></code> function. The precompression size of data compressed in <code>gzip</code> format can be retrieved using the <code><a class="el" href="namespacenn_1_1util.html#af08749f6d24d2bf7d577a253fa2d3c59" title="Gets the precompression size of data compressed in gzip format.">GetGzipDecompressedSize()</a></code> function. This function can handle a data size of up to 4 GB. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_util_compression_2_util_compression_8cpp-example.html#a2">UtilCompression/UtilCompression.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="abda6da1a7c7bb62667781877ec8521a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda6da1a7c7bb62667781877ec8521a9">&#9670;&nbsp;</a></span>CompressGzip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::CompressGzip </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pWork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>workSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>memLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compressionLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs <code>deflate</code> compression in <code>gzip</code> format with the specified compression level and memory usage level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSize</td><td>Data size after compression. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Pointer to the buffer where the compressed data is written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstSize</td><td>Size of the buffer pointed to by <code><em>pDst</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Pointer to the buffer storing the data to compress. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcSize</td><td>Size of the data to compress. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pWork</td><td>Pointer to the working buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">workSize</td><td>Size of the working buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memLevel</td><td>Memory consumption. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compressionLevel</td><td>Compression level.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether compression was successful. If the process fails, increase the output buffer size and try again.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>pWork</em></code> has at least <code>NN_UTIL_CALCULATE_COMPRESS_GZIP_WORKBUFFER_SIZE(<em>memLevel</em>)</code> bytes of space. <code>1</code> &lt;= <code><em>memLevel</em></code> &amp;&amp; <code><em>memLevel</em></code> &lt;= <code>9</code>. <code>0</code> &lt;= <code><em>compressLevel</em></code> &amp;&amp; <code><em>compressLevel</em></code> &lt;= <code>9</code>.</dd></dl>
<p> <b>Details</b> <br  />
 This function is an overloaded function that specifies the compression level and memory consumption level used by <code><a class="el" href="namespacenn_1_1util.html#a1eaf5623ce101256fc619f5b5a03491c" title="Performs deflate compression in Gzip format.">CompressGzip()</a></code>. In this function, you can specify the memory consumption and the compression level. The memory consumption can be set to a value between 1 and 9, where a larger value uses more memory to improve the compression ratio and compression speed. The compression level can be set to a value between 0 and 9, where a smaller value generally results in shorter compression time and a larger value results in smaller compressed data sizes. Specify a value of <code>0</code> for no compression. </p>

</div>
</div>
<a id="a394f55bc3df26d704f0fa46644aeee07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394f55bc3df26d704f0fa46644aeee07">&#9670;&nbsp;</a></span>CompressDeflate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::CompressDeflate </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pWork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>workSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs <code>deflate</code> compression in <code>raw deflate</code> format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSize</td><td>Data size after compression. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Pointer to the buffer where the compressed data is written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstSize</td><td>Size of the buffer pointed to by <code><em>pDst</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Pointer to the buffer storing the data to compress. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcSize</td><td>Size of the data to compress. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pWork</td><td>Pointer to the working buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">workSize</td><td>Size of the working buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether compression was successful. If the process fails, increase the output buffer size and try again.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>pWork</em></code> has at least <code>CompressDeflateWorkBufferSizeDefault</code> bytes of space.</dd></dl>
<p> <b>Details</b> <br  />
 This function uses <code>zlib</code> to perform <code>deflate</code> compression in <code>raw deflate</code> format. <code>zlib</code> is an open source library that compresses and decompresses data using the <code>deflate</code> algorithm. It is distributed at <a href="http://www.zlib.net/">http://www.zlib.net/</a>. This function sets the <code>zlib</code> compression level to <code>6</code> (<code>Z_DEFAULT_COMPRESSION</code>) and the memory consumption (<code><em>memLevel</em></code>) to <code>8</code>. This function compresses everything at the same time without dividing the input data or output buffer. Data compressed with this function can be decompressed with the <code><a class="el" href="namespacenn_1_1util.html#aa24276fbb8f0d3892fdd9b076078d690">DecompressDeflate()</a></code> function. You cannot get the precompressed size from compressed data that was compressed by this function. Keep the precompressed data size separately. This function can handle a data size of up to 4 GB. </p>

</div>
</div>
<a id="a0d02db25df3c786d3b84160a71a4ca4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d02db25df3c786d3b84160a71a4ca4c">&#9670;&nbsp;</a></span>CompressDeflate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::CompressDeflate </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pWork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>workSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>memLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compressionLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs <code>deflate</code> compression in <code>raw deflate</code> format with the specified compression level and memory usage level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSize</td><td>Data size after compression. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Pointer to the buffer where the compressed data is written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstSize</td><td>Size of the buffer pointed to by <code><em>pDst</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Pointer to the buffer storing the data to compress. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcSize</td><td>Size of the data to compress. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pWork</td><td>Pointer to the working buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">workSize</td><td>Size of the working buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memLevel</td><td>Memory consumption. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compressionLevel</td><td>Compression level.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether compression was successful. If the process fails, increase the output buffer size and try again.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>pWork</em></code> has at least <code>NN_UTIL_CALCULATE_COMPRESS_DEFLATE_WORKBUFFER_SIZE(<em>memLevel</em>)</code> bytes of space. <code>1</code> &lt;= <code><em>memLevel</em></code> &amp;&amp; <code><em>memLevel</em></code> &lt;= <code>9</code>. <code>0</code> &lt;= <code><em>compressLevel</em></code> &amp;&amp; <code><em>compressLevel</em></code> &lt;= <code>9</code>.</dd></dl>
<p> <b>Details</b> <br  />
 This function is an overloaded function that specifies the compression level and memory consumption level used by <code><a class="el" href="namespacenn_1_1util.html#a1eaf5623ce101256fc619f5b5a03491c" title="Performs deflate compression in Gzip format.">CompressGzip()</a></code>. In this function, you can specify the memory consumption and the compression level. The memory consumption can be set to a value between 1 and 9, where a larger value uses more memory to improve the compression ratio and compression speed. The compression level can be set to a value between 0 and 9, where a smaller value generally results in shorter compression time and a larger value results in smaller compressed data sizes. Specify a value of <code>0</code> for no compression. </p>

</div>
</div>
<a id="af08749f6d24d2bf7d577a253fa2d3c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af08749f6d24d2bf7d577a253fa2d3c59">&#9670;&nbsp;</a></span>GetGzipDecompressedSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::util::GetGzipDecompressedSize </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the precompression size of data compressed in <code>gzip</code> format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Pointer to the buffer storing the compressed data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcSize</td><td>Size of the compressed data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the size of the data before it was compressed.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>pSrc</em></code> must point to data compressed in GZIP format.</dd></dl>
<p> <b>Details</b> <br  />
 Gets the precompression size of data compressed in <code>gzip</code> format. In <code><em>srcSize</em></code>, specify the size of the compressed data, not the size of the buffer. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_util_decompression_2_util_decompression_8cpp-example.html#a4">UtilDecompression/UtilDecompression.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a5ef5750312d89f54f3e11496c3414ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef5750312d89f54f3e11496c3414ef7">&#9670;&nbsp;</a></span>DecompressZlib()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::DecompressZlib </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pWork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>workSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs <code>deflate</code> decompression in <code>zlib</code> format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Pointer to the buffer where the decompressed data is to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstSize</td><td>Size of the buffer pointed to by <code><em>pDst</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Pointer to the buffer storing the data to decompress. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcSize</td><td>Size of the data to decompress. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pWork</td><td>Pointer to the working buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">workSize</td><td>Size of the working buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether decompression was successful. If the process fails, the data is either in an unsupported format or corrupted.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pWork</em></code> has at least <code>DecompressZlibWorkBufferSize</code> bytes of space.</li>
<li><code><em>dstSize</em></code> is equal to the size of the uncompressed data.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function uses <code>zlib</code> to perform <code>deflate</code> decompression in <code>zlib</code> format. <code>zlib</code> is an open source library that compresses and decompresses data using the <code>deflate</code> algorithm. It is distributed at <a href="http://www.zlib.net/">http://www.zlib.net/</a>. This function decompresses everything at the same time without dividing the input data or output buffer. This function never writes more than <code><em>dstSize</em></code> bytes to <code><em>pDst</em></code>. This function can handle a data size of up to 4 GB. Use the <code><a class="el" href="namespacenn_1_1util.html#a7545b1458e6ce1847a83d1a04d21cb7a" title="Performs streaming deflate decompression in zlib format.">StreamingDecompressZlib()</a></code> function for split streaming decompression. </p>

</div>
</div>
<a id="a8d0dd598671e1a5e68b15f48e4b02045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d0dd598671e1a5e68b15f48e4b02045">&#9670;&nbsp;</a></span>DecompressGzip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::DecompressGzip </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pWork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>workSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs <code>deflate</code> decompression in <code>Gzip</code> format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Pointer to the buffer where the decompressed data is to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstSize</td><td>Size of the buffer pointed to by <code><em>pDst</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Pointer to the buffer storing the data to decompress. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcSize</td><td>Size of the data to decompress. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pWork</td><td>Pointer to the working buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">workSize</td><td>Size of the working buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether decompression was successful. If the process fails, the data is either in an unsupported format or corrupted.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pWork</em></code> has at least <code>DecompressGzipWorkBufferSize</code> bytes of space.</li>
<li><code><em>dstSize</em></code> is equal to the size of the uncompressed data.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function uses <code>zlib</code> to perform <code>deflate</code> decompression in <code>Gzip</code> format. <code>zlib</code> is an open source library that compresses and decompresses data using the <code>deflate</code> algorithm. It is distributed at <a href="http://www.zlib.net/">http://www.zlib.net/</a>. This function decompresses everything at the same time without dividing the input data or output buffer. This function never writes more than <code><em>dstSize</em></code> bytes to <code><em>pDst</em></code>. This function can handle a data size of up to 4 GB. Use the <code><a class="el" href="namespacenn_1_1util.html#ae19480f506b13f96d397ab207377809f" title="Performs streaming deflate decompression in Gzip format.">StreamingDecompressGzip()</a></code> function for split streaming decompression. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_util_decompression_2_util_decompression_8cpp-example.html#a2">UtilDecompression/UtilDecompression.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aa24276fbb8f0d3892fdd9b076078d690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa24276fbb8f0d3892fdd9b076078d690">&#9670;&nbsp;</a></span>DecompressDeflate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::DecompressDeflate </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pWork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>workSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs <code>deflate</code> decompression in <code>raw deflate</code> format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Pointer to the buffer where the decompressed data is to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstSize</td><td>Size of the buffer pointed to by <code><em>pDst</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Pointer to the buffer storing the data to decompress. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcSize</td><td>Size of the data to decompress. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pWork</td><td>Pointer to the working buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">workSize</td><td>Size of the working buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether decompression was successful. If the process fails, the data is either in an unsupported format or corrupted.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pWork</em></code> has at least <code>DecompressDeflateWorkBufferSize</code> bytes of space.</li>
<li><code><em>dstSize</em></code> is equal to the size of the uncompressed data.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function uses <code>zlib</code> to perform <code>deflate</code> decompression in <code>raw deflate</code> format. <code>zlib</code> is an open source library that compresses and decompresses data using the <code>deflate</code> algorithm. It is distributed at <a href="http://www.zlib.net/">http://www.zlib.net/</a>. This function decompresses everything at the same time without dividing the input data or output buffer. This function never writes more than <code><em>dstSize</em></code> bytes to <code><em>pDst</em></code>. This function can handle a data size of up to 4 GB. Use the <code><a class="el" href="namespacenn_1_1util.html#a0f4538c0f548daf8eb7a9be82f0d05db" title="Performs streaming deflate decompression in raw deflate format.">StreamingDecompressDeflate()</a></code> function for split streaming decompression. </p>

</div>
</div>
<a id="a56e0e9db954e75303566caf960d8934f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e0e9db954e75303566caf960d8934f">&#9670;&nbsp;</a></span>SwapEndian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nn::util::SwapEndian </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>pData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses the endian. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pData</td><td>Pointer to the data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11528ff78b0c478ba7980afb1fb758ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11528ff78b0c478ba7980afb1fb758ac">&#9670;&nbsp;</a></span>LoadEndianReversed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::LoadEndianReversed </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pSrc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses the endian and loads data from memory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Data to be specified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of loading from memory. </dd></dl>

</div>
</div>
<a id="a5cc3f4e75adbd4dd9a3aaeb81fabb7a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc3f4e75adbd4dd9a3aaeb81fabb7a4">&#9670;&nbsp;</a></span>StoreEndianReversed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nn::util::StoreEndianReversed </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses the endian and writes data to memory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Data write target. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The data to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93bc440e1aa171900411796a54701ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93bc440e1aa171900411796a54701ac7">&#9670;&nbsp;</a></span>LoadBigEndian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::LoadBigEndian </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pSrc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads big endian data from memory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Data to be specified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of loading from memory. </dd></dl>

</div>
</div>
<a id="a502929487c357dad5613feb3cc1d8ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a502929487c357dad5613feb3cc1d8ca1">&#9670;&nbsp;</a></span>StoreBigEndian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nn::util::StoreBigEndian </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes data to memory in big endian. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Data write target. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The data to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe1fe27e9543f7398c23221c9dc7f86f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe1fe27e9543f7398c23221c9dc7f86f">&#9670;&nbsp;</a></span>LoadLittleEndian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::LoadLittleEndian </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pSrc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads little endian data from memory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Data to be specified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of loading from memory. </dd></dl>

</div>
</div>
<a id="a2462759e94b37f3c9dfb92406fbc4ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2462759e94b37f3c9dfb92406fbc4ec9">&#9670;&nbsp;</a></span>StoreLittleEndian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nn::util::StoreLittleEndian </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes data to memory in little endian. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Data write target. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The data to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d638b63760707ce1d5e68c886cb59b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d638b63760707ce1d5e68c886cb59b5">&#9670;&nbsp;</a></span>FromLittleEndian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::FromLittleEndian </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts little-endian values to the platform's endianness. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">var</td><td>The data to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the conversion result. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>T</em></code> must be an integer type. </dd></dl>

</div>
</div>
<a id="a2f0e81838fd1a4bf14aba90338f0a926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0e81838fd1a4bf14aba90338f0a926">&#9670;&nbsp;</a></span>ToLittleEndian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::ToLittleEndian </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts data to little-endian values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">var</td><td>The data to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the conversion result. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>T</em></code> must be an integer type. </dd></dl>

</div>
</div>
<a id="a3e0e01c015d468b75a416b0724531c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e0e01c015d468b75a416b0724531c27">&#9670;&nbsp;</a></span>FromBigEndian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::FromBigEndian </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts big-endian values to the platform's endianness. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">var</td><td>The data to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the conversion result. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>T</em></code> must be an integer type. </dd></dl>

</div>
</div>
<a id="a85cf0675a6b6235b4662135ab00f7a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85cf0675a6b6235b4662135ab00f7a44">&#9670;&nbsp;</a></span>ToBigEndian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::ToBigEndian </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts data to big-endian values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">var</td><td>The data to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the conversion result. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>T</em></code> must be an integer type. </dd></dl>

</div>
</div>
<a id="ad9d6eacc0ce84cf0853a063c37552e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d6eacc0ce84cf0853a063c37552e88">&#9670;&nbsp;</a></span>ToUnderlying()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::underlying_type&lt;T&gt;::type nn::util::ToUnderlying </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts an enumerated type value to base type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The enumerated type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The enumerated type value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the value that was cast to the base type. </dd></dl>

</div>
</div>
<a id="a89fad03d3f71a12026b6dcb2365180bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89fad03d3f71a12026b6dcb2365180bb">&#9670;&nbsp;</a></span>Exchange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::Exchange </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitutes the specified value into the variable pointed to by the specified pointer, and returns the old value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of variable pointed to by the pointer. (<code>T</code> must be a type that can be copied, moved, and created.) </td></tr>
    <tr><td class="paramname">U</td><td>The type of value to be assigned. (<code>U&amp;&amp;</code> must be assignable to <code>T&amp;</code>.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Specifies a pointer to the variable whose value you want to set or get. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Specifies the value to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the old <code>*<em>p</em></code> value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>p != nullptr </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>*p == static_cast&lt;T&gt;(value)</dd></dl>
<p> <b>Details</b> <br  />
 If <code>T</code> is a pointer type, <code>nullptr</code> or a <code>0</code> literal can be specified for <em>value</em>. </p>

</div>
</div>
<a id="aa65007834da7227e3fa016d111683e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa65007834da7227e3fa016d111683e73">&#9670;&nbsp;</a></span>GenerateFarmHash64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint64_t nn::util::GenerateFarmHash64 </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a 64-bit <code>FarmHash</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pData</td><td>Input data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataSize</td><td>Size of the input data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a 64-bit <code>FarmHash</code>. </dd></dl>

</div>
</div>
<a id="a54f65dcb71d5cb6e32f327ccab7f796c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f65dcb71d5cb6e32f327ccab7f796c">&#9670;&nbsp;</a></span>FormatString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::util::FormatString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1util.html#a1037da81cd878626e7a661798f94b873">FormatStringOutputFunction</a>&#160;</td>
          <td class="paramname"><em>pOutputFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>outputFunctionArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formats a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pOutputFunction</td><td>The callback function that receives the strings in the order they are generated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outputFunctionArg</td><td>User-defined parameter given to the output callback function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFormat</td><td>A <code>printf</code>-style format string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Argument given to the format string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>pOutputFunction</em></code> is not a null pointer. </dd>
<dd>
<code><em>pFormat</em></code> is not a null pointer. </dd>
<dd>
The formatted string in <code><em>pFormat</em></code> is a <code>printf</code>-style formatted string. </dd>
<dd>
The formatted string in <code><em>pFormat</em></code> is passed as one of the required parameters. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code><em>pOutputFunction</em></code> points to the whole generated string.</dd></dl>
<p> <b>Details</b> <br  />
The string is formatted and passed to <code><em>pOutputFunction</em></code> in order. The generated string is divided into multiple blocks of one or more characters, and these blocks are passed to <code><em>pOutputFunction</em></code> one at a time, in order from the top.</p>
<p><code><em>pOutputFunction</em></code> must not throw an exception.</p>
<p>The format of the formatted string is similar to C99 <code>printf</code>. However, it has the following differences.</p>
<ul>
<li>The n conversion specifier has been removed.</li>
</ul>
<p>The conversion specifier may specify the following.</p>
<ul>
<li>Flag<ul>
<li>- +, -, whitespace, #, 0</li>
</ul>
</li>
<li>Field width<ul>
<li>Number, *</li>
</ul>
</li>
<li>Precision<ul>
<li>Number, *</li>
</ul>
</li>
<li>Length modifiers<ul>
<li>hh, h, l, j, z, t, L</li>
</ul>
</li>
<li>Conversion specifiers<ul>
<li>s, c, d, i, o, u, x, X, a, A, e, E, f, F, g, G, p, %.</li>
</ul>
</li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd>The following restrictions exist.<ul>
<li><code>long double</code> values are cast to <code>double</code> and converted to strings with <code>double</code> precision.</li>
<li>The rounding precision is not correct when converting floating-point numbers. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1054c37da4a1d20fe6b0ca90a8ca351c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1054c37da4a1d20fe6b0ca90a8ca351c">&#9670;&nbsp;</a></span>VFormatString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::util::VFormatString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1util.html#a1037da81cd878626e7a661798f94b873">FormatStringOutputFunction</a>&#160;</td>
          <td class="paramname"><em>pOutputFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>outputFunctionArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::va_list&#160;</td>
          <td class="paramname"><em>formatArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formats a string. </p>
<p>Same as the <code><a class="el" href="namespacenn_1_1util.html#a54f65dcb71d5cb6e32f327ccab7f796c">FormatString</a></code> function, except when the argument provided to the format string is received by <code>std::va_list</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pOutputFunction</td><td>The callback function that receives the strings in the order they are output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outputFunctionArg</td><td>User-defined parameter given to the output callback function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFormat</td><td>A <code>printf</code>-style format string. For more information, see the <code><a class="el" href="namespacenn_1_1util.html#a54f65dcb71d5cb6e32f327ccab7f796c">FormatString</a></code> function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">formatArg</td><td>Argument given to the format string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenn_1_1util.html#a54f65dcb71d5cb6e32f327ccab7f796c" title="Formats a string.">FormatString()</a> </dd></dl>

</div>
</div>
<a id="ad0cf8c9c361735e4387e4274f26660fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0cf8c9c361735e4387e4274f26660fb">&#9670;&nbsp;</a></span>SNPrintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::util::SNPrintf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formats a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Buffer that stores the generated string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferLength</td><td>The number of buffer elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFormat</td><td>A <code>printf</code>-style format string. For more information, see the <code><a class="el" href="namespacenn_1_1util.html#a54f65dcb71d5cb6e32f327ccab7f796c">FormatString</a></code> function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Argument given to the format string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of characters in the generated string (excluding the NULL terminator). Returns the number of characters for the untruncated string even in cases where the output is truncated.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(<code><em>buffer</em></code> is not a null pointer) || (<code><em>bufferLength</em></code> == <code>0</code>) </dd>
<dd>
The memory space for <code><em>buffer</em></code> does not overlap with the space for the formatted string. </dd>
<dd>
<code><em>pFormat</em></code> is not a null pointer. </dd>
<dd>
The formatted string in <code><em>pFormat</em></code> is a <code>printf</code>-style formatted string. </dd>
<dd>
The formatted string in <code><em>pFormat</em></code> is passed as one of the required parameters. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <code><em>bufferLength</em></code> != <code>0</code>, the part of the generated string that does not exceed <code><em>bufferLength</em></code> – <code>1</code> is stored in <code><em>buffer</em></code>. </dd>
<dd>
If <code><em>bufferLength</em></code> != <code>0</code>, the string stored in <code><em>buffer</em></code> is null-terminated.</dd></dl>
<p> <b>Details</b> <br  />
Formats a string and outputs it to a buffer.</p>
<p>If <code><em>bufferLength</em></code> == <code>0</code>, nothing is stored in the buffer. Only the length, in characters, of the generated string is calculated.</p>
<p>If <code><em>bufferLength</em></code> != <code>0</code>, the generated string is stored in <code><em>buffer</em></code>. If the string exceeds <code><em>bufferLength</em></code> – <code>1</code>, the extra characters are cut off and not output to <code><em>buffer</em></code>. The string stored in <code><em>buffer</em></code> is null-terminated.</p>
<dl class="section attention"><dt>Attention</dt><dd>The following restrictions exist.<ul>
<li><code>long double</code> values are cast to <code>double</code> and converted with <code>double</code> precision.</li>
<li>The rounding precision is not correct when converting floating-point numbers. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_friends_friend_invitation_2_friends_friend_invitation_8cpp-example.html#a22">FriendsFriendInvitation/FriendsFriendInvitation.cpp</a>, <a class="el" href="_friends_presence_2_friends_presence_8cpp-example.html#a24">FriendsPresence/FriendsPresence.cpp</a>, <a class="el" href="_fs_sd_card_for_debug_2_fs_sd_card_for_debug_8cpp-example.html#a13">FsSdCardForDebug/FsSdCardForDebug.cpp</a>, <a class="el" href="_ui2d_viewer_simple_2main_8cpp-example.html#a116">Ui2dViewerSimple/main.cpp</a>, <a class="el" href="_web_socket_chat_2_web_socket_chat_8cpp-example.html#a57">WebSocketChat/WebSocketChat.cpp</a>, and <a class="el" href="_web_socket_echo_2_web_socket_echo_8cpp-example.html#a35">WebSocketEcho/WebSocketEcho.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="afb19ebf42335aea1037895832e167857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb19ebf42335aea1037895832e167857">&#9670;&nbsp;</a></span>VSNPrintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::util::VSNPrintf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::va_list&#160;</td>
          <td class="paramname"><em>formatArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formats a string. </p>
<p>Same as the <code><a class="el" href="namespacenn_1_1util.html#ad0cf8c9c361735e4387e4274f26660fb">SNPrintf</a></code> function, except when the argument provided to the format string is received by <code>std::va_list</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Buffer that stores the output string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferLength</td><td>The number of buffer elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFormat</td><td>A <code>printf</code>-style format string. For more information, see the <code><a class="el" href="namespacenn_1_1util.html#a54f65dcb71d5cb6e32f327ccab7f796c">FormatString</a></code> function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">formatArg</td><td>Argument given to the format string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of characters in the generated string (excluding the NULL terminator). Returns the number of characters for the untruncated string even in cases where the output is truncated. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_bcat_practical_2_bcat_practical_8cpp-example.html#a47">BcatPractical/BcatPractical.cpp</a>, and <a class="el" href="_nifm_network_connection_simple_2_nifm_network_connection_simple__program_base_8h-example.html#a1">NifmNetworkConnectionSimple/NifmNetworkConnectionSimple_ProgramBase.h</a>.</dd>
</dl>

</div>
</div>
<a id="ab479f53f9fa46369401ff30a75d072fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab479f53f9fa46369401ff30a75d072fd">&#9670;&nbsp;</a></span>MakeIFunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto nn::util::MakeIFunction </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an object whose base type is the <code>IFunction&lt;&gt;</code> corresponding to the specified callable object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The callable type for the arguments. A member pointer cannot be specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object whose base type is the <code>IFunction&lt;&gt;</code> corresponding to the specified callable object.</dd></dl>
<p> <b>Details</b> <br  />
 Infers the callable function type <code>R(Args...)</code> from the type specified for <code><em>F</em></code> and returns <code>IFunction&lt;R(Args...)&gt;::Make(f)</code>.</p>
<p>For more information about conditions for <code><em>F</em></code>, see <code>IFunction&lt;R(Args...)&gt;::Make(f)</code>.</p>
<p>This function cannot be used when <code><em>F</em></code> is a member pointer (a member function pointer or a data member pointer). Explicitly use <code>IFunction&lt;R(Args...)&gt;::Make(f)</code>. </p>

</div>
</div>
<a id="a82d03a923928589295b3070211843fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82d03a923928589295b3070211843fd3">&#9670;&nbsp;</a></span>IsIntValueRepresentable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Destination , typename Source &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool nn::util::IsIntValueRepresentable </td>
          <td>(</td>
          <td class="paramtype">Source&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the specified integer value can be represented as the specified type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Destination</td><td>The integer type to convert to. </td></tr>
    <tr><td class="paramname">Source</td><td>The integer value to convert. Normally this parameter can be omitted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The integer value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the integer value <code><em>n</em></code> can be represented as the integer type specified for <code>Destination</code>; otherwise, returns <code>false</code>. </dd></dl>

</div>
</div>
<a id="a42e3d9b45bb488055380944fd50eeb48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e3d9b45bb488055380944fd50eeb48">&#9670;&nbsp;</a></span>CanAddWithoutOverflow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool nn::util::CanAddWithoutOverflow </td>
          <td>(</td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the integer addition operation (<code><em>x</em></code> + <code><em>y</em></code>) can be performed without an overflow. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Int</td><td>The integer type to use for the process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>One of the values to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The other value to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the addition operation can be performed without an overflow occurring, or <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenn_1_1util.html#ae62a4cec7b8c5f53d70d0a69d45a5079" title="Performs the addition operation (x + y) in an overflow-aware manner.">nn::util::TryAddWithoutOverflow()</a> </dd></dl>

</div>
</div>
<a id="a48caa0cf8edbb0c80d72c44b5c12e622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48caa0cf8edbb0c80d72c44b5c12e622">&#9670;&nbsp;</a></span>CanSubtractWithoutOverflow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool nn::util::CanSubtractWithoutOverflow </td>
          <td>(</td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the integer subtraction operation (<code><em>x</em></code> – <code><em>y</em></code>) can be performed without an overflow. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Int</td><td>The integer type to use for the process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The value from which to subtract. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The value to subtract.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the addition operation can be performed without an overflow occurring, or <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenn_1_1util.html#abba14e338904f3acfd3cc93ce1859c5f" title="Performs the subtraction operation (x – y) in an overflow-aware manner.">nn::util::TrySubtractWithoutOverflow()</a> </dd></dl>

</div>
</div>
<a id="a6407c793283959089b9fb4699c0cfa11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6407c793283959089b9fb4699c0cfa11">&#9670;&nbsp;</a></span>CanMultiplyWithoutOverflow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool nn::util::CanMultiplyWithoutOverflow </td>
          <td>(</td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the integer multiplication operation (x * y) can be performed without an overflow. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Int</td><td>The integer type to use for the process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The value to multiply. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The value to multiply the other value by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if it is possible to perform the multiplication operation without an overflow occurring, or <code>false</code> if not.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenn_1_1util.html#ab49533de8b6f87a0e855283aa87334f7" title="Performs an integer multiplication operation (x * y) without an overflow.">nn::util::TryMultiplyWithoutOverflow()</a> </dd></dl>

</div>
</div>
<a id="ae62a4cec7b8c5f53d70d0a69d45a5079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae62a4cec7b8c5f53d70d0a69d45a5079">&#9670;&nbsp;</a></span>TryAddWithoutOverflow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::TryAddWithoutOverflow </td>
          <td>(</td>
          <td class="paramtype">Int *&#160;</td>
          <td class="paramname"><em>pOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the addition operation (<code><em>x</em></code> + <code><em>y</em></code>) in an overflow-aware manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Int</td><td>The integer type to use for the process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOut</td><td>The location for storing the result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>One of the values to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The other value to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOut</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If <code><a class="el" href="namespacenn_1_1util.html#a42e3d9b45bb488055380944fd50eeb48" title="Determines whether the integer addition operation (x + y) can be performed without an overflow.">nn::util::CanAddWithoutOverflow</a>(<em>x</em>, <em>y</em>)</code> == <code>true</code>, <code>*<em>pOut</em></code> == <code><em>x</em> + <em>y</em></code>.</li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="namespacenn_1_1util.html#a42e3d9b45bb488055380944fd50eeb48" title="Determines whether the integer addition operation (x + y) can be performed without an overflow.">nn::util::CanAddWithoutOverflow</a>(<em>x</em>, <em>y</em>)</code>.</dd></dl>
<p> <b>Details</b> <br  />
 If the operation <code><em>x</em></code> + <code><em>y</em></code> can be calculated without an overflow, the result is stored in <code><em>pOut</em></code>. </p>

</div>
</div>
<a id="abba14e338904f3acfd3cc93ce1859c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba14e338904f3acfd3cc93ce1859c5f">&#9670;&nbsp;</a></span>TrySubtractWithoutOverflow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::TrySubtractWithoutOverflow </td>
          <td>(</td>
          <td class="paramtype">Int *&#160;</td>
          <td class="paramname"><em>pOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the subtraction operation (<code><em>x</em></code> – <code><em>y</em></code>) in an overflow-aware manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Int</td><td>The integer type to use for the process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOut</td><td>The location for storing the result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The value from which to subtract. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The value to subtract.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOut</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If <code><a class="el" href="namespacenn_1_1util.html#a48caa0cf8edbb0c80d72c44b5c12e622" title="Determines whether the integer subtraction operation (x – y) can be performed without an overflow.">nn::util::CanSubtractWithoutOverflow</a>(<em>x</em>, <em>y</em>)</code> == <code>true</code>, <code>*<em>pOut</em></code> == <code><em>x</em></code> – <code><em>y</em></code>.</li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="namespacenn_1_1util.html#a48caa0cf8edbb0c80d72c44b5c12e622" title="Determines whether the integer subtraction operation (x – y) can be performed without an overflow.">nn::util::CanSubtractWithoutOverflow</a>(<em>x</em>, <em>y</em>)</code>.</dd></dl>
<p> <b>Details</b> <br  />
 If the operation <code><em>x</em> – <em>y</em></code> can be calculated without an overflow, the result is stored in <code><em>pOut</em></code>. </p>

</div>
</div>
<a id="ab49533de8b6f87a0e855283aa87334f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49533de8b6f87a0e855283aa87334f7">&#9670;&nbsp;</a></span>TryMultiplyWithoutOverflow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::TryMultiplyWithoutOverflow </td>
          <td>(</td>
          <td class="paramtype">Int *&#160;</td>
          <td class="paramname"><em>pOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an integer multiplication operation (x * y) without an overflow. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Int</td><td>The integer type to use for the process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOut</td><td>The location for storing the result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The value to multiply. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The value to multiply the other value by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOut</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If <code><a class="el" href="namespacenn_1_1util.html#a6407c793283959089b9fb4699c0cfa11" title="Determines whether the integer multiplication operation (x * y) can be performed without an overflow.">nn::util::CanMultiplyWithoutOverflow</a>(<em>x</em>, <em>y</em>)</code> == <code>true</code>, then <code>*<em>pOut</em></code> == <code><em>x</em></code> * <code><em>y</em></code>.</li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="namespacenn_1_1util.html#a6407c793283959089b9fb4699c0cfa11" title="Determines whether the integer multiplication operation (x * y) can be performed without an overflow.">nn::util::CanMultiplyWithoutOverflow</a>(<em>x</em>, <em>y</em>)</code>.</dd></dl>
<p> <b>Details</b> <br  />
 If the operation <code><em>x</em></code> * <code><em>y</em></code> can be calculated without an overflow, the result is stored in <code><em>pOut</em></code>. </p>

</div>
</div>
<a id="a7ce54d7a8842039362ff60b9a3e2b376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ce54d7a8842039362ff60b9a3e2b376">&#9670;&nbsp;</a></span>cmp_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool nn::util::cmp_equal </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a safe comparison for type conversion of integers. </p>
<p> <b>Details</b> <br  />
Makes a safe comparison between the two provided integers. Specifically, this means a safe comparison for the possibility of losing data, or the possibility of the size of the value changing, due to the type conversion.</p>
<p><code><a class="el" href="namespacenn_1_1util.html#a7ce54d7a8842039362ff60b9a3e2b376" title="Makes a safe comparison for type conversion of integers.">nn::util::cmp_equal</a></code> is equivalent to <code>std::cmp_equal</code>, which will be added in C++20 (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0586r2.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0586r2.html</a>). The <code>char</code>, <code>char8_t</code>, <code>char16_t</code>, <code>char32_t</code>, <code>wchar_t</code>, and <code>bool</code> integers are not comparison targets. If <code><em>T</em></code> and <code><em>U</em></code> are not types that are subject to comparison, <code>static_assert</code> causes a compile error.</p>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>T</em></code> and <code><em>U</em></code> are integer types other than <code>char</code>, <code>char8_t</code>, <code>char16_t</code>, <code>char32_t</code>, <code>wchar_t</code>, and <code>bool</code>.</li>
</ul>
</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The target integer type of the process. </td></tr>
    <tr><td class="paramname">U</td><td>The target integer type of the process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The integer value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>The integer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the integers <code><em>t</em></code> and <code><em>u</em></code> are equal, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a85a14e78e7feadb29e61b2d98c452777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a14e78e7feadb29e61b2d98c452777">&#9670;&nbsp;</a></span>cmp_not_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool nn::util::cmp_not_equal </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a safe comparison for type conversion of integers. </p>
<p> <b>Details</b> <br  />
Makes a safe comparison between the two provided integers. Specifically, this means a safe comparison for the possibility of losing data, or the possibility of the size of the value changing, due to the type conversion.</p>
<p><code><a class="el" href="namespacenn_1_1util.html#a85a14e78e7feadb29e61b2d98c452777" title="Makes a safe comparison for type conversion of integers.">nn::util::cmp_not_equal</a></code> is equivalent to <code>std::cmp_not_equal</code>, which will be added in C++20 (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0586r2.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0586r2.html</a>). The <code>char</code>, <code>char8_t</code>, <code>char16_t</code>, <code>char32_t</code>, <code>wchar_t</code>, and <code>bool</code> integers are not comparison targets. If <code><em>T</em></code> and <code><em>U</em></code> are not types that are subject to comparison, <code>static_assert</code> causes a compile error.</p>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>T</em></code> and <code><em>U</em></code> are integer types other than <code>char</code>, <code>char8_t</code>, <code>char16_t</code>, <code>char32_t</code>, <code>wchar_t</code>, and <code>bool</code>.</li>
</ul>
</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The target integer type of the process. </td></tr>
    <tr><td class="paramname">U</td><td>The target integer type of the process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The integer value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>The integer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the integers <code><em>t</em></code> and <code><em>u</em></code> are different, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ad69f568255b834efd162fcc0a94d3186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69f568255b834efd162fcc0a94d3186">&#9670;&nbsp;</a></span>cmp_less()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool nn::util::cmp_less </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a safe comparison for type conversion of integers. </p>
<p> <b>Details</b> <br  />
Makes a safe comparison between the two provided integers. Specifically, this means a safe comparison for the possibility of losing data, or the possibility of the size of the value changing, due to the type conversion.</p>
<p><code><a class="el" href="namespacenn_1_1util.html#ad69f568255b834efd162fcc0a94d3186" title="Makes a safe comparison for type conversion of integers.">nn::util::cmp_less</a></code> is equivalent to <code>std::cmp_less</code>, which will be added in C++20 (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0586r2.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0586r2.html</a>). The <code>char</code>, <code>char8_t</code>, <code>char16_t</code>, <code>char32_t</code>, <code>wchar_t</code>, and <code>bool</code> integers are not comparison targets. If <code><em>T</em></code> and <code><em>U</em></code> are not types that are subject to comparison, <code>static_assert</code> causes a compile error.</p>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>T</em></code> and <code><em>U</em></code> are integer types other than <code>char</code>, <code>char8_t</code>, <code>char16_t</code>, <code>char32_t</code>, <code>wchar_t</code>, and <code>bool</code>.</li>
</ul>
</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The target integer type of the process. </td></tr>
    <tr><td class="paramname">U</td><td>The target integer type of the process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The integer value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>The integer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the integer <code><em>t</em></code> is smaller than the integer <code><em>u</em></code>, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ab9bd5df913b7ea135003dadd676562e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9bd5df913b7ea135003dadd676562e2">&#9670;&nbsp;</a></span>cmp_greater()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool nn::util::cmp_greater </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a safe comparison for type conversion of integers. </p>
<p> <b>Details</b> <br  />
Makes a safe comparison between the two provided integers. Specifically, this means a safe comparison for the possibility of losing data, or the possibility of the size of the value changing, due to the type conversion.</p>
<p><code><a class="el" href="namespacenn_1_1util.html#ab9bd5df913b7ea135003dadd676562e2" title="Makes a safe comparison for type conversion of integers.">nn::util::cmp_greater</a></code> is equivalent to <code>std::cmp_greater</code>, which will be added in C++20 (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0586r2.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0586r2.html</a>). The <code>char</code>, <code>char8_t</code>, <code>char16_t</code>, <code>char32_t</code>, <code>wchar_t</code>, and <code>bool</code> integers are not comparison targets. If <code><em>T</em></code> and <code><em>U</em></code> are not types that are subject to comparison, <code>static_assert</code> causes a compile error.</p>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>T</em></code> and <code><em>U</em></code> are integer types other than <code>char</code>, <code>char8_t</code>, <code>char16_t</code>, <code>char32_t</code>, <code>wchar_t</code>, and <code>bool</code>.</li>
</ul>
</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The target integer type of the process. </td></tr>
    <tr><td class="paramname">U</td><td>The target integer type of the process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The integer value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>The integer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the integer <code><em>t</em></code> is greater than the integer <code><em>u</em></code>, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="acf0e6697ba2f6fdb58f4a65e8d350738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf0e6697ba2f6fdb58f4a65e8d350738">&#9670;&nbsp;</a></span>cmp_less_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool nn::util::cmp_less_equal </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a safe comparison for type conversion of integers. </p>
<p> <b>Details</b> <br  />
Makes a safe comparison between the two provided integers. Specifically, this means a safe comparison for the possibility of losing data, or the possibility of the size of the value changing, due to the type conversion.</p>
<p><code><a class="el" href="namespacenn_1_1util.html#acf0e6697ba2f6fdb58f4a65e8d350738" title="Makes a safe comparison for type conversion of integers.">nn::util::cmp_less_equal</a></code> is equivalent to <code>std::cmp_less_equal</code>, which will be added in C++20 (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0586r2.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0586r2.html</a>). The <code>char</code>, <code>char8_t</code>, <code>char16_t</code>, <code>char32_t</code>, <code>wchar_t</code>, and <code>bool</code> integers are not comparison targets. If <code><em>T</em></code> and <code><em>U</em></code> are not types that are subject to comparison, <code>static_assert</code> causes a compile error.</p>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>T</em></code> and <code><em>U</em></code> are integer types other than <code>char</code>, <code>char8_t</code>, <code>char16_t</code>, <code>char32_t</code>, <code>wchar_t</code>, and <code>bool</code>.</li>
</ul>
</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The target integer type of the process. </td></tr>
    <tr><td class="paramname">U</td><td>The target integer type of the process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The integer value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>The integer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the integer <code><em>t</em></code> is less than the integer <code><em>u</em></code>, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a13bf610c0f72953644cf95f356a24cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13bf610c0f72953644cf95f356a24cc9">&#9670;&nbsp;</a></span>cmp_greater_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool nn::util::cmp_greater_equal </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a safe comparison for type conversion of integers. </p>
<p> <b>Details</b> <br  />
Makes a safe comparison between the two provided integers. Specifically, this means a safe comparison for the possibility of losing data, or the possibility of the size of the value changing, due to the type conversion.</p>
<p><code><a class="el" href="namespacenn_1_1util.html#a13bf610c0f72953644cf95f356a24cc9" title="Makes a safe comparison for type conversion of integers.">nn::util::cmp_greater_equal</a></code> is equivalent to <code>std::cmp_greater_equal</code>, which will be added in C++20 (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0586r2.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0586r2.html</a>). The <code>char</code>, <code>char8_t</code>, <code>char16_t</code>, <code>char32_t</code>, <code>wchar_t</code>, and <code>bool</code> integers are not comparison targets. If <code><em>T</em></code> and <code><em>U</em></code> are not types that are subject to comparison, <code>static_assert</code> causes a compile error.</p>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>T</em></code> and <code><em>U</em></code> are integer types other than <code>char</code>, <code>char8_t</code>, <code>char16_t</code>, <code>char32_t</code>, <code>wchar_t</code>, and <code>bool</code>.</li>
</ul>
</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The target integer type of the process. </td></tr>
    <tr><td class="paramname">U</td><td>The target integer type of the process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The integer value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>The integer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the integer <code><em>t</em></code> is greater than the integer <code><em>u</em></code>, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a8a88c08c31dc52dc7c6e0bec2b517992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a88c08c31dc52dc7c6e0bec2b517992">&#9670;&nbsp;</a></span>in_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Destination , typename Source &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool nn::util::in_range </td>
          <td>(</td>
          <td class="paramtype">Source&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the specified integer value can be represented as the specified type. </p>
<p> <b>Details</b> <br  />
<code><a class="el" href="namespacenn_1_1util.html#a8a88c08c31dc52dc7c6e0bec2b517992" title="Determines whether the specified integer value can be represented as the specified type.">nn::util::in_range</a></code> is equivalent to <code>std::in_range</code>, which will be added in C++20 (<a href="http://cpp.arh.pub.ro/cpp/utility/in_range">http://cpp.arh.pub.ro/cpp/utility/in_range</a>). The <code>char</code>, <code>char8_t</code>, <code>char16_t</code>, <code>char32_t</code>, <code>wchar_t</code>, and <code>bool</code> integers are not evaluation targets for this function. If <code><em>T</em></code> and <code><em>U</em></code> are not types that are subject to evaluation, <code>static_assert</code> causes a compile error.</p>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>T</em></code> and <code><em>U</em></code> are integer types other than <code>char</code>, <code>char8_t</code>, <code>char16_t</code>, <code>char32_t</code>, <code>wchar_t</code>, and <code>bool</code>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenn_1_1util.html#a82d03a923928589295b3070211843fd3" title="Determines whether the specified integer value can be represented as the specified type.">nn::util::IsIntValueRepresentable()</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Destination</td><td>The integer type to convert to. </td></tr>
    <tr><td class="paramname">Source</td><td>The integer type to convert. Normally this parameter can be omitted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The integer value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the integer value <code><em>n</em></code> can be represented as the integer type specified for <code>Destination</code>; otherwise, returns <code>false</code>. </dd></dl>

</div>
</div>
<a id="a354c1fa1e2628d64eecabed732ea0565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a354c1fa1e2628d64eecabed732ea0565">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nn::util::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1util_1_1_shared_function.html">SharedFunction</a>&lt; R(Args...)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1util_1_1_shared_function.html">SharedFunction</a>&lt; R(Args...)&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the call target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The <code><a class="el" href="classnn_1_1util_1_1_shared_function.html" title="Class template for managing IFunction using a shared pointer.">SharedFunction</a></code> object to swap for the call target. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <code><a class="el" href="classnn_1_1util_1_1_shared_function.html" title="Class template for managing IFunction using a shared pointer.">SharedFunction</a></code> object to swap for the call target.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
 It is equivalent to the following implementation.</p>
<div class="fragment"><div class="line">lhs.swap(rhs);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1a5b33d314ee9cb1f8997bd9042d322d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a5b33d314ee9cb1f8997bd9042d322d">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnn_1_1util_1_1_shared_function.html">SharedFunction</a>&lt; R(Args...)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the object does not have a call target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The <code><a class="el" href="classnn_1_1util_1_1_shared_function.html" title="Class template for managing IFunction using a shared pointer.">SharedFunction</a></code> object to evaluate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the object specified by <code><em>lhs</em></code> does not have a call target.</dd></dl>
<p> <b>Details</b> <br  />
 It is equivalent to the following implementation.</p>
<div class="fragment"><div class="line"><span class="keywordflow">return</span> ! lhs;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a500fce66bd4061a998d68741f1603d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a500fce66bd4061a998d68741f1603d75">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::operator== </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnn_1_1util_1_1_shared_function.html">SharedFunction</a>&lt; R(Args...)&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the object does not have a call target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <code><a class="el" href="classnn_1_1util_1_1_shared_function.html" title="Class template for managing IFunction using a shared pointer.">SharedFunction</a></code> object to evaluate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the object specified by <code><em>rhs</em></code> does not have a call target.</dd></dl>
<p> <b>Details</b> <br  />
 It is equivalent to the following implementation.</p>
<div class="fragment"><div class="line"><span class="keywordflow">return</span> ! rhs;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7d2100d89100fd38c89ed6fdead21fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d2100d89100fd38c89ed6fdead21fa2">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnn_1_1util_1_1_shared_function.html">SharedFunction</a>&lt; R(Args...)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the object has a call target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The <code><a class="el" href="classnn_1_1util_1_1_shared_function.html" title="Class template for managing IFunction using a shared pointer.">SharedFunction</a></code> object to evaluate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the object specified by <code><em>lhs</em></code> has a call target.</dd></dl>
<p> <b>Details</b> <br  />
 It is equivalent to the following implementation.</p>
<div class="fragment"><div class="line"><span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">bool</span><span class="keyword">&gt;</span>(lhs);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5e8d169338e0f0ec77f92d586379311a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8d169338e0f0ec77f92d586379311a">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::operator!= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnn_1_1util_1_1_shared_function.html">SharedFunction</a>&lt; R(Args...)&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the object has a call target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <code><a class="el" href="classnn_1_1util_1_1_shared_function.html" title="Class template for managing IFunction using a shared pointer.">SharedFunction</a></code> object to evaluate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the object specified by <code><em>rhs</em></code> has a call target.</dd></dl>
<p> <b>Details</b> <br  />
 It is equivalent to the following implementation.</p>
<div class="fragment"><div class="line"><span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">bool</span><span class="keyword">&gt;</span>(rhs);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a95a0c92775590454820ac267996f2461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a0c92775590454820ac267996f2461">&#9670;&nbsp;</a></span>InitializeStreamingDecompressZlibContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::util::InitializeStreamingDecompressZlibContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1util_1_1_streaming_decompress_zlib_context.html">StreamingDecompressZlibContext</a> *&#160;</td>
          <td class="paramname"><em>pContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the context for streaming decompression in <code>zlib</code> format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pContext</td><td>Context for streaming decompression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The context space is initialized and <code><a class="el" href="namespacenn_1_1util.html#a7545b1458e6ce1847a83d1a04d21cb7a">StreamingDecompressZlib()</a></code> is available.</dd></dl>
<p> <b>Details</b> <br  />
 This function initializes the context area for streaming decompression and makes the <code><a class="el" href="namespacenn_1_1util.html#a7545b1458e6ce1847a83d1a04d21cb7a" title="Performs streaming deflate decompression in zlib format.">StreamingDecompressZlib()</a></code> function available. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_util_streaming_decompression_2_util_streaming_decompression_8cpp-example.html#a2">UtilStreamingDecompression/UtilStreamingDecompression.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a64c59c5b4e3d814b813abf54a60ea4ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c59c5b4e3d814b813abf54a60ea4ec">&#9670;&nbsp;</a></span>InitializeStreamingDecompressGzipContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::util::InitializeStreamingDecompressGzipContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1util.html#ae9beb7ac8f35cef8dd13f0416662320a">StreamingDecompressGzipContext</a> *&#160;</td>
          <td class="paramname"><em>pContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the context for streaming decompression in <code>Gzip</code> format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pContext</td><td>Context for streaming decompression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The context space is initialized and <code><a class="el" href="namespacenn_1_1util.html#ae19480f506b13f96d397ab207377809f">StreamingDecompressGzip()</a></code> is available.</dd></dl>
<p> <b>Details</b> <br  />
 This function initializes the context area for streaming decompression and makes the <code><a class="el" href="namespacenn_1_1util.html#ae19480f506b13f96d397ab207377809f" title="Performs streaming deflate decompression in Gzip format.">StreamingDecompressGzip()</a></code> function available. </p>

</div>
</div>
<a id="a871190073dcf972d7212fe860883f208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871190073dcf972d7212fe860883f208">&#9670;&nbsp;</a></span>InitializeStreamingDecompressDeflateContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::util::InitializeStreamingDecompressDeflateContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1util.html#af2ed3b5d58dc0275f9c96f4d4ec7a079">StreamingDecompressDeflateContext</a> *&#160;</td>
          <td class="paramname"><em>pContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the context for streaming decompression in <code>raw deflate</code> format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pContext</td><td>Context for streaming decompression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The context space is initialized and <code><a class="el" href="namespacenn_1_1util.html#a0f4538c0f548daf8eb7a9be82f0d05db">StreamingDecompressDeflate()</a></code> is available.</dd></dl>
<p> <b>Details</b> <br  />
 This function initializes the context area for streaming decompression and makes the <code><a class="el" href="namespacenn_1_1util.html#a0f4538c0f548daf8eb7a9be82f0d05db" title="Performs streaming deflate decompression in raw deflate format.">StreamingDecompressDeflate()</a></code> function available. </p>

</div>
</div>
<a id="a7545b1458e6ce1847a83d1a04d21cb7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7545b1458e6ce1847a83d1a04d21cb7a">&#9670;&nbsp;</a></span>StreamingDecompressZlib()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::StreamingDecompressZlib </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutDstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutConsumedSrcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1util_1_1_streaming_decompress_zlib_context.html">StreamingDecompressZlibContext</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs streaming <code>deflate</code> decompression in <code>zlib</code> format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutDstSize</td><td>Size written to the output buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConsumedSrcSize</td><td>Size read from the input buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Pointer to the buffer where the decompressed data is to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstSize</td><td>Size of the buffer pointed to by <code><em>pDst</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Pointer to the buffer storing the data to decompress. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcSize</td><td>Size of the buffer pointed to by <code><em>pSrc</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pContext</td><td>Pointer to the context area for streaming decompression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether streaming decompression was successful. If the process fails, the compressed data is either corrupted or unsupported.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The context for streaming decompression must be initialized by calling <code>InitializeStreamingZlibContext()</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Performs streaming <code>deflate</code> decompression in <code>zlib</code> format. This can also be used to stream the read operation when a sufficiently large output buffer cannot be prepared for the size of the compressed data. This function returns <code>true</code> when the end of the specified input buffer is reached or when the output buffer is full. Check <code><em>pOutDstSize</em></code> and <code><em>pOutConsumedSize</em></code>, set the output buffer and input data to the updated values, and call this function again. When all of the compressed data is decompressed, both <code><em>pOutDstSize</em></code> and <code><em>pOutConsumedSize</em></code> are set to <code>0</code> to indicate that the decompression process is complete. This function can handle a data size of up to 4 GB. If you want to deal with more than 4 GB, split the data up and load it in portions. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_util_streaming_decompression_2_util_streaming_decompression_8cpp-example.html#a3">UtilStreamingDecompression/UtilStreamingDecompression.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae19480f506b13f96d397ab207377809f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae19480f506b13f96d397ab207377809f">&#9670;&nbsp;</a></span>StreamingDecompressGzip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::StreamingDecompressGzip </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutDstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutConsumedSrcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1util.html#ae9beb7ac8f35cef8dd13f0416662320a">StreamingDecompressGzipContext</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs streaming <code>deflate</code> decompression in <code>Gzip</code> format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutDstSize</td><td>Size written to the output buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConsumedSrcSize</td><td>Size read from the input buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Pointer to the buffer where the decompressed data is to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstSize</td><td>Size of the buffer pointed to by <code><em>pDst</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Pointer to the buffer storing the data to decompress. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcSize</td><td>Size of the buffer pointed to by <code><em>pSrc</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pContext</td><td>Pointer to the context area for streaming decompression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether streaming decompression was successful. If the process fails, the compressed data is either corrupted or unsupported.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The area for the streaming decompression context must be initialized by calling <code>InitializeStreamingGzipContext()</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Performs streaming <code>deflate</code> decompression in <code>Gzip</code> format. This can also be used to stream the read operation when a sufficiently large output buffer cannot be prepared for the size of the compressed data. This function returns <code>true</code> when the end of the specified input buffer is reached or when the output buffer is full. Check <code><em>pOutDstSize</em></code> and <code><em>pOutConsumedSize</em></code>, set the output buffer and input data to the updated values, and call this function again. When all of the compressed data is decompressed, both <code><em>pOutDstSize</em></code> and <code><em>pOutConsumedSize</em></code> are set to <code>0</code> to indicate that the decompression process is complete. This function can handle a data size of up to 4 GB. If you want to deal with more than 4 GB, split the data up and load it in portions. </p>

</div>
</div>
<a id="a0f4538c0f548daf8eb7a9be82f0d05db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f4538c0f548daf8eb7a9be82f0d05db">&#9670;&nbsp;</a></span>StreamingDecompressDeflate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::StreamingDecompressDeflate </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutDstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutConsumedSrcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1util.html#af2ed3b5d58dc0275f9c96f4d4ec7a079">StreamingDecompressDeflateContext</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs streaming <code>deflate</code> decompression in <code>raw deflate</code> format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutDstSize</td><td>Size written to the output buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConsumedSrcSize</td><td>Size read from the input buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>Pointer to the buffer where the decompressed data is to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstSize</td><td>Size of the buffer pointed to by <code><em>pDst</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>Pointer to the buffer storing the data to decompress. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcSize</td><td>Size of the buffer pointed to by <code><em>pSrc</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pContext</td><td>Pointer to the context area for streaming decompression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether streaming decompression was successful. If the process fails, the compressed data is either corrupted or unsupported.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The area for the streaming decompression context must be initialized by calling <code>InitializeStreamingDeflateContext()</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Performs streaming <code>deflate</code> decompression in <code>raw deflate</code> format. This can also be used to stream the read operation when a sufficiently large output buffer cannot be prepared for the size of the compressed data. This function returns <code>true</code> when the end of the specified input buffer is reached or when the output buffer is full. Check <code><em>pOutDstSize</em></code> and <code><em>pOutConsumedSize</em></code>, set the output buffer and input data to the updated values, and call this function again. When all of the compressed data is decompressed, both <code><em>pOutDstSize</em></code> and <code><em>pOutConsumedSize</em></code> are set to <code>0</code> to indicate that the decompression process is complete. This function can handle a data size of up to 4 GB. If you want to deal with more than 4 GB, split the data up and load it in portions. </p>

</div>
</div>
<a id="a449ac1aeee3544e5fa3ad081df39a0c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a449ac1aeee3544e5fa3ad081df39a0c5">&#9670;&nbsp;</a></span>ToLower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::ToLower </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an uppercase character into lowercase. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The character type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The character to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the character after it has been converted.</dd></dl>
<p> <b>Details</b> <br  />
 This function assumes the system is a C locale system and only converts letters. If you specify something other than an uppercase character, the entered character will be returned unmodified. </p>

</div>
</div>
<a id="a45834f1f0a1e7dbe85de32821bac35fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45834f1f0a1e7dbe85de32821bac35fc">&#9670;&nbsp;</a></span>ToUpper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::ToUpper </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a lowercase character into uppercase. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The character type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The character to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the character after it has been converted.</dd></dl>
<p> <b>Details</b> <br  />
 This function assumes the system is a C locale system and only converts letters. If you specify something other than a lowercase character, the entered character will be returned unmodified. </p>

</div>
</div>
<a id="a9a369852b1204085d96a7cc4f26c880b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a369852b1204085d96a7cc4f26c880b">&#9670;&nbsp;</a></span>Strlcpy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int nn::util::Strlcpy </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>pOutDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies strings, accounting for the number of elements in the copy destination buffer and termination. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The character type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutDst</td><td>The pointer to the starting address of the copy destination buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>The pointer to the starting address of the copy source. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of elements in the copy destination buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the length of the string set in <code><em>pSrc</em></code>, the number of elements not including the terminating null character.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutDst</em></code> is not a null pointer.</li>
<li><code><em>pSrc</em></code> is not a null pointer.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Copies the <code><em>pSrc</em></code> string to <code><em>pOutDst</em></code>, including the terminating null character, when the value of <code><em>count</em></code> is greater than the length of the <code><em>pSrc</em></code> string.</p>
<p>Copies <code><em>count</em></code> – <code>1</code> characters and a terminating null character when the value of <code><em>count</em></code> is greater than <code>1</code>, and the length of <code><em>pSrc</em></code> is greater than <code><em>count</em></code>. When <code><em>count</em></code> is less than <code>0</code>, nothing including the terminating null character is written to the copy destination buffer.</p>
<p>The <code><em>pSrc</em></code> string is copied to <code><em>pOutDst</em></code> with no truncation when the return value of the function is less than <code><em>count</em></code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ec_catalog_2_main_8cpp-example.html#a97">EcCatalog/Main.cpp</a>, <a class="el" href="_ngc_simple_2_ngc_simple_8cpp-example.html#a10">NgcSimple/NgcSimple.cpp</a>, and <a class="el" href="_unit_test_with_googletest_2_unit_test_with_googletest_8cpp-example.html#a3">UnitTestWithGoogletest/UnitTestWithGoogletest.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae67392e3b18c74ee4ee9c90b8191e554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67392e3b18c74ee4ee9c90b8191e554">&#9670;&nbsp;</a></span>Strnlen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int nn::util::Strnlen </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of characters, including the number of buffer elements and the terminator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The character type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pStr</td><td>Pointer to the start of the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of elements in the buffer storing the string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the length of the string specified in <code><em>pStr</em></code>, the number of elements not including the terminating null character.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pStr</em></code> is not a null pointer.</li>
<li><code><em>count</em></code> &gt;= <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Returns the number of elements contained in the <code><em>pStr</em></code> string, not including the terminating null character, when the value of <code><em>count</em></code> is greater than the length of <code><em>pStr</em></code>.</p>
<p>The value of <code><em>count</em></code> is returned when it is less than the length of the <code><em>pStr</em></code> string, and the elements after the <code><em>count</em></code>th element are not accessed.</p>
<p>When the function's return value is equivalent to <code><em>count</em></code>, <code><em>pStr</em></code> is not necessarily null-terminated. The function does not count a character made up of multiple buffer elements as one character, but instead counts it as a number of characters equal to the number of elements. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_user_exception_handler_sample_8cpp-example.html#a33">OsUserExceptionHandlerSample.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a9687192252f37e1984e628b8bf796e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9687192252f37e1984e628b8bf796e22">&#9670;&nbsp;</a></span>Strncmp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int nn::util::Strncmp </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pStr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pStr2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares strings, taking into account the number of elements in the buffer and the terminator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The character type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pStr1</td><td>The pointer to the starting address of the first string to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pStr2</td><td>The pointer to the starting address of the second string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The maximum number of elements to compare in the strings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>0</code> when the strings match, and a nonzero value when they do not match.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pStr1</em></code> is not a null pointer.</li>
<li><code><em>pStr2</em></code> is not a null pointer.</li>
<li><code><em>count</em></code> &gt;= <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Compares two strings character-by-character through the <code><em>count</em></code> – <code>1</code> character.</p>
<p>Returns a negative number if the value of the first discovered different character is smaller in the string specified by <code><em>pStr1</em></code>, and a positive number if it is larger.</p>
<p>If a nonzero value is returned, the two strings differ. However, if <code>0</code> is returned, the two strings are not necessarily identical. To ensure that both strings are identical, the function must return <code>0</code> and you must confirm that neither string is longer than <code><em>count</em></code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ec_catalog_2_aoc_2_aoc_item_scene_8cpp-example.html#a6">EcCatalog/Aoc/AocItemScene.cpp</a>, <a class="el" href="_ec_catalog_2_aoc_2_aoc_item_shelf_scene_8cpp-example.html#a6">EcCatalog/Aoc/AocItemShelfScene.cpp</a>, <a class="el" href="_ec_catalog_2_consumable_2_consumable_scene_8cpp-example.html#a5">EcCatalog/Consumable/ConsumableScene.cpp</a>, <a class="el" href="_ec_catalog_2_related_title_bundle_2_related_title_bundle_scene_8cpp-example.html#a5">EcCatalog/RelatedTitleBundle/RelatedTitleBundleScene.cpp</a>, <a class="el" href="_ec_catalog_2_subscription_service_item_2_subscription_service_item_course_scene_8cpp-example.html#a5">EcCatalog/SubscriptionServiceItem/SubscriptionServiceItemCourseScene.cpp</a>, <a class="el" href="_unit_test_with_googletest_2_unit_test_with_googletest_8cpp-example.html#a4">UnitTestWithGoogletest/UnitTestWithGoogletest.cpp</a>, and <a class="el" href="_web_socket_chat_2_web_socket_chat_8cpp-example.html#a39">WebSocketChat/WebSocketChat.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aad3e455c0d7f8cafe6f97ea27940db7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad3e455c0d7f8cafe6f97ea27940db7f">&#9670;&nbsp;</a></span>Strnicmp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int nn::util::Strnicmp </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pStr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pStr2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares strings, ignoring the case but taking into account the number of elements in the buffer and the terminator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The character type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pStr1</td><td>The pointer to the starting address of the first string to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pStr2</td><td>The pointer to the starting address of the second string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The maximum number of elements to compare in the strings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>0</code> when the strings match, and a nonzero value when they do not match.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pStr1</em></code> is not a null pointer.</li>
<li><code><em>pStr2</em></code> is not a null pointer.</li>
<li><code><em>count</em></code> &gt;= <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Compares two strings, ignoring the case and comparing their characters up to the <code><em>count</em></code> – <code>1</code> character.</p>
<p>Returns a negative number if the value of the first discovered different character is smaller in the string specified by <code><em>pStr1</em></code>, and a positive number if it is larger. This function converts all letters to lowercase before comparing the strings, so if the strings that are specified involve a comparison of symbol characters and uppercase characters between ASCII codes for 'Z' and 'a', the case of the return values is reversed compared to the <code><a class="el" href="namespacenn_1_1util.html#a9687192252f37e1984e628b8bf796e22" title="Compares strings, taking into account the number of elements in the buffer and the terminator.">Strncmp()</a></code> function.</p>
<p>If a nonzero value is returned, the two strings differ. However, if <code>0</code> is returned, the two strings are not necessarily identical. To ensure that both strings are identical, the function must return <code>0</code> and you must confirm that neither string is longer than <code><em>count</em></code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_web_socket_chat_2_web_socket_chat_8cpp-example.html#a38">WebSocketChat/WebSocketChat.cpp</a>, and <a class="el" href="_web_socket_echo_2_web_socket_echo_8cpp-example.html#a40">WebSocketEcho/WebSocketEcho.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a11ec4ff5da8ddd7de157ae929f839938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ec4ff5da8ddd7de157ae929f839938">&#9670;&nbsp;</a></span>Strnstr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* nn::util::Strnstr </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pStr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pStr2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for the location of a partial string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The character type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pStr1</td><td>The string to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pStr2</td><td>A partial string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The maximum number of elements to compare in the strings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the partial string is found, the function returns the position where it first appears. If it is not found, the function returns <code>nullptr</code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pStr1</em></code> is not a null pointer.</li>
<li><code><em>pStr2</em></code> is not a null pointer.</li>
<li><code><em>count</em></code> &gt;= <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Looks for the position of first appearance of <code><em>pStr2</em></code> in <code><em>pStr1</em></code>, searching from the first character in the string to as far as the (<code><em>count</em></code> - 1) character. The null terminator is not part of the comparison.</p>
<p>If <code><em>pStr2</em></code> is an empty string ("&lt;tt&gt;\0&lt;/tt&gt;") the function always returns the start of <code><em>pStr1</em></code>. </p>

</div>
</div>
<a id="aae4b52209632a67c5642c794d6eec9e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4b52209632a67c5642c794d6eec9e7">&#9670;&nbsp;</a></span>Memmem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* nn::util::Memmem </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pHaystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>haystackLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pNeedle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>needleLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for the location of a partial string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHaystack</td><td>The data to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">haystackLength</td><td>The data length of <code><em>pHaystack</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pNeedle</td><td>The partial string data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">needleLength</td><td>The data length of <code><em>pNeedle</em></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the partial string is found, the function returns the position where it first appears. If it is not found, the function returns <code>nullptr</code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pHaystack</em></code> is not a null pointer.</li>
<li><code><em>pNeedle</em></code> is not a null pointer.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Looks for the position of first appearance of <code><em>pNeedle</em></code> in <code><em>pHaystack</em></code>. Unlike <code><a class="el" href="namespacenn_1_1util.html#a11ec4ff5da8ddd7de157ae929f839938" title="Searches for the location of a partial string.">Strnstr()</a></code>, this function does not check null characters.</p>
<p>If <code><em>needleLength</em></code> is <code>0</code>, the function always returns the start of <code><em>pHaystack</em></code>. </p>

</div>
</div>
<a id="af9bcb6a04353d44c401b747d2ce7f812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9bcb6a04353d44c401b747d2ce7f812">&#9670;&nbsp;</a></span>Get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; nn::util::Get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1util_1_1_typed_storage.html">TypedStorage</a>&lt; T, sizeof(T), std::alignment_of&lt; T &gt;::value &gt; &amp;&#160;</td>
          <td class="paramname"><em>storage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a reference to the actual type from the specified region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>A region with the same size and alignment as the type to extract.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
 If the size or alignment of <em>storage</em> differs from the actual data, a compiler error occurs. </p><dl class="section return"><dt>Returns</dt><dd>Returns a reference to the actual type held internally. </dd></dl>

</div>
</div>
<a id="a8769650838b44c09ff5c036f7050bc35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8769650838b44c09ff5c036f7050bc35">&#9670;&nbsp;</a></span>Get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; nn::util::Get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1util_1_1_typed_storage.html">TypedStorage</a>&lt; T, sizeof(T), std::alignment_of&lt; T &gt;::value &gt; &amp;&#160;</td>
          <td class="paramname"><em>storage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a reference to the actual type from the specified region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>A region with the same size and alignment as the type to extract.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
 If the size or alignment of <em>storage</em> differs from the actual data, a compiler error occurs. </p><dl class="section return"><dt>Returns</dt><dd>Returns a reference to the actual type held internally. </dd></dl>

</div>
</div>
<a id="a7df2ac5ca47857cc945af5421ea54aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df2ac5ca47857cc945af5421ea54aa5">&#9670;&nbsp;</a></span>GenerateUuid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1util_1_1_uuid.html">Uuid</a> nn::util::GenerateUuid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Universally Unique Identifier (UUID) that conforms to RFC 4122. </p>
<p> <b>Details</b> <br  />
 Creates a Universally Unique Identifier (UUID) that conforms to RFC 4122.</p>
<p>This API is thread-safe. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
