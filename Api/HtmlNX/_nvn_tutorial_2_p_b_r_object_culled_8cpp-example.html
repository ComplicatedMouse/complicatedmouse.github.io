<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NvnTutorial/PBRObjectCulled.cpp | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">NvnTutorial/PBRObjectCulled.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<p>For an explanation of the source code, see <a class="el" href="_page_sample_nvn_tutorial_library.html">NVN Tutorial Library</a> and <tt>NvnTutorial/PBRObjectCulled.cpp</tt>.</p>
<div class="fragment"><div class="line"><span class="comment">/*--------------------------------------------------------------------------------*</span></div>
<div class="line"><span class="comment">  Copyright (C)Nintendo All rights reserved.</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  These coded instructions, statements, and computer programs contain proprietary</span></div>
<div class="line"><span class="comment">  information of Nintendo and/or its licensed developers and are protected by</span></div>
<div class="line"><span class="comment">  national and international copyright laws. They may not be disclosed to third</span></div>
<div class="line"><span class="comment">  parties or copied or duplicated in any form, in whole or in part, without the</span></div>
<div class="line"><span class="comment">  prior written consent of Nintendo.</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  The content herein is highly confidential and should be handled accordingly.</span></div>
<div class="line"><span class="comment"> *--------------------------------------------------------------------------------*/</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_p_b_r_object_culled_8h.html">nvntutorial/PBRObjectCulled.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="nvn___func_ptr_inline_8h.html">nvn/nvn_FuncPtrInline.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_uniform_buffer_manager_8h.html">nvntutorial/UniformBufferManager.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_asset_file_data_holder_8h.html">nvntutorial/AssetFileDataHolder.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_p_b_r_model_binary_file_headers_8h.html">nvntutorial/PBRModelBinaryFileHeaders.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;nvntutorial/ShaderHeaders/DeferredGBufferDataHelper.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;nvntutorial/ShaderHeaders/ShadowMapDataHelper.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;nvntutorial/ShaderHeaders/PointShadowMapDataHelper.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_tutorial_util_8h.html">nvntutorial/TutorialUtil.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>PBRObject</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::MeshCulled Constructor</span></div>
<div class="line"><span class="comment"> * ---------------------------------</span></div>
<div class="line"><span class="comment"> * Empty constructor.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">MeshCulled::MeshCulled()</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::MeshCulled Destructor</span></div>
<div class="line"><span class="comment"> * --------------------------------</span></div>
<div class="line"><span class="comment"> * Empty destructor.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">MeshCulled::~MeshCulled()</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::MeshCulled::CalculateBoundingBox</span></div>
<div class="line"><span class="comment"> * -------------------------------------------</span></div>
<div class="line"><span class="comment"> * Finds the max and min position of vertex for the</span></div>
<div class="line"><span class="comment"> * axis aligned bounding box.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> MeshCulled::CalculateBoundingBox()</div>
<div class="line">{</div>
<div class="line">    m_BoundingBox.resize(6);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* First vertex */</span></div>
<div class="line">    m_BoundingBox[0] = m_Positions[0];</div>
<div class="line">    m_BoundingBox[1] = m_Positions[1];</div>
<div class="line">    m_BoundingBox[2] = m_Positions[2];</div>
<div class="line"> </div>
<div class="line">    m_BoundingBox[3] = m_Positions[0];</div>
<div class="line">    m_BoundingBox[4] = m_Positions[1];</div>
<div class="line">    m_BoundingBox[5] = m_Positions[2];</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 3; i &lt; m_Positions.size() - 3; i += 3)</div>
<div class="line">    {</div>
<div class="line">        m_BoundingBox[0] = std::min(m_BoundingBox[0], m_Positions[i]);</div>
<div class="line">        m_BoundingBox[1] = std::min(m_BoundingBox[1], m_Positions[i + 1]);</div>
<div class="line">        m_BoundingBox[2] = std::min(m_BoundingBox[2], m_Positions[i + 2]);</div>
<div class="line"> </div>
<div class="line">        m_BoundingBox[3] = std::max(m_BoundingBox[3], m_Positions[i]);</div>
<div class="line">        m_BoundingBox[4] = std::max(m_BoundingBox[4], m_Positions[i + 1]);</div>
<div class="line">        m_BoundingBox[5] = std::max(m_BoundingBox[5], m_Positions[i + 2]);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::MeshCulled::GetBoundingBox</span></div>
<div class="line"><span class="comment"> * -------------------------------------</span></div>
<div class="line"><span class="comment"> * Returns bounding box info.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">const</span> std::vector&lt;float&gt;&amp; MeshCulled::GetBoundingBox()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> m_BoundingBox;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::ModelCulled Constructor</span></div>
<div class="line"><span class="comment"> * ----------------------------------</span></div>
<div class="line"><span class="comment"> * Empty constructor.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">ModelCulled::ModelCulled()</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::ModelCulled Destructor</span></div>
<div class="line"><span class="comment"> * ---------------------------------</span></div>
<div class="line"><span class="comment"> * Empty destructor.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">ModelCulled::~ModelCulled()</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::ModelCulled::CreateMeshes</span></div>
<div class="line"><span class="comment"> * ------------------------------------</span></div>
<div class="line"><span class="comment"> * Creates the meshes for the model.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> ModelCulled::CreateMeshes(<span class="keywordtype">void</span>* pBinaryFile)</div>
<div class="line">{</div>
<div class="line">    PBRModelBinary::FileHeader* pFileHeader = <span class="keyword">reinterpret_cast&lt;</span>PBRModelBinary::FileHeader*<span class="keyword">&gt;</span>(pBinaryFile);</div>
<div class="line">    uint64_t meshBlockOffset = pFileHeader-&gt;m_MeshBlockOffset;</div>
<div class="line">    PBRModelBinary::MeshBlockHeader* pMeshBlockHeader = <span class="keyword">reinterpret_cast&lt;</span>PBRModelBinary::MeshBlockHeader*<span class="keyword">&gt;</span>((<span class="keywordtype">char</span>*)pBinaryFile + meshBlockOffset);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Create the meshes that make up the model */</span></div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; pMeshBlockHeader-&gt;m_NumMeshes; ++i)</div>
<div class="line">    {</div>
<div class="line">        Mesh* mesh = <span class="keyword">new</span> MeshCulled();</div>
<div class="line">        mesh-&gt;SetupFromBinaryFile(pBinaryFile, <span class="keyword">reinterpret_cast&lt;</span>uint64_t<span class="keyword">&gt;</span>((&amp;(pMeshBlockHeader-&gt;m_pMeshOffsets))[i]), m_VertexIndexMemoryPoolSize);</div>
<div class="line">        m_Meshes.push_back(mesh);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::ModelCulled::GetModelIndirectData</span></div>
<div class="line"><span class="comment"> * --------------------------------------------</span></div>
<div class="line"><span class="comment"> * Returns the indirect draw data for the model.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">const</span> std::vector&lt;NVNdrawElementsIndirectData&gt;&amp; ModelCulled::GetModelIndirectData()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> m_ModelIndirectData;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::ModelCulled::SetupModelIndirectData</span></div>
<div class="line"><span class="comment"> * ----------------------------------------------</span></div>
<div class="line"><span class="comment"> * Initializes the indirect draw data.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> ModelCulled::SetupModelDrawIndirectData(<span class="keyword">const</span> std::string&amp; programName)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (programName != <span class="stringliteral">&quot;DeferredGBuffer&quot;</span> || m_ModelIndirectData.size() &gt; 0)</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; m_Meshes.size(); ++i)</div>
<div class="line">    {</div>
<div class="line">        <a name="_a0"></a><a class="code" href="struct_n_v_ndraw_elements_indirect_data.html">NVNdrawElementsIndirectData</a> indirectData;</div>
<div class="line"> </div>
<div class="line">        indirectData.<a name="a1"></a><a class="code" href="struct_n_v_ndraw_elements_indirect_data.html#a7ff6bb51c25820a3fe45d9b5e14dfbba">count</a> = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(<span class="keyword">dynamic_cast&lt;</span>MeshCulled*<span class="keyword">&gt;</span>(m_Meshes[i])-&gt;m_NumIndices);</div>
<div class="line">        indirectData.<a name="a2"></a><a class="code" href="struct_n_v_ndraw_elements_indirect_data.html#ad993a9493e2298af43a4b8bb6a8d4387">instanceCount</a> = 1;</div>
<div class="line">        indirectData.<a name="a3"></a><a class="code" href="struct_n_v_ndraw_elements_indirect_data.html#aa5efefaac79529ac391c6dcd45cd8f08">firstIndex</a> = 0;</div>
<div class="line">        indirectData.<a name="a4"></a><a class="code" href="struct_n_v_ndraw_elements_indirect_data.html#a5589d1accff9f2eb4e89470486661315">baseVertex</a> = 0;</div>
<div class="line">        indirectData.<a name="a5"></a><a class="code" href="struct_n_v_ndraw_elements_indirect_data.html#adc71161b8ddd11a39a5b292108ff25f4">baseInstance</a> = 0;</div>
<div class="line"> </div>
<div class="line">        m_ModelIndirectData.push_back(indirectData);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Model::SetupBoundingBox</span></div>
<div class="line"><span class="comment"> * ----------------------------------</span></div>
<div class="line"><span class="comment"> * Creates the bounding box for the mesh from the max/min</span></div>
<div class="line"><span class="comment"> * vertex positions. This is done at load time for demonstration</span></div>
<div class="line"><span class="comment"> * purposes. In a real application this could/should be done</span></div>
<div class="line"><span class="comment"> * in an offline asset build.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> ModelCulled::SetupBoundingBox(<span class="keyword">const</span> std::string&amp; programName)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (programName != <span class="stringliteral">&quot;DeferredGBuffer&quot;</span>)</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; m_Meshes.size(); ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keyword">dynamic_cast&lt;</span>MeshCulled*<span class="keyword">&gt;</span>(m_Meshes[i])-&gt;GetBoundingBox().size() &gt; 0)</div>
<div class="line">            <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">dynamic_cast&lt;</span>MeshCulled*<span class="keyword">&gt;</span>(m_Meshes[i])-&gt;CalculateBoundingBox();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::ModelCulled::DrawModelIndirect</span></div>
<div class="line"><span class="comment"> * -----------------------------------------</span></div>
<div class="line"><span class="comment"> * Records the indirect draw command using the indirect</span></div>
<div class="line"><span class="comment"> * buffer address and offset for given object.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> ModelCulled::DrawModelIndirect(<a name="_a6"></a><a class="code" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a>* pCommandBuffer, AssetFileDataHolder* shaderProgramData, <span class="keyword">const</span> <a class="code" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&amp; drawIndirectBufferAddress, <span class="keyword">const</span> uint32_t&amp; drawIndirectObjectBufferOffset)</div>
<div class="line">{</div>
<div class="line">    std::string programName;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Get the shader program name */</span></div>
<div class="line">    <span class="keywordflow">if</span> (shaderProgramData-&gt;GetProgramData().size())</div>
<div class="line">    {</div>
<div class="line">        programName = shaderProgramData-&gt;GetProgramData()[0]-&gt;m_pProgramName;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (shaderProgramData-&gt;GetSpecializedProgramData().size())</div>
<div class="line">    {</div>
<div class="line">        programName = shaderProgramData-&gt;GetSpecializedProgramData()[0]-&gt;m_pProgramName;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <a name="a7"></a><a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(<span class="keyword">false</span>, <span class="stringliteral">&quot;No shader in asset data holder.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    PBRModelData::VertexAttributeShaderData&amp; shaderData = m_VertexAttributeShaderData.at(programName);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Draw each mesh held by the model */</span></div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; m_Meshes.size(); ++i)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> vboAddr = nvnBufferGetAddress(&amp;m_Meshes[i]-&gt;m_VertexBuffer);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (std::map&lt;std::string, uint32_t&gt;::iterator itr = shaderData.m_AttributeLocations.begin(); itr != shaderData.m_AttributeLocations.end(); ++itr)</div>
<div class="line">        {</div>
<div class="line">            PBRModelData::VertexAttributeModelData&amp; attr = m_Meshes[i]-&gt;m_VertexAttributeData.at(itr-&gt;first);</div>
<div class="line"> </div>
<div class="line">            nvnCommandBufferBindVertexBuffer(pCommandBuffer, itr-&gt;second, vboAddr + attr.m_BufferOffset, attr.m_DataSize);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        m_Meshes[i]-&gt;BindUniforms(pCommandBuffer, programName);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Bind the vertex attribute states and vertex stream states. */</span></div>
<div class="line">        nvnCommandBufferBindVertexAttribState(pCommandBuffer, <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(shaderData.m_AttributeLocations.size()), &amp;shaderData.m_VertexAttributeStates[0]);</div>
<div class="line">        nvnCommandBufferBindVertexStreamState(pCommandBuffer, <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(shaderData.m_AttributeLocations.size()), &amp;shaderData.m_VertexStreamStates[0]);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Bind shader program */</span></div>
<div class="line">        <span class="keywordflow">if</span> (shaderProgramData-&gt;GetProgramData().size())</div>
<div class="line">        {</div>
<div class="line">            shaderProgramData-&gt;GetProgramData()[0]-&gt;BindShaderProgram(pCommandBuffer);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (shaderProgramData-&gt;GetSpecializedProgramData().size())</div>
<div class="line">        {</div>
<div class="line">            shaderProgramData-&gt;GetSpecializedProgramData()[0]-&gt;BindShaderProgram(pCommandBuffer, m_Meshes[i]-&gt;m_SpecializeShaderIndices.at(programName));</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Draw the model. */</span></div>
<div class="line">        <a class="code" href="group__nvn__c__enum.html#gaaf90e0c2dbdc1e42db8192f0c0cb1522">NVNindexType</a> indexType = Mesh::g_IndexTypeNVN;</div>
<div class="line">        nvnCommandBufferDrawElementsIndirect(pCommandBuffer,</div>
<div class="line">                                             Mesh::g_DrawPrimitiveTypeNVN,</div>
<div class="line">                                             indexType,</div>
<div class="line">                                             nvnBufferGetAddress(&amp;m_Meshes[i]-&gt;m_IndexBuffer),</div>
<div class="line">                                             drawIndirectBufferAddress + drawIndirectObjectBufferOffset +</div>
<div class="line">                                             <span class="keyword">sizeof</span>(<a class="code" href="struct_n_v_ndraw_elements_indirect_data.html">NVNdrawElementsIndirectData</a>) * i);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::ObjectCulled Constructor</span></div>
<div class="line"><span class="comment"> * -----------------------------------</span></div>
<div class="line"><span class="comment"> * Empty constructor.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">ObjectCulled::ObjectCulled()</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::ObjectCulled Destructor</span></div>
<div class="line"><span class="comment"> * ----------------------------------</span></div>
<div class="line"><span class="comment"> * Cleans up the indirect command buffers.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">ObjectCulled::~ObjectCulled()</div>
<div class="line">{</div>
<div class="line">        <span class="comment">/* Clean up command buffer memory and objects */</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; m_DrawIndirectCommandBuffers.size(); ++i)</div>
<div class="line">    {</div>
<div class="line">        nvnCommandBufferFinalize(&amp;(m_DrawIndirectCommandBuffers[i]-&gt;m_CommandBuffer));</div>
<div class="line">        m_DrawIndirectCommandBuffers[i]-&gt;m_pCommandMemoryPool-&gt;Shutdown();</div>
<div class="line"> </div>
<div class="line">        AlignedDeallocate(m_DrawIndirectCommandBuffers[i]-&gt;m_pControlPool);</div>
<div class="line">        <span class="keyword">delete</span> m_DrawIndirectCommandBuffers[i];</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    m_DrawIndirectCommandBuffers.clear();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::ObjectCulled::Draw</span></div>
<div class="line"><span class="comment"> * -----------------------------</span></div>
<div class="line"><span class="comment"> * Binds render state, uniforms, shader program (if needed),</span></div>
<div class="line"><span class="comment"> * and draws the model. If the model has LODs, the appropriate</span></div>
<div class="line"><span class="comment"> * uniforms are bound and LODs are drawn.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> ObjectCulled::Draw(<a class="code" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a>* pCommandBuffer,</div>
<div class="line">                        <span class="keyword">const</span> std::string&amp; programName,</div>
<div class="line">                        <span class="keyword">const</span> std::map&lt;std::string, PBRObject::ModelCulled&gt;&amp; models,</div>
<div class="line">                        AssetFileDataHolder* shaderData)</div>
<div class="line">{</div>
<div class="line">        <span class="comment">/* Bind the render state */</span></div>
<div class="line">    BindState(pCommandBuffer);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Bind the per model uniforms */</span></div>
<div class="line">    BindModelUniforms(pCommandBuffer, programName);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* If needed, bind the material uniforms held by the object */</span></div>
<div class="line">    <span class="keywordflow">if</span> (m_MaterialUniformBuffers.find(programName) != m_MaterialUniformBuffers.end())</div>
<div class="line">    {</div>
<div class="line">        BindMaterialUniforms(pCommandBuffer, programName);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (shaderData-&gt;GetProgramData().size())</div>
<div class="line">        {</div>
<div class="line">            shaderData-&gt;GetProgramData()[0]-&gt;BindShaderProgram(pCommandBuffer);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (shaderData-&gt;GetSpecializedProgramData().size())</div>
<div class="line">        {</div>
<div class="line">            shaderData-&gt;GetSpecializedProgramData()[0]-&gt;BindShaderProgram(pCommandBuffer, m_SpecializeShaderIndices.at(programName));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Draw the model via call commands */</span></div>
<div class="line">    <span class="keywordflow">if</span> (m_LodsToDraw[programName].size())</div>
<div class="line">    {</div>
<div class="line">            <span class="comment">/* If the model has LODs, draw the chosen LOD(s) and blend if needed */</span></div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; m_LodsToDraw[programName].size(); ++i)</div>
<div class="line">        {</div>
<div class="line">            std::string modelName = m_LodInfo[m_LodsToDraw[programName][i].m_Index].m_Name;</div>
<div class="line"> </div>
<div class="line">                <span class="comment">/*</span></div>
<div class="line"><span class="comment">                 * If the model name is blank that means that the &quot;cull&quot; detail level</span></div>
<div class="line"><span class="comment">                 * has been hit and no mesh needs to be drawn.</span></div>
<div class="line"><span class="comment">                 */</span></div>
<div class="line">            <span class="keywordflow">if</span> (modelName == <span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line">                <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">            uint32_t lodIndex = m_LodsToDraw[programName][i].m_Index;</div>
<div class="line"> </div>
<div class="line">            nvnCommandBufferBindUniformBuffer(pCommandBuffer,</div>
<div class="line">                                              m_LodUniforms[programName][lodIndex].m_ShaderStage,</div>
<div class="line">                                              m_LodUniforms[programName][lodIndex].m_BindingLocation,</div>
<div class="line">                                              m_LodUniforms[programName][lodIndex].m_pUniformBuffer-&gt;GetCurrentBufferAddress(),</div>
<div class="line">                                              m_LodUniforms[programName][lodIndex].m_Size);</div>
<div class="line"> </div>
<div class="line">            <a class="code" href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a> drawHandle = models.at(modelName).GetCommandHandle(programName);</div>
<div class="line">            nvnCommandBufferCallCommands(pCommandBuffer, 1, &amp;drawHandle);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">            <span class="comment">/* If no LODs, just draw the base model */</span></div>
<div class="line">        <a class="code" href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a> drawHandle = models.at(GetModel()).GetCommandHandle(programName);</div>
<div class="line">        nvnCommandBufferCallCommands(pCommandBuffer, 1, &amp;drawHandle);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::ObjectCulled::DrawIndirect</span></div>
<div class="line"><span class="comment"> * -------------------------------------</span></div>
<div class="line"><span class="comment"> * Draws the models using the indirect draw data from the</span></div>
<div class="line"><span class="comment"> * frustum culling pass.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> ObjectCulled::DrawIndirect(<a class="code" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a>* pCommandBuffer,</div>
<div class="line">                                <span class="keyword">const</span> std::string&amp; programName,</div>
<div class="line">                                AssetFileDataHolder* shaderData)</div>
<div class="line">{</div>
<div class="line">        <span class="comment">/* Bind the render state */</span></div>
<div class="line">    BindState(pCommandBuffer);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Bind the per model uniforms */</span></div>
<div class="line">    BindModelUniforms(pCommandBuffer, programName);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* If needed, bind the material uniforms held by the object */</span></div>
<div class="line">    <span class="keywordflow">if</span> (m_MaterialUniformBuffers.find(programName) != m_MaterialUniformBuffers.end())</div>
<div class="line">    {</div>
<div class="line">        BindMaterialUniforms(pCommandBuffer, programName);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (shaderData-&gt;GetProgramData().size())</div>
<div class="line">        {</div>
<div class="line">            shaderData-&gt;GetProgramData()[0]-&gt;BindShaderProgram(pCommandBuffer);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (shaderData-&gt;GetSpecializedProgramData().size())</div>
<div class="line">        {</div>
<div class="line">            shaderData-&gt;GetSpecializedProgramData()[0]-&gt;BindShaderProgram(pCommandBuffer, m_SpecializeShaderIndices.at(programName));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Draw the model via call commands */</span></div>
<div class="line">    <span class="keywordflow">if</span> (m_LodsToDraw[programName].size())</div>
<div class="line">    {</div>
<div class="line">            <span class="comment">/* If the model has LODs, draw the chosen LOD(s) and blend if needed */</span></div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; m_LodsToDraw[programName].size(); ++i)</div>
<div class="line">        {</div>
<div class="line">            std::string modelName = m_LodInfo[m_LodsToDraw[programName][i].m_Index].m_Name;</div>
<div class="line"> </div>
<div class="line">                <span class="comment">/*</span></div>
<div class="line"><span class="comment">                 * If the model name is blank that means that the &quot;cull&quot; detail level</span></div>
<div class="line"><span class="comment">                 * has been hit and no mesh needs to be drawn.</span></div>
<div class="line"><span class="comment">                 */</span></div>
<div class="line">            <span class="keywordflow">if</span> (modelName == <span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line">                <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">            uint32_t lodIndex = m_LodsToDraw[programName][i].m_Index;</div>
<div class="line"> </div>
<div class="line">            nvnCommandBufferBindUniformBuffer(pCommandBuffer,</div>
<div class="line">                                              m_LodUniforms[programName][lodIndex].m_ShaderStage,</div>
<div class="line">                                              m_LodUniforms[programName][lodIndex].m_BindingLocation,</div>
<div class="line">                                              m_LodUniforms[programName][lodIndex].m_pUniformBuffer-&gt;GetCurrentBufferAddress(),</div>
<div class="line">                                              m_LodUniforms[programName][lodIndex].m_Size);</div>
<div class="line"> </div>
<div class="line">            <a class="code" href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a> drawHandle = m_DrawIndirectCommandBuffers[lodIndex]-&gt;m_CommandHandle;</div>
<div class="line">            nvnCommandBufferCallCommands(pCommandBuffer, 1, &amp;drawHandle);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a> drawHandle = m_DrawIndirectCommandBuffers[0]-&gt;m_CommandHandle;</div>
<div class="line">        nvnCommandBufferCallCommands(pCommandBuffer, 1, &amp;drawHandle);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::ObjectCulled::SetupDrawIndirectCommandBuffer</span></div>
<div class="line"><span class="comment"> * -------------------------------------------------------</span></div>
<div class="line"><span class="comment"> * Sets up the command buffer to draw the object&#39;s model via indirect draw.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> ObjectCulled::SetupDrawIndirectCommandBuffer(AssetFileDataHolder* shaderProgramData,</div>
<div class="line">                                                  <a name="_a8"></a><a class="code" href="struct_n_v_ndevice.html">NVNdevice</a>* pDevice,</div>
<div class="line">                                                  uint32_t commandMemorySize,</div>
<div class="line">                                                  uint32_t controlMemorySize,</div>
<div class="line">                                                  std::map&lt;std::string, PBRObject::ModelCulled&gt;&amp; models,</div>
<div class="line">                                                  <span class="keyword">const</span> <a class="code" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&amp; drawIndirectBufferAddress)</div>
<div class="line">{</div>
<div class="line">        <span class="comment">/* Grab the command and control alignment values */</span></div>
<div class="line">    <span class="keywordtype">int</span> commandBufferCommandAlignment = 0;</div>
<div class="line">    <span class="keywordtype">int</span> commandBufferControlAlignment = 0;</div>
<div class="line">    nvnDeviceGetInteger(pDevice, <a class="code" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ada72f2b5ef4df11606b61aaa86f6f22c">NVN_DEVICE_INFO_COMMAND_BUFFER_COMMAND_ALIGNMENT</a>, &amp;commandBufferCommandAlignment);</div>
<div class="line">    nvnDeviceGetInteger(pDevice, <a class="code" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a743ea42e337a76b9d8ed34181a0d802e">NVN_DEVICE_INFO_COMMAND_BUFFER_CONTROL_ALIGNMENT</a>, &amp;commandBufferControlAlignment);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (m_LodInfo.size() &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; m_LodInfo.size(); ++i)</div>
<div class="line">        {</div>
<div class="line">            std::string modelName = m_LodInfo[i].m_Name;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (modelName == <span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line">                <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">            m_DrawIndirectCommandBuffers.push_back(<span class="keyword">new</span> PBRModelData::CommandBufferData);</div>
<div class="line">            PBRModelData::CommandBufferData* commandBufferData = m_DrawIndirectCommandBuffers.back();</div>
<div class="line"> </div>
<div class="line">                <span class="comment">/* Create a new command buffer */</span>            ;</div>
<div class="line">            <span class="keywordflow">if</span> (!nvnCommandBufferInitialize(&amp;commandBufferData-&gt;m_CommandBuffer, pDevice))</div>
<div class="line">            {</div>
<div class="line">                <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;nvnCommandBufferInitialize failed&quot;</span>);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">                 <span class="comment">/* Create a memory pool for the command buffer */</span></div>
<div class="line">            commandBufferData-&gt;m_pCommandMemoryPool = <span class="keyword">new</span> <a class="code" href="namespacenn_1_1gfx.html#ad620d8208dd309eb7c4dd5973a6aeee5">MemoryPool</a>();</div>
<div class="line">            commandBufferData-&gt;m_pCommandMemoryPool-&gt;Init(NULL,</div>
<div class="line">                                                         Align(commandMemorySize, commandBufferCommandAlignment),</div>
<div class="line">                                                         <a class="code" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a93f5342f52f301cfdca9901586b9b8e1">NVN_MEMORY_POOL_FLAGS_CPU_UNCACHED_BIT</a> | <a class="code" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a81b40bf9e82d33f8c546a95fc5ce5f7e">NVN_MEMORY_POOL_FLAGS_GPU_CACHED_BIT</a>,</div>
<div class="line">                                                         pDevice);</div>
<div class="line"> </div>
<div class="line">                <span class="comment">/* Allocate the control memory */</span></div>
<div class="line">            commandBufferData-&gt;m_pControlPool = AlignedAllocate(controlMemorySize, commandBufferControlAlignment);</div>
<div class="line"> </div>
<div class="line">            ptrdiff_t offset = commandBufferData-&gt;m_pCommandMemoryPool-&gt;GetNewMemoryChunkOffset(commandMemorySize, commandBufferCommandAlignment);</div>
<div class="line"> </div>
<div class="line">            nvnCommandBufferAddCommandMemory(&amp;commandBufferData-&gt;m_CommandBuffer,</div>
<div class="line">                                             commandBufferData-&gt;m_pCommandMemoryPool-&gt;GetMemoryPool(),</div>
<div class="line">                                             offset,</div>
<div class="line">                                             Align(commandMemorySize, commandBufferCommandAlignment));</div>
<div class="line"> </div>
<div class="line">            nvnCommandBufferAddControlMemory(&amp;commandBufferData-&gt;m_CommandBuffer,</div>
<div class="line">                                             commandBufferData-&gt;m_pControlPool,</div>
<div class="line">                                             Align(controlMemorySize, commandBufferControlAlignment));</div>
<div class="line"> </div>
<div class="line">            nvnCommandBufferBeginRecording(&amp;commandBufferData-&gt;m_CommandBuffer);</div>
<div class="line"> </div>
<div class="line">                <span class="comment">/* Records the commands for drawing the model */</span></div>
<div class="line">            models.at(modelName).DrawModelIndirect(&amp;commandBufferData-&gt;m_CommandBuffer, shaderProgramData, drawIndirectBufferAddress, m_DrawIndirectDataBufferOffset + i * <span class="keyword">sizeof</span>(<a class="code" href="struct_n_v_ndraw_elements_indirect_data.html">NVNdrawElementsIndirectData</a>));</div>
<div class="line"> </div>
<div class="line">                <span class="comment">/* Hold onto the command buffer handle to be used later with nvnCommandBufferCallCommands */</span></div>
<div class="line">            commandBufferData-&gt;m_CommandHandle = nvnCommandBufferEndRecording(&amp;commandBufferData-&gt;m_CommandBuffer);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        m_DrawIndirectCommandBuffers.push_back(<span class="keyword">new</span> PBRModelData::CommandBufferData);</div>
<div class="line">        PBRModelData::CommandBufferData* commandBufferData = m_DrawIndirectCommandBuffers.back();</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (!nvnCommandBufferInitialize(&amp;commandBufferData-&gt;m_CommandBuffer, pDevice))</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;nvnCommandBufferInitialize failed&quot;</span>);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        commandBufferData-&gt;m_pCommandMemoryPool = <span class="keyword">new</span> <a class="code" href="namespacenn_1_1gfx.html#ad620d8208dd309eb7c4dd5973a6aeee5">MemoryPool</a>();</div>
<div class="line">        commandBufferData-&gt;m_pCommandMemoryPool-&gt;Init(NULL,</div>
<div class="line">                                                      Align(commandMemorySize, commandBufferCommandAlignment),</div>
<div class="line">                                                      <a class="code" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a93f5342f52f301cfdca9901586b9b8e1">NVN_MEMORY_POOL_FLAGS_CPU_UNCACHED_BIT</a> | <a class="code" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a81b40bf9e82d33f8c546a95fc5ce5f7e">NVN_MEMORY_POOL_FLAGS_GPU_CACHED_BIT</a>,</div>
<div class="line">                                                      pDevice);</div>
<div class="line"> </div>
<div class="line">        commandBufferData-&gt;m_pControlPool = AlignedAllocate(controlMemorySize, commandBufferControlAlignment);</div>
<div class="line"> </div>
<div class="line">        ptrdiff_t offset = commandBufferData-&gt;m_pCommandMemoryPool-&gt;GetNewMemoryChunkOffset(commandMemorySize, commandBufferCommandAlignment);</div>
<div class="line"> </div>
<div class="line">        nvnCommandBufferAddCommandMemory(&amp;commandBufferData-&gt;m_CommandBuffer,</div>
<div class="line">                                         commandBufferData-&gt;m_pCommandMemoryPool-&gt;GetMemoryPool(),</div>
<div class="line">                                         offset,</div>
<div class="line">                                         Align(commandMemorySize, commandBufferCommandAlignment));</div>
<div class="line"> </div>
<div class="line">        nvnCommandBufferAddControlMemory(&amp;commandBufferData-&gt;m_CommandBuffer,</div>
<div class="line">                                         commandBufferData-&gt;m_pControlPool,</div>
<div class="line">                                         Align(controlMemorySize, commandBufferControlAlignment));</div>
<div class="line"> </div>
<div class="line">        nvnCommandBufferBeginRecording(&amp;commandBufferData-&gt;m_CommandBuffer);</div>
<div class="line"> </div>
<div class="line">        models.at(GetModel()).DrawModelIndirect(&amp;commandBufferData-&gt;m_CommandBuffer, shaderProgramData, drawIndirectBufferAddress, m_DrawIndirectDataBufferOffset);</div>
<div class="line"> </div>
<div class="line">        commandBufferData-&gt;m_CommandHandle = nvnCommandBufferEndRecording(&amp;commandBufferData-&gt;m_CommandBuffer);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::ObjectCulled::SetDrawIndirectDataBufferOffset</span></div>
<div class="line"><span class="comment"> * --------------------------------------------------------</span></div>
<div class="line"><span class="comment"> * Sets the NVNdrawElementsIndirect buffer offset.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> ObjectCulled::SetDrawIndirectDataBufferOffset(uint32_t value)</div>
<div class="line">{</div>
<div class="line">    m_DrawIndirectDataBufferOffset = value;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::ObjectCulled::GetDrawIndirectDataBufferOffset</span></div>
<div class="line"><span class="comment"> * --------------------------------------------------------</span></div>
<div class="line"><span class="comment"> * Returns the NVNdrawElementsIndirect buffer offset.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">uint32_t ObjectCulled::GetDrawIndirectDataBufferOffset()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> m_DrawIndirectDataBufferOffset;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::ObjectCulled::SetInstanceDataBufferOffset</span></div>
<div class="line"><span class="comment"> * ----------------------------------------------------</span></div>
<div class="line"><span class="comment"> * Sets the instance buffer offset.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> ObjectCulled::SetInstanceDataBufferOffset(uint32_t value)</div>
<div class="line">{</div>
<div class="line">    m_InstanceDataBufferOffset = value;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::ObjectCulled::GetInstanceDataBufferOffset</span></div>
<div class="line"><span class="comment"> * ----------------------------------------------------</span></div>
<div class="line"><span class="comment"> * Returns the instance buffer offset.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">uint32_t ObjectCulled::GetInstanceDataBufferOffset()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> m_InstanceDataBufferOffset;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="a_asset_file_data_holder_8h_html"><div class="ttname"><a href="_asset_file_data_holder_8h.html">AssetFileDataHolder.h</a></div><div class="ttdoc">This files defines some structures that hold the data provided by an asset file created by Tutorial02...</div></div>
<div class="ttc" id="a_p_b_r_model_binary_file_headers_8h_html"><div class="ttname"><a href="_p_b_r_model_binary_file_headers_8h.html">PBRModelBinaryFileHeaders.h</a></div><div class="ttdoc">This file defines the structure of the converted binary model files.</div></div>
<div class="ttc" id="a_p_b_r_object_culled_8h_html"><div class="ttname"><a href="_p_b_r_object_culled_8h.html">PBRObjectCulled.h</a></div><div class="ttdoc">This file defines a version of the PBRObject classes used for frustum culling.</div></div>
<div class="ttc" id="a_tutorial_util_8h_html"><div class="ttname"><a href="_tutorial_util_8h.html">TutorialUtil.h</a></div><div class="ttdoc">This file defines the interface for utility functions used in the tutorials.</div></div>
<div class="ttc" id="a_uniform_buffer_manager_8h_html"><div class="ttname"><a href="_uniform_buffer_manager_8h.html">UniformBufferManager.h</a></div><div class="ttdoc">This file defines a class that manages memory for uniform buffers by using multiple chunks of of GPU ...</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_gaaf90e0c2dbdc1e42db8192f0c0cb1522"><div class="ttname"><a href="group__nvn__c__enum.html#gaaf90e0c2dbdc1e42db8192f0c0cb1522">NVNindexType</a></div><div class="ttdeci">NVNindexType</div><div class="ttdoc">Specifies a data type used for index values in DrawElements commands.</div><div class="ttdef"><b>Definition:</b> nvn.h:2232</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_ggaa7df4970255609d7a317631bcb37d654a81b40bf9e82d33f8c546a95fc5ce5f7e"><div class="ttname"><a href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a81b40bf9e82d33f8c546a95fc5ce5f7e">NVN_MEMORY_POOL_FLAGS_GPU_CACHED_BIT</a></div><div class="ttdeci">@ NVN_MEMORY_POOL_FLAGS_GPU_CACHED_BIT</div><div class="ttdoc">Indicates that the memory pool will be accessed by the GPU with caching.</div><div class="ttdef"><b>Definition:</b> nvn.h:3069</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_ggaa7df4970255609d7a317631bcb37d654a93f5342f52f301cfdca9901586b9b8e1"><div class="ttname"><a href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a93f5342f52f301cfdca9901586b9b8e1">NVN_MEMORY_POOL_FLAGS_CPU_UNCACHED_BIT</a></div><div class="ttdeci">@ NVN_MEMORY_POOL_FLAGS_CPU_UNCACHED_BIT</div><div class="ttdoc">Indicates that the memory pool will be accessed by the CPU without caching.</div><div class="ttdef"><b>Definition:</b> nvn.h:3008</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_ggac887e20e2474bb76b87943b0f0be7a50a743ea42e337a76b9d8ed34181a0d802e"><div class="ttname"><a href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a743ea42e337a76b9d8ed34181a0d802e">NVN_DEVICE_INFO_COMMAND_BUFFER_CONTROL_ALIGNMENT</a></div><div class="ttdeci">@ NVN_DEVICE_INFO_COMMAND_BUFFER_CONTROL_ALIGNMENT</div><div class="ttdoc">Minimum alignment for control data in a command builder.</div><div class="ttdef"><b>Definition:</b> nvn.h:567</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_ggac887e20e2474bb76b87943b0f0be7a50ada72f2b5ef4df11606b61aaa86f6f22c"><div class="ttname"><a href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ada72f2b5ef4df11606b61aaa86f6f22c">NVN_DEVICE_INFO_COMMAND_BUFFER_COMMAND_ALIGNMENT</a></div><div class="ttdeci">@ NVN_DEVICE_INFO_COMMAND_BUFFER_COMMAND_ALIGNMENT</div><div class="ttdoc">Minimum alignment for command data in a command builder.</div><div class="ttdef"><b>Definition:</b> nvn.h:564</div></div>
<div class="ttc" id="agroup__nvn__c__handle_html_ga067da3a838f115226c89fad655278f80"><div class="ttname"><a href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a></div><div class="ttdeci">uint64_t NVNbufferAddress</div><div class="ttdoc">GPU address of memory inside a buffer object.</div><div class="ttdef"><b>Definition:</b> nvn.h:434</div></div>
<div class="ttc" id="agroup__nvn__c__handle_html_gab7f10945ffe1f6161c87238c75ae411d"><div class="ttname"><a href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a></div><div class="ttdeci">uint64_t NVNcommandHandle</div><div class="ttdoc">GPU handle used to refer to a command buffer object.</div><div class="ttdef"><b>Definition:</b> nvn.h:437</div></div>
<div class="ttc" id="anamespacenn_1_1gfx_html_ad620d8208dd309eb7c4dd5973a6aeee5"><div class="ttname"><a href="namespacenn_1_1gfx.html#ad620d8208dd309eb7c4dd5973a6aeee5">nn::gfx::MemoryPool</a></div><div class="ttdeci">TMemoryPool&lt; TargetConfig::Variation &gt; MemoryPool</div><div class="ttdoc">The type definition representing a memory pool.</div><div class="ttdef"><b>Definition:</b> gfx_Types.h:116</div></div>
<div class="ttc" id="ann___assert_8h_html_ade59d1d911907a16c0241f8fe3b31542"><div class="ttname"><a href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a></div><div class="ttdeci">#define NN_ASSERT(condition,...)</div><div class="ttdoc">Tests whether a condition is satisfied.</div><div class="ttdef"><b>Definition:</b> nn_Assert.h:124</div></div>
<div class="ttc" id="anvn___func_ptr_inline_8h_html"><div class="ttname"><a href="nvn___func_ptr_inline_8h.html">nvn_FuncPtrInline.h</a></div><div class="ttdoc">Implementation of the NVN C interface entry points as inline functions that call through global funct...</div></div>
<div class="ttc" id="astruct_n_v_ncommand_buffer_html"><div class="ttname"><a href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a></div><div class="ttdoc">Collection of commands to send to the GPU via queues.</div><div class="ttdef"><b>Definition:</b> nvn.h:236</div></div>
<div class="ttc" id="astruct_n_v_ndevice_html"><div class="ttname"><a href="struct_n_v_ndevice.html">NVNdevice</a></div><div class="ttdoc">API class used to represent a specific GPU/device.</div><div class="ttdef"><b>Definition:</b> nvn.h:221</div></div>
<div class="ttc" id="astruct_n_v_ndraw_elements_indirect_data_html"><div class="ttname"><a href="struct_n_v_ndraw_elements_indirect_data.html">NVNdrawElementsIndirectData</a></div><div class="ttdoc">Data structure representing values used by indirect DrawElements commands.</div><div class="ttdef"><b>Definition:</b> nvn.h:4284</div></div>
<div class="ttc" id="astruct_n_v_ndraw_elements_indirect_data_html_a5589d1accff9f2eb4e89470486661315"><div class="ttname"><a href="struct_n_v_ndraw_elements_indirect_data.html#a5589d1accff9f2eb4e89470486661315">NVNdrawElementsIndirectData::baseVertex</a></div><div class="ttdeci">int baseVertex</div><div class="ttdoc">Base vertex number to be added to each vertex index fetched from the index buffer.</div><div class="ttdef"><b>Definition:</b> nvn.h:4299</div></div>
<div class="ttc" id="astruct_n_v_ndraw_elements_indirect_data_html_a7ff6bb51c25820a3fe45d9b5e14dfbba"><div class="ttname"><a href="struct_n_v_ndraw_elements_indirect_data.html#a7ff6bb51c25820a3fe45d9b5e14dfbba">NVNdrawElementsIndirectData::count</a></div><div class="ttdeci">int count</div><div class="ttdoc">Number of vertices in each instance (copy) of the primitives to be drawn.</div><div class="ttdef"><b>Definition:</b> nvn.h:4288</div></div>
<div class="ttc" id="astruct_n_v_ndraw_elements_indirect_data_html_aa5efefaac79529ac391c6dcd45cd8f08"><div class="ttname"><a href="struct_n_v_ndraw_elements_indirect_data.html#aa5efefaac79529ac391c6dcd45cd8f08">NVNdrawElementsIndirectData::firstIndex</a></div><div class="ttdeci">int firstIndex</div><div class="ttdoc">Offset (in units of indices) in the index buffer of the first vertex in each drawn instance.</div><div class="ttdef"><b>Definition:</b> nvn.h:4295</div></div>
<div class="ttc" id="astruct_n_v_ndraw_elements_indirect_data_html_ad993a9493e2298af43a4b8bb6a8d4387"><div class="ttname"><a href="struct_n_v_ndraw_elements_indirect_data.html#ad993a9493e2298af43a4b8bb6a8d4387">NVNdrawElementsIndirectData::instanceCount</a></div><div class="ttdeci">int instanceCount</div><div class="ttdoc">Number of instances (copies) of the primitives to be drawn.</div><div class="ttdef"><b>Definition:</b> nvn.h:4291</div></div>
<div class="ttc" id="astruct_n_v_ndraw_elements_indirect_data_html_adc71161b8ddd11a39a5b292108ff25f4"><div class="ttname"><a href="struct_n_v_ndraw_elements_indirect_data.html#adc71161b8ddd11a39a5b292108ff25f4">NVNdrawElementsIndirectData::baseInstance</a></div><div class="ttdeci">int baseInstance</div><div class="ttdoc">Instance number of the first instance drawn.</div><div class="ttdef"><b>Definition:</b> nvn.h:4302</div></div>
</div><!-- fragment --> </div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
