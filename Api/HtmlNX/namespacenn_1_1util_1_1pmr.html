<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nn::util::pmr Namespace Reference | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenn.html">nn</a></li><li class="navelem"><a class="el" href="namespacenn_1_1util.html">util</a></li><li class="navelem"><a class="el" href="namespacenn_1_1util_1_1pmr.html">pmr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">nn::util::pmr Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides the functionality for handling memory resources conforming to the <code>std::pmr</code> namespace.  
<a href="namespacenn_1_1util_1_1pmr.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html">PolymorphicAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory allocator class that provides the same functionality as <code>std::pmr::polymorphic_allocator</code>.  <a href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9b53675029d9ef5415469f9e36e4c5ca"><td class="memTemplParams" colspan="2"><a id="a9b53675029d9ef5415469f9e36e4c5ca"></a>
template&lt;typename CharT , typename Traits  = std::char_traits&lt;CharT&gt;&gt; </td></tr>
<tr class="memitem:a9b53675029d9ef5415469f9e36e4c5ca"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1pmr.html#a9b53675029d9ef5415469f9e36e4c5ca">BasicString</a> = std::basic_string&lt; CharT, Traits, <a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html">PolymorphicAllocator</a>&lt; CharT &gt; &gt;</td></tr>
<tr class="memdesc:a9b53675029d9ef5415469f9e36e4c5ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of the <code>std::basic_string</code> alias that <code><a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html" title="Memory allocator class that provides the same functionality as std::pmr::polymorphic_allocator.">PolymorphicAllocator</a></code> will use for the allocator. <br /></td></tr>
<tr class="separator:a9b53675029d9ef5415469f9e36e4c5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa997031807a4441fe29761a5279727df"><td class="memItemLeft" align="right" valign="top"><a id="aa997031807a4441fe29761a5279727df"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1pmr.html#aa997031807a4441fe29761a5279727df">CMatch</a> = <a class="el" href="namespacenn_1_1util_1_1pmr.html#ad2b7ad3e3f81e330d4672bf373890c7e">MatchResults</a>&lt; const char * &gt;</td></tr>
<tr class="memdesc:aa997031807a4441fe29761a5279727df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of the alias equivalent of <code>std::cmatch</code> that <code><a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html" title="Memory allocator class that provides the same functionality as std::pmr::polymorphic_allocator.">PolymorphicAllocator</a></code> will use for the allocator. <br /></td></tr>
<tr class="separator:aa997031807a4441fe29761a5279727df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0691d8d35a958bea103e815909afdc5c"><td class="memTemplParams" colspan="2"><a id="a0691d8d35a958bea103e815909afdc5c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0691d8d35a958bea103e815909afdc5c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1pmr.html#a0691d8d35a958bea103e815909afdc5c">Deque</a> = std::deque&lt; T, <a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html">PolymorphicAllocator</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a0691d8d35a958bea103e815909afdc5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of the <code>std::deque</code> alias that <code><a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html" title="Memory allocator class that provides the same functionality as std::pmr::polymorphic_allocator.">PolymorphicAllocator</a></code> will use for the allocator. <br /></td></tr>
<tr class="separator:a0691d8d35a958bea103e815909afdc5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd72ea78b0c2b46b2f705745c13e947"><td class="memTemplParams" colspan="2"><a id="a2dd72ea78b0c2b46b2f705745c13e947"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2dd72ea78b0c2b46b2f705745c13e947"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1pmr.html#a2dd72ea78b0c2b46b2f705745c13e947">ForwardList</a> = std::forward_list&lt; T, <a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html">PolymorphicAllocator</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a2dd72ea78b0c2b46b2f705745c13e947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of the <code>std::forward_list</code> alias that <code><a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html" title="Memory allocator class that provides the same functionality as std::pmr::polymorphic_allocator.">PolymorphicAllocator</a></code> will use for the allocator. <br /></td></tr>
<tr class="separator:a2dd72ea78b0c2b46b2f705745c13e947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93fd8ff66f22954d6a3a9fa50102094d"><td class="memTemplParams" colspan="2"><a id="a93fd8ff66f22954d6a3a9fa50102094d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a93fd8ff66f22954d6a3a9fa50102094d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1pmr.html#a93fd8ff66f22954d6a3a9fa50102094d">List</a> = std::list&lt; T, <a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html">PolymorphicAllocator</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a93fd8ff66f22954d6a3a9fa50102094d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of the <code>std::list</code> alias that <code><a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html" title="Memory allocator class that provides the same functionality as std::pmr::polymorphic_allocator.">PolymorphicAllocator</a></code> will use for the allocator. <br /></td></tr>
<tr class="separator:a93fd8ff66f22954d6a3a9fa50102094d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ad7c31da029524b5dad558eba5c632"><td class="memTemplParams" colspan="2"><a id="a40ad7c31da029524b5dad558eba5c632"></a>
template&lt;typename Key , typename T , typename Compare  = std::less&lt;Key&gt;&gt; </td></tr>
<tr class="memitem:a40ad7c31da029524b5dad558eba5c632"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1pmr.html#a40ad7c31da029524b5dad558eba5c632">Map</a> = std::map&lt; Key, T, Compare, <a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html">PolymorphicAllocator</a>&lt; std::pair&lt; const Key, T &gt; &gt;&gt;</td></tr>
<tr class="memdesc:a40ad7c31da029524b5dad558eba5c632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of the <code>std::map</code> alias that <code><a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html" title="Memory allocator class that provides the same functionality as std::pmr::polymorphic_allocator.">PolymorphicAllocator</a></code> will use for the allocator. <br /></td></tr>
<tr class="separator:a40ad7c31da029524b5dad558eba5c632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b7ad3e3f81e330d4672bf373890c7e"><td class="memTemplParams" colspan="2"><a id="ad2b7ad3e3f81e330d4672bf373890c7e"></a>
template&lt;typename BidirectionalIterator &gt; </td></tr>
<tr class="memitem:ad2b7ad3e3f81e330d4672bf373890c7e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1pmr.html#ad2b7ad3e3f81e330d4672bf373890c7e">MatchResults</a> = std::match_results&lt; BidirectionalIterator, <a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html">PolymorphicAllocator</a>&lt; std::sub_match&lt; BidirectionalIterator &gt; &gt;&gt;</td></tr>
<tr class="memdesc:ad2b7ad3e3f81e330d4672bf373890c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of the <code>std::match_results</code> alias that <code><a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html" title="Memory allocator class that provides the same functionality as std::pmr::polymorphic_allocator.">PolymorphicAllocator</a></code> will use for the allocator. <br /></td></tr>
<tr class="separator:ad2b7ad3e3f81e330d4672bf373890c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4016efa76d0ac6a78c2d1eea156358d2"><td class="memTemplParams" colspan="2"><a id="a4016efa76d0ac6a78c2d1eea156358d2"></a>
template&lt;typename Key , typename T , typename Compare  = std::less&lt;Key&gt;&gt; </td></tr>
<tr class="memitem:a4016efa76d0ac6a78c2d1eea156358d2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1pmr.html#a4016efa76d0ac6a78c2d1eea156358d2">Multimap</a> = std::multimap&lt; Key, T, Compare, <a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html">PolymorphicAllocator</a>&lt; std::pair&lt; const Key, T &gt; &gt;&gt;</td></tr>
<tr class="memdesc:a4016efa76d0ac6a78c2d1eea156358d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of the <code>std::multimap</code> alias that <code><a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html" title="Memory allocator class that provides the same functionality as std::pmr::polymorphic_allocator.">PolymorphicAllocator</a></code> will use for the allocator. <br /></td></tr>
<tr class="separator:a4016efa76d0ac6a78c2d1eea156358d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1972b930ea1cc60a3b914d72707fc154"><td class="memTemplParams" colspan="2"><a id="a1972b930ea1cc60a3b914d72707fc154"></a>
template&lt;typename Key , typename Compare  = std::less&lt;Key&gt;&gt; </td></tr>
<tr class="memitem:a1972b930ea1cc60a3b914d72707fc154"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1pmr.html#a1972b930ea1cc60a3b914d72707fc154">Multiset</a> = std::multiset&lt; Key, Compare, <a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html">PolymorphicAllocator</a>&lt; Key &gt; &gt;</td></tr>
<tr class="memdesc:a1972b930ea1cc60a3b914d72707fc154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of the <code>std::multiset</code> alias that <code><a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html" title="Memory allocator class that provides the same functionality as std::pmr::polymorphic_allocator.">PolymorphicAllocator</a></code> will use for the allocator. <br /></td></tr>
<tr class="separator:a1972b930ea1cc60a3b914d72707fc154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29166793e1166eff3040d7a97d7b6b5"><td class="memTemplParams" colspan="2"><a id="ad29166793e1166eff3040d7a97d7b6b5"></a>
template&lt;typename Key , typename Compare  = std::less&lt;Key&gt;&gt; </td></tr>
<tr class="memitem:ad29166793e1166eff3040d7a97d7b6b5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1pmr.html#ad29166793e1166eff3040d7a97d7b6b5">Set</a> = std::set&lt; Key, Compare, <a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html">PolymorphicAllocator</a>&lt; Key &gt; &gt;</td></tr>
<tr class="memdesc:ad29166793e1166eff3040d7a97d7b6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of the <code>std::set</code> alias that <code><a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html" title="Memory allocator class that provides the same functionality as std::pmr::polymorphic_allocator.">PolymorphicAllocator</a></code> will use for the allocator. <br /></td></tr>
<tr class="separator:ad29166793e1166eff3040d7a97d7b6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78d7b345107a460699c12dfe260b108"><td class="memItemLeft" align="right" valign="top"><a id="ab78d7b345107a460699c12dfe260b108"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1pmr.html#ab78d7b345107a460699c12dfe260b108">SMatch</a> = <a class="el" href="namespacenn_1_1util_1_1pmr.html#ad2b7ad3e3f81e330d4672bf373890c7e">MatchResults</a>&lt; String::const_iterator &gt;</td></tr>
<tr class="memdesc:ab78d7b345107a460699c12dfe260b108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of the alias equivalent of <code>std::smatch</code> that <code><a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html" title="Memory allocator class that provides the same functionality as std::pmr::polymorphic_allocator.">PolymorphicAllocator</a></code> will use for the allocator. <br /></td></tr>
<tr class="separator:ab78d7b345107a460699c12dfe260b108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf5d38fdccc7d2c061e5cffe1e1f12d"><td class="memItemLeft" align="right" valign="top"><a id="a6bf5d38fdccc7d2c061e5cffe1e1f12d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1pmr.html#a6bf5d38fdccc7d2c061e5cffe1e1f12d">String</a> = <a class="el" href="namespacenn_1_1util_1_1pmr.html#a9b53675029d9ef5415469f9e36e4c5ca">BasicString</a>&lt; char &gt;</td></tr>
<tr class="memdesc:a6bf5d38fdccc7d2c061e5cffe1e1f12d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of the alias equivalent of <code>std::string</code> that <code><a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html" title="Memory allocator class that provides the same functionality as std::pmr::polymorphic_allocator.">PolymorphicAllocator</a></code> will use for the allocator. <br /></td></tr>
<tr class="separator:a6bf5d38fdccc7d2c061e5cffe1e1f12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bacaa42b7679917bba2fb5167e673ec"><td class="memItemLeft" align="right" valign="top"><a id="a3bacaa42b7679917bba2fb5167e673ec"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1pmr.html#a3bacaa42b7679917bba2fb5167e673ec">U16String</a> = <a class="el" href="namespacenn_1_1util_1_1pmr.html#a9b53675029d9ef5415469f9e36e4c5ca">BasicString</a>&lt; char16_t &gt;</td></tr>
<tr class="memdesc:a3bacaa42b7679917bba2fb5167e673ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of the alias equivalent of <code>std::u16string</code> that <code><a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html" title="Memory allocator class that provides the same functionality as std::pmr::polymorphic_allocator.">PolymorphicAllocator</a></code> will use for the allocator. <br /></td></tr>
<tr class="separator:a3bacaa42b7679917bba2fb5167e673ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8e3010a9df8cb9fdc98875a80fc9d3"><td class="memItemLeft" align="right" valign="top"><a id="a2c8e3010a9df8cb9fdc98875a80fc9d3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1pmr.html#a2c8e3010a9df8cb9fdc98875a80fc9d3">U32String</a> = <a class="el" href="namespacenn_1_1util_1_1pmr.html#a9b53675029d9ef5415469f9e36e4c5ca">BasicString</a>&lt; char32_t &gt;</td></tr>
<tr class="memdesc:a2c8e3010a9df8cb9fdc98875a80fc9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of the alias equivalent of <code>std::u32string</code> that <code><a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html" title="Memory allocator class that provides the same functionality as std::pmr::polymorphic_allocator.">PolymorphicAllocator</a></code> will use for the allocator. <br /></td></tr>
<tr class="separator:a2c8e3010a9df8cb9fdc98875a80fc9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d339245814febab7261c7bb9cb580a2"><td class="memTemplParams" colspan="2"><a id="a1d339245814febab7261c7bb9cb580a2"></a>
template&lt;typename Key , typename T , typename Hash  = std::hash&lt;Key&gt;, typename Pred  = std::equal_to&lt;Key&gt;&gt; </td></tr>
<tr class="memitem:a1d339245814febab7261c7bb9cb580a2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1pmr.html#a1d339245814febab7261c7bb9cb580a2">UnorderedMap</a> = std::unordered_map&lt; Key, T, Hash, Pred, <a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html">PolymorphicAllocator</a>&lt; std::pair&lt; const Key, T &gt; &gt;&gt;</td></tr>
<tr class="memdesc:a1d339245814febab7261c7bb9cb580a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of the <code>std::unordered_map</code> alias that <code><a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html" title="Memory allocator class that provides the same functionality as std::pmr::polymorphic_allocator.">PolymorphicAllocator</a></code> will use for the allocator. <br /></td></tr>
<tr class="separator:a1d339245814febab7261c7bb9cb580a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1dd513bb2a7c0c01ae932a40a78769"><td class="memTemplParams" colspan="2"><a id="a7a1dd513bb2a7c0c01ae932a40a78769"></a>
template&lt;typename Key , typename T , typename Hash  = std::hash&lt;Key&gt;, typename Pred  = std::equal_to&lt;Key&gt;&gt; </td></tr>
<tr class="memitem:a7a1dd513bb2a7c0c01ae932a40a78769"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1pmr.html#a7a1dd513bb2a7c0c01ae932a40a78769">UnorderedMultimap</a> = std::unordered_multimap&lt; Key, T, Hash, Pred, <a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html">PolymorphicAllocator</a>&lt; std::pair&lt; const Key, T &gt; &gt;&gt;</td></tr>
<tr class="memdesc:a7a1dd513bb2a7c0c01ae932a40a78769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of the <code>std::unordered_multimap</code> alias that <code><a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html" title="Memory allocator class that provides the same functionality as std::pmr::polymorphic_allocator.">PolymorphicAllocator</a></code> will use for the allocator. <br /></td></tr>
<tr class="separator:a7a1dd513bb2a7c0c01ae932a40a78769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c27d8a4ae22266d62a8f21313e0935c"><td class="memTemplParams" colspan="2"><a id="a9c27d8a4ae22266d62a8f21313e0935c"></a>
template&lt;typename Key , typename Hash  = std::hash&lt;Key&gt;, typename Pred  = std::equal_to&lt;Key&gt;&gt; </td></tr>
<tr class="memitem:a9c27d8a4ae22266d62a8f21313e0935c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1pmr.html#a9c27d8a4ae22266d62a8f21313e0935c">UnorderedMultiset</a> = std::unordered_multiset&lt; Key, Hash, Pred, <a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html">PolymorphicAllocator</a>&lt; Key &gt; &gt;</td></tr>
<tr class="memdesc:a9c27d8a4ae22266d62a8f21313e0935c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of the <code>std::unordered_multiset</code> alias that <code><a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html" title="Memory allocator class that provides the same functionality as std::pmr::polymorphic_allocator.">PolymorphicAllocator</a></code> will use for the allocator. <br /></td></tr>
<tr class="separator:a9c27d8a4ae22266d62a8f21313e0935c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3e595adb0c936cc6e1ea6f641960d9"><td class="memTemplParams" colspan="2"><a id="a2b3e595adb0c936cc6e1ea6f641960d9"></a>
template&lt;typename Key , typename Hash  = std::hash&lt;Key&gt;, typename Pred  = std::equal_to&lt;Key&gt;&gt; </td></tr>
<tr class="memitem:a2b3e595adb0c936cc6e1ea6f641960d9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1pmr.html#a2b3e595adb0c936cc6e1ea6f641960d9">UnorderedSet</a> = std::unordered_set&lt; Key, Hash, Pred, <a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html">PolymorphicAllocator</a>&lt; Key &gt; &gt;</td></tr>
<tr class="memdesc:a2b3e595adb0c936cc6e1ea6f641960d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of the <code>std::unordered_set</code> alias that <code><a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html" title="Memory allocator class that provides the same functionality as std::pmr::polymorphic_allocator.">PolymorphicAllocator</a></code> will use for the allocator. <br /></td></tr>
<tr class="separator:a2b3e595adb0c936cc6e1ea6f641960d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce109c5c677ec8fd794de62aada310b"><td class="memTemplParams" colspan="2"><a id="acce109c5c677ec8fd794de62aada310b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acce109c5c677ec8fd794de62aada310b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1pmr.html#acce109c5c677ec8fd794de62aada310b">Vector</a> = std::vector&lt; T, <a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html">PolymorphicAllocator</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:acce109c5c677ec8fd794de62aada310b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of the <code>std::vector</code> alias that <code><a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html" title="Memory allocator class that provides the same functionality as std::pmr::polymorphic_allocator.">PolymorphicAllocator</a></code> will use for the allocator. <br /></td></tr>
<tr class="separator:acce109c5c677ec8fd794de62aada310b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10aaf8441b7ba0881c0796751acf13bc"><td class="memItemLeft" align="right" valign="top"><a id="a10aaf8441b7ba0881c0796751acf13bc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1pmr.html#a10aaf8441b7ba0881c0796751acf13bc">WcMatch</a> = <a class="el" href="namespacenn_1_1util_1_1pmr.html#ad2b7ad3e3f81e330d4672bf373890c7e">MatchResults</a>&lt; const wchar_t * &gt;</td></tr>
<tr class="memdesc:a10aaf8441b7ba0881c0796751acf13bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of the alias equivalent of <code>std::wcmatch</code> that <code><a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html" title="Memory allocator class that provides the same functionality as std::pmr::polymorphic_allocator.">PolymorphicAllocator</a></code> will use for the allocator. <br /></td></tr>
<tr class="separator:a10aaf8441b7ba0881c0796751acf13bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5858c9bab550a11826e3fcf2ebe659d2"><td class="memItemLeft" align="right" valign="top"><a id="a5858c9bab550a11826e3fcf2ebe659d2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1pmr.html#a5858c9bab550a11826e3fcf2ebe659d2">WsMatch</a> = <a class="el" href="namespacenn_1_1util_1_1pmr.html#ad2b7ad3e3f81e330d4672bf373890c7e">MatchResults</a>&lt; WString::const_iterator &gt;</td></tr>
<tr class="memdesc:a5858c9bab550a11826e3fcf2ebe659d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of the alias equivalent of <code>std::wsmatch</code> that <code><a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html" title="Memory allocator class that provides the same functionality as std::pmr::polymorphic_allocator.">PolymorphicAllocator</a></code> will use for the allocator. <br /></td></tr>
<tr class="separator:a5858c9bab550a11826e3fcf2ebe659d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff276eef03dc6356f3f48eb8dc44fad"><td class="memItemLeft" align="right" valign="top"><a id="a4ff276eef03dc6356f3f48eb8dc44fad"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1pmr.html#a4ff276eef03dc6356f3f48eb8dc44fad">WString</a> = <a class="el" href="namespacenn_1_1util_1_1pmr.html#a9b53675029d9ef5415469f9e36e4c5ca">BasicString</a>&lt; wchar_t &gt;</td></tr>
<tr class="memdesc:a4ff276eef03dc6356f3f48eb8dc44fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of the alias equivalent of <code>std::wstring</code> that <code><a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html" title="Memory allocator class that provides the same functionality as std::pmr::polymorphic_allocator.">PolymorphicAllocator</a></code> will use for the allocator. <br /></td></tr>
<tr class="separator:a4ff276eef03dc6356f3f48eb8dc44fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab16b6b553352d17f0b4f565edb0b601d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_memory_resource.html">nn::MemoryResource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1pmr.html#ab16b6b553352d17f0b4f565edb0b601d">GetDefaultResource</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab16b6b553352d17f0b4f565edb0b601d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the default instance of <code><a class="el" href="classnn_1_1_memory_resource.html" title="A multiphase memory allocator interface with the same interface as N4529.">nn::MemoryResource</a></code>.  <a href="namespacenn_1_1util_1_1pmr.html#ab16b6b553352d17f0b4f565edb0b601d">More...</a><br /></td></tr>
<tr class="separator:ab16b6b553352d17f0b4f565edb0b601d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8bcefdfcda79128365857f6f0ab49f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_memory_resource.html">nn::MemoryResource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1pmr.html#aba8bcefdfcda79128365857f6f0ab49f">NewDeleteResource</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aba8bcefdfcda79128365857f6f0ab49f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an instance of <code><a class="el" href="classnn_1_1_memory_resource.html" title="A multiphase memory allocator interface with the same interface as N4529.">nn::MemoryResource</a></code> for use by a global scope <code>operator new</code> and global scope <code>operator delete</code>.  <a href="namespacenn_1_1util_1_1pmr.html#aba8bcefdfcda79128365857f6f0ab49f">More...</a><br /></td></tr>
<tr class="separator:aba8bcefdfcda79128365857f6f0ab49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ff5f1484c1a9329663592734e7e779"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a66ff5f1484c1a9329663592734e7e779"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1pmr.html#a66ff5f1484c1a9329663592734e7e779">operator!=</a> (const <a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html">PolymorphicAllocator</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html">PolymorphicAllocator</a>&lt; T2 &gt; &amp;rhs) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a66ff5f1484c1a9329663592734e7e779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified instances of <code><a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html" title="Memory allocator class that provides the same functionality as std::pmr::polymorphic_allocator.">PolymorphicAllocator</a></code> are unequal.  <a href="namespacenn_1_1util_1_1pmr.html#a66ff5f1484c1a9329663592734e7e779">More...</a><br /></td></tr>
<tr class="separator:a66ff5f1484c1a9329663592734e7e779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2657f17dbf92b6527d3b549e88e2b1"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a8e2657f17dbf92b6527d3b549e88e2b1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1pmr.html#a8e2657f17dbf92b6527d3b549e88e2b1">operator==</a> (const <a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html">PolymorphicAllocator</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html">PolymorphicAllocator</a>&lt; T2 &gt; &amp;rhs) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8e2657f17dbf92b6527d3b549e88e2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified instances of <code><a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html" title="Memory allocator class that provides the same functionality as std::pmr::polymorphic_allocator.">PolymorphicAllocator</a></code> are equal.  <a href="namespacenn_1_1util_1_1pmr.html#a8e2657f17dbf92b6527d3b549e88e2b1">More...</a><br /></td></tr>
<tr class="separator:a8e2657f17dbf92b6527d3b549e88e2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f84f272466de29f5db61100d754b37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_memory_resource.html">nn::MemoryResource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1pmr.html#af0f84f272466de29f5db61100d754b37">SetDefaultResource</a> (<a class="el" href="classnn_1_1_memory_resource.html">nn::MemoryResource</a> *pMemoryResource) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af0f84f272466de29f5db61100d754b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default instance of <code><a class="el" href="classnn_1_1_memory_resource.html" title="A multiphase memory allocator interface with the same interface as N4529.">nn::MemoryResource</a></code>.  <a href="namespacenn_1_1util_1_1pmr.html#af0f84f272466de29f5db61100d754b37">More...</a><br /></td></tr>
<tr class="separator:af0f84f272466de29f5db61100d754b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides the functionality for handling memory resources conforming to the <code>std::pmr</code> namespace. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aba8bcefdfcda79128365857f6f0ab49f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba8bcefdfcda79128365857f6f0ab49f">&#9670;&nbsp;</a></span>NewDeleteResource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_memory_resource.html">nn::MemoryResource</a>* nn::util::pmr::NewDeleteResource </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an instance of <code><a class="el" href="classnn_1_1_memory_resource.html" title="A multiphase memory allocator interface with the same interface as N4529.">nn::MemoryResource</a></code> for use by a global scope <code>operator new</code> and global scope <code>operator delete</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the <code><a class="el" href="classnn_1_1_memory_resource.html" title="A multiphase memory allocator interface with the same interface as N4529.">nn::MemoryResource</a></code> instance.</dd></dl>
<p> <b>Details</b> <br  />
 Its behavior is just like <code>std::pmr::new_delete_resource()</code> to get a pointer to an instance of <code><a class="el" href="classnn_1_1_memory_resource.html" title="A multiphase memory allocator interface with the same interface as N4529.">nn::MemoryResource</a></code>. This function can reference instances of <code><a class="el" href="classnn_1_1_memory_resource.html" title="A multiphase memory allocator interface with the same interface as N4529.">nn::MemoryResource</a></code> that have the following characteristics.</p>
<ul>
<li>Memory is allocated and deallocated using <code>::operator new(std::size_t, const std::nothrow_t&amp;)</code> and <code>::operator delete(void*)</code>.</li>
<li>The instance is allocated as a static object. This function always returns a pointer to the same address.</li>
<li>If <em>p</em> is the return value of the function and <em>r</em> is some instance of <code><a class="el" href="classnn_1_1_memory_resource.html" title="A multiphase memory allocator interface with the same interface as N4529.">nn::MemoryResource</a></code>, the function returns a value where <em>p</em>-&gt;is_equal(<em>r</em>) is <em>p</em> == &amp;<em>r</em>. </li>
</ul>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_fontll_save_to_jpeg_2_fontll_save_to_jpeg_8cpp-example.html#a15">FontllSaveToJpeg/FontllSaveToJpeg.cpp</a>, <a class="el" href="_friends_profile_image_2_friends_profile_image_8cpp-example.html#a4">FriendsProfileImage/FriendsProfileImage.cpp</a>, <a class="el" href="_image_jpeg_decoding_2_image_jpeg_decoding_8cpp-example.html#a30">ImageJpegDecoding/ImageJpegDecoding.cpp</a>, <a class="el" href="_image_jpeg_encoding_2_image_jpeg_encoding_8cpp-example.html#a22">ImageJpegEncoding/ImageJpegEncoding.cpp</a>, and <a class="el" href="_nvn_tutorial11_runtime_texture_compression_2_nvn_tutorial11_8cpp-example.html#a41">NvnTutorial11RuntimeTextureCompression/NvnTutorial11.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab16b6b553352d17f0b4f565edb0b601d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab16b6b553352d17f0b4f565edb0b601d">&#9670;&nbsp;</a></span>GetDefaultResource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_memory_resource.html">nn::MemoryResource</a>* nn::util::pmr::GetDefaultResource </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the default instance of <code><a class="el" href="classnn_1_1_memory_resource.html" title="A multiphase memory allocator interface with the same interface as N4529.">nn::MemoryResource</a></code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the default instance of <code><a class="el" href="classnn_1_1_memory_resource.html" title="A multiphase memory allocator interface with the same interface as N4529.">nn::MemoryResource</a></code>.</dd></dl>
<p> <b>Details</b> <br  />
 This function provides the same functionality as <code>std::pmr::get_default_resource()</code>. The default instance of <code><a class="el" href="classnn_1_1_memory_resource.html" title="A multiphase memory allocator interface with the same interface as N4529.">nn::MemoryResource</a></code> gets used when the application does not specify an explicit <code><a class="el" href="classnn_1_1_memory_resource.html" title="A multiphase memory allocator interface with the same interface as N4529.">nn::MemoryResource</a></code> instance when using APIs that require memory resources.</p>
<p>You can change the default instance of <code><a class="el" href="classnn_1_1_memory_resource.html" title="A multiphase memory allocator interface with the same interface as N4529.">nn::MemoryResource</a></code> using the <code><a class="el" href="namespacenn_1_1util_1_1pmr.html#af0f84f272466de29f5db61100d754b37" title="Sets the default instance of nn::MemoryResource.">SetDefaultResource()</a></code> function. The initial default value is the value returned by the <code><a class="el" href="namespacenn_1_1util_1_1pmr.html#aba8bcefdfcda79128365857f6f0ab49f" title="Gets an instance of nn::MemoryResource for use by a global scope operator new and global scope operat...">NewDeleteResource()</a></code> function.</p>
<p>This function is thread-safe. <code><a class="el" href="namespacenn_1_1util_1_1pmr.html#ab16b6b553352d17f0b4f565edb0b601d" title="Gets the default instance of nn::MemoryResource.">GetDefaultResource()</a></code> and <code><a class="el" href="namespacenn_1_1util_1_1pmr.html#af0f84f272466de29f5db61100d754b37" title="Sets the default instance of nn::MemoryResource.">SetDefaultResource()</a></code> can be called simultaneously by multiple threads. </p>

</div>
</div>
<a id="af0f84f272466de29f5db61100d754b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f84f272466de29f5db61100d754b37">&#9670;&nbsp;</a></span>SetDefaultResource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_memory_resource.html">nn::MemoryResource</a>* nn::util::pmr::SetDefaultResource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1_memory_resource.html">nn::MemoryResource</a> *&#160;</td>
          <td class="paramname"><em>pMemoryResource</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the default instance of <code><a class="el" href="classnn_1_1_memory_resource.html" title="A multiphase memory allocator interface with the same interface as N4529.">nn::MemoryResource</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pMemoryResource</td><td>Pointer to the instance of <code><a class="el" href="classnn_1_1_memory_resource.html" title="A multiphase memory allocator interface with the same interface as N4529.">nn::MemoryResource</a></code> to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the default instance of <code><a class="el" href="classnn_1_1_memory_resource.html" title="A multiphase memory allocator interface with the same interface as N4529.">nn::MemoryResource</a></code> that was specified before the function call.</dd></dl>
<p> <b>Details</b> <br  />
 This function provides the same functionality as <code>std::pmr::set_default_resource()</code>. If <code><em>pMemoryResource</em></code> == <code>nullptr</code>, the value returned by the <code><a class="el" href="namespacenn_1_1util_1_1pmr.html#aba8bcefdfcda79128365857f6f0ab49f" title="Gets an instance of nn::MemoryResource for use by a global scope operator new and global scope operat...">NewDeleteResource()</a></code> function is set as the default instance of <code><a class="el" href="classnn_1_1_memory_resource.html" title="A multiphase memory allocator interface with the same interface as N4529.">nn::MemoryResource</a></code>. Otherwise, the specified instance is set.</p>
<p>This function is thread-safe. <code><a class="el" href="namespacenn_1_1util_1_1pmr.html#ab16b6b553352d17f0b4f565edb0b601d" title="Gets the default instance of nn::MemoryResource.">GetDefaultResource()</a></code> and <code><a class="el" href="namespacenn_1_1util_1_1pmr.html#af0f84f272466de29f5db61100d754b37" title="Sets the default instance of nn::MemoryResource.">SetDefaultResource()</a></code> can be called simultaneously by multiple threads. </p>

</div>
</div>
<a id="a8e2657f17dbf92b6527d3b549e88e2b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2657f17dbf92b6527d3b549e88e2b1">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::pmr::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html">PolymorphicAllocator</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html">PolymorphicAllocator</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the specified instances of <code><a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html" title="Memory allocator class that provides the same functionality as std::pmr::polymorphic_allocator.">PolymorphicAllocator</a></code> are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>An instance of <code><a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html" title="Memory allocator class that provides the same functionality as std::pmr::polymorphic_allocator.">PolymorphicAllocator</a></code> to evaluate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>An instance of <code><a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html" title="Memory allocator class that provides the same functionality as std::pmr::polymorphic_allocator.">PolymorphicAllocator</a></code> to evaluate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the <code><a class="el" href="classnn_1_1_memory_resource.html" title="A multiphase memory allocator interface with the same interface as N4529.">nn::MemoryResource</a></code> instances used by <code><em>lhs</em></code> and <code><em>rhs</em></code> are equal in value.</dd></dl>
<p> <b>Details</b> <br  />
 It is equivalent to the following implementation.</p>
<div class="fragment"><div class="line"><span class="keywordflow">return</span> lhs.resource()-&gt;is_equal(*rhs.resource());</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a66ff5f1484c1a9329663592734e7e779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66ff5f1484c1a9329663592734e7e779">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::pmr::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html">PolymorphicAllocator</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html">PolymorphicAllocator</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the specified instances of <code><a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html" title="Memory allocator class that provides the same functionality as std::pmr::polymorphic_allocator.">PolymorphicAllocator</a></code> are unequal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>An instance of <code><a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html" title="Memory allocator class that provides the same functionality as std::pmr::polymorphic_allocator.">PolymorphicAllocator</a></code> to evaluate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>An instance of <code><a class="el" href="classnn_1_1util_1_1pmr_1_1_polymorphic_allocator.html" title="Memory allocator class that provides the same functionality as std::pmr::polymorphic_allocator.">PolymorphicAllocator</a></code> to evaluate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the <code><a class="el" href="classnn_1_1_memory_resource.html" title="A multiphase memory allocator interface with the same interface as N4529.">nn::MemoryResource</a></code> instances used by <code><em>lhs</em></code> and <code><em>rhs</em></code> are not equal in value.</dd></dl>
<p> <b>Details</b> <br  />
 It is equivalent to the following implementation.</p>
<div class="fragment"><div class="line"><span class="keywordflow">return</span> ! (lhs == rhs);</div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
