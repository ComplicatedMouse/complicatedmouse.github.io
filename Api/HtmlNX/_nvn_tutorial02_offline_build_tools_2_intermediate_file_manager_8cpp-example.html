<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NvnTutorial02OfflineBuildTools/IntermediateFileManager.cpp | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">NvnTutorial02OfflineBuildTools/IntermediateFileManager.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<p>For an explanation of the source code, see <a class="el" href="_page_sample_nvn_tutorial02.html">NVN Tutorial 02: GPU Offline Build Tools</a> and <tt>NvnTutorial02OfflineBuildTools/IntermediateFileManager.cpp</tt>.</p>
<div class="fragment"><div class="line"><span class="comment">/*--------------------------------------------------------------------------------*</span></div>
<div class="line"><span class="comment">  Copyright (C)Nintendo All rights reserved.</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  These coded instructions, statements, and computer programs contain proprietary</span></div>
<div class="line"><span class="comment">  information of Nintendo and/or its licensed developers and are protected by</span></div>
<div class="line"><span class="comment">  national and international copyright laws. They may not be disclosed to third</span></div>
<div class="line"><span class="comment">  parties or copied or duplicated in any form, in whole or in part, without the</span></div>
<div class="line"><span class="comment">  prior written consent of Nintendo.</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  The content herein is highly confidential and should be handled accordingly.</span></div>
<div class="line"><span class="comment"> *--------------------------------------------------------------------------------*/</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_intermediate_file_manager_8h.html">IntermediateFileManager.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_texpkg___helper_8h.html">Texpkg_Helper.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_output_file_headers_8h.html">OutputFileHeaders.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;set&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">float</span> g_OutputFileVersion = 1.0f;</div>
<div class="line"> </div>
<div class="line">IntermediateFileManager::IntermediateFileManager()</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::~IntermediateFileManager</span></div>
<div class="line"><span class="comment"> * -------------------------------------------------</span></div>
<div class="line"><span class="comment"> * Cleans up GLSLC and texpkg objects and frees any dynamically</span></div>
<div class="line"><span class="comment"> * allocated memory.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">IntermediateFileManager::~IntermediateFileManager()</div>
<div class="line">{</div>
<div class="line">        <span class="comment">/* Finalize the glslc compile objects for each shader program. */</span></div>
<div class="line">    <span class="keywordflow">for</span>(std::unordered_map&lt;std::string, ShaderCompileData&gt;::iterator itr = m_ShaderPrograms.begin(); itr != m_ShaderPrograms.end(); ++itr)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="nvn_tool___glslc_interface_8h.html#a05b2032c99f789df2a34ebf32271c320">glslcFinalize</a>(&amp;(itr-&gt;second.m_CompileObject));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Release the raw texture data. */</span></div>
<div class="line">    <span class="keywordflow">for</span>(std::vector&lt;TextureData&gt;::iterator itr = m_RawTextureData.begin(); itr != m_RawTextureData.end(); ++itr)</div>
<div class="line">    {</div>
<div class="line">        itr-&gt;m_pRawImage-&gt;Release();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Release the converted texture data. */</span></div>
<div class="line">    <span class="keywordflow">for</span>(std::unordered_map&lt;std::string, nvnTool::texpkg::NVNHWTexture&gt;::iterator itr = m_ConvertedTextureData.begin(); itr != m_ConvertedTextureData.end(); ++itr)</div>
<div class="line">    {</div>
<div class="line">        g_HwTextureExporter-&gt;<a name="a0"></a><a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image_hardware_texture_exporter.html#a3c17476b5aa35d3c7ef2b385dcd52871">ReleaseTextureData</a>(&amp;itr-&gt;second);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Frees the loaded model data. */</span></div>
<div class="line">    <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; m_RawModelData.size(); ++i)</div>
<div class="line">    {</div>
<div class="line">        free(m_RawModelData[i].m_IndexData.m_pData);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span>(uint32_t j = 0; j &lt; m_RawModelData[i].m_VertexAttributes.size(); ++j)</div>
<div class="line">        {</div>
<div class="line">            free(m_RawModelData[i].m_VertexAttributes[j].m_pData);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Deletes the loaded wavefront data */</span></div>
<div class="line">    <span class="keywordflow">for</span> (std::unordered_map&lt;std::string, WaveFrontObjConfig&gt;::iterator itr = m_WaveFrontObjs.begin(); itr != m_WaveFrontObjs.end(); ++itr)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; itr-&gt;second.m_Meshes.size(); ++i)</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">delete</span> itr-&gt;second.m_Meshes[i];</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::LoadShaderPrograms</span></div>
<div class="line"><span class="comment"> * -------------------------------------------</span></div>
<div class="line"><span class="comment"> * Loads the shader source needed for each stage of the shader program.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">bool</span> IntermediateFileManager::LoadShaderPrograms(<span class="keyword">const</span> std::string&amp; path)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (std::unordered_map&lt;std::string, ShaderCompileData&gt;::iterator itr = m_ShaderPrograms.begin(); itr != m_ShaderPrograms.end(); ++itr)</div>
<div class="line">    {</div>
<div class="line">        std::string* temp = <span class="keyword">reinterpret_cast&lt;</span>std::string*<span class="keyword">&gt;</span>(&amp;(itr-&gt;second));</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; 6; ++i)</div>
<div class="line">        {</div>
<div class="line">                <span class="comment">/* If the shader stage exists for the program, load the source. */</span></div>
<div class="line">            <span class="keywordflow">if</span> (temp[i].size())</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">if</span> (!LoadShaderSource(temp[i], path))</div>
<div class="line">                {</div>
<div class="line">                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::LoadShaderSource</span></div>
<div class="line"><span class="comment"> * -----------------------------------------</span></div>
<div class="line"><span class="comment"> * Loads the shader source specified by the given file name. If the source for</span></div>
<div class="line"><span class="comment"> * that file name has already been loaded, it just returns.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">bool</span> IntermediateFileManager::LoadShaderSource(<span class="keyword">const</span> std::string&amp; filename, <span class="keyword">const</span> std::string&amp; path)</div>
<div class="line">{</div>
<div class="line">        <span class="comment">/* If the source has been loaded already, return true. */</span></div>
<div class="line">    <span class="keywordflow">if</span> (m_RawShaderSource.find(filename) != m_RawShaderSource.end())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::ifstream shaderFile;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Get the file extension to check if it&#39;s a SPIR-V binary */</span></div>
<div class="line">    <span class="keywordtype">size_t</span> dotPos = filename.find_last_of(<span class="charliteral">&#39;.&#39;</span>, filename.length());</div>
<div class="line">    std::string fileExtension = filename.substr(dotPos + 1, filename.length());</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (fileExtension == <span class="stringliteral">&quot;spv&quot;</span> || fileExtension == <span class="stringliteral">&quot;spirv&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        shaderFile.open(path + filename, std::ios_base::binary);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Return false if the file is not found. */</span></div>
<div class="line">        <span class="keywordflow">if</span> (!shaderFile.is_open())</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        m_RawShaderSource[filename].m_Language = <a class="code" href="nvn_tool___glslc_interface_8h.html#a2d6ec24544353b8978008330e2a1f52ba7de6685da3123976fc56e312e02e92fd">GLSLC_LANGUAGE_SPIRV</a>;</div>
<div class="line"> </div>
<div class="line">        shaderFile.seekg(0, std::ifstream::end);</div>
<div class="line">        <span class="keywordtype">size_t</span> fileSize = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(shaderFile.tellg());</div>
<div class="line">        shaderFile.seekg(0, std::ifstream::beg);</div>
<div class="line"> </div>
<div class="line">        std::string temp;</div>
<div class="line">        temp.resize(fileSize);</div>
<div class="line">        shaderFile.read((<span class="keywordtype">char</span>*)&amp;temp[0], fileSize);</div>
<div class="line"> </div>
<div class="line">        m_RawShaderSource[filename].m_Data = temp;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        shaderFile.open(path + filename);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Return false if the file is not found. */</span></div>
<div class="line">        <span class="keywordflow">if</span> (!shaderFile.is_open())</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        m_RawShaderSource[filename].m_Language = <a class="code" href="nvn_tool___glslc_interface_8h.html#a2d6ec24544353b8978008330e2a1f52ba0cfa6af4f3bada8f5dbc6563d70fce1d">GLSLC_LANGUAGE_GLSL</a>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">while</span> (!shaderFile.eof())</div>
<div class="line">        {</div>
<div class="line">            std::string temp;</div>
<div class="line">            std::getline(shaderFile, temp);</div>
<div class="line">            temp += <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">            m_RawShaderSource[filename].m_Data += temp;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * NextSpecializationIndex</span></div>
<div class="line"><span class="comment"> * -----------------------</span></div>
<div class="line"><span class="comment"> * Gets the indices of the specialization uniforms for the current set.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">bool</span> NextSpecializationIndex(<span class="keyword">const</span> std::vector &lt; std::vector&lt;GLSLCspecializationUniform&gt; &gt;&amp; specializationUniforms, std::vector&lt;uint32_t&gt;&amp; indices)</div>
<div class="line">{</div>
<div class="line">    indices.back() += 1;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (indices.back() &gt;= specializationUniforms[indices.size() - 1].size())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (indices.size() == 1)</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">        indices.back() = 0;</div>
<div class="line">        std::vector&lt;uint32_t&gt; temp = std::vector&lt;uint32_t&gt;(indices.begin(), indices.end() - 1);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (NextSpecializationIndex(specializationUniforms, temp) == <span class="keyword">false</span>)</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; temp.size(); ++i)</div>
<div class="line">        {</div>
<div class="line">            indices[i] = temp[i];</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::CompileShaderPrograms</span></div>
<div class="line"><span class="comment"> * ----------------------------------------------</span></div>
<div class="line"><span class="comment"> * Compile the shader sources for each stage with a default set of</span></div>
<div class="line"><span class="comment"> * shader compile options.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">bool</span> IntermediateFileManager::CompileShaderPrograms(<span class="keyword">const</span> std::string&amp; path)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span>(std::unordered_map&lt;std::string, ShaderCompileData&gt;::iterator itr = m_ShaderPrograms.begin(); itr != m_ShaderPrograms.end(); ++itr)</div>
<div class="line">    {</div>
<div class="line">        std::vector&lt;const char *&gt; shaderSources;</div>
<div class="line">        std::vector&lt;NVNshaderStage&gt; shaderStages;</div>
<div class="line"> </div>
<div class="line">        std::vector&lt;uint32_t&gt; spirvModuleSizes;</div>
<div class="line">        std::vector&lt;const char*&gt; spirvEntryPointNames = { <span class="stringliteral">&quot;main&quot;</span>, <span class="stringliteral">&quot;main&quot;</span> };</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">int</span> shaderLanguage = -1;</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/*</span></div>
<div class="line"><span class="comment">             * Checks each stage to see if there is shader source for it. If</span></div>
<div class="line"><span class="comment">             * there is, then the source and stage value are added to their</span></div>
<div class="line"><span class="comment">             * respective lists.</span></div>
<div class="line"><span class="comment">             */</span></div>
<div class="line">        <span class="keywordflow">if</span>(itr-&gt;second.m_Comp.size())</div>
<div class="line">        {</div>
<div class="line">            shaderSources.push_back(m_RawShaderSource.at(itr-&gt;second.m_Comp).m_Data.c_str());</div>
<div class="line">            shaderStages.push_back(NVNshaderStage::NVN_SHADER_STAGE_COMPUTE);</div>
<div class="line"> </div>
<div class="line">            spirvModuleSizes.push_back(<span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(m_RawShaderSource.at(itr-&gt;second.m_Comp).m_Data.size()));</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (shaderLanguage == -1)</div>
<div class="line">            {</div>
<div class="line">                shaderLanguage = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(m_RawShaderSource.at(itr-&gt;second.m_Comp).m_Language);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (shaderLanguage != <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(m_RawShaderSource.at(itr-&gt;second.m_Comp).m_Language))</div>
<div class="line">            {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;NVN_SHADER_STAGE_COMPUTE has wrong shader language set.\n&quot;</span>;</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span>(itr-&gt;second.m_Frag.size())</div>
<div class="line">        {</div>
<div class="line">            shaderSources.push_back(m_RawShaderSource.at(itr-&gt;second.m_Frag).m_Data.c_str());</div>
<div class="line">            shaderStages.push_back(NVNshaderStage::NVN_SHADER_STAGE_FRAGMENT);</div>
<div class="line"> </div>
<div class="line">            spirvModuleSizes.push_back(<span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(m_RawShaderSource.at(itr-&gt;second.m_Frag).m_Data.size()));</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (shaderLanguage == -1)</div>
<div class="line">            {</div>
<div class="line">                shaderLanguage = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(m_RawShaderSource.at(itr-&gt;second.m_Frag).m_Language);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (shaderLanguage != <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(m_RawShaderSource.at(itr-&gt;second.m_Frag).m_Language))</div>
<div class="line">            {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;NVN_SHADER_STAGE_FRAGMENT has wrong shader language set.\n&quot;</span>;</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span>(itr-&gt;second.m_Geom.size())</div>
<div class="line">        {</div>
<div class="line">            shaderSources.push_back(m_RawShaderSource.at(itr-&gt;second.m_Geom).m_Data.c_str());</div>
<div class="line">            shaderStages.push_back(NVNshaderStage::NVN_SHADER_STAGE_GEOMETRY);</div>
<div class="line"> </div>
<div class="line">            spirvModuleSizes.push_back(<span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(m_RawShaderSource.at(itr-&gt;second.m_Geom).m_Data.size()));</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (shaderLanguage == -1)</div>
<div class="line">            {</div>
<div class="line">                shaderLanguage = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(m_RawShaderSource.at(itr-&gt;second.m_Geom).m_Language);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (shaderLanguage != <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(m_RawShaderSource.at(itr-&gt;second.m_Geom).m_Language))</div>
<div class="line">            {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;NVN_SHADER_STAGE_GEOMETRY has wrong shader language set.\n&quot;</span>;</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span>(itr-&gt;second.m_TessCont.size())</div>
<div class="line">        {</div>
<div class="line">            shaderSources.push_back(m_RawShaderSource.at(itr-&gt;second.m_TessCont).m_Data.c_str());</div>
<div class="line">            shaderStages.push_back(NVNshaderStage::NVN_SHADER_STAGE_TESS_CONTROL);</div>
<div class="line"> </div>
<div class="line">            spirvModuleSizes.push_back(<span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(m_RawShaderSource.at(itr-&gt;second.m_TessCont).m_Data.size()));</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (shaderLanguage == -1)</div>
<div class="line">            {</div>
<div class="line">                shaderLanguage = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(m_RawShaderSource.at(itr-&gt;second.m_TessCont).m_Language);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (shaderLanguage != <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(m_RawShaderSource.at(itr-&gt;second.m_TessCont).m_Language))</div>
<div class="line">            {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;NVN_SHADER_STAGE_TESS_CONTROL has wrong shader language set.\n&quot;</span>;</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span>(itr-&gt;second.m_TessEval.size())</div>
<div class="line">        {</div>
<div class="line">            shaderSources.push_back(m_RawShaderSource.at(itr-&gt;second.m_TessEval).m_Data.c_str());</div>
<div class="line">            shaderStages.push_back(NVNshaderStage::NVN_SHADER_STAGE_TESS_EVALUATION);</div>
<div class="line"> </div>
<div class="line">            spirvModuleSizes.push_back(<span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(m_RawShaderSource.at(itr-&gt;second.m_TessEval).m_Data.size()));</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (shaderLanguage == -1)</div>
<div class="line">            {</div>
<div class="line">                shaderLanguage = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(m_RawShaderSource.at(itr-&gt;second.m_TessEval).m_Language);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (shaderLanguage != <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(m_RawShaderSource.at(itr-&gt;second.m_TessEval).m_Language))</div>
<div class="line">            {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;NVN_SHADER_STAGE_TESS_EVALUATION has wrong shader language set.\n&quot;</span>;</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span>(itr-&gt;second.m_Vert.size())</div>
<div class="line">        {</div>
<div class="line">            shaderSources.push_back(m_RawShaderSource.at(itr-&gt;second.m_Vert).m_Data.c_str());</div>
<div class="line">            shaderStages.push_back(NVNshaderStage::NVN_SHADER_STAGE_VERTEX);</div>
<div class="line"> </div>
<div class="line">            spirvModuleSizes.push_back(<span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(m_RawShaderSource.at(itr-&gt;second.m_Vert).m_Data.size()));</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (shaderLanguage == -1)</div>
<div class="line">            {</div>
<div class="line">                shaderLanguage = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(m_RawShaderSource.at(itr-&gt;second.m_Vert).m_Language);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (shaderLanguage != <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(m_RawShaderSource.at(itr-&gt;second.m_Vert).m_Language))</div>
<div class="line">            {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;NVN_SHADER_STAGE_VERTEX has wrong shader language set.\n&quot;</span>;</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/*</span></div>
<div class="line"><span class="comment">             * GLSLC Compile Object</span></div>
<div class="line"><span class="comment">             * --------------------</span></div>
<div class="line"><span class="comment">             * The GLSLCcompileObject holds the options used in the shader compile,</span></div>
<div class="line"><span class="comment">             * the output from the compile, the shader compile status/log, and shader</span></div>
<div class="line"><span class="comment">             * reflection data. The same compile object can be used for multiple compiles.</span></div>
<div class="line"><span class="comment">             * The lastCompiledResults pointer will be freed on subsequent compiles so</span></div>
<div class="line"><span class="comment">             * it is up to the application to copy the necessary data before using the</span></div>
<div class="line"><span class="comment">             * compile object again. The compile object needs to be initialize before</span></div>
<div class="line"><span class="comment">             * being used and should be finalized once the application is done with it.</span></div>
<div class="line"><span class="comment">             */</span></div>
<div class="line">        <span class="keywordflow">if</span> (!<a class="code" href="nvn_tool___glslc_interface_8h.html#a648dfc0b503357a72dad03652fc31e57">glslcInitialize</a>(&amp;(itr-&gt;second.m_CompileObject)))</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to initialize glslc compile object.\n&quot;</span>;</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/*</span></div>
<div class="line"><span class="comment">             * GLSLC Options</span></div>
<div class="line"><span class="comment">             * -------------</span></div>
<div class="line"><span class="comment">             * The GLSLCoptions portion of the GLSLCcompile object has a</span></div>
<div class="line"><span class="comment">             * GLSLCoptionFlags struct that contains a number of options</span></div>
<div class="line"><span class="comment">             * that can be set for the next shader compile. Options:</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * glslSeparable                - Treat the GLSLC object as separable. Can be</span></div>
<div class="line"><span class="comment">             *                                used to compile singular shader stages.</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * outputAssembly               - Include an assembly dump section in the</span></div>
<div class="line"><span class="comment">             *                                GLSLCoutput.</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * outputGpuBinaries            - Output individual program binary sections</span></div>
<div class="line"><span class="comment">             *                                in the GLSLCoutput. Outputs one binary per</span></div>
<div class="line"><span class="comment">             *                                stage.</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * outputPerfStats              - Output individual perf statistics for each</span></div>
<div class="line"><span class="comment">             *                                compiled binary.</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * outputShaderReflection       - Output shader reflection data. Allows the</span></div>
<div class="line"><span class="comment">             *                                application to grab data about the shader like</span></div>
<div class="line"><span class="comment">             *                                uniform block sizes, names, locations, etc.</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * language                     - Specify the language of the input shaders.</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * outputDebugInfo              - Level of debug information to generate.</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * spillControl                 - Control amount of spilling. Can be set to</span></div>
<div class="line"><span class="comment">             *                                DEFAULT_SPILL or NO_SPILL.</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * outputThinGpuBinaries        - Controls whether the resulting output contains a</span></div>
<div class="line"><span class="comment">             *                                GPU program that is a thin binary (only contains</span></div>
<div class="line"><span class="comment">             *                                program code for NX platforms).</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * tessellationAndPassthroughGS - Compiles tessellation evaluation and passthrough</span></div>
<div class="line"><span class="comment">             *                                geometry shaders (NV_geometry_shader_passthrough)</span></div>
<div class="line"><span class="comment">             *                                to work together as a pair.</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * These additional options are available in the GLSLCoptions struct proper:</span></div>
<div class="line"><span class="comment">             * includeInfo                  - Used to set include paths for shader headers.</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * xfbVaryingInfo               - Used to specify transform feedback information.</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * forceIncludeStdHeader        - Include standard header file. If this is NULL,</span></div>
<div class="line"><span class="comment">             *                                no standard header will be included.</span></div>
<div class="line"><span class="comment">             */</span></div>
<div class="line">        <a name="_a1"></a><a class="code" href="struct_g_l_s_l_coptions.html">GLSLCoptions</a> * options = &amp;(itr-&gt;second.m_CompileObject.options);</div>
<div class="line"> </div>
<div class="line">        options-&gt;<a name="a2"></a><a class="code" href="struct_g_l_s_l_coptions.html#ab5a776f09115d6e36fd37988abf15530">includeInfo</a>.<a name="a3"></a><a class="code" href="struct_g_l_s_l_cinclude_info.html#a8e083ff029a90d02e6b48df28eab6fd3">numPaths</a> = 1;</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* includePath = path.c_str();</div>
<div class="line">        options-&gt;<a class="code" href="struct_g_l_s_l_coptions.html#ab5a776f09115d6e36fd37988abf15530">includeInfo</a>.paths = &amp;(includePath);</div>
<div class="line"> </div>
<div class="line">        options-&gt;<a name="a4"></a><a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a name="a5"></a><a class="code" href="struct_g_l_s_l_coption_flags.html#ac0396d28c3ec928aaa280cb90e71f485">outputAssembly</a> = <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// NOTE: This must be set to true for now.</span></div>
<div class="line">        options-&gt;<a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a name="a6"></a><a class="code" href="struct_g_l_s_l_coption_flags.html#aec0779a250ad31f6deafe470820ffbb8">outputGpuBinaries</a> = <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">        options-&gt;<a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a name="a7"></a><a class="code" href="struct_g_l_s_l_coption_flags.html#af673dc6b82db05442d203619be5a022d">glslSeparable</a> = shaderStages.size() &lt; 2;</div>
<div class="line">        options-&gt;<a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a name="a8"></a><a class="code" href="struct_g_l_s_l_coption_flags.html#ad57cedc549a410a87a8b5e667afd31b9">outputPerfStats</a> = <span class="keyword">true</span>;</div>
<div class="line">        options-&gt;<a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a name="a9"></a><a class="code" href="struct_g_l_s_l_coption_flags.html#a723afb9e18cdf4c92bfe315c94e37c96">outputShaderReflection</a> = <span class="keyword">true</span>;</div>
<div class="line">        options-&gt;<a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a name="a10"></a><a class="code" href="struct_g_l_s_l_coption_flags.html#af2b81192a389ab5093f074ced7ceea29">outputDebugInfo</a> = <a class="code" href="nvn_tool___glslc_interface_8h.html#a238b82c174a58d9f9e2be6aa3e8a5bfea81704ec256f338d05d20e0d618decdef">GLSLC_DEBUG_LEVEL_G0</a>;</div>
<div class="line">        options-&gt;<a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a name="a11"></a><a class="code" href="struct_g_l_s_l_coption_flags.html#a5a5caa709a472ef0abfc98e609557e88">optLevel</a> = <a class="code" href="nvn_tool___glslc_interface_8h.html#ad03b8a64a7554065b0e7d9041b07bf17aaaf5953a0242150f9f7dfd36f14db547">GLSLC_OPTLEVEL_DEFAULT</a>;</div>
<div class="line">        options-&gt;<a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a name="a12"></a><a class="code" href="struct_g_l_s_l_coption_flags.html#ac8db49e611084ad2bf89db26904fe4d4">language</a> = <span class="keyword">static_cast&lt;</span><a class="code" href="nvn_tool___glslc_interface_8h.html#a2d6ec24544353b8978008330e2a1f52b">GLSLClanguageTypeEnum</a><span class="keyword">&gt;</span>(shaderLanguage);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span>( <span class="keyword">static_cast&lt;</span><a class="code" href="nvn_tool___glslc_interface_8h.html#a2d6ec24544353b8978008330e2a1f52b">GLSLClanguageTypeEnum</a><span class="keyword">&gt;</span>(shaderLanguage) == GLSLClanguageTypeEnum::GLSLC_LANGUAGE_SPIRV )</div>
<div class="line">        {</div>
<div class="line">            options-&gt;<a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a class="code" href="struct_g_l_s_l_coption_flags.html#af2b81192a389ab5093f074ced7ceea29">outputDebugInfo</a> = <a class="code" href="nvn_tool___glslc_interface_8h.html#a238b82c174a58d9f9e2be6aa3e8a5bfea6aa278f2aac6b0ff1b449861c069423b">GLSLC_DEBUG_LEVEL_NONE</a>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/*</span></div>
<div class="line"><span class="comment">             * GLSLC Input</span></div>
<div class="line"><span class="comment">             * -------------</span></div>
<div class="line"><span class="comment">             * This structure defines the input data for the compilation.</span></div>
<div class="line"><span class="comment">             * The input is a list of pointers to shader source with a</span></div>
<div class="line"><span class="comment">             * corresponding list of NVNshaderStage values.</span></div>
<div class="line"><span class="comment">             */</span></div>
<div class="line">        itr-&gt;second.m_CompileObject.input.sources = &amp;shaderSources[0];</div>
<div class="line">        itr-&gt;second.m_CompileObject.input.stages = &amp;shaderStages[0];</div>
<div class="line">        itr-&gt;second.m_CompileObject.input.count = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(shaderSources.size());</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* SPIR-V specific options */</span></div>
<div class="line">        itr-&gt;second.m_CompileObject.input.spirvEntryPointNames = &amp;spirvEntryPointNames[0];</div>
<div class="line">        itr-&gt;second.m_CompileObject.input.spirvModuleSizes = &amp;spirvModuleSizes[0];</div>
<div class="line">        itr-&gt;second.m_CompileObject.input.spirvSpecInfo = NULL;</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* If the shader has specialized uniforms */</span></div>
<div class="line">        <span class="keywordflow">if</span> (itr-&gt;second.m_SpecializationParam.size() != 0)</div>
<div class="line">        {</div>
<div class="line">                <span class="comment">/*</span></div>
<div class="line"><span class="comment">                 * Compiles the GLSL into an intermediate representation format</span></div>
<div class="line"><span class="comment">                 * to be used with the full specialization compile later</span></div>
<div class="line"><span class="comment">                 */</span></div>
<div class="line">            <span class="keywordflow">if</span> (!<a class="code" href="nvn_tool___glslc_interface_8h.html#a8a7629609d27a49283b8cb9587dcca48">glslcCompilePreSpecialized</a>(&amp;itr-&gt;second.m_CompileObject))</div>
<div class="line">            {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Shader specialization precompilation failed. Info log:\n&quot;</span> &lt;&lt; itr-&gt;second.m_CompileObject.lastCompiledResults-&gt;compilationStatus-&gt;infoLog &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            std::vector &lt; std::vector&lt;GLSLCspecializationUniform&gt; &gt; specializationUniforms;</div>
<div class="line"> </div>
<div class="line">            std::vector&lt;uint32_t&gt; indices;</div>
<div class="line"> </div>
<div class="line">                <span class="comment">/*</span></div>
<div class="line"><span class="comment">                 * For each specialized uniform, create a GLSLCspecializationUniform</span></div>
<div class="line"><span class="comment">                 * for each each value</span></div>
<div class="line"><span class="comment">                 */</span></div>
<div class="line">            <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; itr-&gt;second.m_SpecializationParam.size(); ++i)</div>
<div class="line">            {</div>
<div class="line">                SpecializationParam&amp; param = itr-&gt;second.m_SpecializationParam[i];</div>
<div class="line">                specializationUniforms.push_back(std::vector&lt;GLSLCspecializationUniform&gt;());</div>
<div class="line"> </div>
<div class="line">                <span class="keywordflow">for</span> (uint32_t j = 0; j &lt; param.m_NumElements; ++j)</div>
<div class="line">                {</div>
<div class="line">                    specializationUniforms[i].push_back(<a name="_a13"></a><a class="code" href="struct_g_l_s_l_cspecialization_uniform.html">GLSLCspecializationUniform</a>());</div>
<div class="line"> </div>
<div class="line">                    <a class="code" href="struct_g_l_s_l_cspecialization_uniform.html">GLSLCspecializationUniform</a>&amp; specializationUniform = specializationUniforms[i].back();</div>
<div class="line"> </div>
<div class="line">                    specializationUniform.uniformName = param.m_Name.c_str();</div>
<div class="line">                    specializationUniform.values = (<span class="keywordtype">char</span>*)param.m_pData + param.m_ElementSize * j;</div>
<div class="line">                    specializationUniform.<a name="a14"></a><a class="code" href="struct_g_l_s_l_cspecialization_uniform.html#a1ef3404ed2eb660b125cf84201ec0973">numElements</a> = 1;</div>
<div class="line">                    specializationUniform.<a name="a15"></a><a class="code" href="struct_g_l_s_l_cspecialization_uniform.html#a08e7a735c1dc18c6ba868ffaac434386">elementSize</a> = param.m_ElementSize;</div>
<div class="line">                }</div>
<div class="line"> </div>
<div class="line">                indices.push_back(0);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            std::vector&lt;GLSLCspecializationSet&gt; specializationSets;</div>
<div class="line">            std::vector &lt; std::vector&lt;GLSLCspecializationUniform&gt; &gt; uniformSets;</div>
<div class="line">            <span class="keywordtype">bool</span> loop = <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">                <span class="comment">/*</span></div>
<div class="line"><span class="comment">                 * For each permutation of specialized uniform</span></div>
<div class="line"><span class="comment">                 * values, create a GLSLCspecialization set.</span></div>
<div class="line"><span class="comment">                 */</span></div>
<div class="line">            <span class="keywordflow">while</span> (loop)</div>
<div class="line">            {</div>
<div class="line">                uniformSets.push_back(std::vector&lt;GLSLCspecializationUniform&gt;());</div>
<div class="line">                <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; indices.size(); ++i)</div>
<div class="line">                {</div>
<div class="line">                    uniformSets.back().push_back(specializationUniforms[i][indices[i]]);</div>
<div class="line">                }</div>
<div class="line"> </div>
<div class="line">                specializationSets.push_back(<a name="_a16"></a><a class="code" href="struct_g_l_s_l_cspecialization_set.html">GLSLCspecializationSet</a>());</div>
<div class="line">                specializationSets.back().numUniforms = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(uniformSets.back().size());</div>
<div class="line">                specializationSets.back().uniforms = &amp;(uniformSets.back()[0]);</div>
<div class="line"> </div>
<div class="line">                loop = NextSpecializationIndex(specializationUniforms, indices);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">                <span class="comment">/*</span></div>
<div class="line"><span class="comment">                 * Group all of the specialization sets together</span></div>
<div class="line"><span class="comment">                 * in a GLSLCspecializationBatch and pass that to</span></div>
<div class="line"><span class="comment">                 * the full specialized compile.</span></div>
<div class="line"><span class="comment">                 */</span></div>
<div class="line">            <a name="_a17"></a><a class="code" href="struct_g_l_s_l_cspecialization_batch.html">GLSLCspecializationBatch</a> specializationBatch;</div>
<div class="line">            specializationBatch.<a name="a18"></a><a class="code" href="struct_g_l_s_l_cspecialization_batch.html#a0be46d42422ea32ebcc5e31ca3016484">numEntries</a> = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(specializationSets.size());</div>
<div class="line">            specializationBatch.entries = &amp;specializationSets[0];</div>
<div class="line"> </div>
<div class="line">            itr-&gt;second.m_ppGlslcOutputs = <a class="code" href="nvn_tool___glslc_interface_8h.html#a64bdf010fc635ccc01dc9f1625557da1">glslcCompileSpecialized</a>(&amp;itr-&gt;second.m_CompileObject, &amp;specializationBatch);</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (itr-&gt;second.m_ppGlslcOutputs == NULL || itr-&gt;second.m_CompileObject.lastCompiledResults-&gt;compilationStatus-&gt;success != 1)</div>
<div class="line">            {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Specialization compilation failed. Info log:\n&quot;</span> &lt;&lt; itr-&gt;second.m_CompileObject.lastCompiledResults-&gt;compilationStatus-&gt;infoLog &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            itr-&gt;second.m_NumOutputs = specializationBatch.<a class="code" href="struct_g_l_s_l_cspecialization_batch.html#a0be46d42422ea32ebcc5e31ca3016484">numEntries</a>;</div>
<div class="line">        }</div>
<div class="line">            <span class="comment">/* Compiles the shader program with the given input and options. */</span></div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!<a class="code" href="nvn_tool___glslc_interface_8h.html#ad0fd458cbbcd554a1dc81ac61fdcf7e3">glslcCompile</a>(&amp;(itr-&gt;second.m_CompileObject)))</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Compilation failed. Info log:\n&quot;</span> &lt;&lt; itr-&gt;second.m_CompileObject.lastCompiledResults-&gt;compilationStatus-&gt;infoLog &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}<span class="comment">//NOLINT(impl/function_size)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Align</span></div>
<div class="line"><span class="comment"> * -----</span></div>
<div class="line"><span class="comment"> * Aligns a given value up to the given alignment</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">size_t</span> IntermediateFileManager::Align(<span class="keywordtype">size_t</span> size, <span class="keywordtype">size_t</span> alignment, <span class="keywordtype">size_t</span>&amp; bytesAlignedUp)</div>
<div class="line">{</div>
<div class="line">    bytesAlignedUp = (alignment - (size % alignment)) % alignment;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> bytesAlignedUp + size;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PadFileBuffer</span></div>
<div class="line"><span class="comment"> * -------------</span></div>
<div class="line"><span class="comment"> * Inserts padding bytes into the file to maintain alignment of following</span></div>
<div class="line"><span class="comment"> * entries.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">size_t</span> IntermediateFileManager::PadFileBuffer(FILE* file, <span class="keywordtype">size_t</span> padSize)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (padSize == 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> std::vector&lt;char&gt; padBuffer;</div>
<div class="line">    <span class="keywordflow">if</span> (padSize &gt; padBuffer.size())</div>
<div class="line">    {</div>
<div class="line">        padBuffer.resize(padSize, 0);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> fwrite(&amp;padBuffer[0], <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>), padSize, file);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::WriteGlslcDebugOutput</span></div>
<div class="line"><span class="comment"> * ----------------------------------------------</span></div>
<div class="line"><span class="comment"> * Sets up the shader program headers from the glslc reflection info.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> IntermediateFileManager::WriteGlslcDebugOutput(<span class="keyword">const</span> std::string&amp; outPath, <span class="keyword">const</span> std::string&amp; fileName, <span class="keyword">const</span> <a name="_a19"></a><a class="code" href="struct_g_l_s_l_coutput.html">GLSLCoutput</a>* compileOutput)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">     * Write GLSLC output to file for NVN Graphics Debugger to use.</span></div>
<div class="line"><span class="comment">     * To use these files, capture a frame in NVNGD, click on a</span></div>
<div class="line"><span class="comment">     * draw event in the Events View window, go to one of the shader</span></div>
<div class="line"><span class="comment">     * tabs in the API Inspector View, and click on the link to</span></div>
<div class="line"><span class="comment">     * view shader source.  Set the folder below as the directory</span></div>
<div class="line"><span class="comment">     * to look for the debug files in.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    FILE* glslcOutputFileHandle = NULL;</div>
<div class="line"> </div>
<div class="line">    std::string glslcOutputFileName(outPath + <span class="stringliteral">&quot;GlslcDbg\\&quot;</span> + fileName + <span class="stringliteral">&quot;.glslc&quot;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (fopen_s(&amp;glslcOutputFileHandle, glslcOutputFileName.c_str(), <span class="stringliteral">&quot;wb&quot;</span>) != 0)</div>
<div class="line">    {</div>
<div class="line">        assert(<span class="keyword">false</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (!glslcOutputFileHandle)</div>
<div class="line">    {</div>
<div class="line">        assert(<span class="keyword">false</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    fwrite(<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(compileOutput), compileOutput-&gt;<a name="a20"></a><a class="code" href="struct_g_l_s_l_coutput.html#ac6e8159c6357796e5c51b6eb91f279b7">size</a>, 1, glslcOutputFileHandle);</div>
<div class="line">    fclose(glslcOutputFileHandle);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::SetupShaderProgramHeader</span></div>
<div class="line"><span class="comment"> * -------------------------------------------------</span></div>
<div class="line"><span class="comment"> * Sets up the shader program headers from the glslc reflection info.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> IntermediateFileManager::SetupShaderProgramHeader(<span class="keyword">const</span> std::string&amp; name,</div>
<div class="line">                                                       ShaderProgramHeader&amp; programHeader,</div>
<div class="line">                                                       std::vector&lt;ShaderStageHeader&gt;&amp; stageHeaders,</div>
<div class="line">                                                       <span class="keyword">const</span> <a class="code" href="struct_g_l_s_l_coutput.html">GLSLCoutput</a>* compileOutput)</div>
<div class="line">{</div>
<div class="line">    programHeader.m_pProgramName = name.c_str();</div>
<div class="line">    programHeader.m_ProgramNameLength = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(name.size());</div>
<div class="line">    programHeader.m_MagicPadding = 0;</div>
<div class="line">    programHeader.m_ShaderScratchMemorySize = 0;</div>
<div class="line">    programHeader.m_NumShaderStages = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; compileOutput-&gt;<a name="a21"></a><a class="code" href="struct_g_l_s_l_coutput.html#a6cbb6ec5e8a4ff04512fd1c442aa3d92">numSections</a>; ++i)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="nvn_tool___glslc_interface_8h.html#aab53ab9845cc7be41102195446759a59">GLSLCsectionTypeEnum</a> type = compileOutput-&gt;<a name="a22"></a><a class="code" href="struct_g_l_s_l_coutput.html#a69ff5a7c06d39592caacec94be810995">headers</a>[i].<a name="a23"></a>genericHeader.<a name="a24"></a>common.<a name="a25"></a><a class="code" href="struct_g_l_s_l_csection_header_common.html#a6a8aed7a5a7e82acff908d084fd85e4a">type</a>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (type == GLSLC_SECTION_TYPE_GPU_CODE)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">/*</span></div>
<div class="line"><span class="comment">             * GLSLCgpuCodeHeader</span></div>
<div class="line"><span class="comment">             * ------------------</span></div>
<div class="line"><span class="comment">             * This structure is a section header that holds information used</span></div>
<div class="line"><span class="comment">             * to access compiled shader code for an individual shader stage.</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * stage                      - Shader stage the gpu code correspons to.</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * controlOffset              - Offset in bytes to the control section</span></div>
<div class="line"><span class="comment">             *                              from the start of the data section of the</span></div>
<div class="line"><span class="comment">             *                              header.</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * controlSize                - Size of the control section in bytes.</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * dataOffset                 - Offset to the shader data section in bytes</span></div>
<div class="line"><span class="comment">             *                              fom the start of the header&#39;s data section.</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * dataSize                   - Size of the shader data section.</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * scratchMemBytesPerWarp     - Amount of local memory required for the stage</span></div>
<div class="line"><span class="comment">             *                              in bytes per warp.</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * scratchMemBytesRecommended - Recommended amount of local memory on the target.</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * asmDumpSectionIdx          - Index of the assembly dump section for this shader</span></div>
<div class="line"><span class="comment">             *                              stage (if option was turned on).</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * perfStatsSectionNdx        - Index of the performance stats section for this</span></div>
<div class="line"><span class="comment">             *                              shader stage (if option was turned on).</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * subroutineLinkageMapOffset - Offset to subroutine linkage map offset in data section</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * subroutineLinkageMapSize   - Size of subroutine linkage map size</span></div>
<div class="line"><span class="comment">             */</span></div>
<div class="line">            <span class="keyword">const</span> <a name="_a26"></a><a class="code" href="struct_g_l_s_l_cgpu_code_header.html">GLSLCgpuCodeHeader</a> * gpuHeader = &amp;(compileOutput-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#a69ff5a7c06d39592caacec94be810995">headers</a>[i].<a name="a27"></a>gpuCodeHeader);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Save the max scratch memory size needed for a shader stage of this program. */</span></div>
<div class="line">            programHeader.m_ShaderScratchMemorySize = std::max(gpuHeader-&gt;<a name="a28"></a><a class="code" href="struct_g_l_s_l_cgpu_code_header.html#ac8b1eef84fa9f0debec1874f8b570e62">scratchMemBytesRecommended</a>, programHeader.m_ShaderScratchMemorySize);</div>
<div class="line">            <span class="comment">/*</span></div>
<div class="line"><span class="comment">             * Grab a pointer to the data section of the header. The control offset and</span></div>
<div class="line"><span class="comment">             * data offset from the gpu code header are offsets from this pointer.</span></div>
<div class="line"><span class="comment">             */</span></div>
<div class="line">            <span class="keywordtype">void</span> * data = ((<span class="keywordtype">char</span>*)compileOutput) + gpuHeader-&gt;<a name="a29"></a>common.<a name="a30"></a><a class="code" href="struct_g_l_s_l_csection_header_common.html#abb6e96b70bad30c94477317328d384d5">dataOffset</a>;</div>
<div class="line"> </div>
<div class="line">            ShaderStageHeader stageHeader;</div>
<div class="line">            stageHeader.m_ShaderStage = gpuHeader-&gt;<a name="a31"></a><a class="code" href="struct_g_l_s_l_cgpu_code_header.html#ab1e6be676a326a7281e18ad3a4607ced">stage</a>;</div>
<div class="line">            stageHeader.m_ShaderControlSize = gpuHeader-&gt;<a name="a32"></a><a class="code" href="struct_g_l_s_l_cgpu_code_header.html#aff5295c90f2dc5eb969fb14660f31712">controlSize</a>;</div>
<div class="line">            stageHeader.m_ShaderDataSize = gpuHeader-&gt;<a name="a33"></a><a class="code" href="struct_g_l_s_l_cgpu_code_header.html#a2617848640a161d41ed59f1a7c0ccb35">dataSize</a>;</div>
<div class="line">            stageHeader.m_ShaderControlOffset = 0; <span class="comment">// Retrieve this offset later</span></div>
<div class="line">            stageHeader.m_pShaderData = ((<span class="keywordtype">char</span>*)data + gpuHeader-&gt;<a name="a34"></a><a class="code" href="struct_g_l_s_l_cgpu_code_header.html#aafdececf784595d922fe1b95b06db976">dataOffset</a>);</div>
<div class="line">            stageHeader.m_pShaderControl = ((<span class="keywordtype">char</span>*)data + gpuHeader-&gt;<a name="a35"></a><a class="code" href="struct_g_l_s_l_cgpu_code_header.html#a3b606fedf8582a1a47162d210e8a1448">controlOffset</a>);</div>
<div class="line"> </div>
<div class="line">            ++programHeader.m_NumShaderStages;</div>
<div class="line"> </div>
<div class="line">            stageHeaders.push_back(stageHeader);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    programHeader.m_pShaderStageOffsets = (uint64_t*)malloc(<span class="keyword">sizeof</span>(uint64_t) * programHeader.m_NumShaderStages);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::SetupShaderProgramOffsets</span></div>
<div class="line"><span class="comment"> * --------------------------------------------------</span></div>
<div class="line"><span class="comment"> * Sets up the offsets for the shader program headers.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> IntermediateFileManager::SetupShaderProgramOffsets(std::pair&lt;ShaderProgramHeader, std::vector&lt;ShaderStageHeader&gt; &gt;&amp; shaderProgramHeader,</div>
<div class="line">                                                        std::vector&lt;size_t&gt;&amp; padding,</div>
<div class="line">                                                        <span class="keywordtype">size_t</span>&amp; currentOffset)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">size_t</span> currentPadding = 0;</div>
<div class="line"> </div>
<div class="line">    currentOffset += <span class="keyword">sizeof</span>(ShaderProgramHeader);</div>
<div class="line">    currentOffset -= <span class="keyword">sizeof</span>(shaderProgramHeader.first.m_pShaderStageOffsets);</div>
<div class="line">    currentOffset -= <span class="keyword">sizeof</span>(shaderProgramHeader.first.m_pProgramName);</div>
<div class="line">    currentOffset += <span class="keyword">sizeof</span>(char) * shaderProgramHeader.first.m_ProgramNameLength;</div>
<div class="line">    currentOffset += <span class="keyword">sizeof</span>(uint64_t) * shaderProgramHeader.first.m_NumShaderStages;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t j = 0; j &lt; shaderProgramHeader.first.m_NumShaderStages; ++j)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Align shader stage header struct to account for</span></div>
<div class="line"><span class="comment">         * variable length of shader and control data</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">        currentOffset = Align(currentOffset, 8, currentPadding);</div>
<div class="line">        padding.push_back(currentPadding);</div>
<div class="line">        shaderProgramHeader.first.m_pShaderStageOffsets[j] = currentOffset;</div>
<div class="line"> </div>
<div class="line">        currentOffset += <span class="keyword">sizeof</span>(ShaderStageHeader);</div>
<div class="line">        currentOffset -= <span class="keyword">sizeof</span>(shaderProgramHeader.second[j].m_pShaderData);</div>
<div class="line">        currentOffset -= <span class="keyword">sizeof</span>(shaderProgramHeader.second[j].m_pShaderControl);</div>
<div class="line">        currentOffset += shaderProgramHeader.second[j].m_ShaderDataSize;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Offset of control data is set now to account for the variable</span></div>
<div class="line"><span class="comment">         * size of the shader data</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">        currentOffset = Align(currentOffset, 8, currentPadding);</div>
<div class="line">        padding.push_back(currentPadding);</div>
<div class="line">        shaderProgramHeader.second[j].m_ShaderControlOffset = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(currentOffset);</div>
<div class="line"> </div>
<div class="line">        currentOffset += shaderProgramHeader.second[j].m_ShaderControlSize;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::WriteShaderProgramHeaders</span></div>
<div class="line"><span class="comment"> * --------------------------------------------------</span></div>
<div class="line"><span class="comment"> * Writes the shader program headers to the given output file.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> IntermediateFileManager::WriteShaderProgramHeaders(FILE* outputFile,</div>
<div class="line">                                                        std::pair&lt;ShaderProgramHeader, std::vector&lt;ShaderStageHeader&gt; &gt;&amp; shaderProgramHeader,</div>
<div class="line">                                                        std::vector&lt;size_t&gt;&amp; padding,</div>
<div class="line">                                                        uint64_t&amp; writtenBytes,</div>
<div class="line">                                                        uint32_t&amp; currentPaddingIndex)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Insert padding</span></div>
<div class="line">    writtenBytes += PadFileBuffer(outputFile, padding[currentPaddingIndex++]);</div>
<div class="line"> </div>
<div class="line">    fwrite(&amp;shaderProgramHeader.first.m_NumShaderStages, <span class="keyword">sizeof</span>(shaderProgramHeader.first.m_NumShaderStages), 1, outputFile);</div>
<div class="line">    writtenBytes += <span class="keyword">sizeof</span>(shaderProgramHeader.first.m_NumShaderStages);</div>
<div class="line"> </div>
<div class="line">    fwrite(&amp;shaderProgramHeader.first.m_ProgramNameLength, <span class="keyword">sizeof</span>(shaderProgramHeader.first.m_ProgramNameLength), 1, outputFile);</div>
<div class="line">    writtenBytes += <span class="keyword">sizeof</span>(shaderProgramHeader.first.m_ProgramNameLength);</div>
<div class="line"> </div>
<div class="line">    fwrite(&amp;shaderProgramHeader.first.m_ShaderScratchMemorySize, <span class="keyword">sizeof</span>(shaderProgramHeader.first.m_ShaderScratchMemorySize), 1, outputFile);</div>
<div class="line">    writtenBytes += <span class="keyword">sizeof</span>(shaderProgramHeader.first.m_ShaderScratchMemorySize);</div>
<div class="line"> </div>
<div class="line">    fwrite(&amp;shaderProgramHeader.first.m_MagicPadding, <span class="keyword">sizeof</span>(shaderProgramHeader.first.m_MagicPadding), 1, outputFile);</div>
<div class="line">    writtenBytes += <span class="keyword">sizeof</span>(shaderProgramHeader.first.m_MagicPadding);</div>
<div class="line"> </div>
<div class="line">    fwrite(shaderProgramHeader.first.m_pShaderStageOffsets, <span class="keyword">sizeof</span>(uint64_t), shaderProgramHeader.first.m_NumShaderStages, outputFile);</div>
<div class="line">    writtenBytes += <span class="keyword">sizeof</span>(uint64_t) * shaderProgramHeader.first.m_NumShaderStages;</div>
<div class="line"> </div>
<div class="line">    fwrite(shaderProgramHeader.first.m_pProgramName, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>), shaderProgramHeader.first.m_ProgramNameLength, outputFile);</div>
<div class="line">    writtenBytes += <span class="keyword">sizeof</span>(char) * shaderProgramHeader.first.m_ProgramNameLength;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Shader Stage Headers/Data</span></div>
<div class="line">    for (uint32_t j = 0; j &lt; shaderProgramHeader.first.m_NumShaderStages; ++j)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Insert padding</span></div>
<div class="line">        writtenBytes += PadFileBuffer(outputFile, padding[currentPaddingIndex++]);</div>
<div class="line"> </div>
<div class="line">        fwrite(&amp;shaderProgramHeader.second[j].m_ShaderStage, <span class="keyword">sizeof</span>(shaderProgramHeader.second[j].m_ShaderStage), 1, outputFile);</div>
<div class="line">        writtenBytes += <span class="keyword">sizeof</span>(shaderProgramHeader.second[j].m_ShaderStage);</div>
<div class="line"> </div>
<div class="line">        fwrite(&amp;shaderProgramHeader.second[j].m_ShaderDataSize, <span class="keyword">sizeof</span>(shaderProgramHeader.second[j].m_ShaderDataSize), 1, outputFile);</div>
<div class="line">        writtenBytes += <span class="keyword">sizeof</span>(shaderProgramHeader.second[j].m_ShaderDataSize);</div>
<div class="line"> </div>
<div class="line">        fwrite(&amp;shaderProgramHeader.second[j].m_ShaderControlSize, <span class="keyword">sizeof</span>(shaderProgramHeader.second[j].m_ShaderControlSize), 1, outputFile);</div>
<div class="line">        writtenBytes += <span class="keyword">sizeof</span>(shaderProgramHeader.second[j].m_ShaderControlSize);</div>
<div class="line"> </div>
<div class="line">        fwrite(&amp;shaderProgramHeader.second[j].m_ShaderControlOffset, <span class="keyword">sizeof</span>(shaderProgramHeader.second[j].m_ShaderControlOffset), 1, outputFile);</div>
<div class="line">        writtenBytes += <span class="keyword">sizeof</span>(shaderProgramHeader.second[j].m_ShaderControlOffset);</div>
<div class="line"> </div>
<div class="line">        fwrite(shaderProgramHeader.second[j].m_pShaderData, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>), shaderProgramHeader.second[j].m_ShaderDataSize, outputFile);</div>
<div class="line">        writtenBytes += <span class="keyword">sizeof</span>(char) * shaderProgramHeader.second[j].m_ShaderDataSize;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Insert padding</span></div>
<div class="line">        writtenBytes += PadFileBuffer(outputFile, padding[currentPaddingIndex++]);</div>
<div class="line"> </div>
<div class="line">        fwrite(shaderProgramHeader.second[j].m_pShaderControl, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>), shaderProgramHeader.second[j].m_ShaderControlSize, outputFile);</div>
<div class="line">        writtenBytes += <span class="keyword">sizeof</span>(char) * shaderProgramHeader.second[j].m_ShaderControlSize;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::WriteOutputFile</span></div>
<div class="line"><span class="comment"> * ----------------------------------------</span></div>
<div class="line"><span class="comment"> * Takes the accumulated shader compile data, converted texture</span></div>
<div class="line"><span class="comment"> * data, and model data and writes it all out into one large</span></div>
<div class="line"><span class="comment"> * binary file. The general structure of the file is laid out</span></div>
<div class="line"><span class="comment"> * by the structs defined in OutputFileHeaders.h.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">bool</span> IntermediateFileManager::WriteOutputFile(<span class="keyword">const</span> std::string&amp; outPath, <span class="keyword">const</span> std::string&amp; fileName, <span class="keywordtype">bool</span> outputDebugGlslcFiles)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (m_ShaderPrograms.size() || m_ConvertedTextureData.size() || m_RawModelData.size())</div>
<div class="line">    {</div>
<div class="line">        std::string filePath = outPath + fileName;</div>
<div class="line">        FILE* outputFile;</div>
<div class="line">        fopen_s(&amp;outputFile, filePath.c_str(), <span class="stringliteral">&quot;wb&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (!outputFile)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        OutputFileHeader outputFileHeader;</div>
<div class="line"> </div>
<div class="line">        ShaderBlockHeader shaderBlockHeader;</div>
<div class="line">        memset(&amp;shaderBlockHeader, 0, <span class="keyword">sizeof</span>(ShaderBlockHeader));</div>
<div class="line">        std::vector&lt;std::pair&lt;ShaderProgramHeader, std::vector&lt;ShaderStageHeader&gt; &gt; &gt; shaderProgramHeaders;</div>
<div class="line">        std::vector&lt;std::pair&lt;SpecializedShaderProgramHeader, std::vector&lt;std::pair&lt;ShaderProgramHeader, std::vector&lt;ShaderStageHeader&gt; &gt; &gt; &gt; &gt; specializedShaderProgramHeaders;</div>
<div class="line"> </div>
<div class="line">        TextureBlockHeader textureBlockHeader;</div>
<div class="line">        memset(&amp;textureBlockHeader, 0, <span class="keyword">sizeof</span>(TextureBlockHeader));</div>
<div class="line">        std::vector&lt;TextureDataHeader&gt; textureDataHeaders;</div>
<div class="line"> </div>
<div class="line">        ModelBlockHeader modelBlockHeader;</div>
<div class="line">        memset(&amp;modelBlockHeader, 0, <span class="keyword">sizeof</span>(ModelBlockHeader));</div>
<div class="line"> </div>
<div class="line">        std::vector&lt;std::pair&lt;ModelHeader, std::pair&lt;std::vector&lt;VertexAttributeHeader&gt;, IndexBufferHeader&gt; &gt; &gt; modelHeaders;</div>
<div class="line"> </div>
<div class="line">        outputFileHeader.m_MagicPadding = 0;</div>
<div class="line">        outputFileHeader.m_Version = g_OutputFileVersion;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Keep track of the current offset. */</span></div>
<div class="line">        <span class="keywordtype">size_t</span> currentOffset = <span class="keyword">sizeof</span>(OutputFileHeader);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Keep track of instances of padding */</span></div>
<div class="line">        std::vector&lt;size_t&gt; padding;</div>
<div class="line">        <span class="keywordtype">size_t</span> currentPadding = 0;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Check for shader programs*/</span></div>
<div class="line">        <span class="keywordflow">if</span> (!m_ShaderPrograms.size())</div>
<div class="line">        {</div>
<div class="line">            outputFileHeader.m_ShaderBlockOffset = 0;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (outputDebugGlslcFiles)</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">/* Create directory along side assets that glslc debug output files will go in */</span></div>
<div class="line">                std::string glslcOutputDirectory(outPath + <span class="stringliteral">&quot;GlslcDbg\\&quot;</span>);</div>
<div class="line">                <span class="keywordtype">wchar_t</span> ws[256];</div>
<div class="line">                memset(ws, 0, 256 * <span class="keyword">sizeof</span>(<span class="keywordtype">wchar_t</span>));</div>
<div class="line">                swprintf(ws, glslcOutputDirectory.size(), L<span class="stringliteral">&quot;%hs&quot;</span>, glslcOutputDirectory.c_str());</div>
<div class="line">                <a class="code" href="namespacenn_1_1fs.html#ad09dbc3816b9e95562081f9411711c4a">CreateDirectory</a>(ws, NULL);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            outputFileHeader.m_ShaderBlockOffset = <span class="keyword">sizeof</span>(OutputFileHeader);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Accumulates data about each shader program to be written out. */</span></div>
<div class="line">            <span class="keywordflow">for</span> (std::unordered_map&lt;std::string, ShaderCompileData&gt;::iterator itr = m_ShaderPrograms.begin(); itr != m_ShaderPrograms.end(); ++itr)</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">if</span> (itr-&gt;second.m_SpecializationParam.size() != 0)</div>
<div class="line">                {</div>
<div class="line">                    specializedShaderProgramHeaders.push_back(std::pair&lt;SpecializedShaderProgramHeader, std::vector&lt;std::pair&lt;ShaderProgramHeader, std::vector&lt;ShaderStageHeader&gt; &gt; &gt; &gt;());</div>
<div class="line"> </div>
<div class="line">                    SpecializedShaderProgramHeader&amp; specializedHeader = specializedShaderProgramHeaders.back().first;</div>
<div class="line"> </div>
<div class="line">                    specializedHeader.m_NumVariations = itr-&gt;second.m_NumOutputs;</div>
<div class="line">                    specializedHeader.m_pShaderProgramOffsets = (uint64_t*)malloc(<span class="keyword">sizeof</span>(uint64_t) * specializedHeader.m_NumVariations);</div>
<div class="line"> </div>
<div class="line">                    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; specializedHeader.m_NumVariations; ++i)</div>
<div class="line">                    {</div>
<div class="line">                        std::vector&lt;std::pair&lt;ShaderProgramHeader, std::vector&lt;ShaderStageHeader&gt; &gt; &gt;&amp; programHeaders = specializedShaderProgramHeaders.back().second;</div>
<div class="line">                        programHeaders.push_back(std::pair&lt;ShaderProgramHeader, std::vector&lt;ShaderStageHeader&gt; &gt;());</div>
<div class="line"> </div>
<div class="line">                        ShaderProgramHeader&amp; programHeader = programHeaders.back().first;</div>
<div class="line">                        std::vector&lt;ShaderStageHeader&gt;&amp; stageHeaders = programHeaders.back().second;</div>
<div class="line">                        <span class="keyword">const</span> <a class="code" href="struct_g_l_s_l_coutput.html">GLSLCoutput</a>* compileOutput = itr-&gt;second.m_ppGlslcOutputs[i];</div>
<div class="line"> </div>
<div class="line">                        <span class="keywordflow">if</span> (outputDebugGlslcFiles)</div>
<div class="line">                        {</div>
<div class="line">                            WriteGlslcDebugOutput(outPath, fileName, compileOutput);</div>
<div class="line">                        }</div>
<div class="line"> </div>
<div class="line">                        SetupShaderProgramHeader(itr-&gt;first, programHeader, stageHeaders, compileOutput);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">else</span></div>
<div class="line">                {</div>
<div class="line">                    shaderProgramHeaders.push_back(std::pair&lt;ShaderProgramHeader, std::vector&lt;ShaderStageHeader&gt; &gt;());</div>
<div class="line"> </div>
<div class="line">                    ShaderProgramHeader&amp; programHeader = shaderProgramHeaders.back().first;</div>
<div class="line">                    std::vector&lt;ShaderStageHeader&gt;&amp; stageHeaders = shaderProgramHeaders.back().second;</div>
<div class="line"> </div>
<div class="line">                    <span class="comment">/*</span></div>
<div class="line"><span class="comment">                     * GLSLCoutput</span></div>
<div class="line"><span class="comment">                     * -----------</span></div>
<div class="line"><span class="comment">                     * Holds the various sections output by the shader compile.</span></div>
<div class="line"><span class="comment">                     * Offsets to each section are from the beginning of the</span></div>
<div class="line"><span class="comment">                     * output struct. Offsets defined within a section are from</span></div>
<div class="line"><span class="comment">                     * the beginning of that section. These sections are:</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * GLSLC_SECTION_TYPE_GPU_CODE   - Holds the compiled binary and</span></div>
<div class="line"><span class="comment">                     *                                 information for a shader stage.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * GLSLC_SECTION_TYPE_ASM_DUMP   - Holds the assembly dump for the</span></div>
<div class="line"><span class="comment">                     *                                 compiled shader stage.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * GLSLC_SECTION_TYPE_PERF_STATS - Holds the performance stats for</span></div>
<div class="line"><span class="comment">                     *                                 the shader stage.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * GLSLC_SECTION_TYPE_REFLECTION - Holds the shader reflection data</span></div>
<div class="line"><span class="comment">                     *                                 for the shader stage.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * GLSLC_SECTION_TYPE_DEBUG_INFO - Holds debug information for the</span></div>
<div class="line"><span class="comment">                     *                                 shader stage.</span></div>
<div class="line"><span class="comment">                     */</span></div>
<div class="line">                    <a class="code" href="struct_g_l_s_l_coutput.html">GLSLCoutput</a>* compileOutput = itr-&gt;second.m_CompileObject.lastCompiledResults-&gt;glslcOutput;</div>
<div class="line"> </div>
<div class="line">                    SetupShaderProgramHeader(itr-&gt;first, programHeader, stageHeaders, compileOutput);</div>
<div class="line"> </div>
<div class="line">                    <span class="keywordflow">if</span> (outputDebugGlslcFiles)</div>
<div class="line">                    {</div>
<div class="line">                        WriteGlslcDebugOutput(outPath, fileName, compileOutput);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            shaderBlockHeader.m_NumShaderPrograms = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(shaderProgramHeaders.size());</div>
<div class="line">            shaderBlockHeader.m_NumSpecializedShaderPrograms = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(specializedShaderProgramHeaders.size());</div>
<div class="line"> </div>
<div class="line">            uint32_t shaderProgramOffsetsSize = <span class="keyword">sizeof</span>(uint64_t) * shaderBlockHeader.m_NumShaderPrograms;</div>
<div class="line">            shaderBlockHeader.m_pShaderProgramOffsets = (uint64_t*)malloc(shaderProgramOffsetsSize);</div>
<div class="line"> </div>
<div class="line">            uint32_t specializeShaderProgramOffsetsSize = <span class="keyword">sizeof</span>(uint64_t) * shaderBlockHeader.m_NumSpecializedShaderPrograms;</div>
<div class="line">            shaderBlockHeader.m_pSpecializedShaderProgramOffsets = (uint64_t*)malloc(specializeShaderProgramOffsetsSize);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Based on the accumulated data the currentOffset is updated. */</span></div>
<div class="line">            currentOffset += <span class="keyword">sizeof</span>(ShaderBlockHeader);</div>
<div class="line">            currentOffset -= <span class="keyword">sizeof</span>(shaderBlockHeader.m_pShaderProgramOffsets);</div>
<div class="line">            currentOffset -= <span class="keyword">sizeof</span>(shaderBlockHeader.m_pSpecializedShaderProgramOffsets);</div>
<div class="line">            currentOffset += shaderProgramOffsetsSize;</div>
<div class="line">            currentOffset += specializeShaderProgramOffsetsSize;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; shaderProgramHeaders.size(); ++i)</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">/*</span></div>
<div class="line"><span class="comment">                 * Align shader program header struct to account for</span></div>
<div class="line"><span class="comment">                 * variable length of shader name</span></div>
<div class="line"><span class="comment">                 */</span></div>
<div class="line">                currentOffset = Align(currentOffset, 8, currentPadding);</div>
<div class="line">                padding.push_back(currentPadding);</div>
<div class="line">                shaderBlockHeader.m_pShaderProgramOffsets[i] = currentOffset;</div>
<div class="line"> </div>
<div class="line">                SetupShaderProgramOffsets(shaderProgramHeaders[i], padding, currentOffset);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; specializedShaderProgramHeaders.size(); ++i)</div>
<div class="line">            {</div>
<div class="line">                currentOffset = Align(currentOffset, 8, currentPadding);</div>
<div class="line">                padding.push_back(currentPadding);</div>
<div class="line">                shaderBlockHeader.m_pSpecializedShaderProgramOffsets[i] = currentOffset;</div>
<div class="line"> </div>
<div class="line">                currentOffset += <span class="keyword">sizeof</span>(SpecializedShaderProgramHeader);</div>
<div class="line">                currentOffset -= <span class="keyword">sizeof</span>(specializedShaderProgramHeaders[i].first.m_pShaderProgramOffsets);</div>
<div class="line">                currentOffset += <span class="keyword">sizeof</span>(uint64_t) * specializedShaderProgramHeaders[i].first.m_NumVariations;</div>
<div class="line"> </div>
<div class="line">                for (uint32_t j = 0; j &lt; specializedShaderProgramHeaders[i].second.size(); ++j)</div>
<div class="line">                {</div>
<div class="line">                    <span class="comment">/*</span></div>
<div class="line"><span class="comment">                     * Align shader program header struct to account for</span></div>
<div class="line"><span class="comment">                     * variable length of shader name</span></div>
<div class="line"><span class="comment">                     */</span></div>
<div class="line">                    currentOffset = Align(currentOffset, 8, currentPadding);</div>
<div class="line">                    padding.push_back(currentPadding);</div>
<div class="line">                    specializedShaderProgramHeaders[i].first.m_pShaderProgramOffsets[j] = currentOffset;</div>
<div class="line"> </div>
<div class="line">                    SetupShaderProgramOffsets(specializedShaderProgramHeaders[i].second[j], padding, currentOffset);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Check for textures */</span></div>
<div class="line">        <span class="keywordflow">if</span> (!m_ConvertedTextureData.size())</div>
<div class="line">        {</div>
<div class="line">            outputFileHeader.m_TextureBlockOffset = 0;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            currentOffset = Align(currentOffset, 8, currentPadding);</div>
<div class="line">            padding.push_back(currentPadding);</div>
<div class="line">            outputFileHeader.m_TextureBlockOffset = currentOffset;</div>
<div class="line"> </div>
<div class="line">            textureBlockHeader.m_NumTextures = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(m_ConvertedTextureData.size());</div>
<div class="line">            textureBlockHeader.m_pTextureOffsets = (uint64_t*)malloc(<span class="keyword">sizeof</span>(uint64_t) * textureBlockHeader.m_NumTextures);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Accumulate data to be written out for the textures. */</span></div>
<div class="line">            <span class="keywordflow">for</span> (std::unordered_map&lt;std::string, nvnTool::texpkg::NVNHWTexture&gt;::iterator itr = m_ConvertedTextureData.begin(); itr != m_ConvertedTextureData.end(); ++itr)</div>
<div class="line">            {</div>
<div class="line">                textureDataHeaders.push_back(TextureDataHeader());</div>
<div class="line"> </div>
<div class="line">                TextureDataHeader&amp; header = textureDataHeaders.back();</div>
<div class="line"> </div>
<div class="line">                header.m_TextureDataSize = itr-&gt;second.header.dataSize;</div>
<div class="line">                header.m_GpuVersion = 0;</div>
<div class="line">                header.m_Alignment = itr-&gt;second.header.align;</div>
<div class="line">                header.m_Width = itr-&gt;second.header.width;</div>
<div class="line">                header.m_Height = itr-&gt;second.header.height;</div>
<div class="line">                header.m_Depth = itr-&gt;second.header.depth;</div>
<div class="line">                header.m_NvnTextureTarget = itr-&gt;second.header.target;</div>
<div class="line">                header.m_NvnFormat = itr-&gt;second.header.format;</div>
<div class="line">                header.m_MipLevels = itr-&gt;second.header.mipmapLevels;</div>
<div class="line">                header.m_TextureNameLength = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(itr-&gt;first.size());</div>
<div class="line">                header.m_TextureDataOffset = 0; <span class="comment">// Retrieve offset later</span></div>
<div class="line">                header.m_pTextureName = itr-&gt;first.c_str();</div>
<div class="line">                header.m_pTextureData = itr-&gt;second.data;</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Update currentOffset */</span></div>
<div class="line">            currentOffset += <span class="keyword">sizeof</span>(TextureBlockHeader);</div>
<div class="line">            currentOffset -= <span class="keyword">sizeof</span>(textureBlockHeader.m_pTextureOffsets);</div>
<div class="line">            currentOffset += <span class="keyword">sizeof</span>(uint64_t) * textureBlockHeader.m_NumTextures;</div>
<div class="line"> </div>
<div class="line">            for (uint32_t i = 0; i &lt; textureBlockHeader.m_NumTextures; ++i)</div>
<div class="line">            {</div>
<div class="line">                currentOffset = Align(currentOffset, 8, currentPadding);</div>
<div class="line">                padding.push_back(currentPadding);</div>
<div class="line">                textureBlockHeader.m_pTextureOffsets[i] = currentOffset;</div>
<div class="line"> </div>
<div class="line">                currentOffset += <span class="keyword">sizeof</span>(TextureDataHeader);</div>
<div class="line">                currentOffset -= <span class="keyword">sizeof</span>(textureDataHeaders[i].m_pTextureData);</div>
<div class="line">                currentOffset -= <span class="keyword">sizeof</span>(textureDataHeaders[i].m_pTextureName);</div>
<div class="line">                currentOffset += <span class="keyword">sizeof</span>(char) * textureDataHeaders[i].m_TextureNameLength;</div>
<div class="line"> </div>
<div class="line">                <span class="comment">/*</span></div>
<div class="line"><span class="comment">                 * Offset of texture data is set now to account for the variable</span></div>
<div class="line"><span class="comment">                 * size of the texture name</span></div>
<div class="line"><span class="comment">                 */</span></div>
<div class="line">                currentOffset = Align(currentOffset, 8, currentPadding);</div>
<div class="line">                padding.push_back(currentPadding);</div>
<div class="line">                textureDataHeaders[i].m_TextureDataOffset = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(currentOffset);</div>
<div class="line"> </div>
<div class="line">                currentOffset += <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(textureDataHeaders[i].m_TextureDataSize);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Check for models. */</span></div>
<div class="line">        <span class="keywordflow">if</span> (!m_RawModelData.size())</div>
<div class="line">        {</div>
<div class="line">            outputFileHeader.m_ModelBlockOffset = 0;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            currentOffset = Align(currentOffset, 8, currentPadding);</div>
<div class="line">            padding.push_back(currentPadding);</div>
<div class="line">            outputFileHeader.m_ModelBlockOffset = currentOffset;</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Accumulate model data in the header structs. */</span></div>
<div class="line">            <span class="keywordflow">for</span> (std::vector&lt;Model&gt;::iterator itr = m_RawModelData.begin(); itr != m_RawModelData.end(); ++itr)</div>
<div class="line">            {</div>
<div class="line">                modelHeaders.push_back(std::pair&lt;ModelHeader, std::pair&lt;std::vector&lt;VertexAttributeHeader&gt;, IndexBufferHeader&gt; &gt;());</div>
<div class="line"> </div>
<div class="line">                ModelHeader&amp; modelHeader = modelHeaders.back().first;</div>
<div class="line">                std::vector&lt;VertexAttributeHeader&gt;&amp; vertexBufferHeader = modelHeaders.back().second.first;</div>
<div class="line">                IndexBufferHeader&amp; indexBufferHeader = modelHeaders.back().second.second;</div>
<div class="line"> </div>
<div class="line">                modelHeader.m_NumPrimitives = itr-&gt;m_NumPrimitives;</div>
<div class="line">                modelHeader.m_NvnDrawPrimitiveType = itr-&gt;m_NvnDrawPrimitiveType;</div>
<div class="line">                modelHeader.m_NumVertexAttributes = itr-&gt;m_NumVertexAttributes;</div>
<div class="line">                modelHeader.m_ModelNameLength = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(itr-&gt;m_Name.size());</div>
<div class="line">                modelHeader.m_IndexBufferOffset = 0; <span class="comment">// Retrieve offset later</span></div>
<div class="line">                modelHeader.m_pModelName = itr-&gt;m_Name.c_str();</div>
<div class="line"> </div>
<div class="line">                indexBufferHeader.m_NumIndices = itr-&gt;m_IndexData.m_DataSize / itr-&gt;m_IndexData.m_Stride;</div>
<div class="line">                indexBufferHeader.m_IndexBufferSize = itr-&gt;m_IndexData.m_DataSize;</div>
<div class="line">                indexBufferHeader.m_pIndexData = itr-&gt;m_IndexData.m_pData;</div>
<div class="line">                indexBufferHeader.m_IndexType = itr-&gt;m_IndexData.m_IndexType;</div>
<div class="line">                indexBufferHeader.m_MagicPadding = 0;</div>
<div class="line"> </div>
<div class="line">                <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; itr-&gt;m_VertexAttributes.size(); ++i)</div>
<div class="line">                {</div>
<div class="line">                    VertexAttributeHeader attributeHeader;</div>
<div class="line">                    attributeHeader.m_AttributeStride = itr-&gt;m_VertexAttributes[i].m_Stride;</div>
<div class="line">                    attributeHeader.m_NvnFormat = itr-&gt;m_VertexAttributes[i].m_NvnFormat;</div>
<div class="line">                    attributeHeader.m_AttributeDataSize = itr-&gt;m_VertexAttributes[i].m_DataSize;</div>
<div class="line">                    attributeHeader.m_AttributeNameLength = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(itr-&gt;m_VertexAttributes[i].m_Name.size());</div>
<div class="line">                    attributeHeader.m_AttributeDataOffset = 0; <span class="comment">// Retrieve offset later</span></div>
<div class="line">                    attributeHeader.m_MagicPadding = 0;</div>
<div class="line">                    attributeHeader.m_pAttributeName = itr-&gt;m_VertexAttributes[i].m_Name.c_str();</div>
<div class="line">                    attributeHeader.m_AttributeData = itr-&gt;m_VertexAttributes[i].m_pData;</div>
<div class="line"> </div>
<div class="line">                    vertexBufferHeader.push_back(attributeHeader);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            modelBlockHeader.m_NumModels = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(m_RawModelData.size());</div>
<div class="line">            modelBlockHeader.m_pModelOffsets = (uint64_t*)malloc(<span class="keyword">sizeof</span>(uint64_t) * modelBlockHeader.m_NumModels);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Update currentOffset. */</span></div>
<div class="line">            currentOffset += <span class="keyword">sizeof</span>(ModelBlockHeader);</div>
<div class="line">            currentOffset -= <span class="keyword">sizeof</span>(modelBlockHeader.m_pModelOffsets);</div>
<div class="line">            currentOffset += <span class="keyword">sizeof</span>(uint64_t) * modelBlockHeader.m_NumModels;</div>
<div class="line"> </div>
<div class="line">            for (uint32_t i = 0; i &lt; modelHeaders.size(); ++i)</div>
<div class="line">            {</div>
<div class="line">                currentOffset = Align(currentOffset, 8, currentPadding);</div>
<div class="line">                padding.push_back(currentPadding);</div>
<div class="line">                modelBlockHeader.m_pModelOffsets[i] = currentOffset;</div>
<div class="line"> </div>
<div class="line">                currentOffset += <span class="keyword">sizeof</span>(ModelHeader);</div>
<div class="line">                currentOffset -= <span class="keyword">sizeof</span>(modelHeaders[i].first.m_pVertexAttributeOffsets);</div>
<div class="line">                currentOffset -= <span class="keyword">sizeof</span>(modelHeaders[i].first.m_pModelName);</div>
<div class="line">                currentOffset += <span class="keyword">sizeof</span>(uint64_t) * modelHeaders[i].second.first.size();</div>
<div class="line">                currentOffset += <span class="keyword">sizeof</span>(char) * modelHeaders[i].first.m_ModelNameLength;</div>
<div class="line"> </div>
<div class="line">                modelHeaders[i].first.m_pVertexAttributeOffsets = (uint64_t*)malloc(<span class="keyword">sizeof</span>(uint64_t) * modelHeaders[i].second.first.size());</div>
<div class="line"> </div>
<div class="line">                <span class="keywordflow">for</span> (uint32_t j = 0; j &lt; modelHeaders[i].second.first.size(); ++j)</div>
<div class="line">                {</div>
<div class="line">                    currentOffset = Align(currentOffset, 8, currentPadding);</div>
<div class="line">                    padding.push_back(currentPadding);</div>
<div class="line">                    modelHeaders[i].first.m_pVertexAttributeOffsets[j] = currentOffset;</div>
<div class="line"> </div>
<div class="line">                    currentOffset += <span class="keyword">sizeof</span>(VertexAttributeHeader);</div>
<div class="line">                    currentOffset -= <span class="keyword">sizeof</span>(modelHeaders[i].second.first[j].m_pAttributeName);</div>
<div class="line">                    currentOffset -= <span class="keyword">sizeof</span>(modelHeaders[i].second.first[j].m_AttributeData);</div>
<div class="line">                    currentOffset += <span class="keyword">sizeof</span>(char) * modelHeaders[i].second.first[j].m_AttributeNameLength;</div>
<div class="line"> </div>
<div class="line">                    <span class="comment">/*</span></div>
<div class="line"><span class="comment">                     * Offset of vertex attribute data is set now to account for the variable</span></div>
<div class="line"><span class="comment">                     * size of the attribute&#39;s name</span></div>
<div class="line"><span class="comment">                     */</span></div>
<div class="line">                    currentOffset = Align(currentOffset, 8, currentPadding);</div>
<div class="line">                    padding.push_back(currentPadding);</div>
<div class="line">                    modelHeaders[i].second.first[j].m_AttributeDataOffset = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(currentOffset);</div>
<div class="line"> </div>
<div class="line">                    currentOffset += modelHeaders[i].second.first[j].m_AttributeDataSize;</div>
<div class="line">                }</div>
<div class="line"> </div>
<div class="line">                currentOffset = Align(currentOffset, 8, currentPadding);</div>
<div class="line">                padding.push_back(currentPadding);</div>
<div class="line">                modelHeaders[i].first.m_IndexBufferOffset = currentOffset;</div>
<div class="line"> </div>
<div class="line">                currentOffset += <span class="keyword">sizeof</span>(IndexBufferHeader);</div>
<div class="line">                currentOffset -= <span class="keyword">sizeof</span>(modelHeaders[i].second.second.m_pIndexData);</div>
<div class="line">                currentOffset += modelHeaders[i].second.second.m_IndexBufferSize;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Write the output file based on the setup file section headers. */</span></div>
<div class="line">        uint64_t writtenBytes = 0;</div>
<div class="line">        uint32_t currentPaddingIndex = 0;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// File Header</span></div>
<div class="line">        fwrite(&amp;outputFileHeader, <span class="keyword">sizeof</span>(outputFileHeader), 1, outputFile);</div>
<div class="line">        writtenBytes += <span class="keyword">sizeof</span>(outputFileHeader);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (outputFileHeader.m_ShaderBlockOffset)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Shader Block Header</span></div>
<div class="line">            fwrite(&amp;shaderBlockHeader.m_NumShaderPrograms, <span class="keyword">sizeof</span>(shaderBlockHeader.m_NumShaderPrograms), 1, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(shaderBlockHeader.m_NumShaderPrograms);</div>
<div class="line"> </div>
<div class="line">            fwrite(&amp;shaderBlockHeader.m_NumSpecializedShaderPrograms, <span class="keyword">sizeof</span>(shaderBlockHeader.m_NumSpecializedShaderPrograms), 1, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(shaderBlockHeader.m_NumSpecializedShaderPrograms);</div>
<div class="line"> </div>
<div class="line">            fwrite(shaderBlockHeader.m_pShaderProgramOffsets, <span class="keyword">sizeof</span>(shaderBlockHeader.m_pShaderProgramOffsets[0]), shaderBlockHeader.m_NumShaderPrograms, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(shaderBlockHeader.m_pShaderProgramOffsets[0]) * shaderBlockHeader.m_NumShaderPrograms;</div>
<div class="line"> </div>
<div class="line">            fwrite(shaderBlockHeader.m_pSpecializedShaderProgramOffsets, <span class="keyword">sizeof</span>(shaderBlockHeader.m_pSpecializedShaderProgramOffsets[0]), shaderBlockHeader.m_NumSpecializedShaderPrograms, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(shaderBlockHeader.m_pSpecializedShaderProgramOffsets[0]) * shaderBlockHeader.m_NumSpecializedShaderPrograms;</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Shader Program Headers</span></div>
<div class="line">            for (uint32_t i = 0; i &lt; shaderProgramHeaders.size(); ++i)</div>
<div class="line">            {</div>
<div class="line">                WriteShaderProgramHeaders(outputFile, shaderProgramHeaders[i], padding, writtenBytes, currentPaddingIndex);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; specializedShaderProgramHeaders.size(); ++i)</div>
<div class="line">            {</div>
<div class="line">                writtenBytes += PadFileBuffer(outputFile, padding[currentPaddingIndex++]);</div>
<div class="line"> </div>
<div class="line">                fwrite(&amp;specializedShaderProgramHeaders[i].first.m_NumVariations, <span class="keyword">sizeof</span>(specializedShaderProgramHeaders[i].first.m_NumVariations), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(specializedShaderProgramHeaders[i].first.m_NumVariations);</div>
<div class="line"> </div>
<div class="line">                fwrite(&amp;specializedShaderProgramHeaders[i].first.m_MagicPadding, <span class="keyword">sizeof</span>(specializedShaderProgramHeaders[i].first.m_MagicPadding), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(specializedShaderProgramHeaders[i].first.m_MagicPadding);</div>
<div class="line"> </div>
<div class="line">                fwrite(specializedShaderProgramHeaders[i].first.m_pShaderProgramOffsets, <span class="keyword">sizeof</span>(specializedShaderProgramHeaders[i].first.m_pShaderProgramOffsets[0]), specializedShaderProgramHeaders[i].first.m_NumVariations, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(specializedShaderProgramHeaders[i].first.m_pShaderProgramOffsets[0]) * specializedShaderProgramHeaders[i].first.m_NumVariations;</div>
<div class="line"> </div>
<div class="line">                for (uint32_t j = 0; j &lt; specializedShaderProgramHeaders[i].second.size(); ++j)</div>
<div class="line">                {</div>
<div class="line">                    WriteShaderProgramHeaders(outputFile, specializedShaderProgramHeaders[i].second[j], padding, writtenBytes, currentPaddingIndex);</div>
<div class="line">                }</div>
<div class="line"> </div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (outputFileHeader.m_TextureBlockOffset)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Insert padding</span></div>
<div class="line">            writtenBytes += PadFileBuffer(outputFile, padding[currentPaddingIndex++]);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Texture Block Header</span></div>
<div class="line">            fwrite(&amp;textureBlockHeader.m_NumTextures, <span class="keyword">sizeof</span>(textureBlockHeader.m_NumTextures), 1, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(textureBlockHeader.m_NumTextures);</div>
<div class="line"> </div>
<div class="line">            fwrite(&amp;textureBlockHeader.m_MagicPadding, <span class="keyword">sizeof</span>(textureBlockHeader.m_MagicPadding), 1, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(textureBlockHeader.m_MagicPadding);</div>
<div class="line"> </div>
<div class="line">            fwrite(textureBlockHeader.m_pTextureOffsets, <span class="keyword">sizeof</span>(uint64_t), textureBlockHeader.m_NumTextures, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(uint64_t) * textureBlockHeader.m_NumTextures;</div>
<div class="line"> </div>
<div class="line">            for (uint32_t i = 0; i &lt; textureDataHeaders.size(); ++i)</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// Insert padding</span></div>
<div class="line">                writtenBytes += PadFileBuffer(outputFile, padding[currentPaddingIndex++]);</div>
<div class="line"> </div>
<div class="line">                fwrite(&amp;textureDataHeaders[i].m_TextureDataSize, <span class="keyword">sizeof</span>(textureDataHeaders[i].m_TextureDataSize), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(textureDataHeaders[i].m_TextureDataSize);</div>
<div class="line"> </div>
<div class="line">                fwrite(&amp;textureDataHeaders[i].m_GpuVersion, <span class="keyword">sizeof</span>(textureDataHeaders[i].m_GpuVersion), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(textureDataHeaders[i].m_GpuVersion);</div>
<div class="line"> </div>
<div class="line">                fwrite(&amp;textureDataHeaders[i].m_Alignment, <span class="keyword">sizeof</span>(textureDataHeaders[i].m_Alignment), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(textureDataHeaders[i].m_Alignment);</div>
<div class="line"> </div>
<div class="line">                fwrite(&amp;textureDataHeaders[i].m_Width, <span class="keyword">sizeof</span>(textureDataHeaders[i].m_Width), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(textureDataHeaders[i].m_Width);</div>
<div class="line"> </div>
<div class="line">                fwrite(&amp;textureDataHeaders[i].m_Height, <span class="keyword">sizeof</span>(textureDataHeaders[i].m_Height), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(textureDataHeaders[i].m_Height);</div>
<div class="line"> </div>
<div class="line">                fwrite(&amp;textureDataHeaders[i].m_Depth, <span class="keyword">sizeof</span>(textureDataHeaders[i].m_Depth), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(textureDataHeaders[i].m_Depth);</div>
<div class="line"> </div>
<div class="line">                fwrite(&amp;textureDataHeaders[i].m_NvnTextureTarget, <span class="keyword">sizeof</span>(textureDataHeaders[i].m_NvnTextureTarget), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(textureDataHeaders[i].m_NvnTextureTarget);</div>
<div class="line"> </div>
<div class="line">                fwrite(&amp;textureDataHeaders[i].m_NvnFormat, <span class="keyword">sizeof</span>(textureDataHeaders[i].m_NvnFormat), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(textureDataHeaders[i].m_NvnFormat);</div>
<div class="line"> </div>
<div class="line">                fwrite(&amp;textureDataHeaders[i].m_MipLevels, <span class="keyword">sizeof</span>(textureDataHeaders[i].m_MipLevels), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(textureDataHeaders[i].m_MipLevels);</div>
<div class="line"> </div>
<div class="line">                fwrite(&amp;textureDataHeaders[i].m_TextureNameLength, <span class="keyword">sizeof</span>(textureDataHeaders[i].m_TextureNameLength), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(textureDataHeaders[i].m_TextureNameLength);</div>
<div class="line"> </div>
<div class="line">                fwrite(&amp;textureDataHeaders[i].m_TextureDataOffset, <span class="keyword">sizeof</span>(textureDataHeaders[i].m_TextureDataOffset), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(textureDataHeaders[i].m_TextureDataOffset);</div>
<div class="line"> </div>
<div class="line">                fwrite(textureDataHeaders[i].m_pTextureName, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>), textureDataHeaders[i].m_TextureNameLength, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(char) * textureDataHeaders[i].m_TextureNameLength;</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// Insert padding</span></div>
<div class="line">                writtenBytes += PadFileBuffer(outputFile, padding[currentPaddingIndex++]);</div>
<div class="line"> </div>
<div class="line">                fwrite(textureDataHeaders[i].m_pTextureData, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>), <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(textureDataHeaders[i].m_TextureDataSize), outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(char) * textureDataHeaders[i].m_TextureDataSize;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (outputFileHeader.m_ModelBlockOffset)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Insert padding</span></div>
<div class="line">            writtenBytes += PadFileBuffer(outputFile, padding[currentPaddingIndex++]);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Model Block Header</span></div>
<div class="line">            fwrite(&amp;modelBlockHeader.m_NumModels, <span class="keyword">sizeof</span>(modelBlockHeader.m_NumModels), 1, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(modelBlockHeader.m_NumModels);</div>
<div class="line"> </div>
<div class="line">            fwrite(&amp;modelBlockHeader.m_MagicPadding, <span class="keyword">sizeof</span>(modelBlockHeader.m_MagicPadding), 1, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(modelBlockHeader.m_MagicPadding);</div>
<div class="line"> </div>
<div class="line">            fwrite(modelBlockHeader.m_pModelOffsets, <span class="keyword">sizeof</span>(uint64_t), modelBlockHeader.m_NumModels, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(uint64_t) * modelBlockHeader.m_NumModels;</div>
<div class="line"> </div>
<div class="line">            for (uint32_t i = 0; i &lt; modelHeaders.size(); ++i)</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// Insert padding</span></div>
<div class="line">                writtenBytes += PadFileBuffer(outputFile, padding[currentPaddingIndex++]);</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// Model Header</span></div>
<div class="line">                fwrite(&amp;modelHeaders[i].first.m_NumPrimitives, <span class="keyword">sizeof</span>(modelHeaders[i].first.m_NumPrimitives), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(modelHeaders[i].first.m_NumPrimitives);</div>
<div class="line"> </div>
<div class="line">                fwrite(&amp;modelHeaders[i].first.m_NvnDrawPrimitiveType, <span class="keyword">sizeof</span>(modelHeaders[i].first.m_NvnDrawPrimitiveType), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(modelHeaders[i].first.m_NvnDrawPrimitiveType);</div>
<div class="line"> </div>
<div class="line">                fwrite(&amp;modelHeaders[i].first.m_NumVertexAttributes, <span class="keyword">sizeof</span>(modelHeaders[i].first.m_NumVertexAttributes), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(modelHeaders[i].first.m_NumVertexAttributes);</div>
<div class="line"> </div>
<div class="line">                fwrite(&amp;modelHeaders[i].first.m_ModelNameLength, <span class="keyword">sizeof</span>(modelHeaders[i].first.m_ModelNameLength), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(modelHeaders[i].first.m_ModelNameLength);</div>
<div class="line"> </div>
<div class="line">                fwrite(&amp;modelHeaders[i].first.m_IndexBufferOffset, <span class="keyword">sizeof</span>(modelHeaders[i].first.m_IndexBufferOffset), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(modelHeaders[i].first.m_IndexBufferOffset);</div>
<div class="line"> </div>
<div class="line">                fwrite(modelHeaders[i].first.m_pVertexAttributeOffsets, <span class="keyword">sizeof</span>(uint64_t), modelHeaders[i].first.m_NumVertexAttributes, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(uint64_t) * modelHeaders[i].first.m_NumVertexAttributes;</div>
<div class="line"> </div>
<div class="line">                fwrite(modelHeaders[i].first.m_pModelName, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>), modelHeaders[i].first.m_ModelNameLength, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(char) * modelHeaders[i].first.m_ModelNameLength;</div>
<div class="line"> </div>
<div class="line">                std::vector&lt;VertexAttributeHeader&gt;&amp; vertexAttributes = modelHeaders[i].second.first;</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// Vertex Attributes</span></div>
<div class="line">                for (uint32_t j = 0; j &lt; vertexAttributes.size(); ++j)</div>
<div class="line">                {</div>
<div class="line">                    <span class="comment">// Insert padding</span></div>
<div class="line">                    writtenBytes += PadFileBuffer(outputFile, padding[currentPaddingIndex++]);</div>
<div class="line"> </div>
<div class="line">                    fwrite(&amp;vertexAttributes[j].m_AttributeStride, <span class="keyword">sizeof</span>(vertexAttributes[j].m_AttributeStride), 1, outputFile);</div>
<div class="line">                    writtenBytes += <span class="keyword">sizeof</span>(vertexAttributes[j].m_AttributeStride);</div>
<div class="line"> </div>
<div class="line">                    fwrite(&amp;vertexAttributes[j].m_NvnFormat, <span class="keyword">sizeof</span>(vertexAttributes[j].m_NvnFormat), 1, outputFile);</div>
<div class="line">                    writtenBytes += <span class="keyword">sizeof</span>(vertexAttributes[j].m_NvnFormat);</div>
<div class="line"> </div>
<div class="line">                    fwrite(&amp;vertexAttributes[j].m_AttributeDataSize, <span class="keyword">sizeof</span>(vertexAttributes[j].m_AttributeDataSize), 1, outputFile);</div>
<div class="line">                    writtenBytes += <span class="keyword">sizeof</span>(vertexAttributes[j].m_AttributeDataSize);</div>
<div class="line"> </div>
<div class="line">                    fwrite(&amp;vertexAttributes[j].m_AttributeNameLength, <span class="keyword">sizeof</span>(vertexAttributes[j].m_AttributeNameLength), 1, outputFile);</div>
<div class="line">                    writtenBytes += <span class="keyword">sizeof</span>(vertexAttributes[j].m_AttributeNameLength);</div>
<div class="line"> </div>
<div class="line">                    fwrite(&amp;vertexAttributes[j].m_AttributeDataOffset, <span class="keyword">sizeof</span>(vertexAttributes[j].m_AttributeDataOffset), 1, outputFile);</div>
<div class="line">                    writtenBytes += <span class="keyword">sizeof</span>(vertexAttributes[j].m_AttributeDataOffset);</div>
<div class="line"> </div>
<div class="line">                    fwrite(&amp;vertexAttributes[j].m_MagicPadding, <span class="keyword">sizeof</span>(vertexAttributes[j].m_MagicPadding), 1, outputFile);</div>
<div class="line">                    writtenBytes += <span class="keyword">sizeof</span>(vertexAttributes[j].m_MagicPadding);</div>
<div class="line"> </div>
<div class="line">                    fwrite(vertexAttributes[j].m_pAttributeName, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>), vertexAttributes[j].m_AttributeNameLength, outputFile);</div>
<div class="line">                    writtenBytes += <span class="keyword">sizeof</span>(char) * vertexAttributes[j].m_AttributeNameLength;</div>
<div class="line"> </div>
<div class="line">                    <span class="comment">// Insert padding</span></div>
<div class="line">                    writtenBytes += PadFileBuffer(outputFile, padding[currentPaddingIndex++]);</div>
<div class="line"> </div>
<div class="line">                    fwrite(vertexAttributes[j].m_AttributeData, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>), vertexAttributes[j].m_AttributeDataSize, outputFile);</div>
<div class="line">                    writtenBytes += <span class="keyword">sizeof</span>(char) * vertexAttributes[j].m_AttributeDataSize;</div>
<div class="line">                }</div>
<div class="line"> </div>
<div class="line">                    <span class="comment">// Insert padding</span></div>
<div class="line">                writtenBytes += PadFileBuffer(outputFile, padding[currentPaddingIndex++]);</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// Index Buffer Header/Data</span></div>
<div class="line">                fwrite(&amp;modelHeaders[i].second.second.m_IndexBufferSize, <span class="keyword">sizeof</span>(modelHeaders[i].second.second.m_IndexBufferSize), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(modelHeaders[i].second.second.m_IndexBufferSize);</div>
<div class="line"> </div>
<div class="line">                fwrite(&amp;modelHeaders[i].second.second.m_NumIndices, <span class="keyword">sizeof</span>(modelHeaders[i].second.second.m_NumIndices), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(modelHeaders[i].second.second.m_NumIndices);</div>
<div class="line"> </div>
<div class="line">                fwrite(&amp;modelHeaders[i].second.second.m_IndexType, <span class="keyword">sizeof</span>(modelHeaders[i].second.second.m_IndexType), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(modelHeaders[i].second.second.m_IndexType);</div>
<div class="line"> </div>
<div class="line">                fwrite(&amp;modelHeaders[i].second.second.m_MagicPadding, <span class="keyword">sizeof</span>(modelHeaders[i].second.second.m_MagicPadding), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(modelHeaders[i].second.second.m_MagicPadding);</div>
<div class="line"> </div>
<div class="line">                fwrite(modelHeaders[i].second.second.m_pIndexData, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>), modelHeaders[i].second.second.m_IndexBufferSize, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(char) * modelHeaders[i].second.second.m_IndexBufferSize;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check if number of bytes written to file does not match size of data generated</span></div>
<div class="line">        assert(writtenBytes == currentOffset);</div>
<div class="line"> </div>
<div class="line">        fclose(outputFile);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (outputFileHeader.m_ShaderBlockOffset)</div>
<div class="line">        {</div>
<div class="line">            free(shaderBlockHeader.m_pShaderProgramOffsets);</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; shaderProgramHeaders.size(); ++i)</div>
<div class="line">            {</div>
<div class="line">                free(shaderProgramHeaders[i].first.m_pShaderStageOffsets);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (outputFileHeader.m_TextureBlockOffset)</div>
<div class="line">        {</div>
<div class="line">            free(textureBlockHeader.m_pTextureOffsets);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (outputFileHeader.m_ModelBlockOffset)</div>
<div class="line">        {</div>
<div class="line">            free(modelBlockHeader.m_pModelOffsets);</div>
<div class="line">            <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; modelHeaders.size(); ++i)</div>
<div class="line">            {</div>
<div class="line">                free(modelHeaders[i].first.m_pVertexAttributeOffsets);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* WaveFrontObjs are saved to a separate file */</span></div>
<div class="line">    <span class="keywordflow">if</span> (m_WaveFrontObjs.size())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">for</span> (std::unordered_map&lt;std::string, WaveFrontObjConfig&gt;::iterator itr = m_WaveFrontObjs.begin(); itr != m_WaveFrontObjs.end(); ++itr)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (!m_WaveFrontFileManager.WriteBinaryFile(outPath, itr-&gt;first, itr-&gt;second))</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}<span class="comment">//NOLINT(impl/function_size)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::OutputUniformBlockHeaderFiles</span></div>
<div class="line"><span class="comment"> * ------------------------------------------------------</span></div>
<div class="line"><span class="comment"> * This function takes the shader reflection data and the shader performance</span></div>
<div class="line"><span class="comment"> * data from the GLSLC compile object and outputs a C++ header/source file pair.</span></div>
<div class="line"><span class="comment"> * These files define some classes and static data for the vertex attributes</span></div>
<div class="line"><span class="comment"> * and uniform blocks to help with setting up the data to be passed to the</span></div>
<div class="line"><span class="comment"> * shader and keeps track of the location for the data in the shader per stage.</span></div>
<div class="line"><span class="comment"> * The uniform block classes have helper functions to set individual members at</span></div>
<div class="line"><span class="comment"> * the correct offset in the block. The shader performance data is output at the</span></div>
<div class="line"><span class="comment"> * top of the header file in a comment for each stage.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">bool</span> IntermediateFileManager::OutputUniformBlockHeaderFiles(<span class="keyword">const</span> std::string&amp; path)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (std::unordered_map&lt;std::string, ShaderCompileData&gt;::iterator itr = m_ShaderPrograms.begin(); itr != m_ShaderPrograms.end(); ++itr)</div>
<div class="line">    {</div>
<div class="line">        std::ofstream file;</div>
<div class="line">        file.open(path + (itr-&gt;first + <span class="stringliteral">&quot;DataHelper.h&quot;</span>), std::fstream::out);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (!file.is_open())</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to create output header file for &quot;</span> &lt;&lt; itr-&gt;first &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;    &quot;</span> &lt;&lt; path &lt;&lt; itr-&gt;first &lt;&lt; <span class="stringliteral">&quot;DataHelper.h\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;/*--------------------------------------------------------------------------------*\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot; Copyright (C)Nintendo All rights reserved.\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot; These coded instructions, statements, and computer programs contain proprietary\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot; information of Nintendo and/or its licensed developers and are protected by\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot; national and international copyright laws. They may not be disclosed to third\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot; parties or copied or duplicated in any form, in whole or in part, without the\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot; prior written consent of Nintendo.\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot; The content herein is highly confidential and should be handled accordingly.\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot; *--------------------------------------------------------------------------------*/\n\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;/*\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot; * &quot;</span> &lt;&lt; itr-&gt;first &lt;&lt; <span class="stringliteral">&quot;DataHelper.h\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot; * -------------------------------------------------\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot; * This is a generated file from GLSLC shader\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot; * compile reflection information. Do not edit.\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot; * -------------------------------------------------\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot; */\n\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (itr-&gt;second.m_SpecializationParam.size() == 0)</div>
<div class="line">        {</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;/*\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot; * Shader Program: &quot;</span> &lt;&lt; itr-&gt;first &lt;&lt; <span class="stringliteral">&quot;\n * \n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">            <a class="code" href="struct_g_l_s_l_coutput.html">GLSLCoutput</a>* compileOutput = itr-&gt;second.m_CompileObject.lastCompiledResults-&gt;glslcOutput;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; compileOutput-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#a6cbb6ec5e8a4ff04512fd1c442aa3d92">numSections</a>; ++i)</div>
<div class="line">            {</div>
<div class="line">                <a class="code" href="nvn_tool___glslc_interface_8h.html#aab53ab9845cc7be41102195446759a59">GLSLCsectionTypeEnum</a> type = compileOutput-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#a69ff5a7c06d39592caacec94be810995">headers</a>[i].genericHeader.common.<a class="code" href="struct_g_l_s_l_csection_header_common.html#a6a8aed7a5a7e82acff908d084fd85e4a">type</a>;</div>
<div class="line"> </div>
<div class="line">                <span class="keywordflow">if</span> (type == GLSLC_SECTION_TYPE_GPU_CODE)</div>
<div class="line">                {</div>
<div class="line">                    <span class="keyword">const</span> <a class="code" href="struct_g_l_s_l_cgpu_code_header.html">GLSLCgpuCodeHeader</a> * gpuHeader = &amp;(compileOutput-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#a69ff5a7c06d39592caacec94be810995">headers</a>[i].gpuCodeHeader);</div>
<div class="line">                    <span class="keywordtype">int</span> perfStatsNdx = gpuHeader-&gt;<a name="a36"></a><a class="code" href="struct_g_l_s_l_cgpu_code_header.html#a210237850b30911ca52acf10d628bc0e">perfStatsSectionNdx</a>;</div>
<div class="line"> </div>
<div class="line">                    <span class="keyword">const</span> <a name="_a37"></a><a class="code" href="struct_g_l_s_l_cperf_stats_header.html">GLSLCperfStatsHeader</a> * perfStatsHeader = &amp;(compileOutput-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#a69ff5a7c06d39592caacec94be810995">headers</a>[perfStatsNdx].<a name="a38"></a>perfStatsHeader);</div>
<div class="line"> </div>
<div class="line">                        <span class="comment">/*</span></div>
<div class="line"><span class="comment">                         * GLSLCperfStatsData</span></div>
<div class="line"><span class="comment">                         * ------------------</span></div>
<div class="line"><span class="comment">                         * The GLSLCperfStatsData structure holds the performance data</span></div>
<div class="line"><span class="comment">                         * information for a specific shader stage. This information is</span></div>
<div class="line"><span class="comment">                         * present in the option was set in the GLSLCoptions structure</span></div>
<div class="line"><span class="comment">                         * before the last compile.</span></div>
<div class="line"><span class="comment">                         *</span></div>
<div class="line"><span class="comment">                         * magic                - Indicates the presence of perf stats data for</span></div>
<div class="line"><span class="comment">                         *                        sanity checking. This should be equal to the</span></div>
<div class="line"><span class="comment">                         *                        define GLSLC_PERF_STATS_SECTION_MAGIC_NUMBER.</span></div>
<div class="line"><span class="comment">                         * spillMem             - Spill memory data. (lmem and smem)</span></div>
<div class="line"><span class="comment">                         *</span></div>
<div class="line"><span class="comment">                         * nonSpillLMem         - Non-spill memory.</span></div>
<div class="line"><span class="comment">                         *</span></div>
<div class="line"><span class="comment">                         * throughputLimiter    - Throughput limiter information. Values are in terms</span></div>
<div class="line"><span class="comment">                         *                        of warps per cycle.</span></div>
<div class="line"><span class="comment">                         *</span></div>
<div class="line"><span class="comment">                         * loopData             - Loop unroll information. Contains number of partially</span></div>
<div class="line"><span class="comment">                         *                        unrolled loops and number of not unrolled loops.</span></div>
<div class="line"><span class="comment">                         *</span></div>
<div class="line"><span class="comment">                         * latency              - Cycles per pixel.</span></div>
<div class="line"><span class="comment">                         *</span></div>
<div class="line"><span class="comment">                         * occupancy            - Ratio of active warps to maximum number of warps</span></div>
<div class="line"><span class="comment">                         *                        supported.</span></div>
<div class="line"><span class="comment">                         *</span></div>
<div class="line"><span class="comment">                         * numDivergentBranches - Number of divergent branches.</span></div>
<div class="line"><span class="comment">                         *</span></div>
<div class="line"><span class="comment">                         * attributeMemUsage    - Attribute memory usage in bytes.</span></div>
<div class="line"><span class="comment">                         *</span></div>
<div class="line"><span class="comment">                         * programSize          - Program size in bytes.</span></div>
<div class="line"><span class="comment">                         *</span></div>
<div class="line"><span class="comment">                         */</span></div>
<div class="line">                    <span class="keyword">const</span> <a name="_a39"></a><a class="code" href="struct_g_l_s_l_cperf_stats_data.html">GLSLCperfStatsData</a> * perfStatsData = (<span class="keyword">const</span> <a class="code" href="struct_g_l_s_l_cperf_stats_data.html">GLSLCperfStatsData</a> *)(((<span class="keyword">const</span> <span class="keywordtype">char</span>*)(compileOutput)) + perfStatsHeader-&gt;<a name="a40"></a>common.<a class="code" href="struct_g_l_s_l_csection_header_common.html#abb6e96b70bad30c94477317328d384d5">dataOffset</a>);</div>
<div class="line"> </div>
<div class="line">                    std::string stage;</div>
<div class="line"> </div>
<div class="line">                    <span class="keywordflow">switch</span> (gpuHeader-&gt;<a class="code" href="struct_g_l_s_l_cgpu_code_header.html#ab1e6be676a326a7281e18ad3a4607ced">stage</a>)</div>
<div class="line">                    {</div>
<div class="line">                    <span class="keywordflow">case</span> NVNshaderStage::NVN_SHADER_STAGE_VERTEX:</div>
<div class="line">                        stage = <span class="stringliteral">&quot;Vertex&quot;</span>;</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    <span class="keywordflow">case</span> NVNshaderStage::NVN_SHADER_STAGE_FRAGMENT:</div>
<div class="line">                        stage = <span class="stringliteral">&quot;Fragment&quot;</span>;</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    <span class="keywordflow">case</span> NVNshaderStage::NVN_SHADER_STAGE_GEOMETRY:</div>
<div class="line">                        stage = <span class="stringliteral">&quot;Geometry&quot;</span>;</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    <span class="keywordflow">case</span> NVNshaderStage::NVN_SHADER_STAGE_TESS_CONTROL:</div>
<div class="line">                        stage = <span class="stringliteral">&quot;Tesselation Control&quot;</span>;</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    <span class="keywordflow">case</span> NVNshaderStage::NVN_SHADER_STAGE_TESS_EVALUATION:</div>
<div class="line">                        stage = <span class="stringliteral">&quot;Tesselation Evaluation&quot;</span>;</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    <span class="keywordflow">case</span> NVNshaderStage::NVN_SHADER_STAGE_COMPUTE:</div>
<div class="line">                        stage = <span class="stringliteral">&quot;Compute&quot;</span>;</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    <span class="keywordflow">default</span>:</div>
<div class="line">                        assert(<span class="keyword">false</span>);</div>
<div class="line">                    }</div>
<div class="line"> </div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot; * Perf Statistics - Stage: &quot;</span> &lt;&lt; stage &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot; * -------------------------------------------------------------&quot;</span> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot; * Latency:                           &quot;</span> &lt;&lt; perfStatsData-&gt;<a name="a41"></a><a class="code" href="struct_g_l_s_l_cperf_stats_data.html#aeba2f57d7a5786cfac325cd5ea99250c">latency</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot; * Number of lmem spill bytes:        &quot;</span> &lt;&lt; perfStatsData-&gt;<a name="a42"></a><a class="code" href="struct_g_l_s_l_cperf_stats_data.html#ae368ee8152d78e81cd42094c5d7f08a4">spillMem</a>.<a name="a43"></a><a class="code" href="struct_g_l_s_l_cspill_l_mem.html#ad224d4137a67b9e8009302ce36351305">numLmemSpillBytes</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot; * Number of lmem refill bytes:       &quot;</span> &lt;&lt; perfStatsData-&gt;<a class="code" href="struct_g_l_s_l_cperf_stats_data.html#ae368ee8152d78e81cd42094c5d7f08a4">spillMem</a>.<a name="a44"></a><a class="code" href="struct_g_l_s_l_cspill_l_mem.html#af6b39e00e63c8a8e0f7e0b6873221e1a">numLmemRefillBytes</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot; * Number of smem spill bytes:        &quot;</span> &lt;&lt; perfStatsData-&gt;<a class="code" href="struct_g_l_s_l_cperf_stats_data.html#ae368ee8152d78e81cd42094c5d7f08a4">spillMem</a>.<a name="a45"></a><a class="code" href="struct_g_l_s_l_cspill_l_mem.html#ad2e83c16dc5264df509f512c3807705b">numSmemSpillBytes</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot; * Number of smem refill bytes:       &quot;</span> &lt;&lt; perfStatsData-&gt;<a class="code" href="struct_g_l_s_l_cperf_stats_data.html#ae368ee8152d78e81cd42094c5d7f08a4">spillMem</a>.<a name="a46"></a><a class="code" href="struct_g_l_s_l_cspill_l_mem.html#a41a1bf5449af1806420a1160482adb1e">numSmemRefillBytes</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot; * Lmem Spill Size:                   &quot;</span> &lt;&lt; perfStatsData-&gt;<a class="code" href="struct_g_l_s_l_cperf_stats_data.html#ae368ee8152d78e81cd42094c5d7f08a4">spillMem</a>.<a name="a47"></a><a class="code" href="struct_g_l_s_l_cspill_l_mem.html#a6cfdf0aeb653422164babeffc41b4b68">size</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot; * Local Memory Non-spill Loads:      &quot;</span> &lt;&lt; perfStatsData-&gt;<a name="a48"></a><a class="code" href="struct_g_l_s_l_cperf_stats_data.html#a9adc6910a33636f8688ad1231d0ad293">nonSpillLMem</a>.<a name="a49"></a><a class="code" href="struct_g_l_s_l_cnon_spill_l_mem.html#a27760cf751240260637a72447d127bb6">loadBytes</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot; * Local Memory Non-spill Stores:     &quot;</span> &lt;&lt; perfStatsData-&gt;<a class="code" href="struct_g_l_s_l_cperf_stats_data.html#a9adc6910a33636f8688ad1231d0ad293">nonSpillLMem</a>.<a name="a50"></a><a class="code" href="struct_g_l_s_l_cnon_spill_l_mem.html#a9e9f1b81107865e233a351231841e6f6">storeBytes</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot; * Non-spill Local Memory Size:       &quot;</span> &lt;&lt; perfStatsData-&gt;<a class="code" href="struct_g_l_s_l_cperf_stats_data.html#a9adc6910a33636f8688ad1231d0ad293">nonSpillLMem</a>.<a name="a51"></a><a class="code" href="struct_g_l_s_l_cnon_spill_l_mem.html#a76ddc6e0aedfd37e36aa7d7d5d96a909">size</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot; * Occupancy:                         &quot;</span> &lt;&lt; perfStatsData-&gt;<a name="a52"></a><a class="code" href="struct_g_l_s_l_cperf_stats_data.html#ad91e1581425b17e18ef6603d9f1fde22">occupancy</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot; * Number of Divergent Branches:      &quot;</span> &lt;&lt; perfStatsData-&gt;<a name="a53"></a><a class="code" href="struct_g_l_s_l_cperf_stats_data.html#ad66aa359d1cadbb6680fe56c8084c48b">numDivergentBranches</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot; * Attribute Memory Usage:            &quot;</span> &lt;&lt; perfStatsData-&gt;<a name="a54"></a><a class="code" href="struct_g_l_s_l_cperf_stats_data.html#a169e086f11fc356a04df91af96b31d08">attributeMemUsage</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot; * Program Size:                      &quot;</span> &lt;&lt; perfStatsData-&gt;<a name="a55"></a><a class="code" href="struct_g_l_s_l_cperf_stats_data.html#abe4198110a02135c0941513d8493017f">programSize</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot; * Issue Ltd Throughput:              &quot;</span> &lt;&lt; perfStatsData-&gt;<a name="a56"></a><a class="code" href="struct_g_l_s_l_cperf_stats_data.html#af787142790d854a42032ec6998ed5658">throughputLimiter</a>.<a name="a57"></a><a class="code" href="struct_g_l_s_l_cthroughput_limiter.html#a80471483a98d5aa2b56f3d091c6f66c3">issue</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot; * FP Ltd Throughput:                 &quot;</span> &lt;&lt; perfStatsData-&gt;<a class="code" href="struct_g_l_s_l_cperf_stats_data.html#af787142790d854a42032ec6998ed5658">throughputLimiter</a>.<a name="a58"></a><a class="code" href="struct_g_l_s_l_cthroughput_limiter.html#afe5545973adf22ed4001a0784348efda">fp</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot; * Half Ltd Throughput:               &quot;</span> &lt;&lt; perfStatsData-&gt;<a class="code" href="struct_g_l_s_l_cperf_stats_data.html#af787142790d854a42032ec6998ed5658">throughputLimiter</a>.<a name="a59"></a><a class="code" href="struct_g_l_s_l_cthroughput_limiter.html#a77999a2646e730fb536abb4263f9cd19">half</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot; * Trancedental Ltd Throughput:       &quot;</span> &lt;&lt; perfStatsData-&gt;<a class="code" href="struct_g_l_s_l_cperf_stats_data.html#af787142790d854a42032ec6998ed5658">throughputLimiter</a>.<a name="a60"></a><a class="code" href="struct_g_l_s_l_cthroughput_limiter.html#a53a2616c9cc95e2656c12cfa10266485">trancedental</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot; * IPA Ltd Throughput:                &quot;</span> &lt;&lt; perfStatsData-&gt;<a class="code" href="struct_g_l_s_l_cperf_stats_data.html#af787142790d854a42032ec6998ed5658">throughputLimiter</a>.<a name="a61"></a><a class="code" href="struct_g_l_s_l_cthroughput_limiter.html#a374b65adbd7ae380a465089bbbc29bab">ipa</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot; * Shared Ltd Throughput:             &quot;</span> &lt;&lt; perfStatsData-&gt;<a class="code" href="struct_g_l_s_l_cperf_stats_data.html#af787142790d854a42032ec6998ed5658">throughputLimiter</a>.<a name="a62"></a><a class="code" href="struct_g_l_s_l_cthroughput_limiter.html#aaa1a970a3f023d8b399e4323d0354276">shared</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot; * ControlFlow Ltd Throughput:        &quot;</span> &lt;&lt; perfStatsData-&gt;<a class="code" href="struct_g_l_s_l_cperf_stats_data.html#af787142790d854a42032ec6998ed5658">throughputLimiter</a>.<a name="a63"></a><a class="code" href="struct_g_l_s_l_cthroughput_limiter.html#a82a4ac305863d2195e79c945b8188d65">controlFlow</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot; * Texture/Load/Store Ltd Throughput: &quot;</span> &lt;&lt; perfStatsData-&gt;<a class="code" href="struct_g_l_s_l_cperf_stats_data.html#af787142790d854a42032ec6998ed5658">throughputLimiter</a>.<a name="a64"></a><a class="code" href="struct_g_l_s_l_cthroughput_limiter.html#a681850c900eb4aacb11bce98483831c7">texLoadStore</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot; * Reg Ltd Throughput:                &quot;</span> &lt;&lt; perfStatsData-&gt;<a class="code" href="struct_g_l_s_l_cperf_stats_data.html#af787142790d854a42032ec6998ed5658">throughputLimiter</a>.<a name="a65"></a><a class="code" href="struct_g_l_s_l_cthroughput_limiter.html#ab3d12b78f87486d981e166d317122466">reg</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot; * Warp Ltd Throughput:               &quot;</span> &lt;&lt; perfStatsData-&gt;<a class="code" href="struct_g_l_s_l_cperf_stats_data.html#af787142790d854a42032ec6998ed5658">throughputLimiter</a>.<a name="a66"></a><a class="code" href="struct_g_l_s_l_cthroughput_limiter.html#aedddd315e155a83318fc9a79723c15b2">warp</a> &lt;&lt; <span class="stringliteral">&quot;\n * \n&quot;</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot; */\n\n&quot;</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;#pragma once\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;#include &lt;cstdint&gt;\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;#include &lt;string&gt;\n\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;namespace &quot;</span> &lt;&lt; itr-&gt;first &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;{\n\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (itr-&gt;second.m_SpecializationParam.size() &gt; 0)</div>
<div class="line">        {</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;uint32_t GetVariationIndex(&quot;</span>;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; itr-&gt;second.m_SpecializationParam.size(); ++i)</div>
<div class="line">            {</div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot;const &quot;</span> &lt;&lt; itr-&gt;second.m_SpecializationParam[i].m_Type &lt;&lt; <span class="stringliteral">&quot;&amp; &quot;</span> &lt;&lt; itr-&gt;second.m_SpecializationParam[i].m_Name &lt;&lt; <span class="stringliteral">&quot;_&quot;</span>;</div>
<div class="line"> </div>
<div class="line">                <span class="keywordflow">if</span> (i + 1 &lt; itr-&gt;second.m_SpecializationParam.size())</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;);\n\n&quot;</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        std::vector&lt;UniformBlockData&gt; uniformBlocks;</div>
<div class="line">        std::vector&lt;UniformData&gt; uniforms;</div>
<div class="line">        std::vector&lt;VertexAttributeData&gt; vertexAttributes;</div>
<div class="line">        std::vector&lt;StorageBlockData&gt; ssboBlocks;</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> <a name="_a67"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html">GLSLCprogramReflectionHeader</a> * pReflectionHeader = itr-&gt;second.m_CompileObject.reflectionSection;</div>
<div class="line">        <span class="keyword">const</span> uint8_t* pReflectionData = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint8_t*<span class="keyword">&gt;</span>(pReflectionHeader) + pReflectionHeader-&gt;<a name="a68"></a>common.<a class="code" href="struct_g_l_s_l_csection_header_common.html#abb6e96b70bad30c94477317328d384d5">dataOffset</a>;</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* pStringPool = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(pReflectionData) + pReflectionHeader-&gt;<a name="a69"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#a23a3fcd75086c2b537f992e212661622">stringPoolOffset</a>;</div>
<div class="line"> </div>
<div class="line">           <span class="comment">/*</span></div>
<div class="line"><span class="comment">            * GLSLCuniformBlockInfo</span></div>
<div class="line"><span class="comment">            * ---------------------</span></div>
<div class="line"><span class="comment">            * This structures holds information about a uniform block in</span></div>
<div class="line"><span class="comment">            * the shader program.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * nameInfo           - Contains the length of the block&#39;s name</span></div>
<div class="line"><span class="comment">            *                      and the offset to the name in the reflection</span></div>
<div class="line"><span class="comment">            *                      header&#39;s string pool.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * size               - Size in bytes of the uniform block.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * numActiveVariables - Number of active variables defined in the block.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * stagesReferencedIn - Mask that represents what stages the block is</span></div>
<div class="line"><span class="comment">            *                      used in.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * bindings           - Per stage bindings for the uniform block. The</span></div>
<div class="line"><span class="comment">            *                      array index corresponds to the NVNshaderStage</span></div>
<div class="line"><span class="comment">            *                      that the binding is for. If the binding value</span></div>
<div class="line"><span class="comment">            *                      is -1, that means he block is not used in that</span></div>
<div class="line"><span class="comment">            *                      stage.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            */</span></div>
<div class="line">        <span class="keyword">const</span> <a name="_a70"></a><a class="code" href="struct_g_l_s_l_cuniform_block_info.html">GLSLCuniformBlockInfo</a> * uniformBlock = (<a class="code" href="struct_g_l_s_l_cuniform_block_info.html">GLSLCuniformBlockInfo</a> *)((<span class="keywordtype">char</span> *)pReflectionData + pReflectionHeader-&gt;<a name="a71"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#ab7239cf2349bda4632d8382ffddcde85">uniformBlockOffset</a>);</div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t j = 0; j &lt; pReflectionHeader-&gt;<a name="a72"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#a006944206bfbf2bbfb56c1dfb9dc7f96">numUniformBlocks</a>; ++j)</div>
<div class="line">        {</div>
<div class="line">            UniformBlockData uniformBlockData;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (uint32_t k = 0; k &lt; 6; ++k)</div>
<div class="line">                uniformBlockData.m_Bindings[k] = uniformBlock-&gt;<a name="a73"></a><a class="code" href="struct_g_l_s_l_cuniform_block_info.html#a3089f78f6431b069fca45643190b8f88">bindings</a>[k];</div>
<div class="line"> </div>
<div class="line">                <span class="comment">/*</span></div>
<div class="line"><span class="comment">                 * Get the correct variable name from</span></div>
<div class="line"><span class="comment">                 * the reflection data generated from SPIR-V binary</span></div>
<div class="line"><span class="comment">                 */</span></div>
<div class="line">            std::string name = pStringPool + uniformBlock-&gt;<a name="a74"></a><a class="code" href="struct_g_l_s_l_cuniform_block_info.html#af581f038ae9544eb77e43729691532a8">nameInfo</a>.<a name="a75"></a><a class="code" href="struct_g_l_s_l_cpiq_name.html#a95cb55a78c99bc13a5442a4ec038fe64">nameOffset</a>;</div>
<div class="line">            if (name.find_last_of(<span class="stringliteral">&quot;.&quot;</span>) != std::string::npos)</div>
<div class="line">            {</div>
<div class="line">                name = name.substr(name.find_last_of(<span class="stringliteral">&quot;.&quot;</span>) + 1, name.length());</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            uniformBlockData.m_Name = name;</div>
<div class="line">            uniformBlockData.m_Size = uniformBlock-&gt;<a name="a76"></a><a class="code" href="struct_g_l_s_l_cuniform_block_info.html#a995ad7b06ac8f754faceea20cb6b8443">size</a>;</div>
<div class="line">            uniformBlockData.m_NumActiveVariables = uniformBlock-&gt;<a name="a77"></a><a class="code" href="struct_g_l_s_l_cuniform_block_info.html#ae96efb0a5531abeb9b8baae6cc99f0ef">numActiveVariables</a>;</div>
<div class="line">            uniformBlockData.m_StagesReferencedIn = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(uniformBlock-&gt;<a name="a78"></a><a class="code" href="struct_g_l_s_l_cuniform_block_info.html#a449b0310144f865d20c9152228c1f5c2">stagesReferencedIn</a>);</div>
<div class="line"> </div>
<div class="line">            uniformBlocks.push_back(uniformBlockData);</div>
<div class="line"> </div>
<div class="line">            ++uniformBlock;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">           <span class="comment">/*</span></div>
<div class="line"><span class="comment">            * GLSLCuniformInfo</span></div>
<div class="line"><span class="comment">            * ---------------------</span></div>
<div class="line"><span class="comment">            * This structure holds information about individual</span></div>
<div class="line"><span class="comment">            * uniforms in the shader program. This includes uniforms</span></div>
<div class="line"><span class="comment">            * that are part of uniform blocks as well sampler/image</span></div>
<div class="line"><span class="comment">            * type uniforms.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * nameInfo           - Contains the length of the block&#39;s name</span></div>
<div class="line"><span class="comment">            *                      and the offset to the name in the reflection</span></div>
<div class="line"><span class="comment">            *                      header&#39;s string pool.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * type               - Data type of the uniform.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * blockNdx           - Index of the uniform in it&#39;s uniform block.</span></div>
<div class="line"><span class="comment">            *                      (-1 if not a part of a block)</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * blockOffset        - Byte offset into the uniform block.</span></div>
<div class="line"><span class="comment">            *                      (-1 if not a part of a block)</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * sizeOfArray        - Number of elements, if an array, 1 if not.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * arrayStride        - Stride between array elements.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * matrixStride       - Specifies stride between columns/rows of matrix</span></div>
<div class="line"><span class="comment">            *                      depending on isRowMajor.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * isRowMajor         - Specifies row major vs column major.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * stagesReferencedIn - Mask that represents what stages the block is</span></div>
<div class="line"><span class="comment">            *                      used in.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * bindings           - Per stage bindings for the uniform block. The</span></div>
<div class="line"><span class="comment">            *                      array index corresponds to the NVNshaderStage</span></div>
<div class="line"><span class="comment">            *                      that the binding is for. If the binding value</span></div>
<div class="line"><span class="comment">            *                      is -1, that means he block is not used in that</span></div>
<div class="line"><span class="comment">            *                      stage.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * kind               - Specifies between image, sampler, or normal uniform.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * isInUBO            - 1 if this uniform is in a uniform block, 0 otherwise.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * isArray            - 1 if this uniform is an array, 0 if otherwise.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            */</span></div>
<div class="line">        <a name="_a79"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html">GLSLCuniformInfo</a> * uniform = (<a class="code" href="struct_g_l_s_l_cuniform_info.html">GLSLCuniformInfo</a> *)((<span class="keywordtype">char</span> *)pReflectionData + pReflectionHeader-&gt;<a name="a80"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#a7116c27cf2638894a145fcdbb7d05568">uniformOffset</a>);</div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t j = 0; j &lt; pReflectionHeader-&gt;<a name="a81"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#a0bf19ae5c6027329eec9480f13c71d3c">numUniforms</a>; ++j)</div>
<div class="line">        {</div>
<div class="line">            UniformData uniformData;</div>
<div class="line"> </div>
<div class="line">                <span class="comment">/*</span></div>
<div class="line"><span class="comment">                 * Get the correct variable name from</span></div>
<div class="line"><span class="comment">                 * the reflection data generated from SPIR-V binary</span></div>
<div class="line"><span class="comment">                 */</span></div>
<div class="line">            std::string name = pStringPool + uniform-&gt;<a name="a82"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html#af3c2cf0a643a810defd8f1964ee5347c">nameInfo</a>.<a class="code" href="struct_g_l_s_l_cpiq_name.html#a95cb55a78c99bc13a5442a4ec038fe64">nameOffset</a>;</div>
<div class="line">            <span class="keywordflow">if</span> (name.find_last_of(<span class="stringliteral">&quot;.&quot;</span>) != std::string::npos)</div>
<div class="line">            {</div>
<div class="line">                name = name.substr(name.find_last_of(<span class="stringliteral">&quot;.&quot;</span>) + 1, name.length());</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            uniformData.m_Name = name;</div>
<div class="line">            uniformData.m_Type = uniform-&gt;<a name="a83"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html#aba31e5a44352d4b9e067ded0f87e8059">type</a>;</div>
<div class="line">            uniformData.m_BlockNdx = uniform-&gt;<a name="a84"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html#adc5be9a9b1526b2ec101a374f4d7fe1a">blockNdx</a>;</div>
<div class="line">            uniformData.m_BlockOffset = uniform-&gt;<a name="a85"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html#a2f72999cec8d93607ffc6c9488c8bd6e">blockOffset</a>;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (uint32_t k = 0; k &lt; 6; ++k)</div>
<div class="line">            {</div>
<div class="line">                uniformData.m_Bindings[k] = uniform-&gt;<a name="a86"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html#af5982205cf060f75098ac393b9d47536">bindings</a>[k];</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            uniformData.m_IsArray = uniform-&gt;<a name="a87"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html#a6b7862e3e1a42c7e95f6041b210c3124">isArray</a>;</div>
<div class="line">            uniformData.m_SizeOfArray = uniform-&gt;<a name="a88"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html#aaa27c23127bba5e365da8b927b344570">sizeOfArray</a>;</div>
<div class="line">            uniformData.m_ArrayStride = uniform-&gt;<a name="a89"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html#a0cbf82d02d29d69ca87d00d575a11d9d">arrayStride</a>;</div>
<div class="line">            uniformData.m_MatrixStride = uniform-&gt;<a name="a90"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html#a540f5953a7f10b489754374639222af5">matrixStride</a>;</div>
<div class="line">            uniformData.m_IsRowMajor = uniform-&gt;<a name="a91"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html#ade0fa25b5b9ead9c2101826d6b445f74">isRowMajor</a>;</div>
<div class="line">            uniformData.m_StagesReferencedIn = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(uniform-&gt;<a name="a92"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html#a062aec36dd8b1203f67b1a8bd12948ee">stagesReferencedIn</a>);</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (uniformData.m_BlockNdx != -1)</div>
<div class="line">            {</div>
<div class="line">                uniformBlocks[uniformData.m_BlockNdx].m_Uniforms.push_back(uniformData);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                uniforms.push_back(uniformData);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            ++uniform;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">           <span class="comment">/*</span></div>
<div class="line"><span class="comment">            * GLSLCprogramInputInfo</span></div>
<div class="line"><span class="comment">            * ---------------------</span></div>
<div class="line"><span class="comment">            * This structure holds information about attributes</span></div>
<div class="line"><span class="comment">            * used by the shader program.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * nameInfo           - Contains the length of the block&#39;s name</span></div>
<div class="line"><span class="comment">            *                      and the offset to the name in the reflection</span></div>
<div class="line"><span class="comment">            *                      header&#39;s string pool.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * type               - Data type of the uniform.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * sizeOfArray        - Number of elements, if an array, 1 if not.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * location           - Location this input is assigned to.</span></div>
<div class="line"><span class="comment">            *                      (-1 if not a vert/frag program)</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * stagesReferencedIn - Per stage bindings for the uniform block. The</span></div>
<div class="line"><span class="comment">            *                      array index corresponds to the NVNshaderStage</span></div>
<div class="line"><span class="comment">            *                      that the binding is for. If the binding value</span></div>
<div class="line"><span class="comment">            *                      is -1, that means he block is not used in that</span></div>
<div class="line"><span class="comment">            *                      stage.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * isArray            - 1 if this input is an array, 0 if otherwise.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * isPerPatch         - 1 if this input is per patch, 0 if otherwise.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            */</span></div>
<div class="line">        <a name="_a93"></a><a class="code" href="struct_g_l_s_l_cprogram_input_info.html">GLSLCprogramInputInfo</a> * programInput = (<a class="code" href="struct_g_l_s_l_cprogram_input_info.html">GLSLCprogramInputInfo</a> *)((<span class="keywordtype">char</span> *)pReflectionData + pReflectionHeader-&gt;<a name="a94"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#a9f264ef95c68193971b360b4df2f259d">programInputsOffset</a>);</div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t j = 0; j &lt; pReflectionHeader-&gt;<a name="a95"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#aca10eea8e482a030016556875aec0a7f">numProgramInputs</a>; ++j)</div>
<div class="line">        {</div>
<div class="line">            VertexAttributeData vertexAttributeData;</div>
<div class="line"> </div>
<div class="line">                <span class="comment">/*</span></div>
<div class="line"><span class="comment">                 * Get the correct variable name from</span></div>
<div class="line"><span class="comment">                 * the reflection data generated from SPIR-V binary</span></div>
<div class="line"><span class="comment">                 */</span></div>
<div class="line">            std::string name = pStringPool + programInput-&gt;<a name="a96"></a><a class="code" href="struct_g_l_s_l_cprogram_input_info.html#a30e2dc0f471667ac41cdde8329d71e25">nameInfo</a>.<a class="code" href="struct_g_l_s_l_cpiq_name.html#a95cb55a78c99bc13a5442a4ec038fe64">nameOffset</a>;</div>
<div class="line">            <span class="keywordflow">if</span> (name.find_last_of(<span class="stringliteral">&quot;.&quot;</span>) != std::string::npos)</div>
<div class="line">            {</div>
<div class="line">                name = name.substr(name.find_last_of(<span class="stringliteral">&quot;.&quot;</span>) + 1, name.length());</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            vertexAttributeData.m_Name = name;</div>
<div class="line">            vertexAttributeData.m_Type = programInput-&gt;<a name="a97"></a><a class="code" href="struct_g_l_s_l_cprogram_input_info.html#af409a6a5d837178521fd638d0e19140f">type</a>;</div>
<div class="line">            vertexAttributeData.m_IsArray = programInput-&gt;<a name="a98"></a><a class="code" href="struct_g_l_s_l_cprogram_input_info.html#af5f932dc8d34d953489986516b2aa632">isArray</a>;</div>
<div class="line">            vertexAttributeData.m_SizeOfArray = programInput-&gt;<a name="a99"></a><a class="code" href="struct_g_l_s_l_cprogram_input_info.html#ade21acdb8e7f5d6fb2023f96a0770e84">sizeOfArray</a>;</div>
<div class="line">            vertexAttributeData.m_Location = programInput-&gt;<a name="a100"></a><a class="code" href="struct_g_l_s_l_cprogram_input_info.html#ac0100c9580f95e97b101ae505680bef0">location</a>;</div>
<div class="line">            vertexAttributeData.m_IsPerPatch = programInput-&gt;<a name="a101"></a><a class="code" href="struct_g_l_s_l_cprogram_input_info.html#a0924d76ca260a63649cc6409a5084541">isPerPatch</a>;</div>
<div class="line">            vertexAttributeData.m_StagesReferencedIn = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(programInput-&gt;<a name="a102"></a><a class="code" href="struct_g_l_s_l_cprogram_input_info.html#aa850abcd72ca572b118cea86cc858af7">stagesReferencedIn</a>);</div>
<div class="line"> </div>
<div class="line">            vertexAttributes.push_back(vertexAttributeData);</div>
<div class="line"> </div>
<div class="line">            ++programInput;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">           <span class="comment">/*</span></div>
<div class="line"><span class="comment">            * GLSLCssboInfo</span></div>
<div class="line"><span class="comment">            * ---------------------</span></div>
<div class="line"><span class="comment">            * This structures holds information about a shader storage block in</span></div>
<div class="line"><span class="comment">            * the shader program.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * nameInfo           - Contains the length of the block&#39;s name</span></div>
<div class="line"><span class="comment">            *                      and the offset to the name in the reflection</span></div>
<div class="line"><span class="comment">            *                      header&#39;s string pool.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * size               - Size in bytes of the uniform block.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * numActiveVariables - Number of active variables defined in the block.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * stagesReferencedIn - Mask that represents what stages the block is</span></div>
<div class="line"><span class="comment">            *                      used in.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * bindings           - Per stage bindings for the shader storage block.</span></div>
<div class="line"><span class="comment">            The array index corresponds to the NVNshaderStage</span></div>
<div class="line"><span class="comment">            *                      that the binding is for. If the binding value</span></div>
<div class="line"><span class="comment">            *                      is -1, that means the block is not used in that</span></div>
<div class="line"><span class="comment">            *                      stage.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            */</span></div>
<div class="line">        <span class="keyword">const</span> <a name="_a103"></a><a class="code" href="struct_g_l_s_l_cssbo_info.html">GLSLCssboInfo</a> * ssboBlock = (<a class="code" href="struct_g_l_s_l_cssbo_info.html">GLSLCssboInfo</a> *)((<span class="keywordtype">char</span> *)pReflectionData + pReflectionHeader-&gt;<a name="a104"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#af58251371ee656b318f40dec153c4837">ssboOffset</a>);</div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t j = 0; j &lt; pReflectionHeader-&gt;<a name="a105"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#a68f8f5f1cb9eb0fa3039a28512f8cdda">numSsbo</a>; ++j)</div>
<div class="line">        {</div>
<div class="line">            StorageBlockData ssboBlockData;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (uint32_t k = 0; k &lt; 6; ++k)</div>
<div class="line">            {</div>
<div class="line">                ssboBlockData.m_Bindings[k] = ssboBlock-&gt;<a name="a106"></a><a class="code" href="struct_g_l_s_l_cssbo_info.html#ad1d55cda38a2560e420a630e50a74897">bindings</a>[k];</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">                <span class="comment">/*</span></div>
<div class="line"><span class="comment">                 * Get the correct variable name from</span></div>
<div class="line"><span class="comment">                 * the reflection data generated from SPIR-V binary</span></div>
<div class="line"><span class="comment">                 */</span></div>
<div class="line">            std::string name = pStringPool + ssboBlock-&gt;<a name="a107"></a><a class="code" href="struct_g_l_s_l_cssbo_info.html#aa6932c7eacfab053588e669f5982c1f0">nameInfo</a>.<a class="code" href="struct_g_l_s_l_cpiq_name.html#a95cb55a78c99bc13a5442a4ec038fe64">nameOffset</a>;</div>
<div class="line">            <span class="keywordflow">if</span> (name.find_last_of(<span class="stringliteral">&quot;.&quot;</span>) != std::string::npos)</div>
<div class="line">            {</div>
<div class="line">                name = name.substr(name.find_last_of(<span class="stringliteral">&quot;.&quot;</span>) + 1, name.length());</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            ssboBlockData.m_Name = name;</div>
<div class="line">            ssboBlockData.m_Size = ssboBlock-&gt;<a name="a108"></a><a class="code" href="struct_g_l_s_l_cssbo_info.html#a3f326bfbaa4cd4e3fe1dbc2930e04109">size</a>;</div>
<div class="line">            ssboBlockData.m_NumActiveVariables = ssboBlock-&gt;<a name="a109"></a><a class="code" href="struct_g_l_s_l_cssbo_info.html#a5395331b65a710af72231721f0d5b6ee">numActiveVariables</a>;</div>
<div class="line">            ssboBlockData.m_StagesReferencedIn = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(ssboBlock-&gt;<a name="a110"></a><a class="code" href="struct_g_l_s_l_cssbo_info.html#a711a0e9191f46d742ad5bac2fe34106b">stagesReferencedIn</a>);</div>
<div class="line"> </div>
<div class="line">            ssboBlocks.push_back(ssboBlockData);</div>
<div class="line"> </div>
<div class="line">            ++ssboBlock;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">           <span class="comment">/*</span></div>
<div class="line"><span class="comment">            * GLSLCbufferVariableInfo</span></div>
<div class="line"><span class="comment">            * ---------------------</span></div>
<div class="line"><span class="comment">            * This structure holds information about variables that</span></div>
<div class="line"><span class="comment">            * are part of the given SSBO.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * nameInfo           - Contains the length of the variable&#39;s name</span></div>
<div class="line"><span class="comment">            *                      and the offset to the name in the reflection</span></div>
<div class="line"><span class="comment">            *                      header&#39;s string pool.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * type               - Data type of the variable.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * blockNdx           - Index of the corresponding.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * blockOffset        - Byte offset into the owning buffer.</span></div>
<div class="line"><span class="comment">            *                      (-1 if not a part of a block)</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * sizeOfArray        - Number of elements, if an array, 1 if not.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * arrayStride        - Stride between array elements.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * matrixStride       - Specifies stride between columns/rows of matrix</span></div>
<div class="line"><span class="comment">            *                      depending on isRowMajor.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * isRowMajor         - Specifies row major vs column major.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * stagesReferencedIn - Mask that represents what stages the block is</span></div>
<div class="line"><span class="comment">            *                      used in.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * isArray            - 1 if this variable is an array, 0 if otherwise.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * topLevelArraySize    number of active elements of the top-level</span></div>
<div class="line"><span class="comment">            *                      storage block member containing this variable.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            * topLevelArrayStride  stride between elements of the top-level storage</span></div>
<div class="line"><span class="comment">            *                      block member containing this active variable.</span></div>
<div class="line"><span class="comment">            *</span></div>
<div class="line"><span class="comment">            */</span></div>
<div class="line">        <a name="_a111"></a><a class="code" href="struct_g_l_s_l_cbuffer_variable_info.html">GLSLCbufferVariableInfo</a> * bufferVariable = (<a class="code" href="struct_g_l_s_l_cbuffer_variable_info.html">GLSLCbufferVariableInfo</a> *)((<span class="keywordtype">char</span> *)pReflectionData + pReflectionHeader-&gt;<a name="a112"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#a89cea5a299e8cf987babd8e2a93994f2">bufferVariableOffset</a>);</div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t j = 0; j &lt; pReflectionHeader-&gt;<a name="a113"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#a2eb867701544eef24f9bece544e729de">numBufferVariables</a>; ++j)</div>
<div class="line">        {</div>
<div class="line">            BufferVariableData bufferVariableData;</div>
<div class="line"> </div>
<div class="line">                <span class="comment">/*</span></div>
<div class="line"><span class="comment">                 * Get the correct variable name from</span></div>
<div class="line"><span class="comment">                 * the reflection data generated from SPIR-V binary</span></div>
<div class="line"><span class="comment">                 */</span></div>
<div class="line">            std::string name = pStringPool + bufferVariable-&gt;<a name="a114"></a><a class="code" href="struct_g_l_s_l_cbuffer_variable_info.html#a6abfac65135a571801c732499a96be1b">nameInfo</a>.<a class="code" href="struct_g_l_s_l_cpiq_name.html#a95cb55a78c99bc13a5442a4ec038fe64">nameOffset</a>;</div>
<div class="line">            <span class="keywordflow">if</span> (name.find_first_of(<span class="stringliteral">&quot;.&quot;</span>) != name.find_last_of(<span class="stringliteral">&quot;.&quot;</span>))</div>
<div class="line">            {</div>
<div class="line">                name = name.substr(name.find_last_of(<span class="stringliteral">&quot;.&quot;</span>) + 1, name.length());</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            bufferVariableData.m_Name = name;</div>
<div class="line">            bufferVariableData.m_Type = bufferVariable-&gt;<a name="a115"></a><a class="code" href="struct_g_l_s_l_cbuffer_variable_info.html#aaa3b140607700cf5a743a861df990efb">type</a>;</div>
<div class="line">            bufferVariableData.m_BlockNdx = bufferVariable-&gt;<a name="a116"></a><a class="code" href="struct_g_l_s_l_cbuffer_variable_info.html#a521155bc7f5002ccee977558beb61be1">blockNdx</a>;</div>
<div class="line">            bufferVariableData.m_BlockOffset = bufferVariable-&gt;<a name="a117"></a><a class="code" href="struct_g_l_s_l_cbuffer_variable_info.html#a24d15b6ca8a2cea8730efe490dd1acfc">blockOffset</a>;</div>
<div class="line">            bufferVariableData.m_IsArray = bufferVariable-&gt;<a name="a118"></a><a class="code" href="struct_g_l_s_l_cbuffer_variable_info.html#a16f5c0e7959077c3ce319414cfec1de0">isArray</a>;</div>
<div class="line">            bufferVariableData.m_SizeOfArray = bufferVariable-&gt;<a name="a119"></a><a class="code" href="struct_g_l_s_l_cbuffer_variable_info.html#a6a6529d21d70fd27bbe6a2ccb73ed1bd">sizeOfArray</a>;</div>
<div class="line">            bufferVariableData.m_ArrayStride = bufferVariable-&gt;<a name="a120"></a>arrayStride;</div>
<div class="line">            bufferVariableData.m_MatrixStride = bufferVariable-&gt;<a name="a121"></a><a class="code" href="struct_g_l_s_l_cbuffer_variable_info.html#a0d22663f76277236ff4fb5177be6ecab">matrixStride</a>;</div>
<div class="line">            bufferVariableData.m_IsRowMajor = bufferVariable-&gt;<a name="a122"></a><a class="code" href="struct_g_l_s_l_cbuffer_variable_info.html#a8f47eb13e0c6661f56ce44f048f8ad2e">isRowMajor</a>;</div>
<div class="line">            bufferVariableData.m_StagesReferencedIn = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(bufferVariable-&gt;<a name="a123"></a><a class="code" href="struct_g_l_s_l_cbuffer_variable_info.html#a3433d01de972916c358960ad5fcec9c5">stagesReferencedIn</a>);</div>
<div class="line">            bufferVariableData.m_TopLevelArraySize = bufferVariable-&gt;<a name="a124"></a><a class="code" href="struct_g_l_s_l_cbuffer_variable_info.html#a466ccaee49d1413ec7f7184f7d2a85d6">topLevelArraySize</a>;</div>
<div class="line">            bufferVariableData.m_TopLevelArrayStride = bufferVariable-&gt;<a name="a125"></a><a class="code" href="struct_g_l_s_l_cbuffer_variable_info.html#a08300b2a95c6ac18e67859870d4e9f5e">topLevelArrayStride</a>;</div>
<div class="line"> </div>
<div class="line">            ssboBlocks[bufferVariableData.m_BlockNdx].m_BufferVariables.push_back(bufferVariableData);</div>
<div class="line"> </div>
<div class="line">            ++bufferVariable;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;    // Holds a list of attribute data and provides binding information for each attribute\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;class Attributes\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;{\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;    public:\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            // Holds information describing a given attribute\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            // Data fields are filled with data from the GLSLC compile output\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        struct AttributeData\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        {\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            AttributeData(const std::string&amp; name = \&quot;\&quot;,\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;                          int32_t location = -1,\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;                          uint8_t stagesReferencedIn = 0) : m_Name(name),\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;                                                            m_Location(location),\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;                                                            m_StagesReferencedIn(stagesReferencedIn)\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            {\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            }\n\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            std::string m_Name;              // Name of the attribute in the shader\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            int32_t m_Location;              // Binding location\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            uint8_t m_StagesReferencedIn;    // Bit flag of stages that the attribute is referenced in, of type NVNshaderStageBits\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        };\n\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            // Get the binding location for the attribute with the given name\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        static int32_t GetAttributeLocation(const std::string&amp; name)\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        {\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            for(uint32_t i = 0; i &lt; m_NumAttributes; ++i)\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            {\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;                if(m_Attributes[i].m_Name == name)\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;                    return m_Attributes[i].m_Location;\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            }\n\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            return -1;\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        }\n\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            // Get the number of vertex attributes in the shader program\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        static uint32_t GetNumAttributes()\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        {\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            return m_NumAttributes;\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        }\n\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            // Get the stages the attribute is referenced in\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        static uint8_t GetStagesReferencedIn(const std::string&amp; name)\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        {\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            for(uint32_t i = 0; i &lt; m_NumAttributes; ++i)\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            {\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;                if(m_Attributes[i].m_Name == name)\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;                    return m_Attributes[i].m_StagesReferencedIn;\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            }\n\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            return 0;\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        }\n\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        static const AttributeData* GetAttributeList()\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        {\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            return m_Attributes;\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        }\n\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;    private:\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        const static uint32_t m_NumAttributes = &quot;</span> &lt;&lt; vertexAttributes.size() &lt;&lt; <span class="stringliteral">&quot;;     // Total number of attributes\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        const static AttributeData m_Attributes[&quot;</span> &lt;&lt; vertexAttributes.size() &lt;&lt; <span class="stringliteral">&quot;];    // Static array of attribute data \n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;};\n\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; uniforms.size(); ++i)</div>
<div class="line">        {</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;    // Helper class for the &quot;</span> &lt;&lt; uniforms[i].m_Name &lt;&lt; <span class="stringliteral">&quot;uniform\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;class &quot;</span> &lt;&lt; uniforms[i].m_Name &lt;&lt; <span class="stringliteral">&quot;UniformData\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;{\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;    public:\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;            // Get the binding location for the uniform\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;            // shaderStage is of type NVNshaderStage\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        static uint32_t GetBinding(uint32_t shaderStage)\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        {\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;            return m_Bindings[shaderStage];\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        }\n\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;            // Get the stages the uniform is referenced in\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        static uint8_t GetStagesReferencedIn()\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        {\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;            return m_StagesReferencedIn;\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        }\n\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;    private:\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;            // Binding locations for the uniform\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        static const int32_t m_Bindings[6];\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        static const uint8_t m_StagesReferencedIn = &quot;</span> &lt;&lt; <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(uniforms[i].m_StagesReferencedIn) &lt;&lt; <span class="stringliteral">&quot;;    // Stages that the uniform is referenced in, of type NVNshaderStageBits\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;};\n\n&quot;</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; uniformBlocks.size(); ++i)</div>
<div class="line">        {</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;    // Helper class for the &quot;</span> &lt;&lt; uniformBlocks[i].m_Name &lt;&lt; <span class="stringliteral">&quot; uniform block\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;class &quot;</span> &lt;&lt; uniformBlocks[i].m_Name &lt;&lt; <span class="stringliteral">&quot;UniformBlockData\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;{\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;    public:\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (uint32_t j = 0; j &lt; uniformBlocks[i].m_Uniforms.size(); ++j)</div>
<div class="line">            {</div>
<div class="line">                <span class="keyword">const</span> UniformData&amp; uniformData = uniformBlocks[i].m_Uniforms[j];</div>
<div class="line"> </div>
<div class="line">                <span class="keywordflow">if</span> (uniformData.m_IsArray == 0)</div>
<div class="line">                {</div>
<div class="line">                    std::string typeName = GetReferenceTypeName(uniformData.m_Type, <span class="stringliteral">&quot;uniformData&quot;</span>);</div>
<div class="line"> </div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot;            // Sets the data at the appropriate offset for the uniform block member: &quot;</span> &lt;&lt; uniformData.m_Name &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot;        void SetUniform_&quot;</span> &lt;&lt; uniformData.m_Name &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; typeName &lt;&lt; <span class="stringliteral">&quot;)\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot;        {\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot;            memcpy(&amp;m_BlockData[&quot;</span> &lt;&lt; uniformData.m_BlockOffset &lt;&lt; <span class="stringliteral">&quot;], &amp;uniformData, sizeof(uniformData));\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot;        }\n\n&quot;</span>;</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">else</span></div>
<div class="line">                {</div>
<div class="line">                    std::string uniformName = uniformData.m_Name.substr(0, uniformData.m_Name.size() - 3);</div>
<div class="line"> </div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot;            // Sets the data at the appropriate offset for the uniform block member: &quot;</span> &lt;&lt; uniformName &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot;        void SetUniform_&quot;</span> &lt;&lt; uniformName &lt;&lt; <span class="stringliteral">&quot;(const void* data, size_t size)\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot;        {\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot;            memcpy(&amp;m_BlockData[&quot;</span> &lt;&lt; uniformData.m_BlockOffset &lt;&lt; <span class="stringliteral">&quot;], data, size);\n&quot;</span>;</div>
<div class="line">                    file &lt;&lt; <span class="stringliteral">&quot;        }\n\n&quot;</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;            // Get the binding location for the uniform block\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;            // shaderStage is of type NVNshaderStage\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        static uint32_t GetBinding(uint32_t shaderStage)\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        {\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;            return m_Bindings[shaderStage];\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        }\n\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;            // Get the stages the uniform block is referenced in\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        static uint8_t GetStagesReferencedIn()\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        {\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;            return m_StagesReferencedIn;\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        }\n\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;    private:\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        char m_BlockData[&quot;</span> &lt;&lt; uniformBlocks[i].m_Size &lt;&lt; <span class="stringliteral">&quot;];    // Block of data representing the uniform block\n\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;            // Binding location of the uniform block\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        static const int32_t m_Bindings[6];\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        static const uint8_t m_StagesReferencedIn = &quot;</span> &lt;&lt; <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(uniformBlocks[i].m_StagesReferencedIn) &lt;&lt; <span class="stringliteral">&quot;;    // Bit flag of stages that the attribute is referenced in, of type NVNshaderStageBits\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;};\n\n&quot;</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; ssboBlocks.size(); ++i)</div>
<div class="line">        {</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;    // Helper class for the &quot;</span> &lt;&lt; ssboBlocks[i].m_Name &lt;&lt; <span class="stringliteral">&quot; shader storage block\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;class &quot;</span> &lt;&lt; ssboBlocks[i].m_Name &lt;&lt; <span class="stringliteral">&quot;StorageBlockData\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;{\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;    public:\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">            {</div>
<div class="line">                std::string structVariableName;</div>
<div class="line">                int32_t structOffset = -1;</div>
<div class="line">                <span class="keywordtype">bool</span> isArrayOfStructs = <span class="keyword">false</span>;</div>
<div class="line">                <span class="keywordflow">for</span> (uint32_t j = 0; j &lt; ssboBlocks[i].m_BufferVariables.size(); ++j)</div>
<div class="line">                {</div>
<div class="line">                    <span class="keyword">const</span> BufferVariableData&amp; bufferVariableData = ssboBlocks[i].m_BufferVariables[j];</div>
<div class="line"> </div>
<div class="line">                       <span class="comment">/*</span></div>
<div class="line"><span class="comment">                        * Structure variables&#39; reflection data looks like this:</span></div>
<div class="line"><span class="comment">                        * &lt;struct_name&gt;.&lt;member_name&gt;. We are using the struct name to copy</span></div>
<div class="line"><span class="comment">                        * the whole block not just the individual members.</span></div>
<div class="line"><span class="comment">                        */</span></div>
<div class="line">                    <span class="keywordflow">if</span> (bufferVariableData.m_Name.find_first_of(<span class="charliteral">&#39;.&#39;</span>) != std::string::npos)</div>
<div class="line">                    {</div>
<div class="line">                            <span class="comment">/* Store the struct name and the first offset on the list. */</span></div>
<div class="line">                        <span class="keywordflow">if</span> (structOffset == -1 &amp;&amp; structVariableName == <span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line">                        {</div>
<div class="line">                            structVariableName = bufferVariableData.m_Name.substr(0, bufferVariableData.m_Name.find_first_of(<span class="charliteral">&#39;.&#39;</span>));</div>
<div class="line">                            structOffset = bufferVariableData.m_BlockOffset;</div>
<div class="line">                            isArrayOfStructs = bufferVariableData.m_TopLevelArrayStride &gt; 0;</div>
<div class="line">                        }</div>
<div class="line"> </div>
<div class="line">                            <span class="comment">/* Find the lowset offest in the block. This is the offset of the whole struct. */</span></div>
<div class="line">                        structOffset = std::min(structOffset, bufferVariableData.m_BlockOffset);</div>
<div class="line"> </div>
<div class="line">                            <span class="comment">/* Get the name of the next variable in the block if there is one */</span></div>
<div class="line">                        std::string structVariableNameNext;</div>
<div class="line">                        <span class="keywordflow">if</span> (j + 1 &lt; ssboBlocks[i].m_BufferVariables.size())</div>
<div class="line">                        {</div>
<div class="line">                            <span class="keyword">const</span> BufferVariableData&amp; bufferVariableDataNext = ssboBlocks[i].m_BufferVariables[j + 1];</div>
<div class="line">                            structVariableNameNext = bufferVariableDataNext.m_Name.substr(0, bufferVariableDataNext.m_Name.find_first_of(<span class="charliteral">&#39;.&#39;</span>));</div>
<div class="line">                        }</div>
<div class="line"> </div>
<div class="line">                            <span class="comment">/* If next variable name is different or this is the last element in the block. */</span></div>
<div class="line">                        <span class="keywordflow">if</span> (j == ssboBlocks[i].m_BufferVariables.size() - 1 || structVariableName != structVariableNameNext)</div>
<div class="line">                        {</div>
<div class="line">                            <span class="keywordflow">if</span> (isArrayOfStructs)</div>
<div class="line">                                structVariableName = structVariableName.substr(0, structVariableName.size() - 3);</div>
<div class="line"> </div>
<div class="line">                            file &lt;&lt; <span class="stringliteral">&quot;            // Sets the data at the appropriate offset for the buffer variable: &quot;</span> &lt;&lt; structVariableName &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                            file &lt;&lt; <span class="stringliteral">&quot;        void SetBufferVariable_&quot;</span> &lt;&lt; structVariableName &lt;&lt; <span class="stringliteral">&quot;(const void* data, size_t size)\n&quot;</span>;</div>
<div class="line">                            file &lt;&lt; <span class="stringliteral">&quot;        {\n&quot;</span>;</div>
<div class="line">                            file &lt;&lt; <span class="stringliteral">&quot;            memcpy(&amp;m_BlockData[&quot;</span> &lt;&lt; structOffset &lt;&lt; <span class="stringliteral">&quot;], data, size);\n&quot;</span>;</div>
<div class="line">                            file &lt;&lt; <span class="stringliteral">&quot;        }\n\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">                            structOffset = -1;</div>
<div class="line">                            structVariableName.clear();</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bufferVariableData.m_IsArray == 0)</div>
<div class="line">                    {</div>
<div class="line">                        std::string typeName = GetReferenceTypeName(bufferVariableData.m_Type, <span class="stringliteral">&quot;bufferVariableData&quot;</span>);</div>
<div class="line"> </div>
<div class="line">                        file &lt;&lt; <span class="stringliteral">&quot;            // Sets the data at the appropriate offset for the buffer variable: &quot;</span> &lt;&lt; bufferVariableData.m_Name &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                        file &lt;&lt; <span class="stringliteral">&quot;        void SetBufferVariable_&quot;</span> &lt;&lt; bufferVariableData.m_Name &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; typeName &lt;&lt; <span class="stringliteral">&quot;)\n&quot;</span>;</div>
<div class="line">                        file &lt;&lt; <span class="stringliteral">&quot;        {\n&quot;</span>;</div>
<div class="line">                        file &lt;&lt; <span class="stringliteral">&quot;            memcpy(&amp;m_BlockData[&quot;</span> &lt;&lt; bufferVariableData.m_BlockOffset &lt;&lt; <span class="stringliteral">&quot;], &amp;bufferVariableData, sizeof(bufferVariableData));\n&quot;</span>;</div>
<div class="line">                        file &lt;&lt; <span class="stringliteral">&quot;        }\n\n&quot;</span>;</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bufferVariableData.m_IsArray == 1)</div>
<div class="line">                    {</div>
<div class="line">                        std::string variableName = bufferVariableData.m_Name.substr(0, bufferVariableData.m_Name.size() - 3);</div>
<div class="line"> </div>
<div class="line">                        file &lt;&lt; <span class="stringliteral">&quot;            // Sets the data at the appropriate offset for the buffer variable: &quot;</span> &lt;&lt; variableName &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                        file &lt;&lt; <span class="stringliteral">&quot;        void SetBufferVariable_&quot;</span> &lt;&lt; variableName &lt;&lt; <span class="stringliteral">&quot;(const void* data, size_t size)\n&quot;</span>;</div>
<div class="line">                        file &lt;&lt; <span class="stringliteral">&quot;        {\n&quot;</span>;</div>
<div class="line">                        file &lt;&lt; <span class="stringliteral">&quot;            memcpy(&amp;m_BlockData[&quot;</span> &lt;&lt; bufferVariableData.m_BlockOffset &lt;&lt; <span class="stringliteral">&quot;], data, size);\n&quot;</span>;</div>
<div class="line">                        file &lt;&lt; <span class="stringliteral">&quot;        }\n\n&quot;</span>;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;            // Get the binding location for the shader storage block\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;            // shaderStage is of type NVNshaderStage\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        static uint32_t GetBinding(uint32_t shaderStage)\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        {\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;            return m_Bindings[shaderStage];\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        }\n\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;            // Get the stages the shader storage is referenced in\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        static uint8_t GetStagesReferencedIn()\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        {\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;            return m_StagesReferencedIn;\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        }\n\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;    private:\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        char m_BlockData[&quot;</span> &lt;&lt; ssboBlocks[i].m_Size &lt;&lt; <span class="stringliteral">&quot;];    // Block of data representing the shader storage\n\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;            // Binding location of the shader storage\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        static const int32_t m_Bindings[6];\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        static const uint8_t m_StagesReferencedIn = &quot;</span> &lt;&lt; <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(ssboBlocks[i].m_StagesReferencedIn) &lt;&lt; <span class="stringliteral">&quot;;    // Bit flag of stages that the attribute is referenced in, of type NVNshaderStageBits\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;};\n\n&quot;</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;}\n\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Source file for static member initilization</span></div>
<div class="line">        std::ofstream sourceFile;</div>
<div class="line">        sourceFile.open(path + (itr-&gt;first + <span class="stringliteral">&quot;DataHelper.cpp&quot;</span>), std::fstream::out);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (!sourceFile.is_open())</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to create output source file for &quot;</span> &lt;&lt; itr-&gt;first &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;    &quot;</span> &lt;&lt; path &lt;&lt; itr-&gt;first &lt;&lt; <span class="stringliteral">&quot;DataHelper.cpp\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot;/*--------------------------------------------------------------------------------*\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot;Copyright (C)Nintendo All rights reserved.\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot;These coded instructions, statements, and computer programs contain proprietary\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot;information of Nintendo and/or its licensed developers and are protected by\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot;national and international copyright laws. They may not be disclosed to third\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot;parties or copied or duplicated in any form, in whole or in part, without the\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot;prior written consent of Nintendo.\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot;The content herein is highly confidential and should be handled accordingly.\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot;*--------------------------------------------------------------------------------*/\n\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot;/*\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot; * &quot;</span> &lt;&lt; itr-&gt;first &lt;&lt; <span class="stringliteral">&quot;DataHelper.cpp\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot; * -------------------------------------------------\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot; * This is a generated file from GLSLC shader\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot; * compile reflection information. Do not edit.\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot; * -------------------------------------------------\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot; */\n\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot;#include \&quot;&quot;</span> &lt;&lt; itr-&gt;first &lt;&lt; <span class="stringliteral">&quot;DataHelper.h\&quot;\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (itr-&gt;second.m_SpecializationParam.size() &gt; 0)</div>
<div class="line">        {</div>
<div class="line">            sourceFile &lt;&lt; <span class="stringliteral">&quot;#include &lt;nn/nn_Assert.h&gt;\n\n&quot;</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            sourceFile &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot;    // The AttributeData array is filled with values from the GLSLC shader compile output\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot;const &quot;</span> &lt;&lt; itr-&gt;first &lt;&lt; <span class="stringliteral">&quot;::Attributes::AttributeData &quot;</span> &lt;&lt; itr-&gt;first &lt;&lt; <span class="stringliteral">&quot;::Attributes::m_Attributes[&quot;</span> &lt;&lt; vertexAttributes.size() &lt;&lt; <span class="stringliteral">&quot;] = { &quot;</span>;</div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; vertexAttributes.size(); ++i)</div>
<div class="line">        {</div>
<div class="line">            sourceFile &lt;&lt; itr-&gt;first &lt;&lt; <span class="stringliteral">&quot;::Attributes::AttributeData(\&quot;&quot;</span> &lt;&lt; vertexAttributes[i].m_Name &lt;&lt; <span class="stringliteral">&quot;\&quot;, &quot;</span> &lt;&lt; vertexAttributes[i].m_Location &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(vertexAttributes[i].m_StagesReferencedIn) &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (i + 1 &lt; vertexAttributes.size())</div>
<div class="line">            {</div>
<div class="line">                sourceFile &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot; };\n\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; uniformBlocks.size(); ++i)</div>
<div class="line">        {</div>
<div class="line">            sourceFile &lt;&lt; <span class="stringliteral">&quot;const int32_t &quot;</span> &lt;&lt; itr-&gt;first &lt;&lt; <span class="stringliteral">&quot;::&quot;</span> &lt;&lt; uniformBlocks[i].m_Name &lt;&lt; <span class="stringliteral">&quot;UniformBlockData::m_Bindings[6] = { &quot;</span> &lt;&lt; uniformBlocks[i].m_Bindings[0];</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (uint32_t j = 1; j &lt; 6; ++j)</div>
<div class="line">            {</div>
<div class="line">                sourceFile &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; uniformBlocks[i].m_Bindings[j];</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            sourceFile &lt;&lt; <span class="stringliteral">&quot; };\n\n&quot;</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; uniforms.size(); ++i)</div>
<div class="line">        {</div>
<div class="line">            sourceFile &lt;&lt; <span class="stringliteral">&quot;const int32_t &quot;</span> &lt;&lt; itr-&gt;first &lt;&lt; <span class="stringliteral">&quot;::&quot;</span> &lt;&lt; uniforms[i].m_Name &lt;&lt; <span class="stringliteral">&quot;UniformData::m_Bindings[6] = { &quot;</span> &lt;&lt; uniforms[i].m_Bindings[0];</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (uint32_t j = 1; j &lt; 6; ++j)</div>
<div class="line">            {</div>
<div class="line">                sourceFile &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; uniforms[i].m_Bindings[j];</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            sourceFile &lt;&lt; <span class="stringliteral">&quot; };\n\n&quot;</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; ssboBlocks.size(); ++i)</div>
<div class="line">        {</div>
<div class="line">            sourceFile &lt;&lt; <span class="stringliteral">&quot;const int32_t &quot;</span> &lt;&lt; itr-&gt;first &lt;&lt; <span class="stringliteral">&quot;::&quot;</span> &lt;&lt; ssboBlocks[i].m_Name &lt;&lt; <span class="stringliteral">&quot;StorageBlockData::m_Bindings[6] = { &quot;</span> &lt;&lt; ssboBlocks[i].m_Bindings[0];</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (uint32_t j = 1; j &lt; 6; ++j)</div>
<div class="line">            {</div>
<div class="line">                sourceFile &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; ssboBlocks[i].m_Bindings[j];</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            sourceFile &lt;&lt; <span class="stringliteral">&quot; };\n\n&quot;</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (itr-&gt;second.m_SpecializationParam.size() &gt; 0)</div>
<div class="line">        {</div>
<div class="line">            sourceFile &lt;&lt; <span class="stringliteral">&quot;uint32_t &quot;</span> &lt;&lt; itr-&gt;first &lt;&lt; <span class="stringliteral">&quot;::GetVariationIndex(&quot;</span>;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; itr-&gt;second.m_SpecializationParam.size(); ++i)</div>
<div class="line">            {</div>
<div class="line">                sourceFile &lt;&lt; <span class="stringliteral">&quot;const &quot;</span> &lt;&lt; itr-&gt;second.m_SpecializationParam[i].m_Type &lt;&lt; <span class="stringliteral">&quot;&amp; &quot;</span> &lt;&lt; itr-&gt;second.m_SpecializationParam[i].m_Name &lt;&lt; <span class="stringliteral">&quot;_&quot;</span>;</div>
<div class="line"> </div>
<div class="line">                <span class="keywordflow">if</span> (i + 1 &lt; itr-&gt;second.m_SpecializationParam.size())</div>
<div class="line">                    sourceFile &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            sourceFile &lt;&lt; <span class="stringliteral">&quot;)\n&quot;</span>;</div>
<div class="line">            sourceFile &lt;&lt; <span class="stringliteral">&quot;{\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; itr-&gt;second.m_SpecializationParam.size(); ++i)</div>
<div class="line">            {</div>
<div class="line">                sourceFile &lt;&lt; <span class="stringliteral">&quot;    &quot;</span> &lt;&lt; itr-&gt;second.m_SpecializationParam[i].m_Type &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">                    &lt;&lt; itr-&gt;second.m_SpecializationParam[i].m_Name &lt;&lt; <span class="stringliteral">&quot;Values[&quot;</span></div>
<div class="line">                    &lt;&lt; itr-&gt;second.m_SpecializationParam[i].m_NumElements &lt;&lt; <span class="stringliteral">&quot;] = {&quot;</span>;</div>
<div class="line"> </div>
<div class="line">                <span class="keywordflow">for</span> (uint32_t j = 0; j &lt; itr-&gt;second.m_SpecializationParam[i].m_NumElements; ++j)</div>
<div class="line">                {</div>
<div class="line">                    <span class="keywordflow">if</span> (itr-&gt;second.m_SpecializationParam[i].m_Type == <span class="stringliteral">&quot;float&quot;</span>)</div>
<div class="line">                    {</div>
<div class="line">                        sourceFile &lt;&lt; ((<span class="keywordtype">float</span>*)itr-&gt;second.m_SpecializationParam[i].m_pData)[j];</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (itr-&gt;second.m_SpecializationParam[i].m_Type == <span class="stringliteral">&quot;int32_t&quot;</span>)</div>
<div class="line">                    {</div>
<div class="line">                        sourceFile &lt;&lt; ((int32_t*)itr-&gt;second.m_SpecializationParam[i].m_pData)[j];</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (itr-&gt;second.m_SpecializationParam[i].m_Type == <span class="stringliteral">&quot;uint32_t&quot;</span>)</div>
<div class="line">                    {</div>
<div class="line">                        sourceFile &lt;&lt; ((uint32_t*)itr-&gt;second.m_SpecializationParam[i].m_pData)[j];</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (itr-&gt;second.m_SpecializationParam[i].m_Type == <span class="stringliteral">&quot;short&quot;</span>)</div>
<div class="line">                    {</div>
<div class="line">                        sourceFile &lt;&lt; ((<span class="keywordtype">short</span>*)itr-&gt;second.m_SpecializationParam[i].m_pData)[j];</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (itr-&gt;second.m_SpecializationParam[i].m_Type == <span class="stringliteral">&quot;char&quot;</span>)</div>
<div class="line">                    {</div>
<div class="line">                        sourceFile &lt;&lt; ((<span class="keywordtype">char</span>*)itr-&gt;second.m_SpecializationParam[i].m_pData)[j];</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">else</span></div>
<div class="line">                    {</div>
<div class="line">                        assert(0 &amp;&amp; <span class="stringliteral">&quot;Unknown specialization type\n&quot;</span>);</div>
<div class="line">                    }</div>
<div class="line"> </div>
<div class="line">                    <span class="keywordflow">if</span> (j + 1 &lt; itr-&gt;second.m_SpecializationParam[i].m_NumElements)</div>
<div class="line">                        sourceFile &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">                }</div>
<div class="line"> </div>
<div class="line">                sourceFile &lt;&lt; <span class="stringliteral">&quot;};\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">                sourceFile &lt;&lt; <span class="stringliteral">&quot;    uint32_t &quot;</span> &lt;&lt; itr-&gt;second.m_SpecializationParam[i].m_Name &lt;&lt; <span class="stringliteral">&quot;Index = -1;\n\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">                sourceFile &lt;&lt; <span class="stringliteral">&quot;    for (uint32_t i = 0; i &lt; &quot;</span> &lt;&lt; itr-&gt;second.m_SpecializationParam[i].m_NumElements &lt;&lt; <span class="stringliteral">&quot;; ++i)\n&quot;</span>;</div>
<div class="line">                sourceFile &lt;&lt; <span class="stringliteral">&quot;    {\n&quot;</span>;</div>
<div class="line">                sourceFile &lt;&lt; <span class="stringliteral">&quot;        if(&quot;</span> &lt;&lt; itr-&gt;second.m_SpecializationParam[i].m_Name &lt;&lt; <span class="stringliteral">&quot;Values[i] == &quot;</span> &lt;&lt; itr-&gt;second.m_SpecializationParam[i].m_Name &lt;&lt; <span class="stringliteral">&quot;_)\n&quot;</span>;</div>
<div class="line">                sourceFile &lt;&lt; <span class="stringliteral">&quot;        {\n&quot;</span>;</div>
<div class="line">                sourceFile &lt;&lt; <span class="stringliteral">&quot;            &quot;</span> &lt;&lt; itr-&gt;second.m_SpecializationParam[i].m_Name &lt;&lt; <span class="stringliteral">&quot;Index = i;\n&quot;</span>;</div>
<div class="line">                sourceFile &lt;&lt; <span class="stringliteral">&quot;            &quot;</span> &lt;&lt; <span class="stringliteral">&quot;break;\n&quot;</span>;</div>
<div class="line">                sourceFile &lt;&lt; <span class="stringliteral">&quot;        }\n&quot;</span>;</div>
<div class="line">                sourceFile &lt;&lt; <span class="stringliteral">&quot;    }\n\n&quot;</span>;</div>
<div class="line">                sourceFile &lt;&lt; <span class="stringliteral">&quot;    NN_ASSERT(&quot;</span> &lt;&lt; itr-&gt;second.m_SpecializationParam[i].m_Name &lt;&lt; <span class="stringliteral">&quot;Index != -1, \&quot;Specialization value not found\&quot;);\n\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            sourceFile &lt;&lt; <span class="stringliteral">&quot;    uint32_t baseIndex = 0;\n&quot;</span>;</div>
<div class="line">            sourceFile &lt;&lt; <span class="stringliteral">&quot;    uint32_t maxIndex = &quot;</span> &lt;&lt; itr-&gt;second.m_NumOutputs &lt;&lt; <span class="stringliteral">&quot;;\n&quot;</span>;</div>
<div class="line">            sourceFile &lt;&lt; <span class="stringliteral">&quot;    uint32_t range = maxIndex;\n\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; itr-&gt;second.m_SpecializationParam.size(); ++i)</div>
<div class="line">            {</div>
<div class="line">                sourceFile &lt;&lt; <span class="stringliteral">&quot;    baseIndex += static_cast&lt;uint32_t&gt;(&quot;</span> &lt;&lt; itr-&gt;second.m_SpecializationParam[i].m_Name &lt;&lt; <span class="stringliteral">&quot;Index / &quot;</span> &lt;&lt; itr-&gt;second.m_SpecializationParam[i].m_NumElements &lt;&lt; <span class="stringliteral">&quot;.0f * range);\n&quot;</span>;</div>
<div class="line">                sourceFile &lt;&lt; <span class="stringliteral">&quot;    maxIndex -= static_cast&lt;uint32_t&gt;((&quot;</span> &lt;&lt; itr-&gt;second.m_SpecializationParam[i].m_NumElements &lt;&lt; <span class="stringliteral">&quot; - (&quot;</span> &lt;&lt; itr-&gt;second.m_SpecializationParam[i].m_Name &lt;&lt; <span class="stringliteral">&quot;Index + 1 )) / &quot;</span></div>
<div class="line">                                                  &lt;&lt; itr-&gt;second.m_SpecializationParam[i].m_NumElements &lt;&lt; <span class="stringliteral">&quot;.0f * range);\n&quot;</span>;</div>
<div class="line">                sourceFile &lt;&lt; <span class="stringliteral">&quot;    range = maxIndex - baseIndex;\n\n&quot;</span>;</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            sourceFile &lt;&lt; <span class="stringliteral">&quot;    return baseIndex;\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">            sourceFile &lt;&lt; <span class="stringliteral">&quot;}\n\n&quot;</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}<span class="comment">//NOLINT(impl/function_size)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::GetReferenceTypeName</span></div>
<div class="line"><span class="comment"> * ---------------------------------------------</span></div>
<div class="line"><span class="comment"> * Helper function that converts a given type enum and variable name</span></div>
<div class="line"><span class="comment"> * into a string to be used by the shader header/source helper file</span></div>
<div class="line"><span class="comment"> * output. The list of types here is not complete and is simply the</span></div>
<div class="line"><span class="comment"> * types that are used by the shaders in these tutorials.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">std::string IntermediateFileManager::GetReferenceTypeName(<a class="code" href="nvn_tool___glslc_interface_8h.html#a71450a1e5f331c7e5a19404cbf63974a">GLSLCpiqTypeEnum</a> type, <span class="keyword">const</span> std::string&amp; variableName)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span>(type)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">case</span> GLSLC_PIQ_TYPE_INT:</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;const int32_t&amp; &quot;</span> + variableName;</div>
<div class="line">        <span class="keywordflow">case</span> GLSLC_PIQ_TYPE_INT64:</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;const int64_t&amp; &quot;</span> + variableName;</div>
<div class="line">        <span class="keywordflow">case</span> GLSLC_PIQ_TYPE_UINT:</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;const uint32_t&amp; &quot;</span> + variableName;</div>
<div class="line">        <span class="keywordflow">case</span> GLSLC_PIQ_TYPE_UINT64:</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;const uint64_t&amp; &quot;</span> + variableName;</div>
<div class="line">        <span class="keywordflow">case</span> GLSLC_PIQ_TYPE_FLOAT:</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;const float&amp; &quot;</span> + variableName;</div>
<div class="line">        <span class="keywordflow">case</span> GLSLC_PIQ_TYPE_FLOAT_VEC2:</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;const float (&amp;&quot;</span> + variableName + <span class="stringliteral">&quot;)[2]&quot;</span>;</div>
<div class="line">        <span class="keywordflow">case</span> GLSLC_PIQ_TYPE_FLOAT_VEC3:</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;const float (&amp;&quot;</span> + variableName + <span class="stringliteral">&quot;)[3]&quot;</span>;</div>
<div class="line">        <span class="keywordflow">case</span> GLSLC_PIQ_TYPE_FLOAT_VEC4:</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;const float (&amp;&quot;</span> + variableName + <span class="stringliteral">&quot;)[4]&quot;</span>;</div>
<div class="line">        <span class="keywordflow">case</span> GLSLC_PIQ_TYPE_MAT3:</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;const float (&amp;&quot;</span> + variableName + <span class="stringliteral">&quot;)[9]&quot;</span>;</div>
<div class="line">        <span class="keywordflow">case</span> GLSLC_PIQ_TYPE_MAT4X3:</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;const float (&amp;&quot;</span> + variableName + <span class="stringliteral">&quot;)[12]&quot;</span>;</div>
<div class="line">        <span class="keywordflow">case</span> GLSLC_PIQ_TYPE_MAT4:</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;const float (&amp;&quot;</span> + variableName + <span class="stringliteral">&quot;)[16]&quot;</span>;</div>
<div class="line">        <span class="keywordflow">case</span> GLSLC_PIQ_INVALID_TYPE:</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Invalid type requested.\n&quot;</span>;</div>
<div class="line">            assert(<span class="stringliteral">&quot;Invalid type requested.&quot;</span> &amp;&amp; 0);</div>
<div class="line">            <span class="keywordflow">return</span> std::string();</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">default</span>:</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Unlisted variable type, case needs to be added.\n&quot;</span>;</div>
<div class="line">            assert(<span class="stringliteral">&quot;Unlisted variable type, case needs to be added.&quot;</span> &amp;&amp; 0);</div>
<div class="line">            <span class="keywordflow">return</span> std::string();</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::LoadTextureData</span></div>
<div class="line"><span class="comment"> * ----------------------------------------</span></div>
<div class="line"><span class="comment"> * Uses the NVN image library to load the raw texture data</span></div>
<div class="line"><span class="comment"> * from the files specified by the config text file. The raw</span></div>
<div class="line"><span class="comment"> * texture data is stored in the nvnTool::texpkg::RawImage class.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">bool</span> IntermediateFileManager::LoadTextureData(<span class="keyword">const</span> std::string&amp; path)</div>
<div class="line">{</div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Texpkg Raw Image</span></div>
<div class="line"><span class="comment">         * ----------------</span></div>
<div class="line"><span class="comment">         * The RawImage structure is a wrapper around a generic pitch-linear</span></div>
<div class="line"><span class="comment">         * image with member functions to get information about the texture.</span></div>
<div class="line"><span class="comment">         * A RawImage can be created with specific settings with the Create</span></div>
<div class="line"><span class="comment">         * function. An image created through the image loader will be setup</span></div>
<div class="line"><span class="comment">         * based on the texture file that is loaded.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Textures */</span></div>
<div class="line">    <span class="keywordflow">for</span>(std::vector&lt;TextureData&gt;::iterator itr = m_RawTextureData.begin(); itr != m_RawTextureData.end(); ++itr)</div>
<div class="line">    {</div>
<div class="line">            <span class="comment">/* Create a RawImage struct for the base texture to be loaded. */</span></div>
<div class="line">        <a name="_a126"></a><a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image.html">nvnTool::texpkg::RawImage</a>* temp = g_NvnImageLib.<a name="a127"></a>createRawImage();</div>
<div class="line"> </div>
<div class="line">        std::string tempFile = path + itr-&gt;m_FileName;</div>
<div class="line">        std::wstring filename(tempFile.begin(), tempFile.end());</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Load the texture in from file into the RawImage. */</span></div>
<div class="line">        TPError err = g_ImageLoader-&gt;<a name="a128"></a><a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image_format_manager.html#a8dc4204e239067cf09595b493588eb68">Load</a>(filename.c_str(), temp);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span>(err != TP_OK)</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to load image: &quot;</span> &lt;&lt; tempFile.c_str() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* If the texture has mip maps that need to be loaded in... */</span></div>
<div class="line">        <span class="keywordflow">if</span>(itr-&gt;m_MipMaps.size())</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image.html">nvnTool::texpkg::RawImage</a>* image = g_NvnImageLib.createRawImage();</div>
<div class="line"> </div>
<div class="line">                <span class="comment">/* Create a new RawImage that has the appropriate number of mip maps. */</span></div>
<div class="line">            TPError create = image-&gt;Create(temp-&gt;<a name="a129"></a>Target(), temp-&gt;<a name="a130"></a><a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image.html#a858faa34edde48e3b8ed1678a28964a2">Width</a>(), temp-&gt;<a name="a131"></a><a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image.html#a9a60cdb1745bfedfa763db28e0fc3b0e">Height</a>(), temp-&gt;<a name="a132"></a><a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image.html#a32b4cb92efd5d7748ad5548cbaab79e2">Depth</a>(), temp-&gt;<a name="a133"></a>Format(), <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(itr-&gt;m_MipMaps.size()) + 1);</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span>(create != TP_OK)</div>
<div class="line">            {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to created image: &quot;</span> &lt;&lt; tempFile.c_str() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">                <span class="comment">/* Grab a pointer to the base level texture data and copy the loaded texture data into it. */</span></div>
<div class="line">            <a name="_a134"></a><a class="code" href="structnvn_tool_1_1texpkg_1_1_raw_mip_map_level.html">nvnTool::texpkg::RawMipMapLevel</a>* base = image-&gt;MipMapLevel(0);</div>
<div class="line">            memcpy(base-&gt;<a name="a135"></a><a class="code" href="structnvn_tool_1_1texpkg_1_1_raw_mip_map_level.html#a7a5c91011253054539257bf5e58f8dfc">data</a>, temp-&gt;<a name="a136"></a><a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image.html#a82824e08861efe2123da72fec40ef788">GetData</a>(), base-&gt;<a name="a137"></a><a class="code" href="structnvn_tool_1_1texpkg_1_1_raw_mip_map_level.html#a9966eb3a43d2a4232b85136c9cb3ca58">dataSize</a>);</div>
<div class="line"> </div>
<div class="line">                <span class="comment">/* For each mip level... */</span></div>
<div class="line">            <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; itr-&gt;m_MipMaps.size(); ++i)</div>
<div class="line">            {</div>
<div class="line">                    <span class="comment">/* Create a RawImage and load the texture file for the mip level. */</span></div>
<div class="line">                <a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image.html">nvnTool::texpkg::RawImage</a>* tempMip = g_NvnImageLib.createRawImage();</div>
<div class="line">                std::string tempFileMip = path + itr-&gt;m_MipMaps[i].m_FileName;</div>
<div class="line">                err = g_ImageLoader-&gt;<a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image_format_manager.html#a8dc4204e239067cf09595b493588eb68">Load</a>(std::wstring(tempFileMip.begin(), tempFileMip.end()).c_str(), tempMip);</div>
<div class="line"> </div>
<div class="line">                <span class="keywordflow">if</span>(err != TP_OK)</div>
<div class="line">                {</div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to load image: &quot;</span> &lt;&lt; tempFileMip.c_str() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">                }</div>
<div class="line"> </div>
<div class="line">                    <span class="comment">/* Grab a poiner to the mip level data and copy the loaded data into it. */</span></div>
<div class="line">                <a class="code" href="structnvn_tool_1_1texpkg_1_1_raw_mip_map_level.html">nvnTool::texpkg::RawMipMapLevel</a>* mipMap = image-&gt;MipMapLevel(itr-&gt;m_MipMaps[i].m_Level);</div>
<div class="line">                memcpy(mipMap-&gt;<a class="code" href="structnvn_tool_1_1texpkg_1_1_raw_mip_map_level.html#a7a5c91011253054539257bf5e58f8dfc">data</a>, tempMip-&gt;<a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image.html#a82824e08861efe2123da72fec40ef788">GetData</a>(), mipMap-&gt;<a class="code" href="structnvn_tool_1_1texpkg_1_1_raw_mip_map_level.html#a9966eb3a43d2a4232b85136c9cb3ca58">dataSize</a>);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            itr-&gt;m_pRawImage = image;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            itr-&gt;m_pRawImage = temp;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Cube maps */</span></div>
<div class="line">    <span class="keywordflow">for</span>(std::vector&lt;CubeMapData&gt;::iterator itr = m_RawCubeMapData.begin(); itr != m_RawCubeMapData.end(); ++itr)</div>
<div class="line">    {</div>
<div class="line">        std::vector&lt;nvnTool::texpkg::RawImage*&gt; faces;</div>
<div class="line">        faces.resize(itr-&gt;m_Faces.size(), NULL);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* For each face... */</span></div>
<div class="line">        <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; itr-&gt;m_Faces.size(); ++i)</div>
<div class="line">        {</div>
<div class="line">                <span class="comment">/* Load in the cube map face from file and create a RawImage for it. */</span></div>
<div class="line">            faces[i] = g_NvnImageLib.createRawImage();</div>
<div class="line"> </div>
<div class="line">            std::string tempFile = path + itr-&gt;m_Faces[i];</div>
<div class="line">            std::wstring filename(tempFile.begin(), tempFile.end());</div>
<div class="line"> </div>
<div class="line">            TPError err = g_ImageLoader-&gt;<a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image_format_manager.html#a8dc4204e239067cf09595b493588eb68">Load</a>(filename.c_str(), faces[i]);</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span>(err != TP_OK)</div>
<div class="line">            {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to load image: &quot;</span> &lt;&lt; itr-&gt;m_Faces[i].c_str() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Create a RawImage for the full cube map with the appropriate parameters. */</span></div>
<div class="line">        <a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image.html">nvnTool::texpkg::RawImage</a>* cubeImage = g_NvnImageLib.createRawImage();</div>
<div class="line"> </div>
<div class="line">        TPError create = cubeImage-&gt;<a name="a138"></a><a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image.html#ac10c025febba178c2f547be67db50c45">Create</a>(NVNtextureTarget::NVN_TEXTURE_TARGET_CUBEMAP, faces[0]-&gt;Width(), faces[0]-&gt;Height(), faces[0]-&gt;Depth(), faces[0]-&gt;Format(), 1, 6);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span>(create != TP_OK)</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to created image: &quot;</span> &lt;&lt; itr-&gt;m_Name.c_str() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Set the cube face mask to all to denote that all cube map faces are being used. */</span></div>
<div class="line">        cubeImage-&gt;<a name="a139"></a>SetCubeFaceMask(nvnTool::texpkg::RawTextureCubeFace::CUBE_FACE_All);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Copy the data for each face at the appropriate subimage. */</span></div>
<div class="line">        <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; itr-&gt;m_Faces.size(); ++i)</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="structnvn_tool_1_1texpkg_1_1_raw_mip_map_level.html">nvnTool::texpkg::RawMipMapLevel</a>* mipMap = cubeImage-&gt;<a name="a140"></a><a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image.html#a0d0ff82a41c39b616dabb7b73b13f9dd">MipMapLevel</a>(0, i);</div>
<div class="line"> </div>
<div class="line">            memcpy(mipMap-&gt;<a class="code" href="structnvn_tool_1_1texpkg_1_1_raw_mip_map_level.html#a7a5c91011253054539257bf5e58f8dfc">data</a>, faces[i]-&gt;GetData(), mipMap-&gt;<a class="code" href="structnvn_tool_1_1texpkg_1_1_raw_mip_map_level.html#a9966eb3a43d2a4232b85136c9cb3ca58">dataSize</a>);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        itr-&gt;m_pRawImage = cubeImage;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::ConvertTextures</span></div>
<div class="line"><span class="comment"> * ----------------------------------------</span></div>
<div class="line"><span class="comment"> * Takes the raw texture data that was loaded in and runs</span></div>
<div class="line"><span class="comment"> * it through the texpkg libraries conversion process. This</span></div>
<div class="line"><span class="comment"> * results in the texture being converted to a format that</span></div>
<div class="line"><span class="comment"> * allows the target harware to use it directly.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">bool</span> IntermediateFileManager::ConvertTextures()</div>
<div class="line">{</div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * NVNHWTexture</span></div>
<div class="line"><span class="comment">         * ------------</span></div>
<div class="line"><span class="comment">         * The NVNHWTexture hold the texture data from a RawImage after</span></div>
<div class="line"><span class="comment">         * it has been converted to the hardware optimized format. This</span></div>
<div class="line"><span class="comment">         * converted format can also be used on Windows if it is given</span></div>
<div class="line"><span class="comment">         * to the texture builder through the SetPackagedTextureData function.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Convert the list of textures. */</span></div>
<div class="line">    <span class="keywordflow">for</span> (std::vector&lt;TextureData&gt;::iterator itr = m_RawTextureData.begin(); itr != m_RawTextureData.end(); ++itr)</div>
<div class="line">    {</div>
<div class="line">        TPError err = g_HwTextureExporter-&gt;<a name="a141"></a><a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image_hardware_texture_exporter.html#afd984b313aa67240995f06d92a8e9ef3">Convert</a>(itr-&gt;m_pRawImage, &amp;m_ConvertedTextureData[itr-&gt;m_FileName]);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span>(err != TP_OK)</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to convert texture: &quot;</span> &lt;&lt; itr-&gt;m_FileName.c_str() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Convert the cube maps. */</span></div>
<div class="line">    <span class="keywordflow">for</span>(std::vector&lt;CubeMapData&gt;::iterator itr = m_RawCubeMapData.begin(); itr != m_RawCubeMapData.end(); ++itr)</div>
<div class="line">    {</div>
<div class="line">        TPError err = g_HwTextureExporter-&gt;<a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image_hardware_texture_exporter.html#afd984b313aa67240995f06d92a8e9ef3">Convert</a>(itr-&gt;m_pRawImage, &amp;m_ConvertedTextureData[itr-&gt;m_Name]);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span>(err != TP_OK)</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to convert texture: &quot;</span> &lt;&lt; itr-&gt;m_Name.c_str() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::LoadWaveFrontData</span></div>
<div class="line"><span class="comment"> * ------------------------------------------</span></div>
<div class="line"><span class="comment"> * Loads and processes the WaveFrontObj data specified</span></div>
<div class="line"><span class="comment"> * by the config file.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">bool</span> IntermediateFileManager::LoadWaveFrontData(<span class="keyword">const</span> std::string&amp; path)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (std::unordered_map&lt;std::string, WaveFrontObjConfig&gt;::iterator itr = m_WaveFrontObjs.begin(); itr != m_WaveFrontObjs.end(); ++itr)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (!m_WaveFrontFileManager.LoadObjFile(path, itr-&gt;first, itr-&gt;second.m_Attrib, itr-&gt;second.m_Shapes, itr-&gt;second.m_Materials))</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">        m_WaveFrontFileManager.ProcessData(itr-&gt;second.m_Attrib, itr-&gt;second.m_Shapes, itr-&gt;second.m_Meshes);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::LoadShaderConfig</span></div>
<div class="line"><span class="comment"> * -----------------------------------------</span></div>
<div class="line"><span class="comment"> * Load the shader section of the config file.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> IntermediateFileManager::LoadShaderConfig(std::ifstream&amp; configFile)</div>
<div class="line">{</div>
<div class="line">    std::string text, programName;</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;Name:&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        configFile &gt;&gt; programName;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Shader Program Name\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Shader Program Name\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> loop = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">while</span> (loop)</div>
<div class="line">    {</div>
<div class="line">        configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;VertexShader:&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            configFile &gt;&gt; text;</div>
<div class="line">            m_ShaderPrograms[programName].m_Vert = text;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;FragmentShader:&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            configFile &gt;&gt; text;</div>
<div class="line">            m_ShaderPrograms[programName].m_Frag = text;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;ComputeShader:&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            configFile &gt;&gt; text;</div>
<div class="line">            m_ShaderPrograms[programName].m_Comp = text;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;TessEvalShader:&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            configFile &gt;&gt; text;</div>
<div class="line">            m_ShaderPrograms[programName].m_TessEval = text;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;TessContShader:&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            configFile &gt;&gt; text;</div>
<div class="line">            m_ShaderPrograms[programName].m_TessCont = text;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;GeometryShader:&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            configFile &gt;&gt; text;</div>
<div class="line">            m_ShaderPrograms[programName].m_Geom = text;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;SpecializationParameterBegin&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            m_ShaderPrograms[programName].m_SpecializationParam.push_back(SpecializationParam());</div>
<div class="line">            SpecializationParam&amp; param = m_ShaderPrograms[programName].m_SpecializationParam.back();</div>
<div class="line"> </div>
<div class="line">            configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;Name:&quot;</span>)</div>
<div class="line">            {</div>
<div class="line">                configFile.seekg(1, std::ios_base::cur);</div>
<div class="line">                std::getline(configFile, param.m_Name);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Specialized Uniform Name\n&quot;</span>;</div>
<div class="line">                assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Specialized Uniform Name\n&quot;</span>);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;NumElements:&quot;</span>)</div>
<div class="line">            {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Specialized Uniform NumElements\n&quot;</span>;</div>
<div class="line">                assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Specialized Uniform NumElements\n&quot;</span>);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            configFile &gt;&gt; param.m_NumElements;</div>
<div class="line"> </div>
<div class="line">            configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;ElementSize:&quot;</span>)</div>
<div class="line">            {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Specialized Uniform ElementSize\n&quot;</span>;</div>
<div class="line">                assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Specialized Uniform ElementSize\n&quot;</span>);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            configFile &gt;&gt; param.m_ElementSize;</div>
<div class="line"> </div>
<div class="line">            configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;Type:&quot;</span>)</div>
<div class="line">            {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Specialized Uniform Type\n&quot;</span>;</div>
<div class="line">                assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Specialized Uniform Type\n&quot;</span>);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            configFile &gt;&gt; param.m_Type;</div>
<div class="line"> </div>
<div class="line">            configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;ValueBegin&quot;</span>)</div>
<div class="line">            {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Expected ValueBegin\n&quot;</span>;</div>
<div class="line">                assert(0 &amp;&amp; <span class="stringliteral">&quot;Expected ValueBegin\n&quot;</span>);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            param.m_pData = malloc(param.m_ElementSize * param.m_NumElements);</div>
<div class="line"> </div>
<div class="line">            <span class="keywordtype">void</span>* temp = param.m_pData;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordtype">bool</span> valueloop = <span class="keyword">true</span>;</div>
<div class="line">            <span class="keywordflow">while</span> (valueloop)</div>
<div class="line">            {</div>
<div class="line">                configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">                <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;End&quot;</span>)</div>
<div class="line">                {</div>
<div class="line">                    valueloop = <span class="keyword">false</span>;</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                }</div>
<div class="line"> </div>
<div class="line">                <span class="keywordflow">if</span> (param.m_Type == <span class="stringliteral">&quot;float&quot;</span>)</div>
<div class="line">                {</div>
<div class="line">                    *(<span class="keywordtype">float</span>*)temp = std::strtof(text.c_str(), <span class="keyword">nullptr</span>);</div>
<div class="line">                    temp = (<span class="keywordtype">float</span>*)temp + 1;</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (param.m_Type == <span class="stringliteral">&quot;int32_t&quot;</span>)</div>
<div class="line">                {</div>
<div class="line">                    *(int32_t*)temp = std::atoi(text.c_str());</div>
<div class="line">                    temp = (int32_t*)temp + 1;</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (param.m_Type == <span class="stringliteral">&quot;uint32_t&quot;</span>)</div>
<div class="line">                {</div>
<div class="line">                    *(uint32_t*)temp = std::atoi(text.c_str());</div>
<div class="line">                    temp = (uint32_t*)temp + 1;</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (param.m_Type == <span class="stringliteral">&quot;short&quot;</span>)</div>
<div class="line">                {</div>
<div class="line">                    *(<span class="keywordtype">short</span>*)temp = <span class="keyword">static_cast&lt;</span><span class="keywordtype">short</span><span class="keyword">&gt;</span>(std::atoi(text.c_str()));</div>
<div class="line">                    temp = (<span class="keywordtype">short</span>*)temp + 1;</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (param.m_Type == <span class="stringliteral">&quot;char&quot;</span>)</div>
<div class="line">                {</div>
<div class="line">                    *(<span class="keywordtype">char</span>*)temp = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(std::atoi(text.c_str()));</div>
<div class="line">                    temp = (<span class="keywordtype">char</span>*)temp + 1;</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">else</span></div>
<div class="line">                {</div>
<div class="line">                    assert(0 &amp;&amp; <span class="stringliteral">&quot;Unknown specialization type\n&quot;</span>);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            configFile &gt;&gt; text;</div>
<div class="line">            <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;End&quot;</span>)</div>
<div class="line">            {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Missing SpecializationParameter End\n&quot;</span>;</div>
<div class="line">                assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing SpecializationParameter End\n&quot;</span>);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;End&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            loop = <span class="keyword">false</span>;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}<span class="comment">//NOLINT(impl/function_size)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::LoadTextureConfig</span></div>
<div class="line"><span class="comment"> * ------------------------------------------</span></div>
<div class="line"><span class="comment"> * Load the texture section of the config file.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> IntermediateFileManager::LoadTextureConfig(std::ifstream&amp; configFile)</div>
<div class="line">{</div>
<div class="line">    std::string text, textureName;</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;Name:&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        configFile &gt;&gt; textureName;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Texture File Name\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Texture File Name\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    m_RawTextureData.push_back(TextureData());</div>
<div class="line"> </div>
<div class="line">    m_RawTextureData.back().m_FileName = textureName;</div>
<div class="line">    m_RawTextureData.back().m_pRawImage = NULL;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> loop = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">while</span> (loop)</div>
<div class="line">    {</div>
<div class="line">        configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;End&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            loop = <span class="keyword">false</span>;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;MipmapBegin&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            m_RawTextureData.back().m_MipMaps.push_back(MipMapData());</div>
<div class="line"> </div>
<div class="line">            configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;Name:&quot;</span>)</div>
<div class="line">            {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Mipmap File Name\n&quot;</span>;</div>
<div class="line">                assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Mipmap File Name\n&quot;</span>);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            configFile &gt;&gt; m_RawTextureData.back().m_MipMaps.back().m_FileName;</div>
<div class="line"> </div>
<div class="line">            configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;Level:&quot;</span>)</div>
<div class="line">            {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Mipmap Level\n&quot;</span>;</div>
<div class="line">                assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Mipmap Level\n&quot;</span>);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            configFile &gt;&gt; m_RawTextureData.back().m_MipMaps.back().m_Level;</div>
<div class="line"> </div>
<div class="line">            configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;End&quot;</span>)</div>
<div class="line">            {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Mipmap End\n&quot;</span>;</div>
<div class="line">                assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Mipmap End\n&quot;</span>);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::LoadCubeMapConfig</span></div>
<div class="line"><span class="comment"> * ------------------------------------------</span></div>
<div class="line"><span class="comment"> * Load the cube map section of the config file.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> IntermediateFileManager::LoadCubeMapConfig(std::ifstream&amp; configFile)</div>
<div class="line">{</div>
<div class="line">    std::string text;</div>
<div class="line"> </div>
<div class="line">    m_RawCubeMapData.push_back(CubeMapData());</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;Name:&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Cube Map Name\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Cube Map Name\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; m_RawCubeMapData.back().m_Name;</div>
<div class="line">    m_RawCubeMapData.back().m_pRawImage = NULL;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> loop = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">while</span> (loop)</div>
<div class="line">    {</div>
<div class="line">        configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;End&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            loop = <span class="keyword">false</span>;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;Face:&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            m_RawCubeMapData.back().m_Faces.push_back(std::string());</div>
<div class="line">            configFile &gt;&gt; m_RawCubeMapData.back().m_Faces.back();</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Unknown Cube Map Element: &quot;</span> &lt;&lt; text &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">            assert(0 &amp;&amp; <span class="stringliteral">&quot;Unknown Cube Map Element\n&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (m_RawCubeMapData.back().m_Faces.size() != 6)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Cube map with less than 6 faces: &quot;</span> &lt;&lt; m_RawCubeMapData.back().m_Name.c_str() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">        assert(<span class="stringliteral">&quot;Cube map with less than 6 faces&quot;</span> &amp;&amp; 0);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::LoadModelConfig</span></div>
<div class="line"><span class="comment"> * ----------------------------------------</span></div>
<div class="line"><span class="comment"> * Load the model section of the config file.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> IntermediateFileManager::LoadModelConfig(std::ifstream&amp; configFile)</div>
<div class="line">{</div>
<div class="line">    Model model;</div>
<div class="line"> </div>
<div class="line">    std::string text;</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;Name:&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Model Name\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Model Name\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; model.m_Name;</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;NumAttributes:&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing NumAttributes\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing NumAttributes\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; model.m_NumVertexAttributes;</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;NumPrimitives:&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing NumPrimitives\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing NumPrimitives\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; model.m_NumPrimitives;</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;nvnDrawPrimitiveType:&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing nvnDrawPrimitiveType\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing nvnDrawPrimitiveType\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; model.m_NvnDrawPrimitiveType;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> loop = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">while</span> (loop)</div>
<div class="line">    {</div>
<div class="line">        configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;VertexAttributeBegin&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            LoadVertexAttributeConfig(configFile, model);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;IndicesBegin&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            LoadIndices(configFile, model);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;End&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            loop = <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    m_RawModelData.push_back(model);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::LoadVertexAttributeConfig</span></div>
<div class="line"><span class="comment"> * --------------------------------------------------</span></div>
<div class="line"><span class="comment"> * Load the vertex attribute section of the config file.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> IntermediateFileManager::LoadVertexAttributeConfig(std::ifstream&amp; configFile, Model&amp; model)</div>
<div class="line">{</div>
<div class="line">    std::string text;</div>
<div class="line">    VertexAttribute vertexAttribute;</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;Name:&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Attribute Name\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Attribute Name\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; vertexAttribute.m_Name;</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;DataSize:&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Attribute DataSize\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Attribute DataSize\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; vertexAttribute.m_DataSize;</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;ElementSize:&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Attribute ElementSize\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Attribute ElementSize\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; vertexAttribute.m_ElementSize;</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;Stride:&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Attribute Stride\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Attribute Stride\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; vertexAttribute.m_Stride;</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;nvnFormat:&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Attribute nvnFormat\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Attribute nvnFormat\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; vertexAttribute.m_NvnFormat;</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;DataBegin&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Attribute Data\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Attribute Data\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    vertexAttribute.m_pData = malloc(vertexAttribute.m_DataSize);</div>
<div class="line">    <span class="keywordtype">void</span>* temp = vertexAttribute.m_pData;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> loop = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">while</span> (loop)</div>
<div class="line">    {</div>
<div class="line">        configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;End&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            loop = <span class="keyword">false</span>;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (vertexAttribute.m_ElementSize == <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>))</div>
<div class="line">        {</div>
<div class="line">            *(<span class="keywordtype">float</span>*)temp = std::strtof(text.c_str(), <span class="keyword">nullptr</span>);</div>
<div class="line">            temp = (<span class="keywordtype">float</span>*)temp + 1;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vertexAttribute.m_ElementSize == <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>))</div>
<div class="line">        {</div>
<div class="line">            *(<span class="keywordtype">short</span>*)temp = <span class="keyword">static_cast&lt;</span><span class="keywordtype">short</span><span class="keyword">&gt;</span>(std::atoi(text.c_str()));</div>
<div class="line">            temp = (<span class="keywordtype">short</span>*)temp + 1;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vertexAttribute.m_ElementSize == <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>))</div>
<div class="line">        {</div>
<div class="line">            *(<span class="keywordtype">char</span>*)temp = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(std::atoi(text.c_str()));</div>
<div class="line">            temp = (<span class="keywordtype">char</span>*)temp + 1;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;End&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Attribute End\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Attribute End\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    model.m_VertexAttributes.push_back(vertexAttribute);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::LoadIndices</span></div>
<div class="line"><span class="comment"> * ------------------------------------</span></div>
<div class="line"><span class="comment"> * Load the index section of the config file.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> IntermediateFileManager::LoadIndices(std::ifstream&amp; configFile, Model&amp; model)</div>
<div class="line">{</div>
<div class="line">    std::string text;</div>
<div class="line">    IndexData&amp; indexData = model.m_IndexData;</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;nvnType:&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Indices NVN Type\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Indices NVN Type\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; indexData.m_IndexType;</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;DataSize:&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Indices DataSize\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Indices DataSize\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; indexData.m_DataSize;</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;Stride:&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Indices Stride\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Indices Stride\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; indexData.m_Stride;</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;DataBegin&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Indices Data\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Indices Data\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    indexData.m_pData = malloc(indexData.m_DataSize);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span>* temp = indexData.m_pData;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> loop = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">while</span> (loop)</div>
<div class="line">    {</div>
<div class="line">        configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;End&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            loop = <span class="keyword">false</span>;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (indexData.m_Stride == <span class="keyword">sizeof</span>(uint32_t))</div>
<div class="line">        {</div>
<div class="line">            *(uint32_t*)temp = std::atoi(text.c_str());</div>
<div class="line">            temp = (uint32_t*)temp + 1;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (indexData.m_Stride == <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>))</div>
<div class="line">        {</div>
<div class="line">            *(<span class="keywordtype">short</span>*)temp = <span class="keyword">static_cast&lt;</span><span class="keywordtype">short</span><span class="keyword">&gt;</span>(std::atoi(text.c_str()));</div>
<div class="line">            temp = (<span class="keywordtype">short</span>*)temp + 1;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (indexData.m_Stride == <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>))</div>
<div class="line">        {</div>
<div class="line">            *(<span class="keywordtype">char</span>*)temp = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(std::atoi(text.c_str()));</div>
<div class="line">            temp = (<span class="keywordtype">char</span>*)temp + 1;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;End&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Indices End\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Indices End\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::LoadWaveFrontConfig</span></div>
<div class="line"><span class="comment"> * --------------------------------------------</span></div>
<div class="line"><span class="comment"> * Load the WaveFrontObj part of the config file.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> IntermediateFileManager::LoadWaveFrontConfig(std::ifstream&amp; configFile)</div>
<div class="line">{</div>
<div class="line">    std::string fileName, text;</div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;FileName:&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        configFile &gt;&gt;fileName;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing WaveFrontObj File Name\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing WaveFrontObj File Name\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    m_WaveFrontObjs[fileName] = WaveFrontObjConfig();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;End&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing WaveFrontObj End\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing WaveFrontObj End\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::LoadConfigFile</span></div>
<div class="line"><span class="comment"> * ---------------------------------------</span></div>
<div class="line"><span class="comment"> * Load the config file.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">bool</span> IntermediateFileManager::LoadConfigFile(std::string fileName)</div>
<div class="line">{</div>
<div class="line">    std::ifstream configFile;</div>
<div class="line">    configFile.open(fileName);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!configFile.is_open())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (!configFile.eof())</div>
<div class="line">    {</div>
<div class="line">        std::string text;</div>
<div class="line">        configFile &gt;&gt; text;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;ShaderProgramBegin&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            LoadShaderConfig(configFile);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;TextureBegin&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            LoadTextureConfig(configFile);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;CubeMapBegin&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            LoadCubeMapConfig(configFile);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;ModelBegin&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            LoadModelConfig(configFile);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;WaveFrontObjBegin&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            LoadWaveFrontConfig(configFile);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="ttc" id="a_intermediate_file_manager_8h_html"><div class="ttname"><a href="_intermediate_file_manager_8h.html">IntermediateFileManager.h</a></div><div class="ttdoc">This file defines a class that handles reading config files, loading raw asset data,...</div></div>
<div class="ttc" id="a_output_file_headers_8h_html"><div class="ttname"><a href="_output_file_headers_8h.html">OutputFileHeaders.h</a></div><div class="ttdoc">This file defines the data structures that make up the the overall structure of the output asset file...</div></div>
<div class="ttc" id="a_texpkg___helper_8h_html"><div class="ttname"><a href="_texpkg___helper_8h.html">Texpkg_Helper.h</a></div><div class="ttdoc">This file defines some global texpkg objects needed to load the texture files and perform the data co...</div></div>
<div class="ttc" id="aclassnvn_tool_1_1texpkg_1_1_raw_image_format_manager_html_a8dc4204e239067cf09595b493588eb68"><div class="ttname"><a href="classnvn_tool_1_1texpkg_1_1_raw_image_format_manager.html#a8dc4204e239067cf09595b493588eb68">nvnTool::texpkg::RawImageFormatManager::Load</a></div><div class="ttdeci">virtual TPError Load(const wchar_t *fileName, RawImage *img)=0</div><div class="ttdoc">Load an image file from disk.</div></div>
<div class="ttc" id="aclassnvn_tool_1_1texpkg_1_1_raw_image_hardware_texture_exporter_html_a3c17476b5aa35d3c7ef2b385dcd52871"><div class="ttname"><a href="classnvn_tool_1_1texpkg_1_1_raw_image_hardware_texture_exporter.html#a3c17476b5aa35d3c7ef2b385dcd52871">nvnTool::texpkg::RawImageHardwareTextureExporter::ReleaseTextureData</a></div><div class="ttdeci">virtual void ReleaseTextureData(NVNHWTexture *hwTexture)=0</div><div class="ttdoc">Release the storage data associated with a HW texture.</div></div>
<div class="ttc" id="aclassnvn_tool_1_1texpkg_1_1_raw_image_hardware_texture_exporter_html_afd984b313aa67240995f06d92a8e9ef3"><div class="ttname"><a href="classnvn_tool_1_1texpkg_1_1_raw_image_hardware_texture_exporter.html#afd984b313aa67240995f06d92a8e9ef3">nvnTool::texpkg::RawImageHardwareTextureExporter::Convert</a></div><div class="ttdeci">virtual TPError Convert(RawImage *inImage, NVNHWTexture *outTexture, uint32_t flags=0U)=0</div><div class="ttdoc">Convert to hardware format texture for NX.</div></div>
<div class="ttc" id="aclassnvn_tool_1_1texpkg_1_1_raw_image_html"><div class="ttname"><a href="classnvn_tool_1_1texpkg_1_1_raw_image.html">nvnTool::texpkg::RawImage</a></div><div class="ttdoc">A generic pitch-linear image.</div><div class="ttdef"><b>Definition:</b> nvnTool_Image.h:126</div></div>
<div class="ttc" id="aclassnvn_tool_1_1texpkg_1_1_raw_image_html_a0d0ff82a41c39b616dabb7b73b13f9dd"><div class="ttname"><a href="classnvn_tool_1_1texpkg_1_1_raw_image.html#a0d0ff82a41c39b616dabb7b73b13f9dd">nvnTool::texpkg::RawImage::MipMapLevel</a></div><div class="ttdeci">virtual RawMipMapLevel * MipMapLevel(uint32_t levelIdx, uint32_t subimage=0)=0</div><div class="ttdoc">Retrieve the reference to a single mipmap level.</div></div>
<div class="ttc" id="aclassnvn_tool_1_1texpkg_1_1_raw_image_html_a32b4cb92efd5d7748ad5548cbaab79e2"><div class="ttname"><a href="classnvn_tool_1_1texpkg_1_1_raw_image.html#a32b4cb92efd5d7748ad5548cbaab79e2">nvnTool::texpkg::RawImage::Depth</a></div><div class="ttdeci">virtual uint32_t Depth(void) const =0</div><div class="ttdoc">Base level depth of the image.</div></div>
<div class="ttc" id="aclassnvn_tool_1_1texpkg_1_1_raw_image_html_a82824e08861efe2123da72fec40ef788"><div class="ttname"><a href="classnvn_tool_1_1texpkg_1_1_raw_image.html#a82824e08861efe2123da72fec40ef788">nvnTool::texpkg::RawImage::GetData</a></div><div class="ttdeci">virtual uint8_t * GetData(void)=0</div><div class="ttdoc">Get the image data pointer, or NULL if image hasn't been initialized.</div></div>
<div class="ttc" id="aclassnvn_tool_1_1texpkg_1_1_raw_image_html_a858faa34edde48e3b8ed1678a28964a2"><div class="ttname"><a href="classnvn_tool_1_1texpkg_1_1_raw_image.html#a858faa34edde48e3b8ed1678a28964a2">nvnTool::texpkg::RawImage::Width</a></div><div class="ttdeci">virtual uint32_t Width(void) const =0</div><div class="ttdoc">Base level width of the image.</div></div>
<div class="ttc" id="aclassnvn_tool_1_1texpkg_1_1_raw_image_html_a9a60cdb1745bfedfa763db28e0fc3b0e"><div class="ttname"><a href="classnvn_tool_1_1texpkg_1_1_raw_image.html#a9a60cdb1745bfedfa763db28e0fc3b0e">nvnTool::texpkg::RawImage::Height</a></div><div class="ttdeci">virtual uint32_t Height(void) const =0</div><div class="ttdoc">Base level height of the image.</div></div>
<div class="ttc" id="aclassnvn_tool_1_1texpkg_1_1_raw_image_html_ac10c025febba178c2f547be67db50c45"><div class="ttname"><a href="classnvn_tool_1_1texpkg_1_1_raw_image.html#ac10c025febba178c2f547be67db50c45">nvnTool::texpkg::RawImage::Create</a></div><div class="ttdeci">virtual TPError Create(NVNtextureTarget target, uint32_t width, uint32_t height, uint32_t depth, NVNformat format, uint32_t mipLevels, uint32_t subimages=1)=0</div><div class="ttdoc">Create the image and allocate its storage.</div></div>
<div class="ttc" id="anamespacenn_1_1fs_html_ad09dbc3816b9e95562081f9411711c4a"><div class="ttname"><a href="namespacenn_1_1fs.html#ad09dbc3816b9e95562081f9411711c4a">nn::fs::CreateDirectory</a></div><div class="ttdeci">Result CreateDirectory(const char *path) NN_NOEXCEPT</div><div class="ttdoc">Creates a directory.</div></div>
<div class="ttc" id="anvn_tool___glslc_interface_8h_html_a05b2032c99f789df2a34ebf32271c320"><div class="ttname"><a href="nvn_tool___glslc_interface_8h.html#a05b2032c99f789df2a34ebf32271c320">glslcFinalize</a></div><div class="ttdeci">GLSLCAPI void glslcFinalize(GLSLCcompileObject *compileObject)</div><div class="ttdoc">Cleans up any internal memory associated with a GLSLC compile.</div></div>
<div class="ttc" id="anvn_tool___glslc_interface_8h_html_a238b82c174a58d9f9e2be6aa3e8a5bfea6aa278f2aac6b0ff1b449861c069423b"><div class="ttname"><a href="nvn_tool___glslc_interface_8h.html#a238b82c174a58d9f9e2be6aa3e8a5bfea6aa278f2aac6b0ff1b449861c069423b">GLSLC_DEBUG_LEVEL_NONE</a></div><div class="ttdeci">@ GLSLC_DEBUG_LEVEL_NONE</div><div class="ttdoc">No debug information generated.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:299</div></div>
<div class="ttc" id="anvn_tool___glslc_interface_8h_html_a238b82c174a58d9f9e2be6aa3e8a5bfea81704ec256f338d05d20e0d618decdef"><div class="ttname"><a href="nvn_tool___glslc_interface_8h.html#a238b82c174a58d9f9e2be6aa3e8a5bfea81704ec256f338d05d20e0d618decdef">GLSLC_DEBUG_LEVEL_G0</a></div><div class="ttdeci">@ GLSLC_DEBUG_LEVEL_G0</div><div class="ttdoc">Minimal debug information required for GLSL source debugging.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:302</div></div>
<div class="ttc" id="anvn_tool___glslc_interface_8h_html_a2d6ec24544353b8978008330e2a1f52b"><div class="ttname"><a href="nvn_tool___glslc_interface_8h.html#a2d6ec24544353b8978008330e2a1f52b">GLSLClanguageTypeEnum</a></div><div class="ttdeci">GLSLClanguageTypeEnum</div><div class="ttdoc">Language the shaders should be compiled with.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:312</div></div>
<div class="ttc" id="anvn_tool___glslc_interface_8h_html_a2d6ec24544353b8978008330e2a1f52ba0cfa6af4f3bada8f5dbc6563d70fce1d"><div class="ttname"><a href="nvn_tool___glslc_interface_8h.html#a2d6ec24544353b8978008330e2a1f52ba0cfa6af4f3bada8f5dbc6563d70fce1d">GLSLC_LANGUAGE_GLSL</a></div><div class="ttdeci">@ GLSLC_LANGUAGE_GLSL</div><div class="ttdoc">OpenGL shading language (default)</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:314</div></div>
<div class="ttc" id="anvn_tool___glslc_interface_8h_html_a2d6ec24544353b8978008330e2a1f52ba7de6685da3123976fc56e312e02e92fd"><div class="ttname"><a href="nvn_tool___glslc_interface_8h.html#a2d6ec24544353b8978008330e2a1f52ba7de6685da3123976fc56e312e02e92fd">GLSLC_LANGUAGE_SPIRV</a></div><div class="ttdeci">@ GLSLC_LANGUAGE_SPIRV</div><div class="ttdoc">SPIR-V compilation.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:320</div></div>
<div class="ttc" id="anvn_tool___glslc_interface_8h_html_a648dfc0b503357a72dad03652fc31e57"><div class="ttname"><a href="nvn_tool___glslc_interface_8h.html#a648dfc0b503357a72dad03652fc31e57">glslcInitialize</a></div><div class="ttdeci">GLSLCAPI uint8_t glslcInitialize(GLSLCcompileObject *compileObject)</div><div class="ttdoc">Initializes the compile objects, setting up internal structures.</div></div>
<div class="ttc" id="anvn_tool___glslc_interface_8h_html_a64bdf010fc635ccc01dc9f1625557da1"><div class="ttname"><a href="nvn_tool___glslc_interface_8h.html#a64bdf010fc635ccc01dc9f1625557da1">glslcCompileSpecialized</a></div><div class="ttdeci">GLSLCAPI const GLSLCoutput *const  * glslcCompileSpecialized(GLSLCcompileObject *compileObject, const GLSLCspecializationBatch *specEntries)</div><div class="ttdoc">Compiles a specialized version of the binary using the input specialization information.</div></div>
<div class="ttc" id="anvn_tool___glslc_interface_8h_html_a71450a1e5f331c7e5a19404cbf63974a"><div class="ttname"><a href="nvn_tool___glslc_interface_8h.html#a71450a1e5f331c7e5a19404cbf63974a">GLSLCpiqTypeEnum</a></div><div class="ttdeci">GLSLCpiqTypeEnum</div><div class="ttdoc">For program interface query support, data types reported for shader elements will have types that cor...</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:111</div></div>
<div class="ttc" id="anvn_tool___glslc_interface_8h_html_a8a7629609d27a49283b8cb9587dcca48"><div class="ttname"><a href="nvn_tool___glslc_interface_8h.html#a8a7629609d27a49283b8cb9587dcca48">glslcCompilePreSpecialized</a></div><div class="ttdeci">GLSLCAPI bool glslcCompilePreSpecialized(GLSLCcompileObject *compileObject)</div><div class="ttdoc">Partially compiles to an intermediate representation so that future specialization compiles don't nee...</div></div>
<div class="ttc" id="anvn_tool___glslc_interface_8h_html_aab53ab9845cc7be41102195446759a59"><div class="ttname"><a href="nvn_tool___glslc_interface_8h.html#aab53ab9845cc7be41102195446759a59">GLSLCsectionTypeEnum</a></div><div class="ttdeci">GLSLCsectionTypeEnum</div><div class="ttdoc">Types for individual sections.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:371</div></div>
<div class="ttc" id="anvn_tool___glslc_interface_8h_html_ad03b8a64a7554065b0e7d9041b07bf17aaaf5953a0242150f9f7dfd36f14db547"><div class="ttname"><a href="nvn_tool___glslc_interface_8h.html#ad03b8a64a7554065b0e7d9041b07bf17aaaf5953a0242150f9f7dfd36f14db547">GLSLC_OPTLEVEL_DEFAULT</a></div><div class="ttdeci">@ GLSLC_OPTLEVEL_DEFAULT</div><div class="ttdoc">Default optimization level.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:336</div></div>
<div class="ttc" id="anvn_tool___glslc_interface_8h_html_ad0fd458cbbcd554a1dc81ac61fdcf7e3"><div class="ttname"><a href="nvn_tool___glslc_interface_8h.html#ad0fd458cbbcd554a1dc81ac61fdcf7e3">glslcCompile</a></div><div class="ttdeci">GLSLCAPI uint8_t glslcCompile(GLSLCcompileObject *compileObject)</div><div class="ttdoc">Compile source shaders using a previously initialized GLSLCcompileObject.</div></div>
<div class="ttc" id="astruct_g_l_s_l_cbuffer_variable_info_html"><div class="ttname"><a href="struct_g_l_s_l_cbuffer_variable_info.html">GLSLCbufferVariableInfo</a></div><div class="ttdoc">An information data section corresponding to individual buffer variables.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:615</div></div>
<div class="ttc" id="astruct_g_l_s_l_cbuffer_variable_info_html_a08300b2a95c6ac18e67859870d4e9f5e"><div class="ttname"><a href="struct_g_l_s_l_cbuffer_variable_info.html#a08300b2a95c6ac18e67859870d4e9f5e">GLSLCbufferVariableInfo::topLevelArrayStride</a></div><div class="ttdeci">uint32_t topLevelArrayStride</div><div class="ttdoc">Stride between elements of the top-level shader storage block member containing this active variable.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:652</div></div>
<div class="ttc" id="astruct_g_l_s_l_cbuffer_variable_info_html_a0d22663f76277236ff4fb5177be6ecab"><div class="ttname"><a href="struct_g_l_s_l_cbuffer_variable_info.html#a0d22663f76277236ff4fb5177be6ecab">GLSLCbufferVariableInfo::matrixStride</a></div><div class="ttdeci">int32_t matrixStride</div><div class="ttdoc">Specifies stride between columns/rows of matrix depending on isRowMajor.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:636</div></div>
<div class="ttc" id="astruct_g_l_s_l_cbuffer_variable_info_html_a16f5c0e7959077c3ce319414cfec1de0"><div class="ttname"><a href="struct_g_l_s_l_cbuffer_variable_info.html#a16f5c0e7959077c3ce319414cfec1de0">GLSLCbufferVariableInfo::isArray</a></div><div class="ttdeci">uint8_t isArray</div><div class="ttdoc">1 if this buffer variable is an array, otherwise 0</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:658</div></div>
<div class="ttc" id="astruct_g_l_s_l_cbuffer_variable_info_html_a24d15b6ca8a2cea8730efe490dd1acfc"><div class="ttname"><a href="struct_g_l_s_l_cbuffer_variable_info.html#a24d15b6ca8a2cea8730efe490dd1acfc">GLSLCbufferVariableInfo::blockOffset</a></div><div class="ttdeci">int32_t blockOffset</div><div class="ttdoc">The data offset (in bytes) of this variable inside it's owning buffer.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:626</div></div>
<div class="ttc" id="astruct_g_l_s_l_cbuffer_variable_info_html_a3433d01de972916c358960ad5fcec9c5"><div class="ttname"><a href="struct_g_l_s_l_cbuffer_variable_info.html#a3433d01de972916c358960ad5fcec9c5">GLSLCbufferVariableInfo::stagesReferencedIn</a></div><div class="ttdeci">NVNshaderStageBits stagesReferencedIn</div><div class="ttdoc">Stage mask representing which stages this variable is active in.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:655</div></div>
<div class="ttc" id="astruct_g_l_s_l_cbuffer_variable_info_html_a466ccaee49d1413ec7f7184f7d2a85d6"><div class="ttname"><a href="struct_g_l_s_l_cbuffer_variable_info.html#a466ccaee49d1413ec7f7184f7d2a85d6">GLSLCbufferVariableInfo::topLevelArraySize</a></div><div class="ttdeci">uint32_t topLevelArraySize</div><div class="ttdoc">Number of active elements of the top-level shader storage block member containing this variable.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:645</div></div>
<div class="ttc" id="astruct_g_l_s_l_cbuffer_variable_info_html_a521155bc7f5002ccee977558beb61be1"><div class="ttname"><a href="struct_g_l_s_l_cbuffer_variable_info.html#a521155bc7f5002ccee977558beb61be1">GLSLCbufferVariableInfo::blockNdx</a></div><div class="ttdeci">int32_t blockNdx</div><div class="ttdoc">The index into the corresponding buffer.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:623</div></div>
<div class="ttc" id="astruct_g_l_s_l_cbuffer_variable_info_html_a6a6529d21d70fd27bbe6a2ccb73ed1bd"><div class="ttname"><a href="struct_g_l_s_l_cbuffer_variable_info.html#a6a6529d21d70fd27bbe6a2ccb73ed1bd">GLSLCbufferVariableInfo::sizeOfArray</a></div><div class="ttdeci">uint32_t sizeOfArray</div><div class="ttdoc">Size of the array if the buffer variable is an array, otherwise 1.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:630</div></div>
<div class="ttc" id="astruct_g_l_s_l_cbuffer_variable_info_html_a6abfac65135a571801c732499a96be1b"><div class="ttname"><a href="struct_g_l_s_l_cbuffer_variable_info.html#a6abfac65135a571801c732499a96be1b">GLSLCbufferVariableInfo::nameInfo</a></div><div class="ttdeci">GLSLCpiqName nameInfo</div><div class="ttdoc">Info about the name in the data string pool.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:617</div></div>
<div class="ttc" id="astruct_g_l_s_l_cbuffer_variable_info_html_a8f47eb13e0c6661f56ce44f048f8ad2e"><div class="ttname"><a href="struct_g_l_s_l_cbuffer_variable_info.html#a8f47eb13e0c6661f56ce44f048f8ad2e">GLSLCbufferVariableInfo::isRowMajor</a></div><div class="ttdeci">uint32_t isRowMajor</div><div class="ttdoc">Specifies whether row major or column major.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:639</div></div>
<div class="ttc" id="astruct_g_l_s_l_cbuffer_variable_info_html_aaa3b140607700cf5a743a861df990efb"><div class="ttname"><a href="struct_g_l_s_l_cbuffer_variable_info.html#aaa3b140607700cf5a743a861df990efb">GLSLCbufferVariableInfo::type</a></div><div class="ttdeci">GLSLCpiqTypeEnum type</div><div class="ttdoc">The data type of this buffer variable.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:620</div></div>
<div class="ttc" id="astruct_g_l_s_l_cgpu_code_header_html"><div class="ttname"><a href="struct_g_l_s_l_cgpu_code_header.html">GLSLCgpuCodeHeader</a></div><div class="ttdoc">GPU code section header containing GPU code for an individual shader stage.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1168</div></div>
<div class="ttc" id="astruct_g_l_s_l_cgpu_code_header_html_a210237850b30911ca52acf10d628bc0e"><div class="ttname"><a href="struct_g_l_s_l_cgpu_code_header.html#a210237850b30911ca52acf10d628bc0e">GLSLCgpuCodeHeader::perfStatsSectionNdx</a></div><div class="ttdeci">uint32_t perfStatsSectionNdx</div><div class="ttdoc">Section index for the corresponding perf stats (if requested).</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1210</div></div>
<div class="ttc" id="astruct_g_l_s_l_cgpu_code_header_html_a2617848640a161d41ed59f1a7c0ccb35"><div class="ttname"><a href="struct_g_l_s_l_cgpu_code_header.html#a2617848640a161d41ed59f1a7c0ccb35">GLSLCgpuCodeHeader::dataSize</a></div><div class="ttdeci">uint32_t dataSize</div><div class="ttdoc">The size of the data portion of the stream in bytes.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1181</div></div>
<div class="ttc" id="astruct_g_l_s_l_cgpu_code_header_html_a3b606fedf8582a1a47162d210e8a1448"><div class="ttname"><a href="struct_g_l_s_l_cgpu_code_header.html#a3b606fedf8582a1a47162d210e8a1448">GLSLCgpuCodeHeader::controlOffset</a></div><div class="ttdeci">uint32_t controlOffset</div><div class="ttdoc">The offset within the data of the control section, in bytes.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1175</div></div>
<div class="ttc" id="astruct_g_l_s_l_cgpu_code_header_html_aafdececf784595d922fe1b95b06db976"><div class="ttname"><a href="struct_g_l_s_l_cgpu_code_header.html#aafdececf784595d922fe1b95b06db976">GLSLCgpuCodeHeader::dataOffset</a></div><div class="ttdeci">uint32_t dataOffset</div><div class="ttdoc">The offset within the data of the GPU code data section in bytes.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1178</div></div>
<div class="ttc" id="astruct_g_l_s_l_cgpu_code_header_html_ab1e6be676a326a7281e18ad3a4607ced"><div class="ttname"><a href="struct_g_l_s_l_cgpu_code_header.html#ab1e6be676a326a7281e18ad3a4607ced">GLSLCgpuCodeHeader::stage</a></div><div class="ttdeci">NVNshaderStage stage</div><div class="ttdoc">The shader stage this corresponds to.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1172</div></div>
<div class="ttc" id="astruct_g_l_s_l_cgpu_code_header_html_ac8b1eef84fa9f0debec1874f8b570e62"><div class="ttname"><a href="struct_g_l_s_l_cgpu_code_header.html#ac8b1eef84fa9f0debec1874f8b570e62">GLSLCgpuCodeHeader::scratchMemBytesRecommended</a></div><div class="ttdeci">uint32_t scratchMemBytesRecommended</div><div class="ttdoc">The total amount of local memory recommended for this program on a NX device.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1204</div></div>
<div class="ttc" id="astruct_g_l_s_l_cgpu_code_header_html_aff5295c90f2dc5eb969fb14660f31712"><div class="ttname"><a href="struct_g_l_s_l_cgpu_code_header.html#aff5295c90f2dc5eb969fb14660f31712">GLSLCgpuCodeHeader::controlSize</a></div><div class="ttdeci">uint32_t controlSize</div><div class="ttdoc">The size of the control portion of the stream in bytes.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1184</div></div>
<div class="ttc" id="astruct_g_l_s_l_cinclude_info_html_a8e083ff029a90d02e6b48df28eab6fd3"><div class="ttname"><a href="struct_g_l_s_l_cinclude_info.html#a8e083ff029a90d02e6b48df28eab6fd3">GLSLCincludeInfo::numPaths</a></div><div class="ttdeci">uint32_t numPaths</div><div class="ttdoc">Number of include paths that are included in the paths variable.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:712</div></div>
<div class="ttc" id="astruct_g_l_s_l_cnon_spill_l_mem_html_a27760cf751240260637a72447d127bb6"><div class="ttname"><a href="struct_g_l_s_l_cnon_spill_l_mem.html#a27760cf751240260637a72447d127bb6">GLSLCnonSpillLMem::loadBytes</a></div><div class="ttdeci">uint32_t loadBytes</div><div class="ttdoc">Amount of local memory read by loads other than refill loads.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1322</div></div>
<div class="ttc" id="astruct_g_l_s_l_cnon_spill_l_mem_html_a76ddc6e0aedfd37e36aa7d7d5d96a909"><div class="ttname"><a href="struct_g_l_s_l_cnon_spill_l_mem.html#a76ddc6e0aedfd37e36aa7d7d5d96a909">GLSLCnonSpillLMem::size</a></div><div class="ttdeci">uint32_t size</div><div class="ttdoc">Amount of local memory used not including extra memory required for divergence handling.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1328</div></div>
<div class="ttc" id="astruct_g_l_s_l_cnon_spill_l_mem_html_a9e9f1b81107865e233a351231841e6f6"><div class="ttname"><a href="struct_g_l_s_l_cnon_spill_l_mem.html#a9e9f1b81107865e233a351231841e6f6">GLSLCnonSpillLMem::storeBytes</a></div><div class="ttdeci">uint32_t storeBytes</div><div class="ttdoc">Amount of local memory written by stores other than spill sotres.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1325</div></div>
<div class="ttc" id="astruct_g_l_s_l_coption_flags_html_a5a5caa709a472ef0abfc98e609557e88"><div class="ttname"><a href="struct_g_l_s_l_coption_flags.html#a5a5caa709a472ef0abfc98e609557e88">GLSLCoptionFlags::optLevel</a></div><div class="ttdeci">GLSLCoptLevelEnum optLevel</div><div class="ttdoc">Optimization level for which to compile the shaders.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:855</div></div>
<div class="ttc" id="astruct_g_l_s_l_coption_flags_html_a723afb9e18cdf4c92bfe315c94e37c96"><div class="ttname"><a href="struct_g_l_s_l_coption_flags.html#a723afb9e18cdf4c92bfe315c94e37c96">GLSLCoptionFlags::outputShaderReflection</a></div><div class="ttdeci">uint32_t outputShaderReflection</div><div class="ttdoc">Output shader reflection data.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:814</div></div>
<div class="ttc" id="astruct_g_l_s_l_coption_flags_html_ac0396d28c3ec928aaa280cb90e71f485"><div class="ttname"><a href="struct_g_l_s_l_coption_flags.html#ac0396d28c3ec928aaa280cb90e71f485">GLSLCoptionFlags::outputAssembly</a></div><div class="ttdeci">uint32_t outputAssembly</div><div class="ttdoc">Include an assembly dump section in the GLSLCoutput.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:804</div></div>
<div class="ttc" id="astruct_g_l_s_l_coption_flags_html_ac8db49e611084ad2bf89db26904fe4d4"><div class="ttname"><a href="struct_g_l_s_l_coption_flags.html#ac8db49e611084ad2bf89db26904fe4d4">GLSLCoptionFlags::language</a></div><div class="ttdeci">GLSLClanguageTypeEnum language</div><div class="ttdoc">Specify the language of the input shaders.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:817</div></div>
<div class="ttc" id="astruct_g_l_s_l_coption_flags_html_ad57cedc549a410a87a8b5e667afd31b9"><div class="ttname"><a href="struct_g_l_s_l_coption_flags.html#ad57cedc549a410a87a8b5e667afd31b9">GLSLCoptionFlags::outputPerfStats</a></div><div class="ttdeci">uint32_t outputPerfStats</div><div class="ttdoc">Output individual perf statistics for each compiled binary.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:811</div></div>
<div class="ttc" id="astruct_g_l_s_l_coption_flags_html_aec0779a250ad31f6deafe470820ffbb8"><div class="ttname"><a href="struct_g_l_s_l_coption_flags.html#aec0779a250ad31f6deafe470820ffbb8">GLSLCoptionFlags::outputGpuBinaries</a></div><div class="ttdeci">uint32_t outputGpuBinaries</div><div class="ttdoc">Output individual program binary sections in the GLSLCoutput.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:808</div></div>
<div class="ttc" id="astruct_g_l_s_l_coption_flags_html_af2b81192a389ab5093f074ced7ceea29"><div class="ttname"><a href="struct_g_l_s_l_coption_flags.html#af2b81192a389ab5093f074ced7ceea29">GLSLCoptionFlags::outputDebugInfo</a></div><div class="ttdeci">GLSLCdebugInfoLevelEnum outputDebugInfo</div><div class="ttdoc">Level of debug information to generate.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:820</div></div>
<div class="ttc" id="astruct_g_l_s_l_coption_flags_html_af673dc6b82db05442d203619be5a022d"><div class="ttname"><a href="struct_g_l_s_l_coption_flags.html#af673dc6b82db05442d203619be5a022d">GLSLCoptionFlags::glslSeparable</a></div><div class="ttdeci">uint32_t glslSeparable</div><div class="ttdoc">Treat the GLSLC object as separable.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:800</div></div>
<div class="ttc" id="astruct_g_l_s_l_coptions_html"><div class="ttname"><a href="struct_g_l_s_l_coptions.html">GLSLCoptions</a></div><div class="ttdoc">Options structure to control compilation phase, what gets output in the GLSLCOutput structure.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:928</div></div>
<div class="ttc" id="astruct_g_l_s_l_coptions_html_a2b07e6d6a4984f7922cab3efbf8caf16"><div class="ttname"><a href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">GLSLCoptions::optionFlags</a></div><div class="ttdeci">GLSLCoptionFlags optionFlags</div><div class="ttdoc">A structure used for controlling which outputs are emitted in the GLSLCoutput section and for specify...</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:934</div></div>
<div class="ttc" id="astruct_g_l_s_l_coptions_html_ab5a776f09115d6e36fd37988abf15530"><div class="ttname"><a href="struct_g_l_s_l_coptions.html#ab5a776f09115d6e36fd37988abf15530">GLSLCoptions::includeInfo</a></div><div class="ttdeci">GLSLCincludeInfo includeInfo</div><div class="ttdoc">A structure used for setting include paths.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:937</div></div>
<div class="ttc" id="astruct_g_l_s_l_coutput_html"><div class="ttname"><a href="struct_g_l_s_l_coutput.html">GLSLCoutput</a></div><div class="ttdoc">Main GLSLC output structure.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1474</div></div>
<div class="ttc" id="astruct_g_l_s_l_coutput_html_a69ff5a7c06d39592caacec94be810995"><div class="ttname"><a href="struct_g_l_s_l_coutput.html#a69ff5a7c06d39592caacec94be810995">GLSLCoutput::headers</a></div><div class="ttdeci">GLSLCsectionHeaderUnion headers[1]</div><div class="ttdoc">Array of section headers for this output structure.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1502</div></div>
<div class="ttc" id="astruct_g_l_s_l_coutput_html_a6cbb6ec5e8a4ff04512fd1c442aa3d92"><div class="ttname"><a href="struct_g_l_s_l_coutput.html#a6cbb6ec5e8a4ff04512fd1c442aa3d92">GLSLCoutput::numSections</a></div><div class="ttdeci">uint32_t numSections</div><div class="ttdoc">Number of sections contained in the binary.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1497</div></div>
<div class="ttc" id="astruct_g_l_s_l_coutput_html_ac6e8159c6357796e5c51b6eb91f279b7"><div class="ttname"><a href="struct_g_l_s_l_coutput.html#ac6e8159c6357796e5c51b6eb91f279b7">GLSLCoutput::size</a></div><div class="ttdeci">uint32_t size</div><div class="ttdoc">Total size of the output (in bytes).</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1490</div></div>
<div class="ttc" id="astruct_g_l_s_l_cperf_stats_data_html"><div class="ttname"><a href="struct_g_l_s_l_cperf_stats_data.html">GLSLCperfStatsData</a></div><div class="ttdoc">Data containing the perf statistics returned from GLSLC.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1383</div></div>
<div class="ttc" id="astruct_g_l_s_l_cperf_stats_data_html_a169e086f11fc356a04df91af96b31d08"><div class="ttname"><a href="struct_g_l_s_l_cperf_stats_data.html#a169e086f11fc356a04df91af96b31d08">GLSLCperfStatsData::attributeMemUsage</a></div><div class="ttdeci">uint32_t attributeMemUsage</div><div class="ttdoc">Attribute memory usage in bytes.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1410</div></div>
<div class="ttc" id="astruct_g_l_s_l_cperf_stats_data_html_a9adc6910a33636f8688ad1231d0ad293"><div class="ttname"><a href="struct_g_l_s_l_cperf_stats_data.html#a9adc6910a33636f8688ad1231d0ad293">GLSLCperfStatsData::nonSpillLMem</a></div><div class="ttdeci">GLSLCnonSpillLMem nonSpillLMem</div><div class="ttdoc">Non-spill memory data.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1392</div></div>
<div class="ttc" id="astruct_g_l_s_l_cperf_stats_data_html_abe4198110a02135c0941513d8493017f"><div class="ttname"><a href="struct_g_l_s_l_cperf_stats_data.html#abe4198110a02135c0941513d8493017f">GLSLCperfStatsData::programSize</a></div><div class="ttdeci">uint32_t programSize</div><div class="ttdoc">Program size in bytes.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1413</div></div>
<div class="ttc" id="astruct_g_l_s_l_cperf_stats_data_html_ad66aa359d1cadbb6680fe56c8084c48b"><div class="ttname"><a href="struct_g_l_s_l_cperf_stats_data.html#ad66aa359d1cadbb6680fe56c8084c48b">GLSLCperfStatsData::numDivergentBranches</a></div><div class="ttdeci">uint32_t numDivergentBranches</div><div class="ttdoc">Number of divergent branches.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1407</div></div>
<div class="ttc" id="astruct_g_l_s_l_cperf_stats_data_html_ad91e1581425b17e18ef6603d9f1fde22"><div class="ttname"><a href="struct_g_l_s_l_cperf_stats_data.html#ad91e1581425b17e18ef6603d9f1fde22">GLSLCperfStatsData::occupancy</a></div><div class="ttdeci">float occupancy</div><div class="ttdoc">Occupancy is the ratio of active warps to maximum number of warps supported.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1404</div></div>
<div class="ttc" id="astruct_g_l_s_l_cperf_stats_data_html_ae368ee8152d78e81cd42094c5d7f08a4"><div class="ttname"><a href="struct_g_l_s_l_cperf_stats_data.html#ae368ee8152d78e81cd42094c5d7f08a4">GLSLCperfStatsData::spillMem</a></div><div class="ttdeci">GLSLCspillLMem spillMem</div><div class="ttdoc">Spill memory data.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1389</div></div>
<div class="ttc" id="astruct_g_l_s_l_cperf_stats_data_html_aeba2f57d7a5786cfac325cd5ea99250c"><div class="ttname"><a href="struct_g_l_s_l_cperf_stats_data.html#aeba2f57d7a5786cfac325cd5ea99250c">GLSLCperfStatsData::latency</a></div><div class="ttdeci">uint32_t latency</div><div class="ttdoc">Cycles per pixel.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1401</div></div>
<div class="ttc" id="astruct_g_l_s_l_cperf_stats_data_html_af787142790d854a42032ec6998ed5658"><div class="ttname"><a href="struct_g_l_s_l_cperf_stats_data.html#af787142790d854a42032ec6998ed5658">GLSLCperfStatsData::throughputLimiter</a></div><div class="ttdeci">GLSLCthroughputLimiter throughputLimiter</div><div class="ttdoc">Throughput limiter information.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1395</div></div>
<div class="ttc" id="astruct_g_l_s_l_cperf_stats_header_html"><div class="ttname"><a href="struct_g_l_s_l_cperf_stats_header.html">GLSLCperfStatsHeader</a></div><div class="ttdoc">Header for perf statistics.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1250</div></div>
<div class="ttc" id="astruct_g_l_s_l_cpiq_name_html_a95cb55a78c99bc13a5442a4ec038fe64"><div class="ttname"><a href="struct_g_l_s_l_cpiq_name.html#a95cb55a78c99bc13a5442a4ec038fe64">GLSLCpiqName::nameOffset</a></div><div class="ttdeci">uint32_t nameOffset</div><div class="ttdoc">Offset of the name into the data string pool.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:398</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_input_info_html"><div class="ttname"><a href="struct_g_l_s_l_cprogram_input_info.html">GLSLCprogramInputInfo</a></div><div class="ttdoc">An information data section corresponding to individual attributes.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:530</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_input_info_html_a0924d76ca260a63649cc6409a5084541"><div class="ttname"><a href="struct_g_l_s_l_cprogram_input_info.html#a0924d76ca260a63649cc6409a5084541">GLSLCprogramInputInfo::isPerPatch</a></div><div class="ttdeci">uint8_t isPerPatch</div><div class="ttdoc">1 if this input is per patch, 0 otherwise.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:551</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_input_info_html_a30e2dc0f471667ac41cdde8329d71e25"><div class="ttname"><a href="struct_g_l_s_l_cprogram_input_info.html#a30e2dc0f471667ac41cdde8329d71e25">GLSLCprogramInputInfo::nameInfo</a></div><div class="ttdeci">GLSLCpiqName nameInfo</div><div class="ttdoc">Info about the name in the data string pool.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:532</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_input_info_html_aa850abcd72ca572b118cea86cc858af7"><div class="ttname"><a href="struct_g_l_s_l_cprogram_input_info.html#aa850abcd72ca572b118cea86cc858af7">GLSLCprogramInputInfo::stagesReferencedIn</a></div><div class="ttdeci">NVNshaderStageBits stagesReferencedIn</div><div class="ttdoc">Stage mask representing which stages this variable is active in.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:545</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_input_info_html_ac0100c9580f95e97b101ae505680bef0"><div class="ttname"><a href="struct_g_l_s_l_cprogram_input_info.html#ac0100c9580f95e97b101ae505680bef0">GLSLCprogramInputInfo::location</a></div><div class="ttdeci">int32_t location</div><div class="ttdoc">Location this input is assigned to.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:542</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_input_info_html_ade21acdb8e7f5d6fb2023f96a0770e84"><div class="ttname"><a href="struct_g_l_s_l_cprogram_input_info.html#ade21acdb8e7f5d6fb2023f96a0770e84">GLSLCprogramInputInfo::sizeOfArray</a></div><div class="ttdeci">uint32_t sizeOfArray</div><div class="ttdoc">Number of array elements if the input is an array, 1 otherwise.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:538</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_input_info_html_af409a6a5d837178521fd638d0e19140f"><div class="ttname"><a href="struct_g_l_s_l_cprogram_input_info.html#af409a6a5d837178521fd638d0e19140f">GLSLCprogramInputInfo::type</a></div><div class="ttdeci">GLSLCpiqTypeEnum type</div><div class="ttdoc">The data type of this input.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:535</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_input_info_html_af5f932dc8d34d953489986516b2aa632"><div class="ttname"><a href="struct_g_l_s_l_cprogram_input_info.html#af5f932dc8d34d953489986516b2aa632">GLSLCprogramInputInfo::isArray</a></div><div class="ttdeci">uint8_t isArray</div><div class="ttdoc">1 if this input is an array, 0 if otherwise.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:548</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_reflection_header_html"><div class="ttname"><a href="struct_g_l_s_l_cprogram_reflection_header.html">GLSLCprogramReflectionHeader</a></div><div class="ttdoc">Program reflection data header.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1088</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_reflection_header_html_a006944206bfbf2bbfb56c1dfb9dc7f96"><div class="ttname"><a href="struct_g_l_s_l_cprogram_reflection_header.html#a006944206bfbf2bbfb56c1dfb9dc7f96">GLSLCprogramReflectionHeader::numUniformBlocks</a></div><div class="ttdeci">uint32_t numUniformBlocks</div><div class="ttdoc">Number of uniform blocks.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1092</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_reflection_header_html_a0bf19ae5c6027329eec9480f13c71d3c"><div class="ttname"><a href="struct_g_l_s_l_cprogram_reflection_header.html#a0bf19ae5c6027329eec9480f13c71d3c">GLSLCprogramReflectionHeader::numUniforms</a></div><div class="ttdeci">uint32_t numUniforms</div><div class="ttdoc">Number of uniforms.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1098</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_reflection_header_html_a23a3fcd75086c2b537f992e212661622"><div class="ttname"><a href="struct_g_l_s_l_cprogram_reflection_header.html#a23a3fcd75086c2b537f992e212661622">GLSLCprogramReflectionHeader::stringPoolOffset</a></div><div class="ttdeci">uint32_t stringPoolOffset</div><div class="ttdoc">Offset into data section for the string pool data.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1137</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_reflection_header_html_a2eb867701544eef24f9bece544e729de"><div class="ttname"><a href="struct_g_l_s_l_cprogram_reflection_header.html#a2eb867701544eef24f9bece544e729de">GLSLCprogramReflectionHeader::numBufferVariables</a></div><div class="ttdeci">uint32_t numBufferVariables</div><div class="ttdoc">Number of buffer variables.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1122</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_reflection_header_html_a68f8f5f1cb9eb0fa3039a28512f8cdda"><div class="ttname"><a href="struct_g_l_s_l_cprogram_reflection_header.html#a68f8f5f1cb9eb0fa3039a28512f8cdda">GLSLCprogramReflectionHeader::numSsbo</a></div><div class="ttdeci">uint32_t numSsbo</div><div class="ttdoc">Number of shader storage buffers.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1116</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_reflection_header_html_a7116c27cf2638894a145fcdbb7d05568"><div class="ttname"><a href="struct_g_l_s_l_cprogram_reflection_header.html#a7116c27cf2638894a145fcdbb7d05568">GLSLCprogramReflectionHeader::uniformOffset</a></div><div class="ttdeci">uint32_t uniformOffset</div><div class="ttdoc">Offset into data section for the uniform reflection data.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1101</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_reflection_header_html_a89cea5a299e8cf987babd8e2a93994f2"><div class="ttname"><a href="struct_g_l_s_l_cprogram_reflection_header.html#a89cea5a299e8cf987babd8e2a93994f2">GLSLCprogramReflectionHeader::bufferVariableOffset</a></div><div class="ttdeci">uint32_t bufferVariableOffset</div><div class="ttdoc">Offset into data section for the buffer variable data.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1125</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_reflection_header_html_a9f264ef95c68193971b360b4df2f259d"><div class="ttname"><a href="struct_g_l_s_l_cprogram_reflection_header.html#a9f264ef95c68193971b360b4df2f259d">GLSLCprogramReflectionHeader::programInputsOffset</a></div><div class="ttdeci">uint32_t programInputsOffset</div><div class="ttdoc">Offset into data section for the program input.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1107</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_reflection_header_html_ab7239cf2349bda4632d8382ffddcde85"><div class="ttname"><a href="struct_g_l_s_l_cprogram_reflection_header.html#ab7239cf2349bda4632d8382ffddcde85">GLSLCprogramReflectionHeader::uniformBlockOffset</a></div><div class="ttdeci">uint32_t uniformBlockOffset</div><div class="ttdoc">Offset into data section for the uniform block reflection data.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1095</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_reflection_header_html_aca10eea8e482a030016556875aec0a7f"><div class="ttname"><a href="struct_g_l_s_l_cprogram_reflection_header.html#aca10eea8e482a030016556875aec0a7f">GLSLCprogramReflectionHeader::numProgramInputs</a></div><div class="ttdeci">uint32_t numProgramInputs</div><div class="ttdoc">Number of program inputs.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1104</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_reflection_header_html_af58251371ee656b318f40dec153c4837"><div class="ttname"><a href="struct_g_l_s_l_cprogram_reflection_header.html#af58251371ee656b318f40dec153c4837">GLSLCprogramReflectionHeader::ssboOffset</a></div><div class="ttdeci">uint32_t ssboOffset</div><div class="ttdoc">Offset into data section for the shader storage block data.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1119</div></div>
<div class="ttc" id="astruct_g_l_s_l_csection_header_common_html_a6a8aed7a5a7e82acff908d084fd85e4a"><div class="ttname"><a href="struct_g_l_s_l_csection_header_common.html#a6a8aed7a5a7e82acff908d084fd85e4a">GLSLCsectionHeaderCommon::type</a></div><div class="ttdeci">GLSLCsectionTypeEnum type</div><div class="ttdoc">Type of section.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1047</div></div>
<div class="ttc" id="astruct_g_l_s_l_csection_header_common_html_abb6e96b70bad30c94477317328d384d5"><div class="ttname"><a href="struct_g_l_s_l_csection_header_common.html#abb6e96b70bad30c94477317328d384d5">GLSLCsectionHeaderCommon::dataOffset</a></div><div class="ttdeci">uint32_t dataOffset</div><div class="ttdoc">Offset of the data section, in bytes, relative to the top-level structure containing the section head...</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1044</div></div>
<div class="ttc" id="astruct_g_l_s_l_cspecialization_batch_html"><div class="ttname"><a href="struct_g_l_s_l_cspecialization_batch.html">GLSLCspecializationBatch</a></div><div class="ttdoc">Used for &quot;batch&quot; mode processing, contains multiple specialization sets.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:784</div></div>
<div class="ttc" id="astruct_g_l_s_l_cspecialization_batch_html_a0be46d42422ea32ebcc5e31ca3016484"><div class="ttname"><a href="struct_g_l_s_l_cspecialization_batch.html#a0be46d42422ea32ebcc5e31ca3016484">GLSLCspecializationBatch::numEntries</a></div><div class="ttdeci">uint32_t numEntries</div><div class="ttdoc">Number of sets in the array entries</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:789</div></div>
<div class="ttc" id="astruct_g_l_s_l_cspecialization_set_html"><div class="ttname"><a href="struct_g_l_s_l_cspecialization_set.html">GLSLCspecializationSet</a></div><div class="ttdoc">Used to specify a set of uniforms to be specialized.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:772</div></div>
<div class="ttc" id="astruct_g_l_s_l_cspecialization_uniform_html"><div class="ttname"><a href="struct_g_l_s_l_cspecialization_uniform.html">GLSLCspecializationUniform</a></div><div class="ttdoc">Each element corresponds to a single uniform.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:736</div></div>
<div class="ttc" id="astruct_g_l_s_l_cspecialization_uniform_html_a08e7a735c1dc18c6ba868ffaac434386"><div class="ttname"><a href="struct_g_l_s_l_cspecialization_uniform.html#a08e7a735c1dc18c6ba868ffaac434386">GLSLCspecializationUniform::elementSize</a></div><div class="ttdeci">uint8_t elementSize</div><div class="ttdoc">Size of each uniform in the array in bytes.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:766</div></div>
<div class="ttc" id="astruct_g_l_s_l_cspecialization_uniform_html_a1ef3404ed2eb660b125cf84201ec0973"><div class="ttname"><a href="struct_g_l_s_l_cspecialization_uniform.html#a1ef3404ed2eb660b125cf84201ec0973">GLSLCspecializationUniform::numElements</a></div><div class="ttdeci">uint32_t numElements</div><div class="ttdoc">Number of uniforms in the array.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:760</div></div>
<div class="ttc" id="astruct_g_l_s_l_cspill_l_mem_html_a41a1bf5449af1806420a1160482adb1e"><div class="ttname"><a href="struct_g_l_s_l_cspill_l_mem.html#a41a1bf5449af1806420a1160482adb1e">GLSLCspillLMem::numSmemRefillBytes</a></div><div class="ttdeci">uint32_t numSmemRefillBytes</div><div class="ttdoc">Amount of shared memory read due to refills.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1311</div></div>
<div class="ttc" id="astruct_g_l_s_l_cspill_l_mem_html_a6cfdf0aeb653422164babeffc41b4b68"><div class="ttname"><a href="struct_g_l_s_l_cspill_l_mem.html#a6cfdf0aeb653422164babeffc41b4b68">GLSLCspillLMem::size</a></div><div class="ttdeci">uint32_t size</div><div class="ttdoc">Amount of local memory used in the shader not including extra memory required for divergence handling...</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1315</div></div>
<div class="ttc" id="astruct_g_l_s_l_cspill_l_mem_html_ad224d4137a67b9e8009302ce36351305"><div class="ttname"><a href="struct_g_l_s_l_cspill_l_mem.html#ad224d4137a67b9e8009302ce36351305">GLSLCspillLMem::numLmemSpillBytes</a></div><div class="ttdeci">uint32_t numLmemSpillBytes</div><div class="ttdoc">Amount of local memory written due to spills.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1302</div></div>
<div class="ttc" id="astruct_g_l_s_l_cspill_l_mem_html_ad2e83c16dc5264df509f512c3807705b"><div class="ttname"><a href="struct_g_l_s_l_cspill_l_mem.html#ad2e83c16dc5264df509f512c3807705b">GLSLCspillLMem::numSmemSpillBytes</a></div><div class="ttdeci">uint32_t numSmemSpillBytes</div><div class="ttdoc">Amount of shared memory written due to spills.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1308</div></div>
<div class="ttc" id="astruct_g_l_s_l_cspill_l_mem_html_af6b39e00e63c8a8e0f7e0b6873221e1a"><div class="ttname"><a href="struct_g_l_s_l_cspill_l_mem.html#af6b39e00e63c8a8e0f7e0b6873221e1a">GLSLCspillLMem::numLmemRefillBytes</a></div><div class="ttdeci">uint32_t numLmemRefillBytes</div><div class="ttdoc">Amount of local memory read due to refills.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1305</div></div>
<div class="ttc" id="astruct_g_l_s_l_cssbo_info_html"><div class="ttname"><a href="struct_g_l_s_l_cssbo_info.html">GLSLCssboInfo</a></div><div class="ttdoc">An information data section corresponding to individual shader storage blocks.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:589</div></div>
<div class="ttc" id="astruct_g_l_s_l_cssbo_info_html_a3f326bfbaa4cd4e3fe1dbc2930e04109"><div class="ttname"><a href="struct_g_l_s_l_cssbo_info.html#a3f326bfbaa4cd4e3fe1dbc2930e04109">GLSLCssboInfo::size</a></div><div class="ttdeci">uint32_t size</div><div class="ttdoc">Size (in bytes) of the shader storage block.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:594</div></div>
<div class="ttc" id="astruct_g_l_s_l_cssbo_info_html_a5395331b65a710af72231721f0d5b6ee"><div class="ttname"><a href="struct_g_l_s_l_cssbo_info.html#a5395331b65a710af72231721f0d5b6ee">GLSLCssboInfo::numActiveVariables</a></div><div class="ttdeci">uint32_t numActiveVariables</div><div class="ttdoc">Number of active variables assigned to the shader storage block.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:597</div></div>
<div class="ttc" id="astruct_g_l_s_l_cssbo_info_html_a711a0e9191f46d742ad5bac2fe34106b"><div class="ttname"><a href="struct_g_l_s_l_cssbo_info.html#a711a0e9191f46d742ad5bac2fe34106b">GLSLCssboInfo::stagesReferencedIn</a></div><div class="ttdeci">NVNshaderStageBits stagesReferencedIn</div><div class="ttdoc">Stage mask representing which stages this variable is active in.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:608</div></div>
<div class="ttc" id="astruct_g_l_s_l_cssbo_info_html_aa6932c7eacfab053588e669f5982c1f0"><div class="ttname"><a href="struct_g_l_s_l_cssbo_info.html#aa6932c7eacfab053588e669f5982c1f0">GLSLCssboInfo::nameInfo</a></div><div class="ttdeci">GLSLCpiqName nameInfo</div><div class="ttdoc">Info about the name in the data string pool.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:591</div></div>
<div class="ttc" id="astruct_g_l_s_l_cssbo_info_html_ad1d55cda38a2560e420a630e50a74897"><div class="ttname"><a href="struct_g_l_s_l_cssbo_info.html#ad1d55cda38a2560e420a630e50a74897">GLSLCssboInfo::bindings</a></div><div class="ttdeci">int32_t bindings[GLSLC_NUM_SHADER_STAGES]</div><div class="ttdoc">Bindings associated with this SSBO in each shader stage, where array ndx n corresponds to NVNshaderSt...</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:605</div></div>
<div class="ttc" id="astruct_g_l_s_l_cthroughput_limiter_html_a374b65adbd7ae380a465089bbbc29bab"><div class="ttname"><a href="struct_g_l_s_l_cthroughput_limiter.html#a374b65adbd7ae380a465089bbbc29bab">GLSLCthroughputLimiter::ipa</a></div><div class="ttdeci">float ipa</div><div class="ttdoc">Attribute interpolation limited throughput.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1348</div></div>
<div class="ttc" id="astruct_g_l_s_l_cthroughput_limiter_html_a53a2616c9cc95e2656c12cfa10266485"><div class="ttname"><a href="struct_g_l_s_l_cthroughput_limiter.html#a53a2616c9cc95e2656c12cfa10266485">GLSLCthroughputLimiter::trancedental</a></div><div class="ttdeci">float trancedental</div><div class="ttdoc">Transcendental, Conversion operation limited throughput.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1345</div></div>
<div class="ttc" id="astruct_g_l_s_l_cthroughput_limiter_html_a681850c900eb4aacb11bce98483831c7"><div class="ttname"><a href="struct_g_l_s_l_cthroughput_limiter.html#a681850c900eb4aacb11bce98483831c7">GLSLCthroughputLimiter::texLoadStore</a></div><div class="ttdeci">float texLoadStore</div><div class="ttdoc">Texture fetch, global/local load/store limited throughput.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1357</div></div>
<div class="ttc" id="astruct_g_l_s_l_cthroughput_limiter_html_a77999a2646e730fb536abb4263f9cd19"><div class="ttname"><a href="struct_g_l_s_l_cthroughput_limiter.html#a77999a2646e730fb536abb4263f9cd19">GLSLCthroughputLimiter::half</a></div><div class="ttdeci">float half</div><div class="ttdoc">Half operation limited throughput.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1342</div></div>
<div class="ttc" id="astruct_g_l_s_l_cthroughput_limiter_html_a80471483a98d5aa2b56f3d091c6f66c3"><div class="ttname"><a href="struct_g_l_s_l_cthroughput_limiter.html#a80471483a98d5aa2b56f3d091c6f66c3">GLSLCthroughputLimiter::issue</a></div><div class="ttdeci">float issue</div><div class="ttdoc">Instruction issue limited throughput.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1336</div></div>
<div class="ttc" id="astruct_g_l_s_l_cthroughput_limiter_html_a82a4ac305863d2195e79c945b8188d65"><div class="ttname"><a href="struct_g_l_s_l_cthroughput_limiter.html#a82a4ac305863d2195e79c945b8188d65">GLSLCthroughputLimiter::controlFlow</a></div><div class="ttdeci">float controlFlow</div><div class="ttdoc">Control flow operation limited throughput.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1354</div></div>
<div class="ttc" id="astruct_g_l_s_l_cthroughput_limiter_html_aaa1a970a3f023d8b399e4323d0354276"><div class="ttname"><a href="struct_g_l_s_l_cthroughput_limiter.html#aaa1a970a3f023d8b399e4323d0354276">GLSLCthroughputLimiter::shared</a></div><div class="ttdeci">float shared</div><div class="ttdoc">Attribute load/store, shared memory load/store limited throughput.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1351</div></div>
<div class="ttc" id="astruct_g_l_s_l_cthroughput_limiter_html_ab3d12b78f87486d981e166d317122466"><div class="ttname"><a href="struct_g_l_s_l_cthroughput_limiter.html#ab3d12b78f87486d981e166d317122466">GLSLCthroughputLimiter::reg</a></div><div class="ttdeci">float reg</div><div class="ttdoc">Register limited throughput.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1360</div></div>
<div class="ttc" id="astruct_g_l_s_l_cthroughput_limiter_html_aedddd315e155a83318fc9a79723c15b2"><div class="ttname"><a href="struct_g_l_s_l_cthroughput_limiter.html#aedddd315e155a83318fc9a79723c15b2">GLSLCthroughputLimiter::warp</a></div><div class="ttdeci">float warp</div><div class="ttdoc">Warp id limited throughput.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1363</div></div>
<div class="ttc" id="astruct_g_l_s_l_cthroughput_limiter_html_afe5545973adf22ed4001a0784348efda"><div class="ttname"><a href="struct_g_l_s_l_cthroughput_limiter.html#afe5545973adf22ed4001a0784348efda">GLSLCthroughputLimiter::fp</a></div><div class="ttdeci">float fp</div><div class="ttdoc">Single precision floating point operation limited throughput.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1339</div></div>
<div class="ttc" id="astruct_g_l_s_l_cuniform_block_info_html"><div class="ttname"><a href="struct_g_l_s_l_cuniform_block_info.html">GLSLCuniformBlockInfo</a></div><div class="ttdoc">An information data section corresponding to uniform blocks.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:408</div></div>
<div class="ttc" id="astruct_g_l_s_l_cuniform_block_info_html_a3089f78f6431b069fca45643190b8f88"><div class="ttname"><a href="struct_g_l_s_l_cuniform_block_info.html#a3089f78f6431b069fca45643190b8f88">GLSLCuniformBlockInfo::bindings</a></div><div class="ttdeci">int32_t bindings[GLSLC_NUM_SHADER_STAGES]</div><div class="ttdoc">Bindings associated with this block in each shader stage, where array index n corresponds to NVNshade...</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:427</div></div>
<div class="ttc" id="astruct_g_l_s_l_cuniform_block_info_html_a449b0310144f865d20c9152228c1f5c2"><div class="ttname"><a href="struct_g_l_s_l_cuniform_block_info.html#a449b0310144f865d20c9152228c1f5c2">GLSLCuniformBlockInfo::stagesReferencedIn</a></div><div class="ttdeci">NVNshaderStageBits stagesReferencedIn</div><div class="ttdoc">Stage mask representing which stages this variable is active in.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:419</div></div>
<div class="ttc" id="astruct_g_l_s_l_cuniform_block_info_html_a995ad7b06ac8f754faceea20cb6b8443"><div class="ttname"><a href="struct_g_l_s_l_cuniform_block_info.html#a995ad7b06ac8f754faceea20cb6b8443">GLSLCuniformBlockInfo::size</a></div><div class="ttdeci">uint32_t size</div><div class="ttdoc">Data size (in bytes) of this uniform block.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:413</div></div>
<div class="ttc" id="astruct_g_l_s_l_cuniform_block_info_html_ae96efb0a5531abeb9b8baae6cc99f0ef"><div class="ttname"><a href="struct_g_l_s_l_cuniform_block_info.html#ae96efb0a5531abeb9b8baae6cc99f0ef">GLSLCuniformBlockInfo::numActiveVariables</a></div><div class="ttdeci">uint32_t numActiveVariables</div><div class="ttdoc">Number of active variables defined in this uniform block.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:416</div></div>
<div class="ttc" id="astruct_g_l_s_l_cuniform_block_info_html_af581f038ae9544eb77e43729691532a8"><div class="ttname"><a href="struct_g_l_s_l_cuniform_block_info.html#af581f038ae9544eb77e43729691532a8">GLSLCuniformBlockInfo::nameInfo</a></div><div class="ttdeci">GLSLCpiqName nameInfo</div><div class="ttdoc">Info about the name in the data string pool.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:410</div></div>
<div class="ttc" id="astruct_g_l_s_l_cuniform_info_html"><div class="ttname"><a href="struct_g_l_s_l_cuniform_info.html">GLSLCuniformInfo</a></div><div class="ttdoc">An information data section corresponding to individual uniforms.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:434</div></div>
<div class="ttc" id="astruct_g_l_s_l_cuniform_info_html_a062aec36dd8b1203f67b1a8bd12948ee"><div class="ttname"><a href="struct_g_l_s_l_cuniform_info.html#a062aec36dd8b1203f67b1a8bd12948ee">GLSLCuniformInfo::stagesReferencedIn</a></div><div class="ttdeci">NVNshaderStageBits stagesReferencedIn</div><div class="ttdoc">Stage mask representing which stages this variable is active in.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:462</div></div>
<div class="ttc" id="astruct_g_l_s_l_cuniform_info_html_a0cbf82d02d29d69ca87d00d575a11d9d"><div class="ttname"><a href="struct_g_l_s_l_cuniform_info.html#a0cbf82d02d29d69ca87d00d575a11d9d">GLSLCuniformInfo::arrayStride</a></div><div class="ttdeci">uint32_t arrayStride</div><div class="ttdoc">Stride in bytes between uniforms in the array.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:452</div></div>
<div class="ttc" id="astruct_g_l_s_l_cuniform_info_html_a2f72999cec8d93607ffc6c9488c8bd6e"><div class="ttname"><a href="struct_g_l_s_l_cuniform_info.html#a2f72999cec8d93607ffc6c9488c8bd6e">GLSLCuniformInfo::blockOffset</a></div><div class="ttdeci">int32_t blockOffset</div><div class="ttdoc">Byte offset into the uniform block. -1 if not defined in a uniform block.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:446</div></div>
<div class="ttc" id="astruct_g_l_s_l_cuniform_info_html_a540f5953a7f10b489754374639222af5"><div class="ttname"><a href="struct_g_l_s_l_cuniform_info.html#a540f5953a7f10b489754374639222af5">GLSLCuniformInfo::matrixStride</a></div><div class="ttdeci">int32_t matrixStride</div><div class="ttdoc">Specifies stride between columns/rows of matrix depending on isRowMajor.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:456</div></div>
<div class="ttc" id="astruct_g_l_s_l_cuniform_info_html_a6b7862e3e1a42c7e95f6041b210c3124"><div class="ttname"><a href="struct_g_l_s_l_cuniform_info.html#a6b7862e3e1a42c7e95f6041b210c3124">GLSLCuniformInfo::isArray</a></div><div class="ttdeci">uint8_t isArray</div><div class="ttdoc">1 if this uniform is an array, 0 if otherwise.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:482</div></div>
<div class="ttc" id="astruct_g_l_s_l_cuniform_info_html_aaa27c23127bba5e365da8b927b344570"><div class="ttname"><a href="struct_g_l_s_l_cuniform_info.html#aaa27c23127bba5e365da8b927b344570">GLSLCuniformInfo::sizeOfArray</a></div><div class="ttdeci">uint32_t sizeOfArray</div><div class="ttdoc">Number of array elements if the uniform is an array, 1 otherwise.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:449</div></div>
<div class="ttc" id="astruct_g_l_s_l_cuniform_info_html_aba31e5a44352d4b9e067ded0f87e8059"><div class="ttname"><a href="struct_g_l_s_l_cuniform_info.html#aba31e5a44352d4b9e067ded0f87e8059">GLSLCuniformInfo::type</a></div><div class="ttdeci">GLSLCpiqTypeEnum type</div><div class="ttdoc">The data type of this uniform.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:439</div></div>
<div class="ttc" id="astruct_g_l_s_l_cuniform_info_html_adc5be9a9b1526b2ec101a374f4d7fe1a"><div class="ttname"><a href="struct_g_l_s_l_cuniform_info.html#adc5be9a9b1526b2ec101a374f4d7fe1a">GLSLCuniformInfo::blockNdx</a></div><div class="ttdeci">int32_t blockNdx</div><div class="ttdoc">If part of a uniform block, the ndx to the corresponding uniform block.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:443</div></div>
<div class="ttc" id="astruct_g_l_s_l_cuniform_info_html_ade0fa25b5b9ead9c2101826d6b445f74"><div class="ttname"><a href="struct_g_l_s_l_cuniform_info.html#ade0fa25b5b9ead9c2101826d6b445f74">GLSLCuniformInfo::isRowMajor</a></div><div class="ttdeci">uint32_t isRowMajor</div><div class="ttdoc">Specifies whether row major or column major.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:459</div></div>
<div class="ttc" id="astruct_g_l_s_l_cuniform_info_html_af3c2cf0a643a810defd8f1964ee5347c"><div class="ttname"><a href="struct_g_l_s_l_cuniform_info.html#af3c2cf0a643a810defd8f1964ee5347c">GLSLCuniformInfo::nameInfo</a></div><div class="ttdeci">GLSLCpiqName nameInfo</div><div class="ttdoc">Info about the name in the data string pool.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:436</div></div>
<div class="ttc" id="astruct_g_l_s_l_cuniform_info_html_af5982205cf060f75098ac393b9d47536"><div class="ttname"><a href="struct_g_l_s_l_cuniform_info.html#af5982205cf060f75098ac393b9d47536">GLSLCuniformInfo::bindings</a></div><div class="ttdeci">int32_t bindings[GLSLC_NUM_SHADER_STAGES]</div><div class="ttdoc">Bindings associated with this uniform in each shader stage, where array ndx n corresponds to NVNshade...</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:473</div></div>
<div class="ttc" id="astructnvn_tool_1_1texpkg_1_1_raw_mip_map_level_html"><div class="ttname"><a href="structnvn_tool_1_1texpkg_1_1_raw_mip_map_level.html">nvnTool::texpkg::RawMipMapLevel</a></div><div class="ttdoc">Reference to the data in one texture mipmap level in an image.</div><div class="ttdef"><b>Definition:</b> nvnTool_Image.h:62</div></div>
<div class="ttc" id="astructnvn_tool_1_1texpkg_1_1_raw_mip_map_level_html_a7a5c91011253054539257bf5e58f8dfc"><div class="ttname"><a href="structnvn_tool_1_1texpkg_1_1_raw_mip_map_level.html#a7a5c91011253054539257bf5e58f8dfc">nvnTool::texpkg::RawMipMapLevel::data</a></div><div class="ttdeci">uint8_t * data</div><div class="ttdoc">The mipmap level pixel data. Weak reference; do not delete.</div><div class="ttdef"><b>Definition:</b> nvnTool_Image.h:81</div></div>
<div class="ttc" id="astructnvn_tool_1_1texpkg_1_1_raw_mip_map_level_html_a9966eb3a43d2a4232b85136c9cb3ca58"><div class="ttname"><a href="structnvn_tool_1_1texpkg_1_1_raw_mip_map_level.html#a9966eb3a43d2a4232b85136c9cb3ca58">nvnTool::texpkg::RawMipMapLevel::dataSize</a></div><div class="ttdeci">uint32_t dataSize</div><div class="ttdoc">Size (in bytes) of the entire mipmap level.</div><div class="ttdef"><b>Definition:</b> nvnTool_Image.h:76</div></div>
</div><!-- fragment --> </div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
