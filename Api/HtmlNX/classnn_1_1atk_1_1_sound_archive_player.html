<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nn::atk::SoundArchivePlayer Class Reference | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenn.html">nn</a></li><li class="navelem"><a class="el" href="namespacenn_1_1atk.html">atk</a></li><li class="navelem"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html">SoundArchivePlayer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classnn_1_1atk_1_1_sound_archive_player-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">nn::atk::SoundArchivePlayer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Plays back sounds in a sound archive.  
 <a href="classnn_1_1atk_1_1_sound_archive_player.html#details">More...</a></p>

<p><code>#include &lt;nn/atk/atk_SoundArchivePlayer.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for nn::atk::SoundArchivePlayer:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classnn_1_1atk_1_1_sound_archive_player.png" usemap="#nn::atk::SoundArchivePlayer_map" alt=""/>
  <map id="nn::atk::SoundArchivePlayer_map" name="nn::atk::SoundArchivePlayer_map">
<area href="classnn_1_1atk_1_1_sound_startable.html" title="An abstract class representing playable sounds." alt="nn::atk::SoundStartable" shape="rect" coords="0,0,172,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1atk_1_1_sound_archive_player_1_1_initialize_param.html">InitializeParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure used to initialize the sound archive player.  <a href="structnn_1_1atk_1_1_sound_archive_player_1_1_initialize_param.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1atk_1_1_sound_archive_player_1_1_stream_sound_instance_state.html">StreamSoundInstanceState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <b>The use of internal features is prohibited.</b>  <a href="structnn_1_1atk_1_1_sound_archive_player_1_1_stream_sound_instance_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae333a16ca9227bd35cd079c16f2d4803"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ae333a16ca9227bd35cd079c16f2d4803">AddAddonSoundArchive</a> (const char *name, const <a class="el" href="classnn_1_1atk_1_1_addon_sound_archive.html">AddonSoundArchive</a> *pSoundArchive, const <a class="el" href="classnn_1_1atk_1_1_sound_data_manager.html">SoundDataManager</a> *pSoundDataManager) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae333a16ca9227bd35cd079c16f2d4803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an additional sound archive to a player.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#ae333a16ca9227bd35cd079c16f2d4803">More...</a><br /></td></tr>
<tr class="separator:ae333a16ca9227bd35cd079c16f2d4803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e3d594647722e0d2aefe1c68453c80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a21e3d594647722e0d2aefe1c68453c80">CheckStreamSoundFileExisting</a> (const char *streamSoundName) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a21e3d594647722e0d2aefe1c68453c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for the existence of a stream sound file (a BFSTM file).  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a21e3d594647722e0d2aefe1c68453c80">More...</a><br /></td></tr>
<tr class="separator:a21e3d594647722e0d2aefe1c68453c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad743c92f9aaa69b097a8d0a0ce7b593c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ad743c92f9aaa69b097a8d0a0ce7b593c">CheckStreamSoundFileExisting</a> (const char *streamSoundName, const char *soundArchiveName) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad743c92f9aaa69b097a8d0a0ce7b593c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for the existence of a stream sound (BFSTM) file in the additional sound archive.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#ad743c92f9aaa69b097a8d0a0ce7b593c">More...</a><br /></td></tr>
<tr class="separator:ad743c92f9aaa69b097a8d0a0ce7b593c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762f020d7a0cbe8f3561b050ed70f2cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a762f020d7a0cbe8f3561b050ed70f2cd">CheckStreamSoundFileExisting</a> (<a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a> streamSoundId) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a762f020d7a0cbe8f3561b050ed70f2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for the existence of a stream sound file (a BFSTM file).  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a762f020d7a0cbe8f3561b050ed70f2cd">More...</a><br /></td></tr>
<tr class="separator:a762f020d7a0cbe8f3561b050ed70f2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ddb64d1ddfed462ec68a0ea1ab32634"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a3ddb64d1ddfed462ec68a0ea1ab32634">CheckStreamSoundFileExisting</a> (<a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a> streamSoundId, const char *soundArchiveName) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3ddb64d1ddfed462ec68a0ea1ab32634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for the existence of a stream sound (BFSTM) file in the additional sound archive.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a3ddb64d1ddfed462ec68a0ea1ab32634">More...</a><br /></td></tr>
<tr class="separator:a3ddb64d1ddfed462ec68a0ea1ab32634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acacd47f7b7b27101220d04da35acb847"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#acacd47f7b7b27101220d04da35acb847">GetStreamBlockCount</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acacd47f7b7b27101220d04da35acb847"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <b>The use of internal features is prohibited.</b>  <a href="classnn_1_1atk_1_1_sound_archive_player.html#acacd47f7b7b27101220d04da35acb847">More...</a><br /></td></tr>
<tr class="separator:acacd47f7b7b27101220d04da35acb847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cb07170215ea29919a734e663f8c72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ac8cb07170215ea29919a734e663f8c72">ReadMarkerInfoArray</a> (<a class="el" href="structnn_1_1atk_1_1_stream_sound_marker_info.html">StreamSoundMarkerInfo</a> *pOutInfoArray, int *pOutActualInfoCount, int markerInfoCountMax, const char *streamSoundName) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac8cb07170215ea29919a734e663f8c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the marker information embedded in the waveform being used by the stream sound.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#ac8cb07170215ea29919a734e663f8c72">More...</a><br /></td></tr>
<tr class="separator:ac8cb07170215ea29919a734e663f8c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c897b36a81e005094d2ce91f1666078"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a3c897b36a81e005094d2ce91f1666078">ReadMarkerInfoArray</a> (<a class="el" href="structnn_1_1atk_1_1_stream_sound_marker_info.html">StreamSoundMarkerInfo</a> *pOutInfoArray, int *pOutActualInfoCount, int markerInfoCountMax, const char *streamSoundName, const char *soundArchiveName) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3c897b36a81e005094d2ce91f1666078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the marker information embedded in the waveform being used by the stream sound.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a3c897b36a81e005094d2ce91f1666078">More...</a><br /></td></tr>
<tr class="separator:a3c897b36a81e005094d2ce91f1666078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80bf0c59c0fa5c1f1bd1a8c76e95db0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ab80bf0c59c0fa5c1f1bd1a8c76e95db0">ReadMarkerInfoArray</a> (<a class="el" href="structnn_1_1atk_1_1_stream_sound_marker_info.html">StreamSoundMarkerInfo</a> *pOutInfoArray, int *pOutActualInfoCount, int markerInfoCountMax, <a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a> streamSoundId) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab80bf0c59c0fa5c1f1bd1a8c76e95db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the marker information embedded in the waveform being used by the stream sound.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#ab80bf0c59c0fa5c1f1bd1a8c76e95db0">More...</a><br /></td></tr>
<tr class="separator:ab80bf0c59c0fa5c1f1bd1a8c76e95db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949eea181cdfa2c44c4a372aec433700"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a949eea181cdfa2c44c4a372aec433700">ReadMarkerInfoArray</a> (<a class="el" href="structnn_1_1atk_1_1_stream_sound_marker_info.html">StreamSoundMarkerInfo</a> *pOutInfoArray, int *pOutActualInfoCount, int markerInfoCountMax, <a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a> streamSoundId, const char *soundArchiveName) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a949eea181cdfa2c44c4a372aec433700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the marker information embedded in the waveform being used by the stream sound.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a949eea181cdfa2c44c4a372aec433700">More...</a><br /></td></tr>
<tr class="separator:a949eea181cdfa2c44c4a372aec433700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e337c51c3030c9c0eb0f2f62e7eed9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a4e337c51c3030c9c0eb0f2f62e7eed9a">ReadStreamSoundDataInfo</a> (<a class="el" href="structnn_1_1atk_1_1_stream_sound_data_info.html">StreamSoundDataInfo</a> *pOutInfo, const char *streamSoundName) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4e337c51c3030c9c0eb0f2f62e7eed9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets stream sound data.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a4e337c51c3030c9c0eb0f2f62e7eed9a">More...</a><br /></td></tr>
<tr class="separator:a4e337c51c3030c9c0eb0f2f62e7eed9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984ec35d2fda38c879e5e96c8cc16362"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a984ec35d2fda38c879e5e96c8cc16362">ReadStreamSoundDataInfo</a> (<a class="el" href="structnn_1_1atk_1_1_stream_sound_data_info.html">StreamSoundDataInfo</a> *pOutInfo, const char *streamSoundName, const char *soundArchiveName) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a984ec35d2fda38c879e5e96c8cc16362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets information about stream sounds in the additional sound archive.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a984ec35d2fda38c879e5e96c8cc16362">More...</a><br /></td></tr>
<tr class="separator:a984ec35d2fda38c879e5e96c8cc16362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e943804fd7c1013fed2d1dab8674bac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a3e943804fd7c1013fed2d1dab8674bac">ReadStreamSoundDataInfo</a> (<a class="el" href="structnn_1_1atk_1_1_stream_sound_data_info.html">StreamSoundDataInfo</a> *pOutInfo, const <a class="el" href="classnn_1_1atk_1_1_sound_archive.html">SoundArchive</a> *pSoundArchive, <a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a> streamSoundId) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3e943804fd7c1013fed2d1dab8674bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets information about stream sounds in the additional sound archive.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a3e943804fd7c1013fed2d1dab8674bac">More...</a><br /></td></tr>
<tr class="separator:a3e943804fd7c1013fed2d1dab8674bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ddd42d5e6f2bd8996cee89b17cfc14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a79ddd42d5e6f2bd8996cee89b17cfc14">ReadStreamSoundDataInfo</a> (<a class="el" href="structnn_1_1atk_1_1_stream_sound_data_info.html">StreamSoundDataInfo</a> *pOutInfo, <a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a> streamSoundId) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a79ddd42d5e6f2bd8996cee89b17cfc14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets stream sound data.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a79ddd42d5e6f2bd8996cee89b17cfc14">More...</a><br /></td></tr>
<tr class="separator:a79ddd42d5e6f2bd8996cee89b17cfc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1094c1da9750822edaacb190a5f4bcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ab1094c1da9750822edaacb190a5f4bcb">ReadStreamSoundDataInfo</a> (<a class="el" href="structnn_1_1atk_1_1_stream_sound_data_info.html">StreamSoundDataInfo</a> *pOutInfo, <a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a> streamSoundId, const char *soundArchiveName) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab1094c1da9750822edaacb190a5f4bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets information about stream sounds in the additional sound archive.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#ab1094c1da9750822edaacb190a5f4bcb">More...</a><br /></td></tr>
<tr class="separator:ab1094c1da9750822edaacb190a5f4bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec1a8d5b20b5281c4a8c3c48c2fb73d"><td class="memItemLeft" align="right" valign="top"><a id="a5ec1a8d5b20b5281c4a8c3c48c2fb73d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a5ec1a8d5b20b5281c4a8c3c48c2fb73d">ReadStreamSoundInstanceState</a> (<a class="el" href="structnn_1_1atk_1_1_sound_archive_player_1_1_stream_sound_instance_state.html">StreamSoundInstanceState</a> *pOutInfo) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5ec1a8d5b20b5281c4a8c3c48c2fb73d"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <b>The use of internal features is prohibited.</b> <br /></td></tr>
<tr class="separator:a5ec1a8d5b20b5281c4a8c3c48c2fb73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72eb791f87b3c9b7a799c669aa91221d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a72eb791f87b3c9b7a799c669aa91221d">ReadStreamSoundRegionDataInfo</a> (<a class="el" href="structnn_1_1atk_1_1_stream_sound_region_data_info.html">StreamSoundRegionDataInfo</a> *pOutInfo, const char *streamSoundName, const char *const *pRegionName, int infoCount, void *buffer, size_t bufferSize) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a72eb791f87b3c9b7a799c669aa91221d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets multiple instances of stream sound region data.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a72eb791f87b3c9b7a799c669aa91221d">More...</a><br /></td></tr>
<tr class="separator:a72eb791f87b3c9b7a799c669aa91221d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f07e3bff894b1d63fdc6e59ce1bbeab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a2f07e3bff894b1d63fdc6e59ce1bbeab">ReadStreamSoundRegionDataInfo</a> (<a class="el" href="structnn_1_1atk_1_1_stream_sound_region_data_info.html">StreamSoundRegionDataInfo</a> *pOutInfo, const char *streamSoundName, const char *const *pRegionName, int infoCount, void *buffer, size_t bufferSize, const char *soundArchiveName) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2f07e3bff894b1d63fdc6e59ce1bbeab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets multiple instances of region information about stream sounds in the additional sound archive.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a2f07e3bff894b1d63fdc6e59ce1bbeab">More...</a><br /></td></tr>
<tr class="separator:a2f07e3bff894b1d63fdc6e59ce1bbeab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c99d23a017ba4ad3b3c0a48db425967"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a2c99d23a017ba4ad3b3c0a48db425967">ReadStreamSoundRegionDataInfo</a> (<a class="el" href="structnn_1_1atk_1_1_stream_sound_region_data_info.html">StreamSoundRegionDataInfo</a> *pOutInfo, const char *streamSoundName, const char *regionName, void *buffer, size_t bufferSize) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2c99d23a017ba4ad3b3c0a48db425967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets stream sound region data.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a2c99d23a017ba4ad3b3c0a48db425967">More...</a><br /></td></tr>
<tr class="separator:a2c99d23a017ba4ad3b3c0a48db425967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c94bb02b7e2d63ea701563e95be33f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a9c94bb02b7e2d63ea701563e95be33f7">ReadStreamSoundRegionDataInfo</a> (<a class="el" href="structnn_1_1atk_1_1_stream_sound_region_data_info.html">StreamSoundRegionDataInfo</a> *pOutInfo, const char *streamSoundName, const char *regionName, void *buffer, size_t bufferSize, const char *soundArchiveName) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9c94bb02b7e2d63ea701563e95be33f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets region information about stream sounds in the additional sound archive.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a9c94bb02b7e2d63ea701563e95be33f7">More...</a><br /></td></tr>
<tr class="separator:a9c94bb02b7e2d63ea701563e95be33f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb2521b4d73e5e2441ecb2a1cd2c394"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a9eb2521b4d73e5e2441ecb2a1cd2c394">ReadStreamSoundRegionDataInfo</a> (<a class="el" href="structnn_1_1atk_1_1_stream_sound_region_data_info.html">StreamSoundRegionDataInfo</a> *pOutInfo, <a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a> streamSoundId, const char *const *pRegionName, int infoCount, const <a class="el" href="classnn_1_1atk_1_1_sound_archive.html">SoundArchive</a> *pSoundArchive, void *buffer, size_t bufferSize) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9eb2521b4d73e5e2441ecb2a1cd2c394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets multiple instances of region information about stream sounds in the additional sound archive.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a9eb2521b4d73e5e2441ecb2a1cd2c394">More...</a><br /></td></tr>
<tr class="separator:a9eb2521b4d73e5e2441ecb2a1cd2c394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59ebc7e0d3fae4e19b525407822dc35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ad59ebc7e0d3fae4e19b525407822dc35">ReadStreamSoundRegionDataInfo</a> (<a class="el" href="structnn_1_1atk_1_1_stream_sound_region_data_info.html">StreamSoundRegionDataInfo</a> *pOutInfo, <a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a> streamSoundId, const char *const *pRegionName, int infoCount, void *buffer, size_t bufferSize) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad59ebc7e0d3fae4e19b525407822dc35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets multiple instances of stream sound region data.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#ad59ebc7e0d3fae4e19b525407822dc35">More...</a><br /></td></tr>
<tr class="separator:ad59ebc7e0d3fae4e19b525407822dc35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd7360c0450f6b2e9bf33d12a495512"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a9fd7360c0450f6b2e9bf33d12a495512">ReadStreamSoundRegionDataInfo</a> (<a class="el" href="structnn_1_1atk_1_1_stream_sound_region_data_info.html">StreamSoundRegionDataInfo</a> *pOutInfo, <a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a> streamSoundId, const char *const *pRegionName, int infoCount, void *buffer, size_t bufferSize, const char *soundArchiveName) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9fd7360c0450f6b2e9bf33d12a495512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets multiple instances of region information about stream sounds in the additional sound archive.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a9fd7360c0450f6b2e9bf33d12a495512">More...</a><br /></td></tr>
<tr class="separator:a9fd7360c0450f6b2e9bf33d12a495512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a77018155a9dd49f1191ca52366a7e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a7a77018155a9dd49f1191ca52366a7e6">ReadStreamSoundRegionDataInfo</a> (<a class="el" href="structnn_1_1atk_1_1_stream_sound_region_data_info.html">StreamSoundRegionDataInfo</a> *pOutInfo, <a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a> streamSoundId, const char *regionName, void *buffer, size_t bufferSize) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7a77018155a9dd49f1191ca52366a7e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets stream sound region data.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a7a77018155a9dd49f1191ca52366a7e6">More...</a><br /></td></tr>
<tr class="separator:a7a77018155a9dd49f1191ca52366a7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bca5c712f338b52c24e4c2202c882e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a3bca5c712f338b52c24e4c2202c882e7">ReadStreamSoundRegionDataInfo</a> (<a class="el" href="structnn_1_1atk_1_1_stream_sound_region_data_info.html">StreamSoundRegionDataInfo</a> *pOutInfo, <a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a> streamSoundId, const char *regionName, void *buffer, size_t bufferSize, const char *soundArchiveName) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3bca5c712f338b52c24e4c2202c882e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets region information about stream sounds in the additional sound archive.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a3bca5c712f338b52c24e4c2202c882e7">More...</a><br /></td></tr>
<tr class="separator:a3bca5c712f338b52c24e4c2202c882e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3acb0b55a560c154f56d338d0c7c325"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aa3acb0b55a560c154f56d338d0c7c325">ReadWaveSoundDataInfo</a> (<a class="el" href="structnn_1_1atk_1_1_wave_sound_data_info.html">WaveSoundDataInfo</a> *pOutInfo, const char *waveSoundName) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa3acb0b55a560c154f56d338d0c7c325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the wave sound information.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#aa3acb0b55a560c154f56d338d0c7c325">More...</a><br /></td></tr>
<tr class="separator:aa3acb0b55a560c154f56d338d0c7c325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7038cade55064aded920d3b5068741d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a7038cade55064aded920d3b5068741d4">ReadWaveSoundDataInfo</a> (<a class="el" href="structnn_1_1atk_1_1_wave_sound_data_info.html">WaveSoundDataInfo</a> *pOutInfo, const char *waveSoundName, const char *soundArchiveName) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7038cade55064aded920d3b5068741d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets information about wave sounds in the additional sound archive.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a7038cade55064aded920d3b5068741d4">More...</a><br /></td></tr>
<tr class="separator:a7038cade55064aded920d3b5068741d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d07cd1990503ea412e12c5eecdc17d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a89d07cd1990503ea412e12c5eecdc17d">ReadWaveSoundDataInfo</a> (<a class="el" href="structnn_1_1atk_1_1_wave_sound_data_info.html">WaveSoundDataInfo</a> *pOutInfo, <a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a> waveSoundId) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a89d07cd1990503ea412e12c5eecdc17d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the wave sound information.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a89d07cd1990503ea412e12c5eecdc17d">More...</a><br /></td></tr>
<tr class="separator:a89d07cd1990503ea412e12c5eecdc17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b06672cd1d7bc0144d65205ad5699ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a6b06672cd1d7bc0144d65205ad5699ee">ReadWaveSoundDataInfo</a> (<a class="el" href="structnn_1_1atk_1_1_wave_sound_data_info.html">WaveSoundDataInfo</a> *pOutInfo, <a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a> waveSoundId, const char *soundArchiveName) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6b06672cd1d7bc0144d65205ad5699ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets information about wave sounds in the additional sound archive.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a6b06672cd1d7bc0144d65205ad5699ee">More...</a><br /></td></tr>
<tr class="separator:a6b06672cd1d7bc0144d65205ad5699ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6e26ba7a00d506e988b0ed81bba0e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aef6e26ba7a00d506e988b0ed81bba0e4">ReadWaveSoundDataInfo</a> (<a class="el" href="structnn_1_1atk_1_1_wave_sound_data_info.html">WaveSoundDataInfo</a> *pOutInfo, <a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a> waveSoundId, const <a class="el" href="classnn_1_1atk_1_1_sound_archive.html">SoundArchive</a> *pSoundArchive, const <a class="el" href="classnn_1_1atk_1_1_sound_data_manager.html">SoundDataManager</a> *pSoundDataManager) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aef6e26ba7a00d506e988b0ed81bba0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets information about wave sounds in the additional sound archive.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#aef6e26ba7a00d506e988b0ed81bba0e4">More...</a><br /></td></tr>
<tr class="separator:aef6e26ba7a00d506e988b0ed81bba0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2aca96645e4bacc9810df0372daa71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a4e2aca96645e4bacc9810df0372daa71">RemoveAddonSoundArchive</a> (const <a class="el" href="classnn_1_1atk_1_1_addon_sound_archive.html">AddonSoundArchive</a> *pSoundArchive) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4e2aca96645e4bacc9810df0372daa71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes an additional sound archive from a player.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a4e2aca96645e4bacc9810df0372daa71">More...</a><br /></td></tr>
<tr class="separator:a4e2aca96645e4bacc9810df0372daa71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3df5bdfb4cc9785e5d4d861d0c3e6b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ad3df5bdfb4cc9785e5d4d861d0c3e6b4">SetDefaultOutputReceiver</a> (<a class="el" href="classnn_1_1atk_1_1_output_receiver.html">OutputReceiver</a> *pOutputReceiver) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad3df5bdfb4cc9785e5d4d861d0c3e6b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default output destination to use when playing sounds using a user-defined submix construct.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#ad3df5bdfb4cc9785e5d4d861d0c3e6b4">More...</a><br /></td></tr>
<tr class="separator:ad3df5bdfb4cc9785e5d4d861d0c3e6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae89259218f196a39ea6a828856a87ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aae89259218f196a39ea6a828856a87ab">SetStreamBlockCount</a> (int count) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aae89259218f196a39ea6a828856a87ab"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <b>The use of internal features is prohibited.</b>  <a href="classnn_1_1atk_1_1_sound_archive_player.html#aae89259218f196a39ea6a828856a87ab">More...</a><br /></td></tr>
<tr class="separator:aae89259218f196a39ea6a828856a87ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and Destructors</div></td></tr>
<tr class="memitem:a38ab10f2d0892f668bc2bfc909294407"><td class="memItemLeft" align="right" valign="top"><a id="a38ab10f2d0892f668bc2bfc909294407"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a38ab10f2d0892f668bc2bfc909294407">SoundArchivePlayer</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a38ab10f2d0892f668bc2bfc909294407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a38ab10f2d0892f668bc2bfc909294407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41dcc10d65f12b27cebd59b7f77f487"><td class="memItemLeft" align="right" valign="top"><a id="ac41dcc10d65f12b27cebd59b7f77f487"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ac41dcc10d65f12b27cebd59b7f77f487">~SoundArchivePlayer</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a> <a class="el" href="nn___macro_8h.html#a5b950a1a9c5f9b57d49185d8fb4cd4ab">NN_OVERRIDE</a></td></tr>
<tr class="memdesc:ac41dcc10d65f12b27cebd59b7f77f487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:ac41dcc10d65f12b27cebd59b7f77f487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Updating.</div></td></tr>
<tr class="memitem:a22e4ef8d9785639f48343fd84aba6d3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a22e4ef8d9785639f48343fd84aba6d3a">Update</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a22e4ef8d9785639f48343fd84aba6d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the sound archive player.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a22e4ef8d9785639f48343fd84aba6d3a">More...</a><br /></td></tr>
<tr class="separator:a22e4ef8d9785639f48343fd84aba6d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Getting Instances</div></td></tr>
<tr class="memitem:ae2c03bc431e10eff824952cc65fc2add"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnn_1_1atk_1_1_sound_archive.html">SoundArchive</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ae2c03bc431e10eff824952cc65fc2add">GetSoundArchive</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae2c03bc431e10eff824952cc65fc2add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sound archive that is bound to a player.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#ae2c03bc431e10eff824952cc65fc2add">More...</a><br /></td></tr>
<tr class="separator:ae2c03bc431e10eff824952cc65fc2add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0742165749cd2467cf8e913bc10d35"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnn_1_1atk_1_1_addon_sound_archive.html">AddonSoundArchive</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aff0742165749cd2467cf8e913bc10d35">GetAddonSoundArchive</a> (const char *soundArchiveName) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aff0742165749cd2467cf8e913bc10d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the additional sound archive linked to the player.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#aff0742165749cd2467cf8e913bc10d35">More...</a><br /></td></tr>
<tr class="separator:aff0742165749cd2467cf8e913bc10d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1aa499e45f855021a8017d2f967c762"><td class="memItemLeft" align="right" valign="top"><a id="ae1aa499e45f855021a8017d2f967c762"></a>
<a class="el" href="classnn_1_1os_1_1_tick.html">nn::os::Tick</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ae1aa499e45f855021a8017d2f967c762">GetAddonSoundArchiveLastAddTick</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae1aa499e45f855021a8017d2f967c762"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <b>The use of internal features is prohibited.</b> <br /></td></tr>
<tr class="separator:ae1aa499e45f855021a8017d2f967c762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0f7fddca5bf28bcaebb8a307589976"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a4c0f7fddca5bf28bcaebb8a307589976">GetAddonSoundArchiveCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4c0f7fddca5bf28bcaebb8a307589976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of additional sound archives linked to the player.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a4c0f7fddca5bf28bcaebb8a307589976">More...</a><br /></td></tr>
<tr class="separator:a4c0f7fddca5bf28bcaebb8a307589976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785e5a1510f605f085ee098bb2034966"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnn_1_1atk_1_1_addon_sound_archive.html">AddonSoundArchive</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a785e5a1510f605f085ee098bb2034966">GetAddonSoundArchive</a> (int index) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a785e5a1510f605f085ee098bb2034966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the additional sound archive linked to the player.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a785e5a1510f605f085ee098bb2034966">More...</a><br /></td></tr>
<tr class="separator:a785e5a1510f605f085ee098bb2034966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f0cb7c9a0aeecc8253c321c7ec1f60"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ad1f0cb7c9a0aeecc8253c321c7ec1f60">GetAddonSoundArchiveName</a> (int index) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad1f0cb7c9a0aeecc8253c321c7ec1f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the names of additional sound archives linked to the player.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#ad1f0cb7c9a0aeecc8253c321c7ec1f60">More...</a><br /></td></tr>
<tr class="separator:ad1f0cb7c9a0aeecc8253c321c7ec1f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881970f24d53ed82586ba25b922e6fa0"><td class="memItemLeft" align="right" valign="top"><a id="a881970f24d53ed82586ba25b922e6fa0"></a>
<a class="el" href="classnn_1_1os_1_1_tick.html">nn::os::Tick</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a881970f24d53ed82586ba25b922e6fa0">GetAddonSoundArchiveAddTick</a> (int index) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a881970f24d53ed82586ba25b922e6fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <b>The use of internal features is prohibited.</b> <br /></td></tr>
<tr class="separator:a881970f24d53ed82586ba25b922e6fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9874b214f461b74e4c05f0667d77014"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnn_1_1atk_1_1_sound_data_manager.html">SoundDataManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ad9874b214f461b74e4c05f0667d77014">GetAddonSoundDataManager</a> (const char *soundArchiveName) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad9874b214f461b74e4c05f0667d77014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sound data manager of the additional sound archive linked to the player.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#ad9874b214f461b74e4c05f0667d77014">More...</a><br /></td></tr>
<tr class="separator:ad9874b214f461b74e4c05f0667d77014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481c256f55a8ae164bb3702d5e764715"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1atk_1_1_sound_player.html">SoundPlayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a481c256f55a8ae164bb3702d5e764715">GetSoundPlayer</a> (<a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a> playerId) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a481c256f55a8ae164bb3702d5e764715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sound player with the specified ID.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a481c256f55a8ae164bb3702d5e764715">More...</a><br /></td></tr>
<tr class="separator:a481c256f55a8ae164bb3702d5e764715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24005c420d53246f71f03e0130f1409c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1atk_1_1_sound_player.html">SoundPlayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a24005c420d53246f71f03e0130f1409c">GetSoundPlayer</a> (const char *pPlayerName) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a24005c420d53246f71f03e0130f1409c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sound player with the specified ID.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a24005c420d53246f71f03e0130f1409c">More...</a><br /></td></tr>
<tr class="separator:a24005c420d53246f71f03e0130f1409c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e630ea0859d7156d90ff9bf1c7de48"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnn_1_1atk_1_1_sound_player.html">SoundPlayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a13e630ea0859d7156d90ff9bf1c7de48">GetSoundPlayer</a> (<a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a> playerId) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a13e630ea0859d7156d90ff9bf1c7de48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sound player with the specified ID.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a13e630ea0859d7156d90ff9bf1c7de48">More...</a><br /></td></tr>
<tr class="separator:a13e630ea0859d7156d90ff9bf1c7de48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5bbafc249f43df55b8a7ec343d04510"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnn_1_1atk_1_1_sound_player.html">SoundPlayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ad5bbafc249f43df55b8a7ec343d04510">GetSoundPlayer</a> (const char *pPlayerName) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad5bbafc249f43df55b8a7ec343d04510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sound player with the specified ID.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#ad5bbafc249f43df55b8a7ec343d04510">More...</a><br /></td></tr>
<tr class="separator:ad5bbafc249f43df55b8a7ec343d04510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa717dbf0b25d9d2d7d0a381fd3702e61"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aa717dbf0b25d9d2d7d0a381fd3702e61">GetSoundUserParamSize</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa717dbf0b25d9d2d7d0a381fd3702e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the user parameters held by each sound instance.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#aa717dbf0b25d9d2d7d0a381fd3702e61">More...</a><br /></td></tr>
<tr class="separator:aa717dbf0b25d9d2d7d0a381fd3702e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Getting the Number of Instances</div></td></tr>
<tr class="memitem:a9f38a3771241a0ed28170c9e31d22afb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a9f38a3771241a0ed28170c9e31d22afb">GetSoundPlayerCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9f38a3771241a0ed28170c9e31d22afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of sound players.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a9f38a3771241a0ed28170c9e31d22afb">More...</a><br /></td></tr>
<tr class="separator:a9f38a3771241a0ed28170c9e31d22afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0f078634d736ad58ce5729d6109b3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ada0f078634d736ad58ce5729d6109b3f">GetFreeSequenceSoundCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ada0f078634d736ad58ce5729d6109b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the remaining number of playable sequence sounds.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#ada0f078634d736ad58ce5729d6109b3f">More...</a><br /></td></tr>
<tr class="separator:ada0f078634d736ad58ce5729d6109b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cde7f084898accc2a3e2a1759c50d51"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a8cde7f084898accc2a3e2a1759c50d51">GetFreeWaveSoundCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8cde7f084898accc2a3e2a1759c50d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the remaining number of playable wave sounds.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a8cde7f084898accc2a3e2a1759c50d51">More...</a><br /></td></tr>
<tr class="separator:a8cde7f084898accc2a3e2a1759c50d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ddb064cdb8a7fd11739c70d543ee61"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ad1ddb064cdb8a7fd11739c70d543ee61">GetFreeStreamSoundCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad1ddb064cdb8a7fd11739c70d543ee61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the remaining number of playable stream sounds.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#ad1ddb064cdb8a7fd11739c70d543ee61">More...</a><br /></td></tr>
<tr class="separator:ad1ddb064cdb8a7fd11739c70d543ee61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80612cb40a838769e36a3f321a1cde4b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a80612cb40a838769e36a3f321a1cde4b">GetActiveWaveSoundCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a80612cb40a838769e36a3f321a1cde4b"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <b>The use of internal features is prohibited.</b>  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a80612cb40a838769e36a3f321a1cde4b">More...</a><br /></td></tr>
<tr class="separator:a80612cb40a838769e36a3f321a1cde4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ceb334dd5eb9133e93abd88017d1bf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a37ceb334dd5eb9133e93abd88017d1bf">GetActiveSequenceSoundCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a37ceb334dd5eb9133e93abd88017d1bf"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <b>The use of internal features is prohibited.</b>  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a37ceb334dd5eb9133e93abd88017d1bf">More...</a><br /></td></tr>
<tr class="separator:a37ceb334dd5eb9133e93abd88017d1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027c2acb6ee6baae3f967091250d9bbb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a027c2acb6ee6baae3f967091250d9bbb">GetActiveStreamSoundCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a027c2acb6ee6baae3f967091250d9bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <b>The use of internal features is prohibited.</b>  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a027c2acb6ee6baae3f967091250d9bbb">More...</a><br /></td></tr>
<tr class="separator:a027c2acb6ee6baae3f967091250d9bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Play</div></td></tr>
<tr class="memitem:a9a075bc1dea627defdc533d514e50c33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">StartResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_startable.html#a9a075bc1dea627defdc533d514e50c33">StartSound</a> (<a class="el" href="classnn_1_1atk_1_1_sound_handle.html">SoundHandle</a> *pHandle, <a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a> soundId, const <a class="el" href="structnn_1_1atk_1_1_sound_startable_1_1_start_info.html">StartInfo</a> *pStartInfo=NULL) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9a075bc1dea627defdc533d514e50c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plays the sound with the specified ID.  <a href="classnn_1_1atk_1_1_sound_startable.html#a9a075bc1dea627defdc533d514e50c33">More...</a><br /></td></tr>
<tr class="separator:a9a075bc1dea627defdc533d514e50c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8c99a4b8a9af64ac1604490eb92e85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">StartResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_startable.html#aad8c99a4b8a9af64ac1604490eb92e85">StartSound</a> (<a class="el" href="classnn_1_1atk_1_1_sound_handle.html">SoundHandle</a> *pHandle, <a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a> soundId, const char *soundArchiveName, const <a class="el" href="structnn_1_1atk_1_1_sound_startable_1_1_start_info.html">StartInfo</a> *pStartInfo=NULL) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aad8c99a4b8a9af64ac1604490eb92e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plays the sound of the specified sound archive and ID.  <a href="classnn_1_1atk_1_1_sound_startable.html#aad8c99a4b8a9af64ac1604490eb92e85">More...</a><br /></td></tr>
<tr class="separator:aad8c99a4b8a9af64ac1604490eb92e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7259f5cb7f4c89ebae54d2c102e1a9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">StartResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_startable.html#af7259f5cb7f4c89ebae54d2c102e1a9e">StartSound</a> (<a class="el" href="classnn_1_1atk_1_1_sound_handle.html">SoundHandle</a> *pHandle, const char *pSoundName, const <a class="el" href="structnn_1_1atk_1_1_sound_startable_1_1_start_info.html">StartInfo</a> *pStartInfo=NULL) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af7259f5cb7f4c89ebae54d2c102e1a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plays the sound with the specified label string.  <a href="classnn_1_1atk_1_1_sound_startable.html#af7259f5cb7f4c89ebae54d2c102e1a9e">More...</a><br /></td></tr>
<tr class="separator:af7259f5cb7f4c89ebae54d2c102e1a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b4818e3c22546b1884dee8a0d51a49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">StartResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_startable.html#ae6b4818e3c22546b1884dee8a0d51a49">StartSound</a> (<a class="el" href="classnn_1_1atk_1_1_sound_handle.html">SoundHandle</a> *pHandle, const char *pSoundName, const char *soundArchiveName, const <a class="el" href="structnn_1_1atk_1_1_sound_startable_1_1_start_info.html">StartInfo</a> *pStartInfo=NULL) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae6b4818e3c22546b1884dee8a0d51a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plays the sound of the specified sound archive and label string.  <a href="classnn_1_1atk_1_1_sound_startable.html#ae6b4818e3c22546b1884dee8a0d51a49">More...</a><br /></td></tr>
<tr class="separator:ae6b4818e3c22546b1884dee8a0d51a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937f7cc13e6961341777ce0b634d47e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">StartResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_startable.html#a937f7cc13e6961341777ce0b634d47e8">HoldSound</a> (<a class="el" href="classnn_1_1atk_1_1_sound_handle.html">SoundHandle</a> *pHandle, <a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a> soundId, const <a class="el" href="structnn_1_1atk_1_1_sound_startable_1_1_start_info.html">StartInfo</a> *pHoldInfo=NULL) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a937f7cc13e6961341777ce0b634d47e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plays or continues the sound with the specified ID.  <a href="classnn_1_1atk_1_1_sound_startable.html#a937f7cc13e6961341777ce0b634d47e8">More...</a><br /></td></tr>
<tr class="separator:a937f7cc13e6961341777ce0b634d47e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf3071a86e28209541371e5f69784b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">StartResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_startable.html#a3bf3071a86e28209541371e5f69784b0">HoldSound</a> (<a class="el" href="classnn_1_1atk_1_1_sound_handle.html">SoundHandle</a> *pHandle, <a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a> soundId, const char *soundArchiveName, const <a class="el" href="structnn_1_1atk_1_1_sound_startable_1_1_start_info.html">StartInfo</a> *pHoldInfo=NULL) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3bf3071a86e28209541371e5f69784b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plays or continues playing the sound of the specified sound archive and ID.  <a href="classnn_1_1atk_1_1_sound_startable.html#a3bf3071a86e28209541371e5f69784b0">More...</a><br /></td></tr>
<tr class="separator:a3bf3071a86e28209541371e5f69784b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660336390bde50606cb2cbd421d08770"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">StartResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_startable.html#a660336390bde50606cb2cbd421d08770">HoldSound</a> (<a class="el" href="classnn_1_1atk_1_1_sound_handle.html">SoundHandle</a> *pHandle, const char *pSoundName, const <a class="el" href="structnn_1_1atk_1_1_sound_startable_1_1_start_info.html">StartInfo</a> *pHoldInfo=NULL) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a660336390bde50606cb2cbd421d08770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plays or holds the sound with the specified label string.  <a href="classnn_1_1atk_1_1_sound_startable.html#a660336390bde50606cb2cbd421d08770">More...</a><br /></td></tr>
<tr class="separator:a660336390bde50606cb2cbd421d08770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6ef3923b4034114ffd3bec3c861ce7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">StartResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_startable.html#abe6ef3923b4034114ffd3bec3c861ce7">HoldSound</a> (<a class="el" href="classnn_1_1atk_1_1_sound_handle.html">SoundHandle</a> *pHandle, const char *pSoundName, const char *soundArchiveName, const <a class="el" href="structnn_1_1atk_1_1_sound_startable_1_1_start_info.html">StartInfo</a> *pHoldInfo=NULL) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:abe6ef3923b4034114ffd3bec3c861ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plays or continues playing the sound of the specified sound archive and label string.  <a href="classnn_1_1atk_1_1_sound_startable.html#abe6ef3923b4034114ffd3bec3c861ce7">More...</a><br /></td></tr>
<tr class="separator:abe6ef3923b4034114ffd3bec3c861ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaedfc0d6b40a7f824e74f274785b484e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">StartResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_startable.html#aaedfc0d6b40a7f824e74f274785b484e">PrepareSound</a> (<a class="el" href="classnn_1_1atk_1_1_sound_handle.html">SoundHandle</a> *pHandle, <a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a> soundId, const <a class="el" href="structnn_1_1atk_1_1_sound_startable_1_1_start_info.html">StartInfo</a> *pStartInfo=NULL) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aaedfc0d6b40a7f824e74f274785b484e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares to play the sound with the specified ID.  <a href="classnn_1_1atk_1_1_sound_startable.html#aaedfc0d6b40a7f824e74f274785b484e">More...</a><br /></td></tr>
<tr class="separator:aaedfc0d6b40a7f824e74f274785b484e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888e75f49a05eec7fd89e44d0397e74b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">StartResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_startable.html#a888e75f49a05eec7fd89e44d0397e74b">PrepareSound</a> (<a class="el" href="classnn_1_1atk_1_1_sound_handle.html">SoundHandle</a> *pHandle, <a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a> soundId, const char *soundArchiveName, const <a class="el" href="structnn_1_1atk_1_1_sound_startable_1_1_start_info.html">StartInfo</a> *pStartInfo=NULL) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a888e75f49a05eec7fd89e44d0397e74b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares to play the sound of the specified sound archive and ID.  <a href="classnn_1_1atk_1_1_sound_startable.html#a888e75f49a05eec7fd89e44d0397e74b">More...</a><br /></td></tr>
<tr class="separator:a888e75f49a05eec7fd89e44d0397e74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c46b7fc9e9c2c187964b7bf5aa1ff31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">StartResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_startable.html#a4c46b7fc9e9c2c187964b7bf5aa1ff31">PrepareSound</a> (<a class="el" href="classnn_1_1atk_1_1_sound_handle.html">SoundHandle</a> *pHandle, const char *pSoundName, const <a class="el" href="structnn_1_1atk_1_1_sound_startable_1_1_start_info.html">StartInfo</a> *pStartInfo=NULL) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4c46b7fc9e9c2c187964b7bf5aa1ff31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares to play the sound with the specified label string.  <a href="classnn_1_1atk_1_1_sound_startable.html#a4c46b7fc9e9c2c187964b7bf5aa1ff31">More...</a><br /></td></tr>
<tr class="separator:a4c46b7fc9e9c2c187964b7bf5aa1ff31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803fa7ba56fc913c226ccf4c54d73a55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">StartResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_startable.html#a803fa7ba56fc913c226ccf4c54d73a55">PrepareSound</a> (<a class="el" href="classnn_1_1atk_1_1_sound_handle.html">SoundHandle</a> *pHandle, const char *pSoundName, const char *soundArchiveName, const <a class="el" href="structnn_1_1atk_1_1_sound_startable_1_1_start_info.html">StartInfo</a> *pStartInfo=NULL) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a803fa7ba56fc913c226ccf4c54d73a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares to play the sound of the specified sound archive and label string.  <a href="classnn_1_1atk_1_1_sound_startable.html#a803fa7ba56fc913c226ccf4c54d73a55">More...</a><br /></td></tr>
<tr class="separator:a803fa7ba56fc913c226ccf4c54d73a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1a5677dd952a371a68249d88dc6eb35b"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a1a5677dd952a371a68249d88dc6eb35b">GetRequiredWorkBufferSizeToReadStreamSoundHeader</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1a5677dd952a371a68249d88dc6eb35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the working area needed to get stream sound header information.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a1a5677dd952a371a68249d88dc6eb35b">More...</a><br /></td></tr>
<tr class="separator:a1a5677dd952a371a68249d88dc6eb35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a075200f0bcc1a4892fa664a148c73dee"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a075200f0bcc1a4892fa664a148c73dee">AddonSoundArchiveNameLengthMax</a> = nn::atk::detail::AddonSoundArchiveContainer::SoundArchiveNameLengthMax</td></tr>
<tr class="memdesc:a075200f0bcc1a4892fa664a148c73dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum length of an <code><a class="el" href="classnn_1_1atk_1_1_addon_sound_archive.html" title="The additional sound archive.">AddonSoundArchive</a></code> name.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a075200f0bcc1a4892fa664a148c73dee">More...</a><br /></td></tr>
<tr class="separator:a075200f0bcc1a4892fa664a148c73dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae6957bb9012107e356845451a8ce84"><td class="memItemLeft" align="right" valign="top"><a id="a9ae6957bb9012107e356845451a8ce84"></a>
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a9ae6957bb9012107e356845451a8ce84">BufferAlignSize</a> = <a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html#accc6577525e99670d0ff97f76a73068f">nn::audio::MemoryPoolType::AddressAlignment</a></td></tr>
<tr class="memdesc:a9ae6957bb9012107e356845451a8ce84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer aligned size. <br /></td></tr>
<tr class="separator:a9ae6957bb9012107e356845451a8ce84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1384c59f80a74a59daf5055a67b3cb8"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ae1384c59f80a74a59daf5055a67b3cb8">StreamBufferTimesMax</a> = 4</td></tr>
<tr class="memdesc:ae1384c59f80a74a59daf5055a67b3cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum magnification for the stream buffer size obtained from <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a057468aa40f05336895186fecac53988">GetRequiredStreamBufferTimes</a></code>.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#ae1384c59f80a74a59daf5055a67b3cb8">More...</a><br /></td></tr>
<tr class="separator:ae1384c59f80a74a59daf5055a67b3cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45775787c4e3c73825290b10fd86bc9d"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a45775787c4e3c73825290b10fd86bc9d">UserParamBoundary</a> = 4</td></tr>
<tr class="memdesc:a45775787c4e3c73825290b10fd86bc9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boundary where the size of the user parameter is cut off.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a45775787c4e3c73825290b10fd86bc9d">More...</a><br /></td></tr>
<tr class="separator:a45775787c4e3c73825290b10fd86bc9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Initialization.</h2></td></tr>
<tr class="memitem:a778f7f63b34d09e5241e7f18aef3f227"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a778f7f63b34d09e5241e7f18aef3f227">GetRequiredStreamBufferSize</a> (const <a class="el" href="classnn_1_1atk_1_1_sound_archive.html">SoundArchive</a> *pArchive) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a778f7f63b34d09e5241e7f18aef3f227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the stream buffer required for initialization.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a778f7f63b34d09e5241e7f18aef3f227">More...</a><br /></td></tr>
<tr class="separator:a778f7f63b34d09e5241e7f18aef3f227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057468aa40f05336895186fecac53988"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a057468aa40f05336895186fecac53988">GetRequiredStreamBufferTimes</a> (const <a class="el" href="classnn_1_1atk_1_1_sound_archive.html">SoundArchive</a> *pArchive) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a057468aa40f05336895186fecac53988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the multiplication factor for the size of stream buffer required for initialization.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a057468aa40f05336895186fecac53988">More...</a><br /></td></tr>
<tr class="separator:a057468aa40f05336895186fecac53988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2de65567087f698294d36e91fd9b9f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aa2de65567087f698294d36e91fd9b9f9">Initialize</a> (const <a class="el" href="classnn_1_1atk_1_1_sound_archive.html">SoundArchive</a> *pArchive, const <a class="el" href="classnn_1_1atk_1_1_sound_data_manager.html">SoundDataManager</a> *pManager, void *pBuffer, size_t bufferSize, void *pStreamBuffer, size_t streamBufferSize, size_t userParamSizePerSound=0) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa2de65567087f698294d36e91fd9b9f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a sound archive player.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#aa2de65567087f698294d36e91fd9b9f9">More...</a><br /></td></tr>
<tr class="separator:aa2de65567087f698294d36e91fd9b9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcfeb67d3e8034a4368449e6611b289e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#afcfeb67d3e8034a4368449e6611b289e">Initialize</a> (const <a class="el" href="structnn_1_1atk_1_1_sound_archive_player_1_1_initialize_param.html">InitializeParam</a> &amp;param) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:afcfeb67d3e8034a4368449e6611b289e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a sound archive player.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#afcfeb67d3e8034a4368449e6611b289e">More...</a><br /></td></tr>
<tr class="separator:afcfeb67d3e8034a4368449e6611b289e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c9c644e782c4dc200eeaa89e358e27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ab8c9c644e782c4dc200eeaa89e358e27">Finalize</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab8c9c644e782c4dc200eeaa89e358e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a sound archive player.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#ab8c9c644e782c4dc200eeaa89e358e27">More...</a><br /></td></tr>
<tr class="separator:ab8c9c644e782c4dc200eeaa89e358e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba772c33240b201b76c9ab1a2a1a0f06"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aba772c33240b201b76c9ab1a2a1a0f06">IsAvailable</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aba772c33240b201b76c9ab1a2a1a0f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks availability for use.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#aba772c33240b201b76c9ab1a2a1a0f06">More...</a><br /></td></tr>
<tr class="separator:aba772c33240b201b76c9ab1a2a1a0f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ae9eba7e9ffd8b45b2714bb721f9aa"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a69ae9eba7e9ffd8b45b2714bb721f9aa">GetRequiredMemSize</a> (const <a class="el" href="classnn_1_1atk_1_1_sound_archive.html">SoundArchive</a> *pArchive) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a69ae9eba7e9ffd8b45b2714bb721f9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the memory size that is required for initialization.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a69ae9eba7e9ffd8b45b2714bb721f9aa">More...</a><br /></td></tr>
<tr class="separator:a69ae9eba7e9ffd8b45b2714bb721f9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e91e2c8502cf393af683fbec9693bf9"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a5e91e2c8502cf393af683fbec9693bf9">GetRequiredMemSize</a> (const <a class="el" href="classnn_1_1atk_1_1_sound_archive.html">SoundArchive</a> *pArchive, size_t userParamSizePerSound) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5e91e2c8502cf393af683fbec9693bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the memory size that is required for initialization.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#a5e91e2c8502cf393af683fbec9693bf9">More...</a><br /></td></tr>
<tr class="separator:a5e91e2c8502cf393af683fbec9693bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad603f32b9162a99285cce4dfa47e81be"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ad603f32b9162a99285cce4dfa47e81be">GetRequiredMemSize</a> (const <a class="el" href="classnn_1_1atk_1_1_sound_archive.html">SoundArchive</a> *pArchive, size_t userParamSizePerSound, int addonSoundArchiveCount) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad603f32b9162a99285cce4dfa47e81be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the memory size that is required for initialization.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#ad603f32b9162a99285cce4dfa47e81be">More...</a><br /></td></tr>
<tr class="separator:ad603f32b9162a99285cce4dfa47e81be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b4d9e6034b9f0e9f8b86b0fb8df9fa"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ac3b4d9e6034b9f0e9f8b86b0fb8df9fa">GetRequiredMemSize</a> (const <a class="el" href="structnn_1_1atk_1_1_sound_archive_player_1_1_initialize_param.html">InitializeParam</a> &amp;param) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac3b4d9e6034b9f0e9f8b86b0fb8df9fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the memory size that is required for initialization.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#ac3b4d9e6034b9f0e9f8b86b0fb8df9fa">More...</a><br /></td></tr>
<tr class="separator:ac3b4d9e6034b9f0e9f8b86b0fb8df9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19f8f15307c045093434d81cc832da0"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ab19f8f15307c045093434d81cc832da0">GetRequiredStreamInstanceSize</a> (const <a class="el" href="classnn_1_1atk_1_1_sound_archive.html">nn::atk::SoundArchive</a> *pArchive) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab19f8f15307c045093434d81cc832da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the memory size required for the stream sound instance.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#ab19f8f15307c045093434d81cc832da0">More...</a><br /></td></tr>
<tr class="separator:ab19f8f15307c045093434d81cc832da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70074367d02753c1eae455bff0fb570"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#af70074367d02753c1eae455bff0fb570">GetRequiredStreamCacheSize</a> (const <a class="el" href="classnn_1_1atk_1_1_sound_archive.html">SoundArchive</a> *pArchive, size_t cacheSizePerSound) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af70074367d02753c1eae455bff0fb570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the buffer size for the file read cache used during streaming sound playback.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#af70074367d02753c1eae455bff0fb570">More...</a><br /></td></tr>
<tr class="separator:af70074367d02753c1eae455bff0fb570"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Sequence Sound Customization</h2></td></tr>
<tr class="memitem:aa39be42f75732183b60d027267073a8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aa39be42f75732183b60d027267073a8b">SetSequenceUserProcCallback</a> (<a class="el" href="namespacenn_1_1atk.html#a82b1ff1657c3ae76cb229ff28bea025d">SequenceUserProcCallback</a> callback, void *pCallbackArg) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa39be42f75732183b60d027267073a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the callback function that is invoked by the <code>userproc</code> sequence command.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#aa39be42f75732183b60d027267073a8b">More...</a><br /></td></tr>
<tr class="separator:aa39be42f75732183b60d027267073a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3217de46093e207f5185d7be48d744f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#af3217de46093e207f5185d7be48d744f">SetSequenceSkipIntervalTick</a> (int intervalTick) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af3217de46093e207f5185d7be48d744f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the blank width for the skip process for midstream playback of sequence sounds.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#af3217de46093e207f5185d7be48d744f">More...</a><br /></td></tr>
<tr class="separator:af3217de46093e207f5185d7be48d744f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78056fc2a14859ad23a02a916084c30"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ab78056fc2a14859ad23a02a916084c30">GetSequenceSkipIntervalTick</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab78056fc2a14859ad23a02a916084c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the blank width for the skip process for midstream playback of sequence sounds.  <a href="classnn_1_1atk_1_1_sound_archive_player.html#ab78056fc2a14859ad23a02a916084c30">More...</a><br /></td></tr>
<tr class="separator:ab78056fc2a14859ad23a02a916084c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Plays back sounds in a sound archive. </p>
<p> <b>Details</b> <br  />
 The sounds played back by the <a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a> can be controlled by using the handle class.</p>
<p>Note the following if you plan to put sound archive files (BFSAR files) or stream sound files (BFSTM files) on an SD card via a downloaded purchase, downloadable content, or a patch.</p>
<p>Occasionally, when stream sound (BFSTM) files stored on an SD card are played, or when data from sound archive (BFSAR) files on an SD card is played frequently using a player heap, the data on the SD card may become corrupted.</p>
<p>There are several ways to limit this kind of data corruption, including not using the player heap for sounds that are played frequently, and using the file read cache for playing stream sounds.</p>
<p>For more information about the stream sound file read cache, see <a class="el" href="structnn_1_1atk_1_1_sound_archive_player_1_1_initialize_param.html">InitializeParam</a>, which passes the structure.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_handle.html" title="A handle class that controls playback sounds.">SoundHandle</a> Class </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_startable.html" title="An abstract class representing playable sounds.">SoundStartable</a> Interface </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_atk_addon_sound_archive_2_atk_addon_sound_archive_8cpp-example.html#_a2">AtkAddonSoundArchive/AtkAddonSoundArchive.cpp</a>, <a class="el" href="_atk_effect_2_atk_effect_8cpp-example.html#_a2">AtkEffect/AtkEffect.cpp</a>, <a class="el" href="_atk_filter_2_atk_filter_8cpp-example.html#_a2">AtkFilter/AtkFilter.cpp</a>, <a class="el" href="_atk_group_2_atk_group_8cpp-example.html#_a2">AtkGroup/AtkGroup.cpp</a>, <a class="el" href="_atk_mix_mode_2_atk_mix_mode_8cpp-example.html#_a2">AtkMixMode/AtkMixMode.cpp</a>, <a class="el" href="_atk_profile_2_atk_profile_8cpp-example.html#_a2">AtkProfile/AtkProfile.cpp</a>, <a class="el" href="_atk_simple_2_atk_simple_8cpp-example.html#_a2">AtkSimple/AtkSimple.cpp</a>, <a class="el" href="_atk_sound3_d_2_atk_sound3_d_8cpp-example.html#_a2">AtkSound3D/AtkSound3D.cpp</a>, <a class="el" href="_atk_sound_actor_2_atk_sound_actor_8cpp-example.html#_a2">AtkSoundActor/AtkSoundActor.cpp</a>, <a class="el" href="_atk_stream_sound_2_atk_stream_sound_8cpp-example.html#_a2">AtkStreamSound/AtkStreamSound.cpp</a>, <a class="el" href="_atk_sub_mix_2_atk_sub_mix_8cpp-example.html#_a2">AtkSubMix/AtkSubMix.cpp</a>, and <a class="el" href="_atk_viewer_2_atk_viewer_8cpp-example.html#_a2">AtkViewer/AtkViewer.cpp</a>.</dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a69ae9eba7e9ffd8b45b2714bb721f9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ae9eba7e9ffd8b45b2714bb721f9aa">&#9670;&nbsp;</a></span>GetRequiredMemSize() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t nn::atk::SoundArchivePlayer::GetRequiredMemSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnn_1_1atk_1_1_sound_archive.html">SoundArchive</a> *&#160;</td>
          <td class="paramname"><em>pArchive</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the memory size that is required for initialization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pArchive</td><td>Sound archive used by the player.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the memory size required for initialization.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aa2de65567087f698294d36e91fd9b9f9" title="Initializes a sound archive player.">Initialize</a> </dd></dl>

</div>
</div>
<a id="a5e91e2c8502cf393af683fbec9693bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e91e2c8502cf393af683fbec9693bf9">&#9670;&nbsp;</a></span>GetRequiredMemSize() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t nn::atk::SoundArchivePlayer::GetRequiredMemSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnn_1_1atk_1_1_sound_archive.html">SoundArchive</a> *&#160;</td>
          <td class="paramname"><em>pArchive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>userParamSizePerSound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the memory size that is required for initialization. </p>
<p> <b>Details</b> <br  />
 For more information about the <code><em>userParamSizePerSound</em></code> parameter, see <a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aa2de65567087f698294d36e91fd9b9f9">Initialize</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pArchive</td><td>Sound archive used by the player. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userParamSizePerSound</td><td>Buffer size of the user parameters holding each sound instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the memory size required for initialization.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aa2de65567087f698294d36e91fd9b9f9" title="Initializes a sound archive player.">Initialize</a> </dd></dl>

</div>
</div>
<a id="ad603f32b9162a99285cce4dfa47e81be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad603f32b9162a99285cce4dfa47e81be">&#9670;&nbsp;</a></span>GetRequiredMemSize() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t nn::atk::SoundArchivePlayer::GetRequiredMemSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnn_1_1atk_1_1_sound_archive.html">SoundArchive</a> *&#160;</td>
          <td class="paramname"><em>pArchive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>userParamSizePerSound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addonSoundArchiveCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the memory size that is required for initialization. </p>
<p> <b>Details</b> <br  />
 For more information about the <code><em>userParamSizePerSound</em></code> parameter, see <a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aa2de65567087f698294d36e91fd9b9f9">Initialize</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pArchive</td><td>Sound archive used by the player. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userParamSizePerSound</td><td>Buffer size of the user parameters holding each sound instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addonSoundArchiveCount</td><td>The number of additional sound archives used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the memory size required for initialization.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aa2de65567087f698294d36e91fd9b9f9" title="Initializes a sound archive player.">Initialize</a> </dd></dl>

</div>
</div>
<a id="ac3b4d9e6034b9f0e9f8b86b0fb8df9fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b4d9e6034b9f0e9f8b86b0fb8df9fa">&#9670;&nbsp;</a></span>GetRequiredMemSize() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t nn::atk::SoundArchivePlayer::GetRequiredMemSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1atk_1_1_sound_archive_player_1_1_initialize_param.html">InitializeParam</a> &amp;&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the memory size that is required for initialization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>The initialization parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the memory size required for initialization. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>param</em>.pSoundArchive</code> != <code>NULL</code>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aa2de65567087f698294d36e91fd9b9f9" title="Initializes a sound archive player.">Initialize</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ab19f8f15307c045093434d81cc832da0" title="Gets the memory size required for the stream sound instance.">GetRequiredStreamInstanceSize</a> </dd></dl>

</div>
</div>
<a id="ab19f8f15307c045093434d81cc832da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19f8f15307c045093434d81cc832da0">&#9670;&nbsp;</a></span>GetRequiredStreamInstanceSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t nn::atk::SoundArchivePlayer::GetRequiredStreamInstanceSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnn_1_1atk_1_1_sound_archive.html">nn::atk::SoundArchive</a> *&#160;</td>
          <td class="paramname"><em>pArchive</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the memory size required for the stream sound instance. </p>
<p> <b>Details</b> <br  />
 Returns the size proportional to the number of stream sounds defined in the sound archive file (BFSAR file), as specified in SoundMaker under <b>Project Settings</b> &gt; <b>Sound Archive</b> &gt; <b>Max. Number of Stream Sounds</b>.</p>
<p>You normally initialize stream sound instances using a part of the buffer specified for <a class="el" href="structnn_1_1atk_1_1_sound_archive_player_1_1_initialize_param.html#ae3247345845a2034158ca2ed8a3285be">InitializeParam::pSetupBuffer</a>. The library manages the memory pool internally because the buffer for this instance must be managed by the memory pool.</p>
<p>Set the buffer managed by the memory pool to <a class="el" href="structnn_1_1atk_1_1_sound_archive_player_1_1_initialize_param.html#a5c72c5b98575f05727e71f7bc2a3a9bb">InitializeParam::pStreamInstanceBuffer</a> to enable memory pool management for the instance buffer from the user, not the library, side. Doing so saves a maximum of <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html#a467d165cfdefac5aafe85cc003482ace" title="The size granularity required for the buffer for MemoryPoolType.">nn::audio::MemoryPoolType::SizeGranularity</a></code> memory size and shortens both initialization and finalization times by a maximum of one audio frame.</p>
<p>When using this feature, set <a class="el" href="structnn_1_1atk_1_1_sound_archive_player_1_1_initialize_param.html#a4c7d3e2f043f055cec5dfd8e9e10f5bd">InitializeParam::enablePreparingStreamInstanceBufferFromSetupBuffer</a> to <code>false</code>, use the size obtained by this function to specify a buffer managed by a memory pool for <a class="el" href="structnn_1_1atk_1_1_sound_archive_player_1_1_initialize_param.html#a5c72c5b98575f05727e71f7bc2a3a9bb">InitializeParam::pStreamInstanceBuffer</a>, and use the size obtained by the version of <a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a69ae9eba7e9ffd8b45b2714bb721f9aa">GetRequiredMemSize</a> that takes <a class="el" href="structnn_1_1atk_1_1_sound_archive_player_1_1_initialize_param.html">InitializeParam</a> as a parameter to specify a buffer for <a class="el" href="structnn_1_1atk_1_1_sound_archive_player_1_1_initialize_param.html#ae3247345845a2034158ca2ed8a3285be">InitializeParam::pSetupBuffer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pArchive</td><td>Sound archive used by the player.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the memory size needed for stream sound instances.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aa2de65567087f698294d36e91fd9b9f9" title="Initializes a sound archive player.">Initialize</a> </dd>
<dd>
<a class="el" href="structnn_1_1atk_1_1_sound_archive_player_1_1_initialize_param.html" title="Structure used to initialize the sound archive player.">InitializeParam</a> Structure </dd></dl>

</div>
</div>
<a id="a778f7f63b34d09e5241e7f18aef3f227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778f7f63b34d09e5241e7f18aef3f227">&#9670;&nbsp;</a></span>GetRequiredStreamBufferSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::atk::SoundArchivePlayer::GetRequiredStreamBufferSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnn_1_1atk_1_1_sound_archive.html">SoundArchive</a> *&#160;</td>
          <td class="paramname"><em>pArchive</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of the stream buffer required for initialization. </p>
<p> <b>Details</b> <br  />
 Gets the minimum stream buffer size to pass to <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aa2de65567087f698294d36e91fd9b9f9">Initialize</a></code>. You must pass a buffer larger than the value obtained with this function, and up to <code>StreamBufferTimesMax</code> times its size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pArchive</td><td>Sound archive used by the player.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the stream buffer size required for initialization.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aa2de65567087f698294d36e91fd9b9f9" title="Initializes a sound archive player.">Initialize</a> </dd></dl>

</div>
</div>
<a id="a057468aa40f05336895186fecac53988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a057468aa40f05336895186fecac53988">&#9670;&nbsp;</a></span>GetRequiredStreamBufferTimes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::atk::SoundArchivePlayer::GetRequiredStreamBufferTimes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnn_1_1atk_1_1_sound_archive.html">SoundArchive</a> *&#160;</td>
          <td class="paramname"><em>pArchive</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the multiplication factor for the size of stream buffer required for initialization. </p>
<p> <b>Details</b> <br  />
 This function gets the multiplication factor indicating how many times larger the stream buffer passed to <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aa2de65567087f698294d36e91fd9b9f9">Initialize</a></code> must be compared to the minimum buffer size obtained by <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a778f7f63b34d09e5241e7f18aef3f227">GetRequiredStreamBufferSize</a></code>. You must pass a buffer that is larger by more than this many times. If it is not large enough, you may not be able to use some of the prefetch data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pArchive</td><td>Sound archive used by the player.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the multiplication factor for the size of stream buffer required for initialization.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aa2de65567087f698294d36e91fd9b9f9" title="Initializes a sound archive player.">Initialize</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a778f7f63b34d09e5241e7f18aef3f227" title="Gets the size of the stream buffer required for initialization.">GetRequiredStreamBufferSize</a> </dd></dl>

</div>
</div>
<a id="aa2de65567087f698294d36e91fd9b9f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2de65567087f698294d36e91fd9b9f9">&#9670;&nbsp;</a></span>Initialize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::atk::SoundArchivePlayer::Initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnn_1_1atk_1_1_sound_archive.html">SoundArchive</a> *&#160;</td>
          <td class="paramname"><em>pArchive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnn_1_1atk_1_1_sound_data_manager.html">SoundDataManager</a> *&#160;</td>
          <td class="paramname"><em>pManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pStreamBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>streamBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>userParamSizePerSound</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a sound archive player. </p>
<p> <b>Details</b> <br  />
 Sound archive players must be initialized before they are used. Initializing the sound archive player associates it with a sound archive and sound data manager, enabling it to play the data in the sound archive.</p>
<p>To get the memory size required by the sound archive player, use <a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a69ae9eba7e9ffd8b45b2714bb721f9aa">GetRequiredMemSize</a> or <a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a778f7f63b34d09e5241e7f18aef3f227">GetRequiredStreamBufferSize</a>.</p>
<p>If the required stream buffer size is <code>0</code>, you can pass <code>NULL</code> to <code><em>pStreamBuffer</em></code>, the pointer to the stream buffer.</p>
<p>If the stream buffer is set larger than the size obtained by <a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a778f7f63b34d09e5241e7f18aef3f227">GetRequiredStreamBufferSize</a>, there is less tendency for audio dropouts, but it takes longer before you can begin actually playing sounds after loading data.</p>
<p>The stream buffer can be set to a size up to <a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ae1384c59f80a74a59daf5055a67b3cb8">StreamBufferTimesMax</a> times the size obtained using the <a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a778f7f63b34d09e5241e7f18aef3f227">GetRequiredStreamBufferSize</a> function. If it is set to a size that is greater than <a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ae1384c59f80a74a59daf5055a67b3cb8">StreamBufferTimesMax</a> times the obtained size, processing stops on an assertion failure in the debug and develop versions. The behavior in the Release version is undefined.</p>
<p>Use the <code><em>userParamSizePerSound</em></code> parameter to give each sound instance its own user parameters (areas that the user can freely read and write).</p>
<p>These user parameters are different from the user parameters set in SoundMaker. The user parameters set in SoundMaker are parameters linked to individual sound IDs and are read-only data accessible with <code><a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a6ff392171dbb97685078e28ee93e4845">SoundArchive::ReadSoundUserParam</a></code>. In contrast, these user parameters are associated with individual sound instances and they can be both read from and written to inside the program.</p>
<p>SoundMaker's user parameters can only hold up to four <code>uint32_t</code> values, whereas these user parameters can hold as many values as fit in the size passed to the <code><em>userParamSizePerSound</em></code> parameter.</p>
<p>If you pass a value of <code>1</code> or greater to <code><em>userParamSizePerSound</em></code> and initialize, you can use the <code><a class="el" href="classnn_1_1atk_1_1_sound_handle.html#a24e52799bab3aded76a16b7ff1d8f41f">SoundHandle::GetUserParam</a></code> function to get the user parameter when you play the sounds. If a value of <code>0</code> is specified for <code><em>userParamSizePerSound</em></code>, <code><a class="el" href="classnn_1_1atk_1_1_sound_handle.html" title="A handle class that controls playback sounds.">SoundHandle</a>:*GetUserParam</code> returns <code>NULL</code>. User parameters are cleared to zero when a sound starts playing.</p>
<p>To get the actual size of the user parameters held by each sound instance, use <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aa717dbf0b25d9d2d7d0a381fd3702e61">GetSoundUserParamSize</a></code>.</p>
<p>Note that the same value must be specified for <code><em>userParamSizePerSound</em></code> as for the <code><em>userParamSizePerSound</em></code> parameter in <a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a69ae9eba7e9ffd8b45b2714bb721f9aa">GetRequiredMemSize</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pArchive</td><td>Sound archive used by the player. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pManager</td><td>Sound data manager used by the player. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBuffer</td><td>Pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Buffer size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pStreamBuffer</td><td>Pointer to the stream buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">streamBufferSize</td><td>The size of the stream buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userParamSizePerSound</td><td>The size of the user parameters per sound.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if initialization succeeded, or <code>false</code> otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pBuffer</em></code> is aligned to <a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a9ae6957bb9012107e356845451a8ce84">BufferAlignSize</a> bytes.</li>
<li><code><em>pStreamBuffer</em></code> is aligned to <code><a class="el" href="namespacenn_1_1audio.html#a61833f2e2cf0253e3054188e900315af" title="The alignment size for audio buffers.">nn::audio::BufferAlignSize</a></code>.</li>
<li><code><em>pArchive</em></code> != <code>nullptr</code>.</li>
<li><code><em>pManager</em></code> != <code>nullptr</code>.</li>
<li><code><em>pBuffer</em></code> != <code>nullptr</code>.</li>
<li><code><a class="el" href="classnn_1_1atk_1_1_sound_system.html">SoundSystem</a></code> is initialized.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a69ae9eba7e9ffd8b45b2714bb721f9aa" title="Gets the memory size that is required for initialization.">GetRequiredMemSize</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a778f7f63b34d09e5241e7f18aef3f227" title="Gets the size of the stream buffer required for initialization.">GetRequiredStreamBufferSize</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ab8c9c644e782c4dc200eeaa89e358e27" title="Destroys a sound archive player.">Finalize</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aba772c33240b201b76c9ab1a2a1a0f06" title="Checks availability for use.">IsAvailable</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_atk_viewer_2_atk_viewer_8cpp-example.html#a31">AtkViewer/AtkViewer.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af70074367d02753c1eae455bff0fb570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70074367d02753c1eae455bff0fb570">&#9670;&nbsp;</a></span>GetRequiredStreamCacheSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t nn::atk::SoundArchivePlayer::GetRequiredStreamCacheSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnn_1_1atk_1_1_sound_archive.html">SoundArchive</a> *&#160;</td>
          <td class="paramname"><em>pArchive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cacheSizePerSound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the buffer size for the file read cache used during streaming sound playback. </p>
<p> <b>Details</b> <br  />
 Returns the size proportional to the number of stream sounds defined in the sound archive file (BFSAR file), as specified in SoundMaker under <b>Project Settings</b> &gt; <b>Sound Archive</b> &gt; <b>Max. Number of Stream Sounds</b>.</p>
<p>Use the following guidelines on the sizes to pass to <code><em>cacheSizePerSound</em></code>. </p><pre class="fragment">       - If sound is only a monaural stream, pass a multiple of 8 KB.
       - If sound is stereo (including multi-track streaming), pass a multiple of 16 KB.
</pre><p> Using a cache has the follow advantages and disadvantages.</p>
<h3><a class="anchor" id="autotoc_md363"></a>
Advantages</h3>
<ul>
<li>If the stream sound file is on an SD card, the possibility of garbled data occurring is limited because the number of SD card accesses drops.</li>
<li>It can ameliorate audio dropouts during stream playback. (You can ameliorate the loss of sound when playing streams when the next stage data is loaded in the background, or when you are playing multiple stream sounds simultaneously.)</li>
</ul>
<h3><a class="anchor" id="autotoc_md364"></a>
Disadvantages</h3>
<ul>
<li>Because the cache is configured for all streamed sound instances, the cache is configured even for sounds that do not require it, using excess memory.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pArchive</td><td>The sound archive used by the sound archive player. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cacheSizePerSound</td><td>The file read cache size per stream sound.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the buffer size for the file read cache when playing stream sounds.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structnn_1_1atk_1_1_sound_archive_player_1_1_initialize_param.html" title="Structure used to initialize the sound archive player.">InitializeParam</a> Structure </dd></dl>

</div>
</div>
<a id="afcfeb67d3e8034a4368449e6611b289e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcfeb67d3e8034a4368449e6611b289e">&#9670;&nbsp;</a></span>Initialize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::atk::SoundArchivePlayer::Initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1atk_1_1_sound_archive_player_1_1_initialize_param.html">InitializeParam</a> &amp;&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a sound archive player. </p>
<p> <b>Details</b> <br  />
 Sound archive players must be initialized before they are used. Initialization associates a sound archive and a sound data manager and enables the sound archive player to play the data in the sound archive.</p>
<p>The memory size required by the sound archive player can be found with the following functions. </p><pre class="fragment">       - &lt;tt&gt;@ref GetRequiredMemSize&lt;/tt&gt;
       - &lt;tt&gt;@ref GetRequiredStreamBufferSize&lt;/tt&gt;
       - &lt;tt&gt;@ref GetRequiredStreamCacheSize&lt;/tt&gt;
       - &lt;tt&gt;@ref GetRequiredStreamInstanceSize&lt;/tt&gt;
</pre><p> The memory size obtained from these functions and the associated memory region are stored in an <code><a class="el" href="structnn_1_1atk_1_1_sound_archive_player_1_1_initialize_param.html">InitializeParam</a></code> and passed to this function. Note that <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#af70074367d02753c1eae455bff0fb570">GetRequiredStreamCacheSize</a></code> and <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ab19f8f15307c045093434d81cc832da0">GetRequiredStreamInstanceSize</a></code> are set only when using file read cache or the features that specify a buffer for the stream instance.</p>
<p>If the stream buffer is set larger than the size obtained by <a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a778f7f63b34d09e5241e7f18aef3f227">GetRequiredStreamBufferSize</a>, there is less tendency for audio dropouts, but it takes longer before you can begin actually playing sounds after loading data.</p>
<p>The stream buffer can be set to a size up to <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ae1384c59f80a74a59daf5055a67b3cb8">StreamBufferTimesMax</a></code> times the size obtained using the <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a778f7f63b34d09e5241e7f18aef3f227">GetRequiredStreamBufferSize</a></code> function. If it is set to a value that is greater than <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ae1384c59f80a74a59daf5055a67b3cb8">StreamBufferTimesMax</a></code> times the obtained size, processing stops on an assertion failure in the Debug and Development versions. Stop. The behavior in the Release version is undefined.</p>
<p>The file system access frequency while playing streaming sound can be reduced by properly configuring the file read cache. For more information about cache buffer size, see <a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#af70074367d02753c1eae455bff0fb570">GetRequiredStreamCacheSize</a>.</p>
<p>You can reduce the time spent by <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aa2de65567087f698294d36e91fd9b9f9">Initialize</a></code> and <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ab8c9c644e782c4dc200eeaa89e358e27">Finalize</a></code> by as much as one audio frame by setting a stream instance buffer. In addition, the total buffer space requirement of the library will be reduced by as much as <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html#a467d165cfdefac5aafe85cc003482ace" title="The size granularity required for the buffer for MemoryPoolType.">nn::audio::MemoryPoolType::SizeGranularity</a></code>. For more information about setting stream instance buffers, see <a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ab19f8f15307c045093434d81cc832da0">GetRequiredStreamInstanceSize</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>The initialization parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structnn_1_1atk_1_1_sound_archive_player_1_1_initialize_param.html" title="Structure used to initialize the sound archive player.">InitializeParam</a> Structure </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a69ae9eba7e9ffd8b45b2714bb721f9aa" title="Gets the memory size that is required for initialization.">GetRequiredMemSize</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a778f7f63b34d09e5241e7f18aef3f227" title="Gets the size of the stream buffer required for initialization.">GetRequiredStreamBufferSize</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#af70074367d02753c1eae455bff0fb570" title="Gets the buffer size for the file read cache used during streaming sound playback.">GetRequiredStreamCacheSize</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ab19f8f15307c045093434d81cc832da0" title="Gets the memory size required for the stream sound instance.">GetRequiredStreamInstanceSize</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ab8c9c644e782c4dc200eeaa89e358e27" title="Destroys a sound archive player.">Finalize</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aba772c33240b201b76c9ab1a2a1a0f06" title="Checks availability for use.">IsAvailable</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if initialization succeeded, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ab8c9c644e782c4dc200eeaa89e358e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c9c644e782c4dc200eeaa89e358e27">&#9670;&nbsp;</a></span>Finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::atk::SoundArchivePlayer::Finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a sound archive player. </p>
<p> <b>Details</b> <br  />
 The following process destroys the sound archive player. </p><pre class="fragment">         - Sounds played using this sound archive player are stopped.
         - Memory allocated at initialization is freed.
         - Associations with the initialized sound archive are removed.
         - Frees the memory pool used by the sound instance.
</pre> <dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aa2de65567087f698294d36e91fd9b9f9" title="Initializes a sound archive player.">Initialize</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aba772c33240b201b76c9ab1a2a1a0f06" title="Checks availability for use.">IsAvailable</a> </dd></dl>

</div>
</div>
<a id="aba772c33240b201b76c9ab1a2a1a0f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba772c33240b201b76c9ab1a2a1a0f06">&#9670;&nbsp;</a></span>IsAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::atk::SoundArchivePlayer::IsAvailable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks availability for use. </p>
<p> <b>Details</b> <br  />
 To use a sound archive player, you must call <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aa2de65567087f698294d36e91fd9b9f9">Initialize</a></code> to finish initializing it. If you call <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ab8c9c644e782c4dc200eeaa89e358e27">Finalize</a></code>, the sound archive player is finalized and becomes unusable.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the sound archive player is in a usable state, or <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aa2de65567087f698294d36e91fd9b9f9" title="Initializes a sound archive player.">Initialize</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ab8c9c644e782c4dc200eeaa89e358e27" title="Destroys a sound archive player.">Finalize</a> </dd></dl>

</div>
</div>
<a id="a22e4ef8d9785639f48343fd84aba6d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22e4ef8d9785639f48343fd84aba6d3a">&#9670;&nbsp;</a></span>Update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::atk::SoundArchivePlayer::Update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the sound archive player. </p>
<p> <b>Details</b> <br  />
 Although this function does not need to be called every video frame, make sure that you call it periodically at a frequency of about once per game frame.</p>
<p>Changing the frequency by which this function is called changes the time for fade in because there are ongoing processes that affect fade in and fade out parameters for players and sounds. This changes the duration of effects such as fade in.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_player.html#a5d964046c4902cb072bbff5ab43f4cd0" title="Stops all sounds.">SoundPlayer::StopAllSound</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_player.html#ab5eb17c2acd00f6051e4ef84103f7fd6" title="Pauses or restarts all sounds.">SoundPlayer::PauseAllSound</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_actor.html#a9e2ae682bf6c431f5d04fbf0967473d4" title="Stops all sounds being played by the actor.">SoundActor::StopAllSound</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_actor.html#a0b88e1745353ddba95acc210b0700939" title="Pauses or resumes all sounds currently being played by the actor.">SoundActor::PauseAllSound</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_actor.html#a9e2ae682bf6c431f5d04fbf0967473d4" title="Stops all sounds being played by the actor.">Sound3DActor::StopAllSound</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_actor.html#a0b88e1745353ddba95acc210b0700939" title="Pauses or resumes all sounds currently being played by the actor.">Sound3DActor::PauseAllSound</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_handle.html#a2ef2040a3bc7b007bc19a6efc26a88bb" title="Stops a sound.">SoundHandle::Stop</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_handle.html#a6e462d41d5f1abddebf2d9162c37bd00" title="Pauses or restarts a sound.">SoundHandle::Pause</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_handle.html#a0d22b35aed3567cb1df5c5f633561dbd" title="Fades in the sound when playback starts.">SoundHandle::FadeIn</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_handle.html#a684831af63fe0928ade6d0a339a5f535" title="Changes the volume of the sound.">SoundHandle::SetVolume</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_handle.html#ac78a7f078e57209b9b896d72036a2e49" title="Gets the number of frames that remain until the fade completes.">SoundHandle::GetRemainingFadeFrames</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_handle.html#ad71c47184fc88c8659fe34240dfcaa87" title="Gets the number of remaining frames until the fade completes, when the system is paused.">SoundHandle::GetRemainingPauseFadeFrames</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_stream_sound_handle.html#ade1d26ca89639ca05d2d0de56046afae" title="Stop a sound.">StreamSoundHandle::Stop</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_stream_sound_handle.html#a3ecb1a8880a2be6502f09b2605915e90" title="Pauses or restarts a sound.">StreamSoundHandle::Pause</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_stream_sound_handle.html#a8642253c7bd054953f967c0d3e708b7e" title="Fades in the sound when playback starts.">StreamSoundHandle::FadeIn</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_stream_sound_handle.html#a10c6875be0a26b1bd92100b5d6cd5fa0" title="Changes the volume of the sound.">StreamSoundHandle::SetVolume</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_stream_sound_handle.html#a5a3f1950275c6d71d4984e2e6160e510" title="Changes the volume of streaming sound tracks.">StreamSoundHandle::SetTrackVolume</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_wave_sound_handle.html#ac58b88d5fb673b5792643c2ec490f2cb" title="Stop a sound.">WaveSoundHandle::Stop</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_wave_sound_handle.html#a1b24b8c8c9c4fe0f0619565cf42724c3" title="Pauses or restarts a sound.">WaveSoundHandle::Pause</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_wave_sound_handle.html#a33d45722e26e5d33bc100623bddd9393" title="Fades in the sound when playback starts.">WaveSoundHandle::FadeIn</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_wave_sound_handle.html#a173437526b85e131156c414ef87c8f02" title="Changes the volume of the sound.">WaveSoundHandle::SetVolume</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sequence_sound_handle.html#a8220d44905efe68da8244bf22c81e125" title="Stop a sound.">SequenceSoundHandle::Stop</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sequence_sound_handle.html#aa475841013bdc7f1c455345103eed5b6" title="Pauses or restarts a sound.">SequenceSoundHandle::Pause</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sequence_sound_handle.html#aa07ee0117ba29c0f61218fe5e0e73176" title="Fades in the sound when playback starts.">SequenceSoundHandle::FadeIn</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sequence_sound_handle.html#a2a63fc3335d7e4177683fb504bdb3f65" title="Changes the volume of the sound.">SequenceSoundHandle::SetVolume</a> </dd></dl>

</div>
</div>
<a id="ae2c03bc431e10eff824952cc65fc2add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c03bc431e10eff824952cc65fc2add">&#9670;&nbsp;</a></span>GetSoundArchive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnn_1_1atk_1_1_sound_archive.html">SoundArchive</a>&amp; nn::atk::SoundArchivePlayer::GetSoundArchive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the sound archive that is bound to a player. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the sound archive bound to a player.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive.html" title="Class for handling a sound archive.">SoundArchive</a> Class </dd></dl>

</div>
</div>
<a id="aff0742165749cd2467cf8e913bc10d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0742165749cd2467cf8e913bc10d35">&#9670;&nbsp;</a></span>GetAddonSoundArchive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnn_1_1atk_1_1_addon_sound_archive.html">AddonSoundArchive</a>* nn::atk::SoundArchivePlayer::GetAddonSoundArchive </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>soundArchiveName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the additional sound archive linked to the player. </p>
<p> <b>Details</b> <br  />
 Gets the additional sound archive linked to the specified name. Returns <code>nullptr</code> if <code>nullptr</code> or an unregistered name is specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">soundArchiveName</td><td>The name for identification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the additional sound archive linked to the specified name.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ae333a16ca9227bd35cd079c16f2d4803" title="Adds an additional sound archive to a player.">AddAddonSoundArchive</a> </dd></dl>

</div>
</div>
<a id="a4c0f7fddca5bf28bcaebb8a307589976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0f7fddca5bf28bcaebb8a307589976">&#9670;&nbsp;</a></span>GetAddonSoundArchiveCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::atk::SoundArchivePlayer::GetAddonSoundArchiveCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of additional sound archives linked to the player. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of additional sound archives linked to the player.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ae333a16ca9227bd35cd079c16f2d4803" title="Adds an additional sound archive to a player.">AddAddonSoundArchive</a> </dd></dl>

</div>
</div>
<a id="a785e5a1510f605f085ee098bb2034966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785e5a1510f605f085ee098bb2034966">&#9670;&nbsp;</a></span>GetAddonSoundArchive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnn_1_1atk_1_1_addon_sound_archive.html">AddonSoundArchive</a>* nn::atk::SoundArchivePlayer::GetAddonSoundArchive </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the additional sound archive linked to the player. </p>
<p> <b>Details</b> <br  />
 Gets the additional sound archive for the specified index. Returns <code>nullptr</code> if an unregistered index is specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the additional sound archive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the additional sound archive linked to the index.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ae333a16ca9227bd35cd079c16f2d4803" title="Adds an additional sound archive to a player.">AddAddonSoundArchive</a> </dd></dl>

</div>
</div>
<a id="ad1f0cb7c9a0aeecc8253c321c7ec1f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f0cb7c9a0aeecc8253c321c7ec1f60">&#9670;&nbsp;</a></span>GetAddonSoundArchiveName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* nn::atk::SoundArchivePlayer::GetAddonSoundArchiveName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the names of additional sound archives linked to the player. </p>
<p> <b>Details</b> <br  />
 Gets the names of the additional sound archives in the specified index. Returns <code>nullptr</code> if an unregistered index is specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the additional sound archive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Gets the names of additional sound archives linked to the index.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ae333a16ca9227bd35cd079c16f2d4803" title="Adds an additional sound archive to a player.">AddAddonSoundArchive</a> </dd></dl>

</div>
</div>
<a id="ad9874b214f461b74e4c05f0667d77014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9874b214f461b74e4c05f0667d77014">&#9670;&nbsp;</a></span>GetAddonSoundDataManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnn_1_1atk_1_1_sound_data_manager.html">SoundDataManager</a>* nn::atk::SoundArchivePlayer::GetAddonSoundDataManager </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>soundArchiveName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the sound data manager of the additional sound archive linked to the player. </p>
<p> <b>Details</b> <br  />
 Gets the sound data manager of the additional sound archive linked to the specified name. Returns <code>nullptr</code> if <code>nullptr</code> or an unregistered name is specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">soundArchiveName</td><td>The name for identification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the sound data manager of the additional sound archive linked to the specified name.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ae333a16ca9227bd35cd079c16f2d4803" title="Adds an additional sound archive to a player.">AddAddonSoundArchive</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_data_manager.html" title="A flag used to load sound archive data.">SoundDataManager</a> Class </dd></dl>

</div>
</div>
<a id="a481c256f55a8ae164bb3702d5e764715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481c256f55a8ae164bb3702d5e764715">&#9670;&nbsp;</a></span>GetSoundPlayer() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1atk_1_1_sound_player.html">SoundPlayer</a>&amp; nn::atk::SoundArchivePlayer::GetSoundPlayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a>&#160;</td>
          <td class="paramname"><em>playerId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the sound player with the specified ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">playerId</td><td>A player ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the sound player with the specified ID.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_player.html" title="The player class for playing sounds.">SoundPlayer</a> Class </dd></dl>

</div>
</div>
<a id="a24005c420d53246f71f03e0130f1409c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24005c420d53246f71f03e0130f1409c">&#9670;&nbsp;</a></span>GetSoundPlayer() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1atk_1_1_sound_player.html">SoundPlayer</a>&amp; nn::atk::SoundArchivePlayer::GetSoundPlayer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pPlayerName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the sound player with the specified ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pPlayerName</td><td>The label string for a player.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the sound player with the specified ID.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_player.html" title="The player class for playing sounds.">SoundPlayer</a> Class </dd></dl>

</div>
</div>
<a id="a13e630ea0859d7156d90ff9bf1c7de48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e630ea0859d7156d90ff9bf1c7de48">&#9670;&nbsp;</a></span>GetSoundPlayer() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnn_1_1atk_1_1_sound_player.html">SoundPlayer</a>&amp; nn::atk::SoundArchivePlayer::GetSoundPlayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a>&#160;</td>
          <td class="paramname"><em>playerId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the sound player with the specified ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">playerId</td><td>A player ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the sound player with the specified ID.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_player.html" title="The player class for playing sounds.">SoundPlayer</a> Class </dd></dl>

</div>
</div>
<a id="ad5bbafc249f43df55b8a7ec343d04510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5bbafc249f43df55b8a7ec343d04510">&#9670;&nbsp;</a></span>GetSoundPlayer() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnn_1_1atk_1_1_sound_player.html">SoundPlayer</a>&amp; nn::atk::SoundArchivePlayer::GetSoundPlayer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pPlayerName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the sound player with the specified ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pPlayerName</td><td>The label string for a player.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the sound player with the specified ID.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_player.html" title="The player class for playing sounds.">SoundPlayer</a> Class </dd></dl>

</div>
</div>
<a id="aa717dbf0b25d9d2d7d0a381fd3702e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa717dbf0b25d9d2d7d0a381fd3702e61">&#9670;&nbsp;</a></span>GetSoundUserParamSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::atk::SoundArchivePlayer::GetSoundUserParamSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of the user parameters held by each sound instance. </p>
<p> <b>Details</b> <br  />
 For more information about user parameters, see <a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aa2de65567087f698294d36e91fd9b9f9">Initialize</a>.</p>
<p>Returns a value limited to <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a45775787c4e3c73825290b10fd86bc9d">UserParamBoundary</a></code> times the <code><em>userParamSizePerSound</em></code> passed to the <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aa2de65567087f698294d36e91fd9b9f9">Initialize</a></code> function.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the user parameter size.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aa2de65567087f698294d36e91fd9b9f9" title="Initializes a sound archive player.">Initialize</a> </dd></dl>

</div>
</div>
<a id="a9f38a3771241a0ed28170c9e31d22afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f38a3771241a0ed28170c9e31d22afb">&#9670;&nbsp;</a></span>GetSoundPlayerCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nn::atk::SoundArchivePlayer::GetSoundPlayerCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of sound players. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of sound players.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_player.html" title="The player class for playing sounds.">SoundPlayer</a> Class </dd></dl>

</div>
</div>
<a id="ada0f078634d736ad58ce5729d6109b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0f078634d736ad58ce5729d6109b3f">&#9670;&nbsp;</a></span>GetFreeSequenceSoundCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::atk::SoundArchivePlayer::GetFreeSequenceSoundCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the remaining number of playable sequence sounds. </p>
<p> <b>Details</b> <br  />
 If an attempt is made to play a new sequence sound when the remaining number is zero, the sound with the lowest player priority among the sounds already playing stops. If the player priority of the new sound is lower, the playback fails.</p>
<p>The total number of playable sequence sounds is defined in the sound archive and is set in the sound archive player by <a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aa2de65567087f698294d36e91fd9b9f9">Initialize</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the remaining number of playable sequence sounds.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aa2de65567087f698294d36e91fd9b9f9" title="Initializes a sound archive player.">Initialize</a> </dd></dl>

</div>
</div>
<a id="a8cde7f084898accc2a3e2a1759c50d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cde7f084898accc2a3e2a1759c50d51">&#9670;&nbsp;</a></span>GetFreeWaveSoundCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::atk::SoundArchivePlayer::GetFreeWaveSoundCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the remaining number of playable wave sounds. </p>
<p> <b>Details</b> <br  />
 If an attempt is made to play a new wave sound when the remaining number is zero, the sound with the lowest player priority among the sounds already playing stops. If the player priority of the new sound is lower, the playback fails.</p>
<p>The total number of playable wave sounds is defined in the sound archive and is set in the sound archive player by <a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aa2de65567087f698294d36e91fd9b9f9">Initialize</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the remaining number of playable wave sounds.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aa2de65567087f698294d36e91fd9b9f9" title="Initializes a sound archive player.">Initialize</a> </dd></dl>

</div>
</div>
<a id="ad1ddb064cdb8a7fd11739c70d543ee61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ddb064cdb8a7fd11739c70d543ee61">&#9670;&nbsp;</a></span>GetFreeStreamSoundCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::atk::SoundArchivePlayer::GetFreeStreamSoundCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the remaining number of playable stream sounds. </p>
<p> <b>Details</b> <br  />
 If an attempt is made to play a new stream sound when the remaining number is zero, the sound with the lowest player priority among the sounds already playing stops. If the player priority of the new sound is lower, the playback fails.</p>
<p>The total number of playable stream sounds is defined in the sound archive and is set in the sound archive player by <a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aa2de65567087f698294d36e91fd9b9f9">Initialize</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the remaining number of playable stream sounds.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aa2de65567087f698294d36e91fd9b9f9" title="Initializes a sound archive player.">Initialize</a> </dd></dl>

</div>
</div>
<a id="a80612cb40a838769e36a3f321a1cde4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80612cb40a838769e36a3f321a1cde4b">&#9670;&nbsp;</a></span>GetActiveWaveSoundCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::atk::SoundArchivePlayer::GetActiveWaveSoundCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p> <b>The use of internal features is prohibited.</b> </p>
<p>Gets the number of wave sounds being played back. </p><dl class="section return"><dt>Returns</dt><dd>Returns the number of wave sounds being played back. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a8cde7f084898accc2a3e2a1759c50d51" title="Gets the remaining number of playable wave sounds.">GetFreeWaveSoundCount</a> </dd></dl>

</div>
</div>
<a id="a37ceb334dd5eb9133e93abd88017d1bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ceb334dd5eb9133e93abd88017d1bf">&#9670;&nbsp;</a></span>GetActiveSequenceSoundCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::atk::SoundArchivePlayer::GetActiveSequenceSoundCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p> <b>The use of internal features is prohibited.</b> </p>
<p>Gets the number of sequence sounds being played back. </p><dl class="section return"><dt>Returns</dt><dd>Returns the number of sequence sounds being played back. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ada0f078634d736ad58ce5729d6109b3f" title="Gets the remaining number of playable sequence sounds.">GetFreeSequenceSoundCount</a> </dd></dl>

</div>
</div>
<a id="a027c2acb6ee6baae3f967091250d9bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a027c2acb6ee6baae3f967091250d9bbb">&#9670;&nbsp;</a></span>GetActiveStreamSoundCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::atk::SoundArchivePlayer::GetActiveStreamSoundCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p> <b>The use of internal features is prohibited.</b> </p>
<p>Gets the number of stream sounds being played back. </p><dl class="section return"><dt>Returns</dt><dd>Returns the number of stream sounds being played back. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ad1ddb064cdb8a7fd11739c70d543ee61" title="Gets the remaining number of playable stream sounds.">GetFreeStreamSoundCount</a> </dd></dl>

</div>
</div>
<a id="aa39be42f75732183b60d027267073a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa39be42f75732183b60d027267073a8b">&#9670;&nbsp;</a></span>SetSequenceUserProcCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::atk::SoundArchivePlayer::SetSequenceUserProcCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1atk.html#a82b1ff1657c3ae76cb229ff28bea025d">SequenceUserProcCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pCallbackArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers the callback function that is invoked by the <code>userproc</code> sequence command. </p>
<p> <b>Details</b> <br  />
 The registered callback is invoked for frames in which the <code>userproc</code> sequence command for the sequence data is processed. The callback function is called from the sound thread.</p>
<p>For more information about the <code>userproc</code> command, see the <em>Sequence Data Manual</em>.</p>
<p>The specified callback function is called from the sound thread. If exclusive control is required, you must use the <code><a class="el" href="classnn_1_1atk_1_1_sound_system_1_1_sound_thread_scoped_lock.html">SoundSystem::SoundThreadScopedLock</a></code> class or the <code><a class="el" href="classnn_1_1atk_1_1_sound_system.html#a04e773eaea02df563bba5a2f474f2124">SoundSystem::LockSoundThread</a></code> and <code><a class="el" href="classnn_1_1atk_1_1_sound_system.html#adb5ed33f057b01ca600ac07e05299a53">SoundSystem::UnlockSoundThread</a></code> functions.</p>
<p>The callback function must quickly finish processing. Prolonged processing has a high probability of generating noise. It may take time for processing to complete if a function that might block (such as for a critical section) is called inside the callback function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback function to register. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pCallbackArg</td><td>The user argument passed to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenn_1_1atk.html#a82b1ff1657c3ae76cb229ff28bea025d" title="The callback of a user procedure that can be used by sequence sounds.">SequenceUserProcCallback</a> </dd></dl>

</div>
</div>
<a id="af3217de46093e207f5185d7be48d744f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3217de46093e207f5185d7be48d744f">&#9670;&nbsp;</a></span>SetSequenceSkipIntervalTick()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void nn::atk::SoundArchivePlayer::SetSequenceSkipIntervalTick </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intervalTick</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the blank width for the skip process for midstream playback of sequence sounds. </p>
<p> <b>Details</b> <br  />
 You can play the sequence sound from midstream by specifying a starting offset using the <code><em>startOffset</em></code> member of the <code><a class="el" href="structnn_1_1atk_1_1_sound_startable_1_1_start_info.html">SoundStartable::StartInfo</a></code> structure and then calling <code><a class="el" href="classnn_1_1atk_1_1_sound_startable.html#a9a075bc1dea627defdc533d514e50c33">StartSound</a></code>, but sequence idling has a processing cost.</p>
<p>The default is a maximum of 48 × 4 × 4 ticks per sound frame (approximately 5 milliseconds). (Note that these ticks are counted in the sequence data. They are not ticks for <a class="el" href="classnn_1_1os_1_1_tick.html" title="Class for handling system ticks.">nn::os::Tick</a>.) This default value can result in a higher processing load on the sound thread and interruptions (skipping) in the sound.</p>
<p>If this happens, reduce the skipping by using this function to set a value of less than 48 × 4 × 4.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">intervalTick</td><td>The maximum blank width (in ticks) for a single sound frame.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ab78056fc2a14859ad23a02a916084c30" title="Gets the blank width for the skip process for midstream playback of sequence sounds.">GetSequenceSkipIntervalTick</a> </dd></dl>

</div>
</div>
<a id="ab78056fc2a14859ad23a02a916084c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78056fc2a14859ad23a02a916084c30">&#9670;&nbsp;</a></span>GetSequenceSkipIntervalTick()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int nn::atk::SoundArchivePlayer::GetSequenceSkipIntervalTick </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the blank width for the skip process for midstream playback of sequence sounds. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the blank width for the skip process for midstream playback of sequence sounds.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#af3217de46093e207f5185d7be48d744f" title="Sets the blank width for the skip process for midstream playback of sequence sounds.">SetSequenceSkipIntervalTick</a> </dd></dl>

</div>
</div>
<a id="a89d07cd1990503ea412e12c5eecdc17d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d07cd1990503ea412e12c5eecdc17d">&#9670;&nbsp;</a></span>ReadWaveSoundDataInfo() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::atk::SoundArchivePlayer::ReadWaveSoundDataInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1atk_1_1_wave_sound_data_info.html">WaveSoundDataInfo</a> *&#160;</td>
          <td class="paramname"><em>pOutInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a>&#160;</td>
          <td class="paramname"><em>waveSoundId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the wave sound information. </p>
<p> <b>Details</b> <br  />
 Unlike <code><a class="el" href="classnn_1_1atk_1_1_wave_sound_handle.html#ae6928f4aa231d95edf8d6a4606ccf317">WaveSoundHandle::ReadWaveSoundDataInfo</a></code>, with this function you can get the information at any time if <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> has been initialized and there are loaded wave sounds in <code><a class="el" href="classnn_1_1atk_1_1_sound_data_manager.html" title="A flag used to load sound archive data.">SoundDataManager</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutInfo</td><td>Pointer to the object storing the read result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">waveSoundId</td><td>ID of the wave sound to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_invalid_id.html">nn::atk::ResultSoundArchivePlayerInvalidId</a> The specified ID was not in the archive, or the wrong type of ID was passed.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_sound_not_loaded.html">nn::atk::ResultSoundArchivePlayerSoundNotLoaded</a> The specified sound has not been loaded.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutInfo</em></code> != <code>nullptr</code>.</li>
<li><code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa3acb0b55a560c154f56d338d0c7c325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3acb0b55a560c154f56d338d0c7c325">&#9670;&nbsp;</a></span>ReadWaveSoundDataInfo() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::atk::SoundArchivePlayer::ReadWaveSoundDataInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1atk_1_1_wave_sound_data_info.html">WaveSoundDataInfo</a> *&#160;</td>
          <td class="paramname"><em>pOutInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>waveSoundName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the wave sound information. </p>
<p> <b>Details</b> <br  />
 Unlike <code><a class="el" href="classnn_1_1atk_1_1_wave_sound_handle.html#ae6928f4aa231d95edf8d6a4606ccf317">WaveSoundHandle::ReadWaveSoundDataInfo</a></code>, with this function you can get the information at any time if <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> has been initialized and there are loaded wave sounds in <code><a class="el" href="classnn_1_1atk_1_1_sound_data_manager.html" title="A flag used to load sound archive data.">SoundDataManager</a></code>.</p>
<p>You must load label string data ahead of time using <code><a class="el" href="classnn_1_1atk_1_1_fs_sound_archive.html#ab402b70a8b5e2ffdb557cd14891314bf">FsSoundArchive::LoadLabelStringData</a></code> when using <code><a class="el" href="classnn_1_1atk_1_1_fs_sound_archive.html">FsSoundArchive</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutInfo</td><td>Pointer to the object storing the read result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">waveSoundName</td><td>The label string of the wave sound to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_invalid_name.html">nn::atk::ResultSoundArchivePlayerInvalidName</a> An invalid name was specified, or the string table was not loaded.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_sound_not_loaded.html">nn::atk::ResultSoundArchivePlayerSoundNotLoaded</a> The specified sound has not been loaded.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutInfo</em></code> != <code>nullptr</code>.</li>
<li><code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is initialized.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_fs_sound_archive.html" title="This class handles sound archives stored in the file system.">FsSoundArchive</a> </dd></dl>

</div>
</div>
<a id="aef6e26ba7a00d506e988b0ed81bba0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef6e26ba7a00d506e988b0ed81bba0e4">&#9670;&nbsp;</a></span>ReadWaveSoundDataInfo() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::atk::SoundArchivePlayer::ReadWaveSoundDataInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1atk_1_1_wave_sound_data_info.html">WaveSoundDataInfo</a> *&#160;</td>
          <td class="paramname"><em>pOutInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a>&#160;</td>
          <td class="paramname"><em>waveSoundId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnn_1_1atk_1_1_sound_archive.html">SoundArchive</a> *&#160;</td>
          <td class="paramname"><em>pSoundArchive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnn_1_1atk_1_1_sound_data_manager.html">SoundDataManager</a> *&#160;</td>
          <td class="paramname"><em>pSoundDataManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets information about wave sounds in the additional sound archive. </p>
<p> <b>Details</b> <br  />
 To get information about wave sounds in the main sound archive, use a function that does not have <code><em>pSoundArchive</em></code> or <code><em>pSoundDataManager</em></code> in the arguments.</p>
<p>Unlike <code><a class="el" href="classnn_1_1atk_1_1_wave_sound_handle.html#ae6928f4aa231d95edf8d6a4606ccf317">WaveSoundHandle::ReadWaveSoundDataInfo</a></code>, with this function you can get the information at any time if <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> has been initialized and there are loaded wave sounds in <code><a class="el" href="classnn_1_1atk_1_1_sound_data_manager.html" title="A flag used to load sound archive data.">SoundDataManager</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutInfo</td><td>Pointer to the object storing the read result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">waveSoundId</td><td>ID of the wave sound to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSoundArchive</td><td>The additional sound archive to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSoundDataManager</td><td>The <code><a class="el" href="classnn_1_1atk_1_1_sound_data_manager.html" title="A flag used to load sound archive data.">SoundDataManager</a></code> to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_invalid_id.html">nn::atk::ResultSoundArchivePlayerInvalidId</a> The specified ID was not in the archive, or the wrong type of ID was passed.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_sound_not_loaded.html">nn::atk::ResultSoundArchivePlayerSoundNotLoaded</a> The specified sound has not been loaded.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutInfo</em></code> != <code>nullptr</code>.</li>
<li><code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is initialized.</li>
<li><code><em>pSoundArchive</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSoundDataManager</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6b06672cd1d7bc0144d65205ad5699ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b06672cd1d7bc0144d65205ad5699ee">&#9670;&nbsp;</a></span>ReadWaveSoundDataInfo() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::atk::SoundArchivePlayer::ReadWaveSoundDataInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1atk_1_1_wave_sound_data_info.html">WaveSoundDataInfo</a> *&#160;</td>
          <td class="paramname"><em>pOutInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a>&#160;</td>
          <td class="paramname"><em>waveSoundId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>soundArchiveName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets information about wave sounds in the additional sound archive. </p>
<p> <b>Details</b> <br  />
 To get information about wave sounds in the main sound archive, use either a function with <code>nullptr</code> specified as the <code><em>soundArchiveName</em></code> parameter, or one that does not have <code><em>soundArchiveName</em></code> in the arguments.</p>
<p>Unlike <code><a class="el" href="classnn_1_1atk_1_1_wave_sound_handle.html#ae6928f4aa231d95edf8d6a4606ccf317">WaveSoundHandle::ReadWaveSoundDataInfo</a></code>, with this function you can get the information at any time if <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> has been initialized and there are loaded wave sounds in <code><a class="el" href="classnn_1_1atk_1_1_sound_data_manager.html" title="A flag used to load sound archive data.">SoundDataManager</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutInfo</td><td>Pointer to the object storing the read result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">waveSoundId</td><td>ID of the wave sound to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soundArchiveName</td><td>The name of the additional sound archive to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_invalid_id.html">nn::atk::ResultSoundArchivePlayerInvalidId</a> The specified ID was not in the archive, or the wrong type of ID was passed.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_sound_not_loaded.html">nn::atk::ResultSoundArchivePlayerSoundNotLoaded</a> The specified sound has not been loaded.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutInfo</em></code> != <code>nullptr</code>.</li>
<li><code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a7038cade55064aded920d3b5068741d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7038cade55064aded920d3b5068741d4">&#9670;&nbsp;</a></span>ReadWaveSoundDataInfo() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::atk::SoundArchivePlayer::ReadWaveSoundDataInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1atk_1_1_wave_sound_data_info.html">WaveSoundDataInfo</a> *&#160;</td>
          <td class="paramname"><em>pOutInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>waveSoundName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>soundArchiveName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets information about wave sounds in the additional sound archive. </p>
<p> <b>Details</b> <br  />
 To get information about wave sounds in the main sound archive, use either a function with <code>nullptr</code> specified as the <code><em>soundArchiveName</em></code> parameter, or one that does not have <code><em>soundArchiveName</em></code> in the arguments.</p>
<p>Unlike <code><a class="el" href="classnn_1_1atk_1_1_wave_sound_handle.html#ae6928f4aa231d95edf8d6a4606ccf317">WaveSoundHandle::ReadWaveSoundDataInfo</a></code>, with this function you can get the information at any time if <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> has been initialized and there are loaded wave sounds in <code><a class="el" href="classnn_1_1atk_1_1_sound_data_manager.html" title="A flag used to load sound archive data.">SoundDataManager</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutInfo</td><td>Pointer to the object storing the read result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">waveSoundName</td><td>The label string of the wave sound to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soundArchiveName</td><td>The name of the additional sound archive to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_invalid_name.html">nn::atk::ResultSoundArchivePlayerInvalidName</a> An invalid name was specified, or the string table was not loaded.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_sound_not_loaded.html">nn::atk::ResultSoundArchivePlayerSoundNotLoaded</a> The specified sound has not been loaded.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutInfo</em></code> != <code>nullptr</code>.</li>
<li><code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a79ddd42d5e6f2bd8996cee89b17cfc14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ddd42d5e6f2bd8996cee89b17cfc14">&#9670;&nbsp;</a></span>ReadStreamSoundDataInfo() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::atk::SoundArchivePlayer::ReadStreamSoundDataInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1atk_1_1_stream_sound_data_info.html">StreamSoundDataInfo</a> *&#160;</td>
          <td class="paramname"><em>pOutInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a>&#160;</td>
          <td class="paramname"><em>streamSoundId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets stream sound data. </p>
<p> <b>Details</b> <br  />
 You can get data at any point after initializing <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code>, as long as the target stream sound is not playing. No data is loaded to <code><em>pOutInfo</em></code> and the <code><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">ResultSoundArchivePlayerStreamSoundIsPlaying</a></code> error is returned when you attempt to get data during playback. If you need to get data during stream sound playback, use instead. Use <code><a class="el" href="classnn_1_1atk_1_1_stream_sound_handle.html#abee7e1e6f237fad672f394260f9e123e">StreamSoundHandle::ReadStreamSoundDataInfo</a></code> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutInfo</td><td>Pointer to the object storing the read result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">streamSoundId</td><td>The ID for the stream sound to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_invalid_format.html">nn::atk::ResultSoundArchivePlayerInvalidFormat</a> A binary in an unsupported format was passed.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">nn::atk::ResultSoundArchivePlayerStreamSoundIsPlaying</a> The target stream sound is playing.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_read_stream_sound_file_path_failed.html">nn::atk::ResultSoundArchivePlayerReadStreamSoundFilePathFailed</a> Failed to load from the file path for the target stream sound.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_file_system_error.html">nn::atk::ResultSoundArchivePlayerFileSystemError</a> File system processing failed.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutInfo</em></code> != <code>nullptr</code>.</li>
<li><code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4e337c51c3030c9c0eb0f2f62e7eed9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e337c51c3030c9c0eb0f2f62e7eed9a">&#9670;&nbsp;</a></span>ReadStreamSoundDataInfo() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::atk::SoundArchivePlayer::ReadStreamSoundDataInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1atk_1_1_stream_sound_data_info.html">StreamSoundDataInfo</a> *&#160;</td>
          <td class="paramname"><em>pOutInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>streamSoundName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets stream sound data. </p>
<p> <b>Details</b> <br  />
 You can get data at any point after initializing <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code>, as long as the target stream sound is not playing. No data is loaded to <code><em>pOutInfo</em></code> and the <code><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">ResultSoundArchivePlayerStreamSoundIsPlaying</a></code> error is returned when you attempt to get data during playback. If you need to get data during stream sound playback, use instead. Use <code><a class="el" href="classnn_1_1atk_1_1_stream_sound_handle.html#abee7e1e6f237fad672f394260f9e123e">StreamSoundHandle::ReadStreamSoundDataInfo</a></code> instead.</p>
<p>You must load label string data ahead of time using <code><a class="el" href="classnn_1_1atk_1_1_fs_sound_archive.html#ab402b70a8b5e2ffdb557cd14891314bf">FsSoundArchive::LoadLabelStringData</a></code> when using <code><a class="el" href="classnn_1_1atk_1_1_fs_sound_archive.html">FsSoundArchive</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutInfo</td><td>Pointer to the object storing the read result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">streamSoundName</td><td>The label string for the stream sound to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_invalid_name.html">nn::atk::ResultSoundArchivePlayerInvalidName</a> An invalid name was specified, or the string table was not loaded.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_invalid_format.html">nn::atk::ResultSoundArchivePlayerInvalidFormat</a> A binary in an unsupported format was passed.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">nn::atk::ResultSoundArchivePlayerStreamSoundIsPlaying</a> The target stream sound is playing.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_read_stream_sound_file_path_failed.html">nn::atk::ResultSoundArchivePlayerReadStreamSoundFilePathFailed</a> Failed to load from the file path for the target stream sound.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_file_system_error.html">nn::atk::ResultSoundArchivePlayerFileSystemError</a> File system processing failed.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutInfo</em></code> != <code>nullptr</code>.</li>
<li><code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is initialized.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_fs_sound_archive.html" title="This class handles sound archives stored in the file system.">FsSoundArchive</a> </dd></dl>

</div>
</div>
<a id="a3e943804fd7c1013fed2d1dab8674bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e943804fd7c1013fed2d1dab8674bac">&#9670;&nbsp;</a></span>ReadStreamSoundDataInfo() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::atk::SoundArchivePlayer::ReadStreamSoundDataInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1atk_1_1_stream_sound_data_info.html">StreamSoundDataInfo</a> *&#160;</td>
          <td class="paramname"><em>pOutInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnn_1_1atk_1_1_sound_archive.html">SoundArchive</a> *&#160;</td>
          <td class="paramname"><em>pSoundArchive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a>&#160;</td>
          <td class="paramname"><em>streamSoundId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets information about stream sounds in the additional sound archive. </p>
<p> <b>Details</b> <br  />
 Gets information about stream sounds present in the main sound archive. Use a function for which <code><em>pSoundArchive</em></code> is not in the argument.</p>
<p>You can get data at any point after initializing <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code>, as long as the target stream sound is not playing. No data is loaded to <code><em>pOutInfo</em></code> and the <code><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">ResultSoundArchivePlayerStreamSoundIsPlaying</a></code> error is returned when you attempt to get data during playback. If you need to get data during stream sound playback, use instead. Use <code><a class="el" href="classnn_1_1atk_1_1_stream_sound_handle.html#abee7e1e6f237fad672f394260f9e123e">StreamSoundHandle::ReadStreamSoundDataInfo</a></code> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutInfo</td><td>Pointer to the object storing the read result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSoundArchive</td><td>The additional sound archive to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">streamSoundId</td><td>The ID for the stream sound to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_invalid_name.html">nn::atk::ResultSoundArchivePlayerInvalidName</a> An invalid name was specified, or the string table was not loaded.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_invalid_format.html">nn::atk::ResultSoundArchivePlayerInvalidFormat</a> A binary in an unsupported format was passed.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">nn::atk::ResultSoundArchivePlayerStreamSoundIsPlaying</a> The target stream sound is playing.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_read_stream_sound_file_path_failed.html">nn::atk::ResultSoundArchivePlayerReadStreamSoundFilePathFailed</a> Failed to load from the file path for the target stream sound.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_file_system_error.html">nn::atk::ResultSoundArchivePlayerFileSystemError</a> File system processing failed.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutInfo</em></code> != <code>nullptr</code>.</li>
<li><code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is initialized.</li>
<li><code><em>pSoundArchive</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab1094c1da9750822edaacb190a5f4bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1094c1da9750822edaacb190a5f4bcb">&#9670;&nbsp;</a></span>ReadStreamSoundDataInfo() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::atk::SoundArchivePlayer::ReadStreamSoundDataInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1atk_1_1_stream_sound_data_info.html">StreamSoundDataInfo</a> *&#160;</td>
          <td class="paramname"><em>pOutInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a>&#160;</td>
          <td class="paramname"><em>streamSoundId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>soundArchiveName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets information about stream sounds in the additional sound archive. </p>
<p> <b>Details</b> <br  />
 To get information about stream sounds in the main sound archive, either specify <code>nullptr</code> for <code><em>soundArchiveName</em></code> or use the version of the function that does not have <code><em>soundArchiveName</em></code> as a parameter.</p>
<p>You can get data at any point after initializing <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code>, as long as the target stream sound is not playing. No data is loaded to <code><em>pOutInfo</em></code> and the <code><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">ResultSoundArchivePlayerStreamSoundIsPlaying</a></code> error is returned when you attempt to get data during playback. If you need to get data during stream sound playback, use instead. Use <code><a class="el" href="classnn_1_1atk_1_1_stream_sound_handle.html#abee7e1e6f237fad672f394260f9e123e">StreamSoundHandle::ReadStreamSoundDataInfo</a></code> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutInfo</td><td>Pointer to the object storing the read result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">streamSoundId</td><td>The ID for the stream sound to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soundArchiveName</td><td>The name of the additional sound archive to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_invalid_format.html">nn::atk::ResultSoundArchivePlayerInvalidFormat</a> A binary in an unsupported format was passed.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">nn::atk::ResultSoundArchivePlayerStreamSoundIsPlaying</a> The target stream sound is playing.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_read_stream_sound_file_path_failed.html">nn::atk::ResultSoundArchivePlayerReadStreamSoundFilePathFailed</a> Failed to load from the file path for the target stream sound.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_file_system_error.html">nn::atk::ResultSoundArchivePlayerFileSystemError</a> File system processing failed.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutInfo</em></code> != <code>nullptr</code>.</li>
<li><code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a984ec35d2fda38c879e5e96c8cc16362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a984ec35d2fda38c879e5e96c8cc16362">&#9670;&nbsp;</a></span>ReadStreamSoundDataInfo() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::atk::SoundArchivePlayer::ReadStreamSoundDataInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1atk_1_1_stream_sound_data_info.html">StreamSoundDataInfo</a> *&#160;</td>
          <td class="paramname"><em>pOutInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>streamSoundName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>soundArchiveName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets information about stream sounds in the additional sound archive. </p>
<p> <b>Details</b> <br  />
 To get information about stream sounds in the main sound archive, either specify <code>nullptr</code> for <code><em>soundArchiveName</em></code> or use the version of the function that does not have <code><em>soundArchiveName</em></code> as a parameter.</p>
<p>You can get data at any point after initializing <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code>, as long as the target stream sound is not playing. No data is loaded to <code><em>pOutInfo</em></code> and the <code><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">ResultSoundArchivePlayerStreamSoundIsPlaying</a></code> error is returned when you attempt to get data during playback. If you need to get data during stream sound playback, use instead. Use <code><a class="el" href="classnn_1_1atk_1_1_stream_sound_handle.html#abee7e1e6f237fad672f394260f9e123e">StreamSoundHandle::ReadStreamSoundDataInfo</a></code> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutInfo</td><td>Pointer to the object storing the read result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">streamSoundName</td><td>The label string for the stream sound to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soundArchiveName</td><td>The name of the additional sound archive to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_invalid_name.html">nn::atk::ResultSoundArchivePlayerInvalidName</a> An invalid name was specified, or the string table was not loaded.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_invalid_format.html">nn::atk::ResultSoundArchivePlayerInvalidFormat</a> A binary in an unsupported format was passed.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">nn::atk::ResultSoundArchivePlayerStreamSoundIsPlaying</a> The target stream sound is playing.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_read_stream_sound_file_path_failed.html">nn::atk::ResultSoundArchivePlayerReadStreamSoundFilePathFailed</a> Failed to load from the file path for the target stream sound.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_file_system_error.html">nn::atk::ResultSoundArchivePlayerFileSystemError</a> File system processing failed.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutInfo</em></code> != <code>nullptr</code>.</li>
<li><code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1a5677dd952a371a68249d88dc6eb35b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a5677dd952a371a68249d88dc6eb35b">&#9670;&nbsp;</a></span>GetRequiredWorkBufferSizeToReadStreamSoundHeader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t nn::atk::SoundArchivePlayer::GetRequiredWorkBufferSizeToReadStreamSoundHeader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the working area needed to get stream sound header information. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the size of the working area needed to get stream sound header information.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a7a77018155a9dd49f1191ca52366a7e6" title="Gets stream sound region data.">ReadStreamSoundRegionDataInfo</a> </dd></dl>

</div>
</div>
<a id="a7a77018155a9dd49f1191ca52366a7e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a77018155a9dd49f1191ca52366a7e6">&#9670;&nbsp;</a></span>ReadStreamSoundRegionDataInfo() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::atk::SoundArchivePlayer::ReadStreamSoundRegionDataInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1atk_1_1_stream_sound_region_data_info.html">StreamSoundRegionDataInfo</a> *&#160;</td>
          <td class="paramname"><em>pOutInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a>&#160;</td>
          <td class="paramname"><em>streamSoundId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>regionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets stream sound region data. </p>
<p> <b>Details</b> <br  />
 You can get data at any point after initializing <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code>, as long as the target stream sound is not playing. No data is loaded to <code><em>pOutInfo</em></code> and the <code><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">ResultSoundArchivePlayerStreamSoundIsPlaying</a></code> error is returned when you attempt to get data during playback.</p>
<p>To get data, you need a working area that is at least as large as the size obtained using <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a1a5677dd952a371a68249d88dc6eb35b">GetRequiredWorkBufferSizeToReadStreamSoundHeader</a></code>. The working area is only used while this function is running.</p>
<p>Consider using <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a7a77018155a9dd49f1191ca52366a7e6">ReadStreamSoundRegionDataInfo</a></code> with <code><em>infoCount</em></code> as a parameter when getting multiple region data instances for a single stream sound. You can improve the efficiency of file access by reading all of the data at the same time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutInfo</td><td>Pointer to the object storing the read result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">streamSoundId</td><td>The ID for the stream sound to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regionName</td><td>The name for the region to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the working area. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of the working area.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">nn::atk::ResultSoundArchivePlayerStreamSoundIsPlaying</a> The target stream sound is playing.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_read_stream_sound_file_path_failed.html">nn::atk::ResultSoundArchivePlayerReadStreamSoundFilePathFailed</a> Failed to load from the file path for the target stream sound.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_file_system_error.html">nn::atk::ResultSoundArchivePlayerFileSystemError</a> File system processing failed.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_load_file_header_failed.html">nn::atk::ResultSoundArchivePlayerLoadFileHeaderFailed</a> Failed to load the header.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_has_no_region.html">nn::atk::ResultSoundArchivePlayerStreamSoundHasNoRegion</a> There is no region information in the target stream sound.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_region_not_found.html">nn::atk::ResultSoundArchivePlayerStreamSoundRegionNotFound</a> Could not find the specified region information in the target stream sound.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutInfo</em></code> != <code>nullptr</code>.</li>
<li><code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is initialized.</li>
<li><code><em>buffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>bufferSize</em></code> &gt;= <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a1a5677dd952a371a68249d88dc6eb35b" title="Gets the size of the working area needed to get stream sound header information.">GetRequiredWorkBufferSizeToReadStreamSoundHeader()</a></code>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a1a5677dd952a371a68249d88dc6eb35b" title="Gets the size of the working area needed to get stream sound header information.">GetRequiredWorkBufferSizeToReadStreamSoundHeader</a> </dd></dl>

</div>
</div>
<a id="a2c99d23a017ba4ad3b3c0a48db425967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c99d23a017ba4ad3b3c0a48db425967">&#9670;&nbsp;</a></span>ReadStreamSoundRegionDataInfo() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::atk::SoundArchivePlayer::ReadStreamSoundRegionDataInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1atk_1_1_stream_sound_region_data_info.html">StreamSoundRegionDataInfo</a> *&#160;</td>
          <td class="paramname"><em>pOutInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>streamSoundName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>regionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets stream sound region data. </p>
<p> <b>Details</b> <br  />
 You can get data at any point after initializing <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code>, as long as the target stream sound is not playing. No data is loaded to <code><em>pOutInfo</em></code> and the <code><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">ResultSoundArchivePlayerStreamSoundIsPlaying</a></code> error is returned when you attempt to get data during playback.</p>
<p>To get data, you need a working area that is at least as large as the size obtained using <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a1a5677dd952a371a68249d88dc6eb35b">GetRequiredWorkBufferSizeToReadStreamSoundHeader</a></code>. The working area is only used while this function is running.</p>
<p>Consider using <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a7a77018155a9dd49f1191ca52366a7e6">ReadStreamSoundRegionDataInfo</a></code> with <code><em>infoCount</em></code> as a parameter when getting multiple region data instances for a single stream sound. You can improve the efficiency of file access by reading all of the data at the same time.</p>
<p>You must load label string data ahead of time using <code><a class="el" href="classnn_1_1atk_1_1_fs_sound_archive.html#ab402b70a8b5e2ffdb557cd14891314bf">FsSoundArchive::LoadLabelStringData</a></code> when using <code><a class="el" href="classnn_1_1atk_1_1_fs_sound_archive.html">FsSoundArchive</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutInfo</td><td>Pointer to the object storing the read result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">streamSoundName</td><td>The label string for the stream sound to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regionName</td><td>The name for the region to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the working area. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of the working area.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_invalid_name.html">nn::atk::ResultSoundArchivePlayerInvalidName</a> An invalid name was specified, or the string table was not loaded.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">nn::atk::ResultSoundArchivePlayerStreamSoundIsPlaying</a> The target stream sound is playing.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_read_stream_sound_file_path_failed.html">nn::atk::ResultSoundArchivePlayerReadStreamSoundFilePathFailed</a> Failed to load from the file path for the target stream sound.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_file_system_error.html">nn::atk::ResultSoundArchivePlayerFileSystemError</a> File system processing failed.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_load_file_header_failed.html">nn::atk::ResultSoundArchivePlayerLoadFileHeaderFailed</a> Failed to load the header.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_has_no_region.html">nn::atk::ResultSoundArchivePlayerStreamSoundHasNoRegion</a> There is no region information in the target stream sound.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_region_not_found.html">nn::atk::ResultSoundArchivePlayerStreamSoundRegionNotFound</a> Could not find the specified region information in the target stream sound.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutInfo</em></code> != <code>nullptr</code>.</li>
<li><code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is initialized.</li>
<li><code><em>buffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>bufferSize</em></code> &gt;= <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a1a5677dd952a371a68249d88dc6eb35b" title="Gets the size of the working area needed to get stream sound header information.">GetRequiredWorkBufferSizeToReadStreamSoundHeader()</a></code>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a1a5677dd952a371a68249d88dc6eb35b" title="Gets the size of the working area needed to get stream sound header information.">GetRequiredWorkBufferSizeToReadStreamSoundHeader</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_fs_sound_archive.html" title="This class handles sound archives stored in the file system.">FsSoundArchive</a> </dd></dl>

</div>
</div>
<a id="ad59ebc7e0d3fae4e19b525407822dc35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59ebc7e0d3fae4e19b525407822dc35">&#9670;&nbsp;</a></span>ReadStreamSoundRegionDataInfo() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::atk::SoundArchivePlayer::ReadStreamSoundRegionDataInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1atk_1_1_stream_sound_region_data_info.html">StreamSoundRegionDataInfo</a> *&#160;</td>
          <td class="paramname"><em>pOutInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a>&#160;</td>
          <td class="paramname"><em>streamSoundId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>pRegionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>infoCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets multiple instances of stream sound region data. </p>
<p> <b>Details</b> <br  />
 You can get data at any point after initializing <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code>, as long as the target stream sound is not playing. No data is loaded to <code><em>pOutInfo</em></code> and the <code><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">ResultSoundArchivePlayerStreamSoundIsPlaying</a></code> error is returned when you attempt to get data during playback.</p>
<p>To get data, you need a working area that is at least as large as the size obtained using <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a1a5677dd952a371a68249d88dc6eb35b">GetRequiredWorkBufferSizeToReadStreamSoundHeader</a></code>. The working area is only used while this function is running.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutInfo</td><td>Passes an array of objects to store the read results. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">streamSoundId</td><td>The ID for the stream sound to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pRegionName</td><td>The array of names for the regions to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">infoCount</td><td>The number of region data instances to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the working area. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of the working area.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">nn::atk::ResultSoundArchivePlayerStreamSoundIsPlaying</a> The target stream sound is playing.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_read_stream_sound_file_path_failed.html">nn::atk::ResultSoundArchivePlayerReadStreamSoundFilePathFailed</a> Failed to load from the file path for the target stream sound.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_file_system_error.html">nn::atk::ResultSoundArchivePlayerFileSystemError</a> File system processing failed.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_load_file_header_failed.html">nn::atk::ResultSoundArchivePlayerLoadFileHeaderFailed</a> Failed to load the header.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_has_no_region.html">nn::atk::ResultSoundArchivePlayerStreamSoundHasNoRegion</a> There is no region information in the target stream sound.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_region_not_found.html">nn::atk::ResultSoundArchivePlayerStreamSoundRegionNotFound</a> Could not find the specified region information in the target stream sound.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutInfo</em></code> != <code>nullptr</code>.</li>
<li><code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is initialized.</li>
<li><code><em>buffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>bufferSize</em></code> &gt;= <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a1a5677dd952a371a68249d88dc6eb35b" title="Gets the size of the working area needed to get stream sound header information.">GetRequiredWorkBufferSizeToReadStreamSoundHeader()</a></code>.</li>
<li><code><em>infoCount</em></code> &gt; <code>0</code>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a1a5677dd952a371a68249d88dc6eb35b" title="Gets the size of the working area needed to get stream sound header information.">GetRequiredWorkBufferSizeToReadStreamSoundHeader</a> </dd></dl>

</div>
</div>
<a id="a72eb791f87b3c9b7a799c669aa91221d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72eb791f87b3c9b7a799c669aa91221d">&#9670;&nbsp;</a></span>ReadStreamSoundRegionDataInfo() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::atk::SoundArchivePlayer::ReadStreamSoundRegionDataInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1atk_1_1_stream_sound_region_data_info.html">StreamSoundRegionDataInfo</a> *&#160;</td>
          <td class="paramname"><em>pOutInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>streamSoundName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>pRegionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>infoCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets multiple instances of stream sound region data. </p>
<p> <b>Details</b> <br  />
 You can get data at any point after initializing <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code>, as long as the target stream sound is not playing. No data is loaded to <code><em>pOutInfo</em></code> and the <code><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">ResultSoundArchivePlayerStreamSoundIsPlaying</a></code> error is returned when you attempt to get data during playback.</p>
<p>To get data, you need a working area that is at least as large as the size obtained using <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a1a5677dd952a371a68249d88dc6eb35b">GetRequiredWorkBufferSizeToReadStreamSoundHeader</a></code>. The working area is only used while this function is running.</p>
<p>You must load label string data ahead of time using <code><a class="el" href="classnn_1_1atk_1_1_fs_sound_archive.html#ab402b70a8b5e2ffdb557cd14891314bf">FsSoundArchive::LoadLabelStringData</a></code> when using <code><a class="el" href="classnn_1_1atk_1_1_fs_sound_archive.html">FsSoundArchive</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutInfo</td><td>Passes an array of objects to store the read results. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">streamSoundName</td><td>The label string for the stream sound to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pRegionName</td><td>The array of names for the regions to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">infoCount</td><td>The number of region data instances to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the working area. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of the working area.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_invalid_name.html">nn::atk::ResultSoundArchivePlayerInvalidName</a> An invalid name was specified, or the string table was not loaded.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">nn::atk::ResultSoundArchivePlayerStreamSoundIsPlaying</a> The target stream sound is playing.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_read_stream_sound_file_path_failed.html">nn::atk::ResultSoundArchivePlayerReadStreamSoundFilePathFailed</a> Failed to load from the file path for the target stream sound.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_file_system_error.html">nn::atk::ResultSoundArchivePlayerFileSystemError</a> File system processing failed.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_load_file_header_failed.html">nn::atk::ResultSoundArchivePlayerLoadFileHeaderFailed</a> Failed to load the header.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_has_no_region.html">nn::atk::ResultSoundArchivePlayerStreamSoundHasNoRegion</a> There is no region information in the target stream sound.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_region_not_found.html">nn::atk::ResultSoundArchivePlayerStreamSoundRegionNotFound</a> Could not find the specified region information in the target stream sound.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutInfo</em></code> != <code>nullptr</code>.</li>
<li><code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is initialized.</li>
<li><code><em>buffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>bufferSize</em></code> &gt;= <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a1a5677dd952a371a68249d88dc6eb35b" title="Gets the size of the working area needed to get stream sound header information.">GetRequiredWorkBufferSizeToReadStreamSoundHeader()</a></code>.</li>
<li><code><em>infoCount</em></code> &gt; <code>0</code>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a1a5677dd952a371a68249d88dc6eb35b" title="Gets the size of the working area needed to get stream sound header information.">GetRequiredWorkBufferSizeToReadStreamSoundHeader</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_fs_sound_archive.html" title="This class handles sound archives stored in the file system.">FsSoundArchive</a> </dd></dl>

</div>
</div>
<a id="a9c94bb02b7e2d63ea701563e95be33f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c94bb02b7e2d63ea701563e95be33f7">&#9670;&nbsp;</a></span>ReadStreamSoundRegionDataInfo() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::atk::SoundArchivePlayer::ReadStreamSoundRegionDataInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1atk_1_1_stream_sound_region_data_info.html">StreamSoundRegionDataInfo</a> *&#160;</td>
          <td class="paramname"><em>pOutInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>streamSoundName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>regionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>soundArchiveName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets region information about stream sounds in the additional sound archive. </p>
<p> <b>Details</b> <br  />
 To get the region information for stream sounds in the main sound archive, either specify <code>nullptr</code> for <code><em>soundArchiveName</em></code> or use the version of the function that does not have <code><em>soundArchiveName</em></code> as a parameter.</p>
<p>You can get data at any point after initializing <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code>, as long as the target stream sound is not playing. No data is loaded to <code><em>pOutInfo</em></code> and the <code><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">ResultSoundArchivePlayerStreamSoundIsPlaying</a></code> error is returned when you attempt to get data during playback.</p>
<p>To get data, you need a working area that is at least as large as the size obtained using <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a1a5677dd952a371a68249d88dc6eb35b">GetRequiredWorkBufferSizeToReadStreamSoundHeader</a></code>. The working area is only used while this function is running.</p>
<p>Consider using <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a7a77018155a9dd49f1191ca52366a7e6">ReadStreamSoundRegionDataInfo</a></code> with <code><em>infoCount</em></code> as a parameter when getting multiple region data instances for a single stream sound. You can improve the efficiency of file access by reading all of the data at the same time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutInfo</td><td>Pointer to the object storing the read result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">streamSoundName</td><td>The label string for the stream sound to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regionName</td><td>The name for the region to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the working area. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of the working area. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soundArchiveName</td><td>The name of the additional sound archive to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_invalid_name.html">nn::atk::ResultSoundArchivePlayerInvalidName</a> An invalid name was specified, or the string table was not loaded.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">nn::atk::ResultSoundArchivePlayerStreamSoundIsPlaying</a> The target stream sound is playing.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_read_stream_sound_file_path_failed.html">nn::atk::ResultSoundArchivePlayerReadStreamSoundFilePathFailed</a> Failed to load from the file path for the target stream sound.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_file_system_error.html">nn::atk::ResultSoundArchivePlayerFileSystemError</a> File system processing failed.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_load_file_header_failed.html">nn::atk::ResultSoundArchivePlayerLoadFileHeaderFailed</a> Failed to load the header.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_has_no_region.html">nn::atk::ResultSoundArchivePlayerStreamSoundHasNoRegion</a> There is no region information in the target stream sound.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_region_not_found.html">nn::atk::ResultSoundArchivePlayerStreamSoundRegionNotFound</a> Could not find the specified region information in the target stream sound.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutInfo</em></code> != <code>nullptr</code>.</li>
<li><code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is initialized.</li>
<li><code><em>buffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>bufferSize</em></code> &gt;= <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a1a5677dd952a371a68249d88dc6eb35b" title="Gets the size of the working area needed to get stream sound header information.">GetRequiredWorkBufferSizeToReadStreamSoundHeader()</a></code>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a1a5677dd952a371a68249d88dc6eb35b" title="Gets the size of the working area needed to get stream sound header information.">GetRequiredWorkBufferSizeToReadStreamSoundHeader</a> </dd></dl>

</div>
</div>
<a id="a3bca5c712f338b52c24e4c2202c882e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bca5c712f338b52c24e4c2202c882e7">&#9670;&nbsp;</a></span>ReadStreamSoundRegionDataInfo() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::atk::SoundArchivePlayer::ReadStreamSoundRegionDataInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1atk_1_1_stream_sound_region_data_info.html">StreamSoundRegionDataInfo</a> *&#160;</td>
          <td class="paramname"><em>pOutInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a>&#160;</td>
          <td class="paramname"><em>streamSoundId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>regionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>soundArchiveName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets region information about stream sounds in the additional sound archive. </p>
<p> <b>Details</b> <br  />
 To get the region information for stream sounds in the main sound archive, either specify <code>nullptr</code> for <code><em>soundArchiveName</em></code> or use the version of the function that does not have <code><em>soundArchiveName</em></code> as a parameter.</p>
<p>You can get data at any point after initializing <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code>, as long as the target stream sound is not playing. No data is loaded to <code><em>pOutInfo</em></code> and the <code><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">ResultSoundArchivePlayerStreamSoundIsPlaying</a></code> error is returned when you attempt to get data during playback.</p>
<p>To get data, you need a working area that is at least as large as the size obtained using <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a1a5677dd952a371a68249d88dc6eb35b">GetRequiredWorkBufferSizeToReadStreamSoundHeader</a></code>. The working area is only used while this function is running.</p>
<p>Consider using <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a7a77018155a9dd49f1191ca52366a7e6">ReadStreamSoundRegionDataInfo</a></code> with <code><em>infoCount</em></code> as a parameter when getting multiple region data instances for a single stream sound. You can improve the efficiency of file access by reading all of the data at the same time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutInfo</td><td>Pointer to the object storing the read result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">streamSoundId</td><td>The ID for the stream sound to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regionName</td><td>The name for the region to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the working area. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of the working area. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soundArchiveName</td><td>The name of the additional sound archive to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">nn::atk::ResultSoundArchivePlayerStreamSoundIsPlaying</a> The target stream sound is playing.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_read_stream_sound_file_path_failed.html">nn::atk::ResultSoundArchivePlayerReadStreamSoundFilePathFailed</a> Failed to load from the file path for the target stream sound.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_file_system_error.html">nn::atk::ResultSoundArchivePlayerFileSystemError</a> File system processing failed.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_load_file_header_failed.html">nn::atk::ResultSoundArchivePlayerLoadFileHeaderFailed</a> Failed to load the header.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_has_no_region.html">nn::atk::ResultSoundArchivePlayerStreamSoundHasNoRegion</a> There is no region information in the target stream sound.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_region_not_found.html">nn::atk::ResultSoundArchivePlayerStreamSoundRegionNotFound</a> Could not find the specified region information in the target stream sound.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutInfo</em></code> != <code>nullptr</code>.</li>
<li><code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is initialized.</li>
<li><code><em>buffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>bufferSize</em></code> &gt;= <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a1a5677dd952a371a68249d88dc6eb35b" title="Gets the size of the working area needed to get stream sound header information.">GetRequiredWorkBufferSizeToReadStreamSoundHeader()</a></code>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a1a5677dd952a371a68249d88dc6eb35b" title="Gets the size of the working area needed to get stream sound header information.">GetRequiredWorkBufferSizeToReadStreamSoundHeader</a> </dd></dl>

</div>
</div>
<a id="a2f07e3bff894b1d63fdc6e59ce1bbeab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f07e3bff894b1d63fdc6e59ce1bbeab">&#9670;&nbsp;</a></span>ReadStreamSoundRegionDataInfo() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::atk::SoundArchivePlayer::ReadStreamSoundRegionDataInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1atk_1_1_stream_sound_region_data_info.html">StreamSoundRegionDataInfo</a> *&#160;</td>
          <td class="paramname"><em>pOutInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>streamSoundName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>pRegionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>infoCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>soundArchiveName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets multiple instances of region information about stream sounds in the additional sound archive. </p>
<p> <b>Details</b> <br  />
 To get the region information for stream sounds in the main sound archive, either specify <code>nullptr</code> for <code><em>soundArchiveName</em></code> or use the version of the function that does not have <code><em>soundArchiveName</em></code> as a parameter.</p>
<p>You can get data at any point after initializing <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code>, as long as the target stream sound is not playing. No data is loaded to <code><em>pOutInfo</em></code> and the <code><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">ResultSoundArchivePlayerStreamSoundIsPlaying</a></code> error is returned when you attempt to get data during playback.</p>
<p>To get data, you need a working area that is at least as large as the size obtained using <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a1a5677dd952a371a68249d88dc6eb35b">GetRequiredWorkBufferSizeToReadStreamSoundHeader</a></code>. The working area is only used while this function is running.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutInfo</td><td>Passes an array of objects to store the read results. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">streamSoundName</td><td>The label string for the stream sound to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pRegionName</td><td>The array of names for the regions to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">infoCount</td><td>The number of region data instances to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the working area. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of the working area. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soundArchiveName</td><td>The name of the additional sound archive to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_invalid_name.html">nn::atk::ResultSoundArchivePlayerInvalidName</a> An invalid name was specified, or the string table was not loaded.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">nn::atk::ResultSoundArchivePlayerStreamSoundIsPlaying</a> The target stream sound is playing.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_read_stream_sound_file_path_failed.html">nn::atk::ResultSoundArchivePlayerReadStreamSoundFilePathFailed</a> Failed to load from the file path for the target stream sound.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_file_system_error.html">nn::atk::ResultSoundArchivePlayerFileSystemError</a> File system processing failed.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_load_file_header_failed.html">nn::atk::ResultSoundArchivePlayerLoadFileHeaderFailed</a> Failed to load the header.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_has_no_region.html">nn::atk::ResultSoundArchivePlayerStreamSoundHasNoRegion</a> There is no region information in the target stream sound.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_region_not_found.html">nn::atk::ResultSoundArchivePlayerStreamSoundRegionNotFound</a> Could not find the specified region information in the target stream sound.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutInfo</em></code> != <code>nullptr</code>.</li>
<li><code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is initialized.</li>
<li><code><em>buffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>bufferSize</em></code> &gt;= <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a1a5677dd952a371a68249d88dc6eb35b" title="Gets the size of the working area needed to get stream sound header information.">GetRequiredWorkBufferSizeToReadStreamSoundHeader()</a></code>.</li>
<li><code><em>infoCount</em></code> &gt; <code>0</code>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a1a5677dd952a371a68249d88dc6eb35b" title="Gets the size of the working area needed to get stream sound header information.">GetRequiredWorkBufferSizeToReadStreamSoundHeader</a> </dd></dl>

</div>
</div>
<a id="a9fd7360c0450f6b2e9bf33d12a495512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd7360c0450f6b2e9bf33d12a495512">&#9670;&nbsp;</a></span>ReadStreamSoundRegionDataInfo() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::atk::SoundArchivePlayer::ReadStreamSoundRegionDataInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1atk_1_1_stream_sound_region_data_info.html">StreamSoundRegionDataInfo</a> *&#160;</td>
          <td class="paramname"><em>pOutInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a>&#160;</td>
          <td class="paramname"><em>streamSoundId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>pRegionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>infoCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>soundArchiveName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets multiple instances of region information about stream sounds in the additional sound archive. </p>
<p> <b>Details</b> <br  />
 To get the region information for stream sounds in the main sound archive, either specify <code>nullptr</code> for <code><em>soundArchiveName</em></code> or use the version of the function that does not have <code><em>soundArchiveName</em></code> as a parameter.</p>
<p>You can get data at any point after initializing <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code>, as long as the target stream sound is not playing. No data is loaded to <code><em>pOutInfo</em></code> and the <code><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">ResultSoundArchivePlayerStreamSoundIsPlaying</a></code> error is returned when you attempt to get data during playback.</p>
<p>To get data, you need a working area that is at least as large as the size obtained using <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a1a5677dd952a371a68249d88dc6eb35b">GetRequiredWorkBufferSizeToReadStreamSoundHeader</a></code>. The working area is only used while this function is running.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutInfo</td><td>Passes an array of objects to store the read results. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">streamSoundId</td><td>The ID for the stream sound to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pRegionName</td><td>The array of names for the regions to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">infoCount</td><td>The number of region data instances to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the working area. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of the working area. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soundArchiveName</td><td>The name of the additional sound archive to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">nn::atk::ResultSoundArchivePlayerStreamSoundIsPlaying</a> The target stream sound is playing.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_read_stream_sound_file_path_failed.html">nn::atk::ResultSoundArchivePlayerReadStreamSoundFilePathFailed</a> Failed to load from the file path for the target stream sound.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_file_system_error.html">nn::atk::ResultSoundArchivePlayerFileSystemError</a> File system processing failed.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_load_file_header_failed.html">nn::atk::ResultSoundArchivePlayerLoadFileHeaderFailed</a> Failed to load the header.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_has_no_region.html">nn::atk::ResultSoundArchivePlayerStreamSoundHasNoRegion</a> There is no region information in the target stream sound.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_region_not_found.html">nn::atk::ResultSoundArchivePlayerStreamSoundRegionNotFound</a> Could not find the specified region information in the target stream sound.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutInfo</em></code> != <code>nullptr</code>.</li>
<li><code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is initialized.</li>
<li><code><em>buffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>bufferSize</em></code> &gt;= <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a1a5677dd952a371a68249d88dc6eb35b" title="Gets the size of the working area needed to get stream sound header information.">GetRequiredWorkBufferSizeToReadStreamSoundHeader()</a></code>.</li>
<li><code><em>infoCount</em></code> &gt; <code>0</code>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a1a5677dd952a371a68249d88dc6eb35b" title="Gets the size of the working area needed to get stream sound header information.">GetRequiredWorkBufferSizeToReadStreamSoundHeader</a> </dd></dl>

</div>
</div>
<a id="a9eb2521b4d73e5e2441ecb2a1cd2c394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb2521b4d73e5e2441ecb2a1cd2c394">&#9670;&nbsp;</a></span>ReadStreamSoundRegionDataInfo() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::atk::SoundArchivePlayer::ReadStreamSoundRegionDataInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1atk_1_1_stream_sound_region_data_info.html">StreamSoundRegionDataInfo</a> *&#160;</td>
          <td class="paramname"><em>pOutInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a>&#160;</td>
          <td class="paramname"><em>streamSoundId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>pRegionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>infoCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnn_1_1atk_1_1_sound_archive.html">SoundArchive</a> *&#160;</td>
          <td class="paramname"><em>pSoundArchive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets multiple instances of region information about stream sounds in the additional sound archive. </p>
<p> <b>Details</b> <br  />
 Gets region information about stream sounds present in the main sound archive. Use a function for which <code><em>pSoundArchive</em></code> is not in the argument.</p>
<p>You can get data at any point after initializing <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code>, as long as the target stream sound is not playing. No data is loaded to <code><em>pOutInfo</em></code> and the <code><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">ResultSoundArchivePlayerStreamSoundIsPlaying</a></code> error is returned when you attempt to get data during playback.</p>
<p>To get data, you need a working area that is at least as large as the size obtained using <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a1a5677dd952a371a68249d88dc6eb35b">GetRequiredWorkBufferSizeToReadStreamSoundHeader</a></code>. The working area is only used while this function is running.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutInfo</td><td>Passes an array of objects to store the read results. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">streamSoundId</td><td>The ID for the stream sound to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pRegionName</td><td>The array of names for the regions to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">infoCount</td><td>The number of region data instances to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSoundArchive</td><td>The additional sound archive to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the working area. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of the working area.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">nn::atk::ResultSoundArchivePlayerStreamSoundIsPlaying</a> The target stream sound is playing.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_read_stream_sound_file_path_failed.html">nn::atk::ResultSoundArchivePlayerReadStreamSoundFilePathFailed</a> Failed to load from the file path for the target stream sound.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_file_system_error.html">nn::atk::ResultSoundArchivePlayerFileSystemError</a> File system processing failed.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_load_file_header_failed.html">nn::atk::ResultSoundArchivePlayerLoadFileHeaderFailed</a> Failed to load the header.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_has_no_region.html">nn::atk::ResultSoundArchivePlayerStreamSoundHasNoRegion</a> There is no region information in the target stream sound.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_region_not_found.html">nn::atk::ResultSoundArchivePlayerStreamSoundRegionNotFound</a> Could not find the specified region information in the target stream sound.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutInfo</em></code> != <code>nullptr</code>.</li>
<li><code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is initialized.</li>
<li><code><em>buffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>bufferSize</em></code> &gt;= <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a1a5677dd952a371a68249d88dc6eb35b" title="Gets the size of the working area needed to get stream sound header information.">GetRequiredWorkBufferSizeToReadStreamSoundHeader()</a></code>.</li>
<li><code><em>infoCount</em></code> &gt; <code>0</code>.</li>
<li><code><em>pSoundArchive</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a1a5677dd952a371a68249d88dc6eb35b" title="Gets the size of the working area needed to get stream sound header information.">GetRequiredWorkBufferSizeToReadStreamSoundHeader</a> </dd></dl>

</div>
</div>
<a id="ab80bf0c59c0fa5c1f1bd1a8c76e95db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80bf0c59c0fa5c1f1bd1a8c76e95db0">&#9670;&nbsp;</a></span>ReadMarkerInfoArray() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::atk::SoundArchivePlayer::ReadMarkerInfoArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1atk_1_1_stream_sound_marker_info.html">StreamSoundMarkerInfo</a> *&#160;</td>
          <td class="paramname"><em>pOutInfoArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutActualInfoCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>markerInfoCountMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a>&#160;</td>
          <td class="paramname"><em>streamSoundId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the marker information embedded in the waveform being used by the stream sound. </p>
<p> <b>Details</b> <br  />
 You can get data at any point after initializing <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code>, as long as the target stream sound is not playing. If you try to get the information during playback, no data is read into <code><em>pOutInfoArray</em></code> and the <code><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">ResultSoundArchivePlayerStreamSoundIsPlaying</a></code> error is returned</p>
<p>By passing a large number of <code><a class="el" href="structnn_1_1atk_1_1_stream_sound_marker_info.html">StreamSoundMarkerInfo</a></code> arrays, and passing that number count as the value for both <code><em>pOutInfoArray</em></code> and <code><em>markerInfoCountMax</em></code>, you can read the information from the stream sound binary and store the results in <code><em>pOutInfoArray</em></code> and <code><em>pOutActualInfoCount</em></code>.</p>
<p>To determine whether all of the marker information could be obtained, check whether <code><em>pOutActualInfoCount</em></code> is equal to or less than <code><em>markerInfoCountMax</em></code> after running this function. If <code><em>pOutActualInfoCount</em></code> is larger than <code><em>markerInfoCountMax</em></code>, only <code><em>markerInfoCountMax</em></code> sets of information from the start have been stored in <code><em>pOutInfoArray</em></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pOutInfoArray</td><td>Pointer to the start of the object arrays for storing the read results. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pOutActualInfoCount</td><td>Pointer to the variable for storing the number of sets of marker information included in the binary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">markerInfoCountMax</td><td>The number of object arrays for storing the read results. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">streamSoundId</td><td>The ID of the stream sound to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">nn::atk::ResultSoundArchivePlayerStreamSoundIsPlaying</a> The target stream sound is playing.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_read_stream_sound_file_path_failed.html">nn::atk::ResultSoundArchivePlayerReadStreamSoundFilePathFailed</a> Failed to load from the file path for the target stream sound.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_file_system_error.html">nn::atk::ResultSoundArchivePlayerFileSystemError</a> File system processing failed.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_invalid_format.html">nn::atk::ResultSoundArchivePlayerInvalidFormat</a> A binary in an unsupported format was passed.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutInfoArray</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutActualInfoCount</em></code> != <code>nullptr</code>.</li>
<li><code><em>markerInfoCountMax</em></code> &gt; <code>0</code>.</li>
<li><code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac8cb07170215ea29919a734e663f8c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8cb07170215ea29919a734e663f8c72">&#9670;&nbsp;</a></span>ReadMarkerInfoArray() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::atk::SoundArchivePlayer::ReadMarkerInfoArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1atk_1_1_stream_sound_marker_info.html">StreamSoundMarkerInfo</a> *&#160;</td>
          <td class="paramname"><em>pOutInfoArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutActualInfoCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>markerInfoCountMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>streamSoundName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the marker information embedded in the waveform being used by the stream sound. </p>
<p> <b>Details</b> <br  />
 You can get data at any point after initializing <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code>, as long as the target stream sound is not playing. If you try to get the information during playback, no data is read into <code><em>pOutInfoArray</em></code> and the <code><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">ResultSoundArchivePlayerStreamSoundIsPlaying</a></code> error is returned</p>
<p>By passing a large number of <code><a class="el" href="structnn_1_1atk_1_1_stream_sound_marker_info.html">StreamSoundMarkerInfo</a></code> arrays, and passing that number count as the value for both <code><em>pOutInfoArray</em></code> and <code><em>markerInfoCountMax</em></code>, you can read the information from the stream sound binary and store the results in <code><em>pOutInfoArray</em></code> and <code><em>pOutActualInfoCount</em></code>.</p>
<p>To determine whether all of the marker information could be obtained, check whether <code><em>pOutActualInfoCount</em></code> is equal to or less than <code><em>markerInfoCountMax</em></code> after running this function. If <code><em>pOutActualInfoCount</em></code> is larger than <code><em>markerInfoCountMax</em></code>, only <code><em>markerInfoCountMax</em></code> sets of information from the start have been stored in <code><em>pOutInfoArray</em></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pOutInfoArray</td><td>Pointer to the start of the object arrays for storing the read results. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pOutActualInfoCount</td><td>Pointer to the variable for storing the number of sets of marker information included in the binary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">markerInfoCountMax</td><td>The number of object arrays for storing the read results. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">streamSoundName</td><td>The label string for the stream sound that will be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_invalid_name.html">nn::atk::ResultSoundArchivePlayerInvalidName</a> An invalid name was specified, or the string table was not loaded.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">nn::atk::ResultSoundArchivePlayerStreamSoundIsPlaying</a> The target stream sound is playing.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_read_stream_sound_file_path_failed.html">nn::atk::ResultSoundArchivePlayerReadStreamSoundFilePathFailed</a> Failed to load from the file path for the target stream sound.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_file_system_error.html">nn::atk::ResultSoundArchivePlayerFileSystemError</a> File system processing failed.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_invalid_format.html">nn::atk::ResultSoundArchivePlayerInvalidFormat</a> A binary in an unsupported format was passed.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutInfoArray</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutActualInfoCount</em></code> != <code>nullptr</code>.</li>
<li><code><em>markerInfoCountMax</em></code> &gt; <code>0</code>.</li>
<li><code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a949eea181cdfa2c44c4a372aec433700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949eea181cdfa2c44c4a372aec433700">&#9670;&nbsp;</a></span>ReadMarkerInfoArray() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::atk::SoundArchivePlayer::ReadMarkerInfoArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1atk_1_1_stream_sound_marker_info.html">StreamSoundMarkerInfo</a> *&#160;</td>
          <td class="paramname"><em>pOutInfoArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutActualInfoCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>markerInfoCountMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a>&#160;</td>
          <td class="paramname"><em>streamSoundId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>soundArchiveName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the marker information embedded in the waveform being used by the stream sound. </p>
<p> <b>Details</b> <br  />
 You can get data at any point after initializing <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code>, as long as the target stream sound is not playing. If you try to get the information during playback, no data is read into <code><em>pOutInfoArray</em></code> and the <code><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">ResultSoundArchivePlayerStreamSoundIsPlaying</a></code> error is returned</p>
<p>By passing a large number of <code><a class="el" href="structnn_1_1atk_1_1_stream_sound_marker_info.html">StreamSoundMarkerInfo</a></code> arrays, and passing that number count as the value for both <code><em>pOutInfoArray</em></code> and <code><em>markerInfoCountMax</em></code>, you can read the information from the stream sound binary and store the results in <code><em>pOutInfoArray</em></code> and <code><em>pOutActualInfoCount</em></code>.</p>
<p>To determine whether all of the marker information could be obtained, check whether <code><em>pOutActualInfoCount</em></code> is equal to or less than <code><em>markerInfoCountMax</em></code> after running this function. If <code><em>pOutActualInfoCount</em></code> is larger than <code><em>markerInfoCountMax</em></code>, only <code><em>markerInfoCountMax</em></code> sets of information from the start have been stored in <code><em>pOutInfoArray</em></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pOutInfoArray</td><td>Pointer to the start of the object arrays for storing the read results. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pOutActualInfoCount</td><td>Pointer to the variable for storing the number of sets of marker information included in the binary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">markerInfoCountMax</td><td>The number of object arrays for storing the read results. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">streamSoundId</td><td>The ID of the stream sound to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soundArchiveName</td><td>The name of the sound archive that will be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">nn::atk::ResultSoundArchivePlayerStreamSoundIsPlaying</a> The target stream sound is playing.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_read_stream_sound_file_path_failed.html">nn::atk::ResultSoundArchivePlayerReadStreamSoundFilePathFailed</a> Failed to load from the file path for the target stream sound.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_file_system_error.html">nn::atk::ResultSoundArchivePlayerFileSystemError</a> File system processing failed.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_invalid_format.html">nn::atk::ResultSoundArchivePlayerInvalidFormat</a> A binary in an unsupported format was passed.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutInfoArray</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutActualInfoCount</em></code> != <code>nullptr</code>.</li>
<li><code><em>markerInfoCountMax</em></code> &gt; <code>0</code>.</li>
<li><code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a3c897b36a81e005094d2ce91f1666078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c897b36a81e005094d2ce91f1666078">&#9670;&nbsp;</a></span>ReadMarkerInfoArray() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::atk::SoundArchivePlayer::ReadMarkerInfoArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1atk_1_1_stream_sound_marker_info.html">StreamSoundMarkerInfo</a> *&#160;</td>
          <td class="paramname"><em>pOutInfoArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutActualInfoCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>markerInfoCountMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>streamSoundName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>soundArchiveName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the marker information embedded in the waveform being used by the stream sound. </p>
<p> <b>Details</b> <br  />
 You can get data at any point after initializing <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code>, as long as the target stream sound is not playing. If you try to get the information during playback, no data is read into <code><em>pOutInfoArray</em></code> and the <code><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">ResultSoundArchivePlayerStreamSoundIsPlaying</a></code> error is returned</p>
<p>By passing a large number of <code><a class="el" href="structnn_1_1atk_1_1_stream_sound_marker_info.html">StreamSoundMarkerInfo</a></code> arrays, and passing that number count as the value for both <code><em>pOutInfoArray</em></code> and <code><em>markerInfoCountMax</em></code>, you can read the information from the stream sound binary and store the results in <code><em>pOutInfoArray</em></code> and <code><em>pOutActualInfoCount</em></code>.</p>
<p>To determine whether all of the marker information could be obtained, check whether <code><em>pOutActualInfoCount</em></code> is equal to or less than <code><em>markerInfoCountMax</em></code> after running this function. If <code><em>pOutActualInfoCount</em></code> is larger than <code><em>markerInfoCountMax</em></code>, only <code><em>markerInfoCountMax</em></code> sets of information from the start have been stored in <code><em>pOutInfoArray</em></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pOutInfoArray</td><td>Pointer to the start of the object arrays for storing the read results. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pOutActualInfoCount</td><td>Pointer to the variable for storing the number of sets of marker information included in the binary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">markerInfoCountMax</td><td>The number of object arrays for storing the read results. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">streamSoundName</td><td>The label string for the stream sound that will be read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soundArchiveName</td><td>The name of the sound archive that will be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_invalid_name.html">nn::atk::ResultSoundArchivePlayerInvalidName</a> An invalid name was specified, or the string table was not loaded.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_stream_sound_is_playing.html">nn::atk::ResultSoundArchivePlayerStreamSoundIsPlaying</a> The target stream sound is playing.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_read_stream_sound_file_path_failed.html">nn::atk::ResultSoundArchivePlayerReadStreamSoundFilePathFailed</a> Failed to load from the file path for the target stream sound.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_file_system_error.html">nn::atk::ResultSoundArchivePlayerFileSystemError</a> File system processing failed.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_invalid_format.html">nn::atk::ResultSoundArchivePlayerInvalidFormat</a> A binary in an unsupported format was passed.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutInfoArray</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutActualInfoCount</em></code> != <code>nullptr</code>.</li>
<li><code><em>markerInfoCountMax</em></code> &gt; <code>0</code>.</li>
<li><code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a762f020d7a0cbe8f3561b050ed70f2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762f020d7a0cbe8f3561b050ed70f2cd">&#9670;&nbsp;</a></span>CheckStreamSoundFileExisting() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::atk::SoundArchivePlayer::CheckStreamSoundFileExisting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a>&#160;</td>
          <td class="paramname"><em>streamSoundId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks for the existence of a stream sound file (a BFSTM file). </p>
<p> <b>Details</b> <br  />
 Returns <code><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html">nn::fs::ResultPathNotFound</a></code> if no file exists for the stream sound specified by the ID. Returns <code><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_read_stream_sound_file_path_failed.html">ResultSoundArchivePlayerReadStreamSoundFilePathFailed</a></code> if the function fails to get the file path, which can happen if the specified ID is not for a stream sound, or if a nonexistent ID has been specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">streamSoundId</td><td>The ID for the stream sound to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html">nn::fs::ResultPathNotFound</a> The target file cannot be found.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_read_stream_sound_file_path_failed.html">nn::atk::ResultSoundArchivePlayerReadStreamSoundFilePathFailed</a> Failed to load from the file path for the target stream sound.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is initialized.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a9fc5990e6b55371f48da4d3c08f27f9d" title="Gets the file path of the stream sound that the specified ID references.">nn::atk::SoundArchive::ReadStreamSoundFilePath</a> </dd></dl>

</div>
</div>
<a id="a21e3d594647722e0d2aefe1c68453c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e3d594647722e0d2aefe1c68453c80">&#9670;&nbsp;</a></span>CheckStreamSoundFileExisting() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::atk::SoundArchivePlayer::CheckStreamSoundFileExisting </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>streamSoundName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks for the existence of a stream sound file (a BFSTM file). </p>
<p> <b>Details</b> <br  />
 Returns <code><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html">nn::fs::ResultPathNotFound</a></code> if no file exists for the stream sound specified by the label name. Returns <code><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_read_stream_sound_file_path_failed.html">ResultSoundArchivePlayerReadStreamSoundFilePathFailed</a></code> if the function fails to get the file path, which can happen if the specified label is not for a stream sound. Returns <code><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_invalid_name.html">ResultSoundArchivePlayerInvalidName</a></code> if the label string is invalid or the string table is not loaded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">streamSoundName</td><td>The label string for the stream sound to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html">nn::fs::ResultPathNotFound</a> The target file cannot be found.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_read_stream_sound_file_path_failed.html">nn::atk::ResultSoundArchivePlayerReadStreamSoundFilePathFailed</a> Failed to load from the file path for the target stream sound.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_invalid_name.html">nn::atk::ResultSoundArchivePlayerInvalidName</a> An invalid name was specified, or the string table was not loaded.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is initialized.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a9fc5990e6b55371f48da4d3c08f27f9d" title="Gets the file path of the stream sound that the specified ID references.">nn::atk::SoundArchive::ReadStreamSoundFilePath</a> </dd></dl>

</div>
</div>
<a id="a3ddb64d1ddfed462ec68a0ea1ab32634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ddb64d1ddfed462ec68a0ea1ab32634">&#9670;&nbsp;</a></span>CheckStreamSoundFileExisting() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::atk::SoundArchivePlayer::CheckStreamSoundFileExisting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a>&#160;</td>
          <td class="paramname"><em>streamSoundId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>soundArchiveName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks for the existence of a stream sound (BFSTM) file in the additional sound archive. </p>
<p> <b>Details</b> <br  />
 To check for the presence of stream sounds files in the main sound archive, use either a function with <code>nullptr</code> specified as the <code><em>soundArchiveName</em></code> parameter, or one that does not have <code><em>soundArchiveName</em></code> in the arguments.</p>
<p>Returns <code><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html">nn::fs::ResultPathNotFound</a></code> if no file exists for the stream sound specified by the ID. Returns <code><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_read_stream_sound_file_path_failed.html">ResultSoundArchivePlayerReadStreamSoundFilePathFailed</a></code> if the function fails to get the file path, which can happen if the specified ID is not for a stream sound, or if a nonexistent ID has been specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">streamSoundId</td><td>The ID for the stream sound to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soundArchiveName</td><td>The name of the sound archive to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html">nn::fs::ResultPathNotFound</a> The target file cannot be found.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_read_stream_sound_file_path_failed.html">nn::atk::ResultSoundArchivePlayerReadStreamSoundFilePathFailed</a> Failed to load from the file path for the target stream sound.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is initialized.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a9fc5990e6b55371f48da4d3c08f27f9d" title="Gets the file path of the stream sound that the specified ID references.">nn::atk::SoundArchive::ReadStreamSoundFilePath</a> </dd></dl>

</div>
</div>
<a id="ad743c92f9aaa69b097a8d0a0ce7b593c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad743c92f9aaa69b097a8d0a0ce7b593c">&#9670;&nbsp;</a></span>CheckStreamSoundFileExisting() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::atk::SoundArchivePlayer::CheckStreamSoundFileExisting </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>streamSoundName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>soundArchiveName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks for the existence of a stream sound (BFSTM) file in the additional sound archive. </p>
<p> <b>Details</b> <br  />
 To check for the presence of stream sounds files in the main sound archive, use either a function with <code>nullptr</code> specified as the <code><em>soundArchiveName</em></code> parameter, or one that does not have <code><em>soundArchiveName</em></code> in the arguments.</p>
<p>Returns <code><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html">nn::fs::ResultPathNotFound</a></code> if no file exists for the stream sound specified by the label name. Returns <code><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_read_stream_sound_file_path_failed.html">ResultSoundArchivePlayerReadStreamSoundFilePathFailed</a></code> if the function fails to get the file path, which can happen if the specified label is not for a stream sound. Returns <code><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_invalid_name.html">ResultSoundArchivePlayerInvalidName</a></code> if the label string is invalid or the string table is not loaded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">streamSoundName</td><td>The label string for the stream sound to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soundArchiveName</td><td>The name of the sound archive to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html">nn::fs::ResultPathNotFound</a> The target file cannot be found.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_read_stream_sound_file_path_failed.html">nn::atk::ResultSoundArchivePlayerReadStreamSoundFilePathFailed</a> Failed to load from the file path for the target stream sound.</li>
<li><a class="el" href="classnn_1_1atk_1_1_result_sound_archive_player_invalid_name.html">nn::atk::ResultSoundArchivePlayerInvalidName</a> An invalid name was specified, or the string table was not loaded.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is initialized.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a9fc5990e6b55371f48da4d3c08f27f9d" title="Gets the file path of the stream sound that the specified ID references.">nn::atk::SoundArchive::ReadStreamSoundFilePath</a> </dd></dl>

</div>
</div>
<a id="ae333a16ca9227bd35cd079c16f2d4803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae333a16ca9227bd35cd079c16f2d4803">&#9670;&nbsp;</a></span>AddAddonSoundArchive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::atk::SoundArchivePlayer::AddAddonSoundArchive </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnn_1_1atk_1_1_addon_sound_archive.html">AddonSoundArchive</a> *&#160;</td>
          <td class="paramname"><em>pSoundArchive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnn_1_1atk_1_1_sound_data_manager.html">SoundDataManager</a> *&#160;</td>
          <td class="paramname"><em>pSoundDataManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an additional sound archive to a player. </p>
<p> <b>Details</b> <br  />
 An additional sound archive added with this function can be used as an additional sound archive with the name specified in the argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the additional sound archive. The maximum name length is <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a075200f0bcc1a4892fa664a148c73dee">AddonSoundArchiveNameLengthMax</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSoundArchive</td><td>The additional sound archive. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSoundDataManager</td><td>The <a class="el" href="classnn_1_1atk_1_1_sound_data_manager.html" title="A flag used to load sound archive data.">SoundDataManager</a> used by the additional sound archive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is initialized.</li>
<li>The number of additional sound archives specified when <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is initialized is greater than zero.</li>
<li><code><em>name</em></code> != <code>nullptr</code>.</li>
<li>(String length of name) &lt; <code>AddonSoundArchiveNameLengthMax</code>.</li>
<li><code><em>pSoundArchive</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSoundArchive</em></code> is initialized.</li>
<li><code><em>pSoundDataManager</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSoundDataManager</em></code> is initialized.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a4e2aca96645e4bacc9810df0372daa71" title="Deletes an additional sound archive from a player.">RemoveAddonSoundArchive</a> </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a075200f0bcc1a4892fa664a148c73dee" title="The maximum length of an AddonSoundArchive name.">AddonSoundArchiveNameLengthMax</a> </dd></dl>

</div>
</div>
<a id="a4e2aca96645e4bacc9810df0372daa71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e2aca96645e4bacc9810df0372daa71">&#9670;&nbsp;</a></span>RemoveAddonSoundArchive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::atk::SoundArchivePlayer::RemoveAddonSoundArchive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnn_1_1atk_1_1_addon_sound_archive.html">AddonSoundArchive</a> *&#160;</td>
          <td class="paramname"><em>pSoundArchive</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes an additional sound archive from a player. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSoundArchive</td><td>The additional sound archive to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is initialized.</li>
<li>The number of additional sound archives specified when <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is initialized is greater than zero.</li>
<li><code><em>pSoundArchive</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ae333a16ca9227bd35cd079c16f2d4803" title="Adds an additional sound archive to a player.">AddAddonSoundArchive</a> </dd></dl>

</div>
</div>
<a id="aae89259218f196a39ea6a828856a87ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae89259218f196a39ea6a828856a87ab">&#9670;&nbsp;</a></span>SetStreamBlockCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::atk::SoundArchivePlayer::SetStreamBlockCount </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p> <b>The use of internal features is prohibited.</b> </p>
<p>Sets the number of blocks to allocate for the buffer used for stream playback. The default number of blocks is <code>DefaultStreamBlockCount</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of blocks to allocate for the buffer used for stream playback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> when set successfully.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html" title="Plays back sounds in a sound archive.">SoundArchivePlayer</a></code> is not yet uninitialized. <code><em>count</em></code> &gt;= <code>StreamBlockCountMin</code>. <code><em>count</em></code> &lt;= <code>DefaultStreamBlockCount</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#acacd47f7b7b27101220d04da35acb847" title="&lt;b&gt;The use of internal features is prohibited.&lt;/b&gt;">GetStreamBlockCount</a> </dd></dl>

</div>
</div>
<a id="acacd47f7b7b27101220d04da35acb847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acacd47f7b7b27101220d04da35acb847">&#9670;&nbsp;</a></span>GetStreamBlockCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::atk::SoundArchivePlayer::GetStreamBlockCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p> <b>The use of internal features is prohibited.</b> </p>
<p>Gets the number of blocks to allocate for the buffer used for stream playback. The default number of blocks is <code>DefaultStreamBlockCount</code>. </p><dl class="section return"><dt>Returns</dt><dd>The number of blocks to allocate for the buffer used for stream playback.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aae89259218f196a39ea6a828856a87ab" title="&lt;b&gt;The use of internal features is prohibited.&lt;/b&gt;">SetStreamBlockCount</a> </dd></dl>

</div>
</div>
<a id="ad3df5bdfb4cc9785e5d4d861d0c3e6b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3df5bdfb4cc9785e5d4d861d0c3e6b4">&#9670;&nbsp;</a></span>SetDefaultOutputReceiver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::atk::SoundArchivePlayer::SetDefaultOutputReceiver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_output_receiver.html">OutputReceiver</a> *&#160;</td>
          <td class="paramname"><em>pOutputReceiver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the default output destination to use when playing sounds using a user-defined submix construct. </p>
<p> <b>Details</b> <br  />
 Sets the default output destination to use when sounds are played using a user-defined submix construct, without configuring <code><a class="el" href="structnn_1_1atk_1_1_sound_startable_1_1_start_info.html#a1961bf9364db8bcc6ffc7a964befb493" title="Sets the sound output line.">SoundStartable::StartInfo::pOutputReceiver</a></code>.</p>
<p>In the initial state, the output destination is the final mix. To restore the initial state, set <code>nullptr</code> using this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pOutputReceiver</td><td>The output destination to use as the default setting. Specify <code>nullptr</code> to set the final mix as the output destination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a075bc1dea627defdc533d514e50c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a075bc1dea627defdc533d514e50c33">&#9670;&nbsp;</a></span>StartSound() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">StartResult</a> nn::atk::SoundStartable::StartSound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_handle.html">SoundHandle</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a>&#160;</td>
          <td class="paramname"><em>soundId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1atk_1_1_sound_startable_1_1_start_info.html">StartInfo</a> *&#160;</td>
          <td class="paramname"><em>pStartInfo</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Plays the sound with the specified ID. </p>
<p> <b>Details</b> <br  />
 The first argument specifies the sound handle. The sound for which playback succeeded is associated with this sound handle.</p>
<p>The second argument specifies the ID of the sound to play.</p>
<p><code><em>pStartInfo</em></code> is an advanced parameter that can be set at playback time. You can start playback without setting this parameter.</p>
<p>Calling this function is the same as calling <code><a class="el" href="classnn_1_1atk_1_1_sound_startable.html#aaedfc0d6b40a7f824e74f274785b484e">PrepareSound</a></code> followed immediately by a call to the handle class function <code><a class="el" href="classnn_1_1atk_1_1_sound_handle.html#a89821c8c19d4faa515e5b61dba898b07">SoundHandle::StartPrepared</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>The handle associated with the sound to play. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soundId</td><td>The ID of the sound to play. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pStartInfo</td><td>Detailed playback parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of playback as a <a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">SoundStartable::StartResult</a> type.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_handle.html" title="A handle class that controls playback sounds.">SoundHandle</a> Class </dd>
<dd>
StartResult </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_startable.html#aaedfc0d6b40a7f824e74f274785b484e" title="Prepares to play the sound with the specified ID.">PrepareSound</a> </dd>
<dd>
StartInfo </dd></dl>

</div>
</div>
<a id="aad8c99a4b8a9af64ac1604490eb92e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad8c99a4b8a9af64ac1604490eb92e85">&#9670;&nbsp;</a></span>StartSound() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">StartResult</a> nn::atk::SoundStartable::StartSound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_handle.html">SoundHandle</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a>&#160;</td>
          <td class="paramname"><em>soundId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>soundArchiveName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1atk_1_1_sound_startable_1_1_start_info.html">StartInfo</a> *&#160;</td>
          <td class="paramname"><em>pStartInfo</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Plays the sound of the specified sound archive and ID. </p>
<p> <b>Details</b> <br  />
 The first argument specifies the sound handle. The sound for which playback succeeded is associated with this sound handle.</p>
<p>The second argument specifies the ID of the sound to play.</p>
<p>Set the target sound archive name to <code><em>soundArchiveName</em></code>. When <code>nullptr</code> is passed, the main sound archive will be selected.</p>
<p><code><em>pStartInfo</em></code> is an advanced parameter that can be set at playback time. You can start playback without setting this parameter.</p>
<p>Calling this function is the same as calling <code><a class="el" href="classnn_1_1atk_1_1_sound_startable.html#aaedfc0d6b40a7f824e74f274785b484e">PrepareSound</a></code> followed immediately by a call to the handle class function <code><a class="el" href="classnn_1_1atk_1_1_sound_handle.html#a89821c8c19d4faa515e5b61dba898b07">SoundHandle::StartPrepared</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>The handle associated with the sound to play. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soundId</td><td>The ID of the sound to play. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soundArchiveName</td><td>The name of the sound archive for playback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pStartInfo</td><td>Detailed playback parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of playback as a <a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">SoundStartable::StartResult</a> type.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_handle.html" title="A handle class that controls playback sounds.">SoundHandle</a> Class </dd>
<dd>
StartResult </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_startable.html#aaedfc0d6b40a7f824e74f274785b484e" title="Prepares to play the sound with the specified ID.">PrepareSound</a> </dd>
<dd>
StartInfo </dd></dl>

</div>
</div>
<a id="af7259f5cb7f4c89ebae54d2c102e1a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7259f5cb7f4c89ebae54d2c102e1a9e">&#9670;&nbsp;</a></span>StartSound() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">StartResult</a> nn::atk::SoundStartable::StartSound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_handle.html">SoundHandle</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSoundName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1atk_1_1_sound_startable_1_1_start_info.html">StartInfo</a> *&#160;</td>
          <td class="paramname"><em>pStartInfo</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Plays the sound with the specified label string. </p>
<p> <b>Details</b> <br  />
 The first argument specifies the sound handle. The sound for which playback succeeded is associated with this sound handle.</p>
<p>The second argument specifies a label string that identifies the sound to play.</p>
<p><code><em>pStartInfo</em></code> is an advanced parameter that can be set at playback time. You can start playback without setting this parameter.</p>
<p>Calling this function is the same as calling <code><a class="el" href="classnn_1_1atk_1_1_sound_startable.html#aaedfc0d6b40a7f824e74f274785b484e">PrepareSound</a></code> followed immediately by a call to the handle class function <code><a class="el" href="classnn_1_1atk_1_1_sound_handle.html#a89821c8c19d4faa515e5b61dba898b07">SoundHandle::StartPrepared</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>The handle associated with the sound to play. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSoundName</td><td>The label string of the sound to play. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pStartInfo</td><td>Detailed playback parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of playback as a <a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">SoundStartable::StartResult</a> type.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_handle.html" title="A handle class that controls playback sounds.">SoundHandle</a> Class </dd>
<dd>
StartResult </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_startable.html#aaedfc0d6b40a7f824e74f274785b484e" title="Prepares to play the sound with the specified ID.">PrepareSound</a> </dd>
<dd>
StartInfo </dd></dl>

</div>
</div>
<a id="ae6b4818e3c22546b1884dee8a0d51a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b4818e3c22546b1884dee8a0d51a49">&#9670;&nbsp;</a></span>StartSound() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">StartResult</a> nn::atk::SoundStartable::StartSound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_handle.html">SoundHandle</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSoundName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>soundArchiveName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1atk_1_1_sound_startable_1_1_start_info.html">StartInfo</a> *&#160;</td>
          <td class="paramname"><em>pStartInfo</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Plays the sound of the specified sound archive and label string. </p>
<p> <b>Details</b> <br  />
 The first argument specifies the sound handle. The sound for which playback succeeded is associated with this sound handle.</p>
<p>The second argument specifies a label string that identifies the sound to play.</p>
<p>Set the target sound archive name to <code><em>soundArchiveName</em></code>. When <code>nullptr</code> is passed, the main sound archive will be selected.</p>
<p><code><em>pStartInfo</em></code> is an advanced parameter that can be set at playback time. You can start playback without setting this parameter.</p>
<p>Calling this function is the same as calling <code><a class="el" href="classnn_1_1atk_1_1_sound_startable.html#aaedfc0d6b40a7f824e74f274785b484e">PrepareSound</a></code> followed immediately by a call to the handle class function <code><a class="el" href="classnn_1_1atk_1_1_sound_handle.html#a89821c8c19d4faa515e5b61dba898b07">SoundHandle::StartPrepared</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>The handle associated with the sound to play. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSoundName</td><td>The label string of the sound to play. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soundArchiveName</td><td>The name of the sound archive for playback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pStartInfo</td><td>Detailed playback parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of playback as a <a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">SoundStartable::StartResult</a> type.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_handle.html" title="A handle class that controls playback sounds.">SoundHandle</a> Class </dd>
<dd>
StartResult </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_startable.html#aaedfc0d6b40a7f824e74f274785b484e" title="Prepares to play the sound with the specified ID.">PrepareSound</a> </dd>
<dd>
StartInfo </dd></dl>

</div>
</div>
<a id="a937f7cc13e6961341777ce0b634d47e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a937f7cc13e6961341777ce0b634d47e8">&#9670;&nbsp;</a></span>HoldSound() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">StartResult</a> nn::atk::SoundStartable::HoldSound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_handle.html">SoundHandle</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a>&#160;</td>
          <td class="paramname"><em>soundId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1atk_1_1_sound_startable_1_1_start_info.html">StartInfo</a> *&#160;</td>
          <td class="paramname"><em>pHoldInfo</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Plays or continues the sound with the specified ID. </p>
<p> <b>Details</b> <br  />
 The sound can be played as long as this function continues to be called in each frame with the same ID. The sound stops when calls to the function stop.</p>
<p>The first argument specifies the sound handle.</p>
<p>The second argument specifies the ID of the sound to play.</p>
<p><code><em>pHoldInfo</em></code> is an advanced parameter that can be set at playback time. You can start playback without setting this parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>The handle associated with the sound to play. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soundId</td><td>The ID of the sound to play. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pHoldInfo</td><td>Detailed playback parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of playback as a <a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">SoundStartable::StartResult</a> type.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_handle.html" title="A handle class that controls playback sounds.">SoundHandle</a> Class </dd>
<dd>
StartResult </dd>
<dd>
StartInfo </dd></dl>

</div>
</div>
<a id="a3bf3071a86e28209541371e5f69784b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf3071a86e28209541371e5f69784b0">&#9670;&nbsp;</a></span>HoldSound() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">StartResult</a> nn::atk::SoundStartable::HoldSound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_handle.html">SoundHandle</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a>&#160;</td>
          <td class="paramname"><em>soundId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>soundArchiveName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1atk_1_1_sound_startable_1_1_start_info.html">StartInfo</a> *&#160;</td>
          <td class="paramname"><em>pHoldInfo</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Plays or continues playing the sound of the specified sound archive and ID. </p>
<p> <b>Details</b> <br  />
 The sound can be played as long as this function continues to be called in each frame with the same ID. The sound stops when calls to the function stop.</p>
<p>The first argument specifies the sound handle.</p>
<p>The second argument specifies the ID of the sound to play.</p>
<p>Set the target sound archive name to <code><em>soundArchiveName</em></code>. When <code>nullptr</code> is passed, the main sound archive will be selected.</p>
<p><code><em>pHoldInfo</em></code> is an advanced parameter that can be set at playback time. You can start playback without setting this parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>The handle associated with the sound to play. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soundId</td><td>The ID of the sound to play. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soundArchiveName</td><td>The name of the sound archive for playback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pHoldInfo</td><td>Detailed playback parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of playback as a <a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">SoundStartable::StartResult</a> type.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_handle.html" title="A handle class that controls playback sounds.">SoundHandle</a> Class </dd>
<dd>
StartResult </dd>
<dd>
StartInfo </dd></dl>

</div>
</div>
<a id="a660336390bde50606cb2cbd421d08770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a660336390bde50606cb2cbd421d08770">&#9670;&nbsp;</a></span>HoldSound() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">StartResult</a> nn::atk::SoundStartable::HoldSound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_handle.html">SoundHandle</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSoundName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1atk_1_1_sound_startable_1_1_start_info.html">StartInfo</a> *&#160;</td>
          <td class="paramname"><em>pHoldInfo</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Plays or holds the sound with the specified label string. </p>
<p> <b>Details</b> <br  />
 The sound can be played as long as this function continues to be called in each frame with the same ID. The sound stops when calls to the function stop.</p>
<p>The first argument specifies the sound handle.</p>
<p>The second argument specifies a label string that identifies the sound to play.</p>
<p><code><em>pHoldInfo</em></code> is an advanced parameter that can be set at playback time. You can start playback without setting this parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>The handle associated with the sound to play. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSoundName</td><td>The label string of the sound to play. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pHoldInfo</td><td>Detailed playback parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of playback as a <a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">SoundStartable::StartResult</a> type.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_handle.html" title="A handle class that controls playback sounds.">SoundHandle</a> Class </dd>
<dd>
StartResult </dd>
<dd>
StartInfo </dd></dl>

</div>
</div>
<a id="abe6ef3923b4034114ffd3bec3c861ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe6ef3923b4034114ffd3bec3c861ce7">&#9670;&nbsp;</a></span>HoldSound() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">StartResult</a> nn::atk::SoundStartable::HoldSound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_handle.html">SoundHandle</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSoundName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>soundArchiveName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1atk_1_1_sound_startable_1_1_start_info.html">StartInfo</a> *&#160;</td>
          <td class="paramname"><em>pHoldInfo</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Plays or continues playing the sound of the specified sound archive and label string. </p>
<p> <b>Details</b> <br  />
 The sound can be played as long as this function continues to be called in each frame with the same ID. The sound stops when calls to the function stop.</p>
<p>The first argument specifies the sound handle.</p>
<p>The second argument specifies a label string that identifies the sound to play.</p>
<p>Set the target sound archive name to <code><em>soundArchiveName</em></code>. When <code>nullptr</code> is passed, the main sound archive will be selected.</p>
<p><code><em>pHoldInfo</em></code> is an advanced parameter that can be set at playback time. You can start playback without setting this parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>The handle associated with the sound to play. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSoundName</td><td>The label string of the sound to play. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soundArchiveName</td><td>The name of the sound archive for playback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pHoldInfo</td><td>Detailed playback parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of playback as a <a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">SoundStartable::StartResult</a> type.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_handle.html" title="A handle class that controls playback sounds.">SoundHandle</a> Class </dd>
<dd>
StartResult </dd>
<dd>
StartInfo </dd></dl>

</div>
</div>
<a id="aaedfc0d6b40a7f824e74f274785b484e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaedfc0d6b40a7f824e74f274785b484e">&#9670;&nbsp;</a></span>PrepareSound() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">StartResult</a> nn::atk::SoundStartable::PrepareSound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_handle.html">SoundHandle</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a>&#160;</td>
          <td class="paramname"><em>soundId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1atk_1_1_sound_startable_1_1_start_info.html">StartInfo</a> *&#160;</td>
          <td class="paramname"><em>pStartInfo</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepares to play the sound with the specified ID. </p>
<p> <b>Details</b> <br  />
 If preparations are completed for a sound, you can call the <a class="el" href="classnn_1_1atk_1_1_sound_handle.html#a89821c8c19d4faa515e5b61dba898b07">SoundHandle::StartPrepared</a> function of the handle class and start the playback of that sound.</p>
<p>The first argument specifies the sound handle. The sound for which playback succeeded is associated with this sound handle.</p>
<p>The second argument specifies the ID of the sound to play.</p>
<p><code><em>pStartInfo</em></code> is an advanced parameter that can be set at playback time. You can start playback without setting this parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>The handle associated with the sound to play. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soundId</td><td>The ID of the sound to play. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pStartInfo</td><td>Detailed playback parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of preparing for playback as a <a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">SoundStartable::StartResult</a> type.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_handle.html" title="A handle class that controls playback sounds.">SoundHandle</a> Class </dd>
<dd>
StartResult </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_startable.html#a9a075bc1dea627defdc533d514e50c33" title="Plays the sound with the specified ID.">StartSound</a> </dd>
<dd>
StartInfo </dd></dl>

</div>
</div>
<a id="a888e75f49a05eec7fd89e44d0397e74b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a888e75f49a05eec7fd89e44d0397e74b">&#9670;&nbsp;</a></span>PrepareSound() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">StartResult</a> nn::atk::SoundStartable::PrepareSound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_handle.html">SoundHandle</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_archive.html#a37cf194dfc6867618c3d90711df0ec07">SoundArchive::ItemId</a>&#160;</td>
          <td class="paramname"><em>soundId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>soundArchiveName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1atk_1_1_sound_startable_1_1_start_info.html">StartInfo</a> *&#160;</td>
          <td class="paramname"><em>pStartInfo</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepares to play the sound of the specified sound archive and ID. </p>
<p> <b>Details</b> <br  />
 If preparations are completed for a sound, you can call the <a class="el" href="classnn_1_1atk_1_1_sound_handle.html#a89821c8c19d4faa515e5b61dba898b07">SoundHandle::StartPrepared</a> function of the handle class and start the playback of that sound.</p>
<p>The first argument specifies the sound handle. The sound for which playback succeeded is associated with this sound handle.</p>
<p>The second argument specifies the ID of the sound to play.</p>
<p>Set the target sound archive name to <code><em>soundArchiveName</em></code>. When <code>nullptr</code> is passed, the main sound archive will be selected.</p>
<p><code><em>pStartInfo</em></code> is an advanced parameter that can be set at playback time. You can start playback without setting this parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>The handle associated with the sound to play. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soundId</td><td>The ID of the sound to play. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soundArchiveName</td><td>The name of the sound archive for playback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pStartInfo</td><td>Detailed playback parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of preparing for playback as a <a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">SoundStartable::StartResult</a> type.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_handle.html" title="A handle class that controls playback sounds.">SoundHandle</a> Class </dd>
<dd>
StartResult </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_startable.html#a9a075bc1dea627defdc533d514e50c33" title="Plays the sound with the specified ID.">StartSound</a> </dd>
<dd>
StartInfo </dd></dl>

</div>
</div>
<a id="a4c46b7fc9e9c2c187964b7bf5aa1ff31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c46b7fc9e9c2c187964b7bf5aa1ff31">&#9670;&nbsp;</a></span>PrepareSound() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">StartResult</a> nn::atk::SoundStartable::PrepareSound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_handle.html">SoundHandle</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSoundName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1atk_1_1_sound_startable_1_1_start_info.html">StartInfo</a> *&#160;</td>
          <td class="paramname"><em>pStartInfo</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepares to play the sound with the specified label string. </p>
<p> <b>Details</b> <br  />
 If preparations are completed for a sound, you can call the <a class="el" href="classnn_1_1atk_1_1_sound_handle.html#a89821c8c19d4faa515e5b61dba898b07">SoundHandle::StartPrepared</a> function of the handle class and start the playback of that sound.</p>
<p>The first argument specifies the sound handle. The sound for which playback succeeded is associated with this sound handle.</p>
<p>The second argument specifies a label string that identifies the sound to play.</p>
<p><code><em>pStartInfo</em></code> is an advanced parameter that can be set at playback time. You can start playback without setting this parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>The handle associated with the sound to play. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSoundName</td><td>The label string of the sound to play. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pStartInfo</td><td>Detailed playback parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of preparing for playback as a <a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">SoundStartable::StartResult</a> type.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_handle.html" title="A handle class that controls playback sounds.">SoundHandle</a> Class </dd>
<dd>
StartResult </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_startable.html#a9a075bc1dea627defdc533d514e50c33" title="Plays the sound with the specified ID.">StartSound</a> </dd>
<dd>
StartInfo </dd></dl>

</div>
</div>
<a id="a803fa7ba56fc913c226ccf4c54d73a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803fa7ba56fc913c226ccf4c54d73a55">&#9670;&nbsp;</a></span>PrepareSound() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">StartResult</a> nn::atk::SoundStartable::PrepareSound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1atk_1_1_sound_handle.html">SoundHandle</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSoundName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>soundArchiveName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1atk_1_1_sound_startable_1_1_start_info.html">StartInfo</a> *&#160;</td>
          <td class="paramname"><em>pStartInfo</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepares to play the sound of the specified sound archive and label string. </p>
<p> <b>Details</b> <br  />
 If preparations are completed for a sound, you can call the <a class="el" href="classnn_1_1atk_1_1_sound_handle.html#a89821c8c19d4faa515e5b61dba898b07">SoundHandle::StartPrepared</a> function of the handle class and start the playback of that sound.</p>
<p>The first argument specifies the sound handle. The sound for which playback succeeded is associated with this sound handle.</p>
<p>The second argument specifies a label string that identifies the sound to play.</p>
<p>Set the target sound archive name to <code><em>soundArchiveName</em></code>. When <code>nullptr</code> is passed, the main sound archive will be selected.</p>
<p><code><em>pStartInfo</em></code> is an advanced parameter that can be set at playback time. You can start playback without setting this parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>The handle associated with the sound to play. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSoundName</td><td>The label string of the sound to play. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soundArchiveName</td><td>The name of the sound archive for playback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pStartInfo</td><td>Detailed playback parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of preparing for playback as a <a class="el" href="classnn_1_1atk_1_1_sound_startable_1_1_start_result.html">SoundStartable::StartResult</a> type.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_handle.html" title="A handle class that controls playback sounds.">SoundHandle</a> Class </dd>
<dd>
StartResult </dd>
<dd>
<a class="el" href="classnn_1_1atk_1_1_sound_startable.html#a9a075bc1dea627defdc533d514e50c33" title="Plays the sound with the specified ID.">StartSound</a> </dd>
<dd>
StartInfo </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae1384c59f80a74a59daf5055a67b3cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1384c59f80a74a59daf5055a67b3cb8">&#9670;&nbsp;</a></span>StreamBufferTimesMax</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t nn::atk::SoundArchivePlayer::StreamBufferTimesMax = 4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum magnification for the stream buffer size obtained from <code><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a057468aa40f05336895186fecac53988">GetRequiredStreamBufferTimes</a></code>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#a057468aa40f05336895186fecac53988" title="Gets the multiplication factor for the size of stream buffer required for initialization.">GetRequiredStreamBufferTimes</a> </dd></dl>

</div>
</div>
<a id="a45775787c4e3c73825290b10fd86bc9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45775787c4e3c73825290b10fd86bc9d">&#9670;&nbsp;</a></span>UserParamBoundary</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t nn::atk::SoundArchivePlayer::UserParamBoundary = 4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The boundary where the size of the user parameter is cut off. </p>
<p><code><em>userParamSizePerSound</em></code>, passed to the <code>Initialize</code> function, is cut off at this multiplication boundary.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#aa717dbf0b25d9d2d7d0a381fd3702e61" title="Gets the size of the user parameters held by each sound instance.">GetSoundUserParamSize</a> </dd></dl>

</div>
</div>
<a id="a075200f0bcc1a4892fa664a148c73dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075200f0bcc1a4892fa664a148c73dee">&#9670;&nbsp;</a></span>AddonSoundArchiveNameLengthMax</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int nn::atk::SoundArchivePlayer::AddonSoundArchiveNameLengthMax = nn::atk::detail::AddonSoundArchiveContainer::SoundArchiveNameLengthMax</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum length of an <code><a class="el" href="classnn_1_1atk_1_1_addon_sound_archive.html" title="The additional sound archive.">AddonSoundArchive</a></code> name. </p>
<p>Includes terminating null characters.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnn_1_1atk_1_1_sound_archive_player.html#ae333a16ca9227bd35cd079c16f2d4803" title="Adds an additional sound archive to a player.">AddAddonSoundArchive</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
