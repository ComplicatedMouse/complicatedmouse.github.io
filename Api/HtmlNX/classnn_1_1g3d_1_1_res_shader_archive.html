<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nn::g3d::ResShaderArchive Class Reference | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenn.html">nn</a></li><li class="navelem"><a class="el" href="namespacenn_1_1g3d.html">g3d</a></li><li class="navelem"><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html">ResShaderArchive</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classnn_1_1g3d_1_1_res_shader_archive-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">nn::g3d::ResShaderArchive Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Shader archive resource.  
 <a href="classnn_1_1g3d_1_1_res_shader_archive.html#details">More...</a></p>

<p><code>#include &lt;nn/g3d/g3d_ResShader.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for nn::g3d::ResShaderArchive:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classnn_1_1g3d_1_1_res_shader_archive.png" usemap="#nn::g3d::ResShaderArchive_map" alt=""/>
  <map id="nn::g3d::ResShaderArchive_map" name="nn::g3d::ResShaderArchive_map">
<area href="classnn_1_1util_1_1_accessor_base.html" alt="nn::util::AccessorBase&lt; ResShaderArchiveData &gt;" shape="rect" coords="0,0,293,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a619e026373fb634bcc17fbdd25c63d1e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a619e026373fb634bcc17fbdd25c63d1e">Alignment</a> { <a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a619e026373fb634bcc17fbdd25c63d1ea3671c86e391e20455a2a752b21e47640">Alignment_WorkMemory</a> = 8
 }</td></tr>
<tr class="memdesc:a619e026373fb634bcc17fbdd25c63d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The required alignment size.  <a href="classnn_1_1g3d_1_1_res_shader_archive.html#a619e026373fb634bcc17fbdd25c63d1e">More...</a><br /></td></tr>
<tr class="separator:a619e026373fb634bcc17fbdd25c63d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab849f4b518a2e54212d70fa471d8c971"><td class="memItemLeft" align="right" valign="top"><a id="ab849f4b518a2e54212d70fa471d8c971"></a>
typedef <a class="el" href="structnn_1_1g3d_1_1_res_shader_archive_data.html">ResShaderArchiveData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#ab849f4b518a2e54212d70fa471d8c971">DataType</a></td></tr>
<tr class="memdesc:ab849f4b518a2e54212d70fa471d8c971"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <b>The use of internal features is prohibited.</b> <br /></td></tr>
<tr class="separator:ab849f4b518a2e54212d70fa471d8c971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79be77a00c94ac03b3bff845763676cd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a79be77a00c94ac03b3bff845763676cd">Flag</a> { <br />
 }</td></tr>
<tr class="memdesc:a79be77a00c94ac03b3bff845763676cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for shader archives.  <a href="classnn_1_1g3d_1_1_res_shader_archive.html#a79be77a00c94ac03b3bff845763676cd">More...</a><br /></td></tr>
<tr class="separator:a79be77a00c94ac03b3bff845763676cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f06add6587efa6c07ca0bb8e8d0913c"><td class="memItemLeft" align="right" valign="top"><a id="a6f06add6587efa6c07ca0bb8e8d0913c"></a>
typedef <a class="el" href="structnn_1_1g3d_1_1_res_shader_archive_data.html">ResShaderArchiveData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_accessor_base.html#a6f06add6587efa6c07ca0bb8e8d0913c">value_type</a></td></tr>
<tr class="memdesc:a6f06add6587efa6c07ca0bb8e8d0913c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data structure type. <br /></td></tr>
<tr class="separator:a6f06add6587efa6c07ca0bb8e8d0913c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae1945852eed72008611418a36346932c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnn_1_1util_1_1_accessor_base.html#a6f06add6587efa6c07ca0bb8e8d0913c">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_accessor_base.html#ae1945852eed72008611418a36346932c">ToData</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae1945852eed72008611418a36346932c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference to an instance of the data structure.  <a href="classnn_1_1util_1_1_accessor_base.html#ae1945852eed72008611418a36346932c">More...</a><br /></td></tr>
<tr class="separator:ae1945852eed72008611418a36346932c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e3bdc089c3a0ee9b009f35fbeb4f38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1util_1_1_accessor_base.html#a6f06add6587efa6c07ca0bb8e8d0913c">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_accessor_base.html#a10e3bdc089c3a0ee9b009f35fbeb4f38">ToData</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a10e3bdc089c3a0ee9b009f35fbeb4f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference to an instance of the data structure.  <a href="classnn_1_1util_1_1_accessor_base.html#a10e3bdc089c3a0ee9b009f35fbeb4f38">More...</a><br /></td></tr>
<tr class="separator:a10e3bdc089c3a0ee9b009f35fbeb4f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and Destructors</div></td></tr>
<tr class="memitem:a0bd2ecf27e62dd885eb25a1c57e29c9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a0bd2ecf27e62dd885eb25a1c57e29c9d">Setup</a> (<a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *pDevice) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0bd2ecf27e62dd885eb25a1c57e29c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the shader archive.  <a href="classnn_1_1g3d_1_1_res_shader_archive.html#a0bd2ecf27e62dd885eb25a1c57e29c9d">More...</a><br /></td></tr>
<tr class="separator:a0bd2ecf27e62dd885eb25a1c57e29c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8650d22892838931d1646cf782a195f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#af8650d22892838931d1646cf782a195f">Setup</a> (<a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *pDevice, void *pWorkMemory, size_t workMemorySize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af8650d22892838931d1646cf782a195f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the shader archive.  <a href="classnn_1_1g3d_1_1_res_shader_archive.html#af8650d22892838931d1646cf782a195f">More...</a><br /></td></tr>
<tr class="separator:af8650d22892838931d1646cf782a195f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b8ed10d9ab49a951139f4ff6b3679d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#ab1b8ed10d9ab49a951139f4ff6b3679d">Setup</a> (<a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *pDevice, <a class="el" href="namespacenn_1_1gfx.html#ad620d8208dd309eb7c4dd5973a6aeee5">nn::gfx::MemoryPool</a> *pMemoryPool, ptrdiff_t memoryPoolOffset, size_t memoryPoolSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab1b8ed10d9ab49a951139f4ff6b3679d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the shader archive.  <a href="classnn_1_1g3d_1_1_res_shader_archive.html#ab1b8ed10d9ab49a951139f4ff6b3679d">More...</a><br /></td></tr>
<tr class="separator:ab1b8ed10d9ab49a951139f4ff6b3679d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af076f48c0424b2873a9adc01b2b6bab7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#af076f48c0424b2873a9adc01b2b6bab7">Setup</a> (<a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *pDevice, <a class="el" href="namespacenn_1_1gfx.html#ad620d8208dd309eb7c4dd5973a6aeee5">nn::gfx::MemoryPool</a> *pMemoryPool, ptrdiff_t memoryPoolOffset, size_t memoryPoolSize, void *pWorkMemory, size_t workMemorySize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af076f48c0424b2873a9adc01b2b6bab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the shader archive.  <a href="classnn_1_1g3d_1_1_res_shader_archive.html#af076f48c0424b2873a9adc01b2b6bab7">More...</a><br /></td></tr>
<tr class="separator:af076f48c0424b2873a9adc01b2b6bab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03541d45efb24c2f6991b780ec42add"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#ad03541d45efb24c2f6991b780ec42add">Cleanup</a> (<a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *pDevice) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad03541d45efb24c2f6991b780ec42add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up the shader archive.  <a href="classnn_1_1g3d_1_1_res_shader_archive.html#ad03541d45efb24c2f6991b780ec42add">More...</a><br /></td></tr>
<tr class="separator:ad03541d45efb24c2f6991b780ec42add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Getting and Setting</div></td></tr>
<tr class="memitem:a5ed5eaebeae9492aeaa64fabaf6e743c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a5ed5eaebeae9492aeaa64fabaf6e743c">GetName</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5ed5eaebeae9492aeaa64fabaf6e743c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of the shader archive.  <a href="classnn_1_1g3d_1_1_res_shader_archive.html#a5ed5eaebeae9492aeaa64fabaf6e743c">More...</a><br /></td></tr>
<tr class="separator:a5ed5eaebeae9492aeaa64fabaf6e743c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8198388e75acb485b1c829fa794ca82"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#af8198388e75acb485b1c829fa794ca82">GetPath</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af8198388e75acb485b1c829fa794ca82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the path name.  <a href="classnn_1_1g3d_1_1_res_shader_archive.html#af8198388e75acb485b1c829fa794ca82">More...</a><br /></td></tr>
<tr class="separator:af8198388e75acb485b1c829fa794ca82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf88d0a508d2c96d9847400999b7f2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a3cf88d0a508d2c96d9847400999b7f2f">SetUserPtr</a> (void *pUserPtr) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3cf88d0a508d2c96d9847400999b7f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a user pointer.  <a href="classnn_1_1g3d_1_1_res_shader_archive.html#a3cf88d0a508d2c96d9847400999b7f2f">More...</a><br /></td></tr>
<tr class="separator:a3cf88d0a508d2c96d9847400999b7f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653a9b76579a3dc72734a59d81d11dd7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a653a9b76579a3dc72734a59d81d11dd7">GetUserPtr</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a653a9b76579a3dc72734a59d81d11dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the user pointer.  <a href="classnn_1_1g3d_1_1_res_shader_archive.html#a653a9b76579a3dc72734a59d81d11dd7">More...</a><br /></td></tr>
<tr class="separator:a653a9b76579a3dc72734a59d81d11dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f94d2f92a631e840078acafd3573fe"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a81f94d2f92a631e840078acafd3573fe">GetUserPtr</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a81f94d2f92a631e840078acafd3573fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the user pointer.  <a href="classnn_1_1g3d_1_1_res_shader_archive.html#a81f94d2f92a631e840078acafd3573fe">More...</a><br /></td></tr>
<tr class="separator:a81f94d2f92a631e840078acafd3573fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c2a25e094aeab40405fd5050940e4a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a80c2a25e094aeab40405fd5050940e4a"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a80c2a25e094aeab40405fd5050940e4a">GetUserPtr</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a80c2a25e094aeab40405fd5050940e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the user pointer.  <a href="classnn_1_1g3d_1_1_res_shader_archive.html#a80c2a25e094aeab40405fd5050940e4a">More...</a><br /></td></tr>
<tr class="separator:a80c2a25e094aeab40405fd5050940e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e465c681eecc8017ec29a2f384d85b3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7e465c681eecc8017ec29a2f384d85b3"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a7e465c681eecc8017ec29a2f384d85b3">GetUserPtr</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7e465c681eecc8017ec29a2f384d85b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the user pointer.  <a href="classnn_1_1g3d_1_1_res_shader_archive.html#a7e465c681eecc8017ec29a2f384d85b3">More...</a><br /></td></tr>
<tr class="separator:a7e465c681eecc8017ec29a2f384d85b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af477eb845836d498ddbb78d589b69cd9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#af477eb845836d498ddbb78d589b69cd9">HasSource</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af477eb845836d498ddbb78d589b69cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the object has a source.  <a href="classnn_1_1g3d_1_1_res_shader_archive.html#af477eb845836d498ddbb78d589b69cd9">More...</a><br /></td></tr>
<tr class="separator:af477eb845836d498ddbb78d589b69cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e10718cbef521e1328867b0db15aba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#ae3e10718cbef521e1328867b0db15aba">HasBinary</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae3e10718cbef521e1328867b0db15aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the object has a binary.  <a href="classnn_1_1g3d_1_1_res_shader_archive.html#ae3e10718cbef521e1328867b0db15aba">More...</a><br /></td></tr>
<tr class="separator:ae3e10718cbef521e1328867b0db15aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c4ad43177695eadd295637bf39b58f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a05c4ad43177695eadd295637bf39b58f">IsBinaryAvailable</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a05c4ad43177695eadd295637bf39b58f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the binary is available.  <a href="classnn_1_1g3d_1_1_res_shader_archive.html#a05c4ad43177695eadd295637bf39b58f">More...</a><br /></td></tr>
<tr class="separator:a05c4ad43177695eadd295637bf39b58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3330e5fa3ffd57ec487ceffe02a19dd1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a3330e5fa3ffd57ec487ceffe02a19dd1">HasIr</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3330e5fa3ffd57ec487ceffe02a19dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the object has an intermediate language source.  <a href="classnn_1_1g3d_1_1_res_shader_archive.html#a3330e5fa3ffd57ec487ceffe02a19dd1">More...</a><br /></td></tr>
<tr class="separator:a3330e5fa3ffd57ec487ceffe02a19dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38509b9fe1f0d8ec457e89c0932b096"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#af38509b9fe1f0d8ec457e89c0932b096">GetWorkMemorySize</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af38509b9fe1f0d8ec457e89c0932b096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the work memory for mutual exclusion to pass to the <code><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a0bd2ecf27e62dd885eb25a1c57e29c9d" title="Sets up the shader archive.">Setup()</a></code> function.  <a href="classnn_1_1g3d_1_1_res_shader_archive.html#af38509b9fe1f0d8ec457e89c0932b096">More...</a><br /></td></tr>
<tr class="separator:af38509b9fe1f0d8ec457e89c0932b096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b1dca82cbf7f8f117ac9501042ee53"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a60b1dca82cbf7f8f117ac9501042ee53">GetWorkMemoryPtr</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a60b1dca82cbf7f8f117ac9501042ee53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pointer to the work memory for mutual exclusion set in the <code><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a0bd2ecf27e62dd885eb25a1c57e29c9d" title="Sets up the shader archive.">Setup()</a></code> function.  <a href="classnn_1_1g3d_1_1_res_shader_archive.html#a60b1dca82cbf7f8f117ac9501042ee53">More...</a><br /></td></tr>
<tr class="separator:a60b1dca82cbf7f8f117ac9501042ee53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752f9e5e14c90fd773762c0e04ae95fb"><td class="memItemLeft" align="right" valign="top"><a id="a752f9e5e14c90fd773762c0e04ae95fb"></a>
<a class="el" href="namespacenn_1_1g3d.html#acd933f27ae9f82e84104429b7c38a6a2">UpdateProgramCallback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a752f9e5e14c90fd773762c0e04ae95fb">GetUpdateProgramCallback</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a752f9e5e14c90fd773762c0e04ae95fb"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <b>The use of internal features is prohibited.</b> <br /></td></tr>
<tr class="separator:a752f9e5e14c90fd773762c0e04ae95fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887a8f048fb79b5233dcb0a290a39e21"><td class="memItemLeft" align="right" valign="top"><a id="a887a8f048fb79b5233dcb0a290a39e21"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a887a8f048fb79b5233dcb0a290a39e21">SetUpdateProgramCallback</a> (<a class="el" href="namespacenn_1_1g3d.html#acd933f27ae9f82e84104429b7c38a6a2">UpdateProgramCallback</a> pCallback) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a887a8f048fb79b5233dcb0a290a39e21"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <b>The use of internal features is prohibited.</b> <br /></td></tr>
<tr class="separator:a887a8f048fb79b5233dcb0a290a39e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Shading Models</div></td></tr>
<tr class="memitem:a73d106366c0cd1093a88e1f2f557fdc1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a73d106366c0cd1093a88e1f2f557fdc1">GetShadingModelCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a73d106366c0cd1093a88e1f2f557fdc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of shading models.  <a href="classnn_1_1g3d_1_1_res_shader_archive.html#a73d106366c0cd1093a88e1f2f557fdc1">More...</a><br /></td></tr>
<tr class="separator:a73d106366c0cd1093a88e1f2f557fdc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c81d3fe346cbcc531ad38138b7117b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1g3d_1_1_res_shading_model.html">ResShadingModel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a17c81d3fe346cbcc531ad38138b7117b">FindShadingModel</a> (const char *str) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a17c81d3fe346cbcc531ad38138b7117b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the shading model with the specified name.  <a href="classnn_1_1g3d_1_1_res_shader_archive.html#a17c81d3fe346cbcc531ad38138b7117b">More...</a><br /></td></tr>
<tr class="separator:a17c81d3fe346cbcc531ad38138b7117b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67911db1972ec39ef0eb4af2093a7a2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnn_1_1g3d_1_1_res_shading_model.html">ResShadingModel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#ab67911db1972ec39ef0eb4af2093a7a2">FindShadingModel</a> (const char *str) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab67911db1972ec39ef0eb4af2093a7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the shading model with the specified name.  <a href="classnn_1_1g3d_1_1_res_shader_archive.html#ab67911db1972ec39ef0eb4af2093a7a2">More...</a><br /></td></tr>
<tr class="separator:ab67911db1972ec39ef0eb4af2093a7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df7d310d5e807965be4f4485e32a837"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a6df7d310d5e807965be4f4485e32a837">FindShadingModelIndex</a> (const char *str) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6df7d310d5e807965be4f4485e32a837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the index of the shading model with the specified name.  <a href="classnn_1_1g3d_1_1_res_shader_archive.html#a6df7d310d5e807965be4f4485e32a837">More...</a><br /></td></tr>
<tr class="separator:a6df7d310d5e807965be4f4485e32a837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462ebd8e0dedc4924ee866abd12cd3f5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a462ebd8e0dedc4924ee866abd12cd3f5">GetShadingModelName</a> (int elemIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a462ebd8e0dedc4924ee866abd12cd3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name from the index of the shading model.  <a href="classnn_1_1g3d_1_1_res_shader_archive.html#a462ebd8e0dedc4924ee866abd12cd3f5">More...</a><br /></td></tr>
<tr class="separator:a462ebd8e0dedc4924ee866abd12cd3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8f897e23cfc7659603a6c8083af122"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1g3d_1_1_res_shading_model.html">ResShadingModel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a6f8f897e23cfc7659603a6c8083af122">GetShadingModel</a> (int elemIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6f8f897e23cfc7659603a6c8083af122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the shading model by looking up the index.  <a href="classnn_1_1g3d_1_1_res_shader_archive.html#a6f8f897e23cfc7659603a6c8083af122">More...</a><br /></td></tr>
<tr class="separator:a6f8f897e23cfc7659603a6c8083af122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3829b22ac691593177ec04358559574"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnn_1_1g3d_1_1_res_shading_model.html">ResShadingModel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#af3829b22ac691593177ec04358559574">GetShadingModel</a> (int elemIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af3829b22ac691593177ec04358559574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the shading model by looking up the index.  <a href="classnn_1_1g3d_1_1_res_shader_archive.html#af3829b22ac691593177ec04358559574">More...</a><br /></td></tr>
<tr class="separator:af3829b22ac691593177ec04358559574"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Shader archive resource. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_edit_8cpp-example.html#_a0">G3dDemo/Edit.cpp</a>, <a class="el" href="_g3d_demo_2_nns_g3d_simple_8cpp-example.html#_a36">G3dDemo/NnsG3dSimple.cpp</a>, <a class="el" href="_g3d_demo_2_outline_8cpp-example.html#_a46">G3dDemo/Outline.cpp</a>, <a class="el" href="_g3d_demo_2_parallel_8cpp-example.html#_a64">G3dDemo/Parallel.cpp</a>, <a class="el" href="_g3d_demo_2_shape_animation_8cpp-example.html#_a14">G3dDemo/ShapeAnimation.cpp</a>, <a class="el" href="_g3d_demo_2_simple_8cpp-example.html#_a32">G3dDemo/Simple.cpp</a>, <a class="el" href="_g3d_demo_2_skeletal_animation_8cpp-example.html#_a70">G3dDemo/SkeletalAnimation.cpp</a>, <a class="el" href="_g3d_demo_2_tessellation_8cpp-example.html#_a111">G3dDemo/Tessellation.cpp</a>, and <a class="el" href="_g3d_demo_2_town_8cpp-example.html#_a2">G3dDemo/Town.cpp</a>.</dd>
</dl>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a79be77a00c94ac03b3bff845763676cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79be77a00c94ac03b3bff845763676cd">&#9670;&nbsp;</a></span>Flag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a79be77a00c94ac03b3bff845763676cd">nn::g3d::ResShaderArchive::Flag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag for shader archives. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a79be77a00c94ac03b3bff845763676cda41c30e5365f382112f6eda08841ff9e8"></a>Flag_Souce&#160;</td><td class="fielddoc"><p>Has a shader source. </p>
</td></tr>
<tr><td class="fieldname"><a id="a79be77a00c94ac03b3bff845763676cdaafef1a2cdeadc253ab779a56102a2646"></a>Flag_Binary&#160;</td><td class="fielddoc"><p>Has a shader binary. </p>
</td></tr>
<tr><td class="fieldname"><a id="a79be77a00c94ac03b3bff845763676cda7c86e79b74a875cf7ca3e4fd95b42cfd"></a>Flag_BinaryAvailable&#160;</td><td class="fielddoc"><p>The binary is available. </p>
</td></tr>
<tr><td class="fieldname"><a id="a79be77a00c94ac03b3bff845763676cdaacf8dbefaf0856f221816807c8c11765"></a>Flag_ForceVariation&#160;</td><td class="fielddoc"><p>At conversion, options are forced into variations. </p>
</td></tr>
<tr><td class="fieldname"><a id="a79be77a00c94ac03b3bff845763676cda7734e30e543bd76ee27adfa677f52ff1"></a>Flag_ShaderOfflineDL&#160;</td><td class="fielddoc"><p>This function is deprecated. </p>
<p>Please check the details for usage conditions and substitute functions. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000065">Deprecated:</a></b></dt><dd>To be deprecated. The shader is converted to offline DL. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a79be77a00c94ac03b3bff845763676cdad0c78082fd44c35bc89971b53596974e"></a>Flag_Ir&#160;</td><td class="fielddoc"><p>The shader has an intermediate language source. </p>
</td></tr>
<tr><td class="fieldname"><a id="a79be77a00c94ac03b3bff845763676cda31847029d6cb74f2832034281816d792"></a>Flag_Initialized&#160;</td><td class="fielddoc"><p>The shader archive is initialized. </p>
</td></tr>
</table>

</div>
</div>
<a id="a619e026373fb634bcc17fbdd25c63d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619e026373fb634bcc17fbdd25c63d1e">&#9670;&nbsp;</a></span>Alignment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a619e026373fb634bcc17fbdd25c63d1e">nn::g3d::ResShaderArchive::Alignment</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The required alignment size. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a619e026373fb634bcc17fbdd25c63d1ea3671c86e391e20455a2a752b21e47640"></a>Alignment_WorkMemory&#160;</td><td class="fielddoc"><p>The alignment size required for the work memory passed to the <code><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a0bd2ecf27e62dd885eb25a1c57e29c9d" title="Sets up the shader archive.">Setup()</a></code> function. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0bd2ecf27e62dd885eb25a1c57e29c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd2ecf27e62dd885eb25a1c57e29c9d">&#9670;&nbsp;</a></span>Setup() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::ResShaderArchive::Setup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *&#160;</td>
          <td class="paramname"><em>pDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up the shader archive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDevice</td><td>Pointer to the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDevice</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Shader initialization is not performed. Shader initialization will be delayed until the <code><a class="el" href="classnn_1_1g3d_1_1_res_shader_program.html#aafe83b170f69457eaa1d396eb6885288" title="Delays initialization until the first time the function is called after the Setup() function.">nn::g3d::ResShaderProgram::Update()</a></code> function has been called. <code><a class="el" href="classnn_1_1g3d_1_1_res_shader_program.html#aafe83b170f69457eaa1d396eb6885288" title="Delays initialization until the first time the function is called after the Setup() function.">nn::g3d::ResShaderProgram::Update()</a></code> is called from the <code><a class="el" href="classnn_1_1g3d_1_1_shader_selector.html#a79873e8ffad5ccd81bc0373f11bf7a44" title="Updates the shader variation.">nn::g3d::ShaderSelector::UpdateVariation()</a></code> function.</p>
<p>Use this if the same shading model is not being handled by multiple threads, or if the same shading model is being handled by multiple threads but mutual exclusion is implemented manually by the user. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_outline_8cpp-example.html#a50">G3dDemo/Outline.cpp</a>, and <a class="el" href="_g3d_demo_2_town_8cpp-example.html#a112">G3dDemo/Town.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af8650d22892838931d1646cf782a195f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8650d22892838931d1646cf782a195f">&#9670;&nbsp;</a></span>Setup() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::ResShaderArchive::Setup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *&#160;</td>
          <td class="paramname"><em>pDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pWorkMemory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>workMemorySize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up the shader archive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDevice</td><td>Pointer to the device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pWorkMemory</td><td>Pointer to the memory used for mutual exclusion. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">workMemorySize</td><td>The size of memory being used for mutual exclusion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDevice</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 If this function was used for initialization, mutual exclusion will be used for shader initialization. Use this function for initialization if the same shading model will be handled by multiple threads.</p>
<p>Shader initialization is not performed. Shader initialization will be delayed until the <code><a class="el" href="classnn_1_1g3d_1_1_res_shader_program.html#aafe83b170f69457eaa1d396eb6885288" title="Delays initialization until the first time the function is called after the Setup() function.">nn::g3d::ResShaderProgram::Update()</a></code> function has been called. <code><a class="el" href="classnn_1_1g3d_1_1_res_shader_program.html#aafe83b170f69457eaa1d396eb6885288" title="Delays initialization until the first time the function is called after the Setup() function.">nn::g3d::ResShaderProgram::Update()</a></code> is called from the <code><a class="el" href="classnn_1_1g3d_1_1_shader_selector.html#a79873e8ffad5ccd81bc0373f11bf7a44" title="Updates the shader variation.">nn::g3d::ShaderSelector::UpdateVariation()</a></code> function. </p>

</div>
</div>
<a id="ab1b8ed10d9ab49a951139f4ff6b3679d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1b8ed10d9ab49a951139f4ff6b3679d">&#9670;&nbsp;</a></span>Setup() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::ResShaderArchive::Setup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *&#160;</td>
          <td class="paramname"><em>pDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1gfx.html#ad620d8208dd309eb7c4dd5973a6aeee5">nn::gfx::MemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pMemoryPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>memoryPoolOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>memoryPoolSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up the shader archive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDevice</td><td>Pointer to the device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pMemoryPool</td><td>Pointer to the memory pool where <code><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html" title="Shader archive resource.">ResShaderArchive</a></code> is located. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memoryPoolOffset</td><td>Offset in the memory pool where <code>ResShadingArchive</code> is located. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memoryPoolSize</td><td>The size of the memory pool where <code>ResShadingArchive</code> is located.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDevice</em></code> is initialized.</li>
<li>Resources are loaded to <code><em>pMemoryPool</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The user loads <code>ResShadingArchive</code> to the locally prepared memory pool, which is then used by this function to set up <code>ResShadingArchive</code>. This function cannot be used to create memory internally. If you are placing <code><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html" title="Shader archive resource.">ResShaderArchive</a></code> in a memory pool, place it so the start of the shader archive file matches the file alignment. To get the alignment of the file, get the header using <code>GetFileHeader()</code> and then call <code><a class="el" href="structnn_1_1util_1_1_binary_file_header.html#a5d08b613e5c8bb9fe95b3bcb53edb62b" title="Gets the alignment.">nn::util::BinaryFileHeader::GetAlignment()</a></code>. CPU access takes place in <code><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html" title="Shader archive resource.">ResShaderArchive</a></code>, so we recommend setting the memory pool properties to <code>CpuCached</code> | <code>GpuCached</code> | <code>ShaderCode</code>. Performance will be lower if you set <code>CpuUncached</code>. You cannot use <code>CpuInvisible</code>.</p>
<p>Shader initialization is not performed. Shader initialization will be delayed until the <code><a class="el" href="classnn_1_1g3d_1_1_res_shader_program.html#aafe83b170f69457eaa1d396eb6885288" title="Delays initialization until the first time the function is called after the Setup() function.">nn::g3d::ResShaderProgram::Update()</a></code> function has been called. <code><a class="el" href="classnn_1_1g3d_1_1_res_shader_program.html#aafe83b170f69457eaa1d396eb6885288" title="Delays initialization until the first time the function is called after the Setup() function.">nn::g3d::ResShaderProgram::Update()</a></code> is called from the <code><a class="el" href="classnn_1_1g3d_1_1_shader_selector.html#a79873e8ffad5ccd81bc0373f11bf7a44" title="Updates the shader variation.">nn::g3d::ShaderSelector::UpdateVariation()</a></code> function.</p>
<p>Use this if the same shading model is not being handled by multiple threads, or if the same shading model is being handled by multiple threads but mutual exclusion is implemented manually by the user. </p>

</div>
</div>
<a id="af076f48c0424b2873a9adc01b2b6bab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af076f48c0424b2873a9adc01b2b6bab7">&#9670;&nbsp;</a></span>Setup() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::ResShaderArchive::Setup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *&#160;</td>
          <td class="paramname"><em>pDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1gfx.html#ad620d8208dd309eb7c4dd5973a6aeee5">nn::gfx::MemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pMemoryPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>memoryPoolOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>memoryPoolSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pWorkMemory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>workMemorySize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up the shader archive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDevice</td><td>Pointer to the device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pMemoryPool</td><td>Pointer to the memory pool where <code><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html" title="Shader archive resource.">ResShaderArchive</a></code> is located. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memoryPoolOffset</td><td>Offset in the memory pool where <code>ResShadingArchive</code> is located. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memoryPoolSize</td><td>The size of the memory pool where <code>ResShadingArchive</code> is located. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pWorkMemory</td><td>Pointer to the memory used for mutual exclusion. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">workMemorySize</td><td>The size of memory being used for mutual exclusion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDevice</em></code> is initialized.</li>
<li>Resources are loaded to <code><em>pMemoryPool</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The user loads <code>ResShadingArchive</code> to the locally prepared memory pool, which is then used by this function to set up <code>ResShadingArchive</code>. This function cannot be used to create memory internally. If you are placing <code><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html" title="Shader archive resource.">ResShaderArchive</a></code> in a memory pool, place it so the start of the shader archive file matches the file alignment. To get the alignment of the file, get the header using <code>GetFileHeader()</code> and then call <code><a class="el" href="structnn_1_1util_1_1_binary_file_header.html#a5d08b613e5c8bb9fe95b3bcb53edb62b" title="Gets the alignment.">nn::util::BinaryFileHeader::GetAlignment()</a></code>. CPU access takes place in <code><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html" title="Shader archive resource.">ResShaderArchive</a></code>, so we recommend setting the memory pool properties to <code>CpuCached</code> | <code>GpuCached</code> | <code>ShaderCode</code>. Performance will be lower if you set <code>CpuUncached</code>. You cannot use <code>CpuInvisible</code>.</p>
<p>If this function was used for initialization, mutual exclusion will be used for shader initialization. Use this function for initialization if the same shading model will be handled by multiple threads. <code><em>pWorkMemory</em></code> requires an alignment of <code>Alignment_WorkMemory</code>. You can get the size of the required working memory using <code><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#af38509b9fe1f0d8ec457e89c0932b096" title="Gets the size of the work memory for mutual exclusion to pass to the Setup() function.">nn::g3d::ResShaderArchive::GetWorkMemorySize()</a></code>.</p>
<p>Shader initialization is not performed. Shader initialization will be delayed until the <code><a class="el" href="classnn_1_1g3d_1_1_res_shader_program.html#aafe83b170f69457eaa1d396eb6885288" title="Delays initialization until the first time the function is called after the Setup() function.">nn::g3d::ResShaderProgram::Update()</a></code> function has been called. <code><a class="el" href="classnn_1_1g3d_1_1_res_shader_program.html#aafe83b170f69457eaa1d396eb6885288" title="Delays initialization until the first time the function is called after the Setup() function.">nn::g3d::ResShaderProgram::Update()</a></code> is called from the <code><a class="el" href="classnn_1_1g3d_1_1_shader_selector.html#a79873e8ffad5ccd81bc0373f11bf7a44" title="Updates the shader variation.">nn::g3d::ShaderSelector::UpdateVariation()</a></code> function. </p>

</div>
</div>
<a id="ad03541d45efb24c2f6991b780ec42add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03541d45efb24c2f6991b780ec42add">&#9670;&nbsp;</a></span>Cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::ResShaderArchive::Cleanup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *&#160;</td>
          <td class="paramname"><em>pDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cleans up the shader archive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDevice</td><td>Pointer to the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDevice</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_simple_8cpp-example.html#a204">G3dDemo/Simple.cpp</a>, and <a class="el" href="_g3d_demo_2_town_8cpp-example.html#a114">G3dDemo/Town.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a5ed5eaebeae9492aeaa64fabaf6e743c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed5eaebeae9492aeaa64fabaf6e743c">&#9670;&nbsp;</a></span>GetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* nn::g3d::ResShaderArchive::GetName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the name of the shader archive. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the shader archive name. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_shape_animation_8cpp-example.html#a205">G3dDemo/ShapeAnimation.cpp</a>, and <a class="el" href="_g3d_demo_2_town_8cpp-example.html#a102">G3dDemo/Town.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af8198388e75acb485b1c829fa794ca82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8198388e75acb485b1c829fa794ca82">&#9670;&nbsp;</a></span>GetPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* nn::g3d::ResShaderArchive::GetPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the path name. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the path name. </dd></dl>

</div>
</div>
<a id="a3cf88d0a508d2c96d9847400999b7f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf88d0a508d2c96d9847400999b7f2f">&#9670;&nbsp;</a></span>SetUserPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::ResShaderArchive::SetUserPtr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pUserPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a user pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUserPtr</td><td>A pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a653a9b76579a3dc72734a59d81d11dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a653a9b76579a3dc72734a59d81d11dd7">&#9670;&nbsp;</a></span>GetUserPtr() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::g3d::ResShaderArchive::GetUserPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the user pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer set by the <code><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a3cf88d0a508d2c96d9847400999b7f2f" title="Sets a user pointer.">SetUserPtr()</a></code> function. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_town_8cpp-example.html#a307">G3dDemo/Town.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a81f94d2f92a631e840078acafd3573fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81f94d2f92a631e840078acafd3573fe">&#9670;&nbsp;</a></span>GetUserPtr() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* nn::g3d::ResShaderArchive::GetUserPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the user pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer set by the <code><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a3cf88d0a508d2c96d9847400999b7f2f" title="Sets a user pointer.">SetUserPtr()</a></code> function. </dd></dl>

</div>
</div>
<a id="a80c2a25e094aeab40405fd5050940e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c2a25e094aeab40405fd5050940e4a">&#9670;&nbsp;</a></span>GetUserPtr() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* nn::g3d::ResShaderArchive::GetUserPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the user pointer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type when getting a pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer set by the <code><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a3cf88d0a508d2c96d9847400999b7f2f" title="Sets a user pointer.">SetUserPtr()</a></code> function. </dd></dl>

</div>
</div>
<a id="a7e465c681eecc8017ec29a2f384d85b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e465c681eecc8017ec29a2f384d85b3">&#9670;&nbsp;</a></span>GetUserPtr() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* nn::g3d::ResShaderArchive::GetUserPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the user pointer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type when getting a pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer set by the <code><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a3cf88d0a508d2c96d9847400999b7f2f" title="Sets a user pointer.">SetUserPtr()</a></code> function. </dd></dl>

</div>
</div>
<a id="af477eb845836d498ddbb78d589b69cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af477eb845836d498ddbb78d589b69cd9">&#9670;&nbsp;</a></span>HasSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::ResShaderArchive::HasSource </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the object has a source. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the object has a source, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ae3e10718cbef521e1328867b0db15aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e10718cbef521e1328867b0db15aba">&#9670;&nbsp;</a></span>HasBinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::ResShaderArchive::HasBinary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the object has a binary. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the object has a binary, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a05c4ad43177695eadd295637bf39b58f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c4ad43177695eadd295637bf39b58f">&#9670;&nbsp;</a></span>IsBinaryAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::ResShaderArchive::IsBinaryAvailable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the binary is available. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the binary is available, or <code>false</code> otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The <code><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a0bd2ecf27e62dd885eb25a1c57e29c9d" title="Sets up the shader archive.">Setup()</a></code> function must have been called. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a3330e5fa3ffd57ec487ceffe02a19dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3330e5fa3ffd57ec487ceffe02a19dd1">&#9670;&nbsp;</a></span>HasIr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::ResShaderArchive::HasIr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the object has an intermediate language source. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the object has an intermediate language source, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="af38509b9fe1f0d8ec457e89c0932b096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38509b9fe1f0d8ec457e89c0932b096">&#9670;&nbsp;</a></span>GetWorkMemorySize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::g3d::ResShaderArchive::GetWorkMemorySize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of the work memory for mutual exclusion to pass to the <code><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a0bd2ecf27e62dd885eb25a1c57e29c9d" title="Sets up the shader archive.">Setup()</a></code> function. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the size of work memory. </dd></dl>

</div>
</div>
<a id="a60b1dca82cbf7f8f117ac9501042ee53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b1dca82cbf7f8f117ac9501042ee53">&#9670;&nbsp;</a></span>GetWorkMemoryPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::g3d::ResShaderArchive::GetWorkMemoryPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the pointer to the work memory for mutual exclusion set in the <code><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a0bd2ecf27e62dd885eb25a1c57e29c9d" title="Sets up the shader archive.">Setup()</a></code> function. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer to the work memory for mutual exclusion set in the <code><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a0bd2ecf27e62dd885eb25a1c57e29c9d" title="Sets up the shader archive.">Setup()</a></code> function.</dd></dl>
<p> <b>Details</b> <br  />
 Returns <code>NULL</code> before the call to the <code><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#a0bd2ecf27e62dd885eb25a1c57e29c9d" title="Sets up the shader archive.">Setup()</a></code> function or after the call to the <code><a class="el" href="classnn_1_1g3d_1_1_res_shader_archive.html#ad03541d45efb24c2f6991b780ec42add" title="Cleans up the shader archive.">Cleanup()</a></code> function. </p>

</div>
</div>
<a id="a73d106366c0cd1093a88e1f2f557fdc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d106366c0cd1093a88e1f2f557fdc1">&#9670;&nbsp;</a></span>GetShadingModelCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ResShaderArchive::GetShadingModelCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of shading models. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of shading models. </dd></dl>

</div>
</div>
<a id="a17c81d3fe346cbcc531ad38138b7117b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c81d3fe346cbcc531ad38138b7117b">&#9670;&nbsp;</a></span>FindShadingModel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1g3d_1_1_res_shading_model.html">ResShadingModel</a>* nn::g3d::ResShaderArchive::FindShadingModel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the shading model with the specified name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>Name of the shading model.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to <code><a class="el" href="classnn_1_1g3d_1_1_res_shading_model.html" title="Shading model resource.">ResShadingModel</a></code>.</dd></dl>
<p> <b>Details</b> <br  />
 Returns <code>NULL</code> if there is no shading model with the specified name.</p>
<p>Looking up indices is faster than looking up names. We recommend registering the index after you get it, and normally using index lookup. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_edit_8cpp-example.html#a16">G3dDemo/Edit.cpp</a>, <a class="el" href="_g3d_demo_2_nns_g3d_simple_8cpp-example.html#a57">G3dDemo/NnsG3dSimple.cpp</a>, <a class="el" href="_g3d_demo_2_outline_8cpp-example.html#a58">G3dDemo/Outline.cpp</a>, <a class="el" href="_g3d_demo_2_parallel_8cpp-example.html#a81">G3dDemo/Parallel.cpp</a>, <a class="el" href="_g3d_demo_2_shape_animation_8cpp-example.html#a153">G3dDemo/ShapeAnimation.cpp</a>, <a class="el" href="_g3d_demo_2_simple_8cpp-example.html#a42">G3dDemo/Simple.cpp</a>, <a class="el" href="_g3d_demo_2_skeletal_animation_8cpp-example.html#a123">G3dDemo/SkeletalAnimation.cpp</a>, <a class="el" href="_g3d_demo_2_tessellation_8cpp-example.html#a128">G3dDemo/Tessellation.cpp</a>, and <a class="el" href="_g3d_demo_2_town_8cpp-example.html#a103">G3dDemo/Town.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab67911db1972ec39ef0eb4af2093a7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67911db1972ec39ef0eb4af2093a7a2">&#9670;&nbsp;</a></span>FindShadingModel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnn_1_1g3d_1_1_res_shading_model.html">ResShadingModel</a>* nn::g3d::ResShaderArchive::FindShadingModel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the shading model with the specified name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>Name of the shading model.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to <code><a class="el" href="classnn_1_1g3d_1_1_res_shading_model.html" title="Shading model resource.">ResShadingModel</a></code>.</dd></dl>
<p> <b>Details</b> <br  />
 Returns <code>NULL</code> if there is no shading model with the specified name.</p>
<p>Looking up indices is faster than looking up names. We recommend registering the index after you get it, and normally using index lookup. </p>

</div>
</div>
<a id="a6df7d310d5e807965be4f4485e32a837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df7d310d5e807965be4f4485e32a837">&#9670;&nbsp;</a></span>FindShadingModelIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ResShaderArchive::FindShadingModelIndex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the index of the shading model with the specified name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>Name of the shading model.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the index of the shading model.</dd></dl>
<p> <b>Details</b> <br  />
 Returns <code><a class="el" href="classnn_1_1util_1_1_res_dic.html#a825d9c73f03e6d02e9f8d0050b0e11a6" title="Specifies an invalid index.">nn::util::ResDic::Npos</a></code> if there is no shading model with the specified name. </p>

</div>
</div>
<a id="a462ebd8e0dedc4924ee866abd12cd3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462ebd8e0dedc4924ee866abd12cd3f5">&#9670;&nbsp;</a></span>GetShadingModelName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* nn::g3d::ResShaderArchive::GetShadingModelName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elemIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the name from the index of the shading model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elemIndex</td><td>Index of the shading model.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the shading model name.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The index is within the range of the number of shading models.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Causes an assertion failure when the specified index is outside the range. </p>

</div>
</div>
<a id="a6f8f897e23cfc7659603a6c8083af122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8f897e23cfc7659603a6c8083af122">&#9670;&nbsp;</a></span>GetShadingModel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1g3d_1_1_res_shading_model.html">ResShadingModel</a>* nn::g3d::ResShaderArchive::GetShadingModel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elemIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the shading model by looking up the index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elemIndex</td><td>Index of the shading model.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to <code><a class="el" href="classnn_1_1g3d_1_1_res_shading_model.html" title="Shading model resource.">ResShadingModel</a></code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The index is within the range of the number of shading models.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Causes an assertion failure when the specified index is outside the range. </p>

</div>
</div>
<a id="af3829b22ac691593177ec04358559574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3829b22ac691593177ec04358559574">&#9670;&nbsp;</a></span>GetShadingModel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnn_1_1g3d_1_1_res_shading_model.html">ResShadingModel</a>* nn::g3d::ResShaderArchive::GetShadingModel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elemIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the shading model by looking up the index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elemIndex</td><td>Index of the shading model.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to <code><a class="el" href="classnn_1_1g3d_1_1_res_shading_model.html" title="Shading model resource.">ResShadingModel</a></code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The index is within the range of the number of shading models.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Causes an assertion failure when the specified index is outside the range. </p>

</div>
</div>
<a id="a10e3bdc089c3a0ee9b009f35fbeb4f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10e3bdc089c3a0ee9b009f35fbeb4f38">&#9670;&nbsp;</a></span>ToData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1util_1_1_accessor_base.html#a6f06add6587efa6c07ca0bb8e8d0913c">value_type</a>&amp; <a class="el" href="classnn_1_1util_1_1_accessor_base.html">nn::util::AccessorBase</a>&lt; <a class="el" href="structnn_1_1g3d_1_1_res_shader_archive_data.html">ResShaderArchiveData</a>  &gt;::ToData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a reference to an instance of the data structure. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a reference to an instance of the data structure. </dd></dl>

</div>
</div>
<a id="ae1945852eed72008611418a36346932c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1945852eed72008611418a36346932c">&#9670;&nbsp;</a></span>ToData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnn_1_1util_1_1_accessor_base.html#a6f06add6587efa6c07ca0bb8e8d0913c">value_type</a>&amp; <a class="el" href="classnn_1_1util_1_1_accessor_base.html">nn::util::AccessorBase</a>&lt; <a class="el" href="structnn_1_1g3d_1_1_res_shader_archive_data.html">ResShaderArchiveData</a>  &gt;::ToData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a reference to an instance of the data structure. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a reference to an instance of the data structure. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
