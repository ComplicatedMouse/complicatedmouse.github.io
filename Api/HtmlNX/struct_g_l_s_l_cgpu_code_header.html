<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GLSLCgpuCodeHeader Struct Reference | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="struct_g_l_s_l_cgpu_code_header-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GLSLCgpuCodeHeader Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>GPU code section header containing GPU code for an individual shader stage.  
 <a href="struct_g_l_s_l_cgpu_code_header.html#details">More...</a></p>

<p><code>#include &lt;nvnTool/nvnTool_GlslcInterface.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7f3316d21de741d75c172f1bb7635255"><td class="memItemLeft" align="right" valign="top"><a id="a7f3316d21de741d75c172f1bb7635255"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_l_s_l_cgpu_code_header.html#a7f3316d21de741d75c172f1bb7635255">asmDumpSectionIdx</a></td></tr>
<tr class="memdesc:a7f3316d21de741d75c172f1bb7635255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Section index for the corresponding assembly dump (if requested). <br /></td></tr>
<tr class="separator:a7f3316d21de741d75c172f1bb7635255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b606fedf8582a1a47162d210e8a1448"><td class="memItemLeft" align="right" valign="top"><a id="a3b606fedf8582a1a47162d210e8a1448"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_l_s_l_cgpu_code_header.html#a3b606fedf8582a1a47162d210e8a1448">controlOffset</a></td></tr>
<tr class="memdesc:a3b606fedf8582a1a47162d210e8a1448"><td class="mdescLeft">&#160;</td><td class="mdescRight">The offset within the data of the control section, in bytes. <br /></td></tr>
<tr class="separator:a3b606fedf8582a1a47162d210e8a1448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5295c90f2dc5eb969fb14660f31712"><td class="memItemLeft" align="right" valign="top"><a id="aff5295c90f2dc5eb969fb14660f31712"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_l_s_l_cgpu_code_header.html#aff5295c90f2dc5eb969fb14660f31712">controlSize</a></td></tr>
<tr class="memdesc:aff5295c90f2dc5eb969fb14660f31712"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the control portion of the stream in bytes. <br /></td></tr>
<tr class="separator:aff5295c90f2dc5eb969fb14660f31712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafdececf784595d922fe1b95b06db976"><td class="memItemLeft" align="right" valign="top"><a id="aafdececf784595d922fe1b95b06db976"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_l_s_l_cgpu_code_header.html#aafdececf784595d922fe1b95b06db976">dataOffset</a></td></tr>
<tr class="memdesc:aafdececf784595d922fe1b95b06db976"><td class="mdescLeft">&#160;</td><td class="mdescRight">The offset within the data of the GPU code data section in bytes. <br /></td></tr>
<tr class="separator:aafdececf784595d922fe1b95b06db976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2617848640a161d41ed59f1a7c0ccb35"><td class="memItemLeft" align="right" valign="top"><a id="a2617848640a161d41ed59f1a7c0ccb35"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_l_s_l_cgpu_code_header.html#a2617848640a161d41ed59f1a7c0ccb35">dataSize</a></td></tr>
<tr class="memdesc:a2617848640a161d41ed59f1a7c0ccb35"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the data portion of the stream in bytes. <br /></td></tr>
<tr class="separator:a2617848640a161d41ed59f1a7c0ccb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210237850b30911ca52acf10d628bc0e"><td class="memItemLeft" align="right" valign="top"><a id="a210237850b30911ca52acf10d628bc0e"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_l_s_l_cgpu_code_header.html#a210237850b30911ca52acf10d628bc0e">perfStatsSectionNdx</a></td></tr>
<tr class="memdesc:a210237850b30911ca52acf10d628bc0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Section index for the corresponding perf stats (if requested). <br /></td></tr>
<tr class="separator:a210237850b30911ca52acf10d628bc0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804117e2ce22cbcc85316d5d2e8b1c84"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_l_s_l_cgpu_code_header.html#a804117e2ce22cbcc85316d5d2e8b1c84">scratchMemBytesPerWarp</a></td></tr>
<tr class="memdesc:a804117e2ce22cbcc85316d5d2e8b1c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">The amount of local memory (in bytes per warp) required for this program.  <a href="struct_g_l_s_l_cgpu_code_header.html#a804117e2ce22cbcc85316d5d2e8b1c84">More...</a><br /></td></tr>
<tr class="separator:a804117e2ce22cbcc85316d5d2e8b1c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b1eef84fa9f0debec1874f8b570e62"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_l_s_l_cgpu_code_header.html#ac8b1eef84fa9f0debec1874f8b570e62">scratchMemBytesRecommended</a></td></tr>
<tr class="memdesc:ac8b1eef84fa9f0debec1874f8b570e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total amount of local memory recommended for this program on a NX device.  <a href="struct_g_l_s_l_cgpu_code_header.html#ac8b1eef84fa9f0debec1874f8b570e62">More...</a><br /></td></tr>
<tr class="separator:ac8b1eef84fa9f0debec1874f8b570e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e6be676a326a7281e18ad3a4607ced"><td class="memItemLeft" align="right" valign="top"><a id="ab1e6be676a326a7281e18ad3a4607ced"></a>
<a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_l_s_l_cgpu_code_header.html#ab1e6be676a326a7281e18ad3a4607ced">stage</a></td></tr>
<tr class="memdesc:ab1e6be676a326a7281e18ad3a4607ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">The shader stage this corresponds to. <br /></td></tr>
<tr class="separator:ab1e6be676a326a7281e18ad3a4607ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3691577caae8cb572efc2f9db9dc422c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_l_s_l_cgpu_code_header.html#a3691577caae8cb572efc2f9db9dc422c">subroutineLinkageMapOffset</a></td></tr>
<tr class="memdesc:a3691577caae8cb572efc2f9db9dc422c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subroutine linkage map offset (in bytes) into the data section.  <a href="struct_g_l_s_l_cgpu_code_header.html#a3691577caae8cb572efc2f9db9dc422c">More...</a><br /></td></tr>
<tr class="separator:a3691577caae8cb572efc2f9db9dc422c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f8174e850ec8ff2ffbb678032f6ec7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_l_s_l_cgpu_code_header.html#a45f8174e850ec8ff2ffbb678032f6ec7">subroutineLinkageMapSize</a></td></tr>
<tr class="memdesc:a45f8174e850ec8ff2ffbb678032f6ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subroutine linkage map size (in bytes).  <a href="struct_g_l_s_l_cgpu_code_header.html#a45f8174e850ec8ff2ffbb678032f6ec7">More...</a><br /></td></tr>
<tr class="separator:a45f8174e850ec8ff2ffbb678032f6ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>GPU code section header containing GPU code for an individual shader stage. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_graphics_shader_8cpp-example.html#_a16">NvnSimple/NvnSimpleSharedLib/GraphicsShader.cpp</a>, <a class="el" href="_nvn_tutorial_2_asset_file_loading_helper_8cpp-example.html#_a57">NvnTutorial/AssetFileLoadingHelper.cpp</a>, and <a class="el" href="_nvn_tutorial02_offline_build_tools_2_intermediate_file_manager_8cpp-example.html#_a26">NvnTutorial02OfflineBuildTools/IntermediateFileManager.cpp</a>.</dd>
</dl>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a id="a804117e2ce22cbcc85316d5d2e8b1c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a804117e2ce22cbcc85316d5d2e8b1c84">&#9670;&nbsp;</a></span>scratchMemBytesPerWarp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GLSLCgpuCodeHeader::scratchMemBytesPerWarp</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The amount of local memory (in bytes per warp) required for this program. </p>
<p>This is used to compute the total amount of scratch memory needed for a program depending on the platform. See the NVN programming guide's section on shader scratch memory to see how this value is used by the application. </p>

</div>
</div>
<a id="ac8b1eef84fa9f0debec1874f8b570e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b1eef84fa9f0debec1874f8b570e62">&#9670;&nbsp;</a></span>scratchMemBytesRecommended</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GLSLCgpuCodeHeader::scratchMemBytesRecommended</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The total amount of local memory recommended for this program on a NX device. </p>
<dl class="section note"><dt>Note</dt><dd>The Windows reference NVN driver manages its own internal scratch memory allocations for the target desktop GPU and will ignore the scratch memory provided by applications.</dd></dl>
<p>GLSLC calculates this value using the formula documented in the NVN programming guide for computing scratch memory requirements from queried device properties and the scratchMemBytesPerWarp variable, where the device property values used in the formula are the same device property values that NVN would return if running on a NX device. The value is only included in this output for convenience. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_graphics_shader_8cpp-example.html#a24">NvnSimple/NvnSimpleSharedLib/GraphicsShader.cpp</a>, <a class="el" href="_nvn_tutorial_2_asset_file_loading_helper_8cpp-example.html#a65">NvnTutorial/AssetFileLoadingHelper.cpp</a>, and <a class="el" href="_nvn_tutorial02_offline_build_tools_2_intermediate_file_manager_8cpp-example.html#a28">NvnTutorial02OfflineBuildTools/IntermediateFileManager.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3691577caae8cb572efc2f9db9dc422c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3691577caae8cb572efc2f9db9dc422c">&#9670;&nbsp;</a></span>subroutineLinkageMapOffset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GLSLCgpuCodeHeader::subroutineLinkageMapOffset</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subroutine linkage map offset (in bytes) into the data section. </p>
<p>The subroutine linkage map is an opaque structure that is provided to the NVN driver by the application via a call to nvnProgramSetSubroutineLinkage. The driver uses the information stored in this map to determine which entries in an internal jump table stored in constant memory need to be patched, and also which values they should be patched with by mapping from subroutine uniform binding inputs in a nvnCommandBufferSetProgramSubroutines call to the actual code locations for the subroutines in the program. </p>

</div>
</div>
<a id="a45f8174e850ec8ff2ffbb678032f6ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f8174e850ec8ff2ffbb678032f6ec7">&#9670;&nbsp;</a></span>subroutineLinkageMapSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GLSLCgpuCodeHeader::subroutineLinkageMapSize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subroutine linkage map size (in bytes). </p>
<p>This is 0 if there are no active subroutines used by the program. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
