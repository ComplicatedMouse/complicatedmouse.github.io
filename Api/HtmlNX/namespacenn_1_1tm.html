<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nn::tm Namespace Reference | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenn.html">nn</a></li><li class="navelem"><a class="el" href="namespacenn_1_1tm.html">tm</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">nn::tm Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Target Manager API (TMAPI) public interfaces.  
<a href="namespacenn_1_1tm.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1tm_1_1_discovery_handle.html">DiscoveryHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unique handle for interacting with discovered targets.  <a href="structnn_1_1tm_1_1_discovery_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1tm_1_1_error_text.html">ErrorText</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The null-terminated <a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034" title="Target Manager API error codes.">nn::tm::Error</a> text buffer.  <a href="structnn_1_1tm_1_1_error_text.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1tm_1_1_htcs_address.html">HtcsAddress</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The null-terminated ip address and port number for HTCS.  <a href="structnn_1_1tm_1_1_htcs_address.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1tm_1_1_htcs_peer_name.html">HtcsPeerName</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The null-terminated peer name of the HTCS address.  <a href="structnn_1_1tm_1_1_htcs_peer_name.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1tm_1_1_htcs_port_name.html">HtcsPortName</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The null-terminated port name of the HTCS address.  <a href="structnn_1_1tm_1_1_htcs_port_name.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1tm_1_1_target_agent_version.html">TargetAgentVersion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED.  <a href="structnn_1_1tm_1_1_target_agent_version.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1tm_1_1_target_firmware_version.html">TargetFirmwareVersion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The struct for containing the target firmware version.  <a href="structnn_1_1tm_1_1_target_firmware_version.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unique handle for interacting with targets.  <a href="structnn_1_1tm_1_1_target_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1tm_1_1_target_ip_address.html">TargetIpAddress</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A null-terminated target ip address.  <a href="structnn_1_1tm_1_1_target_ip_address.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1tm_1_1_target_mac_address.html">TargetMacAddress</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The null-terminated target mac address.  <a href="structnn_1_1tm_1_1_target_mac_address.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1tm_1_1_target_name.html">TargetName</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The null-terminated target name.  <a href="structnn_1_1tm_1_1_target_name.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1tm_1_1_target_program_name.html">TargetProgramName</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The null-terminated target serial number.  <a href="structnn_1_1tm_1_1_target_program_name.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1tm_1_1_target_serial_number.html">TargetSerialNumber</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The null-terminated target serial number.  <a href="structnn_1_1tm_1_1_target_serial_number.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1tm_1_1_target_user.html">TargetUser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The null-terminated user connected to the target.  <a href="structnn_1_1tm_1_1_target_user.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1tm_1_1_target_working_directory.html">TargetWorkingDirectory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The struct for containing the target working directory.  <a href="structnn_1_1tm_1_1_target_working_directory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2422234500de1643cba6348b73cf2289"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a2422234500de1643cba6348b73cf2289">DiscoveryState</a> : int32_t { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#a2422234500de1643cba6348b73cf2289aa21041c97ee0a65580f52d11ab44ae34">DiscoveryState_Uninitialized</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#a2422234500de1643cba6348b73cf2289a2d7edf80d2d7b907045ec71412fa2ef8">DiscoveryState_Started</a> = 1
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#a2422234500de1643cba6348b73cf2289aa98c202a61ce933ad457e2b01414a1b4">DiscoveryState_Complete</a> = 2
<br />
 }</td></tr>
<tr class="memdesc:a2422234500de1643cba6348b73cf2289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discovery scan states in Target Manager.  <a href="namespacenn_1_1tm.html#a2422234500de1643cba6348b73cf2289">More...</a><br /></td></tr>
<tr class="separator:a2422234500de1643cba6348b73cf2289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed75c59e3dcda10a6cf06c0048a86769"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#aed75c59e3dcda10a6cf06c0048a86769">DumpType</a> : int32_t { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#aed75c59e3dcda10a6cf06c0048a86769aebc7cf1e7bc9149cd938ec99cf7b57b2">DumpType_Quick</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#aed75c59e3dcda10a6cf06c0048a86769a85dcca74ab4839db2f3f6a1de6b2fa57">DumpType_Full</a> = 1
<br />
 }</td></tr>
<tr class="memdesc:aed75c59e3dcda10a6cf06c0048a86769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of dump file to create.  <a href="namespacenn_1_1tm.html#aed75c59e3dcda10a6cf06c0048a86769">More...</a><br /></td></tr>
<tr class="separator:aed75c59e3dcda10a6cf06c0048a86769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ab04e057ae2bf176cfe7f5b5699034"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> : int32_t { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6">Error_Ok</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ac6e2f50304c5f1ee1776ecf3caa5b617">Error_Unknown</a> = 2
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034af5144589cf266fd500ed87e44dd27265">Error_Timeout</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a26cfc3f76d5dc7338ddf6fd81fdddbbd">Error_NoConnection</a> = 4
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034abd1c903d6b60cd879414d689ed5c3a0b">Error_IncompatibleProtocol</a> = 5
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034af4d723d8e45769827fb6306e290b62aa">Error_InvalidOpcode</a> = 6
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a2b25b9a09f2add5e52b828ff707cbc99">Error_TargetBusy</a> = 7
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a6d895311a7152461b10680039ce017fd">Error_TargetUnavailable</a> = 8
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a421a6fab38ca3694fe42edc768634b6f">Error_InvalidAddress</a> = 9
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034af3a88ae0129383fabfa419cd4660c54d">Error_ExecutableNotFound</a> = 10
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a34e74783a4dddc0d02f07be98cc991f1">Error_InvalidTarget</a> = 11
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a442a2efec8e197708a65d4fadafcd981">Error_InvalidResponse</a> = 13
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ae529b6aa16fac809546b3dcc87edebf4">Error_TargetDuplicated</a> = 14
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034aa2a0c3e74cd8ee2ed200b7e05b574957">Error_InvalidParameter</a> = 15
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034af6e604a8bd361dc3a101573925c8ff27">Error_InvalidDeviceHandle</a> = 16
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ab41a31cd4a6b685068993333a64e5797">Error_InvalidController</a> = 17
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a2417492ffada4fec9860c5537294f322">Error_ExecutableNotCompatible</a> = 18
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a8d535ba9b218d52e6013d6c5e0cc4b40">Error_BufferTooSmall</a> = 19
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a60de56b739a259b0f382950554f6c354">Error_InternalError</a> = 20
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034adc08f55d06020162d442cee61b7bf4e8">Error_Cancelled</a> = 21
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034af3c5a197f285e16d3baa3d35714ba5c5">Error_ConnectVersionError</a> = 22
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a9f14d5b4edd81a9f63d525860632f75e">Error_ConnectFailed</a> = 23
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a27a641f35dfeb3a5aa3111b47e0bba73">Error_NotImplemented</a> = 24
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034aa3e0d3b30af3b8cc9b037462f02c76d9">Error_IncompatibleTmApiVersion</a> = 25
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a893cebc3895216ce4a10f27256a1691b">Error_DebuggingUnavailable</a> = 26
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a2544f223b05a02c4f8b3e0a40cf81655">Error_NotBackwardsCompatible</a> = 27
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034abb6b1b234ade06d7e083d452bdb6a002">Error_ServiceUnavailable</a> = 28
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a8ae3dd727e77c35c116e31c4e8ab0c13">Error_TargetDiscoveryAlreadyStarted</a> = 29
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a97149d21fd19e7b3edf44557c3b9eff1">Error_ConnectFailedLogServer</a> = 30
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ae6b882faf47f5f6575a3518c2eb2e4c0">Error_TargetIoSearchComplete</a> = 31
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a14d9ccbd7a376c3092b622cb05606072">Error_TargetIoInsufficientSpace</a> = 32
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a47bf9bda326d373ae9577890235cb58e">Error_TargetIoNoMemoryCard</a> = 33
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a9bfc82606044fe622e4e89e1d01073dc">Error_TargetIoPathAlreadyExists</a> = 34
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034afe6d594bd8e35c893144de7203547b0a">Error_TargetIoMemoryCardError</a> = 35
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a9f43433fed125510ae9aa5b9743a718c">Error_TargetAsleep</a> = 36
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a1a0875d2189d91d4896d73f796220055">Error_NoProgramLoaded</a> = 37
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a84a294a637d26b172a05f24d79099cc7">Error_IncompatibleTargetManager</a> = 38
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034abf2bff45a561b4cea89e81a12ba5b046">Error_TargetNotConnected</a> = 39
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ac6ea81ad9887986fac35d7decd27d970">Error_UnableToCreateCoredump</a> = 40
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034aa04eaf138217ec17fa306333e821ad44">Error_InvalidHtcsAddress</a> = 44
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a2054d2448c6651ec4209ad1534c78e6f">Error_DuplicateHtcsAddress</a> = 45
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a8e079fd20b061341675a25407272fef7">Error_HtcsAddressNotFound</a> = 46
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a56ad41d3319812727f1545e361d966f8">Error_OtherUser</a> = 47
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a75db7b8f9013d6dbeb69d0badb7b0c0e">Error_InvalidScreenshotFolderSetting</a> = 48
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a21d5e9683b8f2967c1f43329f4fa936e">Error_InvalidScreenshotFilenameSetting</a> = 49
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ae44d27ce0cc5c40ce1e9de74870df0fe">Error_HtcsEntryNotFound</a> = 50
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a7173ccac3abf473b84f2d597f680ab09">Error_HtcsEventHandleAlreadyRegistered</a> = 51
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a3c00ed74bb7744bf80c86b01ca74e928">Error_HtcsEventHandleNotFound</a> = 52
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a733efd1bda5a124c3adb423213c7cfad">Error_InvalidTargetName</a> = 53
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a33e464c95c2c7736c677a2d185974eaa">Error_ProgramEventHandleAlreadyRegistered</a> = 54
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a1611631547167cb88790009e74b331f3">Error_InvalidWorkingDirectory</a> = 55
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a02e26582bb7a856d2326f80a4e7f251d">Error_InvalidVideoFolderSetting</a> = 56
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a3e6c1f3525b2de6b56c768fb056fd53d">Error_InvalidVideoFilenameSetting</a> = 57
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a175d1c594d2fa9396a978f0f912a9f09">Error_ProgramStartFailed</a> = 101
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034aaa9e454365a6ec41bca42f1f608a303d">Error_ProgramNotLoaded</a> = 102
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034aabe00ec867f79cd851bb13d9220f0d5f">Error_ProgramInvalidArguments</a> = 103
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a7fed45c13851a71a9f632bc146400da1">Error_ProgramCreateFailed</a> = 104
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a00835e2b9464daf288ecc4e15a67cae7">Error_ProgramIsRunning</a> = 105
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a94da9a628f4517a5a6bb619bb74d8a2f">Error_ProgramNotRunning</a> = 106
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a78fface09b8ea9dc908f9bd21cf0772f">Error_ProgramNotHalted</a> = 107
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a94c6ee2d42e406419ee6bec07cb0d319">Error_ProgramAlreadyStarted</a> = 108
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a2272b92fa42311697d693be67b800711">Error_ProgramHalted</a> = 109
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a46c0d5d92b4be0744d2ccdd93aded7ec">Error_ProgramUnknownRegister</a> = 110
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a897880e6c90de71632247044b179e96b">Error_ProgramAttachFailed</a> = 111
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a2394c98c5eb1a127935ad144dc3a950b">Error_ProgramNotStarted</a> = 112
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a0f7215a105e3a727a922c28f6474c7d4">Error_ProgramDebuggingDisabled</a> = 113
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ac6d624313577be738b3f75b5a7984177">Error_ProgramPackageIncomplete</a> = 114
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034acef1b8626effaac845bd1c9210893a80">Error_ProgramBeingDebugged</a> = 139
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ac5ab471961d23e8f73abaa3003b49f27">Error_InvalidPathSpecified</a> = 140
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a24b9ebdf341f498afdb6cdc9a19bfd62">Error_RemoteVideoNotRecording</a> = 142
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a658d85f26db37b7afb05e3eee3ce5b53">Error_RemoteVideoRecording</a> = 143
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a0211bddecc2afd579c01de1adffa94ff">Error_RemoteVideoNotAvailable</a> = 144
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ac79bcf48eb3f4a4925643505c9998d17">Error_RemoteVideoIncorrectBufferSize</a> = 145
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a04308a25c2016035a98330936f3f2ae6">Error_RemoteVideoEventRegistered</a> = 146
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034abbd5e23e4e09894eaeb7fcb4c269e2e2">Error_RemoteVideoEventNotRegistered</a> = 147
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a94d279d8de5aa27a57444e6ce1010623">Error_RemoteVideoNotInitialized</a> = 148
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a208ea47352e5f3c1dc9ab9a5231c6f8f">Error_TargetLogNotAvailable</a> = 149
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034af3e248e82c2ede8e0f93a9443b7de01d">Error_TargetLogFileDoesNotExists</a> = 150
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a2676f8205c60bd45bbd2cd02180f227f">Error_TargetLogFileInProgress</a> = 151
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a22fadffa7d6d16020b5c3949daa33258">Error_TargetLogFilePathInvalid</a> = 152
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a933b5d02728643753a352ec2119552c5">Error_ProgramEventHandleNotFound</a> = 153
<br />
 }</td></tr>
<tr class="memdesc:af7ab04e057ae2bf176cfe7f5b5699034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Target Manager API error codes.  <a href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">More...</a><br /></td></tr>
<tr class="separator:af7ab04e057ae2bf176cfe7f5b5699034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59a34a84efb360bab2a0ffc81424f85"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#aa59a34a84efb360bab2a0ffc81424f85">TargetConnectionType</a> : int32_t { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#aa59a34a84efb360bab2a0ffc81424f85af38a71ad2fab37a8f5d71c81761951cc">TargetConnectionType_Unknown</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#aa59a34a84efb360bab2a0ffc81424f85a1e13d7f3b9474aa56a98e949cada419e">TargetConnectionType_Usb</a> = 1
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#aa59a34a84efb360bab2a0ffc81424f85aa0423cc745714405d0c664c54a01d1f3">TargetConnectionType_Ethernet</a> = 2
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#aa59a34a84efb360bab2a0ffc81424f85a5f839c5fd6e0695538d03737a5262364">TargetConnectionType_Future</a> = 3
<br />
 }</td></tr>
<tr class="memdesc:aa59a34a84efb360bab2a0ffc81424f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to specify how the target is connected to the host.  <a href="namespacenn_1_1tm.html#aa59a34a84efb360bab2a0ffc81424f85">More...</a><br /></td></tr>
<tr class="separator:aa59a34a84efb360bab2a0ffc81424f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45342c02e85eb2eacb90f4b44f9cde6d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a45342c02e85eb2eacb90f4b44f9cde6d">TargetHardwareType</a> : int32_t { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#a45342c02e85eb2eacb90f4b44f9cde6da9fc34c0dd4b9f5d7fa59587fdf89f3ee">TargetHardwareType_Unknown</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#a45342c02e85eb2eacb90f4b44f9cde6dac5fae7a3c9795fd97127279617b4b938">TargetHardwareType_Edev</a> = 1
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#a45342c02e85eb2eacb90f4b44f9cde6da0096c2f3455a7ed6d4c3b4b1c9b6404e">TargetHardwareType_Sdev</a> = 2
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#a45342c02e85eb2eacb90f4b44f9cde6dad7e9af390525b60373bf94dfbe973b80">TargetHardwareType_Sim</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#a45342c02e85eb2eacb90f4b44f9cde6da3fa88cf2292f41534bf527ed5d4c111f">TargetHardwareType_Hdev</a> = 4
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#a45342c02e85eb2eacb90f4b44f9cde6da432796d22642077e79842b76dc21059b">TargetHardwareType_Adev</a> = 5
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#a45342c02e85eb2eacb90f4b44f9cde6daf0774c8eaeb5431a13926579ba2fdfd2">TargetHardwareType_SdevD</a> = 6
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#a45342c02e85eb2eacb90f4b44f9cde6dab325131fc51886e7e5f80e1b7d459d44">TargetHardwareType_EdevD</a> = 7
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#a45342c02e85eb2eacb90f4b44f9cde6da323c154fd9a4e29ddf5637dca70a0426">TargetHardwareType_Future</a> = 8
<br />
 }</td></tr>
<tr class="memdesc:a45342c02e85eb2eacb90f4b44f9cde6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to specify the hardware type of the target.  <a href="namespacenn_1_1tm.html#a45342c02e85eb2eacb90f4b44f9cde6d">More...</a><br /></td></tr>
<tr class="separator:a45342c02e85eb2eacb90f4b44f9cde6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43e699168225cc498bb7d90bdab7c96"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#ab43e699168225cc498bb7d90bdab7c96">TargetPowerState</a> : int32_t { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#ab43e699168225cc498bb7d90bdab7c96ac4517348258d672e0b2f7587ae48bb44">TargetPowerState_Unknown</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#ab43e699168225cc498bb7d90bdab7c96afcc31aaf70b4913a59d039712a7bb794">TargetPowerState_Off</a> = 1
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#ab43e699168225cc498bb7d90bdab7c96a25b96ffa1730605db483e8ad21467f2d">TargetPowerState_On</a> = 2
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#ab43e699168225cc498bb7d90bdab7c96a0b264ab42915cf13511f0c540fa2e9c1">TargetPowerState_Asleep</a> = 3
, <br />
&#160;&#160;<b>TargetPowerState_NoBattery</b> = 4
<br />
 }</td></tr>
<tr class="memdesc:ab43e699168225cc498bb7d90bdab7c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hardware power states for targets.  <a href="namespacenn_1_1tm.html#ab43e699168225cc498bb7d90bdab7c96">More...</a><br /></td></tr>
<tr class="separator:ab43e699168225cc498bb7d90bdab7c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c4c275de00753bdcb270212e8d603c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a65c4c275de00753bdcb270212e8d603c">TargetProgramState</a> : int32_t { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#a65c4c275de00753bdcb270212e8d603ca5b1d907c9dbe701f64ae31aca109e105">TargetProgramState_NoProgram</a> = -1
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#a65c4c275de00753bdcb270212e8d603cac9e7ca3c2bb11e34400a06606b54bca0">TargetProgramState_Loading</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#a65c4c275de00753bdcb270212e8d603cab88d6a63c04d44c02954fbb0cd3348ef">TargetProgramState_Loaded</a> = 1
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#a65c4c275de00753bdcb270212e8d603ca8d090882df600b38b05f9fdd8b11203d">TargetProgramState_Running</a> = 2
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#a65c4c275de00753bdcb270212e8d603caa08957d9eac76f784fa70f0d70028c50">TargetProgramState_Halted</a> = 3
<br />
 }</td></tr>
<tr class="memdesc:a65c4c275de00753bdcb270212e8d603c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program states on a target.  <a href="namespacenn_1_1tm.html#a65c4c275de00753bdcb270212e8d603c">More...</a><br /></td></tr>
<tr class="separator:a65c4c275de00753bdcb270212e8d603c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f46629dc9dc5852868677b0f3b2448"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a05f46629dc9dc5852868677b0f3b2448">TargetStatus</a> : int32_t { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#a05f46629dc9dc5852868677b0f3b2448a7803552d039e5eff2252d5619d26db7a">TargetStatus_Unknown</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#a05f46629dc9dc5852868677b0f3b2448a8b2050ce8da0e2fce72df6e898efdecc">TargetStatus_Disconnected</a> = 1
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#a05f46629dc9dc5852868677b0f3b2448ab104ed0ad936c73abbfc43076fb4d875">TargetStatus_Disconnecting</a> = 2
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#a05f46629dc9dc5852868677b0f3b2448a5ca0076cc1bcdd4c0ca5944857137df6">TargetStatus_Connected</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#a05f46629dc9dc5852868677b0f3b2448ac4228061a1d2e70ead1fa84f06998afe">TargetStatus_Connecting</a> = 4
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#a05f46629dc9dc5852868677b0f3b2448aa6d0b4471a3ff4e6617c4dedc43d0141">TargetStatus_Asleep</a> = 5
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#a05f46629dc9dc5852868677b0f3b2448a2e54c1c39f73a3049d74442b5f726a91">TargetStatus_PoweringOn</a> = 6
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#a05f46629dc9dc5852868677b0f3b2448a481720da3cbd79f60363351932b70e22">TargetStatus_PoweringOff</a> = 7
<br />
 }</td></tr>
<tr class="memdesc:a05f46629dc9dc5852868677b0f3b2448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to specify the connection status of the target.  <a href="namespacenn_1_1tm.html#a05f46629dc9dc5852868677b0f3b2448">More...</a><br /></td></tr>
<tr class="separator:a05f46629dc9dc5852868677b0f3b2448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8924b817752c0fc71eeaaf38ccfde4d4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a8924b817752c0fc71eeaaf38ccfde4d4">VideoRecordingExitReason</a> : int32_t { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#a8924b817752c0fc71eeaaf38ccfde4d4a5b2012d1e335a7f4fe9001b838fd6c92">VideoRecordingExitReason_None</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#a8924b817752c0fc71eeaaf38ccfde4d4afb6a388e3f5da6d31a706de26e28933c">VideoRecordingExitReason_TimeCompleted</a> = 1
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#a8924b817752c0fc71eeaaf38ccfde4d4aabc958a9c610b4b3fcf41d8f687a9883">VideoRecordingExitReason_StopTriggered</a> = 2
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#a8924b817752c0fc71eeaaf38ccfde4d4ab000407e096f18c90fad8f0849786f14">VideoRecordingExitReason_GetVideoFailed</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#a8924b817752c0fc71eeaaf38ccfde4d4aef7ee091f9efa24f8984f73d9aa8e55b">VideoRecordingExitReason_ConnectionInterrupted</a> = 4
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1tm.html#a8924b817752c0fc71eeaaf38ccfde4d4aebd77dd5994f18e1c574cc1073f71d34">VideoRecordingExitReason_UnexpectedError</a> = 5
<br />
 }</td></tr>
<tr class="memdesc:a8924b817752c0fc71eeaaf38ccfde4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit reason for the last recorded video.  <a href="namespacenn_1_1tm.html#a8924b817752c0fc71eeaaf38ccfde4d4">More...</a><br /></td></tr>
<tr class="separator:a8924b817752c0fc71eeaaf38ccfde4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5c5f587a589e9b6811e43e3bacd97608"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a5c5f587a589e9b6811e43e3bacd97608">AbortDiscovery</a> (void)</td></tr>
<tr class="memdesc:a5c5f587a589e9b6811e43e3bacd97608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts the current discovery scan.  <a href="namespacenn_1_1tm.html#a5c5f587a589e9b6811e43e3bacd97608">More...</a><br /></td></tr>
<tr class="separator:a5c5f587a589e9b6811e43e3bacd97608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433ee979733abf98d33e410835c0b653"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a433ee979733abf98d33e410835c0b653">AddTarget</a> (<a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> *pOutTargetHandle, const <a class="el" href="structnn_1_1tm_1_1_target_ip_address.html">TargetIpAddress</a> *pIpAddress)</td></tr>
<tr class="memdesc:a433ee979733abf98d33e410835c0b653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a target specified by the ip address to Target Manager.  <a href="namespacenn_1_1tm.html#a433ee979733abf98d33e410835c0b653">More...</a><br /></td></tr>
<tr class="separator:a433ee979733abf98d33e410835c0b653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91d588d32d881224b13222e3231dc4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#af91d588d32d881224b13222e3231dc4d">AddTarget</a> (<a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> *pOutTargetHandle, <a class="el" href="structnn_1_1tm_1_1_discovery_handle.html">DiscoveryHandle</a> discoveryHandle)</td></tr>
<tr class="memdesc:af91d588d32d881224b13222e3231dc4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a target specified by the <a class="el" href="structnn_1_1tm_1_1_discovery_handle.html" title="A unique handle for interacting with discovered targets.">DiscoveryHandle</a> to Target Manager.  <a href="namespacenn_1_1tm.html#af91d588d32d881224b13222e3231dc4d">More...</a><br /></td></tr>
<tr class="separator:af91d588d32d881224b13222e3231dc4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae836a0e0d88b30103e0cb7d3ad86403f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#ae836a0e0d88b30103e0cb7d3ad86403f">CloseTargetVideoStream</a> (<a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:ae836a0e0d88b30103e0cb7d3ad86403f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes a target video stream.  <a href="namespacenn_1_1tm.html#ae836a0e0d88b30103e0cb7d3ad86403f">More...</a><br /></td></tr>
<tr class="separator:ae836a0e0d88b30103e0cb7d3ad86403f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c3f9c3c4d21eae6e748898d2e89add"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a85c3f9c3c4d21eae6e748898d2e89add">ConnectTarget</a> (<a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:a85c3f9c3c4d21eae6e748898d2e89add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects to the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>.  <a href="namespacenn_1_1tm.html#a85c3f9c3c4d21eae6e748898d2e89add">More...</a><br /></td></tr>
<tr class="separator:a85c3f9c3c4d21eae6e748898d2e89add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bba2bc861557e25fc20c6dfcc79878d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a7bba2bc861557e25fc20c6dfcc79878d">CreateTargetProgramDump</a> (<a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle, const char *pFilePath, <a class="el" href="namespacenn_1_1tm.html#aed75c59e3dcda10a6cf06c0048a86769">DumpType</a> dumpType)</td></tr>
<tr class="memdesc:a7bba2bc861557e25fc20c6dfcc79878d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a nxdmp file for the application on the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>.  <a href="namespacenn_1_1tm.html#a7bba2bc861557e25fc20c6dfcc79878d">More...</a><br /></td></tr>
<tr class="separator:a7bba2bc861557e25fc20c6dfcc79878d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c08287b3ea934b53c9c3d1f2eb5176"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a37c08287b3ea934b53c9c3d1f2eb5176">DisconnectTarget</a> (<a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:a37c08287b3ea934b53c9c3d1f2eb5176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects from the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>.  <a href="namespacenn_1_1tm.html#a37c08287b3ea934b53c9c3d1f2eb5176">More...</a><br /></td></tr>
<tr class="separator:a37c08287b3ea934b53c9c3d1f2eb5176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1335a874e1f2314d2789f11ea7f490"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a8b1335a874e1f2314d2789f11ea7f490">ForceConnectTarget</a> (<a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:a8b1335a874e1f2314d2789f11ea7f490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces a connection to the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>.  <a href="namespacenn_1_1tm.html#a8b1335a874e1f2314d2789f11ea7f490">More...</a><br /></td></tr>
<tr class="separator:a8b1335a874e1f2314d2789f11ea7f490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16f8646436f34f1e13d98856ada479c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#af16f8646436f34f1e13d98856ada479c">GetDefaultTarget</a> (<a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> *pOutTargetHandle)</td></tr>
<tr class="memdesc:af16f8646436f34f1e13d98856ada479c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a> of the default target in Target Manager.  <a href="namespacenn_1_1tm.html#af16f8646436f34f1e13d98856ada479c">More...</a><br /></td></tr>
<tr class="separator:af16f8646436f34f1e13d98856ada479c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955d2e7c36c4b9e6621d706e7cf6a3dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a955d2e7c36c4b9e6621d706e7cf6a3dd">GetDiscoveryState</a> (<a class="el" href="namespacenn_1_1tm.html#a2422234500de1643cba6348b73cf2289">DiscoveryState</a> *pOutDiscoveryState)</td></tr>
<tr class="memdesc:a955d2e7c36c4b9e6621d706e7cf6a3dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current state of the discovery scan.  <a href="namespacenn_1_1tm.html#a955d2e7c36c4b9e6621d706e7cf6a3dd">More...</a><br /></td></tr>
<tr class="separator:a955d2e7c36c4b9e6621d706e7cf6a3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc69cab46a97618e5bf6331f9c67abef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#abc69cab46a97618e5bf6331f9c67abef">GetDiscoveryTargetAgentVersion</a> (<a class="el" href="structnn_1_1tm_1_1_target_agent_version.html">TargetAgentVersion</a> *pOutTargetAgentVersion, <a class="el" href="structnn_1_1tm_1_1_discovery_handle.html">DiscoveryHandle</a> discoveryHandle)</td></tr>
<tr class="memdesc:abc69cab46a97618e5bf6331f9c67abef"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED.  <a href="namespacenn_1_1tm.html#abc69cab46a97618e5bf6331f9c67abef">More...</a><br /></td></tr>
<tr class="separator:abc69cab46a97618e5bf6331f9c67abef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ebc666c416974264c7677c4ecea001"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a31ebc666c416974264c7677c4ecea001">GetDiscoveryTargetConnectionType</a> (<a class="el" href="namespacenn_1_1tm.html#aa59a34a84efb360bab2a0ffc81424f85">TargetConnectionType</a> *pOutTargetConnectionType, <a class="el" href="structnn_1_1tm_1_1_discovery_handle.html">DiscoveryHandle</a> discoveryHandle)</td></tr>
<tr class="memdesc:a31ebc666c416974264c7677c4ecea001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the connection type of the discovered target specified by the <a class="el" href="structnn_1_1tm_1_1_discovery_handle.html" title="A unique handle for interacting with discovered targets.">DiscoveryHandle</a>.  <a href="namespacenn_1_1tm.html#a31ebc666c416974264c7677c4ecea001">More...</a><br /></td></tr>
<tr class="separator:a31ebc666c416974264c7677c4ecea001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3925fbf4c1069cdcbc537a96fb1f6746"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a3925fbf4c1069cdcbc537a96fb1f6746">GetDiscoveryTargetCount</a> (int32_t *pOutDiscoveryTargetCount)</td></tr>
<tr class="memdesc:a3925fbf4c1069cdcbc537a96fb1f6746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of discovered targets from the last executed discovery scan.  <a href="namespacenn_1_1tm.html#a3925fbf4c1069cdcbc537a96fb1f6746">More...</a><br /></td></tr>
<tr class="separator:a3925fbf4c1069cdcbc537a96fb1f6746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6758ab77b140308e0082326673fea42c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a6758ab77b140308e0082326673fea42c">GetDiscoveryTargetHardwareType</a> (<a class="el" href="namespacenn_1_1tm.html#a45342c02e85eb2eacb90f4b44f9cde6d">TargetHardwareType</a> *pOutTargetHardwareType, <a class="el" href="structnn_1_1tm_1_1_discovery_handle.html">DiscoveryHandle</a> discoveryHandle)</td></tr>
<tr class="memdesc:a6758ab77b140308e0082326673fea42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the hardware type of the discovered target specified by the <a class="el" href="structnn_1_1tm_1_1_discovery_handle.html" title="A unique handle for interacting with discovered targets.">DiscoveryHandle</a>.  <a href="namespacenn_1_1tm.html#a6758ab77b140308e0082326673fea42c">More...</a><br /></td></tr>
<tr class="separator:a6758ab77b140308e0082326673fea42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1102c1e9497e0879b92c40abe6751132"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a1102c1e9497e0879b92c40abe6751132">GetDiscoveryTargetIpAddress</a> (<a class="el" href="structnn_1_1tm_1_1_target_ip_address.html">TargetIpAddress</a> *pOutTargetIpAddress, <a class="el" href="structnn_1_1tm_1_1_discovery_handle.html">DiscoveryHandle</a> discoveryHandle)</td></tr>
<tr class="memdesc:a1102c1e9497e0879b92c40abe6751132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the ip address of the discovered target specified by the <a class="el" href="structnn_1_1tm_1_1_discovery_handle.html" title="A unique handle for interacting with discovered targets.">DiscoveryHandle</a>.  <a href="namespacenn_1_1tm.html#a1102c1e9497e0879b92c40abe6751132">More...</a><br /></td></tr>
<tr class="separator:a1102c1e9497e0879b92c40abe6751132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d33f738ce669a3c0f08b4c84734840"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#af8d33f738ce669a3c0f08b4c84734840">GetDiscoveryTargetMacAddress</a> (<a class="el" href="structnn_1_1tm_1_1_target_mac_address.html">TargetMacAddress</a> *pOutTargetMacAddress, <a class="el" href="structnn_1_1tm_1_1_discovery_handle.html">DiscoveryHandle</a> discoveryHandle)</td></tr>
<tr class="memdesc:af8d33f738ce669a3c0f08b4c84734840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the mac address of the discovered target specified by the <a class="el" href="structnn_1_1tm_1_1_discovery_handle.html" title="A unique handle for interacting with discovered targets.">DiscoveryHandle</a>.  <a href="namespacenn_1_1tm.html#af8d33f738ce669a3c0f08b4c84734840">More...</a><br /></td></tr>
<tr class="separator:af8d33f738ce669a3c0f08b4c84734840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc83f1ebddc0b361cbbaccc9fbdc058"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a4fc83f1ebddc0b361cbbaccc9fbdc058">GetDiscoveryTargetName</a> (<a class="el" href="structnn_1_1tm_1_1_target_name.html">TargetName</a> *pOutTargetName, <a class="el" href="structnn_1_1tm_1_1_discovery_handle.html">DiscoveryHandle</a> discoveryHandle)</td></tr>
<tr class="memdesc:a4fc83f1ebddc0b361cbbaccc9fbdc058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of the discovered target specified by the <a class="el" href="structnn_1_1tm_1_1_discovery_handle.html" title="A unique handle for interacting with discovered targets.">DiscoveryHandle</a>.  <a href="namespacenn_1_1tm.html#a4fc83f1ebddc0b361cbbaccc9fbdc058">More...</a><br /></td></tr>
<tr class="separator:a4fc83f1ebddc0b361cbbaccc9fbdc058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa309bdadb5f56cde33525a5ce5dfedd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#aa309bdadb5f56cde33525a5ce5dfedd5">GetDiscoveryTargets</a> (<a class="el" href="structnn_1_1tm_1_1_discovery_handle.html">DiscoveryHandle</a> *pOutDiscoveredTargetsBuffer, int32_t *pOutBufferSize, int32_t bufferSize)</td></tr>
<tr class="memdesc:aa309bdadb5f56cde33525a5ce5dfedd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a buffer containing DiscoveryHandles.  <a href="namespacenn_1_1tm.html#aa309bdadb5f56cde33525a5ce5dfedd5">More...</a><br /></td></tr>
<tr class="separator:aa309bdadb5f56cde33525a5ce5dfedd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c051987b95b741c68cb94aa5d025c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#ab6c051987b95b741c68cb94aa5d025c6">GetDiscoveryTargetSerialNumber</a> (<a class="el" href="structnn_1_1tm_1_1_target_serial_number.html">TargetSerialNumber</a> *pOutTargetSerialNumber, <a class="el" href="structnn_1_1tm_1_1_discovery_handle.html">DiscoveryHandle</a> discoveryHandle)</td></tr>
<tr class="memdesc:ab6c051987b95b741c68cb94aa5d025c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the serial number of the discovered target specified by the <a class="el" href="structnn_1_1tm_1_1_discovery_handle.html" title="A unique handle for interacting with discovered targets.">DiscoveryHandle</a>.  <a href="namespacenn_1_1tm.html#ab6c051987b95b741c68cb94aa5d025c6">More...</a><br /></td></tr>
<tr class="separator:ab6c051987b95b741c68cb94aa5d025c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02f790b535ed08d05286d21d85809b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#af02f790b535ed08d05286d21d85809b9">GetDiscoveryTargetUser</a> (<a class="el" href="structnn_1_1tm_1_1_target_user.html">TargetUser</a> *pOutTargetUser, <a class="el" href="structnn_1_1tm_1_1_discovery_handle.html">DiscoveryHandle</a> discoveryHandle)</td></tr>
<tr class="memdesc:af02f790b535ed08d05286d21d85809b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last known user connected to the discovered target specified by the <a class="el" href="structnn_1_1tm_1_1_discovery_handle.html" title="A unique handle for interacting with discovered targets.">DiscoveryHandle</a>.  <a href="namespacenn_1_1tm.html#af02f790b535ed08d05286d21d85809b9">More...</a><br /></td></tr>
<tr class="separator:af02f790b535ed08d05286d21d85809b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89127dbdf0d39442a3a004bc6afefd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#af89127dbdf0d39442a3a004bc6afefd9">GetErrorText</a> (<a class="el" href="structnn_1_1tm_1_1_error_text.html">ErrorText</a> *pOutTextBuffer, <a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> error)</td></tr>
<tr class="memdesc:af89127dbdf0d39442a3a004bc6afefd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the <a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034" title="Target Manager API error codes.">nn::tm::Error</a> code into an text string.  <a href="namespacenn_1_1tm.html#af89127dbdf0d39442a3a004bc6afefd9">More...</a><br /></td></tr>
<tr class="separator:af89127dbdf0d39442a3a004bc6afefd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642828ac7ffde86bf9fc0ef626d309b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a642828ac7ffde86bf9fc0ef626d309b0">GetErrorTextEn</a> (<a class="el" href="structnn_1_1tm_1_1_error_text.html">ErrorText</a> *pOutTextBuffer, <a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> error)</td></tr>
<tr class="memdesc:a642828ac7ffde86bf9fc0ef626d309b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the <a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034" title="Target Manager API error codes.">nn::tm::Error</a> code into an English text string.  <a href="namespacenn_1_1tm.html#a642828ac7ffde86bf9fc0ef626d309b0">More...</a><br /></td></tr>
<tr class="separator:a642828ac7ffde86bf9fc0ef626d309b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838bd030e2da9dcab10bc5e23f32d768"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a838bd030e2da9dcab10bc5e23f32d768">GetErrorTextJa</a> (<a class="el" href="structnn_1_1tm_1_1_error_text.html">ErrorText</a> *pOutTextBuffer, <a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> error)</td></tr>
<tr class="memdesc:a838bd030e2da9dcab10bc5e23f32d768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the <a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034" title="Target Manager API error codes.">nn::tm::Error</a> code into an Japanese text string.  <a href="namespacenn_1_1tm.html#a838bd030e2da9dcab10bc5e23f32d768">More...</a><br /></td></tr>
<tr class="separator:a838bd030e2da9dcab10bc5e23f32d768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d88b6f94720e2151cca902d73efb67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a65d88b6f94720e2151cca902d73efb67">GetHtcsAddresses</a> (<a class="el" href="structnn_1_1tm_1_1_htcs_address.html">HtcsAddress</a> *pOutHtcsAddresses, int32_t *pOutBufferSize, int32_t bufferSize)</td></tr>
<tr class="memdesc:a65d88b6f94720e2151cca902d73efb67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all of the HTCS addresses reserved by Target Manager.  <a href="namespacenn_1_1tm.html#a65d88b6f94720e2151cca902d73efb67">More...</a><br /></td></tr>
<tr class="separator:a65d88b6f94720e2151cca902d73efb67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797f11eafc380305702480f96770db7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a797f11eafc380305702480f96770db7f">GetHtcsAddressesCount</a> (int32_t *pOutHtcsAddressesCount)</td></tr>
<tr class="memdesc:a797f11eafc380305702480f96770db7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of the HTCS addresses reserved by Target Manager.  <a href="namespacenn_1_1tm.html#a797f11eafc380305702480f96770db7f">More...</a><br /></td></tr>
<tr class="separator:a797f11eafc380305702480f96770db7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a71568a86c10d76566a4c0b07326085"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a9a71568a86c10d76566a4c0b07326085">GetHtcsControlPort</a> (int32_t *pOutControlPort)</td></tr>
<tr class="memdesc:a9a71568a86c10d76566a4c0b07326085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the control port number used for HTCS.  <a href="namespacenn_1_1tm.html#a9a71568a86c10d76566a4c0b07326085">More...</a><br /></td></tr>
<tr class="separator:a9a71568a86c10d76566a4c0b07326085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb92be54fbe72b703fbb910d86643748"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#acb92be54fbe72b703fbb910d86643748">GetHtcsEntryEndPoints</a> (<a class="el" href="structnn_1_1tm_1_1_htcs_address.html">HtcsAddress</a> *pOutHtcsAddresses, int32_t *pOutBufferSize, int32_t bufferSize, const <a class="el" href="structnn_1_1tm_1_1_htcs_peer_name.html">HtcsPeerName</a> *pPeerName, const <a class="el" href="structnn_1_1tm_1_1_htcs_port_name.html">HtcsPortName</a> *pPortName)</td></tr>
<tr class="memdesc:acb92be54fbe72b703fbb910d86643748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a filtered list of HtcsAddresses as specified by the peer and port names.  <a href="namespacenn_1_1tm.html#acb92be54fbe72b703fbb910d86643748">More...</a><br /></td></tr>
<tr class="separator:acb92be54fbe72b703fbb910d86643748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd183e6f272b14f51bc38d783bceb098"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#abd183e6f272b14f51bc38d783bceb098">GetHtcsPeerName</a> (<a class="el" href="structnn_1_1tm_1_1_htcs_peer_name.html">HtcsPeerName</a> *pOutPeerName, const <a class="el" href="structnn_1_1tm_1_1_htcs_address.html">HtcsAddress</a> *pSocketAddress)</td></tr>
<tr class="memdesc:abd183e6f272b14f51bc38d783bceb098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the peer name of the HTCS address.  <a href="namespacenn_1_1tm.html#abd183e6f272b14f51bc38d783bceb098">More...</a><br /></td></tr>
<tr class="separator:abd183e6f272b14f51bc38d783bceb098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58fb31f53dcc172d963716a9cb108848"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a58fb31f53dcc172d963716a9cb108848">GetHtcsPortName</a> (<a class="el" href="structnn_1_1tm_1_1_htcs_port_name.html">HtcsPortName</a> *pOutPortName, const <a class="el" href="structnn_1_1tm_1_1_htcs_address.html">HtcsAddress</a> *pSocketAddress)</td></tr>
<tr class="memdesc:a58fb31f53dcc172d963716a9cb108848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the port name of the HTCS address.  <a href="namespacenn_1_1tm.html#a58fb31f53dcc172d963716a9cb108848">More...</a><br /></td></tr>
<tr class="separator:a58fb31f53dcc172d963716a9cb108848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4553697223400181823df5096fbb38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a1a4553697223400181823df5096fbb38">GetLastVideoRecordingExitReason</a> (<a class="el" href="namespacenn_1_1tm.html#a8924b817752c0fc71eeaaf38ccfde4d4">VideoRecordingExitReason</a> *pOutReason, <a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:a1a4553697223400181823df5096fbb38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the reason why the last video recording finished.  <a href="namespacenn_1_1tm.html#a1a4553697223400181823df5096fbb38">More...</a><br /></td></tr>
<tr class="separator:a1a4553697223400181823df5096fbb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c11fbc3ec5b25eef4317d42c3220d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a82c11fbc3ec5b25eef4317d42c3220d2">GetLog</a> (bool *pOutUnbroken, size_t *pOutSize, char *buffer, size_t bufferSize, <a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:a82c11fbc3ec5b25eef4317d42c3220d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets log that is already output at that time.  <a href="namespacenn_1_1tm.html#a82c11fbc3ec5b25eef4317d42c3220d2">More...</a><br /></td></tr>
<tr class="separator:a82c11fbc3ec5b25eef4317d42c3220d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac996ae9e8812c475e971b499053b3b9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#ac996ae9e8812c475e971b499053b3b9c">GetScreenImageData</a> (char *pOutBuffer, size_t bufferSize, <a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:ac996ae9e8812c475e971b499053b3b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the raw RGB pixel values of the target screen image.  <a href="namespacenn_1_1tm.html#ac996ae9e8812c475e971b499053b3b9c">More...</a><br /></td></tr>
<tr class="separator:ac996ae9e8812c475e971b499053b3b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62326c39781b1c183edf8f68b2afc4e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a62326c39781b1c183edf8f68b2afc4e5">GetScreenImageSize</a> (int32_t *pOutWidth, int32_t *pOutHeight, <a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:a62326c39781b1c183edf8f68b2afc4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the width and height of the target screen image.  <a href="namespacenn_1_1tm.html#a62326c39781b1c183edf8f68b2afc4e5">More...</a><br /></td></tr>
<tr class="separator:a62326c39781b1c183edf8f68b2afc4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069317a9491ead7a8c602255e2e123ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a069317a9491ead7a8c602255e2e123ff">GetTargetAgentVersion</a> (<a class="el" href="structnn_1_1tm_1_1_target_agent_version.html">TargetAgentVersion</a> *pOutTargetAgentVersion, <a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:a069317a9491ead7a8c602255e2e123ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED.  <a href="namespacenn_1_1tm.html#a069317a9491ead7a8c602255e2e123ff">More...</a><br /></td></tr>
<tr class="separator:a069317a9491ead7a8c602255e2e123ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ee418d82ed14a94a6b659e78f8bdc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a52ee418d82ed14a94a6b659e78f8bdc1">GetTargetConnectionType</a> (<a class="el" href="namespacenn_1_1tm.html#aa59a34a84efb360bab2a0ffc81424f85">TargetConnectionType</a> *pOutTargetConnectionType, <a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:a52ee418d82ed14a94a6b659e78f8bdc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the target connection type of the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>.  <a href="namespacenn_1_1tm.html#a52ee418d82ed14a94a6b659e78f8bdc1">More...</a><br /></td></tr>
<tr class="separator:a52ee418d82ed14a94a6b659e78f8bdc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1bae8c19e9dcc5c5590e4a0a3fc2348"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#ab1bae8c19e9dcc5c5590e4a0a3fc2348">GetTargetCount</a> (int32_t *pOutTargetCount)</td></tr>
<tr class="memdesc:ab1bae8c19e9dcc5c5590e4a0a3fc2348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of targets in Target Manager.  <a href="namespacenn_1_1tm.html#ab1bae8c19e9dcc5c5590e4a0a3fc2348">More...</a><br /></td></tr>
<tr class="separator:ab1bae8c19e9dcc5c5590e4a0a3fc2348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e9719a818a8515e221ab26c8acdc42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a66e9719a818a8515e221ab26c8acdc42">GetTargetFirmwareVersion</a> (<a class="el" href="structnn_1_1tm_1_1_target_firmware_version.html">TargetFirmwareVersion</a> *pOutTargetFirmwareVersion, <a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:a66e9719a818a8515e221ab26c8acdc42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the firmware version of the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>.  <a href="namespacenn_1_1tm.html#a66e9719a818a8515e221ab26c8acdc42">More...</a><br /></td></tr>
<tr class="separator:a66e9719a818a8515e221ab26c8acdc42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd844cc492fa70b5d85d825542b1f131"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#abd844cc492fa70b5d85d825542b1f131">GetTargetHardwareType</a> (<a class="el" href="namespacenn_1_1tm.html#a45342c02e85eb2eacb90f4b44f9cde6d">TargetHardwareType</a> *pOutTargetHardwareType, <a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:abd844cc492fa70b5d85d825542b1f131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the hardware type of the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>.  <a href="namespacenn_1_1tm.html#abd844cc492fa70b5d85d825542b1f131">More...</a><br /></td></tr>
<tr class="separator:abd844cc492fa70b5d85d825542b1f131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73941e8a33d7ce3b6389e2ece60b486"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#ad73941e8a33d7ce3b6389e2ece60b486">GetTargetIpAddress</a> (<a class="el" href="structnn_1_1tm_1_1_target_ip_address.html">TargetIpAddress</a> *pOutTargetIpAddress, <a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:ad73941e8a33d7ce3b6389e2ece60b486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the target ip address of the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>.  <a href="namespacenn_1_1tm.html#ad73941e8a33d7ce3b6389e2ece60b486">More...</a><br /></td></tr>
<tr class="separator:ad73941e8a33d7ce3b6389e2ece60b486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eed937f7f18fcf145ec0631563b61ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a0eed937f7f18fcf145ec0631563b61ac">GetTargetIsConnected</a> (bool *pOutIsConnected, <a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:a0eed937f7f18fcf145ec0631563b61ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns target connection status of the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>.  <a href="namespacenn_1_1tm.html#a0eed937f7f18fcf145ec0631563b61ac">More...</a><br /></td></tr>
<tr class="separator:a0eed937f7f18fcf145ec0631563b61ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665c0ff1359e1f48262aee05f7d94b7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a665c0ff1359e1f48262aee05f7d94b7d">GetTargetIsSleeping</a> (bool *pOutIsSleeping, <a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:a665c0ff1359e1f48262aee05f7d94b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns target sleep status of the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>.  <a href="namespacenn_1_1tm.html#a665c0ff1359e1f48262aee05f7d94b7d">More...</a><br /></td></tr>
<tr class="separator:a665c0ff1359e1f48262aee05f7d94b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9580b7cf83fd41575e9503d9cc99a248"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a9580b7cf83fd41575e9503d9cc99a248">GetTargetMacAddress</a> (<a class="el" href="structnn_1_1tm_1_1_target_mac_address.html">TargetMacAddress</a> *pOutTargetMacAddress, <a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:a9580b7cf83fd41575e9503d9cc99a248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mac address of the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>.  <a href="namespacenn_1_1tm.html#a9580b7cf83fd41575e9503d9cc99a248">More...</a><br /></td></tr>
<tr class="separator:a9580b7cf83fd41575e9503d9cc99a248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800c61b734b55dc4092f4fb67a52ca91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a800c61b734b55dc4092f4fb67a52ca91">GetTargetName</a> (<a class="el" href="structnn_1_1tm_1_1_target_name.html">TargetName</a> *pOutTargetName, <a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:a800c61b734b55dc4092f4fb67a52ca91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the target name of the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>.  <a href="namespacenn_1_1tm.html#a800c61b734b55dc4092f4fb67a52ca91">More...</a><br /></td></tr>
<tr class="separator:a800c61b734b55dc4092f4fb67a52ca91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e416569975e489112f73827431e963"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a67e416569975e489112f73827431e963">GetTargetProgramName</a> (<a class="el" href="structnn_1_1tm_1_1_target_program_name.html">TargetProgramName</a> *pOutTargetProgramName, <a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:a67e416569975e489112f73827431e963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the program on the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>.  <a href="namespacenn_1_1tm.html#a67e416569975e489112f73827431e963">More...</a><br /></td></tr>
<tr class="separator:a67e416569975e489112f73827431e963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbde8c1b5037ae73ba7708e85fe5724d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#adbde8c1b5037ae73ba7708e85fe5724d">GetTargetProgramState</a> (<a class="el" href="namespacenn_1_1tm.html#a65c4c275de00753bdcb270212e8d603c">TargetProgramState</a> *pOutTargetProgramState, <a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:adbde8c1b5037ae73ba7708e85fe5724d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the state of the program on the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>.  <a href="namespacenn_1_1tm.html#adbde8c1b5037ae73ba7708e85fe5724d">More...</a><br /></td></tr>
<tr class="separator:adbde8c1b5037ae73ba7708e85fe5724d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e6b98b7fd6773d8c896ffdd7dfe48e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a50e6b98b7fd6773d8c896ffdd7dfe48e">GetTargets</a> (<a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> *pOutTargetsBuffer, int32_t *pOutBufferSize, int32_t bufferSize)</td></tr>
<tr class="memdesc:a50e6b98b7fd6773d8c896ffdd7dfe48e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the array of targets in Target Manager.  <a href="namespacenn_1_1tm.html#a50e6b98b7fd6773d8c896ffdd7dfe48e">More...</a><br /></td></tr>
<tr class="separator:a50e6b98b7fd6773d8c896ffdd7dfe48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfc5817575397e282a0d2bcf0af3242"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#aebfc5817575397e282a0d2bcf0af3242">GetTargetSerialNumber</a> (<a class="el" href="structnn_1_1tm_1_1_target_serial_number.html">TargetSerialNumber</a> *pOutTargetSerialNumber, <a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:aebfc5817575397e282a0d2bcf0af3242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the target serial number of the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>.  <a href="namespacenn_1_1tm.html#aebfc5817575397e282a0d2bcf0af3242">More...</a><br /></td></tr>
<tr class="separator:aebfc5817575397e282a0d2bcf0af3242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf2dfc50667bdad60a5363e6f141e94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a5cf2dfc50667bdad60a5363e6f141e94">GetTargetStatus</a> (<a class="el" href="namespacenn_1_1tm.html#a05f46629dc9dc5852868677b0f3b2448">TargetStatus</a> *pOutTargetStatus, <a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:a5cf2dfc50667bdad60a5363e6f141e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the target connection status of the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>.  <a href="namespacenn_1_1tm.html#a5cf2dfc50667bdad60a5363e6f141e94">More...</a><br /></td></tr>
<tr class="separator:a5cf2dfc50667bdad60a5363e6f141e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97d74050793e4f314ffc91153416aca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#ab97d74050793e4f314ffc91153416aca">GetTargetUser</a> (<a class="el" href="structnn_1_1tm_1_1_target_user.html">TargetUser</a> *pOutTargetUser, <a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:ab97d74050793e4f314ffc91153416aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the user connected to the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>.  <a href="namespacenn_1_1tm.html#ab97d74050793e4f314ffc91153416aca">More...</a><br /></td></tr>
<tr class="separator:ab97d74050793e4f314ffc91153416aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8466e9a9e63456f9e3ee743f0f1403d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#af8466e9a9e63456f9e3ee743f0f1403d">GetTargetWorkingDirectory</a> (<a class="el" href="structnn_1_1tm_1_1_target_working_directory.html">TargetWorkingDirectory</a> *pOutWorkingDirectory, <a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:af8466e9a9e63456f9e3ee743f0f1403d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the working directory of the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>.  <a href="namespacenn_1_1tm.html#af8466e9a9e63456f9e3ee743f0f1403d">More...</a><br /></td></tr>
<tr class="separator:af8466e9a9e63456f9e3ee743f0f1403d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f80d8a454f628089fe81343e4332874"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a1f80d8a454f628089fe81343e4332874">KillTargetProgram</a> (<a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:a1f80d8a454f628089fe81343e4332874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kill the user program on the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>.  <a href="namespacenn_1_1tm.html#a1f80d8a454f628089fe81343e4332874">More...</a><br /></td></tr>
<tr class="separator:a1f80d8a454f628089fe81343e4332874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e5dfcc831c62dc7a5cf9af8c5aa721"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#ad8e5dfcc831c62dc7a5cf9af8c5aa721">LaunchTargetProgram</a> (<a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle, const char *pFileName, const char *pArguments, const char *pWorkingDirectory, const char *pTDF)</td></tr>
<tr class="memdesc:ad8e5dfcc831c62dc7a5cf9af8c5aa721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Launches an executable on the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>.  <a href="namespacenn_1_1tm.html#ad8e5dfcc831c62dc7a5cf9af8c5aa721">More...</a><br /></td></tr>
<tr class="separator:ad8e5dfcc831c62dc7a5cf9af8c5aa721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a4b5e7f005bac95378e7ee8363de82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a01a4b5e7f005bac95378e7ee8363de82">LongPressPowerButton</a> (<a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:a01a4b5e7f005bac95378e7ee8363de82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emulates holding the Target's Power button down for eight seconds.  <a href="namespacenn_1_1tm.html#a01a4b5e7f005bac95378e7ee8363de82">More...</a><br /></td></tr>
<tr class="separator:a01a4b5e7f005bac95378e7ee8363de82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3014495e915f0f4764927f97745a0cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#ae3014495e915f0f4764927f97745a0cd">MiddlePressPowerButton</a> (<a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:ae3014495e915f0f4764927f97745a0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emulates holding the Target's Power button down for four seconds.  <a href="namespacenn_1_1tm.html#ae3014495e915f0f4764927f97745a0cd">More...</a><br /></td></tr>
<tr class="separator:ae3014495e915f0f4764927f97745a0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dffdb040971f72737d02eeee8c2139d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a4dffdb040971f72737d02eeee8c2139d">OpenTargetVideoStream</a> (<a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:a4dffdb040971f72737d02eeee8c2139d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a target video stream.  <a href="namespacenn_1_1tm.html#a4dffdb040971f72737d02eeee8c2139d">More...</a><br /></td></tr>
<tr class="separator:a4dffdb040971f72737d02eeee8c2139d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbd49fd76124fc8d06c88ebfa9939d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a5bbd49fd76124fc8d06c88ebfa9939d3">PowerOffTarget</a> (<a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:a5bbd49fd76124fc8d06c88ebfa9939d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Powers off the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>.  <a href="namespacenn_1_1tm.html#a5bbd49fd76124fc8d06c88ebfa9939d3">More...</a><br /></td></tr>
<tr class="separator:a5bbd49fd76124fc8d06c88ebfa9939d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38525a0238284c8f0ff9a76ce10b2971"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a38525a0238284c8f0ff9a76ce10b2971">PowerOnTarget</a> (<a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:a38525a0238284c8f0ff9a76ce10b2971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Powers on the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>.  <a href="namespacenn_1_1tm.html#a38525a0238284c8f0ff9a76ce10b2971">More...</a><br /></td></tr>
<tr class="separator:a38525a0238284c8f0ff9a76ce10b2971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676f047a474fb78d1e3c62ce3ac143d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a676f047a474fb78d1e3c62ce3ac143d4">RegisterHtcsEntry</a> (const <a class="el" href="structnn_1_1tm_1_1_htcs_peer_name.html">HtcsPeerName</a> *pPeerName, const <a class="el" href="structnn_1_1tm_1_1_htcs_port_name.html">HtcsPortName</a> *pPortName, const <a class="el" href="structnn_1_1tm_1_1_htcs_address.html">HtcsAddress</a> *pSocketAddress)</td></tr>
<tr class="memdesc:a676f047a474fb78d1e3c62ce3ac143d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers an HTCS entry.  <a href="namespacenn_1_1tm.html#a676f047a474fb78d1e3c62ce3ac143d4">More...</a><br /></td></tr>
<tr class="separator:a676f047a474fb78d1e3c62ce3ac143d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f59176e6b15e2d2ec3cb2ef95a862c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#ad8f59176e6b15e2d2ec3cb2ef95a862c">RegisterHtcsPortMappingUpdateEvent</a> (HANDLE eventHandle)</td></tr>
<tr class="memdesc:ad8f59176e6b15e2d2ec3cb2ef95a862c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies an event handle to be signaled when HTCS port mapping is updated.  <a href="namespacenn_1_1tm.html#ad8f59176e6b15e2d2ec3cb2ef95a862c">More...</a><br /></td></tr>
<tr class="separator:ad8f59176e6b15e2d2ec3cb2ef95a862c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43d77e6366a90b6b8a4becafd39a043"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#aa43d77e6366a90b6b8a4becafd39a043">RegisterProgramErrorEvent</a> (HANDLE eventHandle)</td></tr>
<tr class="memdesc:aa43d77e6366a90b6b8a4becafd39a043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers an EVENT which will be signaled when a target program has crashed.  <a href="namespacenn_1_1tm.html#aa43d77e6366a90b6b8a4becafd39a043">More...</a><br /></td></tr>
<tr class="separator:aa43d77e6366a90b6b8a4becafd39a043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396ed39d6d70e06d19b9a2644d86ef13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a396ed39d6d70e06d19b9a2644d86ef13">RegisterProgramExitEvent</a> (HANDLE eventHandle)</td></tr>
<tr class="memdesc:a396ed39d6d70e06d19b9a2644d86ef13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers an EVENT which will be signaled when running program exits.  <a href="namespacenn_1_1tm.html#a396ed39d6d70e06d19b9a2644d86ef13">More...</a><br /></td></tr>
<tr class="separator:a396ed39d6d70e06d19b9a2644d86ef13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845128493276d7e375818d35db77da81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a845128493276d7e375818d35db77da81">RegisterRemoteVideoUpdateEvent</a> (<a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle, HANDLE eventHandle)</td></tr>
<tr class="memdesc:a845128493276d7e375818d35db77da81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers an EVENT to be signaled when a target's remote video stops recording.  <a href="namespacenn_1_1tm.html#a845128493276d7e375818d35db77da81">More...</a><br /></td></tr>
<tr class="separator:a845128493276d7e375818d35db77da81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508371f9f38192a778047de636581413"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a508371f9f38192a778047de636581413">RemoveAllTargets</a> (void)</td></tr>
<tr class="memdesc:a508371f9f38192a778047de636581413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all targets from Target Manager.  <a href="namespacenn_1_1tm.html#a508371f9f38192a778047de636581413">More...</a><br /></td></tr>
<tr class="separator:a508371f9f38192a778047de636581413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020a3edb4b36e2af471b23a069d00c5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a020a3edb4b36e2af471b23a069d00c5e">RemoveTarget</a> (<a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:a020a3edb4b36e2af471b23a069d00c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a> from Target Manager.  <a href="namespacenn_1_1tm.html#a020a3edb4b36e2af471b23a069d00c5e">More...</a><br /></td></tr>
<tr class="separator:a020a3edb4b36e2af471b23a069d00c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5629fa64ca24271266aac23b3ce02a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#abf5629fa64ca24271266aac23b3ce02a">ResetTargetHard</a> (<a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:abf5629fa64ca24271266aac23b3ce02a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>.  <a href="namespacenn_1_1tm.html#abf5629fa64ca24271266aac23b3ce02a">More...</a><br /></td></tr>
<tr class="separator:abf5629fa64ca24271266aac23b3ce02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7f551be8c5378585a68f6974579d7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a0f7f551be8c5378585a68f6974579d7f">ResetTargetSoft</a> (<a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:a0f7f551be8c5378585a68f6974579d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>.  <a href="namespacenn_1_1tm.html#a0f7f551be8c5378585a68f6974579d7f">More...</a><br /></td></tr>
<tr class="separator:a0f7f551be8c5378585a68f6974579d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06342c1c35c1fb185f045b385a9eb8c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a06342c1c35c1fb185f045b385a9eb8c9">SaveRecentVideo</a> (char *pOutFilePath, size_t bufferSize, <a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle, const char *pDirectory, const char *pFileName)</td></tr>
<tr class="memdesc:a06342c1c35c1fb185f045b385a9eb8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the recent video recorded in the target.  <a href="namespacenn_1_1tm.html#a06342c1c35c1fb185f045b385a9eb8c9">More...</a><br /></td></tr>
<tr class="separator:a06342c1c35c1fb185f045b385a9eb8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b59efc89404abec7b18d8343129edb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a9b59efc89404abec7b18d8343129edb0">SetDefaultTarget</a> (<a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:a9b59efc89404abec7b18d8343129edb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default target in Target Manager to the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>.  <a href="namespacenn_1_1tm.html#a9b59efc89404abec7b18d8343129edb0">More...</a><br /></td></tr>
<tr class="separator:a9b59efc89404abec7b18d8343129edb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304fd62e7e51f64ea7dde65f518a8a81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a304fd62e7e51f64ea7dde65f518a8a81">SetTargetDockState</a> (<a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle, bool bDocked)</td></tr>
<tr class="memdesc:a304fd62e7e51f64ea7dde65f518a8a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dock state of the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>.  <a href="namespacenn_1_1tm.html#a304fd62e7e51f64ea7dde65f518a8a81">More...</a><br /></td></tr>
<tr class="separator:a304fd62e7e51f64ea7dde65f518a8a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e10b5c3359e82ca603dc36d26a57fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a46e10b5c3359e82ca603dc36d26a57fa">SetTargetName</a> (<a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle, const <a class="el" href="structnn_1_1tm_1_1_target_name.html">TargetName</a> *pTargetName)</td></tr>
<tr class="memdesc:a46e10b5c3359e82ca603dc36d26a57fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name of the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>.  <a href="namespacenn_1_1tm.html#a46e10b5c3359e82ca603dc36d26a57fa">More...</a><br /></td></tr>
<tr class="separator:a46e10b5c3359e82ca603dc36d26a57fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb43f266dc1d445c759f4dc7385c8659"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#abb43f266dc1d445c759f4dc7385c8659">SetTargetWorkingDirectory</a> (<a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle, <a class="el" href="structnn_1_1tm_1_1_target_working_directory.html">TargetWorkingDirectory</a> *pWorkingDirectory)</td></tr>
<tr class="memdesc:abb43f266dc1d445c759f4dc7385c8659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the working directory of the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>.  <a href="namespacenn_1_1tm.html#abb43f266dc1d445c759f4dc7385c8659">More...</a><br /></td></tr>
<tr class="separator:abb43f266dc1d445c759f4dc7385c8659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16568cf76c9efc4a55c49970ed3b3a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#aa16568cf76c9efc4a55c49970ed3b3a2">ShortPressPowerButton</a> (<a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:aa16568cf76c9efc4a55c49970ed3b3a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emulates holding the Target's Power button down for one second.  <a href="namespacenn_1_1tm.html#aa16568cf76c9efc4a55c49970ed3b3a2">More...</a><br /></td></tr>
<tr class="separator:aa16568cf76c9efc4a55c49970ed3b3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc7631993d4d81734fd04ff6801ed1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#affc7631993d4d81734fd04ff6801ed1e">StartDiscovery</a> (int32_t msTimeout)</td></tr>
<tr class="memdesc:affc7631993d4d81734fd04ff6801ed1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a discovery scan.  <a href="namespacenn_1_1tm.html#affc7631993d4d81734fd04ff6801ed1e">More...</a><br /></td></tr>
<tr class="separator:affc7631993d4d81734fd04ff6801ed1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5220d3ff4b1cc4b21a82a93b0ede38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#abb5220d3ff4b1cc4b21a82a93b0ede38">StartSavingJsonLog</a> (<a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle, const char *filePath, bool includeHistory)</td></tr>
<tr class="memdesc:abb5220d3ff4b1cc4b21a82a93b0ede38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start saving log output from the target as Json.  <a href="namespacenn_1_1tm.html#abb5220d3ff4b1cc4b21a82a93b0ede38">More...</a><br /></td></tr>
<tr class="separator:abb5220d3ff4b1cc4b21a82a93b0ede38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5096f347e3e3ad9ae2a5891fb142e04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#ac5096f347e3e3ad9ae2a5891fb142e04">StartSavingLog</a> (<a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle, const char *filePath, bool includeHistory)</td></tr>
<tr class="memdesc:ac5096f347e3e3ad9ae2a5891fb142e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start saving log output from the target.  <a href="namespacenn_1_1tm.html#ac5096f347e3e3ad9ae2a5891fb142e04">More...</a><br /></td></tr>
<tr class="separator:ac5096f347e3e3ad9ae2a5891fb142e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc447667b98e018a37be3dbd39cbb1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a6bc447667b98e018a37be3dbd39cbb1b">StartVideoRecording</a> (char *pOutFilePath, size_t bufferSize, <a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle, const char *pDirectory, const char *pFileName, int32_t recordingTime)</td></tr>
<tr class="memdesc:a6bc447667b98e018a37be3dbd39cbb1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records a video of the target screen.  <a href="namespacenn_1_1tm.html#a6bc447667b98e018a37be3dbd39cbb1b">More...</a><br /></td></tr>
<tr class="separator:a6bc447667b98e018a37be3dbd39cbb1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b1ffd4c2cbfb9a0fb50552f44ed249"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#af1b1ffd4c2cbfb9a0fb50552f44ed249">StopSavingJsonLog</a> (<a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:af1b1ffd4c2cbfb9a0fb50552f44ed249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop saving log started by StartSavingJsonLog.  <a href="namespacenn_1_1tm.html#af1b1ffd4c2cbfb9a0fb50552f44ed249">More...</a><br /></td></tr>
<tr class="separator:af1b1ffd4c2cbfb9a0fb50552f44ed249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc4baa7876d01926076e7a22d917071"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#abbc4baa7876d01926076e7a22d917071">StopSavingLog</a> (<a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:abbc4baa7876d01926076e7a22d917071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop saving log started by StartSavingLog.  <a href="namespacenn_1_1tm.html#abbc4baa7876d01926076e7a22d917071">More...</a><br /></td></tr>
<tr class="separator:abbc4baa7876d01926076e7a22d917071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9298df3fe428d287f3271cb54b9fe01b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a9298df3fe428d287f3271cb54b9fe01b">StopVideoRecording</a> (<a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle)</td></tr>
<tr class="memdesc:a9298df3fe428d287f3271cb54b9fe01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops video recording.  <a href="namespacenn_1_1tm.html#a9298df3fe428d287f3271cb54b9fe01b">More...</a><br /></td></tr>
<tr class="separator:a9298df3fe428d287f3271cb54b9fe01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10cbc14431a2d7c6cc94b95d14ac04f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a10cbc14431a2d7c6cc94b95d14ac04f8">TakeScreenshot</a> (char *pOutFilePath, size_t bufferSize, <a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle, const char *pDirectory, const char *pFileName)</td></tr>
<tr class="memdesc:a10cbc14431a2d7c6cc94b95d14ac04f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a screenshot on the target and returns the file path to screenshot.  <a href="namespacenn_1_1tm.html#a10cbc14431a2d7c6cc94b95d14ac04f8">More...</a><br /></td></tr>
<tr class="separator:a10cbc14431a2d7c6cc94b95d14ac04f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27955499d6f6456166d318257d11203"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#ae27955499d6f6456166d318257d11203">UnregisterHtcsEntry</a> (const <a class="el" href="structnn_1_1tm_1_1_htcs_peer_name.html">HtcsPeerName</a> *pPeerName, const <a class="el" href="structnn_1_1tm_1_1_htcs_port_name.html">HtcsPortName</a> *pPortName)</td></tr>
<tr class="memdesc:ae27955499d6f6456166d318257d11203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters an HTCS entry.  <a href="namespacenn_1_1tm.html#ae27955499d6f6456166d318257d11203">More...</a><br /></td></tr>
<tr class="separator:ae27955499d6f6456166d318257d11203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a3aef51a46737a421b3045d7c5447d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a72a3aef51a46737a421b3045d7c5447d">UnregisterHtcsPortMappingUpdateEvent</a> (HANDLE eventHandle)</td></tr>
<tr class="memdesc:a72a3aef51a46737a421b3045d7c5447d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters an event handle.  <a href="namespacenn_1_1tm.html#a72a3aef51a46737a421b3045d7c5447d">More...</a><br /></td></tr>
<tr class="separator:a72a3aef51a46737a421b3045d7c5447d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398b4e3baebacf85b42ea02b09bcc0c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a398b4e3baebacf85b42ea02b09bcc0c9">UnregisterProgramErrorEvent</a> (HANDLE eventHandle)</td></tr>
<tr class="memdesc:a398b4e3baebacf85b42ea02b09bcc0c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters an EVENT which will be signaled when a target program has crashed.  <a href="namespacenn_1_1tm.html#a398b4e3baebacf85b42ea02b09bcc0c9">More...</a><br /></td></tr>
<tr class="separator:a398b4e3baebacf85b42ea02b09bcc0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2eac619037136734c9771022a3626f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a3b2eac619037136734c9771022a3626f">UnregisterProgramExitEvent</a> (HANDLE eventHandle)</td></tr>
<tr class="memdesc:a3b2eac619037136734c9771022a3626f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters an EVENT which will be signaled when running program exits.  <a href="namespacenn_1_1tm.html#a3b2eac619037136734c9771022a3626f">More...</a><br /></td></tr>
<tr class="separator:a3b2eac619037136734c9771022a3626f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4888e14b9f53fafac0f3f127ad9c0f47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a4888e14b9f53fafac0f3f127ad9c0f47">UnregisterRemoteVideoUpdateEvent</a> (<a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> targetHandle, HANDLE eventHandle)</td></tr>
<tr class="memdesc:a4888e14b9f53fafac0f3f127ad9c0f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters an EVENT to be signaled when a target's remote video stops recording.  <a href="namespacenn_1_1tm.html#a4888e14b9f53fafac0f3f127ad9c0f47">More...</a><br /></td></tr>
<tr class="separator:a4888e14b9f53fafac0f3f127ad9c0f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:adcb2afa623f12690233acf3df552ba26"><td class="memItemLeft" align="right" valign="top"><a id="adcb2afa623f12690233acf3df552ba26"></a>
const int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#adcb2afa623f12690233acf3df552ba26">ErrorTextBufferLength</a> = 1024</td></tr>
<tr class="memdesc:adcb2afa623f12690233acf3df552ba26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of a <a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034" title="Target Manager API error codes.">nn::tm::Error</a> text string. <br /></td></tr>
<tr class="separator:adcb2afa623f12690233acf3df552ba26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937109e09de72d60ee7dcda6009e0a73"><td class="memItemLeft" align="right" valign="top">const int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a937109e09de72d60ee7dcda6009e0a73">HtcsIpAndPortAddressBufferLength</a> = 128</td></tr>
<tr class="memdesc:a937109e09de72d60ee7dcda6009e0a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum IP address length, including the null terminator.  <a href="namespacenn_1_1tm.html#a937109e09de72d60ee7dcda6009e0a73">More...</a><br /></td></tr>
<tr class="separator:a937109e09de72d60ee7dcda6009e0a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f724ea58c4b4870555941d0de0534f"><td class="memItemLeft" align="right" valign="top"><a id="a19f724ea58c4b4870555941d0de0534f"></a>
const int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a19f724ea58c4b4870555941d0de0534f">HtcsPeerNameBufferLength</a> = 32</td></tr>
<tr class="memdesc:a19f724ea58c4b4870555941d0de0534f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of a HTCS peer name, including the null terminator. <br /></td></tr>
<tr class="separator:a19f724ea58c4b4870555941d0de0534f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68466f9cf14803f5402cf5f327284d15"><td class="memItemLeft" align="right" valign="top"><a id="a68466f9cf14803f5402cf5f327284d15"></a>
const int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a68466f9cf14803f5402cf5f327284d15">HtcsPortNameBufferLength</a> = 32</td></tr>
<tr class="memdesc:a68466f9cf14803f5402cf5f327284d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of a HTCS port name, including the null terminator. <br /></td></tr>
<tr class="separator:a68466f9cf14803f5402cf5f327284d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bc0455199e067798f4e113e551138c"><td class="memItemLeft" align="right" valign="top"><a id="a44bc0455199e067798f4e113e551138c"></a>
const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a44bc0455199e067798f4e113e551138c">InvalidHandle</a> = (uint64_t) - 1</td></tr>
<tr class="memdesc:a44bc0455199e067798f4e113e551138c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default value for invalid target and discovery handles. <br /></td></tr>
<tr class="separator:a44bc0455199e067798f4e113e551138c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af526c433cab512235cf88c515820a1a2"><td class="memItemLeft" align="right" valign="top"><a id="af526c433cab512235cf88c515820a1a2"></a>
const <a class="el" href="structnn_1_1tm_1_1_htcs_peer_name.html">HtcsPeerName</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#af526c433cab512235cf88c515820a1a2">PeerNameAny</a> = <a class="el" href="structnn_1_1tm_1_1_htcs_peer_name.html">HtcsPeerName</a>{ &quot;&quot; }</td></tr>
<tr class="memdesc:af526c433cab512235cf88c515820a1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="structnn_1_1tm_1_1_htcs_peer_name.html" title="The null-terminated peer name of the HTCS address.">HtcsPeerName</a> that is used to specify an arbitrary peer name. <br /></td></tr>
<tr class="separator:af526c433cab512235cf88c515820a1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797b966f4325b3f66fe48ce95af50c40"><td class="memItemLeft" align="right" valign="top"><a id="a797b966f4325b3f66fe48ce95af50c40"></a>
const <a class="el" href="structnn_1_1tm_1_1_htcs_peer_name.html">HtcsPeerName</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a797b966f4325b3f66fe48ce95af50c40">PeerNameHostPc</a> = <a class="el" href="structnn_1_1tm_1_1_htcs_peer_name.html">HtcsPeerName</a>{ &quot;&quot; }</td></tr>
<tr class="memdesc:a797b966f4325b3f66fe48ce95af50c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="structnn_1_1tm_1_1_htcs_peer_name.html" title="The null-terminated peer name of the HTCS address.">HtcsPeerName</a> that is used to specify the host PC name. <br /></td></tr>
<tr class="separator:a797b966f4325b3f66fe48ce95af50c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac997906e0ab42990b60e6263bba6c87a"><td class="memItemLeft" align="right" valign="top"><a id="ac997906e0ab42990b60e6263bba6c87a"></a>
const <a class="el" href="structnn_1_1tm_1_1_htcs_port_name.html">HtcsPortName</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#ac997906e0ab42990b60e6263bba6c87a">PortNameAny</a> = <a class="el" href="structnn_1_1tm_1_1_htcs_port_name.html">HtcsPortName</a>{ &quot;&quot; }</td></tr>
<tr class="memdesc:ac997906e0ab42990b60e6263bba6c87a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="structnn_1_1tm_1_1_htcs_port_name.html" title="The null-terminated port name of the HTCS address.">HtcsPortName</a> that is used to specify an arbitrary port name. <br /></td></tr>
<tr class="separator:ac997906e0ab42990b60e6263bba6c87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91cefbe876eaf202f2954028731cad3"><td class="memItemLeft" align="right" valign="top"><a id="ab91cefbe876eaf202f2954028731cad3"></a>
const int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#ab91cefbe876eaf202f2954028731cad3">TargetFirmwareVersionBufferLength</a> = 128</td></tr>
<tr class="memdesc:ab91cefbe876eaf202f2954028731cad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of the target firmware version, including the null terminator. <br /></td></tr>
<tr class="separator:ab91cefbe876eaf202f2954028731cad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6af240f2e4b09eb348de378494b10da"><td class="memItemLeft" align="right" valign="top"><a id="ab6af240f2e4b09eb348de378494b10da"></a>
const int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#ab6af240f2e4b09eb348de378494b10da">TargetIpAddressBufferLength</a> = 128</td></tr>
<tr class="memdesc:ab6af240f2e4b09eb348de378494b10da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of a target ip address, including the null terminator. <br /></td></tr>
<tr class="separator:ab6af240f2e4b09eb348de378494b10da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcab9bdd9f62076278ec0fa0be9798c4"><td class="memItemLeft" align="right" valign="top"><a id="afcab9bdd9f62076278ec0fa0be9798c4"></a>
const int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#afcab9bdd9f62076278ec0fa0be9798c4">TargetMacAddressBufferLength</a> = 32</td></tr>
<tr class="memdesc:afcab9bdd9f62076278ec0fa0be9798c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of a target mac address, including the null terminator. <br /></td></tr>
<tr class="separator:afcab9bdd9f62076278ec0fa0be9798c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61384d2baed8b30e16e6675c8d896749"><td class="memItemLeft" align="right" valign="top"><a id="a61384d2baed8b30e16e6675c8d896749"></a>
const int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a61384d2baed8b30e16e6675c8d896749">TargetNameBufferLength</a> = 64</td></tr>
<tr class="memdesc:a61384d2baed8b30e16e6675c8d896749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of a target name, including the null terminator. <br /></td></tr>
<tr class="separator:a61384d2baed8b30e16e6675c8d896749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1dda224e0d462818b4a6952f9beccb2"><td class="memItemLeft" align="right" valign="top"><a id="ae1dda224e0d462818b4a6952f9beccb2"></a>
const int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#ae1dda224e0d462818b4a6952f9beccb2">TargetProgramNameBufferLength</a> = 256</td></tr>
<tr class="memdesc:ae1dda224e0d462818b4a6952f9beccb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of a program name, including the null terminator. <br /></td></tr>
<tr class="separator:ae1dda224e0d462818b4a6952f9beccb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a34689f49b02967cdb21918860d41ff"><td class="memItemLeft" align="right" valign="top"><a id="a6a34689f49b02967cdb21918860d41ff"></a>
const int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#a6a34689f49b02967cdb21918860d41ff">TargetSerialNumberBufferLength</a> = 24</td></tr>
<tr class="memdesc:a6a34689f49b02967cdb21918860d41ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of a target serial number, including the null terminator. <br /></td></tr>
<tr class="separator:a6a34689f49b02967cdb21918860d41ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92b5fd410d431c2750ab6e6463a7330"><td class="memItemLeft" align="right" valign="top"><a id="ad92b5fd410d431c2750ab6e6463a7330"></a>
const int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#ad92b5fd410d431c2750ab6e6463a7330">TargetWorkingDirectoryBufferLength</a> = 512</td></tr>
<tr class="memdesc:ad92b5fd410d431c2750ab6e6463a7330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of a working directory, including the null terminator. <br /></td></tr>
<tr class="separator:ad92b5fd410d431c2750ab6e6463a7330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e12bd1ea4b28c55d6217711a9e66e3"><td class="memItemLeft" align="right" valign="top"><a id="af5e12bd1ea4b28c55d6217711a9e66e3"></a>
const int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1tm.html#af5e12bd1ea4b28c55d6217711a9e66e3">VideoRecordingTimeInfinite</a> = -1</td></tr>
<tr class="memdesc:af5e12bd1ea4b28c55d6217711a9e66e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies StartVideoRecording to record video until StopVideoRecording is called. <br /></td></tr>
<tr class="separator:af5e12bd1ea4b28c55d6217711a9e66e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Target Manager API (TMAPI) public interfaces. </p>
<p> <b>Details</b> <br  />
 Interface for adding, removing, and controlling targets in Nintendo Target Manager.</p>
<p>Connections to Target Manager do not require a connect or attach call. Any function call through this API will automatically establish a connection to Target Manager. If a connection could not be made, an error will be returned.</p>
<p>Regarding functions which retrieve variable length arrays of data into buffers provided by the caller...</p>
<p>Such functions allow the caller to provide a buffer into which results will be placed and a value which indicates the number of elements in the buffer.</p>
<p>If the number of results will fit within the given buffer, then the function will return a successful error code (assuming nothing else goes wrong) and the parameter indicating the size of the buffer will be changed to the number of elements which are returned.</p>
<p>If the number of results will NOT fit within the given buffer, the buffer will be filled up to the specified buffer size.</p>
<p>For example:</p>
<pre>
     // Get the number of targets.
     int32_t targetCount = 0;
     <a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034" title="Target Manager API error codes.">nn::tm::Error</a> error = nn::tm::GetTargetCount( &amp;targetCount );

     if( error == <a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> )
     {
         <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">nn::tm::TargetHandle</a>* pTargetHandles = new <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">nn::tm::TargetHandle</a>[targetCount];
         error = nn::tm::GetTargets( pTargetHandles, &amp;targetCount, targetCount );

         // Get the target names.
         if( error == <a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> )
         {
             for( int32_t iTarget = 0; iTarget &lt; targetCount; iTarget++ )
             {
                 <a class="el" href="structnn_1_1tm_1_1_target_name.html" title="The null-terminated target name.">TargetName</a> nameBuffer = {0};
                 error = nn::tm::GetTargetName( &amp;nameBuffer, pTargetHandles[iTarget] );

                 // Do something with nameBuffer.
             }
         }

         delete[] pTargetHandles;
     }
     else
     {
         // Handle error.
     }
  </pre><p>Why did we structure this interface this way? Some of these functions can be transactionally time consuming. If you already have a sufficiently large buffer, then we are able to get results in a single transaction. This is more efficient than a traditional GetCount(N) then GetStuff(N) pairing which always requires two transactions. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a2422234500de1643cba6348b73cf2289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2422234500de1643cba6348b73cf2289">&#9670;&nbsp;</a></span>DiscoveryState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1tm.html#a2422234500de1643cba6348b73cf2289">nn::tm::DiscoveryState</a> : int32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discovery scan states in Target Manager. </p>
<p>Only one discovery scan may be running at a given time. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2422234500de1643cba6348b73cf2289aa21041c97ee0a65580f52d11ab44ae34"></a>DiscoveryState_Uninitialized&#160;</td><td class="fielddoc"><p>A discovery scan has not been executed. No targets have been discovered. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2422234500de1643cba6348b73cf2289a2d7edf80d2d7b907045ec71412fa2ef8"></a>DiscoveryState_Started&#160;</td><td class="fielddoc"><p>A discovery scan is currently in progress. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2422234500de1643cba6348b73cf2289aa98c202a61ce933ad457e2b01414a1b4"></a>DiscoveryState_Complete&#160;</td><td class="fielddoc"><p>A discovery scan is not in progress. The previous discovery scan was completed or aborted. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab43e699168225cc498bb7d90bdab7c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43e699168225cc498bb7d90bdab7c96">&#9670;&nbsp;</a></span>TargetPowerState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1tm.html#ab43e699168225cc498bb7d90bdab7c96">nn::tm::TargetPowerState</a> : int32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hardware power states for targets. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab43e699168225cc498bb7d90bdab7c96ac4517348258d672e0b2f7587ae48bb44"></a>TargetPowerState_Unknown&#160;</td><td class="fielddoc"><p>The power state of the target is unknown. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab43e699168225cc498bb7d90bdab7c96afcc31aaf70b4913a59d039712a7bb794"></a>TargetPowerState_Off&#160;</td><td class="fielddoc"><p>The target has been powered off. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab43e699168225cc498bb7d90bdab7c96a25b96ffa1730605db483e8ad21467f2d"></a>TargetPowerState_On&#160;</td><td class="fielddoc"><p>The target is powered on. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab43e699168225cc498bb7d90bdab7c96a0b264ab42915cf13511f0c540fa2e9c1"></a>TargetPowerState_Asleep&#160;</td><td class="fielddoc"><p>The target is asleep. </p>
</td></tr>
</table>

</div>
</div>
<a id="a65c4c275de00753bdcb270212e8d603c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c4c275de00753bdcb270212e8d603c">&#9670;&nbsp;</a></span>TargetProgramState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1tm.html#a65c4c275de00753bdcb270212e8d603c">nn::tm::TargetProgramState</a> : int32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Program states on a target. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a65c4c275de00753bdcb270212e8d603ca5b1d907c9dbe701f64ae31aca109e105"></a>TargetProgramState_NoProgram&#160;</td><td class="fielddoc"><p>No program is currently loaded onto the target. </p>
</td></tr>
<tr><td class="fieldname"><a id="a65c4c275de00753bdcb270212e8d603cac9e7ca3c2bb11e34400a06606b54bca0"></a>TargetProgramState_Loading&#160;</td><td class="fielddoc"><p>The program is being loaded onto the target. </p>
</td></tr>
<tr><td class="fieldname"><a id="a65c4c275de00753bdcb270212e8d603cab88d6a63c04d44c02954fbb0cd3348ef"></a>TargetProgramState_Loaded&#160;</td><td class="fielddoc"><p>The program has been loaded onto the target. This program has not been started. </p>
</td></tr>
<tr><td class="fieldname"><a id="a65c4c275de00753bdcb270212e8d603ca8d090882df600b38b05f9fdd8b11203d"></a>TargetProgramState_Running&#160;</td><td class="fielddoc"><p>The program has been loaded and is running. </p>
</td></tr>
<tr><td class="fieldname"><a id="a65c4c275de00753bdcb270212e8d603caa08957d9eac76f784fa70f0d70028c50"></a>TargetProgramState_Halted&#160;</td><td class="fielddoc"><p>The program has been halted. </p>
</td></tr>
</table>

</div>
</div>
<a id="aa59a34a84efb360bab2a0ffc81424f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa59a34a84efb360bab2a0ffc81424f85">&#9670;&nbsp;</a></span>TargetConnectionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1tm.html#aa59a34a84efb360bab2a0ffc81424f85">nn::tm::TargetConnectionType</a> : int32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to specify how the target is connected to the host. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa59a34a84efb360bab2a0ffc81424f85af38a71ad2fab37a8f5d71c81761951cc"></a>TargetConnectionType_Unknown&#160;</td><td class="fielddoc"><p>The target connection type is unknown. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa59a34a84efb360bab2a0ffc81424f85a1e13d7f3b9474aa56a98e949cada419e"></a>TargetConnectionType_Usb&#160;</td><td class="fielddoc"><p>The target is connected via a USB connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa59a34a84efb360bab2a0ffc81424f85aa0423cc745714405d0c664c54a01d1f3"></a>TargetConnectionType_Ethernet&#160;</td><td class="fielddoc"><p>The target is connected via an ethernet connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa59a34a84efb360bab2a0ffc81424f85a5f839c5fd6e0695538d03737a5262364"></a>TargetConnectionType_Future&#160;</td><td class="fielddoc"><p>Reserved for future use. </p>
</td></tr>
</table>

</div>
</div>
<a id="a45342c02e85eb2eacb90f4b44f9cde6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45342c02e85eb2eacb90f4b44f9cde6d">&#9670;&nbsp;</a></span>TargetHardwareType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1tm.html#a45342c02e85eb2eacb90f4b44f9cde6d">nn::tm::TargetHardwareType</a> : int32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to specify the hardware type of the target. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a45342c02e85eb2eacb90f4b44f9cde6da9fc34c0dd4b9f5d7fa59587fdf89f3ee"></a>TargetHardwareType_Unknown&#160;</td><td class="fielddoc"><p>The target type is unknown. </p>
</td></tr>
<tr><td class="fieldname"><a id="a45342c02e85eb2eacb90f4b44f9cde6dac5fae7a3c9795fd97127279617b4b938"></a>TargetHardwareType_Edev&#160;</td><td class="fielddoc"><p>The target type is an EDEV. </p>
</td></tr>
<tr><td class="fieldname"><a id="a45342c02e85eb2eacb90f4b44f9cde6da0096c2f3455a7ed6d4c3b4b1c9b6404e"></a>TargetHardwareType_Sdev&#160;</td><td class="fielddoc"><p>The target type is an SDEV. </p>
</td></tr>
<tr><td class="fieldname"><a id="a45342c02e85eb2eacb90f4b44f9cde6dad7e9af390525b60373bf94dfbe973b80"></a>TargetHardwareType_Sim&#160;</td><td class="fielddoc"><p>The target type is a simulated target. </p>
</td></tr>
<tr><td class="fieldname"><a id="a45342c02e85eb2eacb90f4b44f9cde6da3fa88cf2292f41534bf527ed5d4c111f"></a>TargetHardwareType_Hdev&#160;</td><td class="fielddoc"><p>The target type is an HDEV. </p>
</td></tr>
<tr><td class="fieldname"><a id="a45342c02e85eb2eacb90f4b44f9cde6da432796d22642077e79842b76dc21059b"></a>TargetHardwareType_Adev&#160;</td><td class="fielddoc"><p>The target type is an ADEV. </p>
</td></tr>
<tr><td class="fieldname"><a id="a45342c02e85eb2eacb90f4b44f9cde6daf0774c8eaeb5431a13926579ba2fdfd2"></a>TargetHardwareType_SdevD&#160;</td><td class="fielddoc"><p>The target type is an SDEV-D. </p>
</td></tr>
<tr><td class="fieldname"><a id="a45342c02e85eb2eacb90f4b44f9cde6dab325131fc51886e7e5f80e1b7d459d44"></a>TargetHardwareType_EdevD&#160;</td><td class="fielddoc"><p>The target type is an EDEV-D. </p>
</td></tr>
<tr><td class="fieldname"><a id="a45342c02e85eb2eacb90f4b44f9cde6da323c154fd9a4e29ddf5637dca70a0426"></a>TargetHardwareType_Future&#160;</td><td class="fielddoc"><p>Reserved for future use. </p>
</td></tr>
</table>

</div>
</div>
<a id="a05f46629dc9dc5852868677b0f3b2448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f46629dc9dc5852868677b0f3b2448">&#9670;&nbsp;</a></span>TargetStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1tm.html#a05f46629dc9dc5852868677b0f3b2448">nn::tm::TargetStatus</a> : int32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to specify the connection status of the target. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a05f46629dc9dc5852868677b0f3b2448a7803552d039e5eff2252d5619d26db7a"></a>TargetStatus_Unknown&#160;</td><td class="fielddoc"><p>The target status is unknown. </p>
</td></tr>
<tr><td class="fieldname"><a id="a05f46629dc9dc5852868677b0f3b2448a8b2050ce8da0e2fce72df6e898efdecc"></a>TargetStatus_Disconnected&#160;</td><td class="fielddoc"><p>The target is disconnected from Target Manager. </p>
</td></tr>
<tr><td class="fieldname"><a id="a05f46629dc9dc5852868677b0f3b2448ab104ed0ad936c73abbfc43076fb4d875"></a>TargetStatus_Disconnecting&#160;</td><td class="fielddoc"><p>The target is being disconnected from Target Manager. </p>
</td></tr>
<tr><td class="fieldname"><a id="a05f46629dc9dc5852868677b0f3b2448a5ca0076cc1bcdd4c0ca5944857137df6"></a>TargetStatus_Connected&#160;</td><td class="fielddoc"><p>The target is connected to Target Manager. </p>
</td></tr>
<tr><td class="fieldname"><a id="a05f46629dc9dc5852868677b0f3b2448ac4228061a1d2e70ead1fa84f06998afe"></a>TargetStatus_Connecting&#160;</td><td class="fielddoc"><p>The target is being connected to Target Manager. </p>
</td></tr>
<tr><td class="fieldname"><a id="a05f46629dc9dc5852868677b0f3b2448aa6d0b4471a3ff4e6617c4dedc43d0141"></a>TargetStatus_Asleep&#160;</td><td class="fielddoc"><p>The target is asleep. </p>
</td></tr>
<tr><td class="fieldname"><a id="a05f46629dc9dc5852868677b0f3b2448a2e54c1c39f73a3049d74442b5f726a91"></a>TargetStatus_PoweringOn&#160;</td><td class="fielddoc"><p>The target is powering on. </p>
</td></tr>
<tr><td class="fieldname"><a id="a05f46629dc9dc5852868677b0f3b2448a481720da3cbd79f60363351932b70e22"></a>TargetStatus_PoweringOff&#160;</td><td class="fielddoc"><p>The target is powering off. </p>
</td></tr>
</table>

</div>
</div>
<a id="af7ab04e057ae2bf176cfe7f5b5699034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ab04e057ae2bf176cfe7f5b5699034">&#9670;&nbsp;</a></span>Error</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">nn::tm::Error</a> : int32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Target Manager API error codes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6"></a>Error_Ok&#160;</td><td class="fielddoc"><p>No error. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034ac6e2f50304c5f1ee1776ecf3caa5b617"></a>Error_Unknown&#160;</td><td class="fielddoc"><p>Unknown error. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034af5144589cf266fd500ed87e44dd27265"></a>Error_Timeout&#160;</td><td class="fielddoc"><p>Timeout. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a26cfc3f76d5dc7338ddf6fd81fdddbbd"></a>Error_NoConnection&#160;</td><td class="fielddoc"><p>No connection to Target Manager service. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034abd1c903d6b60cd879414d689ed5c3a0b"></a>Error_IncompatibleProtocol&#160;</td><td class="fielddoc"><p>Target Manager protocol version incompatible. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034af4d723d8e45769827fb6306e290b62aa"></a>Error_InvalidOpcode&#160;</td><td class="fielddoc"><p>Invalid protocol opcode. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a2b25b9a09f2add5e52b828ff707cbc99"></a>Error_TargetBusy&#160;</td><td class="fielddoc"><p>The requested target is busy. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a6d895311a7152461b10680039ce017fd"></a>Error_TargetUnavailable&#160;</td><td class="fielddoc"><p>Active target no longer available. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a421a6fab38ca3694fe42edc768634b6f"></a>Error_InvalidAddress&#160;</td><td class="fielddoc"><p>Invalid memory address. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034af3a88ae0129383fabfa419cd4660c54d"></a>Error_ExecutableNotFound&#160;</td><td class="fielddoc"><p>Requested executable file was not found. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a34e74783a4dddc0d02f07be98cc991f1"></a>Error_InvalidTarget&#160;</td><td class="fielddoc"><p>Invalid target specified. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a442a2efec8e197708a65d4fadafcd981"></a>Error_InvalidResponse&#160;</td><td class="fielddoc"><p>Invalid value returned. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034ae529b6aa16fac809546b3dcc87edebf4"></a>Error_TargetDuplicated&#160;</td><td class="fielddoc"><p>Target already exists. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034aa2a0c3e74cd8ee2ed200b7e05b574957"></a>Error_InvalidParameter&#160;</td><td class="fielddoc"><p>One of the parameter(s) is invalid. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034af6e604a8bd361dc3a101573925c8ff27"></a>Error_InvalidDeviceHandle&#160;</td><td class="fielddoc"><p>The HID handle is invalid. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034ab41a31cd4a6b685068993333a64e5797"></a>Error_InvalidController&#160;</td><td class="fielddoc"><p>The controller index is invalid. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a2417492ffada4fec9860c5537294f322"></a>Error_ExecutableNotCompatible&#160;</td><td class="fielddoc"><p>The executable file is not compatible with the hardware. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a8d535ba9b218d52e6013d6c5e0cc4b40"></a>Error_BufferTooSmall&#160;</td><td class="fielddoc"><p>A provided buffer is too small. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a60de56b739a259b0f382950554f6c354"></a>Error_InternalError&#160;</td><td class="fielddoc"><p>An "internal error" occurred. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034adc08f55d06020162d442cee61b7bf4e8"></a>Error_Cancelled&#160;</td><td class="fielddoc"><p>Operation cancelled. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034af3c5a197f285e16d3baa3d35714ba5c5"></a>Error_ConnectVersionError&#160;</td><td class="fielddoc"><p>Incorrect version connection problem. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a9f14d5b4edd81a9f63d525860632f75e"></a>Error_ConnectFailed&#160;</td><td class="fielddoc"><p>Connect failure due to unknown reason. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a27a641f35dfeb3a5aa3111b47e0bba73"></a>Error_NotImplemented&#160;</td><td class="fielddoc"><p>An API or feature is not implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034aa3e0d3b30af3b8cc9b037462f02c76d9"></a>Error_IncompatibleTmApiVersion&#160;</td><td class="fielddoc"><p>The client and Target Manager API versions are not compatible. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a893cebc3895216ce4a10f27256a1691b"></a>Error_DebuggingUnavailable&#160;</td><td class="fielddoc"><p>Debugging service isn't available. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a2544f223b05a02c4f8b3e0a40cf81655"></a>Error_NotBackwardsCompatible&#160;</td><td class="fielddoc"><p>The packet failed to send because the specified task is not backwards compatible an older target i.e. the target is not up to date with this version of Target Manager. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034abb6b1b234ade06d7e083d452bdb6a002"></a>Error_ServiceUnavailable&#160;</td><td class="fielddoc"><p>The service that handles this isn't available. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a8ae3dd727e77c35c116e31c4e8ab0c13"></a>Error_TargetDiscoveryAlreadyStarted&#160;</td><td class="fielddoc"><p>Target discovery has already started. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a97149d21fd19e7b3edf44557c3b9eff1"></a>Error_ConnectFailedLogServer&#160;</td><td class="fielddoc"><p>The connect failed because log service is unavailable. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034ae6b882faf47f5f6575a3518c2eb2e4c0"></a>Error_TargetIoSearchComplete&#160;</td><td class="fielddoc"><p>The target Io search is finished we have found all there is to find. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a14d9ccbd7a376c3092b622cb05606072"></a>Error_TargetIoInsufficientSpace&#160;</td><td class="fielddoc"><p>Not enough space on the memory card. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a47bf9bda326d373ae9577890235cb58e"></a>Error_TargetIoNoMemoryCard&#160;</td><td class="fielddoc"><p>No memory card inserted in the device. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a9bfc82606044fe622e4e89e1d01073dc"></a>Error_TargetIoPathAlreadyExists&#160;</td><td class="fielddoc"><p>Path already exists on the memory card. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034afe6d594bd8e35c893144de7203547b0a"></a>Error_TargetIoMemoryCardError&#160;</td><td class="fielddoc"><p>Problem reading the memory card. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a9f43433fed125510ae9aa5b9743a718c"></a>Error_TargetAsleep&#160;</td><td class="fielddoc"><p>Target is asleep. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a1a0875d2189d91d4896d73f796220055"></a>Error_NoProgramLoaded&#160;</td><td class="fielddoc"><p>No program is loaded to the target. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a84a294a637d26b172a05f24d79099cc7"></a>Error_IncompatibleTargetManager&#160;</td><td class="fielddoc"><p>This function is not implemented in the detected version of Target Manager. This can occur if client code is attempting to call a new function on an older version of Targer Manager. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034abf2bff45a561b4cea89e81a12ba5b046"></a>Error_TargetNotConnected&#160;</td><td class="fielddoc"><p>Requested action requires a connection to the target. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034ac6ea81ad9887986fac35d7decd27d970"></a>Error_UnableToCreateCoredump&#160;</td><td class="fielddoc"><p>Unable to create coredump file. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034aa04eaf138217ec17fa306333e821ad44"></a>Error_InvalidHtcsAddress&#160;</td><td class="fielddoc"><p>An invalid HTCS address was requested. HTCS addresses must be of the form "xxx.xxx.xxx.xxx:yyyyy". </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a2054d2448c6651ec4209ad1534c78e6f"></a>Error_DuplicateHtcsAddress&#160;</td><td class="fielddoc"><p>An HTCS reservation was requested that conflicts with an existing HTCS reservation with the same ip address and port number or the same server and port names. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a8e079fd20b061341675a25407272fef7"></a>Error_HtcsAddressNotFound&#160;</td><td class="fielddoc"><p>No HTCS entry exists with the specified address. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a56ad41d3319812727f1545e361d966f8"></a>Error_OtherUser&#160;</td><td class="fielddoc"><p>The target is in use by another user. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a75db7b8f9013d6dbeb69d0badb7b0c0e"></a>Error_InvalidScreenshotFolderSetting&#160;</td><td class="fielddoc"><p>Invalid screenshot folder setting. Check your screenshot settings in Options. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a21d5e9683b8f2967c1f43329f4fa936e"></a>Error_InvalidScreenshotFilenameSetting&#160;</td><td class="fielddoc"><p>Invalid screenshot filename setting. Check your screenshot settings in Options. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034ae44d27ce0cc5c40ce1e9de74870df0fe"></a>Error_HtcsEntryNotFound&#160;</td><td class="fielddoc"><p>No HTCS entry exists with the specified peer and port name. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a7173ccac3abf473b84f2d597f680ab09"></a>Error_HtcsEventHandleAlreadyRegistered&#160;</td><td class="fielddoc"><p>The specified event handle for HTCS updates has already been registered. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a3c00ed74bb7744bf80c86b01ca74e928"></a>Error_HtcsEventHandleNotFound&#160;</td><td class="fielddoc"><p>The specified event handle for HTCS updates has not been registered. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a733efd1bda5a124c3adb423213c7cfad"></a>Error_InvalidTargetName&#160;</td><td class="fielddoc"><p>Invalid target name. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a33e464c95c2c7736c677a2d185974eaa"></a>Error_ProgramEventHandleAlreadyRegistered&#160;</td><td class="fielddoc"><p>Program event handle already registered. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a1611631547167cb88790009e74b331f3"></a>Error_InvalidWorkingDirectory&#160;</td><td class="fielddoc"><p>Invalid working directory specified. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a02e26582bb7a856d2326f80a4e7f251d"></a>Error_InvalidVideoFolderSetting&#160;</td><td class="fielddoc"><p>Invalid video folder setting. Check your video settings in Options. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a3e6c1f3525b2de6b56c768fb056fd53d"></a>Error_InvalidVideoFilenameSetting&#160;</td><td class="fielddoc"><p>Invalid video filename setting. Check your video settings in Options. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a175d1c594d2fa9396a978f0f912a9f09"></a>Error_ProgramStartFailed&#160;</td><td class="fielddoc"><p>Failed to StartProgram. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034aaa9e454365a6ec41bca42f1f608a303d"></a>Error_ProgramNotLoaded&#160;</td><td class="fielddoc"><p>Data has not finished loading. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034aabe00ec867f79cd851bb13d9220f0d5f"></a>Error_ProgramInvalidArguments&#160;</td><td class="fielddoc"><p>Invalid program arguments. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a7fed45c13851a71a9f632bc146400da1"></a>Error_ProgramCreateFailed&#160;</td><td class="fielddoc"><p>Failed to create a program with path. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a00835e2b9464daf288ecc4e15a67cae7"></a>Error_ProgramIsRunning&#160;</td><td class="fielddoc"><p>Program already running. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a94da9a628f4517a5a6bb619bb74d8a2f"></a>Error_ProgramNotRunning&#160;</td><td class="fielddoc"><p>Desired program is not running. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a78fface09b8ea9dc908f9bd21cf0772f"></a>Error_ProgramNotHalted&#160;</td><td class="fielddoc"><p>Program not halted. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a94c6ee2d42e406419ee6bec07cb0d319"></a>Error_ProgramAlreadyStarted&#160;</td><td class="fielddoc"><p>Program already started. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a2272b92fa42311697d693be67b800711"></a>Error_ProgramHalted&#160;</td><td class="fielddoc"><p>Program halted. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a46c0d5d92b4be0744d2ccdd93aded7ec"></a>Error_ProgramUnknownRegister&#160;</td><td class="fielddoc"><p>Unknown register. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a897880e6c90de71632247044b179e96b"></a>Error_ProgramAttachFailed&#160;</td><td class="fielddoc"><p>Failed to attach to a program by program Id. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a2394c98c5eb1a127935ad144dc3a950b"></a>Error_ProgramNotStarted&#160;</td><td class="fielddoc"><p>Program hasn't been started yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a0f7215a105e3a727a922c28f6474c7d4"></a>Error_ProgramDebuggingDisabled&#160;</td><td class="fielddoc"><p>Debugging is disabled for this program. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034ac6d624313577be738b3f75b5a7984177"></a>Error_ProgramPackageIncomplete&#160;</td><td class="fielddoc"><p>A file is missing from the EXE. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034acef1b8626effaac845bd1c9210893a80"></a>Error_ProgramBeingDebugged&#160;</td><td class="fielddoc"><p>Program is currently locked for debugging. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034ac5ab471961d23e8f73abaa3003b49f27"></a>Error_InvalidPathSpecified&#160;</td><td class="fielddoc"><p>An invalid path was specified. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a24b9ebdf341f498afdb6cdc9a19bfd62"></a>Error_RemoteVideoNotRecording&#160;</td><td class="fielddoc"><p>Remote video is not recording. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a658d85f26db37b7afb05e3eee3ce5b53"></a>Error_RemoteVideoRecording&#160;</td><td class="fielddoc"><p>Remote video recording in progress. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a0211bddecc2afd579c01de1adffa94ff"></a>Error_RemoteVideoNotAvailable&#160;</td><td class="fielddoc"><p>Remote video is not available. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034ac79bcf48eb3f4a4925643505c9998d17"></a>Error_RemoteVideoIncorrectBufferSize&#160;</td><td class="fielddoc"><p>An incorrect buffer size was specified. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a04308a25c2016035a98330936f3f2ae6"></a>Error_RemoteVideoEventRegistered&#160;</td><td class="fielddoc"><p>A remote video event has already been registered for the specified target. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034abbd5e23e4e09894eaeb7fcb4c269e2e2"></a>Error_RemoteVideoEventNotRegistered&#160;</td><td class="fielddoc"><p>The specified remote video event has not been registered. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a94d279d8de5aa27a57444e6ce1010623"></a>Error_RemoteVideoNotInitialized&#160;</td><td class="fielddoc"><p>A remote video stream has not been initialized. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a208ea47352e5f3c1dc9ab9a5231c6f8f"></a>Error_TargetLogNotAvailable&#160;</td><td class="fielddoc"><p>Target logs are not available. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034af3e248e82c2ede8e0f93a9443b7de01d"></a>Error_TargetLogFileDoesNotExists&#160;</td><td class="fielddoc"><p>Target log file does not exists. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a2676f8205c60bd45bbd2cd02180f227f"></a>Error_TargetLogFileInProgress&#160;</td><td class="fielddoc"><p>Target file logging is already in progress. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a22fadffa7d6d16020b5c3949daa33258"></a>Error_TargetLogFilePathInvalid&#160;</td><td class="fielddoc"><p>Target log file path is invalid or not available. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ab04e057ae2bf176cfe7f5b5699034a933b5d02728643753a352ec2119552c5"></a>Error_ProgramEventHandleNotFound&#160;</td><td class="fielddoc"><p>Program event handle not found. </p>
</td></tr>
</table>

</div>
</div>
<a id="aed75c59e3dcda10a6cf06c0048a86769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed75c59e3dcda10a6cf06c0048a86769">&#9670;&nbsp;</a></span>DumpType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1tm.html#aed75c59e3dcda10a6cf06c0048a86769">nn::tm::DumpType</a> : int32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of dump file to create. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aed75c59e3dcda10a6cf06c0048a86769aebc7cf1e7bc9149cd938ec99cf7b57b2"></a>DumpType_Quick&#160;</td><td class="fielddoc"><p>Quick dump. </p>
</td></tr>
<tr><td class="fieldname"><a id="aed75c59e3dcda10a6cf06c0048a86769a85dcca74ab4839db2f3f6a1de6b2fa57"></a>DumpType_Full&#160;</td><td class="fielddoc"><p>Full dump. </p>
</td></tr>
</table>

</div>
</div>
<a id="a8924b817752c0fc71eeaaf38ccfde4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8924b817752c0fc71eeaaf38ccfde4d4">&#9670;&nbsp;</a></span>VideoRecordingExitReason</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1tm.html#a8924b817752c0fc71eeaaf38ccfde4d4">nn::tm::VideoRecordingExitReason</a> : int32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit reason for the last recorded video. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8924b817752c0fc71eeaaf38ccfde4d4a5b2012d1e335a7f4fe9001b838fd6c92"></a>VideoRecordingExitReason_None&#160;</td><td class="fielddoc"><p>Video recording has not been requested. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8924b817752c0fc71eeaaf38ccfde4d4afb6a388e3f5da6d31a706de26e28933c"></a>VideoRecordingExitReason_TimeCompleted&#160;</td><td class="fielddoc"><p>The specified time elapsed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8924b817752c0fc71eeaaf38ccfde4d4aabc958a9c610b4b3fcf41d8f687a9883"></a>VideoRecordingExitReason_StopTriggered&#160;</td><td class="fielddoc"><p><a class="el" href="namespacenn_1_1tm.html#a9298df3fe428d287f3271cb54b9fe01b" title="Stops video recording.">nn::tm::StopVideoRecording</a> was called. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8924b817752c0fc71eeaaf38ccfde4d4ab000407e096f18c90fad8f0849786f14"></a>VideoRecordingExitReason_GetVideoFailed&#160;</td><td class="fielddoc"><p>The target video was not available. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8924b817752c0fc71eeaaf38ccfde4d4aef7ee091f9efa24f8984f73d9aa8e55b"></a>VideoRecordingExitReason_ConnectionInterrupted&#160;</td><td class="fielddoc"><p>Connection to the target was interrupted. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8924b817752c0fc71eeaaf38ccfde4d4aebd77dd5994f18e1c574cc1073f71d34"></a>VideoRecordingExitReason_UnexpectedError&#160;</td><td class="fielddoc"><p>Unexpected error. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab1bae8c19e9dcc5c5590e4a0a3fc2348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1bae8c19e9dcc5c5590e4a0a3fc2348">&#9670;&nbsp;</a></span>GetTargetCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetTargetCount </td>
          <td>(</td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>pOutTargetCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of targets in Target Manager. </p>
<p>All targets that have been added to Target Manager will be counted. This includes targets that are asleep, powered off, or have an unknown status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutTargetCount</td><td>The number of targets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code.</dd></dl>
<p> <b>Details</b> <br  />
 The returned number of targets can be used to determine the proper buffer size for <a class="el" href="namespacenn_1_1tm.html#a50e6b98b7fd6773d8c896ffdd7dfe48e" title="Returns the array of targets in Target Manager.">GetTargets()</a>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a50">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a50e6b98b7fd6773d8c896ffdd7dfe48e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50e6b98b7fd6773d8c896ffdd7dfe48e">&#9670;&nbsp;</a></span>GetTargets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetTargets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> *&#160;</td>
          <td class="paramname"><em>pOutTargetsBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>pOutBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the array of targets in Target Manager. </p>
<p>All targets that have been added to Target Manager will be returned. This includes targets that are asleep, powered off, or have an unknown status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutTargetsBuffer</td><td>A client preallocated buffer for storing TargetHandles. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutBufferSize</td><td>The size, in number of elements, of the returned preallocated buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size, in number of elements, of the client preallocated buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code.</dd></dl>
<p> <b>Details</b> <br  />
 The returned TargetHandles can be used to acquire additional Target information, such as GetTargetName( targetHandle ). </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a51">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af16f8646436f34f1e13d98856ada479c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af16f8646436f34f1e13d98856ada479c">&#9670;&nbsp;</a></span>GetDefaultTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetDefaultTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> *&#160;</td>
          <td class="paramname"><em>pOutTargetHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a> of the default target in Target Manager. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutTargetHandle</td><td>The <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a> of the current default target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code.</dd></dl>
<p> <b>Details</b> <br  />
 The default target will be the target used when launching applications from Visual Studio. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_remote_video_8cpp-example.html#a19">TmRemoteVideo.cpp</a>, and <a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a52">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a9b59efc89404abec7b18d8343129edb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b59efc89404abec7b18d8343129edb0">&#9670;&nbsp;</a></span>SetDefaultTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::SetDefaultTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the default target in Target Manager to the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a> of the desired default target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code.</dd></dl>
<p> <b>Details</b> <br  />
 The default target will be the target used when launching applications from Visual Studio. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a76">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="affc7631993d4d81734fd04ff6801ed1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc7631993d4d81734fd04ff6801ed1e">&#9670;&nbsp;</a></span>StartDiscovery()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::StartDiscovery </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>msTimeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a discovery scan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msTimeout</td><td>The amount of time in milliseconds before the discovery scan is completed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a37">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a5c5f587a589e9b6811e43e3bacd97608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5f587a589e9b6811e43e3bacd97608">&#9670;&nbsp;</a></span>AbortDiscovery()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::AbortDiscovery </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aborts the current discovery scan. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code.</dd></dl>
<p> <b>Details</b> <br  />
 If a discovery scan is not in progress, <a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> is returned. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a88">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a955d2e7c36c4b9e6621d706e7cf6a3dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a955d2e7c36c4b9e6621d706e7cf6a3dd">&#9670;&nbsp;</a></span>GetDiscoveryState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetDiscoveryState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1tm.html#a2422234500de1643cba6348b73cf2289">DiscoveryState</a> *&#160;</td>
          <td class="paramname"><em>pOutDiscoveryState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current state of the discovery scan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutDiscoveryState</td><td>The current state of the discovery scan.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code.</dd></dl>
<p> <b>Details</b> <br  />
 If a scan is aborted with <a class="el" href="namespacenn_1_1tm.html#a5c5f587a589e9b6811e43e3bacd97608" title="Aborts the current discovery scan.">AbortDiscovery()</a>, the returned state will be DiscoveryState_Complete. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a40">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3925fbf4c1069cdcbc537a96fb1f6746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3925fbf4c1069cdcbc537a96fb1f6746">&#9670;&nbsp;</a></span>GetDiscoveryTargetCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetDiscoveryTargetCount </td>
          <td>(</td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>pOutDiscoveryTargetCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of discovered targets from the last executed discovery scan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutDiscoveryTargetCount</td><td>The number of discovered targets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a41">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aa309bdadb5f56cde33525a5ce5dfedd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa309bdadb5f56cde33525a5ce5dfedd5">&#9670;&nbsp;</a></span>GetDiscoveryTargets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetDiscoveryTargets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_discovery_handle.html">DiscoveryHandle</a> *&#160;</td>
          <td class="paramname"><em>pOutDiscoveredTargetsBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>pOutBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a buffer containing DiscoveryHandles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutDiscoveredTargetsBuffer</td><td>The client preallocated buffer for storing DiscoveryHandles. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutBufferSize</td><td>The size, in number of elements, of the returned preallocated buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size, in number of elements, of the client preallocated buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a43">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a4fc83f1ebddc0b361cbbaccc9fbdc058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc83f1ebddc0b361cbbaccc9fbdc058">&#9670;&nbsp;</a></span>GetDiscoveryTargetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetDiscoveryTargetName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_name.html">TargetName</a> *&#160;</td>
          <td class="paramname"><em>pOutTargetName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_discovery_handle.html">DiscoveryHandle</a>&#160;</td>
          <td class="paramname"><em>discoveryHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the name of the discovered target specified by the <a class="el" href="structnn_1_1tm_1_1_discovery_handle.html" title="A unique handle for interacting with discovered targets.">DiscoveryHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutTargetName</td><td>The client preallocated buffer to store the target name. The returned buffer is null-terminated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">discoveryHandle</td><td>The handle of the discovered target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a44">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1102c1e9497e0879b92c40abe6751132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1102c1e9497e0879b92c40abe6751132">&#9670;&nbsp;</a></span>GetDiscoveryTargetIpAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetDiscoveryTargetIpAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_ip_address.html">TargetIpAddress</a> *&#160;</td>
          <td class="paramname"><em>pOutTargetIpAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_discovery_handle.html">DiscoveryHandle</a>&#160;</td>
          <td class="paramname"><em>discoveryHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the ip address of the discovered target specified by the <a class="el" href="structnn_1_1tm_1_1_discovery_handle.html" title="A unique handle for interacting with discovered targets.">DiscoveryHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutTargetIpAddress</td><td>The client preallocated buffer to store the ip address. The returned buffer is null-terminated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">discoveryHandle</td><td>The handle of the discovered target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a45">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab6c051987b95b741c68cb94aa5d025c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c051987b95b741c68cb94aa5d025c6">&#9670;&nbsp;</a></span>GetDiscoveryTargetSerialNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetDiscoveryTargetSerialNumber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_serial_number.html">TargetSerialNumber</a> *&#160;</td>
          <td class="paramname"><em>pOutTargetSerialNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_discovery_handle.html">DiscoveryHandle</a>&#160;</td>
          <td class="paramname"><em>discoveryHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the serial number of the discovered target specified by the <a class="el" href="structnn_1_1tm_1_1_discovery_handle.html" title="A unique handle for interacting with discovered targets.">DiscoveryHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutTargetSerialNumber</td><td>The client preallocated buffer to store the serial number. The returned buffer is null-terminated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">discoveryHandle</td><td>The handle of the discovered target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a46">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af8d33f738ce669a3c0f08b4c84734840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d33f738ce669a3c0f08b4c84734840">&#9670;&nbsp;</a></span>GetDiscoveryTargetMacAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetDiscoveryTargetMacAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_mac_address.html">TargetMacAddress</a> *&#160;</td>
          <td class="paramname"><em>pOutTargetMacAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_discovery_handle.html">DiscoveryHandle</a>&#160;</td>
          <td class="paramname"><em>discoveryHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the mac address of the discovered target specified by the <a class="el" href="structnn_1_1tm_1_1_discovery_handle.html" title="A unique handle for interacting with discovered targets.">DiscoveryHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutTargetMacAddress</td><td>The client preallocated buffer to store the mac address. The returned buffer is null-terminated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">discoveryHandle</td><td>The handle of the discovered target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a47">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a6758ab77b140308e0082326673fea42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6758ab77b140308e0082326673fea42c">&#9670;&nbsp;</a></span>GetDiscoveryTargetHardwareType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetDiscoveryTargetHardwareType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1tm.html#a45342c02e85eb2eacb90f4b44f9cde6d">TargetHardwareType</a> *&#160;</td>
          <td class="paramname"><em>pOutTargetHardwareType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_discovery_handle.html">DiscoveryHandle</a>&#160;</td>
          <td class="paramname"><em>discoveryHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the hardware type of the discovered target specified by the <a class="el" href="structnn_1_1tm_1_1_discovery_handle.html" title="A unique handle for interacting with discovered targets.">DiscoveryHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutTargetHardwareType</td><td>The hardware type of the target. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">discoveryHandle</td><td>The handle of the discovered target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a48">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a31ebc666c416974264c7677c4ecea001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ebc666c416974264c7677c4ecea001">&#9670;&nbsp;</a></span>GetDiscoveryTargetConnectionType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetDiscoveryTargetConnectionType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1tm.html#aa59a34a84efb360bab2a0ffc81424f85">TargetConnectionType</a> *&#160;</td>
          <td class="paramname"><em>pOutTargetConnectionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_discovery_handle.html">DiscoveryHandle</a>&#160;</td>
          <td class="paramname"><em>discoveryHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the connection type of the discovered target specified by the <a class="el" href="structnn_1_1tm_1_1_discovery_handle.html" title="A unique handle for interacting with discovered targets.">DiscoveryHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutTargetConnectionType</td><td>The connection type of the hardware, such as USB or ethernet. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">discoveryHandle</td><td>The handle of the discovered target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>

</div>
</div>
<a id="abc69cab46a97618e5bf6331f9c67abef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc69cab46a97618e5bf6331f9c67abef">&#9670;&nbsp;</a></span>GetDiscoveryTargetAgentVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetDiscoveryTargetAgentVersion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_agent_version.html">TargetAgentVersion</a> *&#160;</td>
          <td class="paramname"><em>pOutTargetAgentVersion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_discovery_handle.html">DiscoveryHandle</a>&#160;</td>
          <td class="paramname"><em>discoveryHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DEPRECATED. </p>
<p>Please use GetTargetFirmwareVersion. Returns the agent version of the discovered target specified by the <a class="el" href="structnn_1_1tm_1_1_discovery_handle.html" title="A unique handle for interacting with discovered targets.">DiscoveryHandle</a>. Only valid for EDEV targets. Attempting to issue this command to a discovered SDEV target will return the Error_TargetNotConnected error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutTargetAgentVersion</td><td>The target major, minor, micro, and revision versions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">discoveryHandle</td><td>The handle of the discovered target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. If called on a discovered SDEV target, the Error_TargetNotConnected error will be returned. To determine the SDEV target agent version, connect to the target and use <a class="el" href="namespacenn_1_1tm.html#a069317a9491ead7a8c602255e2e123ff" title="DEPRECATED.">GetTargetAgentVersion()</a>. </dd></dl>

</div>
</div>
<a id="af02f790b535ed08d05286d21d85809b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02f790b535ed08d05286d21d85809b9">&#9670;&nbsp;</a></span>GetDiscoveryTargetUser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetDiscoveryTargetUser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_user.html">TargetUser</a> *&#160;</td>
          <td class="paramname"><em>pOutTargetUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_discovery_handle.html">DiscoveryHandle</a>&#160;</td>
          <td class="paramname"><em>discoveryHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the last known user connected to the discovered target specified by the <a class="el" href="structnn_1_1tm_1_1_discovery_handle.html" title="A unique handle for interacting with discovered targets.">DiscoveryHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutTargetUser</td><td>A client preallocated buffer to contain the user of the discovered target. The user will be "" if no user is connected. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">discoveryHandle</td><td>The handle of the discovered target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a49">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a433ee979733abf98d33e410835c0b653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a433ee979733abf98d33e410835c0b653">&#9670;&nbsp;</a></span>AddTarget() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::AddTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> *&#160;</td>
          <td class="paramname"><em>pOutTargetHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1tm_1_1_target_ip_address.html">TargetIpAddress</a> *&#160;</td>
          <td class="paramname"><em>pIpAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a target specified by the ip address to Target Manager. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutTargetHandle</td><td>The <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a> of the newly added target. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pIpAddress</td><td>The null-terminated ip address of the target to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code.</dd></dl>
<p> <b>Details</b> <br  />
 The target specified by the ip address is not required to be present or powered on to be added to Target Manager. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a54">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af91d588d32d881224b13222e3231dc4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af91d588d32d881224b13222e3231dc4d">&#9670;&nbsp;</a></span>AddTarget() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::AddTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a> *&#160;</td>
          <td class="paramname"><em>pOutTargetHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_discovery_handle.html">DiscoveryHandle</a>&#160;</td>
          <td class="paramname"><em>discoveryHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a target specified by the <a class="el" href="structnn_1_1tm_1_1_discovery_handle.html" title="A unique handle for interacting with discovered targets.">DiscoveryHandle</a> to Target Manager. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutTargetHandle</td><td>The <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a> of the newly added target. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">discoveryHandle</td><td>The discovery handle of the target to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code.</dd></dl>
<p> <b>Details</b> <br  />
 To determine the discoveryHandle of the target to be added, use TmDiscoveryGetTargets(). Additional discovered target information can be acquired with the GetDiscoveryTarget methods. </p>

</div>
</div>
<a id="a020a3edb4b36e2af471b23a069d00c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a020a3edb4b36e2af471b23a069d00c5e">&#9670;&nbsp;</a></span>RemoveTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::RemoveTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a> from Target Manager. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the target to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a55">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a508371f9f38192a778047de636581413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508371f9f38192a778047de636581413">&#9670;&nbsp;</a></span>RemoveAllTargets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::RemoveAllTargets </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all targets from Target Manager. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a56">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a85c3f9c3c4d21eae6e748898d2e89add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85c3f9c3c4d21eae6e748898d2e89add">&#9670;&nbsp;</a></span>ConnectTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::ConnectTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connects to the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the target to be connected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a69">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a8b1335a874e1f2314d2789f11ea7f490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1335a874e1f2314d2789f11ea7f490">&#9670;&nbsp;</a></span>ForceConnectTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::ForceConnectTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forces a connection to the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>. </p>
<p>If the target is in use by another user, that user will be disconnected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the target to be connected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>

</div>
</div>
<a id="a37c08287b3ea934b53c9c3d1f2eb5176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c08287b3ea934b53c9c3d1f2eb5176">&#9670;&nbsp;</a></span>DisconnectTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::DisconnectTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnects from the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the target to be disconnected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a75">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a38525a0238284c8f0ff9a76ce10b2971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38525a0238284c8f0ff9a76ce10b2971">&#9670;&nbsp;</a></span>PowerOnTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::PowerOnTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Powers on the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the target to be powered on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code.</dd></dl>
<p> <b>Details</b> <br  />
 This control is only permitted for SDEV targets. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a83">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a5bbd49fd76124fc8d06c88ebfa9939d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bbd49fd76124fc8d06c88ebfa9939d3">&#9670;&nbsp;</a></span>PowerOffTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::PowerOffTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Powers off the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the target to be powered off.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a79">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a0f7f551be8c5378585a68f6974579d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7f551be8c5378585a68f6974579d7f">&#9670;&nbsp;</a></span>ResetTargetSoft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::ResetTargetSoft </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>. </p>
<p>Target Manager must be connected to the target to issue this command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the target to be reset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a80">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="abf5629fa64ca24271266aac23b3ce02a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5629fa64ca24271266aac23b3ce02a">&#9670;&nbsp;</a></span>ResetTargetHard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::ResetTargetHard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>. </p>
<p>Hard resets on SDEV targets do not require a connection to the target. Any existing connection to the SDEV target will be severed. Hard resets on EDEV targets require a connection to the target.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the target to be reset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a81">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aa16568cf76c9efc4a55c49970ed3b3a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16568cf76c9efc4a55c49970ed3b3a2">&#9670;&nbsp;</a></span>ShortPressPowerButton()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::ShortPressPowerButton </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emulates holding the Target's Power button down for one second. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the target to press Power button.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. If called on an EDEV target, the Error_InvalidTarget will be returned.</dd></dl>
<p> <b>Details</b> <br  />
 This control is only permitted for SDEV targets. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a85">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae3014495e915f0f4764927f97745a0cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3014495e915f0f4764927f97745a0cd">&#9670;&nbsp;</a></span>MiddlePressPowerButton()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::MiddlePressPowerButton </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emulates holding the Target's Power button down for four seconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the target to press Power button.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. If called on an EDEV target, the Error_InvalidTarget will be returned.</dd></dl>
<p> <b>Details</b> <br  />
 This control is only permitted for SDEV targets. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a86">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a01a4b5e7f005bac95378e7ee8363de82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a4b5e7f005bac95378e7ee8363de82">&#9670;&nbsp;</a></span>LongPressPowerButton()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::LongPressPowerButton </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emulates holding the Target's Power button down for eight seconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the target to press Power button.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. If called on an EDEV target, the Error_InvalidTarget will be returned.</dd></dl>
<p> <b>Details</b> <br  />
 This control is only permitted for SDEV targets. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a87">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a800c61b734b55dc4092f4fb67a52ca91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a800c61b734b55dc4092f4fb67a52ca91">&#9670;&nbsp;</a></span>GetTargetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetTargetName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_name.html">TargetName</a> *&#160;</td>
          <td class="paramname"><em>pOutTargetName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the target name of the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutTargetName</td><td>A client preallocated buffer to contain the name of the requested target. The returned buffer is null-terminated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a12">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab97d74050793e4f314ffc91153416aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97d74050793e4f314ffc91153416aca">&#9670;&nbsp;</a></span>GetTargetUser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetTargetUser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_user.html">TargetUser</a> *&#160;</td>
          <td class="paramname"><em>pOutTargetUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the user connected to the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutTargetUser</td><td>A client preallocated buffer to contain the user of the requested target. The user will be "" if no user is connected. The user will be "Unknown" the user status has not been queried for the target. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a30">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad73941e8a33d7ce3b6389e2ece60b486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad73941e8a33d7ce3b6389e2ece60b486">&#9670;&nbsp;</a></span>GetTargetIpAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetTargetIpAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_ip_address.html">TargetIpAddress</a> *&#160;</td>
          <td class="paramname"><em>pOutTargetIpAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the target ip address of the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutTargetIpAddress</td><td>A client preallocated buffer to contain the ip address of the requested target. The returned buffer is null-terminated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a15">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aebfc5817575397e282a0d2bcf0af3242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebfc5817575397e282a0d2bcf0af3242">&#9670;&nbsp;</a></span>GetTargetSerialNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetTargetSerialNumber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_serial_number.html">TargetSerialNumber</a> *&#160;</td>
          <td class="paramname"><em>pOutTargetSerialNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the target serial number of the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutTargetSerialNumber</td><td>A client preallocated buffer to contain the serial number of the requested target. The returned buffer is null-terminated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a18">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a9580b7cf83fd41575e9503d9cc99a248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9580b7cf83fd41575e9503d9cc99a248">&#9670;&nbsp;</a></span>GetTargetMacAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetTargetMacAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_mac_address.html">TargetMacAddress</a> *&#160;</td>
          <td class="paramname"><em>pOutTargetMacAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the mac address of the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutTargetMacAddress</td><td>A client preallocated buffer to contain the mac address of the requested target. The returned buffer is null-terminated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a21">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a5cf2dfc50667bdad60a5363e6f141e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf2dfc50667bdad60a5363e6f141e94">&#9670;&nbsp;</a></span>GetTargetStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetTargetStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1tm.html#a05f46629dc9dc5852868677b0f3b2448">TargetStatus</a> *&#160;</td>
          <td class="paramname"><em>pOutTargetStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the target connection status of the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutTargetStatus</td><td>The target status, such as connected, disconnected, or asleep. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a26">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a52ee418d82ed14a94a6b659e78f8bdc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ee418d82ed14a94a6b659e78f8bdc1">&#9670;&nbsp;</a></span>GetTargetConnectionType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetTargetConnectionType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1tm.html#aa59a34a84efb360bab2a0ffc81424f85">TargetConnectionType</a> *&#160;</td>
          <td class="paramname"><em>pOutTargetConnectionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the target connection type of the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutTargetConnectionType</td><td>The connection type of the hardware, such as USB or ethernet. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a27">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="abd844cc492fa70b5d85d825542b1f131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd844cc492fa70b5d85d825542b1f131">&#9670;&nbsp;</a></span>GetTargetHardwareType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetTargetHardwareType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1tm.html#a45342c02e85eb2eacb90f4b44f9cde6d">TargetHardwareType</a> *&#160;</td>
          <td class="paramname"><em>pOutTargetHardwareType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the hardware type of the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutTargetHardwareType</td><td>The hardware type of the target. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a28">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a069317a9491ead7a8c602255e2e123ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a069317a9491ead7a8c602255e2e123ff">&#9670;&nbsp;</a></span>GetTargetAgentVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetTargetAgentVersion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_agent_version.html">TargetAgentVersion</a> *&#160;</td>
          <td class="paramname"><em>pOutTargetAgentVersion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DEPRECATED. </p>
<p>Please use GetTargetFirmwareVersion. Returns the agent version of the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutTargetAgentVersion</td><td>The target major, minor, micro, and revision versions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
 SDEV targets require a one-time connection to Target Manager to acquire the agent version. If an SDEV target has not been connected to Target Manager, GetTargetAgentVersion will return <a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034abf2bff45a561b4cea89e81a12ba5b046" title="Requested action requires a connection to the target.">nn::tm::Error_TargetNotConnected</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>

</div>
</div>
<a id="a665c0ff1359e1f48262aee05f7d94b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665c0ff1359e1f48262aee05f7d94b7d">&#9670;&nbsp;</a></span>GetTargetIsSleeping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetTargetIsSleeping </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pOutIsSleeping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns target sleep status of the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutIsSleeping</td><td>true if the target is asleep, false otherwise, for the requested target. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a36">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a0eed937f7f18fcf145ec0631563b61ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eed937f7f18fcf145ec0631563b61ac">&#9670;&nbsp;</a></span>GetTargetIsConnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetTargetIsConnected </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pOutIsConnected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns target connection status of the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutIsConnected</td><td>Returns true if the target is connected for the requested target. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a35">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a46e10b5c3359e82ca603dc36d26a57fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e10b5c3359e82ca603dc36d26a57fa">&#9670;&nbsp;</a></span>SetTargetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::SetTargetName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1tm_1_1_target_name.html">TargetName</a> *&#160;</td>
          <td class="paramname"><em>pTargetName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the name of the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pTargetName</td><td>The desired name of the target. pTargetName is a UTF-8 null-terminated string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a77">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a304fd62e7e51f64ea7dde65f518a8a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a304fd62e7e51f64ea7dde65f518a8a81">&#9670;&nbsp;</a></span>SetTargetDockState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::SetTargetDockState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bDocked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the dock state of the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>. </p>
<p>This function is only supported by SDEV targets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bDocked</td><td>The requested dock state of the target: true for docked, false for undocked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a84">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af8466e9a9e63456f9e3ee743f0f1403d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8466e9a9e63456f9e3ee743f0f1403d">&#9670;&nbsp;</a></span>GetTargetWorkingDirectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetTargetWorkingDirectory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_working_directory.html">TargetWorkingDirectory</a> *&#160;</td>
          <td class="paramname"><em>pOutWorkingDirectory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the working directory of the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutWorkingDirectory</td><td>The working directory for the target. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a33">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="abb43f266dc1d445c759f4dc7385c8659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb43f266dc1d445c759f4dc7385c8659">&#9670;&nbsp;</a></span>SetTargetWorkingDirectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::SetTargetWorkingDirectory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_working_directory.html">TargetWorkingDirectory</a> *&#160;</td>
          <td class="paramname"><em>pWorkingDirectory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the working directory of the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pWorkingDirectory</td><td>The working directory for the target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a78">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a66e9719a818a8515e221ab26c8acdc42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e9719a818a8515e221ab26c8acdc42">&#9670;&nbsp;</a></span>GetTargetFirmwareVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetTargetFirmwareVersion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_firmware_version.html">TargetFirmwareVersion</a> *&#160;</td>
          <td class="paramname"><em>pOutTargetFirmwareVersion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the firmware version of the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutTargetFirmwareVersion</td><td>The firmware version of the target. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
 SDEV targets require a one-time connection to Target Manager to acquire the firmware version. If an SDEV target has not been connected to Target Manager, GetTargetFirmwareVersion will return <a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034abf2bff45a561b4cea89e81a12ba5b046" title="Requested action requires a connection to the target.">nn::tm::Error_TargetNotConnected</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a24">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad8e5dfcc831c62dc7a5cf9af8c5aa721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e5dfcc831c62dc7a5cf9af8c5aa721">&#9670;&nbsp;</a></span>LaunchTargetProgram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::LaunchTargetProgram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pArguments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pWorkingDirectory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pTDF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Launches an executable on the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFileName</td><td>The absolute null-terminated path to the executable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pArguments</td><td>Optional. The null-terminated arguments to be passed to the executable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pWorkingDirectory</td><td>Optional. The null-terminated working directory of the executable. If not specified, the target working directory will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pTDF</td><td>Optional. The absolute null-terminated path to the target environment variables definitions file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_remote_video_8cpp-example.html#a6">TmRemoteVideo.cpp</a>, and <a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a66">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1f80d8a454f628089fe81343e4332874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f80d8a454f628089fe81343e4332874">&#9670;&nbsp;</a></span>KillTargetProgram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::KillTargetProgram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kill the user program on the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_remote_video_8cpp-example.html#a18">TmRemoteVideo.cpp</a>, and <a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a65">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a67e416569975e489112f73827431e963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67e416569975e489112f73827431e963">&#9670;&nbsp;</a></span>GetTargetProgramName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetTargetProgramName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_program_name.html">TargetProgramName</a> *&#160;</td>
          <td class="paramname"><em>pOutTargetProgramName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of the program on the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutTargetProgramName</td><td>The client preallocated buffer to store the name of the currently active program. The returned buffer is null-terminated. Null is returned if no programs are currently running. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a58">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="adbde8c1b5037ae73ba7708e85fe5724d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbde8c1b5037ae73ba7708e85fe5724d">&#9670;&nbsp;</a></span>GetTargetProgramState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetTargetProgramState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1tm.html#a65c4c275de00753bdcb270212e8d603c">TargetProgramState</a> *&#160;</td>
          <td class="paramname"><em>pOutTargetProgramState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the state of the program on the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutTargetProgramState</td><td>The state of the currently active program. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a60">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a7bba2bc861557e25fc20c6dfcc79878d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bba2bc861557e25fc20c6dfcc79878d">&#9670;&nbsp;</a></span>CreateTargetProgramDump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::CreateTargetProgramDump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pFilePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1tm.html#aed75c59e3dcda10a6cf06c0048a86769">DumpType</a>&#160;</td>
          <td class="paramname"><em>dumpType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a nxdmp file for the application on the target specified by the <a class="el" href="structnn_1_1tm_1_1_target_handle.html" title="A unique handle for interacting with targets.">TargetHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFilePath</td><td>The requested output path for the nxdmp file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dumpType</td><td>The type of dump file to create.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a64">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a396ed39d6d70e06d19b9a2644d86ef13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396ed39d6d70e06d19b9a2644d86ef13">&#9670;&nbsp;</a></span>RegisterProgramExitEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::RegisterProgramExitEvent </td>
          <td>(</td>
          <td class="paramtype">HANDLE&#160;</td>
          <td class="paramname"><em>eventHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers an EVENT which will be signaled when running program exits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eventHandle</td><td>A handle that is created by CreateEvent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a0">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3b2eac619037136734c9771022a3626f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b2eac619037136734c9771022a3626f">&#9670;&nbsp;</a></span>UnregisterProgramExitEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::UnregisterProgramExitEvent </td>
          <td>(</td>
          <td class="paramtype">HANDLE&#160;</td>
          <td class="paramname"><em>eventHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregisters an EVENT which will be signaled when running program exits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eventHandle</td><td>A handle that is created by CreateEvent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>

</div>
</div>
<a id="aa43d77e6366a90b6b8a4becafd39a043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43d77e6366a90b6b8a4becafd39a043">&#9670;&nbsp;</a></span>RegisterProgramErrorEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::RegisterProgramErrorEvent </td>
          <td>(</td>
          <td class="paramtype">HANDLE&#160;</td>
          <td class="paramname"><em>eventHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers an EVENT which will be signaled when a target program has crashed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eventHandle</td><td>A handle that is created by CreateEvent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a5">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a398b4e3baebacf85b42ea02b09bcc0c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398b4e3baebacf85b42ea02b09bcc0c9">&#9670;&nbsp;</a></span>UnregisterProgramErrorEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::UnregisterProgramErrorEvent </td>
          <td>(</td>
          <td class="paramtype">HANDLE&#160;</td>
          <td class="paramname"><em>eventHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregisters an EVENT which will be signaled when a target program has crashed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eventHandle</td><td>A handle that is created by CreateEvent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>

</div>
</div>
<a id="a82c11fbc3ec5b25eef4317d42c3220d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c11fbc3ec5b25eef4317d42c3220d2">&#9670;&nbsp;</a></span>GetLog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetLog </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pOutUnbroken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets log that is already output at that time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutUnbroken</td><td>true if the log has continuity, false otherwise. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSize</td><td>Returns the size of returned log in byte. This includes the size of null code. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>The client preallocated buffer for storing the log. Null terminated.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of buffer in byte. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code.</dd></dl>
<p> <b>Details</b> <br  />
 Log that has been output at that time will be put into buffer. When this API is called again, it will return log from the point right after the preceding GetLog returned. Note that returned log will be limited by Target Manager capacity that is specified by Target Manager Maximum log lines option. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a70">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac5096f347e3e3ad9ae2a5891fb142e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5096f347e3e3ad9ae2a5891fb142e04">&#9670;&nbsp;</a></span>StartSavingLog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::StartSavingLog </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeHistory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start saving log output from the target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filePath</td><td>The file path to save the log. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">includeHistory</td><td>If enabled, all cached logs will be included in the log file. If disabled, only new logs will be included in the log file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code.</dd></dl>
<p> <b>Details</b> <br  />
 Start saving log output from the target. This API cannot be called again for the same target until StopSavingLog is called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a71">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="abbc4baa7876d01926076e7a22d917071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc4baa7876d01926076e7a22d917071">&#9670;&nbsp;</a></span>StopSavingLog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::StopSavingLog </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop saving log started by StartSavingLog. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a72">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="abb5220d3ff4b1cc4b21a82a93b0ede38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5220d3ff4b1cc4b21a82a93b0ede38">&#9670;&nbsp;</a></span>StartSavingJsonLog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::StartSavingJsonLog </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeHistory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start saving log output from the target as Json. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filePath</td><td>The file path to save the log. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">includeHistory</td><td>If enabled, all cached logs will be included in the log file. If disabled, only new logs will be included in the log file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code.</dd></dl>
<p> <b>Details</b> <br  />
 Start saving log output from the target. This API cannot be called again for the same target until StopSavingJsonLog is called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a73">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af1b1ffd4c2cbfb9a0fb50552f44ed249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b1ffd4c2cbfb9a0fb50552f44ed249">&#9670;&nbsp;</a></span>StopSavingJsonLog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::StopSavingJsonLog </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop saving log started by StartSavingJsonLog. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a74">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a676f047a474fb78d1e3c62ce3ac143d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676f047a474fb78d1e3c62ce3ac143d4">&#9670;&nbsp;</a></span>RegisterHtcsEntry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::RegisterHtcsEntry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1tm_1_1_htcs_peer_name.html">HtcsPeerName</a> *&#160;</td>
          <td class="paramname"><em>pPeerName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1tm_1_1_htcs_port_name.html">HtcsPortName</a> *&#160;</td>
          <td class="paramname"><em>pPortName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1tm_1_1_htcs_address.html">HtcsAddress</a> *&#160;</td>
          <td class="paramname"><em>pSocketAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers an HTCS entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pPeerName</td><td>The peer name on the host. To specify the host PC name, use PeerNameHostPc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pPortName</td><td>The port name on the host. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSocketAddress</td><td>The HTCS address that the host application is listening on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>

</div>
</div>
<a id="ae27955499d6f6456166d318257d11203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27955499d6f6456166d318257d11203">&#9670;&nbsp;</a></span>UnregisterHtcsEntry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::UnregisterHtcsEntry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1tm_1_1_htcs_peer_name.html">HtcsPeerName</a> *&#160;</td>
          <td class="paramname"><em>pPeerName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1tm_1_1_htcs_port_name.html">HtcsPortName</a> *&#160;</td>
          <td class="paramname"><em>pPortName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregisters an HTCS entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pPeerName</td><td>The peer name on the host. To specify the host PC name, use PeerNameHostPc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pPortName</td><td>The port name on the host.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>

</div>
</div>
<a id="a797f11eafc380305702480f96770db7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a797f11eafc380305702480f96770db7f">&#9670;&nbsp;</a></span>GetHtcsAddressesCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetHtcsAddressesCount </td>
          <td>(</td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>pOutHtcsAddressesCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of the HTCS addresses reserved by Target Manager. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutHtcsAddressesCount</td><td>the number of the HTCS ports reserved by Target Manager.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>

</div>
</div>
<a id="a65d88b6f94720e2151cca902d73efb67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d88b6f94720e2151cca902d73efb67">&#9670;&nbsp;</a></span>GetHtcsAddresses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetHtcsAddresses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_htcs_address.html">HtcsAddress</a> *&#160;</td>
          <td class="paramname"><em>pOutHtcsAddresses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>pOutBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets all of the HTCS addresses reserved by Target Manager. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutHtcsAddresses</td><td>The client preallocated buffer for storing the Target Manager HTCS reserved addresses. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutBufferSize</td><td>The size, in number of elements, of the returned preallocated buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size, in number of elements, of the client preallocated buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>

</div>
</div>
<a id="abd183e6f272b14f51bc38d783bceb098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd183e6f272b14f51bc38d783bceb098">&#9670;&nbsp;</a></span>GetHtcsPeerName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetHtcsPeerName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_htcs_peer_name.html">HtcsPeerName</a> *&#160;</td>
          <td class="paramname"><em>pOutPeerName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1tm_1_1_htcs_address.html">HtcsAddress</a> *&#160;</td>
          <td class="paramname"><em>pSocketAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the peer name of the HTCS address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutPeerName</td><td>The client preallocated buffer for storing the peer name of the HTCS reserved port. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSocketAddress</td><td>The <a class="el" href="structnn_1_1tm_1_1_htcs_address.html" title="The null-terminated ip address and port number for HTCS.">HtcsAddress</a> of the HTCS entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>

</div>
</div>
<a id="a58fb31f53dcc172d963716a9cb108848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58fb31f53dcc172d963716a9cb108848">&#9670;&nbsp;</a></span>GetHtcsPortName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetHtcsPortName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_htcs_port_name.html">HtcsPortName</a> *&#160;</td>
          <td class="paramname"><em>pOutPortName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1tm_1_1_htcs_address.html">HtcsAddress</a> *&#160;</td>
          <td class="paramname"><em>pSocketAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the port name of the HTCS address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutPortName</td><td>The client preallocated buffer for storing the port name of the HTCS reserved port. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSocketAddress</td><td>The <a class="el" href="structnn_1_1tm_1_1_htcs_address.html" title="The null-terminated ip address and port number for HTCS.">HtcsAddress</a> of the HTCS entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>

</div>
</div>
<a id="a9a71568a86c10d76566a4c0b07326085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a71568a86c10d76566a4c0b07326085">&#9670;&nbsp;</a></span>GetHtcsControlPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetHtcsControlPort </td>
          <td>(</td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>pOutControlPort</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the control port number used for HTCS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutControlPort</td><td>Control port number used for HTCS.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>

</div>
</div>
<a id="acb92be54fbe72b703fbb910d86643748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb92be54fbe72b703fbb910d86643748">&#9670;&nbsp;</a></span>GetHtcsEntryEndPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetHtcsEntryEndPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_htcs_address.html">HtcsAddress</a> *&#160;</td>
          <td class="paramname"><em>pOutHtcsAddresses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>pOutBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1tm_1_1_htcs_peer_name.html">HtcsPeerName</a> *&#160;</td>
          <td class="paramname"><em>pPeerName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1tm_1_1_htcs_port_name.html">HtcsPortName</a> *&#160;</td>
          <td class="paramname"><em>pPortName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a filtered list of HtcsAddresses as specified by the peer and port names. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutHtcsAddresses</td><td>A client preallocated buffer for storing IP addresses and ports. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutBufferSize</td><td>The size, in number of elements, of the returned preallocated buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size, in number of elements, of the client preallocated buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pPeerName</td><td>The peer name used to filter the returned list of HTCS addresses. Use a nullptr or PeerNameAny to not filter on a peer name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pPortName</td><td>The port name used to filter the returned list of HTCS addresses. Use a nullptr or PortNameAny to not filter on a port name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a8">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad8f59176e6b15e2d2ec3cb2ef95a862c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f59176e6b15e2d2ec3cb2ef95a862c">&#9670;&nbsp;</a></span>RegisterHtcsPortMappingUpdateEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::RegisterHtcsPortMappingUpdateEvent </td>
          <td>(</td>
          <td class="paramtype">HANDLE&#160;</td>
          <td class="paramname"><em>eventHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies an event handle to be signaled when HTCS port mapping is updated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eventHandle</td><td>A handle that was created by CreateEvent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a6">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a72a3aef51a46737a421b3045d7c5447d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a3aef51a46737a421b3045d7c5447d">&#9670;&nbsp;</a></span>UnregisterHtcsPortMappingUpdateEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::UnregisterHtcsPortMappingUpdateEvent </td>
          <td>(</td>
          <td class="paramtype">HANDLE&#160;</td>
          <td class="paramname"><em>eventHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregisters an event handle. </p>
<p>The event will no longer be signaled when HTCS port mapping is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eventHandle</td><td>A handle that was created by the CreateEvent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>

</div>
</div>
<a id="a6bc447667b98e018a37be3dbd39cbb1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc447667b98e018a37be3dbd39cbb1b">&#9670;&nbsp;</a></span>StartVideoRecording()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::StartVideoRecording </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pOutFilePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pDirectory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>recordingTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Records a video of the target screen. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutFilePath</td><td>The client preallocated buffer to hold the path to the video. If pOutFilePath is null, the full file path will not be returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of pOutFilePath in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pDirectory</td><td>The desired directory path to the video. If pDirectory is null or an empty string, the folder specified in Options -&gt; Videos will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFileName</td><td>The desired file name of the video. If pFileName is null or an empty string, the filename specified in Options -&gt; Videos will be used. pFileName can include the following variables: $(Target), $(Serial), $(Date), $(Time), $(Index). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recordingTime</td><td>The amount of time in seconds to record the screen video. If recordingTime is <a class="el" href="namespacenn_1_1tm.html#af5e12bd1ea4b28c55d6217711a9e66e3" title="Specifies StartVideoRecording to record video until StopVideoRecording is called.">nn::tm::VideoRecordingTimeInfinite</a>, video recording will continue until StopVideoRecording is called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. If recording is already in progress, <a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a658d85f26db37b7afb05e3eee3ce5b53" title="Remote video recording in progress.">nn::tm::Error_RemoteVideoRecording</a> will be returned.</dd></dl>
<p> <b>Details</b> <br  />
 A video recording can be interrupted in several ways: Remote video is no longer available due to a loss of connection, the target is unable to send data, the target program has completed, or StopVideoRecording was called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_remote_video_8cpp-example.html#a7">TmRemoteVideo.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a06342c1c35c1fb185f045b385a9eb8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06342c1c35c1fb185f045b385a9eb8c9">&#9670;&nbsp;</a></span>SaveRecentVideo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::SaveRecentVideo </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pOutFilePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pDirectory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pFileName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the recent video recorded in the target. </p>
<p> <b>Details</b> <br  />
Save the video of the last 30 seconds.<br  />
If the application is running for less than 30 seconds, saved video will have the same length as the appication.</p>
<dl class="section pre"><dt>Precondition</dt><dd>OpenTargetVideoStream is required to save the recent video. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutFilePath</td><td>The client preallocated buffer to hold the path to the video. If pOutFilePath is null, the full file path will not be returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of pOutFilePath in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pDirectory</td><td>The desired directory path to the video. If pDirectory is null or an empty string, the folder specified in Options -&gt; Videos will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFileName</td><td>The desired file name of the video. If pFileName is null or an empty string, the filename specified in Options -&gt; Videos will be used. pFileName can include the following variables: $(Target), $(Serial), $(Date), $(Time), $(Index).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_remote_video_8cpp-example.html#a16">TmRemoteVideo.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a9298df3fe428d287f3271cb54b9fe01b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9298df3fe428d287f3271cb54b9fe01b">&#9670;&nbsp;</a></span>StopVideoRecording()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::StopVideoRecording </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops video recording. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_remote_video_8cpp-example.html#a9">TmRemoteVideo.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a4dffdb040971f72737d02eeee8c2139d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dffdb040971f72737d02eeee8c2139d">&#9670;&nbsp;</a></span>OpenTargetVideoStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::OpenTargetVideoStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a target video stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code.</dd></dl>
<p> <b>Details</b> <br  />
 Opens a stream to send target screen information to the host. OpenTargetVideoStream is a prerequisite for GetScreenImageData. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_remote_video_8cpp-example.html#a12">TmRemoteVideo.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae836a0e0d88b30103e0cb7d3ad86403f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae836a0e0d88b30103e0cb7d3ad86403f">&#9670;&nbsp;</a></span>CloseTargetVideoStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::CloseTargetVideoStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes a target video stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_remote_video_8cpp-example.html#a13">TmRemoteVideo.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a62326c39781b1c183edf8f68b2afc4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62326c39781b1c183edf8f68b2afc4e5">&#9670;&nbsp;</a></span>GetScreenImageSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetScreenImageSize </td>
          <td>(</td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>pOutWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>pOutHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the width and height of the target screen image. </p>
<dl class="section pre"><dt>Precondition</dt><dd>OpenTargetVideoStream is required to get target image data. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutWidth</td><td>The width of the target screen image. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutHeight</td><td>The height of the target screen image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_remote_video_8cpp-example.html#a10">TmRemoteVideo.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac996ae9e8812c475e971b499053b3b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac996ae9e8812c475e971b499053b3b9c">&#9670;&nbsp;</a></span>GetScreenImageData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetScreenImageData </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pOutBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the raw RGB pixel values of the target screen image. </p>
<dl class="section pre"><dt>Precondition</dt><dd>OpenTargetVideoStream is required to get target image data. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutBuffer</td><td>The client preallocated buffer to hold the screen image data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of pOutBuffer in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. If image data is not available, <a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034a0211bddecc2afd579c01de1adffa94ff" title="Remote video is not available.">nn::tm::Error_RemoteVideoNotAvailable</a> will be returned.</dd></dl>
<p> <b>Details</b> <br  />
 Gets the raw color (RGB) pixel data of the target screen. The data is returned in the following format: RGB(x,y). For example: pOufBuffer[0] = R(0,0), pOufBuffer[1] = G(0,0), pOufBuffer[2] = B(0,0), pOufBuffer[3] = R(1,0), pOufBuffer[4] = G(1,0), ... If an insufficient buffer is specified, <a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ac79bcf48eb3f4a4925643505c9998d17" title="An incorrect buffer size was specified.">nn::tm::Error_RemoteVideoIncorrectBufferSize</a> is returned. The required buffer size can be determined by the width * height * 3, which is returned by GetScreenImageSize. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_remote_video_8cpp-example.html#a11">TmRemoteVideo.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a845128493276d7e375818d35db77da81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845128493276d7e375818d35db77da81">&#9670;&nbsp;</a></span>RegisterRemoteVideoUpdateEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::RegisterRemoteVideoUpdateEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HANDLE&#160;</td>
          <td class="paramname"><em>eventHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers an EVENT to be signaled when a target's remote video stops recording. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eventHandle</td><td>A handle that was created by CreateEvent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_remote_video_8cpp-example.html#a5">TmRemoteVideo.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a4888e14b9f53fafac0f3f127ad9c0f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4888e14b9f53fafac0f3f127ad9c0f47">&#9670;&nbsp;</a></span>UnregisterRemoteVideoUpdateEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::UnregisterRemoteVideoUpdateEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HANDLE&#160;</td>
          <td class="paramname"><em>eventHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregisters an EVENT to be signaled when a target's remote video stops recording. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eventHandle</td><td>A handle that was created by CreateEvent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_remote_video_8cpp-example.html#a17">TmRemoteVideo.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1a4553697223400181823df5096fbb38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4553697223400181823df5096fbb38">&#9670;&nbsp;</a></span>GetLastVideoRecordingExitReason()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetLastVideoRecordingExitReason </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1tm.html#a8924b817752c0fc71eeaaf38ccfde4d4">VideoRecordingExitReason</a> *&#160;</td>
          <td class="paramname"><em>pOutReason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the reason why the last video recording finished. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutReason</td><td>The reason why the last video recording finished. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_remote_video_8cpp-example.html#a15">TmRemoteVideo.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af89127dbdf0d39442a3a004bc6afefd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af89127dbdf0d39442a3a004bc6afefd9">&#9670;&nbsp;</a></span>GetErrorText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetErrorText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_error_text.html">ErrorText</a> *&#160;</td>
          <td class="paramname"><em>pOutTextBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the <a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034" title="Target Manager API error codes.">nn::tm::Error</a> code into an text string. </p>
<p>The text will attempt to use the system language or default to English.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutTextBuffer</td><td>The client preallocated buffer for storing the text string. The returned buffer is null-terminated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error</td><td>The <a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034" title="Target Manager API error codes.">nn::tm::Error</a> code to be converted into text.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>

</div>
</div>
<a id="a642828ac7ffde86bf9fc0ef626d309b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642828ac7ffde86bf9fc0ef626d309b0">&#9670;&nbsp;</a></span>GetErrorTextEn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetErrorTextEn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_error_text.html">ErrorText</a> *&#160;</td>
          <td class="paramname"><em>pOutTextBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the <a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034" title="Target Manager API error codes.">nn::tm::Error</a> code into an English text string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutTextBuffer</td><td>The client preallocated buffer for storing the text string. The returned buffer is null-terminated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error</td><td>The <a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034" title="Target Manager API error codes.">nn::tm::Error</a> code to be converted into text.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_remote_video_8cpp-example.html#a2">TmRemoteVideo.cpp</a>, and <a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a3">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a838bd030e2da9dcab10bc5e23f32d768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838bd030e2da9dcab10bc5e23f32d768">&#9670;&nbsp;</a></span>GetErrorTextJa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::GetErrorTextJa </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_error_text.html">ErrorText</a> *&#160;</td>
          <td class="paramname"><em>pOutTextBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a>&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the <a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034" title="Target Manager API error codes.">nn::tm::Error</a> code into an Japanese text string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutTextBuffer</td><td>The client preallocated buffer for storing the text string. The returned buffer is null-terminated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error</td><td>The <a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034" title="Target Manager API error codes.">nn::tm::Error</a> code to be converted into text.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. </dd></dl>

</div>
</div>
<a id="a10cbc14431a2d7c6cc94b95d14ac04f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10cbc14431a2d7c6cc94b95d14ac04f8">&#9670;&nbsp;</a></span>TakeScreenshot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034">Error</a> nn::tm::TakeScreenshot </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pOutFilePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1tm_1_1_target_handle.html">TargetHandle</a>&#160;</td>
          <td class="paramname"><em>targetHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pDirectory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pFileName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a screenshot on the target and returns the file path to screenshot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutFilePath</td><td>The client preallocated buffer to hold the path to the screenshot. If pOutFilePath is null, the full file path will not be returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of pOutFilePath in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetHandle</td><td>The handle of the requested target. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pDirectory</td><td>The desired directory path to the screenshot. If pDirectory is null or an empty string, the folder specified in Options -&gt; Screenshots will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFileName</td><td>The desired file name of the screenshot. If pFileName is null or an empty string, the filename specified in Options -&gt; Screenshots will be used. pFileName can include the following variables: $(Target), $(Serial), $(Date), $(Time), $(Index).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacenn_1_1tm.html#af7ab04e057ae2bf176cfe7f5b5699034ad61301c99dccde95d75d2cad197848d6" title="No error.">nn::tm::Error_Ok</a> if successful, else an error code. If Error_InvalidParameter is returned, the specified pDirectory or pFileName is invalid. If Error_InvalidScreenshotFolderSetting or Error_InvalidScreenshotFilenameSetting is returned, the Target Manager screenshot configuration is invalid. Verify settings in Target Manager Options. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_tm_simple_2_tm_simple_8cpp-example.html#a61">TmSimple/TmSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a937109e09de72d60ee7dcda6009e0a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a937109e09de72d60ee7dcda6009e0a73">&#9670;&nbsp;</a></span>HtcsIpAndPortAddressBufferLength</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t nn::tm::HtcsIpAndPortAddressBufferLength = 128</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum IP address length, including the null terminator. </p>
<p>Only IPv4 addresses and port numbers are supported. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
