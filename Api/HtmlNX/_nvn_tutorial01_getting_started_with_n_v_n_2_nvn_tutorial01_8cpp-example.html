<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NvnTutorial01GettingStartedWithNVN/NvnTutorial01.cpp | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">NvnTutorial01GettingStartedWithNVN/NvnTutorial01.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<p>For an explanation of the source code, see <a class="el" href="_page_sample_nvn_tutorial01.html">NVN Tutorial 01: Getting Started With NVN</a> and <tt>NvnTutorial01GettingStartedWithNVN/NvnTutorial01.cpp</tt>.</p>
<div class="fragment"><div class="line"><span class="comment">/*--------------------------------------------------------------------------------*</span></div>
<div class="line"><span class="comment">  Copyright (C)Nintendo All rights reserved.</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  These coded instructions, statements, and computer programs contain proprietary</span></div>
<div class="line"><span class="comment">  information of Nintendo and/or its licensed developers and are protected by</span></div>
<div class="line"><span class="comment">  national and international copyright laws. They may not be disclosed to third</span></div>
<div class="line"><span class="comment">  parties or copied or duplicated in any form, in whole or in part, without the</span></div>
<div class="line"><span class="comment">  prior written consent of Nintendo.</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  The content herein is highly confidential and should be handled accordingly.</span></div>
<div class="line"><span class="comment"> *--------------------------------------------------------------------------------*/</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="nvn___func_ptr_inline_8h.html">nvn/nvn_FuncPtrInline.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="nvn___func_ptr_impl_8h.html">nvn/nvn_FuncPtrImpl.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_tutorial_base_class_8h.html">nvntutorial/TutorialBaseClass.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_memory_pool_8h.html">nvntutorial/MemoryPool.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_tutorial_util_8h.html">nvntutorial/TutorialUtil.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="nn___assert_8h.html">nn/nn_Assert.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="nn___log_8h.html">nn/nn_Log.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> g_CommandMemorySize = 512;</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> g_ControlMemorySize = 512;</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span>    g_NumColorBuffers = 2;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>GettingStartedWithNVN : <span class="keyword">public</span> TutorialBaseClass</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        GettingStartedWithNVN() ;</div>
<div class="line">        <span class="keyword">virtual</span> ~GettingStartedWithNVN() ;</div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> Init(<a class="code" href="group__nvn__c__funcptrs.html#ga6d548eaff5d46c83d72a818154476b84">PFNNVNBOOTSTRAPLOADERPROC</a> loader, <a class="code" href="group__nvn__c__api__typedefs.html#ga05b6b3dd5b965bd81efe2d03cee0bbbd">NVNnativeWindow</a> nativeWindow);</div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespacenn_1_1socket.html#a895595468f09d14293edd099a8ff7dc5">Shutdown</a>();</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> Draw(uint64_t millisec) ;</div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> Resize(<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height) ;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        <span class="keyword">static</span> <span class="keywordtype">void</span> NVNAPIENTRY DebugLayerCallback(</div>
<div class="line">            <a class="code" href="group__nvn__c__enum.html#ga70a49f98019e4832818240297bee7eb3">NVNdebugCallbackSource</a> source,</div>
<div class="line">            <a class="code" href="group__nvn__c__enum.html#ga661d03f0e1c886c81d5ccc67935df182">NVNdebugCallbackType</a> type,</div>
<div class="line">            <span class="keywordtype">int</span> <span class="keywordtype">id</span>,</div>
<div class="line">            <a class="code" href="group__nvn__c__enum.html#ga6d72003c068d7795201e77d27bf8c7ac">NVNdebugCallbackSeverity</a> severity,</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">char</span>* message,</div>
<div class="line">            <span class="keywordtype">void</span>* pUser</div>
<div class="line">            ) ;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">int</span> UpdateRenderTargets() ;</div>
<div class="line"> </div>
<div class="line">        <a name="_a0"></a><a class="code" href="struct_n_v_ndevice.html">NVNdevice</a>         m_Device;</div>
<div class="line">        <a name="_a1"></a><a class="code" href="struct_n_v_nqueue.html">NVNqueue</a>          m_Queue;</div>
<div class="line">        <span class="keywordtype">void</span>*             m_pQueueMemory;</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="namespacenn_1_1gfx.html#ad620d8208dd309eb7c4dd5973a6aeee5">MemoryPool</a>*       m_pCommandMemoryPool;</div>
<div class="line"> </div>
<div class="line">        ptrdiff_t         m_CommandPoolOffset;</div>
<div class="line">        <span class="keywordtype">void</span>*             m_pControlPool;</div>
<div class="line">        <a name="_a2"></a><a class="code" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a>  m_CommandBuffer;</div>
<div class="line">        <a class="code" href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a>  m_CommandHandle;</div>
<div class="line"> </div>
<div class="line">        ptrdiff_t         m_RenderTargetCommandPoolOffset;</div>
<div class="line">        <span class="keywordtype">void</span>*             m_pRenderTargetControlPool;</div>
<div class="line">        <a class="code" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a>  m_RenderTargetCommandBuffer;</div>
<div class="line">        <a class="code" href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a>  m_RenderTargetCommandHandle;</div>
<div class="line"> </div>
<div class="line">        <a name="_a3"></a><a class="code" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> m_RenderTargetBuilder;</div>
<div class="line">        <a name="_a4"></a><a class="code" href="struct_n_v_ntexture.html">NVNtexture</a>*       m_RenderTargets[g_NumColorBuffers];</div>
<div class="line"> </div>
<div class="line">        <a name="_a5"></a><a class="code" href="struct_n_v_nsync.html">NVNsync</a>           m_CommandBufferSync;</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="namespacenn_1_1gfx.html#ad620d8208dd309eb7c4dd5973a6aeee5">MemoryPool</a>*       m_pRenderTargetMemoryPool;</div>
<div class="line"> </div>
<div class="line">        <a name="_a6"></a><a class="code" href="struct_n_v_nwindow.html">NVNwindow</a>*        m_pWindow;</div>
<div class="line">        <a name="_a7"></a><a class="code" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a>  m_WindowBuilder;</div>
<div class="line">        <span class="keywordtype">int</span>               m_CurrentWindowIndex;</div>
<div class="line">        <a class="code" href="struct_n_v_nsync.html">NVNsync</a>           m_WindowSync;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">size_t</span>            m_ColorTargetSize;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * GettingStartedWithNVN Constructor</span></div>
<div class="line"><span class="comment"> * ----------------------------</span></div>
<div class="line"><span class="comment"> * Sets up default values for the members of the class.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">GettingStartedWithNVN::GettingStartedWithNVN() :</div>
<div class="line">    m_pQueueMemory(NULL),</div>
<div class="line">    m_pCommandMemoryPool(NULL),</div>
<div class="line">    m_pControlPool(NULL),</div>
<div class="line">    m_CommandHandle(NULL),</div>
<div class="line">    m_pRenderTargetControlPool(NULL),</div>
<div class="line">    m_RenderTargetCommandHandle(NULL),</div>
<div class="line">    m_pRenderTargetMemoryPool(NULL),</div>
<div class="line">    m_pWindow(NULL),</div>
<div class="line">    m_CurrentWindowIndex(-1)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; g_NumColorBuffers; ++i)</div>
<div class="line">    {</div>
<div class="line">        m_RenderTargets[i] = NULL;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * GettingStartedWithNVN Destructor</span></div>
<div class="line"><span class="comment"> * --------------------------------</span></div>
<div class="line"><span class="comment"> * Empty destructor.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">GettingStartedWithNVN::~GettingStartedWithNVN()</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * GettingStartedWithNVN::Init</span></div>
<div class="line"><span class="comment"> * ---------------------------</span></div>
<div class="line"><span class="comment"> * This method demonstrates basic NVN initialization. The bootstrap loader</span></div>
<div class="line"><span class="comment"> * function pointer is obtained in the platform-specific base class.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> GettingStartedWithNVN::Init(PFNNVNBOOTSTRAPLOADERPROC loader, <a class="code" href="group__nvn__c__api__typedefs.html#ga05b6b3dd5b965bd81efe2d03cee0bbbd">NVNnativeWindow</a> nativeWindow)</div>
<div class="line">{</div>
<div class="line">    <a name="a8"></a><a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(loader != NULL, <span class="stringliteral">&quot;Bootstrap loader function pointer is NULL\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">     * NVN Device</span></div>
<div class="line"><span class="comment">     * ----------</span></div>
<div class="line"><span class="comment">     * The NVN device object is intended to be a per-process singleton; it is</span></div>
<div class="line"><span class="comment">     * used to establish communication with the GPU, and a parent for all of</span></div>
<div class="line"><span class="comment">     * the other NVN object types.</span></div>
<div class="line"><span class="comment">     *</span></div>
<div class="line"><span class="comment">     * Device Memory</span></div>
<div class="line"><span class="comment">     * -------------</span></div>
<div class="line"><span class="comment">     * The loader function pointer allows access to the NVN device initialization</span></div>
<div class="line"><span class="comment">     * function. This function takes a structure pointer allowing the app to</span></div>
<div class="line"><span class="comment">     * set relevant parameters. One parameter is the &quot;device memory&quot;, a block</span></div>
<div class="line"><span class="comment">     * of memory the NVN driver should use for it&#39;s internal data structures.</span></div>
<div class="line"><span class="comment">     *</span></div>
<div class="line"><span class="comment">     * Debug Layer</span></div>
<div class="line"><span class="comment">     * -----------</span></div>
<div class="line"><span class="comment">     * It is possible to enable the debug layer via device initialization</span></div>
<div class="line"><span class="comment">     * parameters. The debug layer adds error checking to many NVN entry points,</span></div>
<div class="line"><span class="comment">     * but has no overhead at all when not enabled. The debug layer also will</span></div>
<div class="line"><span class="comment">     * generate error and warning messages when various programming errors are</span></div>
<div class="line"><span class="comment">     * detected, so be sure to provide a message handler callback. See below for</span></div>
<div class="line"><span class="comment">     * an example of how to do this.</span></div>
<div class="line"><span class="comment">     *</span></div>
<div class="line"><span class="comment">     * Device Thread Safety</span></div>
<div class="line"><span class="comment">     * --------------------</span></div>
<div class="line"><span class="comment">     * There is no need to provide synchronization for the NVNdevice object;</span></div>
<div class="line"><span class="comment">     * it may be passed in to any NVN function that requires it from any thread.</span></div>
<div class="line"><span class="comment">     * The exception to this rule is device initialization and finalization;</span></div>
<div class="line"><span class="comment">     * threads may not begin to use the NVNdevice until nvnDeviceInitialize has</span></div>
<div class="line"><span class="comment">     * returned sucessfully, and must cease using the device before</span></div>
<div class="line"><span class="comment">     * nvnDeviceFinalize is called.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line"> </div>
<div class="line">    pfnc_nvnDeviceInitialize = <span class="keyword">reinterpret_cast&lt;</span><a class="code" href="group__nvn__c__entryfuncptrs.html#gaac2535d2f4e2740efa3fd69d683110fc">PFNNVNDEVICEINITIALIZEPROC</a><span class="keyword">&gt;</span>((*loader)(<span class="stringliteral">&quot;nvnDeviceInitialize&quot;</span>));</div>
<div class="line">    pfnc_nvnDeviceGetProcAddress = <span class="keyword">reinterpret_cast&lt;</span><a class="code" href="group__nvn__c__entryfuncptrs.html#ga9557d931192cd70c7d2810a6425326eb">PFNNVNDEVICEGETPROCADDRESSPROC</a><span class="keyword">&gt;</span>((*loader)(<span class="stringliteral">&quot;nvnDeviceGetProcAddress&quot;</span>));</div>
<div class="line">    <span class="keywordflow">if</span> (!pfnc_nvnDeviceInitialize)</div>
<div class="line">    {</div>
<div class="line">            <span class="comment">/* This can happen if an NVN driver is not installed on a Windows PC. */</span></div>
<div class="line">        <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;BootstrapLoader failed to find nvnDeviceInitialize&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Load function pointers for creating nvn device.  NULL</span></div>
<div class="line"><span class="comment">         * is passed here at first, the function is called again</span></div>
<div class="line"><span class="comment">         * after device initialization to ensure all the function</span></div>
<div class="line"><span class="comment">         * pointers work properly.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    nvnLoadCProcs( NULL, pfnc_nvnDeviceGetProcAddress );</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Version Check</span></div>
<div class="line"><span class="comment">         * -------------</span></div>
<div class="line"><span class="comment">         * Check for API version mismatches. This is a comparison between the version</span></div>
<div class="line"><span class="comment">         * support reported by the NVN library, and the version of the NVN headers this</span></div>
<div class="line"><span class="comment">         * source file is compiled with. Exit with an error if the major version</span></div>
<div class="line"><span class="comment">         * mismatches (major revisions are backward-incompatible) or if the driver</span></div>
<div class="line"><span class="comment">         * reports a lower minor version. It is possible to call nvnDeviceGetInteger</span></div>
<div class="line"><span class="comment">         * with a NULL device and get the correct result when querying</span></div>
<div class="line"><span class="comment">         * NVN_DEVICE_INFO_API_MAJOR_VERSION and NVN_DEVICE_INFO_API_MINOR_VERSION.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <span class="keywordtype">int</span> <a class="code" href="namespacenn_1_1ui2d.html#a3d128ec7087f91b3f54cbfcf73fb93b9">MajorVersion</a>, <a class="code" href="namespacenn_1_1ui2d.html#a8ebb4f5324b526c9e74f0b01037fb74c">MinorVersion</a>;</div>
<div class="line">    nvnDeviceGetInteger(NULL, NVN_DEVICE_INFO_API_MAJOR_VERSION, &amp;MajorVersion);</div>
<div class="line">    nvnDeviceGetInteger(NULL, NVN_DEVICE_INFO_API_MINOR_VERSION, &amp;MinorVersion);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (MajorVersion != <a name="a9"></a><a class="code" href="group__nvn__c__defines.html#ga4eb83fe713146d844b1ac7f8e9c3dada">NVN_API_MAJOR_VERSION</a> || MinorVersion &lt; <a name="a10"></a><a class="code" href="group__nvn__c__defines.html#gaa8b4a49a0c4f852b73be3b50bb3f270e">NVN_API_MINOR_VERSION</a>)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;NVN SDK not supported by current driver.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* If debug or develop is enabled, turn on NVN&#39;s debug layer. */</span></div>
<div class="line">    <span class="keywordtype">int</span> deviceFlags = 0;</div>
<div class="line"><span class="preprocessor">#if defined(NN_SDK_BUILD_DEBUG) || defined(NN_SDK_BUILD_DEVELOP)</span></div>
<div class="line">    deviceFlags = <a class="code" href="group__nvn__c__enum.html#gga9c68350bf64f2e7a90a23290c26872d3ac002cdaba27241c296213d4722dad0a6">NVN_DEVICE_FLAG_DEBUG_ENABLE_LEVEL_2_BIT</a>;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line">    <a name="_a11"></a><a class="code" href="struct_n_v_ndevice_builder.html">NVNdeviceBuilder</a> deviceBuilder;</div>
<div class="line">    nvnDeviceBuilderSetDefaults(&amp;deviceBuilder);</div>
<div class="line">    nvnDeviceBuilderSetFlags(&amp;deviceBuilder, deviceFlags);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (nvnDeviceInitialize(&amp;m_Device, &amp;deviceBuilder) == <span class="keyword">false</span>)</div>
<div class="line">    {</div>
<div class="line">            <span class="comment">/*</span></div>
<div class="line"><span class="comment">             * This can fail for a few reasons; the most likely on Horizon is</span></div>
<div class="line"><span class="comment">             * insufficent device memory.</span></div>
<div class="line"><span class="comment">             */</span></div>
<div class="line">        <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;nvnDeviceInitialize&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * API Loading</span></div>
<div class="line"><span class="comment">         * -----------</span></div>
<div class="line"><span class="comment">         * Once the device has been initialized, it is now possible to load all of the</span></div>
<div class="line"><span class="comment">         * remaining NVN API entry points. The bootstrap loader is used again to</span></div>
<div class="line"><span class="comment">         * locate the &quot;real&quot; loader function. The real loader may be passed along</span></div>
<div class="line"><span class="comment">         * with the device into nvnLoadProcs if using nvn_FuncPtrInline.h. It is also</span></div>
<div class="line"><span class="comment">         * completely valid for applications to load with their own entry points.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    nvnLoadCProcs(&amp;m_Device, pfnc_nvnDeviceGetProcAddress );</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Debug Layer Callback</span></div>
<div class="line"><span class="comment">         * --------------------</span></div>
<div class="line"><span class="comment">         * Install the debug layer callback if the debug layer was enabled during</span></div>
<div class="line"><span class="comment">         * device initialization. It is possible to pass a pointer to the NVN API</span></div>
<div class="line"><span class="comment">         * to remember and pass back through the debug callback.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <span class="keywordflow">if</span> (deviceFlags &amp; NVN_DEVICE_FLAG_DEBUG_ENABLE_LEVEL_2_BIT)</div>
<div class="line">    {</div>
<div class="line">        nvnDeviceInstallDebugCallback(</div>
<div class="line">            &amp;m_Device,</div>
<div class="line">            <span class="keyword">reinterpret_cast&lt;</span><a class="code" href="group__nvn__c__funcptrs.html#gab106acc34961bf1c3a43514686dbfc4b">PFNNVNDEBUGCALLBACKPROC</a><span class="keyword">&gt;</span>(&amp;DebugLayerCallback),</div>
<div class="line">            NULL, <span class="comment">// For testing purposes; any pointer is OK here.</span></div>
<div class="line">            <a name="a12"></a><a class="code" href="group__nvn__c__defines.html#ga48151b7e768a13685d77d1a4c464a33b">NVN_TRUE</a> <span class="comment">// NVN_TRUE = Enable the callback.</span></div>
<div class="line">            );</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * NVN Queue</span></div>
<div class="line"><span class="comment">         * ---------</span></div>
<div class="line"><span class="comment">         * The NVNqueue object represent a GPU context and is used to submit command buffers</span></div>
<div class="line"><span class="comment">         * to the GPU. The queue must be associated with an NVNdevice through the Initialize</span></div>
<div class="line"><span class="comment">         * function before being used. Commands submitted to the queue through the command</span></div>
<div class="line"><span class="comment">         * buffers are processed in the order that they are submitted. Commands submitted</span></div>
<div class="line"><span class="comment">         * to one queue are processed independently from commands submitted to other queues.</span></div>
<div class="line"><span class="comment">         * The order in which commands in multiple queues are executed relative to each other</span></div>
<div class="line"><span class="comment">         * is undefined unless a synchronization primitive is used. Each queue has it&#39;s own</span></div>
<div class="line"><span class="comment">         * NVN state, meaning that state changes in one queue will not affect rendering in</span></div>
<div class="line"><span class="comment">         * another.</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * It is possible to more explicitly control the size of the backing memory of a queue.</span></div>
<div class="line"><span class="comment">         * Using the Set&lt;Compute/Command&gt;MemorySize functions changes the size of the backing</span></div>
<div class="line"><span class="comment">         * memory that is automatically allocated for use in submitting command buffer commands</span></div>
<div class="line"><span class="comment">         * and dispatching work to compute shaders.  The memory a queue requires for work with</span></div>
<div class="line"><span class="comment">         * compute is significantly higher than what is needed for command, so if compute is not</span></div>
<div class="line"><span class="comment">         * being used at all then the size for compute memory should be set to zero like in this</span></div>
<div class="line"><span class="comment">         * demo.</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * You can also instead provide the queue builder a manually allocated block of memory</span></div>
<div class="line"><span class="comment">         * through the function SetQueueMemory; the minimum size needed can be queried through</span></div>
<div class="line"><span class="comment">         * GetQueueMemorySize. The value returned by GetQueueMemorySize includes the (minimum)</span></div>
<div class="line"><span class="comment">         * memory necessary for command processing, the (minimum) memory necessary for compute</span></div>
<div class="line"><span class="comment">         * dispatches, and scratch memory for fragment shader interlocks and other internal GPU</span></div>
<div class="line"><span class="comment">         * operations based on the current state of the queue builder; this is why command and</span></div>
<div class="line"><span class="comment">         * compute memory sizes are set before the query, so that they will be figured into</span></div>
<div class="line"><span class="comment">         * the minimum necessary size for the queue&#39;s memory block.</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * Providing a block can be useful to minimize the amount of times the internal buffer</span></div>
<div class="line"><span class="comment">         * needs to be flushed if a lot of commands are being submitted.  It is also possible</span></div>
<div class="line"><span class="comment">         * to set a threshold for the queue&#39;s memory that will flush the buffer when it is</span></div>
<div class="line"><span class="comment">         * filled past the threshold.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <a name="_a13"></a><a class="code" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> queueBuilder;</div>
<div class="line">    nvnQueueBuilderSetDevice(&amp;queueBuilder, &amp;m_Device);</div>
<div class="line">    nvnQueueBuilderSetDefaults(&amp;queueBuilder);</div>
<div class="line">    nvnQueueBuilderSetComputeMemorySize(&amp;queueBuilder, 0);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Get minimum size allowed for queue&#39;s internal command memory.</span></div>
<div class="line"><span class="comment">         * More can be provided to the queue if the application requires</span></div>
<div class="line"><span class="comment">         * as long as it fulfils the necessary granularity and alignment</span></div>
<div class="line"><span class="comment">         * requirements.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <span class="keywordtype">int</span> minQueueCommandMemorySize = 0;</div>
<div class="line">    nvnDeviceGetInteger(&amp;m_Device, NVN_DEVICE_INFO_QUEUE_COMMAND_MEMORY_MIN_SIZE, &amp;minQueueCommandMemorySize);</div>
<div class="line">    nvnQueueBuilderSetCommandMemorySize(&amp;queueBuilder, minQueueCommandMemorySize);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Setting the flush threshold on the queue&#39;s command memory here helps</span></div>
<div class="line"><span class="comment">         * to prevent implicit flushes when a significant amount of the memory</span></div>
<div class="line"><span class="comment">         * is used (compute dispatches, shader subroutine uniform updates, etc.)</span></div>
<div class="line"><span class="comment">         * This is due to the default flush threshold being 1/8th of the available</span></div>
<div class="line"><span class="comment">         * command memory; setting it to the size of the buffer itself means a</span></div>
<div class="line"><span class="comment">         * flush will only occur automatically when it has no more room in its</span></div>
<div class="line"><span class="comment">         * internal command buffer.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    nvnQueueBuilderSetCommandFlushThreshold(&amp;queueBuilder, minQueueCommandMemorySize);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">size_t</span> neededQueueMemorySize = nvnQueueBuilderGetQueueMemorySize(&amp;queueBuilder);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> ((neededQueueMemorySize % <a name="a14"></a><a class="code" href="group__nvn__c__defines.html#gadfd69601d2d9f953c55808127ba60853">NVN_MEMORY_POOL_STORAGE_GRANULARITY</a>) != 0)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;Memory size reported for queue is not the proper granularity&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * On Windows, the buffer provided to the queue here is ignored</span></div>
<div class="line"><span class="comment">         * completely and the driver allocates the memory.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line"><span class="preprocessor">#if defined( NN_BUILD_TARGET_PLATFORM_OS_WIN )</span></div>
<div class="line">    m_pQueueMemory = NULL;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    m_pQueueMemory = AlignedAllocate(neededQueueMemorySize, <a name="a15"></a><a class="code" href="group__nvn__c__defines.html#gace820e752b400cf7aa36e9684a7f45cb">NVN_MEMORY_POOL_STORAGE_ALIGNMENT</a>);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line">    nvnQueueBuilderSetQueueMemory(&amp;queueBuilder, m_pQueueMemory, neededQueueMemorySize);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span>(nvnQueueInitialize(&amp;m_Queue, &amp;queueBuilder) == <span class="keyword">false</span>)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;nvnQueueInitialize failed&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * NVN Command Buffer</span></div>
<div class="line"><span class="comment">         * ------------------</span></div>
<div class="line"><span class="comment">         * The NVNcommandBuffer object is used to record a list of commands to be run</span></div>
<div class="line"><span class="comment">         * by the GPU. The command buffer is populated by calling nvnCommandBuffer***</span></div>
<div class="line"><span class="comment">         * methods between calls to the BeginRecording and EndRecording methods. The</span></div>
<div class="line"><span class="comment">         * EndRecording method returns a NVNcommandBufferHandle that can be submitted</span></div>
<div class="line"><span class="comment">         * to the queue to run the commands in the command buffer in the order they</span></div>
<div class="line"><span class="comment">         * were recorded.</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * A command buffer requires two blocks of memory: command memory and control</span></div>
<div class="line"><span class="comment">         * memory. Command memory is used to record the GPU commands. The command</span></div>
<div class="line"><span class="comment">         * memory is an NVNmemoryPool object and should CPU coherent or CPU non-coherent.</span></div>
<div class="line"><span class="comment">         * Control memory is used to store additional information/data needed for the</span></div>
<div class="line"><span class="comment">         * GPU commands to be processed. This memory is simply allocated by the CPU and</span></div>
<div class="line"><span class="comment">         * is not an NVNmemoryPool.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <span class="keywordflow">if</span>(!nvnCommandBufferInitialize(&amp;m_CommandBuffer, &amp;m_Device))</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;nvnCommandBufferInitialize&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Queries the device for the proper control and command</span></div>
<div class="line"><span class="comment">         * memory alignment for a command buffer.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <span class="keywordtype">int</span> commandBufferCommandAlignment = 0;</div>
<div class="line">    <span class="keywordtype">int</span> commandBufferControlAlignment = 0;</div>
<div class="line">    nvnDeviceGetInteger(&amp;m_Device, NVN_DEVICE_INFO_COMMAND_BUFFER_COMMAND_ALIGNMENT, &amp;commandBufferCommandAlignment);</div>
<div class="line">    nvnDeviceGetInteger(&amp;m_Device, NVN_DEVICE_INFO_COMMAND_BUFFER_CONTROL_ALIGNMENT, &amp;commandBufferControlAlignment);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Setup the command buffer memory pool. */</span></div>
<div class="line">    m_pCommandMemoryPool = <span class="keyword">new</span> <a class="code" href="namespacenn_1_1gfx.html#ad620d8208dd309eb7c4dd5973a6aeee5">MemoryPool</a>();</div>
<div class="line">    m_pCommandMemoryPool-&gt;Init(</div>
<div class="line">        NULL,</div>
<div class="line">        Align(g_CommandMemorySize, commandBufferCommandAlignment) * 2,</div>
<div class="line">        NVN_MEMORY_POOL_FLAGS_CPU_UNCACHED_BIT | NVN_MEMORY_POOL_FLAGS_GPU_CACHED_BIT,</div>
<div class="line">        &amp;m_Device);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Setup the control memory with the proper alignment. */</span></div>
<div class="line">    m_pControlPool = AlignedAllocate(g_ControlMemorySize, commandBufferControlAlignment);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Grab the offset from the memory pool. */</span></div>
<div class="line">    m_CommandPoolOffset = m_pCommandMemoryPool-&gt;GetNewMemoryChunkOffset(g_CommandMemorySize, commandBufferCommandAlignment);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Provides the command buffer with the command and control memory blocks. */</span></div>
<div class="line">    nvnCommandBufferAddCommandMemory(&amp;m_CommandBuffer, m_pCommandMemoryPool-&gt;GetMemoryPool(), m_CommandPoolOffset, g_CommandMemorySize);</div>
<div class="line">    nvnCommandBufferAddControlMemory(&amp;m_CommandBuffer, m_pControlPool, g_ControlMemorySize);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Render Target Setting Command Buffer */</span></div>
<div class="line">    <span class="keywordflow">if</span>(!nvnCommandBufferInitialize(&amp;m_RenderTargetCommandBuffer, &amp;m_Device))</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;nvnCommandBufferInitialize&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Setup the control memory with the proper alignment. */</span></div>
<div class="line">    m_pRenderTargetControlPool = AlignedAllocate(g_ControlMemorySize, commandBufferControlAlignment);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Grab the offset from the memory pool. */</span></div>
<div class="line">    m_RenderTargetCommandPoolOffset = m_pCommandMemoryPool-&gt;GetNewMemoryChunkOffset(g_CommandMemorySize, commandBufferCommandAlignment);</div>
<div class="line"> </div>
<div class="line">    nvnCommandBufferAddCommandMemory(&amp;m_RenderTargetCommandBuffer, m_pCommandMemoryPool-&gt;GetMemoryPool(), m_RenderTargetCommandPoolOffset, g_CommandMemorySize);</div>
<div class="line">    nvnCommandBufferAddControlMemory(&amp;m_RenderTargetCommandBuffer, m_pRenderTargetControlPool, g_ControlMemorySize);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * NVN Sync Object</span></div>
<div class="line"><span class="comment">         * ---------------</span></div>
<div class="line"><span class="comment">         * The NVNsync object is a synchronization primitive that can be used to</span></div>
<div class="line"><span class="comment">         * synchronize between queue or between a queue and the CPU. The condition</span></div>
<div class="line"><span class="comment">         * that causes the sync to fire is set by the nvnQueueFenceSync command.</span></div>
<div class="line"><span class="comment">         * The condition can be:</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * ALL_GPU_COMMANDS_COMPLETE     - Signals when all preceding GPU commands have</span></div>
<div class="line"><span class="comment">         *                                 been executed.</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * GRAPHICS_WORLD_SPACE_COMPLETE - Signals when the vertices from the previous</span></div>
<div class="line"><span class="comment">         *                                 commands have been processed, meaning that the</span></div>
<div class="line"><span class="comment">         *                                 vertex, tessellation, and geometry shader stages</span></div>
<div class="line"><span class="comment">         *                                 and the transform feedback stage have all been</span></div>
<div class="line"><span class="comment">         *                                 fully completed.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <span class="keywordflow">if</span>(!nvnSyncInitialize(&amp;m_CommandBufferSync, &amp;m_Device))</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;nvnSyncInitialize&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!nvnSyncInitialize(&amp;m_WindowSync, &amp;m_Device))</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;Failed to initialize window sync&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * NVN Builder Objects</span></div>
<div class="line"><span class="comment">         * -------------------</span></div>
<div class="line"><span class="comment">         * Some objects in NVN require a builder object to initialize them (buffers, textures, etc).</span></div>
<div class="line"><span class="comment">         * These builder objects are used to setup the state of the object to be created. Once</span></div>
<div class="line"><span class="comment">         * an object has been created through a builder, it can&#39;t be edited. Before using a builder</span></div>
<div class="line"><span class="comment">         * object, the SetDefaults method should be called to avoid having unitialized/undefined</span></div>
<div class="line"><span class="comment">         * state.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * NVN Texture</span></div>
<div class="line"><span class="comment">         * -----------</span></div>
<div class="line"><span class="comment">         * The NVNtexture object represents a block of GPU memory used to hold image data. It also</span></div>
<div class="line"><span class="comment">         * holds data to describe the image and how the image is allowed to be accessed.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * NVN Texture Builder</span></div>
<div class="line"><span class="comment">         * -------------------</span></div>
<div class="line"><span class="comment">         * The NVNtextureBuilder object is used to initialize an NVNtexture with</span></div>
<div class="line"><span class="comment">         * a specific set of states. States that can be set:</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * SetFlags                 - Set flags indentifying special properties of the texture.</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * SetTarget                - Type of the texture (1D, 2D, Array, etc).</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * SetWidth                 - Width of the texture.</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * SetHeight                - Height of the texture.</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * SetDepth                 - Depth of the texture.</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * SetSize*D                - Set width, height, and/or depth together in one call.</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * SetLevels                - Number of mip map levels.</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * SetFormat                - Pixel format.</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * SetSamples               - Number of samples. Must be 0 for non multisample, 2/4/8/16 for multisample.</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * SetSwizzle               - Specifies what is output from a texture lookup.</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * SetDepthStencilMode      - Identifies whether texture lookups will return depth or stencil values.</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * SetStorage               - Set the location in a memory pool where the texture will be allocated from.</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * SetPackagedTextureData   - (Windows only) Pointer to texture data that has been run through the texture packager.</span></div>
<div class="line"><span class="comment">         *                            Converts the texture data from the packaged format back to something usable on Windows.</span></div>
<div class="line"><span class="comment">         *                            This is ignored on the target device as the packaged texture data may be used directly.</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * SetPackagedTextureLayout - Specify the layout of packaged texture data used for texture storage.</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * SetStride                - Specifies the stride for linear textures.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    nvnTextureBuilderSetDevice(&amp;m_RenderTargetBuilder, &amp;m_Device);</div>
<div class="line">    nvnTextureBuilderSetDefaults(&amp;m_RenderTargetBuilder);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Render targets that need to be displayed to the screen need both the display access and compressible bit. */</span></div>
<div class="line">    nvnTextureBuilderSetFlags (&amp;m_RenderTargetBuilder, NVN_TEXTURE_FLAGS_DISPLAY_BIT | NVN_TEXTURE_FLAGS_COMPRESSIBLE_BIT);</div>
<div class="line">    nvnTextureBuilderSetTarget(&amp;m_RenderTargetBuilder, NVN_TEXTURE_TARGET_2D);</div>
<div class="line">    nvnTextureBuilderSetFormat(&amp;m_RenderTargetBuilder, NVN_FORMAT_RGBA8);</div>
<div class="line">    nvnTextureBuilderSetSize2D(&amp;m_RenderTargetBuilder, 1920, 1080);</div>
<div class="line">    m_ColorTargetSize = nvnTextureBuilderGetStorageSize(&amp;m_RenderTargetBuilder);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Setup the render target memory pool.  Render targets are required to be compressible</span></div>
<div class="line"><span class="comment">         * textures allocated from memory pools with the NVN_MEMORY_POOL_FLAGS_COMPRESSIBLE_BIT</span></div>
<div class="line"><span class="comment">         * bit set.</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * Vsync is enforced on the device, so if an application takes too long in a frame to</span></div>
<div class="line"><span class="comment">         * maintain 60 FPS it will drop to 30 FPS.  The tutorials provide 2 render targets to</span></div>
<div class="line"><span class="comment">         * the NVNwindow to swap between but more intensive applications may require more.  An</span></div>
<div class="line"><span class="comment">         * NVNwindow can support up to 6 render targets.</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * For more information on memory pools see MemoryPool.cpp/.h</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    m_pRenderTargetMemoryPool = <span class="keyword">new</span> <a class="code" href="namespacenn_1_1gfx.html#ad620d8208dd309eb7c4dd5973a6aeee5">MemoryPool</a>();</div>
<div class="line">    m_pRenderTargetMemoryPool-&gt;Init(</div>
<div class="line">        NULL,</div>
<div class="line">        m_ColorTargetSize * g_NumColorBuffers,</div>
<div class="line">        NVN_MEMORY_POOL_FLAGS_CPU_NO_ACCESS_BIT | NVN_MEMORY_POOL_FLAGS_GPU_CACHED_BIT | NVN_MEMORY_POOL_FLAGS_COMPRESSIBLE_BIT,</div>
<div class="line">        &amp;m_Device);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * NVN Window</span></div>
<div class="line"><span class="comment">         * ----------</span></div>
<div class="line"><span class="comment">         * The NVNwindow is used to present a render target to the screen. It manages</span></div>
<div class="line"><span class="comment">         * an array of render targets and associates them with an NVNnativeWindow. On</span></div>
<div class="line"><span class="comment">         * Horizon NVNnativeWindow defined as ANativeWindow* and on Windows it&#39;s defined</span></div>
<div class="line"><span class="comment">         * as HWND. Each frame, the NVNwindow needs to be queried for the active render</span></div>
<div class="line"><span class="comment">         * target for that frame.</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * Window Builder Settings</span></div>
<div class="line"><span class="comment">         * -----------------------</span></div>
<div class="line"><span class="comment">         * SetTextures        - Sets the list of render targets to be used by the window.</span></div>
<div class="line"><span class="comment">         *                      Textures used by the NVNwindow must be initialized with the</span></div>
<div class="line"><span class="comment">         *                      display access bit. A window can be given a max of 6 targets.</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * SetNativeWindow    - Sets the handle to the window.</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * SetPresentInterval - Sets interval for how often the window is presented to.</span></div>
<div class="line"><span class="comment">         *                      Legal values:</span></div>
<div class="line"><span class="comment">         *                      - 0: Update without waiting for next refresh, tearing likely</span></div>
<div class="line"><span class="comment">         *                           to occur</span></div>
<div class="line"><span class="comment">         *                      - 1: Updates display on next refresh, frame rate limited to</span></div>
<div class="line"><span class="comment">         *                           display&#39;s refresh rate</span></div>
<div class="line"><span class="comment">         *                      - 2: Updates display on next refresh, no sooner than two since</span></div>
<div class="line"><span class="comment">         *                           previous update.  Halves display&#39;s refresh rate.</span></div>
<div class="line"><span class="comment">         *                      This api is not supported on Windows</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    nvnWindowBuilderSetDefaults(&amp;m_WindowBuilder);</div>
<div class="line">    nvnWindowBuilderSetDevice(&amp;m_WindowBuilder, &amp;m_Device);</div>
<div class="line">    nvnWindowBuilderSetNativeWindow(&amp;m_WindowBuilder, nativeWindow);</div>
<div class="line">}<span class="comment">//NOLINT(impl/function_size)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * GettingStartedWithNVN::Shutdown</span></div>
<div class="line"><span class="comment"> * -------------------------------</span></div>
<div class="line"><span class="comment"> * This method cleans up all nvn objects and dynamically allocated memory.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> GettingStartedWithNVN::Shutdown()</div>
<div class="line">{</div>
<div class="line">    nvnQueueFinish(&amp;m_Queue);</div>
<div class="line"> </div>
<div class="line">    nvnSyncFinalize(&amp;m_CommandBufferSync);</div>
<div class="line">    nvnSyncFinalize(&amp;m_WindowSync);</div>
<div class="line"> </div>
<div class="line">    nvnCommandBufferFinalize(&amp;m_RenderTargetCommandBuffer);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span>(m_pRenderTargetControlPool)</div>
<div class="line">    {</div>
<div class="line">        AlignedDeallocate(m_pRenderTargetControlPool);</div>
<div class="line">        m_pRenderTargetControlPool = NULL;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    nvnCommandBufferFinalize(&amp;m_CommandBuffer);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span>(m_pCommandMemoryPool)</div>
<div class="line">    {</div>
<div class="line">        m_pCommandMemoryPool-&gt;Shutdown();</div>
<div class="line">        <span class="keyword">delete</span> m_pCommandMemoryPool;</div>
<div class="line">        m_pCommandMemoryPool = NULL;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span>(m_pControlPool)</div>
<div class="line">    {</div>
<div class="line">        AlignedDeallocate(m_pControlPool);</div>
<div class="line">        m_pControlPool = NULL;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (m_pWindow)</div>
<div class="line">    {</div>
<div class="line">        nvnWindowFinalize(m_pWindow);</div>
<div class="line">        <span class="keyword">delete</span> m_pWindow;</div>
<div class="line">        m_pWindow = NULL;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; g_NumColorBuffers; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (m_RenderTargets[i])</div>
<div class="line">        {</div>
<div class="line">            nvnTextureFinalize(m_RenderTargets[i]);</div>
<div class="line">            <span class="keyword">delete</span> m_RenderTargets[i];</div>
<div class="line">            m_RenderTargets[i] = NULL;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span>(m_pRenderTargetMemoryPool)</div>
<div class="line">    {</div>
<div class="line">        m_pRenderTargetMemoryPool-&gt;Shutdown();</div>
<div class="line">        <span class="keyword">delete</span> m_pRenderTargetMemoryPool;</div>
<div class="line">        m_pRenderTargetMemoryPool = NULL;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    nvnQueueFinalize(&amp;m_Queue);</div>
<div class="line">    <span class="keywordflow">if</span> (m_pQueueMemory)</div>
<div class="line">    {</div>
<div class="line">        AlignedDeallocate(m_pQueueMemory);</div>
<div class="line">        m_pQueueMemory = NULL;</div>
<div class="line">    }</div>
<div class="line">    nvnDeviceFinalize(&amp;m_Device);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * GettingStartedWithNVN::Resize</span></div>
<div class="line"><span class="comment"> * -----------------------------</span></div>
<div class="line"><span class="comment"> * This method is called everytime the window is resized and is passed</span></div>
<div class="line"><span class="comment"> * the new size of the window. It frees the old render target and creates a new</span></div>
<div class="line"><span class="comment"> * render target with the new screen size. A new set of commands for the command buffer</span></div>
<div class="line"><span class="comment"> * is recorded that performs four scissored clears of different colors on the target.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> GettingStartedWithNVN::Resize(<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height)</div>
<div class="line">{</div>
<div class="line">        <span class="comment">/* Check for the window being minimized or having no visible surface. */</span></div>
<div class="line">    <span class="keywordflow">if</span> (width == 0 || height == 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Before recording a new command buffer, make sure all previous GPU</span></div>
<div class="line"><span class="comment">         * commands have finished by setting up a fence and waiting for it to</span></div>
<div class="line"><span class="comment">         * be signalled. This so that the memory the command buffer uses isn&#39;t</span></div>
<div class="line"><span class="comment">         * overwritten before the GPU is done using it.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    nvnQueueFenceSync(&amp;m_Queue, &amp;m_CommandBufferSync, NVN_SYNC_CONDITION_ALL_GPU_COMMANDS_COMPLETE, 0);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * A sync placed into the queue as above must first be flushed to the</span></div>
<div class="line"><span class="comment">         * GPU before nvnSyncWait can be called on it.  If not, then a dead</span></div>
<div class="line"><span class="comment">         * lock happens where the CPU is waiting for the GPU to signal a</span></div>
<div class="line"><span class="comment">         * sync it does not know about yet.  With the debug layer active</span></div>
<div class="line"><span class="comment">         * this causes the callback function to be called if the sync is not</span></div>
<div class="line"><span class="comment">         * flushed.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    nvnQueueFlush(&amp;m_Queue);</div>
<div class="line">    nvnSyncWait(&amp;m_CommandBufferSync, <a name="a16"></a><a class="code" href="group__nvn__c__defines.html#ga6c3444e501307a094f1d57abf1059aed">NVN_WAIT_TIMEOUT_MAXIMUM</a>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* If it&#39;s the first time Resize is called, allocate the NVNwindow. */</span></div>
<div class="line">    <span class="keywordflow">if</span> (m_pWindow == NULL)</div>
<div class="line">    {</div>
<div class="line">        m_pWindow = <span class="keyword">new</span> <a class="code" href="struct_n_v_nwindow.html">NVNwindow</a>;</div>
<div class="line">    }</div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Otherwise finalize (free) the NVNwindow used for the previous window size.</span></div>
<div class="line"><span class="comment">         * The NVNWindow must be finalized before a render target it owns is finalized.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        nvnWindowFinalize(m_pWindow);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Set the size of the texture to be created by the texture builder.</span></div>
<div class="line"><span class="comment">         * Implicitly sets depth to one.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    nvnTextureBuilderSetSize2D(&amp;m_RenderTargetBuilder, width, height);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; g_NumColorBuffers; ++i)</div>
<div class="line">    {</div>
<div class="line">            <span class="comment">/* If it&#39;s the first time Resize is called, allocate the texture. */</span></div>
<div class="line">        <span class="keywordflow">if</span> (!m_RenderTargets[i])</div>
<div class="line">        {</div>
<div class="line">            m_RenderTargets[i] = <span class="keyword">new</span> <a class="code" href="struct_n_v_ntexture.html">NVNtexture</a>;</div>
<div class="line">        }</div>
<div class="line">            <span class="comment">/*</span></div>
<div class="line"><span class="comment">             * Otherwise, finalize (free) the texture from the previous frame.</span></div>
<div class="line"><span class="comment">             * A texture belonging to an NVNwindow must be finalized after the</span></div>
<div class="line"><span class="comment">             * window that owns it is finalized.</span></div>
<div class="line"><span class="comment">             */</span></div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            nvnTextureFinalize(m_RenderTargets[i]);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Set the memory pool the texture is to be allocated from and offset to where it will be located. */</span></div>
<div class="line">        nvnTextureBuilderSetStorage(&amp;m_RenderTargetBuilder, m_pRenderTargetMemoryPool-&gt;GetMemoryPool(), m_ColorTargetSize * i);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Create the texture using the current state of the texture builder. */</span></div>
<div class="line">        nvnTextureInitialize(m_RenderTargets[i], &amp;m_RenderTargetBuilder);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         *  Sets the number of render targets that the NVNwindow will have available and</span></div>
<div class="line"><span class="comment">         *  gives a pointer to an array of those targets.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    nvnWindowBuilderSetTextures(&amp;m_WindowBuilder, g_NumColorBuffers, m_RenderTargets);</div>
<div class="line">    nvnWindowInitialize(m_pWindow, &amp;m_WindowBuilder);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Clear Colors */</span></div>
<div class="line">    <span class="keywordtype">float</span> black[4] = { 0.0f, 0.0f, 0.0f, 1.0f };</div>
<div class="line">    <span class="keywordtype">float</span>   red[4] = { 1.0f, 0.0f, 0.0f, 1.0f };</div>
<div class="line">    <span class="keywordtype">float</span> green[4] = { 0.0f, 1.0f, 0.0f, 1.0f };</div>
<div class="line">    <span class="keywordtype">float</span>  blue[4] = { 0.0f, 0.0f, 1.0f, 1.0f };</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Temporary variables for size/position of cleared rects. */</span></div>
<div class="line">    <span class="keywordtype">int</span> halfWidth  = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(ceil(width / 2.0f));</div>
<div class="line">    <span class="keywordtype">int</span> halfHeight = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(ceil(height / 2.0f));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Reset the command and control memory pointers back to the beginning</span></div>
<div class="line"><span class="comment">         * of their blocks of memory. This causes the next recording to overwrite</span></div>
<div class="line"><span class="comment">         * whatever memory was there.  This is only safe to do if a sync is</span></div>
<div class="line"><span class="comment">         * used to ensure that the command memory about to be overwritten</span></div>
<div class="line"><span class="comment">         * has already been used by the gpu.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    nvnCommandBufferAddCommandMemory(&amp;m_CommandBuffer, m_pCommandMemoryPool-&gt;GetMemoryPool(), m_CommandPoolOffset, g_CommandMemorySize);</div>
<div class="line">    nvnCommandBufferAddControlMemory(&amp;m_CommandBuffer, m_pControlPool, g_ControlMemorySize);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Starts the recording of a new set of commands for the given command buffer. */</span></div>
<div class="line">    nvnCommandBufferBeginRecording(&amp;m_CommandBuffer);</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">            <span class="comment">/*</span></div>
<div class="line"><span class="comment">             * Lower left quadrant - black</span></div>
<div class="line"><span class="comment">             * Sets the scissor rectangle by the coordinates of its lower left</span></div>
<div class="line"><span class="comment">             * and its width/height.</span></div>
<div class="line"><span class="comment">             */</span></div>
<div class="line">        nvnCommandBufferSetScissor(&amp;m_CommandBuffer, 0, 0, halfWidth, halfHeight);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/*</span></div>
<div class="line"><span class="comment">             * Clears the currently set render target at a given index.</span></div>
<div class="line"><span class="comment">             * Channels to be cleared are set through the clear color mask.</span></div>
<div class="line"><span class="comment">             */</span></div>
<div class="line">        nvnCommandBufferClearColor(&amp;m_CommandBuffer, 0, black, NVN_CLEAR_COLOR_MASK_RGBA);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Lower right quadrant - red */</span></div>
<div class="line">        nvnCommandBufferSetScissor(&amp;m_CommandBuffer, halfWidth, 0, width - halfWidth, halfHeight);</div>
<div class="line">        nvnCommandBufferClearColor(&amp;m_CommandBuffer, 0, red, NVN_CLEAR_COLOR_MASK_RGBA);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Upper right quadrant - green */</span></div>
<div class="line">        nvnCommandBufferSetScissor(&amp;m_CommandBuffer, halfWidth, halfHeight, width - halfWidth, height - halfHeight);</div>
<div class="line">        nvnCommandBufferClearColor(&amp;m_CommandBuffer, 0, green, NVN_CLEAR_COLOR_MASK_RGBA);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Upper left quadrant - blue */</span></div>
<div class="line">        nvnCommandBufferSetScissor(&amp;m_CommandBuffer, 0, halfHeight, halfWidth, height - halfHeight);</div>
<div class="line">        nvnCommandBufferClearColor(&amp;m_CommandBuffer, 0, blue, NVN_CLEAR_COLOR_MASK_RGBA);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Ends the recording of commands for the command buffer. Returns a</span></div>
<div class="line"><span class="comment">         * command handle to the compiled set of commands that can be submitted</span></div>
<div class="line"><span class="comment">         * to a queue or used as a part of another command buffer.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    m_CommandHandle = nvnCommandBufferEndRecording(&amp;m_CommandBuffer);</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef CHECK_COMMAND_BUFFER_MEMORY_USAGE</span></div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * In order to pare down the memory used for command/control memory,</span></div>
<div class="line"><span class="comment">         * the command buffer can be queried for the amount of memory that is</span></div>
<div class="line"><span class="comment">         * free or used. This is useful to figure out how much memory to</span></div>
<div class="line"><span class="comment">         * allocate initially for small, reuasble command buffers.</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * When a command buffer runs out of either command or control memory,</span></div>
<div class="line"><span class="comment">         * a callback function (optionally provided by the user) will be hit.</span></div>
<div class="line"><span class="comment">         * More information about how the callback function works can be found</span></div>
<div class="line"><span class="comment">         * in ManagedCommandBuffer.cpp</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <span class="keywordtype">size_t</span> commandMemoryUsed = nvnCommandBufferGetCommandMemoryUsed(&amp;m_CommandBuffer);</div>
<div class="line">    <span class="keywordtype">size_t</span> controlMemoryUsed = nvnCommandBufferGetControlMemoryUsed(&amp;m_CommandBuffer);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * GettingStartedWithNVN::Draw</span></div>
<div class="line"><span class="comment"> * ---------------------------</span></div>
<div class="line"><span class="comment"> * This method submits the commands recorded in the command buffers to the queue</span></div>
<div class="line"><span class="comment"> * and presents the current render target to the screen.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> GettingStartedWithNVN::Draw(uint64_t <span class="comment">/*millisec*/</span>)</div>
<div class="line">{</div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Update the command buffer to set the current render target and grab</span></div>
<div class="line"><span class="comment">         * the index to that target.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <span class="keywordtype">int</span> index = UpdateRenderTargets();</div>
<div class="line"> </div>
<div class="line">    nvnSyncWait(&amp;m_WindowSync, <a class="code" href="group__nvn__c__defines.html#ga6c3444e501307a094f1d57abf1059aed">NVN_WAIT_TIMEOUT_MAXIMUM</a>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Submits the recorded commands in the command buffer to the queue</span></div>
<div class="line"><span class="comment">         * to be processed by the GPU. Multiple command buffers can be</span></div>
<div class="line"><span class="comment">         * submitted with one call by passing the number of command buffers</span></div>
<div class="line"><span class="comment">         * to be submitted and an array of command handles.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Render target setting command buffer. */</span></div>
<div class="line">    nvnQueueSubmitCommands(&amp;m_Queue, 1, &amp;m_RenderTargetCommandHandle);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Scissored clears command buffer, created/update by the Resize function. */</span></div>
<div class="line">    nvnQueueSubmitCommands(&amp;m_Queue, 1, &amp;m_CommandHandle);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Displays the render target at the given index to the screen. */</span></div>
<div class="line">    nvnQueuePresentTexture(&amp;m_Queue, m_pWindow, index);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * GettingStartedWithNVN::UpdateRenderTargets</span></div>
<div class="line"><span class="comment"> * ------------------------------------------</span></div>
<div class="line"><span class="comment"> * Gets the index of the current render target from the NVNwindow</span></div>
<div class="line"><span class="comment"> * and records a command buffer that sets it up to be rendered to.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">int</span> GettingStartedWithNVN::UpdateRenderTargets()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="group__nvn__c__enum.html#ga58e9b155d7f2272b95044eed1f40415e">NVNwindowAcquireTextureResult</a> result = nvnWindowAcquireTexture(m_pWindow, &amp;m_WindowSync, &amp;m_CurrentWindowIndex);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(result == NVN_WINDOW_ACQUIRE_TEXTURE_RESULT_SUCCESS);</div>
<div class="line">    <a name="a17"></a><a class="code" href="nn___macro_8h.html#af2d1673769927c5eae977d8dde3ce106">NN_UNUSED</a>(result);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Set the sync object to signal when all gpu commands are complete and wait on the</span></div>
<div class="line"><span class="comment">         * sync object before overwriting the command buffer.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    nvnQueueFenceSync(&amp;m_Queue, &amp;m_CommandBufferSync, NVN_SYNC_CONDITION_ALL_GPU_COMMANDS_COMPLETE, 0);</div>
<div class="line">    nvnQueueFlush(&amp;m_Queue);</div>
<div class="line">    nvnSyncWait(&amp;m_CommandBufferSync, <a class="code" href="group__nvn__c__defines.html#ga6c3444e501307a094f1d57abf1059aed">NVN_WAIT_TIMEOUT_MAXIMUM</a>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Reset the command and control memory pointers back to the beginning</span></div>
<div class="line"><span class="comment">         * of their blocks of memory. This causes the next recording to overwrite</span></div>
<div class="line"><span class="comment">         * whatever memory was there.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    nvnCommandBufferAddCommandMemory(&amp;m_RenderTargetCommandBuffer, m_pCommandMemoryPool-&gt;GetMemoryPool(), m_RenderTargetCommandPoolOffset, g_CommandMemorySize);</div>
<div class="line">    nvnCommandBufferAddControlMemory(&amp;m_RenderTargetCommandBuffer, m_pRenderTargetControlPool, g_ControlMemorySize);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Records a command buffer that sets the render target at the index given</span></div>
<div class="line"><span class="comment">         * by the NVNwindow.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    nvnCommandBufferBeginRecording(&amp;m_RenderTargetCommandBuffer);</div>
<div class="line">    nvnCommandBufferSetRenderTargets(&amp;m_RenderTargetCommandBuffer, 1, &amp;m_RenderTargets[m_CurrentWindowIndex], NULL, NULL, NULL);</div>
<div class="line">    m_RenderTargetCommandHandle = nvnCommandBufferEndRecording(&amp;m_RenderTargetCommandBuffer);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Return the index acquired from the NVNwindow so it can be used in the next present call. */</span></div>
<div class="line">    <span class="keywordflow">return</span> m_CurrentWindowIndex;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// static</span></div>
<div class="line"><span class="keywordtype">void</span> GettingStartedWithNVN::DebugLayerCallback(</div>
<div class="line">    <a class="code" href="group__nvn__c__enum.html#ga70a49f98019e4832818240297bee7eb3">NVNdebugCallbackSource</a> source,</div>
<div class="line">    <a class="code" href="group__nvn__c__enum.html#ga661d03f0e1c886c81d5ccc67935df182">NVNdebugCallbackType</a> type,</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keywordtype">id</span>,</div>
<div class="line">    <a class="code" href="group__nvn__c__enum.html#ga6d72003c068d7795201e77d27bf8c7ac">NVNdebugCallbackSeverity</a> severity,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* message,</div>
<div class="line">    <span class="keywordtype">void</span>* pUser</div>
<div class="line">    )</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(pUser == NULL);</div>
<div class="line">    <a class="code" href="nn___macro_8h.html#af2d1673769927c5eae977d8dde3ce106">NN_UNUSED</a>(pUser);</div>
<div class="line"> </div>
<div class="line">    <a name="a18"></a><a class="code" href="nn___log_8h.html#a2d720c8bc6b733bce63879350d134a84">NN_LOG</a>(<span class="stringliteral">&quot;NVN Debug Layer Callback:\n&quot;</span>);</div>
<div class="line">    <a class="code" href="nn___log_8h.html#a2d720c8bc6b733bce63879350d134a84">NN_LOG</a>(<span class="stringliteral">&quot;  source:       0x%08x\n&quot;</span>, source);</div>
<div class="line">    <a class="code" href="nn___log_8h.html#a2d720c8bc6b733bce63879350d134a84">NN_LOG</a>(<span class="stringliteral">&quot;  type:         0x%08x\n&quot;</span>, type);</div>
<div class="line">    <a class="code" href="nn___log_8h.html#a2d720c8bc6b733bce63879350d134a84">NN_LOG</a>(<span class="stringliteral">&quot;  id:           0x%08x\n&quot;</span>, <span class="keywordtype">id</span>);</div>
<div class="line">    <a class="code" href="nn___log_8h.html#a2d720c8bc6b733bce63879350d134a84">NN_LOG</a>(<span class="stringliteral">&quot;  severity:     0x%08x\n&quot;</span>, severity);</div>
<div class="line">    <a class="code" href="nn___log_8h.html#a2d720c8bc6b733bce63879350d134a84">NN_LOG</a>(<span class="stringliteral">&quot;  message:      %s\n&quot;</span>,     message);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;NVN Debug layer callback hit&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TutorialBaseClass* t()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">static</span> GettingStartedWithNVN tut;</div>
<div class="line">    <span class="keywordflow">return</span> (&amp;tut);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> nnMain()</div>
<div class="line">{</div>
<div class="line">    TutorialRun();</div>
<div class="line">}</div>
<div class="ttc" id="a_memory_pool_8h_html"><div class="ttname"><a href="_memory_pool_8h.html">MemoryPool.h</a></div><div class="ttdoc">This file defines a wrapper around the NVNmemoryPool object that keeps track of the memory allocated ...</div></div>
<div class="ttc" id="a_tutorial_base_class_8h_html"><div class="ttname"><a href="_tutorial_base_class_8h.html">TutorialBaseClass.h</a></div><div class="ttdoc">This class is shared among all tutorials in order to abstract away per-operating system details relat...</div></div>
<div class="ttc" id="a_tutorial_util_8h_html"><div class="ttname"><a href="_tutorial_util_8h.html">TutorialUtil.h</a></div><div class="ttdoc">This file defines the interface for utility functions used in the tutorials.</div></div>
<div class="ttc" id="agroup__nvn__c__api__typedefs_html_ga05b6b3dd5b965bd81efe2d03cee0bbbd"><div class="ttname"><a href="group__nvn__c__api__typedefs.html#ga05b6b3dd5b965bd81efe2d03cee0bbbd">NVNnativeWindow</a></div><div class="ttdeci">void * NVNnativeWindow</div><div class="ttdoc">Platform native window type.</div><div class="ttdef"><b>Definition:</b> nvn.h:159</div></div>
<div class="ttc" id="agroup__nvn__c__defines_html_ga48151b7e768a13685d77d1a4c464a33b"><div class="ttname"><a href="group__nvn__c__defines.html#ga48151b7e768a13685d77d1a4c464a33b">NVN_TRUE</a></div><div class="ttdeci">#define NVN_TRUE</div><div class="ttdoc">Boolean condition with a value of true.</div><div class="ttdef"><b>Definition:</b> nvn.h:4566</div></div>
<div class="ttc" id="agroup__nvn__c__defines_html_ga4eb83fe713146d844b1ac7f8e9c3dada"><div class="ttname"><a href="group__nvn__c__defines.html#ga4eb83fe713146d844b1ac7f8e9c3dada">NVN_API_MAJOR_VERSION</a></div><div class="ttdeci">#define NVN_API_MAJOR_VERSION</div><div class="ttdoc">Major version of the NVN API.</div><div class="ttdef"><b>Definition:</b> nvn.h:59</div></div>
<div class="ttc" id="agroup__nvn__c__defines_html_ga6c3444e501307a094f1d57abf1059aed"><div class="ttname"><a href="group__nvn__c__defines.html#ga6c3444e501307a094f1d57abf1059aed">NVN_WAIT_TIMEOUT_MAXIMUM</a></div><div class="ttdeci">#define NVN_WAIT_TIMEOUT_MAXIMUM</div><div class="ttdoc">When waiting on NVNsync objects, wait indefinitely until the sync object is signaled.</div><div class="ttdef"><b>Definition:</b> nvn.h:4574</div></div>
<div class="ttc" id="agroup__nvn__c__defines_html_gaa8b4a49a0c4f852b73be3b50bb3f270e"><div class="ttname"><a href="group__nvn__c__defines.html#gaa8b4a49a0c4f852b73be3b50bb3f270e">NVN_API_MINOR_VERSION</a></div><div class="ttdeci">#define NVN_API_MINOR_VERSION</div><div class="ttdoc">Minor version of the NVN API.</div><div class="ttdef"><b>Definition:</b> nvn.h:62</div></div>
<div class="ttc" id="agroup__nvn__c__defines_html_gace820e752b400cf7aa36e9684a7f45cb"><div class="ttname"><a href="group__nvn__c__defines.html#gace820e752b400cf7aa36e9684a7f45cb">NVN_MEMORY_POOL_STORAGE_ALIGNMENT</a></div><div class="ttdeci">#define NVN_MEMORY_POOL_STORAGE_ALIGNMENT</div><div class="ttdoc">Required base address alignment for app-specified memory used to back memory pools.</div><div class="ttdef"><b>Definition:</b> nvn.h:4578</div></div>
<div class="ttc" id="agroup__nvn__c__defines_html_gadfd69601d2d9f953c55808127ba60853"><div class="ttname"><a href="group__nvn__c__defines.html#gadfd69601d2d9f953c55808127ba60853">NVN_MEMORY_POOL_STORAGE_GRANULARITY</a></div><div class="ttdeci">#define NVN_MEMORY_POOL_STORAGE_GRANULARITY</div><div class="ttdoc">Required size alignment for app-specified memory used to back memory pools.</div><div class="ttdef"><b>Definition:</b> nvn.h:4582</div></div>
<div class="ttc" id="agroup__nvn__c__entryfuncptrs_html_ga9557d931192cd70c7d2810a6425326eb"><div class="ttname"><a href="group__nvn__c__entryfuncptrs.html#ga9557d931192cd70c7d2810a6425326eb">PFNNVNDEVICEGETPROCADDRESSPROC</a></div><div class="ttdeci">PFNNVNGENERICFUNCPTRPROC(* PFNNVNDEVICEGETPROCADDRESSPROC)(const NVNdevice *device, const char *name)</div><div class="ttdoc">Function pointer type to call nvnDeviceGetProcAddress().</div><div class="ttdef"><b>Definition:</b> nvn.h:15922</div></div>
<div class="ttc" id="agroup__nvn__c__entryfuncptrs_html_gaac2535d2f4e2740efa3fd69d683110fc"><div class="ttname"><a href="group__nvn__c__entryfuncptrs.html#gaac2535d2f4e2740efa3fd69d683110fc">PFNNVNDEVICEINITIALIZEPROC</a></div><div class="ttdeci">NVNboolean(* PFNNVNDEVICEINITIALIZEPROC)(NVNdevice *device, const NVNdeviceBuilder *builder)</div><div class="ttdoc">Function pointer type to call nvnDeviceInitialize().</div><div class="ttdef"><b>Definition:</b> nvn.h:15913</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_ga58e9b155d7f2272b95044eed1f40415e"><div class="ttname"><a href="group__nvn__c__enum.html#ga58e9b155d7f2272b95044eed1f40415e">NVNwindowAcquireTextureResult</a></div><div class="ttdeci">NVNwindowAcquireTextureResult</div><div class="ttdoc">Specifies the result of acquiring a texture from a window.</div><div class="ttdef"><b>Definition:</b> nvn.h:2673</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_ga661d03f0e1c886c81d5ccc67935df182"><div class="ttname"><a href="group__nvn__c__enum.html#ga661d03f0e1c886c81d5ccc67935df182">NVNdebugCallbackType</a></div><div class="ttdeci">NVNdebugCallbackType</div><div class="ttdoc">Specifies the type of event triggering a debug callback.</div><div class="ttdef"><b>Definition:</b> nvn.h:2924</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_ga6d72003c068d7795201e77d27bf8c7ac"><div class="ttname"><a href="group__nvn__c__enum.html#ga6d72003c068d7795201e77d27bf8c7ac">NVNdebugCallbackSeverity</a></div><div class="ttdeci">NVNdebugCallbackSeverity</div><div class="ttdoc">Specifies the severity of the event triggering a debug callback.</div><div class="ttdef"><b>Definition:</b> nvn.h:2954</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_ga70a49f98019e4832818240297bee7eb3"><div class="ttname"><a href="group__nvn__c__enum.html#ga70a49f98019e4832818240297bee7eb3">NVNdebugCallbackSource</a></div><div class="ttdeci">NVNdebugCallbackSource</div><div class="ttdoc">Specifies the type of operation being performed when a debug callback is made.</div><div class="ttdef"><b>Definition:</b> nvn.h:2902</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_gga9c68350bf64f2e7a90a23290c26872d3ac002cdaba27241c296213d4722dad0a6"><div class="ttname"><a href="group__nvn__c__enum.html#gga9c68350bf64f2e7a90a23290c26872d3ac002cdaba27241c296213d4722dad0a6">NVN_DEVICE_FLAG_DEBUG_ENABLE_LEVEL_2_BIT</a></div><div class="ttdeci">@ NVN_DEVICE_FLAG_DEBUG_ENABLE_LEVEL_2_BIT</div><div class="ttdoc">Enable (TRUE) or disable (FALSE) level 2 debug layer for the device.</div><div class="ttdef"><b>Definition:</b> nvn.h:2828</div></div>
<div class="ttc" id="agroup__nvn__c__funcptrs_html_ga6d548eaff5d46c83d72a818154476b84"><div class="ttname"><a href="group__nvn__c__funcptrs.html#ga6d548eaff5d46c83d72a818154476b84">PFNNVNBOOTSTRAPLOADERPROC</a></div><div class="ttdeci">PFNNVNGENERICFUNCPTRPROC(* PFNNVNBOOTSTRAPLOADERPROC)(const char *name)</div><div class="ttdoc">Function pointer type used to retreive main API entry points such as nvnDeviceInitialize and nvnDevic...</div><div class="ttdef"><b>Definition:</b> nvn.h:4646</div></div>
<div class="ttc" id="agroup__nvn__c__funcptrs_html_gab106acc34961bf1c3a43514686dbfc4b"><div class="ttname"><a href="group__nvn__c__funcptrs.html#gab106acc34961bf1c3a43514686dbfc4b">PFNNVNDEBUGCALLBACKPROC</a></div><div class="ttdeci">void(* PFNNVNDEBUGCALLBACKPROC)(NVNdebugCallbackSource source, NVNdebugCallbackType type, int id, NVNdebugCallbackSeverity severity, const char *message, void *userParam)</div><div class="ttdoc">Function pointer type used to specify a function to call for debug callbacks.</div><div class="ttdef"><b>Definition:</b> nvn.h:4674</div></div>
<div class="ttc" id="agroup__nvn__c__handle_html_gab7f10945ffe1f6161c87238c75ae411d"><div class="ttname"><a href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a></div><div class="ttdeci">uint64_t NVNcommandHandle</div><div class="ttdoc">GPU handle used to refer to a command buffer object.</div><div class="ttdef"><b>Definition:</b> nvn.h:437</div></div>
<div class="ttc" id="anamespacenn_1_1gfx_html_ad620d8208dd309eb7c4dd5973a6aeee5"><div class="ttname"><a href="namespacenn_1_1gfx.html#ad620d8208dd309eb7c4dd5973a6aeee5">nn::gfx::MemoryPool</a></div><div class="ttdeci">TMemoryPool&lt; TargetConfig::Variation &gt; MemoryPool</div><div class="ttdoc">The type definition representing a memory pool.</div><div class="ttdef"><b>Definition:</b> gfx_Types.h:116</div></div>
<div class="ttc" id="anamespacenn_1_1socket_html_a895595468f09d14293edd099a8ff7dc5"><div class="ttname"><a href="namespacenn_1_1socket.html#a895595468f09d14293edd099a8ff7dc5">nn::socket::Shutdown</a></div><div class="ttdeci">int Shutdown(int socket, ShutdownMethod how) NN_NOEXCEPT</div><div class="ttdoc">Disable sends and/or receives on a socket.</div></div>
<div class="ttc" id="anamespacenn_1_1ui2d_html_a3d128ec7087f91b3f54cbfcf73fb93b9"><div class="ttname"><a href="namespacenn_1_1ui2d.html#a3d128ec7087f91b3f54cbfcf73fb93b9">nn::ui2d::MajorVersion</a></div><div class="ttdeci">const uint8_t MajorVersion</div><div class="ttdoc">Major version of the resource.</div><div class="ttdef"><b>Definition:</b> ui2d_Resources.h:47</div></div>
<div class="ttc" id="anamespacenn_1_1ui2d_html_a8ebb4f5324b526c9e74f0b01037fb74c"><div class="ttname"><a href="namespacenn_1_1ui2d.html#a8ebb4f5324b526c9e74f0b01037fb74c">nn::ui2d::MinorVersion</a></div><div class="ttdeci">const uint8_t MinorVersion</div><div class="ttdoc">Minor version of the resource.</div><div class="ttdef"><b>Definition:</b> ui2d_Resources.h:54</div></div>
<div class="ttc" id="ann___assert_8h_html"><div class="ttname"><a href="nn___assert_8h.html">nn_Assert.h</a></div><div class="ttdoc">Declarations for API resources to test whether conditions are satisfied.</div></div>
<div class="ttc" id="ann___assert_8h_html_ade59d1d911907a16c0241f8fe3b31542"><div class="ttname"><a href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a></div><div class="ttdeci">#define NN_ASSERT(condition,...)</div><div class="ttdoc">Tests whether a condition is satisfied.</div><div class="ttdef"><b>Definition:</b> nn_Assert.h:124</div></div>
<div class="ttc" id="ann___log_8h_html"><div class="ttname"><a href="nn___log_8h.html">nn_Log.h</a></div><div class="ttdoc">Declarations for the logging API.</div></div>
<div class="ttc" id="ann___log_8h_html_a2d720c8bc6b733bce63879350d134a84"><div class="ttname"><a href="nn___log_8h.html#a2d720c8bc6b733bce63879350d134a84">NN_LOG</a></div><div class="ttdeci">#define NN_LOG(...)</div><div class="ttdoc">Adds the string specified in the parameter as a log entry.</div><div class="ttdef"><b>Definition:</b> nn_Log.h:33</div></div>
<div class="ttc" id="ann___macro_8h_html_af2d1673769927c5eae977d8dde3ce106"><div class="ttname"><a href="nn___macro_8h.html#af2d1673769927c5eae977d8dde3ce106">NN_UNUSED</a></div><div class="ttdeci">#define NN_UNUSED(variable)</div><div class="ttdoc">Suppresses compiler warnings on intentionally unused variables.</div><div class="ttdef"><b>Definition:</b> nn_Macro.h:610</div></div>
<div class="ttc" id="anvn___func_ptr_impl_8h_html"><div class="ttname"><a href="nvn___func_ptr_impl_8h.html">nvn_FuncPtrImpl.h</a></div><div class="ttdoc">Definition of the global function pointer variables implementing the entry points of the NVN C interf...</div></div>
<div class="ttc" id="anvn___func_ptr_inline_8h_html"><div class="ttname"><a href="nvn___func_ptr_inline_8h.html">nvn_FuncPtrInline.h</a></div><div class="ttdoc">Implementation of the NVN C interface entry points as inline functions that call through global funct...</div></div>
<div class="ttc" id="astruct_n_v_ncommand_buffer_html"><div class="ttname"><a href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a></div><div class="ttdoc">Collection of commands to send to the GPU via queues.</div><div class="ttdef"><b>Definition:</b> nvn.h:236</div></div>
<div class="ttc" id="astruct_n_v_ndevice_builder_html"><div class="ttname"><a href="struct_n_v_ndevice_builder.html">NVNdeviceBuilder</a></div><div class="ttdoc">Object specifying state used to construct new device objects.</div><div class="ttdef"><b>Definition:</b> nvn.h:216</div></div>
<div class="ttc" id="astruct_n_v_ndevice_html"><div class="ttname"><a href="struct_n_v_ndevice.html">NVNdevice</a></div><div class="ttdoc">API class used to represent a specific GPU/device.</div><div class="ttdef"><b>Definition:</b> nvn.h:221</div></div>
<div class="ttc" id="astruct_n_v_nqueue_builder_html"><div class="ttname"><a href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a></div><div class="ttdoc">Object specifying state used to construct new queue objects.</div><div class="ttdef"><b>Definition:</b> nvn.h:226</div></div>
<div class="ttc" id="astruct_n_v_nqueue_html"><div class="ttname"><a href="struct_n_v_nqueue.html">NVNqueue</a></div><div class="ttdoc">API class used to send commands to the GPU.</div><div class="ttdef"><b>Definition:</b> nvn.h:231</div></div>
<div class="ttc" id="astruct_n_v_nsync_html"><div class="ttname"><a href="struct_n_v_nsync.html">NVNsync</a></div><div class="ttdoc">Synchronization primitive object used to order execution of commands and track progress.</div><div class="ttdef"><b>Definition:</b> nvn.h:364</div></div>
<div class="ttc" id="astruct_n_v_ntexture_builder_html"><div class="ttname"><a href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a></div><div class="ttdoc">Object specifying state used to construct new texture objects.</div><div class="ttdef"><b>Definition:</b> nvn.h:330</div></div>
<div class="ttc" id="astruct_n_v_ntexture_html"><div class="ttname"><a href="struct_n_v_ntexture.html">NVNtexture</a></div><div class="ttdoc">Block of GPU-accessible memory and related state used to hold image data.</div><div class="ttdef"><b>Definition:</b> nvn.h:325</div></div>
<div class="ttc" id="astruct_n_v_nwindow_builder_html"><div class="ttname"><a href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a></div><div class="ttdoc">Object specifying state used to construct new window objects.</div><div class="ttdef"><b>Definition:</b> nvn.h:375</div></div>
<div class="ttc" id="astruct_n_v_nwindow_html"><div class="ttname"><a href="struct_n_v_nwindow.html">NVNwindow</a></div><div class="ttdoc">Object that manages texture presentation to the platform windowing system.</div><div class="ttdef"><b>Definition:</b> nvn.h:370</div></div>
</div><!-- fragment --> </div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
