<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NvnTutorial/AssetFileLoadingHelper.cpp | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">NvnTutorial/AssetFileLoadingHelper.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<p>For an explanation of the source code, see <a class="el" href="_page_sample_nvn_tutorial_library.html">NVN Tutorial Library</a> and <tt>NvnTutorial/AssetFileLoadingHelper.cpp</tt>.</p>
<div class="fragment"><div class="line"><span class="comment">/*--------------------------------------------------------------------------------*</span></div>
<div class="line"><span class="comment">  Copyright (C)Nintendo All rights reserved.</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  These coded instructions, statements, and computer programs contain proprietary</span></div>
<div class="line"><span class="comment">  information of Nintendo and/or its licensed developers and are protected by</span></div>
<div class="line"><span class="comment">  national and international copyright laws. They may not be disclosed to third</span></div>
<div class="line"><span class="comment">  parties or copied or duplicated in any form, in whole or in part, without the</span></div>
<div class="line"><span class="comment">  prior written consent of Nintendo.</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  The content herein is highly confidential and should be handled accordingly.</span></div>
<div class="line"><span class="comment"> *--------------------------------------------------------------------------------*/</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstring&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fs_8h.html">nn/fs.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="nn___assert_8h.html">nn/nn_Assert.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="nn___log_8h.html">nn/nn_Log.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="nvn_8h.html">nvn/nvn.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="nvn___func_ptr_inline_8h.html">nvn/nvn_FuncPtrInline.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_asset_file_loading_helper_8h.html">nvntutorial/AssetFileLoadingHelper.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_output_file_headers_8h.html">nvntutorial/OutputFileHeaders.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_tutorial_util_8h.html">nvntutorial/TutorialUtil.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_texture_i_d_manager_8h.html">nvntutorial/TextureIDManager.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_memory_pool_8h.html">nvntutorial/MemoryPool.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * AssetFileLoadingHelper Constructor</span></div>
<div class="line"><span class="comment"> * ----------------------------------</span></div>
<div class="line"><span class="comment"> * Sets up the file loader with a pointer to the NVNdevice and</span></div>
<div class="line"><span class="comment"> * the texture ID manager for the application.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">AssetFileLoadingHelper::AssetFileLoadingHelper(<a name="_a0"></a><a class="code" href="struct_n_v_ndevice.html">NVNdevice</a>* pDevice, TextureIDManager* pTextureIDManager) :</div>
<div class="line">    m_pDevice(pDevice),</div>
<div class="line">    m_pTextureIDManager(pTextureIDManager),</div>
<div class="line">    m_pFileHead(NULL),</div>
<div class="line">    m_FileSize(0)</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">* AssetFileLoadingHelper Destructor</span></div>
<div class="line"><span class="comment">* ---------------------------------</span></div>
<div class="line"><span class="comment">* Cleans up the file loader.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line">AssetFileLoadingHelper::~AssetFileLoadingHelper()</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * AssetFileLoadingHelper::LoadAssetFile</span></div>
<div class="line"><span class="comment"> * -------------------------------------</span></div>
<div class="line"><span class="comment"> * Loads the binary asset file, checks for each section of</span></div>
<div class="line"><span class="comment"> * the file, and interprets the data for the sections that</span></div>
<div class="line"><span class="comment"> * exist.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">AssetFileDataHolder* AssetFileLoadingHelper::LoadAssetFile(<span class="keyword">const</span> <span class="keywordtype">char</span>* pFilename)</div>
<div class="line">{</div>
<div class="line">    <a name="a1"></a><a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(pFilename != NULL, <span class="stringliteral">&quot;File name to load NULL&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Reads in the binary file and grabs a pointer to its head. */</span></div>
<div class="line">    <a name="_a2"></a><a class="code" href="structnn_1_1fs_1_1_file_handle.html">nn::fs::FileHandle</a> fileHandle;</div>
<div class="line">    std::string rom(<span class="stringliteral">&quot;rom:/&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <a name="_a3"></a><a class="code" href="classnn_1_1_result.html">nn::Result</a> res = <a name="a4"></a><a class="code" href="namespacenn_1_1fs.html#a0f2b5b30657b1ffaf1dec49bfb36462b">nn::fs::OpenFile</a>(&amp;fileHandle, (rom + pFilename).c_str(), <a name="a5"></a><a class="code" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393afde4472d2b455879cad02aade386ac0d">nn::fs::OpenMode_Read</a>);</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(res.IsSuccess());</div>
<div class="line"> </div>
<div class="line">    res = <a name="a6"></a><a class="code" href="namespacenn_1_1fs.html#aba29e01d386e809349d60eccdb15ff21">nn::fs::GetFileSize</a>(&amp;m_FileSize, fileHandle);</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(res.IsSuccess());</div>
<div class="line"> </div>
<div class="line">    m_pFileHead = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(AlignedAllocate(<span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(m_FileSize + 1), 8));</div>
<div class="line">    memset(m_pFileHead, 0, <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(m_FileSize + 1));</div>
<div class="line">    <span class="keywordtype">size_t</span> out;</div>
<div class="line">    res = <a name="a7"></a><a class="code" href="namespacenn_1_1fs.html#a81801a404563984f8c6cc1483cc6d730">nn::fs::ReadFile</a>(&amp;out, fileHandle, 0, m_pFileHead, <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(m_FileSize));</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(res.IsSuccess());</div>
<div class="line"> </div>
<div class="line">    OutputFileHeader* pFileHeader = <span class="keyword">reinterpret_cast&lt;</span>OutputFileHeader*<span class="keyword">&gt;</span>(m_pFileHead);</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(pFileHeader != NULL, <span class="stringliteral">&quot;Failed to read file header&quot;</span>)</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Creates a default buffer builder. */</span></div>
<div class="line">    nvnBufferBuilderSetDevice(&amp;m_BufferBuilder, m_pDevice);</div>
<div class="line">    nvnBufferBuilderSetDefaults(&amp;m_BufferBuilder);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Creates a default texture builder. */</span></div>
<div class="line">    nvnTextureBuilderSetDevice(&amp;m_TextureBuilder, m_pDevice);</div>
<div class="line">    nvnTextureBuilderSetDefaults(&amp;m_TextureBuilder);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Creates a default sampler builder. */</span></div>
<div class="line">    nvnSamplerBuilderSetDevice(&amp;m_SamplerBuilder, m_pDevice);</div>
<div class="line">    nvnSamplerBuilderSetDefaults(&amp;m_SamplerBuilder);</div>
<div class="line"> </div>
<div class="line">    m_pDataHolder = new AssetFileDataHolder();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Check for the shader section of the file and interpret the data. */</span></div>
<div class="line">    if (pFileHeader-&gt;m_ShaderBlockOffset &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">char</span>* pShaderBlockHead = m_pFileHead + pFileHeader-&gt;m_ShaderBlockOffset;</div>
<div class="line">        LoadShaders(pShaderBlockHead);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Check for the texture section of the file and interpret the data. */</span></div>
<div class="line">    <span class="keywordflow">if</span> (pFileHeader-&gt;m_TextureBlockOffset &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">char</span>* pTextureBlockHead = m_pFileHead + pFileHeader-&gt;m_TextureBlockOffset;</div>
<div class="line">        LoadTextures(pTextureBlockHead);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Check for the model section of the file and interpret the data. */</span></div>
<div class="line">    <span class="keywordflow">if</span> (pFileHeader-&gt;m_ModelBlockOffset &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">char</span>* pModelBlockHead = m_pFileHead + pFileHeader-&gt;m_ModelBlockOffset;</div>
<div class="line">        LoadModels(pModelBlockHead);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a name="a8"></a><a class="code" href="namespacenn_1_1fs.html#ac8bd9e828751bd4f953acfa765278f84">nn::fs::CloseFile</a>(fileHandle);</div>
<div class="line"> </div>
<div class="line">    AlignedDeallocate(m_pFileHead);</div>
<div class="line">    m_pFileHead = NULL;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> m_pDataHolder;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * AssetFileLoadingHelper::LoadSpecializedShaders</span></div>
<div class="line"><span class="comment"> * -------------------------------------</span></div>
<div class="line"><span class="comment"> * Generates the specialized versions of a set of shaders</span></div>
<div class="line"><span class="comment"> * passed in and loaded at runtime into a number of unique</span></div>
<div class="line"><span class="comment"> * shader programs, new NVNProgramData objects are loaded</span></div>
<div class="line"><span class="comment"> * into the AssetFileLoadingHelper class used to call</span></div>
<div class="line"><span class="comment"> * this function</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> AssetFileLoadingHelper::LoadSpecializedShaders(</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>** ppShaderSources,</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;NVNshaderStage&gt;&amp; shaderStages,</div>
<div class="line">    <a name="_a9"></a><a class="code" href="struct_g_l_s_l_cspecialization_batch.html">GLSLCspecializationBatch</a>* specializationBatch,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* shaderProgramName,</div>
<div class="line">    <span class="keywordtype">int</span> nameLength,</div>
<div class="line">    ReflectionBlockInfoFunction blockFunction,</div>
<div class="line">    ReflectionUniformInfoFunction uniformFunction,</div>
<div class="line">    AttributeReflectionInfoFunction attributeFunction)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(ppShaderSources != NULL, <span class="stringliteral">&quot;No shader source passed in\n&quot;</span>);</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(shaderStages.size() &gt; 0, <span class="stringliteral">&quot;No shader stages passed in\n&quot;</span>);</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(specializationBatch != NULL, <span class="stringliteral">&quot;No shader specialization batch passed in\n&quot;</span>);</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(blockFunction != NULL &amp;&amp; uniformFunction != NULL, <span class="stringliteral">&quot;No reflection functions passed to shader specialization\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * The compile object contains the input shader source, options for compilation,</span></div>
<div class="line"><span class="comment">         * and all the results (error logs in the result of failure) of each step of</span></div>
<div class="line"><span class="comment">         * compilation.  Valid until the object is used for another regular Compile</span></div>
<div class="line"><span class="comment">         * operation, Pre-Specialized + Specialized operation, or until the object</span></div>
<div class="line"><span class="comment">         * is finalized.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <a name="_a10"></a><a class="code" href="struct_g_l_s_l_ccompile_object.html">GLSLCcompileObject</a> compileObject;</div>
<div class="line">    uint8_t initializeResult = <a class="code" href="nvn_tool___glslc_interface_8h.html#a648dfc0b503357a72dad03652fc31e57">glslcInitialize</a>(&amp;compileObject);</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(initializeResult == 1, <span class="stringliteral">&quot;Failed to initialize glslc compile object\n&quot;</span>);</div>
<div class="line">    <a name="a11"></a><a class="code" href="nn___macro_8h.html#af2d1673769927c5eae977d8dde3ce106">NN_UNUSED</a>(initializeResult);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Contains input array of shader source */</span></div>
<div class="line">    <a name="_a12"></a><a class="code" href="struct_g_l_s_l_cinput.html">GLSLCinput</a>&amp; glslcInput = compileObject.<a name="a13"></a><a class="code" href="struct_g_l_s_l_ccompile_object.html#a1439e7a28e5232e1dc82924e8c4d063d">input</a>;</div>
<div class="line">    glslcInput.sources = ppShaderSources;</div>
<div class="line">    glslcInput.<a name="a14"></a><a class="code" href="struct_g_l_s_l_cinput.html#a2dd94f2657ef155e688d6a9927c6c381">count</a> = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(shaderStages.size());</div>
<div class="line">    glslcInput.stages = &amp;shaderStages[0];</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Various options available for compiling the shaders */</span></div>
<div class="line">    <a name="_a15"></a><a class="code" href="struct_g_l_s_l_coptions.html">GLSLCoptions</a>&amp; glslcOptions = compileObject.<a name="a16"></a><a class="code" href="struct_g_l_s_l_ccompile_object.html#a6cc042ea5fe41d3aa6c9fac773a447b8">options</a>;</div>
<div class="line">    glslcOptions.<a name="a17"></a><a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a name="a18"></a><a class="code" href="struct_g_l_s_l_coption_flags.html#af673dc6b82db05442d203619be5a022d">glslSeparable</a> = shaderStages.size() &lt; 2;</div>
<div class="line">    glslcOptions.<a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a name="a19"></a><a class="code" href="struct_g_l_s_l_coption_flags.html#ac0396d28c3ec928aaa280cb90e71f485">outputAssembly</a> = <span class="keyword">false</span>;</div>
<div class="line">    <span class="comment">// NOTE: This must be set to true for now.</span></div>
<div class="line">    glslcOptions.<a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a name="a20"></a><a class="code" href="struct_g_l_s_l_coption_flags.html#aec0779a250ad31f6deafe470820ffbb8">outputGpuBinaries</a> = <span class="keyword">true</span>;</div>
<div class="line">    glslcOptions.<a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a name="a21"></a><a class="code" href="struct_g_l_s_l_coption_flags.html#ad57cedc549a410a87a8b5e667afd31b9">outputPerfStats</a> = <span class="keyword">true</span>;</div>
<div class="line">    glslcOptions.<a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a name="a22"></a><a class="code" href="struct_g_l_s_l_coption_flags.html#a723afb9e18cdf4c92bfe315c94e37c96">outputShaderReflection</a> = <span class="keyword">true</span>;</div>
<div class="line">    glslcOptions.<a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a name="a23"></a><a class="code" href="struct_g_l_s_l_coption_flags.html#af2b81192a389ab5093f074ced7ceea29">outputDebugInfo</a> = <a class="code" href="nvn_tool___glslc_interface_8h.html#a238b82c174a58d9f9e2be6aa3e8a5bfea81704ec256f338d05d20e0d618decdef">GLSLC_DEBUG_LEVEL_G0</a>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Denotes whether to output gpu binaries of</span></div>
<div class="line"><span class="comment">         * a smaller size for exclusive use on the NX</span></div>
<div class="line"><span class="comment">         * device. This option has no effect on binaries</span></div>
<div class="line"><span class="comment">         * generated on Windows, which will continue to</span></div>
<div class="line"><span class="comment">         * contain the data necessary for both Windows</span></div>
<div class="line"><span class="comment">         * and NX use.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line"><span class="preprocessor">#ifdef NN_BUILD_TARGET_PLATFORM_OS_WIN</span></div>
<div class="line">    glslcOptions.<a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a name="a24"></a><a class="code" href="struct_g_l_s_l_coption_flags.html#acb869c3adcd98163305142fba3d84e2b">outputThinGpuBinaries</a> = 0;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    glslcOptions.<a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a class="code" href="struct_g_l_s_l_coption_flags.html#acb869c3adcd98163305142fba3d84e2b">outputThinGpuBinaries</a> = 1;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * The first step of shader specialization, the pre-specialized compile</span></div>
<div class="line"><span class="comment">         * function takes the raw shader source and generates intermediary</span></div>
<div class="line"><span class="comment">         * data that will be used in the specialized compile function below.</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * NOTE: When using glslc online, it is required that glslcSetAllocator</span></div>
<div class="line"><span class="comment">         * is called with function pointers to an allocator and deallocator function</span></div>
<div class="line"><span class="comment">         * for glslc functions (bar glslcInitialize) to work.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <span class="keywordflow">if</span>(!<a class="code" href="nvn_tool___glslc_interface_8h.html#a8a7629609d27a49283b8cb9587dcca48">glslcCompilePreSpecialized</a>(&amp;compileObject))</div>
<div class="line">    {</div>
<div class="line">        <a name="a25"></a><a class="code" href="nn___log_8h.html#a2d720c8bc6b733bce63879350d134a84">NN_LOG</a>(compileObject.lastCompiledResults-&gt;compilationStatus-&gt;infoLog);</div>
<div class="line">        <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;Shader specialization precompilation failed\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Reflection information is ALWAYS generated by the pre-specialized function</span></div>
<div class="line"><span class="comment">         * above, regardless of whether the outputShaderReflection flag is set in the</span></div>
<div class="line"><span class="comment">         * glslc options above.  The reflection header contains offsets into the header</span></div>
<div class="line"><span class="comment">         * itself that contain the actual reflection information.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <a name="_a26"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html">GLSLCprogramReflectionHeader</a>* pReflectionHeader = compileObject.reflectionSection;</div>
<div class="line">    <span class="keyword">const</span> uint8_t* pReflectionData = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint8_t*<span class="keyword">&gt;</span>(pReflectionHeader) + pReflectionHeader-&gt;<a name="a27"></a>common.<a name="a28"></a><a class="code" href="struct_g_l_s_l_csection_header_common.html#abb6e96b70bad30c94477317328d384d5">dataOffset</a>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* pStringPool = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(pReflectionData) + pReflectionHeader-&gt;<a name="a29"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#a23a3fcd75086c2b537f992e212661622">stringPoolOffset</a>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Grabs a pointer to the reflection information of the first uniform block</span></div>
<div class="line"><span class="comment">         * listed.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <span class="keyword">const</span> <a name="_a30"></a><a class="code" href="struct_g_l_s_l_cuniform_block_info.html">GLSLCuniformBlockInfo</a>* pUniformBlock = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code" href="struct_g_l_s_l_cuniform_block_info.html">GLSLCuniformBlockInfo</a> *<span class="keyword">&gt;</span>(pReflectionData + pReflectionHeader-&gt;<a name="a31"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#ab7239cf2349bda4632d8382ffddcde85">uniformBlockOffset</a>);</div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; pReflectionHeader-&gt;<a name="a32"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#a006944206bfbf2bbfb56c1dfb9dc7f96">numUniformBlocks</a>; ++i)</div>
<div class="line">    {</div>
<div class="line">            <span class="comment">/*</span></div>
<div class="line"><span class="comment">             * Grab the binding location of the uniform block.  Each of the</span></div>
<div class="line"><span class="comment">             * entries in the bindings array corresponds to the enum values</span></div>
<div class="line"><span class="comment">             * in NVNshaderStage and lists the binding location of the block</span></div>
<div class="line"><span class="comment">             * in that stage;  a value of -1 means the block is not bound</span></div>
<div class="line"><span class="comment">             * in that stage.</span></div>
<div class="line"><span class="comment">             */</span></div>
<div class="line">        int32_t bindingLocation = -1;</div>
<div class="line">        <span class="keywordflow">for</span>(uint32_t j = 0; j &lt; GLSLC_NUM_SHADER_STAGES; ++j)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span>(pUniformBlock-&gt;<a name="a33"></a><a class="code" href="struct_g_l_s_l_cuniform_block_info.html#a3089f78f6431b069fca45643190b8f88">bindings</a>[j] &gt; -1)</div>
<div class="line">            {</div>
<div class="line">                bindingLocation = pUniformBlock-&gt;<a class="code" href="struct_g_l_s_l_cuniform_block_info.html#a3089f78f6431b069fca45643190b8f88">bindings</a>[j];</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/*</span></div>
<div class="line"><span class="comment">             * Pass the reflection information (binding location, block size, and name)</span></div>
<div class="line"><span class="comment">             * through the function pointer passed in.  Additional reflection parameters</span></div>
<div class="line"><span class="comment">             * can be found in the definition of the GLSLCuniformBlockInfo struct.</span></div>
<div class="line"><span class="comment">             */</span></div>
<div class="line">        <span class="keywordflow">if</span>(bindingLocation &gt; -1)</div>
<div class="line">        {</div>
<div class="line">            std::string blockName = pStringPool + pUniformBlock-&gt;<a name="a34"></a><a class="code" href="struct_g_l_s_l_cuniform_block_info.html#af581f038ae9544eb77e43729691532a8">nameInfo</a>.<a name="a35"></a><a class="code" href="struct_g_l_s_l_cpiq_name.html#a95cb55a78c99bc13a5442a4ec038fe64">nameOffset</a>;</div>
<div class="line">                <span class="comment">/* Call reflection function */</span></div>
<div class="line">            blockFunction(pUniformBlock-&gt;<a name="a36"></a><a class="code" href="struct_g_l_s_l_cuniform_block_info.html#a449b0310144f865d20c9152228c1f5c2">stagesReferencedIn</a>, bindingLocation, pUniformBlock-&gt;<a name="a37"></a><a class="code" href="struct_g_l_s_l_cuniform_block_info.html#a995ad7b06ac8f754faceea20cb6b8443">size</a>, blockName);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Advance to the next uniform block&#39;s reflection info */</span></div>
<div class="line">        ++pUniformBlock;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Grabs a pointer to the reflection information of the first uniform variable</span></div>
<div class="line"><span class="comment">         * listed.  The uniforms in this part of the reflection header come from all</span></div>
<div class="line"><span class="comment">         * uniform blocks in the shaders provided and no guarantee is made to their</span></div>
<div class="line"><span class="comment">         * ordering.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <span class="keyword">const</span> <a name="_a38"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html">GLSLCuniformInfo</a>* pUniformData = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code" href="struct_g_l_s_l_cuniform_info.html">GLSLCuniformInfo</a> *<span class="keyword">&gt;</span>(pReflectionData + pReflectionHeader-&gt;<a name="a39"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#a7116c27cf2638894a145fcdbb7d05568">uniformOffset</a>);</div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t j = 0; j &lt; pReflectionHeader-&gt;<a name="a40"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#a0bf19ae5c6027329eec9480f13c71d3c">numUniforms</a>; ++j)</div>
<div class="line">    {</div>
<div class="line">        std::string uniformName = pStringPool + pUniformData-&gt;<a name="a41"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html#af3c2cf0a643a810defd8f1964ee5347c">nameInfo</a>.<a class="code" href="struct_g_l_s_l_cpiq_name.html#a95cb55a78c99bc13a5442a4ec038fe64">nameOffset</a>;</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/*</span></div>
<div class="line"><span class="comment">             * Pass the reflection information (stages uniform is referenced in, offset in uniform block, and name)</span></div>
<div class="line"><span class="comment">             * through the function pointer passed in.  Additional reflection parameters can be found in the</span></div>
<div class="line"><span class="comment">             * definition of the GLSLCuniformInfo struct.</span></div>
<div class="line"><span class="comment">             */</span></div>
<div class="line">        uniformFunction(pUniformData-&gt;<a name="a42"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html#a062aec36dd8b1203f67b1a8bd12948ee">stagesReferencedIn</a>, pUniformData-&gt;<a name="a43"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html#a2f72999cec8d93607ffc6c9488c8bd6e">blockOffset</a>, 0, uniformName);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Advance to the next uniform variable&#39;s reflection info */</span></div>
<div class="line">        ++pUniformData;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Grabs a pointer to the reflection information of the shader</span></div>
<div class="line"><span class="comment">         * program inputs.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <span class="keyword">const</span> <a name="_a44"></a><a class="code" href="struct_g_l_s_l_cprogram_input_info.html">GLSLCprogramInputInfo</a>* pProgramInput = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code" href="struct_g_l_s_l_cprogram_input_info.html">GLSLCprogramInputInfo</a> *<span class="keyword">&gt;</span>(pReflectionData + pReflectionHeader-&gt;<a name="a45"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#a9f264ef95c68193971b360b4df2f259d">programInputsOffset</a>);</div>
<div class="line">    <span class="keywordflow">for</span>(uint32_t j = 0; j &lt; pReflectionHeader-&gt;<a name="a46"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#aca10eea8e482a030016556875aec0a7f">numProgramInputs</a>; ++j)</div>
<div class="line">    {</div>
<div class="line">        std::string name = pStringPool + pProgramInput-&gt;<a name="a47"></a><a class="code" href="struct_g_l_s_l_cprogram_input_info.html#a30e2dc0f471667ac41cdde8329d71e25">nameInfo</a>.<a class="code" href="struct_g_l_s_l_cpiq_name.html#a95cb55a78c99bc13a5442a4ec038fe64">nameOffset</a>;</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/*</span></div>
<div class="line"><span class="comment">             * Pass the reflection information (stages attribute is referenced in, binding location, and name)</span></div>
<div class="line"><span class="comment">             * through the function pointer passed in.</span></div>
<div class="line"><span class="comment">             */</span></div>
<div class="line">        attributeFunction(pProgramInput-&gt;<a name="a48"></a><a class="code" href="struct_g_l_s_l_cprogram_input_info.html#aa850abcd72ca572b118cea86cc858af7">stagesReferencedIn</a>, pProgramInput-&gt;<a name="a49"></a><a class="code" href="struct_g_l_s_l_cprogram_input_info.html#ac0100c9580f95e97b101ae505680bef0">location</a>, name);</div>
<div class="line">        ++pProgramInput;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * The second and last step of shader specialization, the specialized</span></div>
<div class="line"><span class="comment">         * compile function takes the intermediary data stored in the compile</span></div>
<div class="line"><span class="comment">         * object and generates an array of GLSLCoutput objects, each one</span></div>
<div class="line"><span class="comment">         * representing the compiled output of one of the shader programs.</span></div>
<div class="line"><span class="comment">         * The number of output objects corresponds to the number of</span></div>
<div class="line"><span class="comment">         * specialization sets contained in the specialization batch object.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <span class="keyword">const</span> <a name="_a50"></a><a class="code" href="struct_g_l_s_l_coutput.html">GLSLCoutput</a>* <span class="keyword">const</span>* ppGlslcOutputs = <a class="code" href="nvn_tool___glslc_interface_8h.html#a64bdf010fc635ccc01dc9f1625557da1">glslcCompileSpecialized</a>(&amp;compileObject, specializationBatch);</div>
<div class="line">    <span class="keywordflow">if</span>(ppGlslcOutputs == NULL || compileObject.lastCompiledResults-&gt;compilationStatus-&gt;success != 1)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="nn___log_8h.html#a2d720c8bc6b733bce63879350d134a84">NN_LOG</a>(compileObject.lastCompiledResults-&gt;compilationStatus-&gt;infoLog);</div>
<div class="line">        <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;Shader specialization compilation failed\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Looping through the array of output objects, the data within</span></div>
<div class="line"><span class="comment">         * is placed into ShaderStageHeader structs and passed to the</span></div>
<div class="line"><span class="comment">         * CreateShaderProgram function to be placed into memory pools</span></div>
<div class="line"><span class="comment">         * and NVNprograms created.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; specializationBatch-&gt;<a name="a51"></a><a class="code" href="struct_g_l_s_l_cspecialization_batch.html#a0be46d42422ea32ebcc5e31ca3016484">numEntries</a>; ++i)</div>
<div class="line">    {</div>
<div class="line">        NVNProgramData* pProgramData = <span class="keyword">new</span> NVNProgramData;</div>
<div class="line">        pProgramData-&gt;Initialize();</div>
<div class="line">        pProgramData-&gt;SetName(shaderProgramName, nameLength);</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="struct_g_l_s_l_coutput.html">GLSLCoutput</a>* currentGlslcOutput = ppGlslcOutputs[i];</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">int</span> shaderSections = currentGlslcOutput-&gt;<a name="a52"></a><a class="code" href="struct_g_l_s_l_coutput.html#a6cbb6ec5e8a4ff04512fd1c442aa3d92">numSections</a>;</div>
<div class="line">        std::vector&lt;ShaderStageHeader&gt; shaderStageHeaders;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; shaderSections; ++j)</div>
<div class="line">        {</div>
<div class="line">                <span class="comment">/*</span></div>
<div class="line"><span class="comment">                 * Each shader stage (vertex, fragment, etc...) will have a glslc section that</span></div>
<div class="line"><span class="comment">                 * contains all the relevant data for it, as denoted by the GLSLC_SECTION_TYPE_GPU_CODE</span></div>
<div class="line"><span class="comment">                 * enum.  Other types of glslc sections can be found in GLSLCsectionTypeEnum in</span></div>
<div class="line"><span class="comment">                 * nvnToolGlslcInterface.h</span></div>
<div class="line"><span class="comment">                 */</span></div>
<div class="line">            <a class="code" href="nvn_tool___glslc_interface_8h.html#aab53ab9845cc7be41102195446759a59">GLSLCsectionTypeEnum</a> type = currentGlslcOutput-&gt;<a name="a53"></a><a class="code" href="struct_g_l_s_l_coutput.html#a69ff5a7c06d39592caacec94be810995">headers</a>[j].<a name="a54"></a>genericHeader.<a name="a55"></a>common.<a name="a56"></a><a class="code" href="struct_g_l_s_l_csection_header_common.html#a6a8aed7a5a7e82acff908d084fd85e4a">type</a>;</div>
<div class="line">            <span class="keywordflow">if</span> (type == GLSLC_SECTION_TYPE_GPU_CODE)</div>
<div class="line">            {</div>
<div class="line">                <span class="keyword">const</span> <a name="_a57"></a><a class="code" href="struct_g_l_s_l_cgpu_code_header.html">GLSLCgpuCodeHeader</a>&amp; pGpuHeader = (currentGlslcOutput-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#a69ff5a7c06d39592caacec94be810995">headers</a>[j].<a name="a58"></a>gpuCodeHeader);</div>
<div class="line">                <span class="keyword">const</span> uint8_t* pData = (<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint8_t*<span class="keyword">&gt;</span>(currentGlslcOutput)) + pGpuHeader.<a name="a59"></a>common.<a class="code" href="struct_g_l_s_l_csection_header_common.html#abb6e96b70bad30c94477317328d384d5">dataOffset</a>;</div>
<div class="line"> </div>
<div class="line">                shaderStageHeaders.push_back(ShaderStageHeader());</div>
<div class="line">                ShaderStageHeader&amp; currentHeader    = shaderStageHeaders.back();</div>
<div class="line">                currentHeader.m_ShaderStage         = pGpuHeader.<a name="a60"></a><a class="code" href="struct_g_l_s_l_cgpu_code_header.html#ab1e6be676a326a7281e18ad3a4607ced">stage</a>;</div>
<div class="line">                currentHeader.m_ShaderDataSize      = pGpuHeader.<a name="a61"></a><a class="code" href="struct_g_l_s_l_cgpu_code_header.html#a2617848640a161d41ed59f1a7c0ccb35">dataSize</a>;</div>
<div class="line">                currentHeader.m_ShaderControlSize   = pGpuHeader.<a name="a62"></a><a class="code" href="struct_g_l_s_l_cgpu_code_header.html#aff5295c90f2dc5eb969fb14660f31712">controlSize</a>;</div>
<div class="line">                currentHeader.m_ShaderControlOffset = 0;</div>
<div class="line">                currentHeader.m_pShaderData         = <span class="keyword">const_cast&lt;</span>uint8_t*<span class="keyword">&gt;</span>(pData + pGpuHeader.<a name="a63"></a><a class="code" href="struct_g_l_s_l_cgpu_code_header.html#aafdececf784595d922fe1b95b06db976">dataOffset</a>);</div>
<div class="line">                currentHeader.m_pShaderControl      = <span class="keyword">const_cast&lt;</span>uint8_t*<span class="keyword">&gt;</span>(pData + pGpuHeader.<a name="a64"></a><a class="code" href="struct_g_l_s_l_cgpu_code_header.html#a3b606fedf8582a1a47162d210e8a1448">controlOffset</a>);</div>
<div class="line"> </div>
<div class="line">                    <span class="comment">/* Save the max scratch memory size needed for a shader stage of this program. */</span></div>
<div class="line">                pProgramData-&gt;m_ShaderScratchMemorySize = std::max(<span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(pGpuHeader.<a name="a65"></a><a class="code" href="struct_g_l_s_l_cgpu_code_header.html#ac8b1eef84fa9f0debec1874f8b570e62">scratchMemBytesRecommended</a>), pProgramData-&gt;m_ShaderScratchMemorySize);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/*</span></div>
<div class="line"><span class="comment">             * Creates the actual NVNprogram using the shader data pulled above.</span></div>
<div class="line"><span class="comment">             * An NVNProgramData object is inserted into this asset loaders&#39;s</span></div>
<div class="line"><span class="comment">             * data holder.</span></div>
<div class="line"><span class="comment">             */</span></div>
<div class="line">        CreateShaderProgram(shaderStageHeaders, pProgramData);</div>
<div class="line">        m_pDataHolder-&gt;AddProgramData(pProgramData);</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Finalize the compile object, rendering all data it held invalid</span></div>
<div class="line"><span class="comment">         * and preventing reuse of the object until glslcInitialize is called</span></div>
<div class="line"><span class="comment">         * on it again.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <a class="code" href="nvn_tool___glslc_interface_8h.html#a05b2032c99f789df2a34ebf32271c320">glslcFinalize</a>(&amp;compileObject);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * AssetFileLoadingHelper::LoadShaders</span></div>
<div class="line"><span class="comment"> * -----------------------------------</span></div>
<div class="line"><span class="comment"> * Receives a pointer to the shader block of data and passes</span></div>
<div class="line"><span class="comment"> * a pointer to the start of an individual shader program&#39;s</span></div>
<div class="line"><span class="comment"> * block to be parsed.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> AssetFileLoadingHelper::LoadShaders(<span class="keyword">const</span> <span class="keywordtype">char</span>* pShaderBlockHead)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(pShaderBlockHead != NULL, <span class="stringliteral">&quot;Shader block header pointer NULL&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Grabs the number of shaders and their offsets. */</span></div>
<div class="line">    <span class="keyword">const</span> ShaderBlockHeader* pShaderBlockHeader = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>ShaderBlockHeader*<span class="keyword">&gt;</span>(pShaderBlockHead);</div>
<div class="line">    uint32_t numPrograms = pShaderBlockHeader-&gt;m_NumShaderPrograms;</div>
<div class="line">    uint32_t numSpecializedPrograms = pShaderBlockHeader-&gt;m_NumSpecializedShaderPrograms;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> uint64_t* pShaderProgramHeaderOffsets = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint64_t*<span class="keyword">&gt;</span>(pShaderBlockHead + <span class="keyword">sizeof</span>(uint32_t) * 2);</div>
<div class="line">    <span class="keyword">const</span> uint64_t* pSpecializedHeaderOffsets = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint64_t*<span class="keyword">&gt;</span>(pShaderBlockHead + <span class="keyword">sizeof</span>(uint32_t) * 2 + <span class="keyword">sizeof</span>(uint64_t) * numPrograms);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Creates a program for each shader. */</span></div>
<div class="line">    <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; numPrograms; ++i)</div>
<div class="line">    {</div>
<div class="line">        NVNProgramData* pProgramData = LoadShaderHeaders(m_pFileHead + pShaderProgramHeaderOffsets[i]);</div>
<div class="line">        m_pDataHolder-&gt;AddProgramData(pProgramData);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; numSpecializedPrograms; ++i)</div>
<div class="line">    {</div>
<div class="line">        NVNSpecializedProgramData* pSpecializedProgramData = LoadSpecializedShaderHeaders(m_pFileHead + pSpecializedHeaderOffsets[i]);</div>
<div class="line">        m_pDataHolder-&gt;AddSpecializedProgramData(pSpecializedProgramData);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * AssetFileLoadingHelper::LoadShaderHeaders</span></div>
<div class="line"><span class="comment"> * -----------------------------------------</span></div>
<div class="line"><span class="comment"> * Parses the pointer passed in for the data necessary to build</span></div>
<div class="line"><span class="comment"> * an NVNprogram.  This data is then passed onto CreateShaderProgram</span></div>
<div class="line"><span class="comment"> * to actually create the NVNprogram and set up the memory pools</span></div>
<div class="line"><span class="comment"> * for the data to be copied into.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">NVNProgramData* AssetFileLoadingHelper::LoadShaderHeaders(<span class="keyword">const</span> <span class="keywordtype">char</span>* pShaderProgramHead)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(pShaderProgramHead != NULL, <span class="stringliteral">&quot;Shader program header pointer NULL&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Grabs the metadata and the list of offsets to individual shader stages. */</span></div>
<div class="line">    <span class="keyword">const</span> ShaderProgramHeader* pShaderProgramHeader = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>ShaderProgramHeader*<span class="keyword">&gt;</span>(pShaderProgramHead);</div>
<div class="line"> </div>
<div class="line">    uint32_t                   numShaderStages      = pShaderProgramHeader-&gt;m_NumShaderStages;</div>
<div class="line">    <span class="keyword">const</span> uint64_t*            pShaderStageOffsets  = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint64_t*<span class="keyword">&gt;</span>(pShaderProgramHead + <span class="keyword">sizeof</span>(uint32_t) * 4);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>*                pProgramName         = pShaderProgramHead + <span class="keyword">sizeof</span>(uint32_t) * 4 + <span class="keyword">sizeof</span>(uint64_t) * numShaderStages;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (pShaderProgramHeader == NULL ||</div>
<div class="line">        pShaderProgramHeader-&gt;m_ProgramNameLength == 0 ||</div>
<div class="line">        pProgramName == NULL ||</div>
<div class="line">        numShaderStages == 0 ||</div>
<div class="line">        pShaderStageOffsets == NULL)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;Failed to read ShaderProgramHeader&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    NVNProgramData* pProgramData = <span class="keyword">new</span> NVNProgramData;</div>
<div class="line">    pProgramData-&gt;Initialize();</div>
<div class="line">    pProgramData-&gt;SetName(pProgramName, pShaderProgramHeader-&gt;m_ProgramNameLength);</div>
<div class="line">    pProgramData-&gt;m_ShaderType = ShaderTypes::GetShaderTypeEnum(std::string(pProgramData-&gt;m_pProgramName));</div>
<div class="line">    pProgramData-&gt;m_ShaderScratchMemorySize = pShaderProgramHeader-&gt;m_ShaderScratchMemorySize;</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;ShaderStageHeader&gt; shaderStageHeaders;</div>
<div class="line">    shaderStageHeaders.resize(numShaderStages, ShaderStageHeader());</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Grab the stage metadata and pointers to the control and data section</span></div>
<div class="line"><span class="comment">         * of the compiled shader.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; numShaderStages; ++i)</div>
<div class="line">    {</div>
<div class="line">        ShaderStageHeader* pShaderStageHeader = <span class="keyword">reinterpret_cast&lt;</span>ShaderStageHeader*<span class="keyword">&gt;</span>(m_pFileHead + pShaderStageOffsets[i]);</div>
<div class="line"> </div>
<div class="line">        shaderStageHeaders[i].m_ShaderStage         = pShaderStageHeader-&gt;m_ShaderStage;</div>
<div class="line">        shaderStageHeaders[i].m_ShaderDataSize      = pShaderStageHeader-&gt;m_ShaderDataSize;</div>
<div class="line">        shaderStageHeaders[i].m_ShaderControlSize   = pShaderStageHeader-&gt;m_ShaderControlSize;</div>
<div class="line">        shaderStageHeaders[i].m_ShaderControlOffset = pShaderStageHeader-&gt;m_ShaderControlOffset;</div>
<div class="line">        shaderStageHeaders[i].m_pShaderData         = m_pFileHead + pShaderStageOffsets[i] + 4 * <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">        shaderStageHeaders[i].m_pShaderControl      = m_pFileHead + shaderStageHeaders[i].m_ShaderControlOffset;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    CreateShaderProgram(shaderStageHeaders, pProgramData);</div>
<div class="line">    <span class="keywordflow">return</span> pProgramData;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * AssetFileLoadingHelper::CreateShaderProgram</span></div>
<div class="line"><span class="comment"> * -------------------------------------------</span></div>
<div class="line"><span class="comment"> * Saves the shader metadata in an NVNProgramData object</span></div>
<div class="line"><span class="comment"> * and creates an NVNprogram object from the compiled</span></div>
<div class="line"><span class="comment"> * shader binary.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> AssetFileLoadingHelper::CreateShaderProgram(std::vector&lt;ShaderStageHeader&gt;&amp; shaderStageHeaders, NVNProgramData* pProgramData)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(pProgramData != NULL, <span class="stringliteral">&quot;Pointer to program data to modify is NULL&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    uint32_t numShaderStages = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(shaderStageHeaders.size());</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;size_t&gt; alignmentOffsets;</div>
<div class="line">    alignmentOffsets.resize(numShaderStages, 0);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Grab the stage metadata and pointers to the control and data section</span></div>
<div class="line"><span class="comment">         * of the compiled shader.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <span class="keywordtype">size_t</span> shaderDataBufferMemoryPoolSize = 0;</div>
<div class="line">    <span class="keywordtype">int</span> bufferAlignment = 0;</div>
<div class="line">    nvnDeviceGetInteger(m_pDevice, NVN_DEVICE_INFO_UNIFORM_BUFFER_ALIGNMENT, &amp;bufferAlignment);</div>
<div class="line">    <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; numShaderStages; ++i)</div>
<div class="line">    {</div>
<div class="line">            <span class="comment">/* Store offsets for filling the memory pool and initializing buffers. */</span></div>
<div class="line">        alignmentOffsets[i] = shaderDataBufferMemoryPoolSize;</div>
<div class="line">        shaderDataBufferMemoryPoolSize += shaderStageHeaders[i].m_ShaderDataSize;</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Make sure the size is at the correct alignment. */</span></div>
<div class="line">        shaderDataBufferMemoryPoolSize = Align(shaderDataBufferMemoryPoolSize, bufferAlignment);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Shader code is not allowed to be in the last 1024 bytes of a memory pool on NX,</span></div>
<div class="line"><span class="comment">         * additional padding is added to ensure that does not happen.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <span class="keywordtype">int</span> shaderMemoryPoolPadding = 0;</div>
<div class="line">    nvnDeviceGetInteger(m_pDevice, NVN_DEVICE_INFO_SHADER_CODE_MEMORY_POOL_PADDING_SIZE, &amp;shaderMemoryPoolPadding);</div>
<div class="line">    shaderDataBufferMemoryPoolSize += shaderMemoryPoolPadding;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Copy the shader data into a contiguous block of memory to wrap a pool around. */</span></div>
<div class="line">    <span class="keywordtype">size_t</span> memoryPoolAlignedSize;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (shaderDataBufferMemoryPoolSize &lt; g_MinimumPoolSize)</div>
<div class="line">    {</div>
<div class="line">        memoryPoolAlignedSize = g_MinimumPoolSize;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        memoryPoolAlignedSize = Align(shaderDataBufferMemoryPoolSize, <a name="a66"></a><a class="code" href="group__nvn__c__defines.html#gadfd69601d2d9f953c55808127ba60853">NVN_MEMORY_POOL_STORAGE_GRANULARITY</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">char</span>* shaderDataArray = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(AlignedAllocate(memoryPoolAlignedSize, <a name="a67"></a><a class="code" href="group__nvn__c__defines.html#gace820e752b400cf7aa36e9684a7f45cb">NVN_MEMORY_POOL_STORAGE_ALIGNMENT</a>));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; shaderStageHeaders.size(); ++i)</div>
<div class="line">    {</div>
<div class="line">        memcpy(shaderDataArray + alignmentOffsets[i], shaderStageHeaders[i].m_pShaderData, shaderStageHeaders[i].m_ShaderDataSize);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Create new memory pool around the shader data. Any memory pool</span></div>
<div class="line"><span class="comment">         * that wishes to load compiled shader data must have the</span></div>
<div class="line"><span class="comment">         * NVN_MEMORY_POOL_FLAGS_SHADER_CODE_BIT bit set.</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * NOTE: Avoid loading a shader into the last 1kb of memory in the</span></div>
<div class="line"><span class="comment">         * memory pool. GPU shader cores may pre-fetch from instruction</span></div>
<div class="line"><span class="comment">         * memory beyond the last byte of actual shader code, which could</span></div>
<div class="line"><span class="comment">         * fault if the GPU virtual address space beyond the end of the</span></div>
<div class="line"><span class="comment">         * pool is unpopulated.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    pProgramData-&gt;m_ShaderMemoryPool.Init(shaderDataArray,</div>
<div class="line">                                          memoryPoolAlignedSize,</div>
<div class="line">                                          NVN_MEMORY_POOL_FLAGS_CPU_NO_ACCESS_BIT | NVN_MEMORY_POOL_FLAGS_GPU_CACHED_BIT | NVN_MEMORY_POOL_FLAGS_SHADER_CODE_BIT,</div>
<div class="line">                                          m_pDevice);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * NVNprogram</span></div>
<div class="line"><span class="comment">         * ----------</span></div>
<div class="line"><span class="comment">         * The NVNprogram object is a collection of different shader stages</span></div>
<div class="line"><span class="comment">         * that can be used for rendering or compute operations. The object</span></div>
<div class="line"><span class="comment">         * cannot hold both rendering and compute shaders at the same time</span></div>
<div class="line"><span class="comment">         * and can only have one compute shader. The program is created</span></div>
<div class="line"><span class="comment">         * through a call to nvnProgramInitialize followed by a call to</span></div>
<div class="line"><span class="comment">         * nvnProgramSetShaders. This function takes a list of NVNshaderData</span></div>
<div class="line"><span class="comment">         * structures (described below) that provide the object with shader</span></div>
<div class="line"><span class="comment">         * binary compiled by GLSLC. The shader program is bound using</span></div>
<div class="line"><span class="comment">         * nvnCommandBufferBindProgram which sets the active shader for</span></div>
<div class="line"><span class="comment">         * each stage.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * NVNshaderData</span></div>
<div class="line"><span class="comment">         * -------------</span></div>
<div class="line"><span class="comment">         * This structure is used to define an individual shader stage</span></div>
<div class="line"><span class="comment">         * that is to be made a part of an NVNprogram object. The structure</span></div>
<div class="line"><span class="comment">         * holds a pointer to the control section output by the GLSLC</span></div>
<div class="line"><span class="comment">         * compile as well as an NVNbufferAddress that holds the address</span></div>
<div class="line"><span class="comment">         * of an NVNbuffer created from the shader data section of the</span></div>
<div class="line"><span class="comment">         * GLSLC output.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line"> </div>
<div class="line">    std::vector&lt;NVNshaderData&gt; nvnShaderData;</div>
<div class="line">    nvnShaderData.resize(numShaderStages, <a name="_a68"></a><a class="code" href="struct_n_v_nshader_data.html">NVNshaderData</a>());</div>
<div class="line">    pProgramData-&gt;m_ShaderBuffers.resize(numShaderStages, NULL);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Create NVNbuffer objects out of the memory pool for each shader stage.</span></div>
<div class="line"><span class="comment">         * The NVNbufferAddress for these buffers are placed in a list with the</span></div>
<div class="line"><span class="comment">         * pointers to the corresponding shader control sections.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; shaderStageHeaders.size(); ++i)</div>
<div class="line">    {</div>
<div class="line">        pProgramData-&gt;m_ShaderStages |= ConvertNVNStageToBitField(<span class="keyword">static_cast&lt;</span><a class="code" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a><span class="keyword">&gt;</span>(shaderStageHeaders[i].m_ShaderStage));</div>
<div class="line">        pProgramData-&gt;m_ShaderBuffers[i] = <span class="keyword">new</span> <a name="_a69"></a><a class="code" href="struct_n_v_nbuffer.html">NVNbuffer</a>;</div>
<div class="line"> </div>
<div class="line">        nvnBufferBuilderSetDefaults(&amp;m_BufferBuilder);</div>
<div class="line">        nvnBufferBuilderSetStorage(&amp;m_BufferBuilder, pProgramData-&gt;m_ShaderMemoryPool.GetMemoryPool(), alignmentOffsets[i], shaderStageHeaders[i].m_ShaderDataSize);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (!nvnBufferInitialize(pProgramData-&gt;m_ShaderBuffers[i], &amp;m_BufferBuilder))</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">delete</span> pProgramData-&gt;m_ShaderBuffers[i];</div>
<div class="line">            <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;Failed to initialize shader buffer storage&quot;</span>);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        nvnShaderData[i].control = shaderStageHeaders[i].m_pShaderControl;</div>
<div class="line">        nvnShaderData[i].data    = nvnBufferGetAddress(pProgramData-&gt;m_ShaderBuffers[i]);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Initialize the shader program and provide it with the compiled shader data. */</span></div>
<div class="line">    nvnProgramInitialize(&amp;pProgramData-&gt;m_Program, m_pDevice);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!nvnProgramSetShaders(&amp;pProgramData-&gt;m_Program, numShaderStages, &amp;nvnShaderData[0]))</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;Failed to set pre-compiled shaders&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * AssetFileLoadingHelper::LoadSpecializedShaderHeaders</span></div>
<div class="line"><span class="comment"> * ----------------------------------------------------</span></div>
<div class="line"><span class="comment"> * Parses the specialized shader program header and creates an</span></div>
<div class="line"><span class="comment"> * NVNprogram object for each variation.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">NVNSpecializedProgramData* AssetFileLoadingHelper::LoadSpecializedShaderHeaders(<span class="keyword">const</span> <span class="keywordtype">char</span>* pSpecializedShaderProgramHead)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(pSpecializedShaderProgramHead != NULL, <span class="stringliteral">&quot;Specialized program header pointer NULL&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> SpecializedShaderProgramHeader* pShaderProgramHeader = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>SpecializedShaderProgramHeader*<span class="keyword">&gt;</span>(pSpecializedShaderProgramHead);</div>
<div class="line"> </div>
<div class="line">    uint32_t        numVariations         = pShaderProgramHeader-&gt;m_NumVariations;</div>
<div class="line">    <span class="keyword">const</span> uint64_t* pShaderProgramOffsets = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint64_t*<span class="keyword">&gt;</span>(pSpecializedShaderProgramHead + <span class="keyword">sizeof</span>(uint32_t) * 2);</div>
<div class="line"> </div>
<div class="line">    NVNSpecializedProgramData* pSpecializedProgramData = <span class="keyword">new</span> NVNSpecializedProgramData;</div>
<div class="line">    pSpecializedProgramData-&gt;Initialize();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">size_t</span> shaderDataBufferMemoryPoolSize = 0;</div>
<div class="line">    <span class="keywordtype">int</span> bufferAlignment = 0;</div>
<div class="line">    nvnDeviceGetInteger(m_pDevice, NVN_DEVICE_INFO_UNIFORM_BUFFER_ALIGNMENT, &amp;bufferAlignment);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt; std::vector&lt;size_t&gt; &gt; alignmentOffsets;</div>
<div class="line">    alignmentOffsets.resize(numVariations, std::vector&lt;size_t&gt;());</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;std::pair&lt;const ShaderProgramHeader*, std::vector&lt;ShaderStageHeader&gt; &gt; &gt; variations;</div>
<div class="line"> </div>
<div class="line">    variations.resize(numVariations, std::pair&lt;<span class="keyword">const</span> ShaderProgramHeader*, std::vector&lt;ShaderStageHeader&gt; &gt;());</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; numVariations; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>*                pShaderProgramHead   = m_pFileHead + pShaderProgramOffsets[i];</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(pShaderProgramHead != NULL, <span class="stringliteral">&quot;Shader program header pointer NULL&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        variations[i].first = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>ShaderProgramHeader*<span class="keyword">&gt;</span>(pShaderProgramHead);</div>
<div class="line"> </div>
<div class="line">        uint32_t                   numShaderStages      = variations[i].first-&gt;m_NumShaderStages;</div>
<div class="line">        <span class="keyword">const</span> uint64_t*            pShaderStageOffsets  = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint64_t*<span class="keyword">&gt;</span>(pShaderProgramHead + <span class="keyword">sizeof</span>(uint32_t) * 4);</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>*                pProgramName         = pShaderProgramHead + <span class="keyword">sizeof</span>(uint32_t) * 4 + <span class="keyword">sizeof</span>(uint64_t) * numShaderStages;</div>
<div class="line"> </div>
<div class="line">        pSpecializedProgramData-&gt;m_ShaderScratchMemorySize = std::max(pSpecializedProgramData-&gt;m_ShaderScratchMemorySize,</div>
<div class="line">                                                                      (<span class="keywordtype">size_t</span>)variations[i].first-&gt;m_ShaderScratchMemorySize);</div>
<div class="line"> </div>
<div class="line">        variations[i].second.resize(numShaderStages, ShaderStageHeader());</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t j = 0; j &lt; numShaderStages; ++j)</div>
<div class="line">        {</div>
<div class="line">            ShaderStageHeader* pShaderStageHeader = <span class="keyword">reinterpret_cast&lt;</span>ShaderStageHeader*<span class="keyword">&gt;</span>(m_pFileHead + pShaderStageOffsets[j]);</div>
<div class="line"> </div>
<div class="line">            variations[i].second[j].m_ShaderStage = pShaderStageHeader-&gt;m_ShaderStage;</div>
<div class="line">            variations[i].second[j].m_ShaderDataSize = pShaderStageHeader-&gt;m_ShaderDataSize;</div>
<div class="line">            variations[i].second[j].m_ShaderControlSize = pShaderStageHeader-&gt;m_ShaderControlSize;</div>
<div class="line">            variations[i].second[j].m_ShaderControlOffset = pShaderStageHeader-&gt;m_ShaderControlOffset;</div>
<div class="line">            variations[i].second[j].m_pShaderData = m_pFileHead + pShaderStageOffsets[j] + 4 * <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">            variations[i].second[j].m_pShaderControl = m_pFileHead + variations[i].second[j].m_ShaderControlOffset;</div>
<div class="line"> </div>
<div class="line">            alignmentOffsets[i].push_back(shaderDataBufferMemoryPoolSize);</div>
<div class="line">            shaderDataBufferMemoryPoolSize += pShaderStageHeader-&gt;m_ShaderDataSize;</div>
<div class="line">            shaderDataBufferMemoryPoolSize = Align(shaderDataBufferMemoryPoolSize, bufferAlignment);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (i == 0)</div>
<div class="line">        {</div>
<div class="line">            pSpecializedProgramData-&gt;SetName(pProgramName, variations[i].first-&gt;m_ProgramNameLength);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Shader code is not allowed to be in the last 1024 bytes of a memory pool on NX,</span></div>
<div class="line"><span class="comment">         * additional padding is added to ensure that does not happen.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <span class="keywordtype">int</span> shaderMemoryPoolPadding = 0;</div>
<div class="line">    nvnDeviceGetInteger(m_pDevice, NVN_DEVICE_INFO_SHADER_CODE_MEMORY_POOL_PADDING_SIZE, &amp;shaderMemoryPoolPadding);</div>
<div class="line">    shaderDataBufferMemoryPoolSize += shaderMemoryPoolPadding;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">size_t</span> memoryPoolAlignedSize;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (shaderDataBufferMemoryPoolSize &lt; g_MinimumPoolSize)</div>
<div class="line">    {</div>
<div class="line">        memoryPoolAlignedSize = g_MinimumPoolSize;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        memoryPoolAlignedSize = Align(shaderDataBufferMemoryPoolSize, <a class="code" href="group__nvn__c__defines.html#gadfd69601d2d9f953c55808127ba60853">NVN_MEMORY_POOL_STORAGE_GRANULARITY</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">char</span>* shaderDataArray = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(AlignedAllocate(memoryPoolAlignedSize, <a class="code" href="group__nvn__c__defines.html#gace820e752b400cf7aa36e9684a7f45cb">NVN_MEMORY_POOL_STORAGE_ALIGNMENT</a>));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; numVariations; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t j = 0; j &lt; variations[i].second.size(); ++j)</div>
<div class="line">        {</div>
<div class="line">            memcpy(shaderDataArray + alignmentOffsets[i][j], variations[i].second[j].m_pShaderData, variations[i].second[j].m_ShaderDataSize);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Create new memory pool around the shader data. Any memory pool</span></div>
<div class="line"><span class="comment">         * that wishes to load compiled shader data must have the</span></div>
<div class="line"><span class="comment">         * NVN_MEMORY_POOL_FLAGS_SHADER_CODE_BIT bit set.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    pSpecializedProgramData-&gt;m_ShaderMemoryPool.Init(shaderDataArray,</div>
<div class="line">                                                     memoryPoolAlignedSize,</div>
<div class="line">                                                     NVN_MEMORY_POOL_FLAGS_CPU_NO_ACCESS_BIT | NVN_MEMORY_POOL_FLAGS_GPU_CACHED_BIT | NVN_MEMORY_POOL_FLAGS_SHADER_CODE_BIT,</div>
<div class="line">                                                     m_pDevice);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; numVariations; ++i)</div>
<div class="line">    {</div>
<div class="line">        std::vector&lt;NVNshaderData&gt; nvnShaderData;</div>
<div class="line">        nvnShaderData.resize(variations[i].second.size(), <a class="code" href="struct_n_v_nshader_data.html">NVNshaderData</a>());</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t j = 0; j &lt; variations[i].second.size(); ++j)</div>
<div class="line">        {</div>
<div class="line">            pSpecializedProgramData-&gt;m_ShaderStages |= ConvertNVNStageToBitField(<span class="keyword">static_cast&lt;</span><a class="code" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a><span class="keyword">&gt;</span>(variations[i].second[j].m_ShaderStage));</div>
<div class="line">            <a class="code" href="struct_n_v_nbuffer.html">NVNbuffer</a>* shaderBuffer = <span class="keyword">new</span> <a class="code" href="struct_n_v_nbuffer.html">NVNbuffer</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">            nvnBufferBuilderSetDefaults(&amp;m_BufferBuilder);</div>
<div class="line">            nvnBufferBuilderSetStorage(&amp;m_BufferBuilder, pSpecializedProgramData-&gt;m_ShaderMemoryPool.GetMemoryPool(), alignmentOffsets[i][j], variations[i].second[j].m_ShaderDataSize);</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (!nvnBufferInitialize(shaderBuffer, &amp;m_BufferBuilder))</div>
<div class="line">            {</div>
<div class="line">                <span class="keyword">delete</span> shaderBuffer;</div>
<div class="line">                <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;Failed to initialize shader buffer storage&quot;</span>);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            nvnShaderData[j].control = variations[i].second[j].m_pShaderControl;</div>
<div class="line">            nvnShaderData[j].data = nvnBufferGetAddress(shaderBuffer);</div>
<div class="line"> </div>
<div class="line">            pSpecializedProgramData-&gt;m_ShaderBuffers.push_back(shaderBuffer);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Initialize the shader program and provide it with the compiled shader data. */</span></div>
<div class="line">        <a name="_a70"></a><a class="code" href="struct_n_v_nprogram.html">NVNprogram</a>* pProgram = <span class="keyword">new</span> <a class="code" href="struct_n_v_nprogram.html">NVNprogram</a>;</div>
<div class="line">        pSpecializedProgramData-&gt;m_Variations.push_back(pProgram);</div>
<div class="line"> </div>
<div class="line">        nvnProgramInitialize(pProgram, m_pDevice);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (!nvnProgramSetShaders(pProgram, <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(variations[i].second.size()), &amp;nvnShaderData[0]))</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;Failed to set pre-compiled shaders&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> pSpecializedProgramData;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * AssetFileLoadingHelper::LoadTextures</span></div>
<div class="line"><span class="comment"> * ------------------------------------</span></div>
<div class="line"><span class="comment"> * Grabs the texture block header of the asset file and loads</span></div>
<div class="line"><span class="comment"> * the texture data at the specified offsets.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> AssetFileLoadingHelper::LoadTextures(<span class="keyword">const</span> <span class="keywordtype">char</span>* pTextureBlockHead)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(pTextureBlockHead != NULL, <span class="stringliteral">&quot;Texture block header pointer NULL&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> TextureBlockHeader* pTextureBlockHeader = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>TextureBlockHeader*<span class="keyword">&gt;</span>(pTextureBlockHead);</div>
<div class="line">    <span class="keyword">const</span> uint64_t* pTextureOffsets = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint64_t*<span class="keyword">&gt;</span>(pTextureBlockHead + <span class="keyword">sizeof</span>(uint32_t) * 2);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; pTextureBlockHeader-&gt;m_NumTextures; ++i)</div>
<div class="line">    {</div>
<div class="line">        NVNTextureData* pTextureData = LoadTextureData(m_pFileHead + pTextureOffsets[i]);</div>
<div class="line">        m_pDataHolder-&gt;AddTextureData(pTextureData);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * AssetFileLoadingHelper::LoadTextureData</span></div>
<div class="line"><span class="comment"> * ---------------------------------------</span></div>
<div class="line"><span class="comment"> * Loads the packaged texture data and metadata from the texture header.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">NVNTextureData* AssetFileLoadingHelper::LoadTextureData(<span class="keywordtype">char</span>* pTextureDataHead)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(pTextureDataHead != NULL, <span class="stringliteral">&quot;Texture data pointer NULL&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    NVNTextureData* pNvnTextureData = <span class="keyword">new</span> NVNTextureData;</div>
<div class="line">    pNvnTextureData-&gt;Initialize();</div>
<div class="line"> </div>
<div class="line">    uint32_t currentDataEntryOffset = 0;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Grab the texture&#39;s metadata. */</span></div>
<div class="line">    pNvnTextureData-&gt;m_TextureDataSize      = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pTextureDataHead + currentDataEntryOffset);          currentDataEntryOffset += <span class="keyword">sizeof</span>(uint64_t);</div>
<div class="line">    pNvnTextureData-&gt;m_GpuVersion           = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">int</span>*<span class="keyword">&gt;</span>(pTextureDataHead + currentDataEntryOffset);               currentDataEntryOffset += <span class="keyword">sizeof</span>(int);</div>
<div class="line">    pNvnTextureData-&gt;m_Alignment            = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pTextureDataHead + currentDataEntryOffset);          currentDataEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    pNvnTextureData-&gt;m_Width                = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pTextureDataHead + currentDataEntryOffset);          currentDataEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    pNvnTextureData-&gt;m_Height               = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pTextureDataHead + currentDataEntryOffset);          currentDataEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    pNvnTextureData-&gt;m_Depth                = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pTextureDataHead + currentDataEntryOffset);          currentDataEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    pNvnTextureData-&gt;m_NvnTextureTarget     = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code" href="group__nvn__c__enum.html#ga7f247010f53480c7dd1f3b2ad638c431">NVNtextureTarget</a>*<span class="keyword">&gt;</span>(pTextureDataHead + currentDataEntryOffset);  currentDataEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    pNvnTextureData-&gt;m_NvnFormat            = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a>*<span class="keyword">&gt;</span>(pTextureDataHead + currentDataEntryOffset);         currentDataEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    pNvnTextureData-&gt;m_MipLevels            = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pTextureDataHead + currentDataEntryOffset);          currentDataEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    uint32_t textureNameLength              = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pTextureDataHead + currentDataEntryOffset);          currentDataEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    uint32_t textureDataOffset              = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pTextureDataHead + currentDataEntryOffset);          currentDataEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* pTextureName                = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(pTextureDataHead + currentDataEntryOffset);               currentDataEntryOffset += <span class="keyword">sizeof</span>(char) * textureNameLength;</div>
<div class="line">    <span class="keywordtype">void</span>* pTextureData                      = (m_pFileHead + textureDataOffset);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!textureNameLength ||</div>
<div class="line">        pTextureName == NULL ||</div>
<div class="line">        !pNvnTextureData-&gt;m_Width ||</div>
<div class="line">        !pNvnTextureData-&gt;m_Height ||</div>
<div class="line">        !pNvnTextureData-&gt;m_Depth ||</div>
<div class="line">        pNvnTextureData-&gt;m_NvnTextureTarget &gt; NVN_TEXTURE_TARGET_BUFFER ||</div>
<div class="line">        !pNvnTextureData-&gt;m_NvnFormat ||</div>
<div class="line">        !pNvnTextureData-&gt;m_MipLevels ||</div>
<div class="line">        pTextureData == NULL)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;Failed to read texture data&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">size_t</span> memoryPoolSize;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (pNvnTextureData-&gt;m_TextureDataSize &lt; g_MinimumPoolSize)</div>
<div class="line">    {</div>
<div class="line">        memoryPoolSize = g_MinimumPoolSize;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        memoryPoolSize = Align(<span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(pNvnTextureData-&gt;m_TextureDataSize), <a class="code" href="group__nvn__c__defines.html#gadfd69601d2d9f953c55808127ba60853">NVN_MEMORY_POOL_STORAGE_GRANULARITY</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span>* memoryPoolData = AlignedAllocate(memoryPoolSize, <a class="code" href="group__nvn__c__defines.html#gace820e752b400cf7aa36e9684a7f45cb">NVN_MEMORY_POOL_STORAGE_ALIGNMENT</a>);</div>
<div class="line"> </div>
<div class="line">    memcpy(memoryPoolData, pTextureData, <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(pNvnTextureData-&gt;m_TextureDataSize));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Wrap a memory pool around the texture data. */</span></div>
<div class="line">    pNvnTextureData-&gt;m_TextureMemoryPool.Init(memoryPoolData,</div>
<div class="line">                                              memoryPoolSize,</div>
<div class="line">                                              NVN_MEMORY_POOL_FLAGS_CPU_NO_ACCESS_BIT | NVN_MEMORY_POOL_FLAGS_GPU_CACHED_BIT,</div>
<div class="line">                                              m_pDevice);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Set up the texture builder based on the loaded metadata. */</span></div>
<div class="line">    pNvnTextureData-&gt;SetName(pTextureName, textureNameLength);</div>
<div class="line">    nvnTextureBuilderSetDefaults(&amp;m_TextureBuilder);</div>
<div class="line">    nvnTextureBuilderSetTarget(&amp;m_TextureBuilder, pNvnTextureData-&gt;m_NvnTextureTarget);</div>
<div class="line">    nvnTextureBuilderSetFormat(&amp;m_TextureBuilder, pNvnTextureData-&gt;m_NvnFormat);</div>
<div class="line">    nvnTextureBuilderSetSize2D(&amp;m_TextureBuilder, pNvnTextureData-&gt;m_Width, pNvnTextureData-&gt;m_Height);</div>
<div class="line">    nvnTextureBuilderSetDepth(&amp;m_TextureBuilder, pNvnTextureData-&gt;m_Depth);</div>
<div class="line">    nvnTextureBuilderSetLevels(&amp;m_TextureBuilder, pNvnTextureData-&gt;m_MipLevels);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">        * On Windows, the packaged texture data cannot be used by the GPU as</span></div>
<div class="line"><span class="comment">        * it will not be compatible with the format used by the device. To</span></div>
<div class="line"><span class="comment">        * remedy this, it can be provided to the texture builder through the</span></div>
<div class="line"><span class="comment">        * SetPackagedTextureData function. The windows driver will decode the</span></div>
<div class="line"><span class="comment">        * texture data and re-encode it to the proper format. On the device, the</span></div>
<div class="line"><span class="comment">        * function is a no-op; the pointer is ignored and its contents unmodified.</span></div>
<div class="line"><span class="comment">        */</span></div>
<div class="line">    nvnTextureBuilderSetPackagedTextureData(&amp;m_TextureBuilder, pTextureData);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Set the storage for the texture. */</span></div>
<div class="line">    nvnTextureBuilderSetStorage(&amp;m_TextureBuilder, pNvnTextureData-&gt;m_TextureMemoryPool.GetMemoryPool(), 0);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Initialize the texture with the builder&#39;s settings. */</span></div>
<div class="line">    <span class="keywordflow">if</span> (!nvnTextureInitialize(&amp;pNvnTextureData-&gt;m_Texture, &amp;m_TextureBuilder))</div>
<div class="line">    {</div>
<div class="line">        pNvnTextureData-&gt;Finalize();</div>
<div class="line">        <span class="keyword">delete</span> pNvnTextureData;</div>
<div class="line">        <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;Failed to initialize texture&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> NULL;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        pNvnTextureData-&gt;m_TextureInitialized = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Register the texture and hold onto its ID. */</span></div>
<div class="line">    pNvnTextureData-&gt;m_TextureID = m_pTextureIDManager-&gt;RegisterTexture(&amp;pNvnTextureData-&gt;m_Texture);</div>
<div class="line">    <span class="keywordflow">return</span> pNvnTextureData;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * AssetFileLoadingHelper::LoadModels</span></div>
<div class="line"><span class="comment"> * ----------------------------------</span></div>
<div class="line"><span class="comment"> * Grabs the model block header and loads the model data</span></div>
<div class="line"><span class="comment"> * at the specified offsets.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> AssetFileLoadingHelper::LoadModels(<span class="keyword">const</span> <span class="keywordtype">char</span>* pModelBlockHead)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(pModelBlockHead != NULL, <span class="stringliteral">&quot;Model block header pointer NULL&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    uint32_t numModels = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pModelBlockHead);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> uint64_t* pModelOffsets = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint64_t*<span class="keyword">&gt;</span>(pModelBlockHead + <span class="keyword">sizeof</span>(uint32_t) * 2);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; numModels; ++i)</div>
<div class="line">    {</div>
<div class="line">        NVNModelData* pModelData = LoadModelData(m_pFileHead + pModelOffsets[i]);</div>
<div class="line">        m_pDataHolder-&gt;AddModelData(pModelData);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * AssetFileLoadingHelper::LoadModelData</span></div>
<div class="line"><span class="comment"> * -------------------------------------</span></div>
<div class="line"><span class="comment"> * Loads in the model vertex attributes and index buffer as well</span></div>
<div class="line"><span class="comment"> * as some data describing the model.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">NVNModelData* AssetFileLoadingHelper::LoadModelData(<span class="keyword">const</span> <span class="keywordtype">char</span>* pModelHead)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(pModelHead != NULL, <span class="stringliteral">&quot;Model data pointer NULL&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Grab the model&#39;s metadata. */</span></div>
<div class="line">    uint32_t            currentDataEntryOffset  = 0;</div>
<div class="line">    uint32_t            numPrimitives           = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pModelHead + currentDataEntryOffset);              currentDataEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    <a class="code" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a>    nvnDrawPrimitiveType    = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a>*<span class="keyword">&gt;</span>(pModelHead + currentDataEntryOffset);      currentDataEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    uint32_t            numVertexAttributes     = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pModelHead + currentDataEntryOffset);              currentDataEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    uint32_t            modelNameLength         = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pModelHead + currentDataEntryOffset);              currentDataEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    uint64_t            indexBufferOffset       = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint64_t*<span class="keyword">&gt;</span>(pModelHead + currentDataEntryOffset);              currentDataEntryOffset += <span class="keyword">sizeof</span>(uint64_t);</div>
<div class="line">    <span class="keyword">const</span> uint64_t*     pVertexAttributeOffsets = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint64_t*<span class="keyword">&gt;</span>(pModelHead + currentDataEntryOffset);               currentDataEntryOffset += <span class="keyword">sizeof</span>(uint64_t) * numVertexAttributes;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>*         pModelName              = pModelHead + currentDataEntryOffset;                                                  currentDataEntryOffset += <span class="keyword">sizeof</span>(char) * modelNameLength;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (modelNameLength == 0 ||</div>
<div class="line">        pModelName == NULL ||</div>
<div class="line">        !numPrimitives ||</div>
<div class="line">        nvnDrawPrimitiveType &gt; NVN_DRAW_PRIMITIVE_PATCHES ||</div>
<div class="line">        !numVertexAttributes ||</div>
<div class="line">        pVertexAttributeOffsets == NULL ||</div>
<div class="line">        !indexBufferOffset)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;Failed to read model data&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    NVNModelData* pModelData = <span class="keyword">new</span> NVNModelData;</div>
<div class="line">    pModelData-&gt;Initialize();</div>
<div class="line">    pModelData-&gt;SetName(pModelName, modelNameLength);</div>
<div class="line"> </div>
<div class="line">    Model* pModel = &amp;pModelData-&gt;m_Model;</div>
<div class="line">    pModel-&gt;m_NumVertexAttributes = numVertexAttributes;</div>
<div class="line">    pModel-&gt;m_NumPrimitives = numPrimitives;</div>
<div class="line">    pModel-&gt;m_NvnDrawPrimitiveType = nvnDrawPrimitiveType;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Grab the data for the individual vertex attributes. */</span></div>
<div class="line">    <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; numVertexAttributes; ++i)</div>
<div class="line">    {</div>
<div class="line">        VertexAttributeHeader header;</div>
<div class="line">        <span class="keywordtype">char</span>* pAttributeHeader = m_pFileHead + pVertexAttributeOffsets[i];</div>
<div class="line">        uint32_t currVertexEntryOffset  = 0;</div>
<div class="line"> </div>
<div class="line">        header.m_AttributeStride        = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pAttributeHeader + currVertexEntryOffset);     currVertexEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">        header.m_NvnFormat              = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pAttributeHeader + currVertexEntryOffset);     currVertexEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">        header.m_AttributeDataSize      = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pAttributeHeader + currVertexEntryOffset);     currVertexEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">        header.m_AttributeNameLength    = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pAttributeHeader + currVertexEntryOffset);     currVertexEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">        header.m_AttributeDataOffset    = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pAttributeHeader + currVertexEntryOffset);     currVertexEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">        header.m_MagicPadding           = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pAttributeHeader + currVertexEntryOffset);     currVertexEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">        header.m_pAttributeName         = pAttributeHeader + currVertexEntryOffset;                                         currVertexEntryOffset += <span class="keyword">sizeof</span>(char) * header.m_AttributeNameLength;</div>
<div class="line">        header.m_AttributeData          = m_pFileHead + header.m_AttributeDataOffset;</div>
<div class="line"> </div>
<div class="line">        pModelData-&gt;AddVertexAttribute(header);</div>
<div class="line">        pModelData-&gt;m_VertexBufferSize += header.m_AttributeDataSize;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Grab the index buffer data. */</span></div>
<div class="line">    <span class="keywordtype">char</span>* pIndexBufferHead          = m_pFileHead + indexBufferOffset;</div>
<div class="line">    uint32_t currIndexEntryOffset   = 0;</div>
<div class="line"> </div>
<div class="line">    uint32_t indexBufferSize        = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pIndexBufferHead + currIndexEntryOffset);        currIndexEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    uint32_t numIndices             = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pIndexBufferHead + currIndexEntryOffset);        currIndexEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    uint32_t indexType              = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pIndexBufferHead + currIndexEntryOffset);        currIndexEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    currIndexEntryOffset            += <span class="keyword">sizeof</span>(uint32_t); <span class="comment">/* Account for padding in struct */</span></div>
<div class="line">    <span class="keywordtype">void</span>* pIndexData                = (pIndexBufferHead + currIndexEntryOffset);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Align the index buffer according to its type. */</span></div>
<div class="line">    <span class="keywordtype">size_t</span> memoryPoolSize = pModelData-&gt;m_VertexBufferSize;</div>
<div class="line">    uint32_t indexBufferAlignment = 0;</div>
<div class="line">    <span class="keywordflow">switch</span>((<a class="code" href="group__nvn__c__enum.html#gaaf90e0c2dbdc1e42db8192f0c0cb1522">NVNindexType</a>)indexType)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">case</span> <a class="code" href="group__nvn__c__enum.html#ggaaf90e0c2dbdc1e42db8192f0c0cb1522a9d49b4695541469d3ecbadeac29c98b8">NVN_INDEX_TYPE_UNSIGNED_BYTE</a>:</div>
<div class="line">            indexBufferAlignment = <span class="keyword">sizeof</span>(uint8_t);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> <a class="code" href="group__nvn__c__enum.html#ggaaf90e0c2dbdc1e42db8192f0c0cb1522a01b3069396b6d9c7ca2f6c7579627e32">NVN_INDEX_TYPE_UNSIGNED_SHORT</a>:</div>
<div class="line">            indexBufferAlignment = <span class="keyword">sizeof</span>(uint16_t);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> <a class="code" href="group__nvn__c__enum.html#ggaaf90e0c2dbdc1e42db8192f0c0cb1522aedbe4967c83f6b7f1b800e51bc7f3ab6">NVN_INDEX_TYPE_UNSIGNED_INT</a>:</div>
<div class="line">            indexBufferAlignment = <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">default</span>:</div>
<div class="line">            <a name="a71"></a><a class="code" href="nn___macro_8h.html#abfe6f7c5f80ef52b7c0616042aba59b9">NN_UNEXPECTED_DEFAULT</a>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(indexBufferSize / numIndices == indexBufferAlignment);</div>
<div class="line">    <a class="code" href="nn___macro_8h.html#af2d1673769927c5eae977d8dde3ce106">NN_UNUSED</a>(numIndices);</div>
<div class="line">        <span class="comment">/* Get the aligned pool size. */</span></div>
<div class="line">    memoryPoolSize = Align(memoryPoolSize, indexBufferAlignment);</div>
<div class="line">    <span class="keywordtype">size_t</span> indexBufferAlignedLocation = memoryPoolSize;</div>
<div class="line">    memoryPoolSize += indexBufferSize;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Save the index buffer data in the model. */</span></div>
<div class="line">    pModel-&gt;m_IndexData.m_IndexType = indexType;</div>
<div class="line">    pModel-&gt;m_IndexData.m_DataSize  = indexBufferSize;</div>
<div class="line">    pModel-&gt;m_IndexData.m_Stride    = indexBufferAlignment;</div>
<div class="line">    pModel-&gt;m_IndexData.m_pData     = <span class="keyword">new</span> <span class="keywordtype">char</span>[indexBufferSize];</div>
<div class="line"> </div>
<div class="line">    memcpy(pModel-&gt;m_IndexData.m_pData, pIndexData, indexBufferSize);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Allocate memory for the pool. */</span></div>
<div class="line">    <span class="keywordflow">if</span> (memoryPoolSize &lt; g_MinimumPoolSize)</div>
<div class="line">    {</div>
<div class="line">        memoryPoolSize = g_MinimumPoolSize;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        memoryPoolSize = Align(memoryPoolSize, <a class="code" href="group__nvn__c__defines.html#gadfd69601d2d9f953c55808127ba60853">NVN_MEMORY_POOL_STORAGE_GRANULARITY</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">char</span>* modelDataBuffer = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(AlignedAllocate(memoryPoolSize, <a class="code" href="group__nvn__c__defines.html#gace820e752b400cf7aa36e9684a7f45cb">NVN_MEMORY_POOL_STORAGE_ALIGNMENT</a>));</div>
<div class="line">    memset(modelDataBuffer, 0, memoryPoolSize);</div>
<div class="line"> </div>
<div class="line">    uint32_t currentBufferOffset = 0;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Copy in the vertex data. */</span></div>
<div class="line">    <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; pModel-&gt;m_VertexAttributes.size(); ++i)</div>
<div class="line">    {</div>
<div class="line">        memcpy(modelDataBuffer + currentBufferOffset, pModel-&gt;m_VertexAttributes[i].m_pData, pModel-&gt;m_VertexAttributes[i].m_DataSize);</div>
<div class="line">        pModelData-&gt;m_VertexAttributeBufferOffsets.push_back(currentBufferOffset);</div>
<div class="line">        currentBufferOffset += pModel-&gt;m_VertexAttributes[i].m_DataSize;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Copy the index data. */</span></div>
<div class="line">    memcpy(modelDataBuffer + indexBufferAlignedLocation, pIndexData, indexBufferSize);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Create a memory pool around the model data. */</span></div>
<div class="line">    pModelData-&gt;m_BufferMemoryPool.Init(modelDataBuffer,</div>
<div class="line">                                        memoryPoolSize,</div>
<div class="line">                                        NVN_MEMORY_POOL_FLAGS_CPU_NO_ACCESS_BIT | NVN_MEMORY_POOL_FLAGS_GPU_CACHED_BIT,</div>
<div class="line">                                        m_pDevice);</div>
<div class="line"> </div>
<div class="line">    nvnBufferBuilderSetDefaults(&amp;m_BufferBuilder);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Create the vertex buffer from the memory pool at the correct offset. */</span></div>
<div class="line">    nvnBufferBuilderSetStorage(&amp;m_BufferBuilder, pModelData-&gt;m_BufferMemoryPool.GetMemoryPool(), 0, pModelData-&gt;m_VertexBufferSize);</div>
<div class="line">    <span class="keywordflow">if</span> (!nvnBufferInitialize(&amp;pModelData-&gt;m_VertexBuffer, &amp;m_BufferBuilder))</div>
<div class="line">    {</div>
<div class="line">        pModelData-&gt;Finalize();</div>
<div class="line">        <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;Failed to initialize vertex buffer storage&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    nvnBufferBuilderSetDefaults(&amp;m_BufferBuilder);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Create the index buffer from the memory pool at the correct offset. */</span></div>
<div class="line">    nvnBufferBuilderSetStorage(&amp;m_BufferBuilder, pModelData-&gt;m_BufferMemoryPool.GetMemoryPool(), indexBufferAlignedLocation, indexBufferSize);</div>
<div class="line">    <span class="keywordflow">if</span> (!nvnBufferInitialize(&amp;pModelData-&gt;m_IndexBuffer, &amp;m_BufferBuilder))</div>
<div class="line">    {</div>
<div class="line">        pModelData-&gt;Finalize();</div>
<div class="line">        <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;Failed to initialize index buffer storage&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> pModelData;</div>
<div class="line">}<span class="comment">//NOLINT(impl/function_size)</span></div>
<div class="ttc" id="a_asset_file_loading_helper_8h_html"><div class="ttname"><a href="_asset_file_loading_helper_8h.html">AssetFileLoadingHelper.h</a></div><div class="ttdoc">This file defines a helper class used to load in asset files generated by Tutorial02.</div></div>
<div class="ttc" id="a_memory_pool_8h_html"><div class="ttname"><a href="_memory_pool_8h.html">MemoryPool.h</a></div><div class="ttdoc">This file defines a wrapper around the NVNmemoryPool object that keeps track of the memory allocated ...</div></div>
<div class="ttc" id="a_output_file_headers_8h_html"><div class="ttname"><a href="_output_file_headers_8h.html">OutputFileHeaders.h</a></div><div class="ttdoc">This file defines the data structures that make up the the overall structure of the output asset file...</div></div>
<div class="ttc" id="a_texture_i_d_manager_8h_html"><div class="ttname"><a href="_texture_i_d_manager_8h.html">TextureIDManager.h</a></div><div class="ttdoc">This file defines a class that wraps the texture and sampler registering process.</div></div>
<div class="ttc" id="a_tutorial_util_8h_html"><div class="ttname"><a href="_tutorial_util_8h.html">TutorialUtil.h</a></div><div class="ttdoc">This file defines the interface for utility functions used in the tutorials.</div></div>
<div class="ttc" id="aclassnn_1_1_result_html"><div class="ttname"><a href="classnn_1_1_result.html">nn::Result</a></div><div class="ttdoc">Represents the generic result of an operation.</div><div class="ttdef"><b>Definition:</b> nn_Result.h:32</div></div>
<div class="ttc" id="afs_8h_html"><div class="ttname"><a href="fs_8h.html">fs.h</a></div><div class="ttdoc">Declarations of API resources for the file system.</div></div>
<div class="ttc" id="agroup__nvn__c__defines_html_gace820e752b400cf7aa36e9684a7f45cb"><div class="ttname"><a href="group__nvn__c__defines.html#gace820e752b400cf7aa36e9684a7f45cb">NVN_MEMORY_POOL_STORAGE_ALIGNMENT</a></div><div class="ttdeci">#define NVN_MEMORY_POOL_STORAGE_ALIGNMENT</div><div class="ttdoc">Required base address alignment for app-specified memory used to back memory pools.</div><div class="ttdef"><b>Definition:</b> nvn.h:4578</div></div>
<div class="ttc" id="agroup__nvn__c__defines_html_gadfd69601d2d9f953c55808127ba60853"><div class="ttname"><a href="group__nvn__c__defines.html#gadfd69601d2d9f953c55808127ba60853">NVN_MEMORY_POOL_STORAGE_GRANULARITY</a></div><div class="ttdeci">#define NVN_MEMORY_POOL_STORAGE_GRANULARITY</div><div class="ttdoc">Required size alignment for app-specified memory used to back memory pools.</div><div class="ttdef"><b>Definition:</b> nvn.h:4582</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_ga7f247010f53480c7dd1f3b2ad638c431"><div class="ttname"><a href="group__nvn__c__enum.html#ga7f247010f53480c7dd1f3b2ad638c431">NVNtextureTarget</a></div><div class="ttdeci">NVNtextureTarget</div><div class="ttdoc">Identifies the type of a texture object.</div><div class="ttdef"><b>Definition:</b> nvn.h:1081</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_ga99463f5b9af6151e604b01dfdd5fecab"><div class="ttname"><a href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a></div><div class="ttdeci">NVNformat</div><div class="ttdoc">Identifies how data elements stored in texture or buffer objects are encoded.</div><div class="ttdef"><b>Definition:</b> nvn.h:1175</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_gaaf90e0c2dbdc1e42db8192f0c0cb1522"><div class="ttname"><a href="group__nvn__c__enum.html#gaaf90e0c2dbdc1e42db8192f0c0cb1522">NVNindexType</a></div><div class="ttdeci">NVNindexType</div><div class="ttdoc">Specifies a data type used for index values in DrawElements commands.</div><div class="ttdef"><b>Definition:</b> nvn.h:2232</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_gab22437710b6816a67a1263d0087ded72"><div class="ttname"><a href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a></div><div class="ttdeci">NVNdrawPrimitive</div><div class="ttdoc">Specifies the type of primitive to render in draw calls.</div><div class="ttdef"><b>Definition:</b> nvn.h:2120</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_gac99deb2b11df8b0358f73a92e2a2abdd"><div class="ttname"><a href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a></div><div class="ttdeci">NVNshaderStage</div><div class="ttdoc">Specifies a programmable shader stage.</div><div class="ttdef"><b>Definition:</b> nvn.h:2685</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_ggaaf90e0c2dbdc1e42db8192f0c0cb1522a01b3069396b6d9c7ca2f6c7579627e32"><div class="ttname"><a href="group__nvn__c__enum.html#ggaaf90e0c2dbdc1e42db8192f0c0cb1522a01b3069396b6d9c7ca2f6c7579627e32">NVN_INDEX_TYPE_UNSIGNED_SHORT</a></div><div class="ttdeci">@ NVN_INDEX_TYPE_UNSIGNED_SHORT</div><div class="ttdoc">Index values are specified as 16-bit unsigned integers.</div><div class="ttdef"><b>Definition:</b> nvn.h:2238</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_ggaaf90e0c2dbdc1e42db8192f0c0cb1522a9d49b4695541469d3ecbadeac29c98b8"><div class="ttname"><a href="group__nvn__c__enum.html#ggaaf90e0c2dbdc1e42db8192f0c0cb1522a9d49b4695541469d3ecbadeac29c98b8">NVN_INDEX_TYPE_UNSIGNED_BYTE</a></div><div class="ttdeci">@ NVN_INDEX_TYPE_UNSIGNED_BYTE</div><div class="ttdoc">Index values are specified as (8-bit) unsigned bytes.</div><div class="ttdef"><b>Definition:</b> nvn.h:2235</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_ggaaf90e0c2dbdc1e42db8192f0c0cb1522aedbe4967c83f6b7f1b800e51bc7f3ab6"><div class="ttname"><a href="group__nvn__c__enum.html#ggaaf90e0c2dbdc1e42db8192f0c0cb1522aedbe4967c83f6b7f1b800e51bc7f3ab6">NVN_INDEX_TYPE_UNSIGNED_INT</a></div><div class="ttdeci">@ NVN_INDEX_TYPE_UNSIGNED_INT</div><div class="ttdoc">Index values are specified as 32-bit unsigned integers.</div><div class="ttdef"><b>Definition:</b> nvn.h:2241</div></div>
<div class="ttc" id="anamespacenn_1_1fs_html_a0f2b5b30657b1ffaf1dec49bfb36462b"><div class="ttname"><a href="namespacenn_1_1fs.html#a0f2b5b30657b1ffaf1dec49bfb36462b">nn::fs::OpenFile</a></div><div class="ttdeci">Result OpenFile(FileHandle *outValue, const char *path, int mode) NN_NOEXCEPT</div><div class="ttdoc">Opens a file.</div></div>
<div class="ttc" id="anamespacenn_1_1fs_html_a4c97b79cce78a95c2333dbc9053b9393afde4472d2b455879cad02aade386ac0d"><div class="ttname"><a href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393afde4472d2b455879cad02aade386ac0d">nn::fs::OpenMode_Read</a></div><div class="ttdeci">@ OpenMode_Read</div><div class="ttdoc">Specifies read mode.</div><div class="ttdef"><b>Definition:</b> fs_FileSystem.h:39</div></div>
<div class="ttc" id="anamespacenn_1_1fs_html_a81801a404563984f8c6cc1483cc6d730"><div class="ttname"><a href="namespacenn_1_1fs.html#a81801a404563984f8c6cc1483cc6d730">nn::fs::ReadFile</a></div><div class="ttdeci">Result ReadFile(FileHandle handle, int64_t offset, void *buffer, size_t size, const ReadOption &amp;option) NN_NOEXCEPT</div><div class="ttdoc">Loads the content of the file into the specified memory.</div></div>
<div class="ttc" id="anamespacenn_1_1fs_html_aba29e01d386e809349d60eccdb15ff21"><div class="ttname"><a href="namespacenn_1_1fs.html#aba29e01d386e809349d60eccdb15ff21">nn::fs::GetFileSize</a></div><div class="ttdeci">Result GetFileSize(int64_t *outValue, FileHandle handle) NN_NOEXCEPT</div><div class="ttdoc">Gets the size of a file.</div></div>
<div class="ttc" id="anamespacenn_1_1fs_html_ac8bd9e828751bd4f953acfa765278f84"><div class="ttname"><a href="namespacenn_1_1fs.html#ac8bd9e828751bd4f953acfa765278f84">nn::fs::CloseFile</a></div><div class="ttdeci">void CloseFile(FileHandle handle) NN_NOEXCEPT</div><div class="ttdoc">Closes a file.</div></div>
<div class="ttc" id="ann___assert_8h_html"><div class="ttname"><a href="nn___assert_8h.html">nn_Assert.h</a></div><div class="ttdoc">Declarations for API resources to test whether conditions are satisfied.</div></div>
<div class="ttc" id="ann___assert_8h_html_ade59d1d911907a16c0241f8fe3b31542"><div class="ttname"><a href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a></div><div class="ttdeci">#define NN_ASSERT(condition,...)</div><div class="ttdoc">Tests whether a condition is satisfied.</div><div class="ttdef"><b>Definition:</b> nn_Assert.h:124</div></div>
<div class="ttc" id="ann___log_8h_html"><div class="ttname"><a href="nn___log_8h.html">nn_Log.h</a></div><div class="ttdoc">Declarations for the logging API.</div></div>
<div class="ttc" id="ann___log_8h_html_a2d720c8bc6b733bce63879350d134a84"><div class="ttname"><a href="nn___log_8h.html#a2d720c8bc6b733bce63879350d134a84">NN_LOG</a></div><div class="ttdeci">#define NN_LOG(...)</div><div class="ttdoc">Adds the string specified in the parameter as a log entry.</div><div class="ttdef"><b>Definition:</b> nn_Log.h:33</div></div>
<div class="ttc" id="ann___macro_8h_html_abfe6f7c5f80ef52b7c0616042aba59b9"><div class="ttname"><a href="nn___macro_8h.html#abfe6f7c5f80ef52b7c0616042aba59b9">NN_UNEXPECTED_DEFAULT</a></div><div class="ttdeci">#define NN_UNEXPECTED_DEFAULT</div><div class="ttdoc">Explicitly states that the default label is never reached in a switch statement.</div><div class="ttdef"><b>Definition:</b> nn_Macro.h:571</div></div>
<div class="ttc" id="ann___macro_8h_html_af2d1673769927c5eae977d8dde3ce106"><div class="ttname"><a href="nn___macro_8h.html#af2d1673769927c5eae977d8dde3ce106">NN_UNUSED</a></div><div class="ttdeci">#define NN_UNUSED(variable)</div><div class="ttdoc">Suppresses compiler warnings on intentionally unused variables.</div><div class="ttdef"><b>Definition:</b> nn_Macro.h:610</div></div>
<div class="ttc" id="anvn_8h_html"><div class="ttname"><a href="nvn_8h.html">nvn.h</a></div><div class="ttdoc">C headers for the NVN 3D API.</div></div>
<div class="ttc" id="anvn___func_ptr_inline_8h_html"><div class="ttname"><a href="nvn___func_ptr_inline_8h.html">nvn_FuncPtrInline.h</a></div><div class="ttdoc">Implementation of the NVN C interface entry points as inline functions that call through global funct...</div></div>
<div class="ttc" id="anvn_tool___glslc_interface_8h_html_a05b2032c99f789df2a34ebf32271c320"><div class="ttname"><a href="nvn_tool___glslc_interface_8h.html#a05b2032c99f789df2a34ebf32271c320">glslcFinalize</a></div><div class="ttdeci">GLSLCAPI void glslcFinalize(GLSLCcompileObject *compileObject)</div><div class="ttdoc">Cleans up any internal memory associated with a GLSLC compile.</div></div>
<div class="ttc" id="anvn_tool___glslc_interface_8h_html_a238b82c174a58d9f9e2be6aa3e8a5bfea81704ec256f338d05d20e0d618decdef"><div class="ttname"><a href="nvn_tool___glslc_interface_8h.html#a238b82c174a58d9f9e2be6aa3e8a5bfea81704ec256f338d05d20e0d618decdef">GLSLC_DEBUG_LEVEL_G0</a></div><div class="ttdeci">@ GLSLC_DEBUG_LEVEL_G0</div><div class="ttdoc">Minimal debug information required for GLSL source debugging.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:302</div></div>
<div class="ttc" id="anvn_tool___glslc_interface_8h_html_a648dfc0b503357a72dad03652fc31e57"><div class="ttname"><a href="nvn_tool___glslc_interface_8h.html#a648dfc0b503357a72dad03652fc31e57">glslcInitialize</a></div><div class="ttdeci">GLSLCAPI uint8_t glslcInitialize(GLSLCcompileObject *compileObject)</div><div class="ttdoc">Initializes the compile objects, setting up internal structures.</div></div>
<div class="ttc" id="anvn_tool___glslc_interface_8h_html_a64bdf010fc635ccc01dc9f1625557da1"><div class="ttname"><a href="nvn_tool___glslc_interface_8h.html#a64bdf010fc635ccc01dc9f1625557da1">glslcCompileSpecialized</a></div><div class="ttdeci">GLSLCAPI const GLSLCoutput *const  * glslcCompileSpecialized(GLSLCcompileObject *compileObject, const GLSLCspecializationBatch *specEntries)</div><div class="ttdoc">Compiles a specialized version of the binary using the input specialization information.</div></div>
<div class="ttc" id="anvn_tool___glslc_interface_8h_html_a8a7629609d27a49283b8cb9587dcca48"><div class="ttname"><a href="nvn_tool___glslc_interface_8h.html#a8a7629609d27a49283b8cb9587dcca48">glslcCompilePreSpecialized</a></div><div class="ttdeci">GLSLCAPI bool glslcCompilePreSpecialized(GLSLCcompileObject *compileObject)</div><div class="ttdoc">Partially compiles to an intermediate representation so that future specialization compiles don't nee...</div></div>
<div class="ttc" id="anvn_tool___glslc_interface_8h_html_aab53ab9845cc7be41102195446759a59"><div class="ttname"><a href="nvn_tool___glslc_interface_8h.html#aab53ab9845cc7be41102195446759a59">GLSLCsectionTypeEnum</a></div><div class="ttdeci">GLSLCsectionTypeEnum</div><div class="ttdoc">Types for individual sections.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:371</div></div>
<div class="ttc" id="astruct_g_l_s_l_ccompile_object_html"><div class="ttname"><a href="struct_g_l_s_l_ccompile_object.html">GLSLCcompileObject</a></div><div class="ttdoc">The main object that holds input/output variables for compilation.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1577</div></div>
<div class="ttc" id="astruct_g_l_s_l_ccompile_object_html_a1439e7a28e5232e1dc82924e8c4d063d"><div class="ttname"><a href="struct_g_l_s_l_ccompile_object.html#a1439e7a28e5232e1dc82924e8c4d063d">GLSLCcompileObject::input</a></div><div class="ttdeci">GLSLCinput input</div><div class="ttdoc">Input shaders.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1603</div></div>
<div class="ttc" id="astruct_g_l_s_l_ccompile_object_html_a6cc042ea5fe41d3aa6c9fac773a447b8"><div class="ttname"><a href="struct_g_l_s_l_ccompile_object.html#a6cc042ea5fe41d3aa6c9fac773a447b8">GLSLCcompileObject::options</a></div><div class="ttdeci">GLSLCoptions options</div><div class="ttdoc">Compilation options.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1600</div></div>
<div class="ttc" id="astruct_g_l_s_l_cgpu_code_header_html"><div class="ttname"><a href="struct_g_l_s_l_cgpu_code_header.html">GLSLCgpuCodeHeader</a></div><div class="ttdoc">GPU code section header containing GPU code for an individual shader stage.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1168</div></div>
<div class="ttc" id="astruct_g_l_s_l_cgpu_code_header_html_a2617848640a161d41ed59f1a7c0ccb35"><div class="ttname"><a href="struct_g_l_s_l_cgpu_code_header.html#a2617848640a161d41ed59f1a7c0ccb35">GLSLCgpuCodeHeader::dataSize</a></div><div class="ttdeci">uint32_t dataSize</div><div class="ttdoc">The size of the data portion of the stream in bytes.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1181</div></div>
<div class="ttc" id="astruct_g_l_s_l_cgpu_code_header_html_a3b606fedf8582a1a47162d210e8a1448"><div class="ttname"><a href="struct_g_l_s_l_cgpu_code_header.html#a3b606fedf8582a1a47162d210e8a1448">GLSLCgpuCodeHeader::controlOffset</a></div><div class="ttdeci">uint32_t controlOffset</div><div class="ttdoc">The offset within the data of the control section, in bytes.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1175</div></div>
<div class="ttc" id="astruct_g_l_s_l_cgpu_code_header_html_aafdececf784595d922fe1b95b06db976"><div class="ttname"><a href="struct_g_l_s_l_cgpu_code_header.html#aafdececf784595d922fe1b95b06db976">GLSLCgpuCodeHeader::dataOffset</a></div><div class="ttdeci">uint32_t dataOffset</div><div class="ttdoc">The offset within the data of the GPU code data section in bytes.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1178</div></div>
<div class="ttc" id="astruct_g_l_s_l_cgpu_code_header_html_ab1e6be676a326a7281e18ad3a4607ced"><div class="ttname"><a href="struct_g_l_s_l_cgpu_code_header.html#ab1e6be676a326a7281e18ad3a4607ced">GLSLCgpuCodeHeader::stage</a></div><div class="ttdeci">NVNshaderStage stage</div><div class="ttdoc">The shader stage this corresponds to.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1172</div></div>
<div class="ttc" id="astruct_g_l_s_l_cgpu_code_header_html_ac8b1eef84fa9f0debec1874f8b570e62"><div class="ttname"><a href="struct_g_l_s_l_cgpu_code_header.html#ac8b1eef84fa9f0debec1874f8b570e62">GLSLCgpuCodeHeader::scratchMemBytesRecommended</a></div><div class="ttdeci">uint32_t scratchMemBytesRecommended</div><div class="ttdoc">The total amount of local memory recommended for this program on a NX device.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1204</div></div>
<div class="ttc" id="astruct_g_l_s_l_cgpu_code_header_html_aff5295c90f2dc5eb969fb14660f31712"><div class="ttname"><a href="struct_g_l_s_l_cgpu_code_header.html#aff5295c90f2dc5eb969fb14660f31712">GLSLCgpuCodeHeader::controlSize</a></div><div class="ttdeci">uint32_t controlSize</div><div class="ttdoc">The size of the control portion of the stream in bytes.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1184</div></div>
<div class="ttc" id="astruct_g_l_s_l_cinput_html"><div class="ttname"><a href="struct_g_l_s_l_cinput.html">GLSLCinput</a></div><div class="ttdoc">A structure used as input into GLSLC functions.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1005</div></div>
<div class="ttc" id="astruct_g_l_s_l_cinput_html_a2dd94f2657ef155e688d6a9927c6c381"><div class="ttname"><a href="struct_g_l_s_l_cinput.html#a2dd94f2657ef155e688d6a9927c6c381">GLSLCinput::count</a></div><div class="ttdeci">uint8_t count</div><div class="ttdoc">Number of entries in both the sources and stages arrays.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1017</div></div>
<div class="ttc" id="astruct_g_l_s_l_coption_flags_html_a723afb9e18cdf4c92bfe315c94e37c96"><div class="ttname"><a href="struct_g_l_s_l_coption_flags.html#a723afb9e18cdf4c92bfe315c94e37c96">GLSLCoptionFlags::outputShaderReflection</a></div><div class="ttdeci">uint32_t outputShaderReflection</div><div class="ttdoc">Output shader reflection data.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:814</div></div>
<div class="ttc" id="astruct_g_l_s_l_coption_flags_html_ac0396d28c3ec928aaa280cb90e71f485"><div class="ttname"><a href="struct_g_l_s_l_coption_flags.html#ac0396d28c3ec928aaa280cb90e71f485">GLSLCoptionFlags::outputAssembly</a></div><div class="ttdeci">uint32_t outputAssembly</div><div class="ttdoc">Include an assembly dump section in the GLSLCoutput.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:804</div></div>
<div class="ttc" id="astruct_g_l_s_l_coption_flags_html_acb869c3adcd98163305142fba3d84e2b"><div class="ttname"><a href="struct_g_l_s_l_coption_flags.html#acb869c3adcd98163305142fba3d84e2b">GLSLCoptionFlags::outputThinGpuBinaries</a></div><div class="ttdeci">uint32_t outputThinGpuBinaries</div><div class="ttdoc">Controls whether the resulting output contains a GPU program that is a thin binary (only contains pro...</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:827</div></div>
<div class="ttc" id="astruct_g_l_s_l_coption_flags_html_ad57cedc549a410a87a8b5e667afd31b9"><div class="ttname"><a href="struct_g_l_s_l_coption_flags.html#ad57cedc549a410a87a8b5e667afd31b9">GLSLCoptionFlags::outputPerfStats</a></div><div class="ttdeci">uint32_t outputPerfStats</div><div class="ttdoc">Output individual perf statistics for each compiled binary.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:811</div></div>
<div class="ttc" id="astruct_g_l_s_l_coption_flags_html_aec0779a250ad31f6deafe470820ffbb8"><div class="ttname"><a href="struct_g_l_s_l_coption_flags.html#aec0779a250ad31f6deafe470820ffbb8">GLSLCoptionFlags::outputGpuBinaries</a></div><div class="ttdeci">uint32_t outputGpuBinaries</div><div class="ttdoc">Output individual program binary sections in the GLSLCoutput.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:808</div></div>
<div class="ttc" id="astruct_g_l_s_l_coption_flags_html_af2b81192a389ab5093f074ced7ceea29"><div class="ttname"><a href="struct_g_l_s_l_coption_flags.html#af2b81192a389ab5093f074ced7ceea29">GLSLCoptionFlags::outputDebugInfo</a></div><div class="ttdeci">GLSLCdebugInfoLevelEnum outputDebugInfo</div><div class="ttdoc">Level of debug information to generate.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:820</div></div>
<div class="ttc" id="astruct_g_l_s_l_coption_flags_html_af673dc6b82db05442d203619be5a022d"><div class="ttname"><a href="struct_g_l_s_l_coption_flags.html#af673dc6b82db05442d203619be5a022d">GLSLCoptionFlags::glslSeparable</a></div><div class="ttdeci">uint32_t glslSeparable</div><div class="ttdoc">Treat the GLSLC object as separable.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:800</div></div>
<div class="ttc" id="astruct_g_l_s_l_coptions_html"><div class="ttname"><a href="struct_g_l_s_l_coptions.html">GLSLCoptions</a></div><div class="ttdoc">Options structure to control compilation phase, what gets output in the GLSLCOutput structure.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:928</div></div>
<div class="ttc" id="astruct_g_l_s_l_coptions_html_a2b07e6d6a4984f7922cab3efbf8caf16"><div class="ttname"><a href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">GLSLCoptions::optionFlags</a></div><div class="ttdeci">GLSLCoptionFlags optionFlags</div><div class="ttdoc">A structure used for controlling which outputs are emitted in the GLSLCoutput section and for specify...</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:934</div></div>
<div class="ttc" id="astruct_g_l_s_l_coutput_html"><div class="ttname"><a href="struct_g_l_s_l_coutput.html">GLSLCoutput</a></div><div class="ttdoc">Main GLSLC output structure.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1474</div></div>
<div class="ttc" id="astruct_g_l_s_l_coutput_html_a69ff5a7c06d39592caacec94be810995"><div class="ttname"><a href="struct_g_l_s_l_coutput.html#a69ff5a7c06d39592caacec94be810995">GLSLCoutput::headers</a></div><div class="ttdeci">GLSLCsectionHeaderUnion headers[1]</div><div class="ttdoc">Array of section headers for this output structure.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1502</div></div>
<div class="ttc" id="astruct_g_l_s_l_coutput_html_a6cbb6ec5e8a4ff04512fd1c442aa3d92"><div class="ttname"><a href="struct_g_l_s_l_coutput.html#a6cbb6ec5e8a4ff04512fd1c442aa3d92">GLSLCoutput::numSections</a></div><div class="ttdeci">uint32_t numSections</div><div class="ttdoc">Number of sections contained in the binary.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1497</div></div>
<div class="ttc" id="astruct_g_l_s_l_cpiq_name_html_a95cb55a78c99bc13a5442a4ec038fe64"><div class="ttname"><a href="struct_g_l_s_l_cpiq_name.html#a95cb55a78c99bc13a5442a4ec038fe64">GLSLCpiqName::nameOffset</a></div><div class="ttdeci">uint32_t nameOffset</div><div class="ttdoc">Offset of the name into the data string pool.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:398</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_input_info_html"><div class="ttname"><a href="struct_g_l_s_l_cprogram_input_info.html">GLSLCprogramInputInfo</a></div><div class="ttdoc">An information data section corresponding to individual attributes.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:530</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_input_info_html_a30e2dc0f471667ac41cdde8329d71e25"><div class="ttname"><a href="struct_g_l_s_l_cprogram_input_info.html#a30e2dc0f471667ac41cdde8329d71e25">GLSLCprogramInputInfo::nameInfo</a></div><div class="ttdeci">GLSLCpiqName nameInfo</div><div class="ttdoc">Info about the name in the data string pool.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:532</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_input_info_html_aa850abcd72ca572b118cea86cc858af7"><div class="ttname"><a href="struct_g_l_s_l_cprogram_input_info.html#aa850abcd72ca572b118cea86cc858af7">GLSLCprogramInputInfo::stagesReferencedIn</a></div><div class="ttdeci">NVNshaderStageBits stagesReferencedIn</div><div class="ttdoc">Stage mask representing which stages this variable is active in.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:545</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_input_info_html_ac0100c9580f95e97b101ae505680bef0"><div class="ttname"><a href="struct_g_l_s_l_cprogram_input_info.html#ac0100c9580f95e97b101ae505680bef0">GLSLCprogramInputInfo::location</a></div><div class="ttdeci">int32_t location</div><div class="ttdoc">Location this input is assigned to.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:542</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_reflection_header_html"><div class="ttname"><a href="struct_g_l_s_l_cprogram_reflection_header.html">GLSLCprogramReflectionHeader</a></div><div class="ttdoc">Program reflection data header.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1088</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_reflection_header_html_a006944206bfbf2bbfb56c1dfb9dc7f96"><div class="ttname"><a href="struct_g_l_s_l_cprogram_reflection_header.html#a006944206bfbf2bbfb56c1dfb9dc7f96">GLSLCprogramReflectionHeader::numUniformBlocks</a></div><div class="ttdeci">uint32_t numUniformBlocks</div><div class="ttdoc">Number of uniform blocks.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1092</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_reflection_header_html_a0bf19ae5c6027329eec9480f13c71d3c"><div class="ttname"><a href="struct_g_l_s_l_cprogram_reflection_header.html#a0bf19ae5c6027329eec9480f13c71d3c">GLSLCprogramReflectionHeader::numUniforms</a></div><div class="ttdeci">uint32_t numUniforms</div><div class="ttdoc">Number of uniforms.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1098</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_reflection_header_html_a23a3fcd75086c2b537f992e212661622"><div class="ttname"><a href="struct_g_l_s_l_cprogram_reflection_header.html#a23a3fcd75086c2b537f992e212661622">GLSLCprogramReflectionHeader::stringPoolOffset</a></div><div class="ttdeci">uint32_t stringPoolOffset</div><div class="ttdoc">Offset into data section for the string pool data.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1137</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_reflection_header_html_a7116c27cf2638894a145fcdbb7d05568"><div class="ttname"><a href="struct_g_l_s_l_cprogram_reflection_header.html#a7116c27cf2638894a145fcdbb7d05568">GLSLCprogramReflectionHeader::uniformOffset</a></div><div class="ttdeci">uint32_t uniformOffset</div><div class="ttdoc">Offset into data section for the uniform reflection data.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1101</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_reflection_header_html_a9f264ef95c68193971b360b4df2f259d"><div class="ttname"><a href="struct_g_l_s_l_cprogram_reflection_header.html#a9f264ef95c68193971b360b4df2f259d">GLSLCprogramReflectionHeader::programInputsOffset</a></div><div class="ttdeci">uint32_t programInputsOffset</div><div class="ttdoc">Offset into data section for the program input.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1107</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_reflection_header_html_ab7239cf2349bda4632d8382ffddcde85"><div class="ttname"><a href="struct_g_l_s_l_cprogram_reflection_header.html#ab7239cf2349bda4632d8382ffddcde85">GLSLCprogramReflectionHeader::uniformBlockOffset</a></div><div class="ttdeci">uint32_t uniformBlockOffset</div><div class="ttdoc">Offset into data section for the uniform block reflection data.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1095</div></div>
<div class="ttc" id="astruct_g_l_s_l_cprogram_reflection_header_html_aca10eea8e482a030016556875aec0a7f"><div class="ttname"><a href="struct_g_l_s_l_cprogram_reflection_header.html#aca10eea8e482a030016556875aec0a7f">GLSLCprogramReflectionHeader::numProgramInputs</a></div><div class="ttdeci">uint32_t numProgramInputs</div><div class="ttdoc">Number of program inputs.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1104</div></div>
<div class="ttc" id="astruct_g_l_s_l_csection_header_common_html_a6a8aed7a5a7e82acff908d084fd85e4a"><div class="ttname"><a href="struct_g_l_s_l_csection_header_common.html#a6a8aed7a5a7e82acff908d084fd85e4a">GLSLCsectionHeaderCommon::type</a></div><div class="ttdeci">GLSLCsectionTypeEnum type</div><div class="ttdoc">Type of section.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1047</div></div>
<div class="ttc" id="astruct_g_l_s_l_csection_header_common_html_abb6e96b70bad30c94477317328d384d5"><div class="ttname"><a href="struct_g_l_s_l_csection_header_common.html#abb6e96b70bad30c94477317328d384d5">GLSLCsectionHeaderCommon::dataOffset</a></div><div class="ttdeci">uint32_t dataOffset</div><div class="ttdoc">Offset of the data section, in bytes, relative to the top-level structure containing the section head...</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:1044</div></div>
<div class="ttc" id="astruct_g_l_s_l_cspecialization_batch_html"><div class="ttname"><a href="struct_g_l_s_l_cspecialization_batch.html">GLSLCspecializationBatch</a></div><div class="ttdoc">Used for &quot;batch&quot; mode processing, contains multiple specialization sets.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:784</div></div>
<div class="ttc" id="astruct_g_l_s_l_cspecialization_batch_html_a0be46d42422ea32ebcc5e31ca3016484"><div class="ttname"><a href="struct_g_l_s_l_cspecialization_batch.html#a0be46d42422ea32ebcc5e31ca3016484">GLSLCspecializationBatch::numEntries</a></div><div class="ttdeci">uint32_t numEntries</div><div class="ttdoc">Number of sets in the array entries</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:789</div></div>
<div class="ttc" id="astruct_g_l_s_l_cuniform_block_info_html"><div class="ttname"><a href="struct_g_l_s_l_cuniform_block_info.html">GLSLCuniformBlockInfo</a></div><div class="ttdoc">An information data section corresponding to uniform blocks.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:408</div></div>
<div class="ttc" id="astruct_g_l_s_l_cuniform_block_info_html_a3089f78f6431b069fca45643190b8f88"><div class="ttname"><a href="struct_g_l_s_l_cuniform_block_info.html#a3089f78f6431b069fca45643190b8f88">GLSLCuniformBlockInfo::bindings</a></div><div class="ttdeci">int32_t bindings[GLSLC_NUM_SHADER_STAGES]</div><div class="ttdoc">Bindings associated with this block in each shader stage, where array index n corresponds to NVNshade...</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:427</div></div>
<div class="ttc" id="astruct_g_l_s_l_cuniform_block_info_html_a449b0310144f865d20c9152228c1f5c2"><div class="ttname"><a href="struct_g_l_s_l_cuniform_block_info.html#a449b0310144f865d20c9152228c1f5c2">GLSLCuniformBlockInfo::stagesReferencedIn</a></div><div class="ttdeci">NVNshaderStageBits stagesReferencedIn</div><div class="ttdoc">Stage mask representing which stages this variable is active in.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:419</div></div>
<div class="ttc" id="astruct_g_l_s_l_cuniform_block_info_html_a995ad7b06ac8f754faceea20cb6b8443"><div class="ttname"><a href="struct_g_l_s_l_cuniform_block_info.html#a995ad7b06ac8f754faceea20cb6b8443">GLSLCuniformBlockInfo::size</a></div><div class="ttdeci">uint32_t size</div><div class="ttdoc">Data size (in bytes) of this uniform block.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:413</div></div>
<div class="ttc" id="astruct_g_l_s_l_cuniform_block_info_html_af581f038ae9544eb77e43729691532a8"><div class="ttname"><a href="struct_g_l_s_l_cuniform_block_info.html#af581f038ae9544eb77e43729691532a8">GLSLCuniformBlockInfo::nameInfo</a></div><div class="ttdeci">GLSLCpiqName nameInfo</div><div class="ttdoc">Info about the name in the data string pool.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:410</div></div>
<div class="ttc" id="astruct_g_l_s_l_cuniform_info_html"><div class="ttname"><a href="struct_g_l_s_l_cuniform_info.html">GLSLCuniformInfo</a></div><div class="ttdoc">An information data section corresponding to individual uniforms.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:434</div></div>
<div class="ttc" id="astruct_g_l_s_l_cuniform_info_html_a062aec36dd8b1203f67b1a8bd12948ee"><div class="ttname"><a href="struct_g_l_s_l_cuniform_info.html#a062aec36dd8b1203f67b1a8bd12948ee">GLSLCuniformInfo::stagesReferencedIn</a></div><div class="ttdeci">NVNshaderStageBits stagesReferencedIn</div><div class="ttdoc">Stage mask representing which stages this variable is active in.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:462</div></div>
<div class="ttc" id="astruct_g_l_s_l_cuniform_info_html_a2f72999cec8d93607ffc6c9488c8bd6e"><div class="ttname"><a href="struct_g_l_s_l_cuniform_info.html#a2f72999cec8d93607ffc6c9488c8bd6e">GLSLCuniformInfo::blockOffset</a></div><div class="ttdeci">int32_t blockOffset</div><div class="ttdoc">Byte offset into the uniform block. -1 if not defined in a uniform block.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:446</div></div>
<div class="ttc" id="astruct_g_l_s_l_cuniform_info_html_af3c2cf0a643a810defd8f1964ee5347c"><div class="ttname"><a href="struct_g_l_s_l_cuniform_info.html#af3c2cf0a643a810defd8f1964ee5347c">GLSLCuniformInfo::nameInfo</a></div><div class="ttdeci">GLSLCpiqName nameInfo</div><div class="ttdoc">Info about the name in the data string pool.</div><div class="ttdef"><b>Definition:</b> nvnTool_GlslcInterface.h:436</div></div>
<div class="ttc" id="astruct_n_v_nbuffer_html"><div class="ttname"><a href="struct_n_v_nbuffer.html">NVNbuffer</a></div><div class="ttdoc">Block of GPU-accessible memory used to hold data used for various purposes.</div><div class="ttdef"><b>Definition:</b> nvn.h:319</div></div>
<div class="ttc" id="astruct_n_v_ndevice_html"><div class="ttname"><a href="struct_n_v_ndevice.html">NVNdevice</a></div><div class="ttdoc">API class used to represent a specific GPU/device.</div><div class="ttdef"><b>Definition:</b> nvn.h:221</div></div>
<div class="ttc" id="astruct_n_v_nprogram_html"><div class="ttname"><a href="struct_n_v_nprogram.html">NVNprogram</a></div><div class="ttdoc">Collection of programmable shaders used to process primitives.</div><div class="ttdef"><b>Definition:</b> nvn.h:284</div></div>
<div class="ttc" id="astruct_n_v_nshader_data_html"><div class="ttname"><a href="struct_n_v_nshader_data.html">NVNshaderData</a></div><div class="ttdoc">Data structure representing the shader data.</div><div class="ttdef"><b>Definition:</b> nvn.h:4133</div></div>
<div class="ttc" id="astructnn_1_1fs_1_1_file_handle_html"><div class="ttname"><a href="structnn_1_1fs_1_1_file_handle.html">nn::fs::FileHandle</a></div><div class="ttdoc">Handle for working with a file.</div><div class="ttdef"><b>Definition:</b> fs_File.h:90</div></div>
</div><!-- fragment --> </div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
