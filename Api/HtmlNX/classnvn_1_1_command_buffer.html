<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nvn::CommandBuffer Class Reference | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenvn.html">nvn</a></li><li class="navelem"><a class="el" href="classnvn_1_1_command_buffer.html">CommandBuffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classnvn_1_1_command_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">nvn::CommandBuffer Class Reference<div class="ingroups"><a class="el" href="group__nvn__cpp__interface.html">NVN C++ API Bindings</a> &raquo; <a class="el" href="group__nvn__cpp__apiclasses.html">API Classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Collection of commands to send to the GPU via queues.  
 <a href="classnvn_1_1_command_buffer.html#details">More...</a></p>

<p><code>#include &lt;nvn/nvn_Cpp.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab6b7a5a37fd5f91e4b50fb22498a992d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#ab6b7a5a37fd5f91e4b50fb22498a992d">AddCommandMemory</a> (const <a class="el" href="classnvn_1_1_memory_pool.html">MemoryPool</a> *pool, ptrdiff_t offset, size_t size)</td></tr>
<tr class="memdesc:ab6b7a5a37fd5f91e4b50fb22498a992d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add command data memory for a <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a> object.  <a href="classnvn_1_1_command_buffer.html#ab6b7a5a37fd5f91e4b50fb22498a992d">More...</a><br /></td></tr>
<tr class="separator:ab6b7a5a37fd5f91e4b50fb22498a992d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4fd1a23d42725f00f814de03270d17a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#aa4fd1a23d42725f00f814de03270d17a">AddControlMemory</a> (void *memory, size_t size)</td></tr>
<tr class="memdesc:aa4fd1a23d42725f00f814de03270d17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add control memory for a <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a> object.  <a href="classnvn_1_1_command_buffer.html#aa4fd1a23d42725f00f814de03270d17a">More...</a><br /></td></tr>
<tr class="separator:aa4fd1a23d42725f00f814de03270d17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9df9457cbd501a6035720f31979752"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a1d9df9457cbd501a6035720f31979752">Barrier</a> (<a class="el" href="structnvn_1_1_barrier_bits.html">BarrierBits</a> barrier)</td></tr>
<tr class="memdesc:a1d9df9457cbd501a6035720f31979752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a barrier ordering execution of GPU commands and invalidating internal GPU caches.  <a href="classnvn_1_1_command_buffer.html#a1d9df9457cbd501a6035720f31979752">More...</a><br /></td></tr>
<tr class="separator:a1d9df9457cbd501a6035720f31979752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569698f00f43c1074330c137b97f9e81"><td class="memItemLeft" align="right" valign="top"><a id="a569698f00f43c1074330c137b97f9e81"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a569698f00f43c1074330c137b97f9e81">BeginRecording</a> ()</td></tr>
<tr class="memdesc:a569698f00f43c1074330c137b97f9e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin recording a new set of commands in this <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a> object. <br /></td></tr>
<tr class="separator:a569698f00f43c1074330c137b97f9e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d6195ed2b397b50771255376b455e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a24d6195ed2b397b50771255376b455e6">BeginRecording_fastpath</a> ()</td></tr>
<tr class="memdesc:a24d6195ed2b397b50771255376b455e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin recording a new set of commands in this <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a> object.  <a href="classnvn_1_1_command_buffer.html#a24d6195ed2b397b50771255376b455e6">More...</a><br /></td></tr>
<tr class="separator:a24d6195ed2b397b50771255376b455e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e05f90c241cb01ffe07862ae2afaad5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a6e05f90c241cb01ffe07862ae2afaad5">BeginTransformFeedback</a> (<a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> buffer)</td></tr>
<tr class="memdesc:a6e05f90c241cb01ffe07862ae2afaad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a transform feedback (stream output) operation.  <a href="classnvn_1_1_command_buffer.html#a6e05f90c241cb01ffe07862ae2afaad5">More...</a><br /></td></tr>
<tr class="separator:a6e05f90c241cb01ffe07862ae2afaad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328628b7afb78c07dc84fed234782b6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a328628b7afb78c07dc84fed234782b6d">BindBlendState</a> (NVN_NOESCAPE const <a class="el" href="classnvn_1_1_blend_state.html">BlendState</a> *blend)</td></tr>
<tr class="memdesc:a328628b7afb78c07dc84fed234782b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a new <a class="el" href="classnvn_1_1_blend_state.html" title="API state object controlling blending for one color target.">BlendState</a> object to bind for subsequent commands.  <a href="classnvn_1_1_command_buffer.html#a328628b7afb78c07dc84fed234782b6d">More...</a><br /></td></tr>
<tr class="separator:a328628b7afb78c07dc84fed234782b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a797044107ce1574da45a9d4dcbe3b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a6a797044107ce1574da45a9d4dcbe3b2">BindChannelMaskState</a> (NVN_NOESCAPE const <a class="el" href="classnvn_1_1_channel_mask_state.html">ChannelMaskState</a> *channelMask)</td></tr>
<tr class="memdesc:a6a797044107ce1574da45a9d4dcbe3b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a new <a class="el" href="classnvn_1_1_channel_mask_state.html" title="API state object holding per-channel write masks for all color buffers.">ChannelMaskState</a> object to bind for subsequent commands.  <a href="classnvn_1_1_command_buffer.html#a6a797044107ce1574da45a9d4dcbe3b2">More...</a><br /></td></tr>
<tr class="separator:a6a797044107ce1574da45a9d4dcbe3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d9cbd74906a5c23c4eefffaca5b0a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a76d9cbd74906a5c23c4eefffaca5b0a7">BindColorState</a> (NVN_NOESCAPE const <a class="el" href="classnvn_1_1_color_state.html">ColorState</a> *color)</td></tr>
<tr class="memdesc:a76d9cbd74906a5c23c4eefffaca5b0a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a new <a class="el" href="classnvn_1_1_color_state.html" title="API state object controlling processing of color values.">ColorState</a> object to bind for subsequent commands.  <a href="classnvn_1_1_command_buffer.html#a76d9cbd74906a5c23c4eefffaca5b0a7">More...</a><br /></td></tr>
<tr class="separator:a76d9cbd74906a5c23c4eefffaca5b0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590a471152f386345e26f39e98890d60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a590a471152f386345e26f39e98890d60">BindCoverageModulationTable</a> (NVN_NOESCAPE const float *entries)</td></tr>
<tr class="memdesc:a590a471152f386345e26f39e98890d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds or unbinds a coverage modulation table used for target-independent rasterization.  <a href="classnvn_1_1_command_buffer.html#a590a471152f386345e26f39e98890d60">More...</a><br /></td></tr>
<tr class="separator:a590a471152f386345e26f39e98890d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3602d565b4fb17392a1d3ade9513be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a7f3602d565b4fb17392a1d3ade9513be">BindDepthStencilState</a> (NVN_NOESCAPE const <a class="el" href="classnvn_1_1_depth_stencil_state.html">DepthStencilState</a> *depthStencil)</td></tr>
<tr class="memdesc:a7f3602d565b4fb17392a1d3ade9513be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a new <a class="el" href="classnvn_1_1_depth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">DepthStencilState</a> object to bind for subsequent commands.  <a href="classnvn_1_1_command_buffer.html#a7f3602d565b4fb17392a1d3ade9513be">More...</a><br /></td></tr>
<tr class="separator:a7f3602d565b4fb17392a1d3ade9513be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4748cba765d583a25c409e57645c7ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#aa4748cba765d583a25c409e57645c7ab">BindImage</a> (<a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a> stage, int index, <a class="el" href="group__nvn__cpp__handle.html#ga0ad8373f5da7065f67ab5d14eed99ac2">ImageHandle</a> image)</td></tr>
<tr class="memdesc:aa4748cba765d583a25c409e57645c7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> to use for image loads and stores in shaders.  <a href="classnvn_1_1_command_buffer.html#aa4748cba765d583a25c409e57645c7ab">More...</a><br /></td></tr>
<tr class="separator:aa4748cba765d583a25c409e57645c7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419c6e03d540096c3cc4ddf1ec04183b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a419c6e03d540096c3cc4ddf1ec04183b">BindImages</a> (<a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a> stage, int first, int count, NVN_NOESCAPE const <a class="el" href="group__nvn__cpp__handle.html#ga0ad8373f5da7065f67ab5d14eed99ac2">ImageHandle</a> *images)</td></tr>
<tr class="memdesc:a419c6e03d540096c3cc4ddf1ec04183b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more Textures to use for image loads and stores in shaders.  <a href="classnvn_1_1_command_buffer.html#a419c6e03d540096c3cc4ddf1ec04183b">More...</a><br /></td></tr>
<tr class="separator:a419c6e03d540096c3cc4ddf1ec04183b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6b61951fb49c5720eafe6e174b2011"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#aac6b61951fb49c5720eafe6e174b2011">BindImagesDeferred</a> (<a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a> stage, int first, int count, const <a class="el" href="group__nvn__cpp__handle.html#ga0ad8373f5da7065f67ab5d14eed99ac2">ImageHandle</a> *images)</td></tr>
<tr class="memdesc:aac6b61951fb49c5720eafe6e174b2011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more Textures to use for image loads and stores in shaders.  <a href="classnvn_1_1_command_buffer.html#aac6b61951fb49c5720eafe6e174b2011">More...</a><br /></td></tr>
<tr class="separator:aac6b61951fb49c5720eafe6e174b2011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585c02d8f766d6972fd1054a0e93c449"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a585c02d8f766d6972fd1054a0e93c449">BindImagesDeferred_fastpath</a> (<a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a> stage, int first, int count, const <a class="el" href="group__nvn__cpp__handle.html#ga0ad8373f5da7065f67ab5d14eed99ac2">ImageHandle</a> *images)</td></tr>
<tr class="memdesc:a585c02d8f766d6972fd1054a0e93c449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more Textures to use for image loads and stores in shaders.  <a href="classnvn_1_1_command_buffer.html#a585c02d8f766d6972fd1054a0e93c449">More...</a><br /></td></tr>
<tr class="separator:a585c02d8f766d6972fd1054a0e93c449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada98a813425af1616714bb465233ffe8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#ada98a813425af1616714bb465233ffe8">BindMultisampleState</a> (NVN_NOESCAPE const <a class="el" href="classnvn_1_1_multisample_state.html">MultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:ada98a813425af1616714bb465233ffe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a new <a class="el" href="classnvn_1_1_multisample_state.html" title="API state object controlling multisample rasterization and sample processing.">MultisampleState</a> object to bind for subsequent commands.  <a href="classnvn_1_1_command_buffer.html#ada98a813425af1616714bb465233ffe8">More...</a><br /></td></tr>
<tr class="separator:ada98a813425af1616714bb465233ffe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab5d1dedfe29fb0ca07d8f48be7eace"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#adab5d1dedfe29fb0ca07d8f48be7eace">BindPolygonState</a> (NVN_NOESCAPE const <a class="el" href="classnvn_1_1_polygon_state.html">PolygonState</a> *polygon)</td></tr>
<tr class="memdesc:adab5d1dedfe29fb0ca07d8f48be7eace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a new <a class="el" href="classnvn_1_1_polygon_state.html" title="API state object controlling rasterization of polygons.">PolygonState</a> object to bind for subsequent commands.  <a href="classnvn_1_1_command_buffer.html#adab5d1dedfe29fb0ca07d8f48be7eace">More...</a><br /></td></tr>
<tr class="separator:adab5d1dedfe29fb0ca07d8f48be7eace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533458762741e1851a0d64a766593b5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a533458762741e1851a0d64a766593b5d">BindProgram</a> (const <a class="el" href="classnvn_1_1_program.html">Program</a> *program, <a class="el" href="structnvn_1_1_shader_stage_bits.html">ShaderStageBits</a> stages)</td></tr>
<tr class="memdesc:a533458762741e1851a0d64a766593b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind or unbind shaders in a <a class="el" href="classnvn_1_1_program.html" title="Collection of programmable shaders used to process primitives.">Program</a> object for subsequent rendering commands.  <a href="classnvn_1_1_command_buffer.html#a533458762741e1851a0d64a766593b5d">More...</a><br /></td></tr>
<tr class="separator:a533458762741e1851a0d64a766593b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a0cf86766888156ef4f1b50f2095e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a32a0cf86766888156ef4f1b50f2095e1">BindSeparateSampler</a> (<a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a> stage, int index, <a class="el" href="structnvn_1_1_separate_sampler_handle.html">SeparateSamplerHandle</a> samplerHandle)</td></tr>
<tr class="memdesc:a32a0cf86766888156ef4f1b50f2095e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a separate <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">Sampler</a> to use for texture mapping in shaders.  <a href="classnvn_1_1_command_buffer.html#a32a0cf86766888156ef4f1b50f2095e1">More...</a><br /></td></tr>
<tr class="separator:a32a0cf86766888156ef4f1b50f2095e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148ad5b6d2eda66976f2161bb7729b89"><td class="memItemLeft" align="right" valign="top">NVN_PRE_DEPRECATED void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a148ad5b6d2eda66976f2161bb7729b89">bindSeparateSampler</a> (<a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a> stage, int index, <a class="el" href="structnvn_1_1_separate_sampler_handle.html">SeparateSamplerHandle</a> samplerHandle) NVN_POST_DEPRECATED</td></tr>
<tr class="memdesc:a148ad5b6d2eda66976f2161bb7729b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a separate <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">Sampler</a> to use for texture mapping in shaders.  <a href="classnvn_1_1_command_buffer.html#a148ad5b6d2eda66976f2161bb7729b89">More...</a><br /></td></tr>
<tr class="separator:a148ad5b6d2eda66976f2161bb7729b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80cb59e7b9cf2c3722d5b9f90815f57c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a80cb59e7b9cf2c3722d5b9f90815f57c">BindSeparateSamplers</a> (<a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a> stage, int first, int count, NVN_NOESCAPE const <a class="el" href="structnvn_1_1_separate_sampler_handle.html">SeparateSamplerHandle</a> *samplerHandles)</td></tr>
<tr class="memdesc:a80cb59e7b9cf2c3722d5b9f90815f57c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more Samplers to use for texture mapping in shaders.  <a href="classnvn_1_1_command_buffer.html#a80cb59e7b9cf2c3722d5b9f90815f57c">More...</a><br /></td></tr>
<tr class="separator:a80cb59e7b9cf2c3722d5b9f90815f57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92b5310f827c5a5490107e794a73c0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#ad92b5310f827c5a5490107e794a73c0e">BindSeparateSamplersDeferred</a> (<a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a> stage, int first, int count, const <a class="el" href="structnvn_1_1_separate_sampler_handle.html">SeparateSamplerHandle</a> *samplerHandles)</td></tr>
<tr class="memdesc:ad92b5310f827c5a5490107e794a73c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more Samplers to use for texture mapping in shaders.  <a href="classnvn_1_1_command_buffer.html#ad92b5310f827c5a5490107e794a73c0e">More...</a><br /></td></tr>
<tr class="separator:ad92b5310f827c5a5490107e794a73c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dcbbf6918247308a2b3ec2edf04c7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a48dcbbf6918247308a2b3ec2edf04c7e">BindSeparateSamplersDeferred_fastpath</a> (<a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a> stage, int first, int count, const <a class="el" href="structnvn_1_1_separate_sampler_handle.html">SeparateSamplerHandle</a> *samplerHandles)</td></tr>
<tr class="memdesc:a48dcbbf6918247308a2b3ec2edf04c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more Samplers to use for texture mapping in shaders.  <a href="classnvn_1_1_command_buffer.html#a48dcbbf6918247308a2b3ec2edf04c7e">More...</a><br /></td></tr>
<tr class="separator:a48dcbbf6918247308a2b3ec2edf04c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c573173dbcfeda3576f8bf6ed55407e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a3c573173dbcfeda3576f8bf6ed55407e">BindSeparateTexture</a> (<a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a> stage, int index, <a class="el" href="structnvn_1_1_separate_texture_handle.html">SeparateTextureHandle</a> textureHandle)</td></tr>
<tr class="memdesc:a3c573173dbcfeda3576f8bf6ed55407e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a separate <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> to use for texture mapping in shaders.  <a href="classnvn_1_1_command_buffer.html#a3c573173dbcfeda3576f8bf6ed55407e">More...</a><br /></td></tr>
<tr class="separator:a3c573173dbcfeda3576f8bf6ed55407e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab753effba29b618dcf425e42ecb392c6"><td class="memItemLeft" align="right" valign="top">NVN_PRE_DEPRECATED void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#ab753effba29b618dcf425e42ecb392c6">bindSeparateTexture</a> (<a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a> stage, int index, <a class="el" href="structnvn_1_1_separate_texture_handle.html">SeparateTextureHandle</a> textureHandle) NVN_POST_DEPRECATED</td></tr>
<tr class="memdesc:ab753effba29b618dcf425e42ecb392c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a separate <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> to use for texture mapping in shaders.  <a href="classnvn_1_1_command_buffer.html#ab753effba29b618dcf425e42ecb392c6">More...</a><br /></td></tr>
<tr class="separator:ab753effba29b618dcf425e42ecb392c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e12db39b6d1672fee21a7915219c621"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a9e12db39b6d1672fee21a7915219c621">BindSeparateTextures</a> (<a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a> stage, int first, int count, NVN_NOESCAPE const <a class="el" href="structnvn_1_1_separate_texture_handle.html">SeparateTextureHandle</a> *textureHandles)</td></tr>
<tr class="memdesc:a9e12db39b6d1672fee21a7915219c621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more separate textures to use for texture mapping in shaders.  <a href="classnvn_1_1_command_buffer.html#a9e12db39b6d1672fee21a7915219c621">More...</a><br /></td></tr>
<tr class="separator:a9e12db39b6d1672fee21a7915219c621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a1ea897a32a20f0603f86d372e8c52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a36a1ea897a32a20f0603f86d372e8c52">BindSeparateTexturesDeferred</a> (<a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a> stage, int first, int count, const <a class="el" href="structnvn_1_1_separate_texture_handle.html">SeparateTextureHandle</a> *textureHandles)</td></tr>
<tr class="memdesc:a36a1ea897a32a20f0603f86d372e8c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more separate textures to use for texture mapping in shaders.  <a href="classnvn_1_1_command_buffer.html#a36a1ea897a32a20f0603f86d372e8c52">More...</a><br /></td></tr>
<tr class="separator:a36a1ea897a32a20f0603f86d372e8c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da8679714d52e36ff1aaf5190255866"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a2da8679714d52e36ff1aaf5190255866">BindSeparateTexturesDeferred_fastpath</a> (<a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a> stage, int first, int count, const <a class="el" href="structnvn_1_1_separate_texture_handle.html">SeparateTextureHandle</a> *textureHandles)</td></tr>
<tr class="memdesc:a2da8679714d52e36ff1aaf5190255866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more separate textures to use for texture mapping in shaders.  <a href="classnvn_1_1_command_buffer.html#a2da8679714d52e36ff1aaf5190255866">More...</a><br /></td></tr>
<tr class="separator:a2da8679714d52e36ff1aaf5190255866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8f4df985fe6d64ede82ae19a5ee9d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a1e8f4df985fe6d64ede82ae19a5ee9d7">BindStorageBuffer</a> (<a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a> stage, int index, <a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> buffer, size_t size)</td></tr>
<tr class="memdesc:a1e8f4df985fe6d64ede82ae19a5ee9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a range of a <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object to use for random-access reads and writes in shaders.  <a href="classnvn_1_1_command_buffer.html#a1e8f4df985fe6d64ede82ae19a5ee9d7">More...</a><br /></td></tr>
<tr class="separator:a1e8f4df985fe6d64ede82ae19a5ee9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23714ab975ced5fe2a5502504e34a59c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a23714ab975ced5fe2a5502504e34a59c">BindStorageBuffers</a> (<a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a> stage, int first, int count, NVN_NOESCAPE const <a class="el" href="structnvn_1_1_buffer_range.html">BufferRange</a> *buffers)</td></tr>
<tr class="memdesc:a23714ab975ced5fe2a5502504e34a59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object ranges to use for random-access reads and writes in shaders.  <a href="classnvn_1_1_command_buffer.html#a23714ab975ced5fe2a5502504e34a59c">More...</a><br /></td></tr>
<tr class="separator:a23714ab975ced5fe2a5502504e34a59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c27d787401033c1a1202e5566b0ff4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a38c27d787401033c1a1202e5566b0ff4">BindStorageBuffersDeferred</a> (<a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a> stage, int first, int count, const <a class="el" href="structnvn_1_1_buffer_range.html">BufferRange</a> *buffers)</td></tr>
<tr class="memdesc:a38c27d787401033c1a1202e5566b0ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object ranges to use for random-access reads and writes in shaders.  <a href="classnvn_1_1_command_buffer.html#a38c27d787401033c1a1202e5566b0ff4">More...</a><br /></td></tr>
<tr class="separator:a38c27d787401033c1a1202e5566b0ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01eed4ca62a3cd835e5a840e906c25a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a01eed4ca62a3cd835e5a840e906c25a2">BindStorageBuffersDeferred_fastpath</a> (<a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a> stage, int first, int count, const <a class="el" href="structnvn_1_1_buffer_range.html">BufferRange</a> *buffers)</td></tr>
<tr class="memdesc:a01eed4ca62a3cd835e5a840e906c25a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object ranges to use for random-access reads and writes in shaders.  <a href="classnvn_1_1_command_buffer.html#a01eed4ca62a3cd835e5a840e906c25a2">More...</a><br /></td></tr>
<tr class="separator:a01eed4ca62a3cd835e5a840e906c25a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1b66c1660d5692b9e337db1262f901"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a4f1b66c1660d5692b9e337db1262f901">BindTexture</a> (<a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a> stage, int index, <a class="el" href="group__nvn__cpp__handle.html#gafe744b035d9582a86872d256349c5e08">TextureHandle</a> texture)</td></tr>
<tr class="memdesc:a4f1b66c1660d5692b9e337db1262f901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a Texture/Sampler pair to use for texture mapping in shaders.  <a href="classnvn_1_1_command_buffer.html#a4f1b66c1660d5692b9e337db1262f901">More...</a><br /></td></tr>
<tr class="separator:a4f1b66c1660d5692b9e337db1262f901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3256b8853627d7b5cf003c2e4e807f2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a3256b8853627d7b5cf003c2e4e807f2d">BindTextures</a> (<a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a> stage, int first, int count, NVN_NOESCAPE const <a class="el" href="group__nvn__cpp__handle.html#gafe744b035d9582a86872d256349c5e08">TextureHandle</a> *textures)</td></tr>
<tr class="memdesc:a3256b8853627d7b5cf003c2e4e807f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more Texture/Sampler pairs to use for texture mapping in shaders.  <a href="classnvn_1_1_command_buffer.html#a3256b8853627d7b5cf003c2e4e807f2d">More...</a><br /></td></tr>
<tr class="separator:a3256b8853627d7b5cf003c2e4e807f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef859ca8cf0402a8e4d1f7ef602d89c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a3ef859ca8cf0402a8e4d1f7ef602d89c">BindTexturesDeferred</a> (<a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a> stage, int first, int count, const <a class="el" href="group__nvn__cpp__handle.html#gafe744b035d9582a86872d256349c5e08">TextureHandle</a> *textures)</td></tr>
<tr class="memdesc:a3ef859ca8cf0402a8e4d1f7ef602d89c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more Texture/Sampler pairs to use for texture mapping in shaders.  <a href="classnvn_1_1_command_buffer.html#a3ef859ca8cf0402a8e4d1f7ef602d89c">More...</a><br /></td></tr>
<tr class="separator:a3ef859ca8cf0402a8e4d1f7ef602d89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a41e95f94942dd7d6f2722d98bdddb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#ae2a41e95f94942dd7d6f2722d98bdddb">BindTexturesDeferred_fastpath</a> (<a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a> stage, int first, int count, const <a class="el" href="group__nvn__cpp__handle.html#gafe744b035d9582a86872d256349c5e08">TextureHandle</a> *textures)</td></tr>
<tr class="memdesc:ae2a41e95f94942dd7d6f2722d98bdddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more Texture/Sampler pairs to use for texture mapping in shaders.  <a href="classnvn_1_1_command_buffer.html#ae2a41e95f94942dd7d6f2722d98bdddb">More...</a><br /></td></tr>
<tr class="separator:ae2a41e95f94942dd7d6f2722d98bdddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2ad7d6b0e29930b13d8590026a074c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a6d2ad7d6b0e29930b13d8590026a074c">BindTransformFeedbackBuffer</a> (int index, <a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> buffer, size_t size)</td></tr>
<tr class="memdesc:a6d2ad7d6b0e29930b13d8590026a074c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a range of a <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object to use for capturing transformed vertex data.  <a href="classnvn_1_1_command_buffer.html#a6d2ad7d6b0e29930b13d8590026a074c">More...</a><br /></td></tr>
<tr class="separator:a6d2ad7d6b0e29930b13d8590026a074c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9594fd76317f902d6c3dc6f74e71e8a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a9594fd76317f902d6c3dc6f74e71e8a4">BindTransformFeedbackBuffers</a> (int first, int count, NVN_NOESCAPE const <a class="el" href="structnvn_1_1_buffer_range.html">BufferRange</a> *buffers)</td></tr>
<tr class="memdesc:a9594fd76317f902d6c3dc6f74e71e8a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object ranges to use for capturing transformed vertex data.  <a href="classnvn_1_1_command_buffer.html#a9594fd76317f902d6c3dc6f74e71e8a4">More...</a><br /></td></tr>
<tr class="separator:a9594fd76317f902d6c3dc6f74e71e8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486ff1b4cd3e5dc02263c20e65e23081"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a486ff1b4cd3e5dc02263c20e65e23081">BindUniformBuffer</a> (<a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a> stage, int index, <a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> buffer, size_t size)</td></tr>
<tr class="memdesc:a486ff1b4cd3e5dc02263c20e65e23081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a range of a <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object to use for fetching shader uniform values.  <a href="classnvn_1_1_command_buffer.html#a486ff1b4cd3e5dc02263c20e65e23081">More...</a><br /></td></tr>
<tr class="separator:a486ff1b4cd3e5dc02263c20e65e23081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03dc7240d4b99bac5429e43f0f34e0f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a03dc7240d4b99bac5429e43f0f34e0f3">BindUniformBuffer_fastpath</a> (<a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a> stage, int index, <a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> buffer, size_t size)</td></tr>
<tr class="memdesc:a03dc7240d4b99bac5429e43f0f34e0f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a range of a <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object to use for fetching shader uniform values.  <a href="classnvn_1_1_command_buffer.html#a03dc7240d4b99bac5429e43f0f34e0f3">More...</a><br /></td></tr>
<tr class="separator:a03dc7240d4b99bac5429e43f0f34e0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9743dc0cc5c7fbf449053aca7cb562"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#aeb9743dc0cc5c7fbf449053aca7cb562">BindUniformBuffers</a> (<a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a> stage, int first, int count, NVN_NOESCAPE const <a class="el" href="structnvn_1_1_buffer_range.html">BufferRange</a> *buffers)</td></tr>
<tr class="memdesc:aeb9743dc0cc5c7fbf449053aca7cb562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object ranges to use for fetching shader uniform values.  <a href="classnvn_1_1_command_buffer.html#aeb9743dc0cc5c7fbf449053aca7cb562">More...</a><br /></td></tr>
<tr class="separator:aeb9743dc0cc5c7fbf449053aca7cb562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f301b7e9b087d8984d8a286f6c107d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a4f301b7e9b087d8984d8a286f6c107d1">BindUniformBuffers_fastpath</a> (<a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a> stage, int first, int count, NVN_NOESCAPE const <a class="el" href="structnvn_1_1_buffer_range.html">BufferRange</a> *buffers)</td></tr>
<tr class="memdesc:a4f301b7e9b087d8984d8a286f6c107d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object ranges to use for fetching shader uniform values.  <a href="classnvn_1_1_command_buffer.html#a4f301b7e9b087d8984d8a286f6c107d1">More...</a><br /></td></tr>
<tr class="separator:a4f301b7e9b087d8984d8a286f6c107d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d347b1239f9b48390e326adf270b91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a64d347b1239f9b48390e326adf270b91">BindUniformBuffersDeferred</a> (<a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a> stage, int first, int count, const <a class="el" href="structnvn_1_1_buffer_range.html">BufferRange</a> *buffers)</td></tr>
<tr class="memdesc:a64d347b1239f9b48390e326adf270b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object ranges to use for fetching shader uniform values.  <a href="classnvn_1_1_command_buffer.html#a64d347b1239f9b48390e326adf270b91">More...</a><br /></td></tr>
<tr class="separator:a64d347b1239f9b48390e326adf270b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542941c3d6ad7f3adf1438784e26ce61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a542941c3d6ad7f3adf1438784e26ce61">BindUniformBuffersDeferred_fastpath</a> (<a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a> stage, int first, int count, const <a class="el" href="structnvn_1_1_buffer_range.html">BufferRange</a> *buffers)</td></tr>
<tr class="memdesc:a542941c3d6ad7f3adf1438784e26ce61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object ranges to use for fetching shader uniform values.  <a href="classnvn_1_1_command_buffer.html#a542941c3d6ad7f3adf1438784e26ce61">More...</a><br /></td></tr>
<tr class="separator:a542941c3d6ad7f3adf1438784e26ce61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57223468c54a870cd07cee18752a1a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#aa57223468c54a870cd07cee18752a1a9">BindVertexAttribState</a> (int numAttribs, NVN_NOESCAPE const <a class="el" href="classnvn_1_1_vertex_attrib_state.html">VertexAttribState</a> *attribs)</td></tr>
<tr class="memdesc:aa57223468c54a870cd07cee18752a1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a vertex attribute layout for subsequent commands.  <a href="classnvn_1_1_command_buffer.html#aa57223468c54a870cd07cee18752a1a9">More...</a><br /></td></tr>
<tr class="separator:aa57223468c54a870cd07cee18752a1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5187aa77bf5509c1a02bae33ea3b17c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#ad5187aa77bf5509c1a02bae33ea3b17c">BindVertexBuffer</a> (int index, <a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> buffer, size_t size)</td></tr>
<tr class="memdesc:ad5187aa77bf5509c1a02bae33ea3b17c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a range of a <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object to use for fetching vertex attributes.  <a href="classnvn_1_1_command_buffer.html#ad5187aa77bf5509c1a02bae33ea3b17c">More...</a><br /></td></tr>
<tr class="separator:ad5187aa77bf5509c1a02bae33ea3b17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede2e0a0dfbbbf18dc19a3e3804e9a87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#aede2e0a0dfbbbf18dc19a3e3804e9a87">BindVertexBuffer_fastpath</a> (int index, <a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> buffer, size_t size)</td></tr>
<tr class="memdesc:aede2e0a0dfbbbf18dc19a3e3804e9a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a range of a <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object to use for fetching vertex attributes.  <a href="classnvn_1_1_command_buffer.html#aede2e0a0dfbbbf18dc19a3e3804e9a87">More...</a><br /></td></tr>
<tr class="separator:aede2e0a0dfbbbf18dc19a3e3804e9a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64dd97ba97b852b4b149a73451c8c70a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a64dd97ba97b852b4b149a73451c8c70a">BindVertexBuffers</a> (int first, int count, NVN_NOESCAPE const <a class="el" href="structnvn_1_1_buffer_range.html">BufferRange</a> *buffers)</td></tr>
<tr class="memdesc:a64dd97ba97b852b4b149a73451c8c70a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object ranges to use for fetching vertex attributes.  <a href="classnvn_1_1_command_buffer.html#a64dd97ba97b852b4b149a73451c8c70a">More...</a><br /></td></tr>
<tr class="separator:a64dd97ba97b852b4b149a73451c8c70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9165f6db2a89abe261119ef7775fec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#afe9165f6db2a89abe261119ef7775fec">BindVertexBuffers_fastpath</a> (int first, int count, NVN_NOESCAPE const <a class="el" href="structnvn_1_1_buffer_range.html">BufferRange</a> *buffers)</td></tr>
<tr class="memdesc:afe9165f6db2a89abe261119ef7775fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object ranges to use for fetching vertex attributes.  <a href="classnvn_1_1_command_buffer.html#afe9165f6db2a89abe261119ef7775fec">More...</a><br /></td></tr>
<tr class="separator:afe9165f6db2a89abe261119ef7775fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5c1896e8850f177606530b2599226f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a5c5c1896e8850f177606530b2599226f">BindVertexStreamState</a> (int numStreams, NVN_NOESCAPE const <a class="el" href="classnvn_1_1_vertex_stream_state.html">VertexStreamState</a> *streams)</td></tr>
<tr class="memdesc:a5c5c1896e8850f177606530b2599226f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a vertex stream layout for subsequent commands.  <a href="classnvn_1_1_command_buffer.html#a5c5c1896e8850f177606530b2599226f">More...</a><br /></td></tr>
<tr class="separator:a5c5c1896e8850f177606530b2599226f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26cc174e1b801e022cff2c5405726b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#ac26cc174e1b801e022cff2c5405726b0">CallCommands</a> (int numCommands, NVN_NOESCAPE const <a class="el" href="group__nvn__cpp__handle.html#ga48a6926aea0b934109f96ae32027b7fb">CommandHandle</a> *handles)</td></tr>
<tr class="memdesc:ac26cc174e1b801e022cff2c5405726b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert calls to previously recorded command sets into the command set under construction.  <a href="classnvn_1_1_command_buffer.html#ac26cc174e1b801e022cff2c5405726b0">More...</a><br /></td></tr>
<tr class="separator:ac26cc174e1b801e022cff2c5405726b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2792fadaef65c9a39fc28127fb64bf00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a2792fadaef65c9a39fc28127fb64bf00">CallCommands_fastpath</a> (int numCommands, NVN_NOESCAPE const <a class="el" href="group__nvn__cpp__handle.html#ga48a6926aea0b934109f96ae32027b7fb">CommandHandle</a> *handles)</td></tr>
<tr class="memdesc:a2792fadaef65c9a39fc28127fb64bf00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert calls to previously recorded command sets into the command set under construction.  <a href="classnvn_1_1_command_buffer.html#a2792fadaef65c9a39fc28127fb64bf00">More...</a><br /></td></tr>
<tr class="separator:a2792fadaef65c9a39fc28127fb64bf00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55c2ab50e7a8e474a12f55c640b0e8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#af55c2ab50e7a8e474a12f55c640b0e8c">ClearBuffer</a> (<a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> dst, size_t size, uint32_t value)</td></tr>
<tr class="memdesc:af55c2ab50e7a8e474a12f55c640b0e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a buffer to a 32-bit integer value.  <a href="classnvn_1_1_command_buffer.html#af55c2ab50e7a8e474a12f55c640b0e8c">More...</a><br /></td></tr>
<tr class="separator:af55c2ab50e7a8e474a12f55c640b0e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e04c4a4003648f60f65ce05ce8b61f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a61e04c4a4003648f60f65ce05ce8b61f">ClearColor</a> (int index, NVN_NOESCAPE const float *color, <a class="el" href="structnvn_1_1_clear_color_mask.html">ClearColorMask</a> mask)</td></tr>
<tr class="memdesc:a61e04c4a4003648f60f65ce05ce8b61f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a color buffer using floating-point clear color values.  <a href="classnvn_1_1_command_buffer.html#a61e04c4a4003648f60f65ce05ce8b61f">More...</a><br /></td></tr>
<tr class="separator:a61e04c4a4003648f60f65ce05ce8b61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2279d44a44fd246ef9f9392b8f9e8bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#ae2279d44a44fd246ef9f9392b8f9e8bf">ClearColori</a> (int index, NVN_NOESCAPE const int *color, <a class="el" href="structnvn_1_1_clear_color_mask.html">ClearColorMask</a> mask)</td></tr>
<tr class="memdesc:ae2279d44a44fd246ef9f9392b8f9e8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a color buffer using signed integer clear color values.  <a href="classnvn_1_1_command_buffer.html#ae2279d44a44fd246ef9f9392b8f9e8bf">More...</a><br /></td></tr>
<tr class="separator:ae2279d44a44fd246ef9f9392b8f9e8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b88ad85195c8749ebe41a3c4e9ee250"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a4b88ad85195c8749ebe41a3c4e9ee250">ClearColorui</a> (int index, NVN_NOESCAPE const uint32_t *color, <a class="el" href="structnvn_1_1_clear_color_mask.html">ClearColorMask</a> mask)</td></tr>
<tr class="memdesc:a4b88ad85195c8749ebe41a3c4e9ee250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a color buffer using unsigned integer clear color values.  <a href="classnvn_1_1_command_buffer.html#a4b88ad85195c8749ebe41a3c4e9ee250">More...</a><br /></td></tr>
<tr class="separator:a4b88ad85195c8749ebe41a3c4e9ee250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0f6d9771cdf2c4d2ec99fcbc366640"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a9a0f6d9771cdf2c4d2ec99fcbc366640">ClearDepthStencil</a> (float depthValue, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> depthMask, int stencilValue, int stencilMask)</td></tr>
<tr class="memdesc:a9a0f6d9771cdf2c4d2ec99fcbc366640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a depth/stencil buffer.  <a href="classnvn_1_1_command_buffer.html#a9a0f6d9771cdf2c4d2ec99fcbc366640">More...</a><br /></td></tr>
<tr class="separator:a9a0f6d9771cdf2c4d2ec99fcbc366640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba967469608c76841e41d2b4546f8bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#acba967469608c76841e41d2b4546f8bd">ClearTexture</a> (const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *dstTexture, NVN_NOESCAPE const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *dstView, NVN_NOESCAPE const <a class="el" href="structnvn_1_1_copy_region.html">CopyRegion</a> *dstRegion, NVN_NOESCAPE const float *color, <a class="el" href="structnvn_1_1_clear_color_mask.html">ClearColorMask</a> mask)</td></tr>
<tr class="memdesc:acba967469608c76841e41d2b4546f8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a color buffer using floating point clear color values.  <a href="classnvn_1_1_command_buffer.html#acba967469608c76841e41d2b4546f8bd">More...</a><br /></td></tr>
<tr class="separator:acba967469608c76841e41d2b4546f8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c37d217f9cdcc5dd083986aa785d17b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a7c37d217f9cdcc5dd083986aa785d17b">ClearTexturei</a> (const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *dstTexture, NVN_NOESCAPE const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *dstView, NVN_NOESCAPE const <a class="el" href="structnvn_1_1_copy_region.html">CopyRegion</a> *dstRegion, NVN_NOESCAPE const int *color, <a class="el" href="structnvn_1_1_clear_color_mask.html">ClearColorMask</a> mask)</td></tr>
<tr class="memdesc:a7c37d217f9cdcc5dd083986aa785d17b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a color buffer using signed integer clear color values.  <a href="classnvn_1_1_command_buffer.html#a7c37d217f9cdcc5dd083986aa785d17b">More...</a><br /></td></tr>
<tr class="separator:a7c37d217f9cdcc5dd083986aa785d17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4313e5838e0b2528870bb3437a18bf5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a4313e5838e0b2528870bb3437a18bf5d">ClearTextureui</a> (const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *dstTexture, NVN_NOESCAPE const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *dstView, NVN_NOESCAPE const <a class="el" href="structnvn_1_1_copy_region.html">CopyRegion</a> *dstRegion, NVN_NOESCAPE const uint32_t *color, <a class="el" href="structnvn_1_1_clear_color_mask.html">ClearColorMask</a> mask)</td></tr>
<tr class="memdesc:a4313e5838e0b2528870bb3437a18bf5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a color buffer using unsigned integer clear color values.  <a href="classnvn_1_1_command_buffer.html#a4313e5838e0b2528870bb3437a18bf5d">More...</a><br /></td></tr>
<tr class="separator:a4313e5838e0b2528870bb3437a18bf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6785390e813c50f1394d8f3e44de924"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#aa6785390e813c50f1394d8f3e44de924">CopyBufferToBuffer</a> (<a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> src, <a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> dst, size_t size, <a class="el" href="structnvn_1_1_copy_flags.html">CopyFlags</a> flags)</td></tr>
<tr class="memdesc:aa6785390e813c50f1394d8f3e44de924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a copy of data from one <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object into another <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object.  <a href="classnvn_1_1_command_buffer.html#aa6785390e813c50f1394d8f3e44de924">More...</a><br /></td></tr>
<tr class="separator:aa6785390e813c50f1394d8f3e44de924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3573269dfa045bfc0673173a8f55fb34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a3573269dfa045bfc0673173a8f55fb34">CopyBufferToTexture</a> (<a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> src, const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *dstTexture, NVN_NOESCAPE const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *dstView, NVN_NOESCAPE const <a class="el" href="structnvn_1_1_copy_region.html">CopyRegion</a> *dstRegion, <a class="el" href="structnvn_1_1_copy_flags.html">CopyFlags</a> flags)</td></tr>
<tr class="memdesc:a3573269dfa045bfc0673173a8f55fb34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy texture data from buffer memory into a region of a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> object.  <a href="classnvn_1_1_command_buffer.html#a3573269dfa045bfc0673173a8f55fb34">More...</a><br /></td></tr>
<tr class="separator:a3573269dfa045bfc0673173a8f55fb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1d30a924b48b7691a509f28783ae55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a5d1d30a924b48b7691a509f28783ae55">CopyCommands</a> (int numCommands, NVN_NOESCAPE const <a class="el" href="group__nvn__cpp__handle.html#ga48a6926aea0b934109f96ae32027b7fb">CommandHandle</a> *handles)</td></tr>
<tr class="memdesc:a5d1d30a924b48b7691a509f28783ae55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert copies of previously recorded command sets into the command set under construction.  <a href="classnvn_1_1_command_buffer.html#a5d1d30a924b48b7691a509f28783ae55">More...</a><br /></td></tr>
<tr class="separator:a5d1d30a924b48b7691a509f28783ae55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776e2215df7bf908253d82689ead67b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a776e2215df7bf908253d82689ead67b5">CopyTextureToBuffer</a> (const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *srcTexture, NVN_NOESCAPE const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *srcView, NVN_NOESCAPE const <a class="el" href="structnvn_1_1_copy_region.html">CopyRegion</a> *srcRegion, <a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> dst, <a class="el" href="structnvn_1_1_copy_flags.html">CopyFlags</a> flags)</td></tr>
<tr class="memdesc:a776e2215df7bf908253d82689ead67b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy texture data from a region of a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> object into buffer memory.  <a href="classnvn_1_1_command_buffer.html#a776e2215df7bf908253d82689ead67b5">More...</a><br /></td></tr>
<tr class="separator:a776e2215df7bf908253d82689ead67b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc27996fe951eb5f8f9c852c0dca88f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#acc27996fe951eb5f8f9c852c0dca88f7">CopyTextureToTexture</a> (const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *srcTexture, NVN_NOESCAPE const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *srcView, NVN_NOESCAPE const <a class="el" href="structnvn_1_1_copy_region.html">CopyRegion</a> *srcRegion, const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *dstTexture, NVN_NOESCAPE const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *dstView, NVN_NOESCAPE const <a class="el" href="structnvn_1_1_copy_region.html">CopyRegion</a> *dstRegion, <a class="el" href="structnvn_1_1_copy_flags.html">CopyFlags</a> flags)</td></tr>
<tr class="memdesc:acc27996fe951eb5f8f9c852c0dca88f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy texture data from a region of one <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> object into a region of another <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> object.  <a href="classnvn_1_1_command_buffer.html#acc27996fe951eb5f8f9c852c0dca88f7">More...</a><br /></td></tr>
<tr class="separator:acc27996fe951eb5f8f9c852c0dca88f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f6b826ef568486e1ec5875663bb980"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a51f6b826ef568486e1ec5875663bb980">DiscardColor</a> (int index)</td></tr>
<tr class="memdesc:a51f6b826ef568486e1ec5875663bb980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discard the contents of the specified bound color render target.  <a href="classnvn_1_1_command_buffer.html#a51f6b826ef568486e1ec5875663bb980">More...</a><br /></td></tr>
<tr class="separator:a51f6b826ef568486e1ec5875663bb980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c508e0b02295d5ac10849239c1499a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#ae8c508e0b02295d5ac10849239c1499a">DiscardDepthStencil</a> ()</td></tr>
<tr class="memdesc:ae8c508e0b02295d5ac10849239c1499a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discard the contents of the currently bound depth/stencil render target.  <a href="classnvn_1_1_command_buffer.html#ae8c508e0b02295d5ac10849239c1499a">More...</a><br /></td></tr>
<tr class="separator:ae8c508e0b02295d5ac10849239c1499a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbd3065ed66e5d9060d0b996a08f427"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a0bbd3065ed66e5d9060d0b996a08f427">DispatchCompute</a> (int groupsX, int groupsY, int groupsZ)</td></tr>
<tr class="memdesc:a0bbd3065ed66e5d9060d0b996a08f427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch a new grid of compute shader work groups for processing.  <a href="classnvn_1_1_command_buffer.html#a0bbd3065ed66e5d9060d0b996a08f427">More...</a><br /></td></tr>
<tr class="separator:a0bbd3065ed66e5d9060d0b996a08f427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007a24940c8df5f378f27832ef65424f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a007a24940c8df5f378f27832ef65424f">DispatchComputeIndirect</a> (<a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> indirectBuffer)</td></tr>
<tr class="memdesc:a007a24940c8df5f378f27832ef65424f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch a new grid of compute shader work groups for processing.  <a href="classnvn_1_1_command_buffer.html#a007a24940c8df5f378f27832ef65424f">More...</a><br /></td></tr>
<tr class="separator:a007a24940c8df5f378f27832ef65424f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f0fd0366d48cd3ba8f9c2cfea40e23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#af3f0fd0366d48cd3ba8f9c2cfea40e23">Downsample</a> (const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *src, const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *dst)</td></tr>
<tr class="memdesc:af3f0fd0366d48cd3ba8f9c2cfea40e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a filtered version of a multisample source texture to produce a single-sample destination texture.  <a href="classnvn_1_1_command_buffer.html#af3f0fd0366d48cd3ba8f9c2cfea40e23">More...</a><br /></td></tr>
<tr class="separator:af3f0fd0366d48cd3ba8f9c2cfea40e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad675ea33fa4fd4ce4815ed5db5c320a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#aad675ea33fa4fd4ce4815ed5db5c320a">DownsampleTextureView</a> (const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *src, NVN_NOESCAPE const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *srcView, const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *dst, NVN_NOESCAPE const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *dstView)</td></tr>
<tr class="memdesc:aad675ea33fa4fd4ce4815ed5db5c320a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a filtered version of a multisample source texture and texture view to produce a single-sample destination texture through a texture view.  <a href="classnvn_1_1_command_buffer.html#aad675ea33fa4fd4ce4815ed5db5c320a">More...</a><br /></td></tr>
<tr class="separator:aad675ea33fa4fd4ce4815ed5db5c320a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da364199d8c432151e8c18234ddde61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a9da364199d8c432151e8c18234ddde61">DrawArrays</a> (<a class="el" href="structnvn_1_1_draw_primitive.html">DrawPrimitive</a> mode, int first, int count)</td></tr>
<tr class="memdesc:a9da364199d8c432151e8c18234ddde61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render a primitive with consecutive vertex indices.  <a href="classnvn_1_1_command_buffer.html#a9da364199d8c432151e8c18234ddde61">More...</a><br /></td></tr>
<tr class="separator:a9da364199d8c432151e8c18234ddde61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae646d84699c45f2fbb8f19228d09c552"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#ae646d84699c45f2fbb8f19228d09c552">DrawArraysIndirect</a> (<a class="el" href="structnvn_1_1_draw_primitive.html">DrawPrimitive</a> mode, <a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> indirectBuffer)</td></tr>
<tr class="memdesc:ae646d84699c45f2fbb8f19228d09c552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render primitives with consecutive vertex indices, using draw parameters fetched from an indirect data buffer.  <a href="classnvn_1_1_command_buffer.html#ae646d84699c45f2fbb8f19228d09c552">More...</a><br /></td></tr>
<tr class="separator:ae646d84699c45f2fbb8f19228d09c552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1d89da478af0af62b725f3acb2a03d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#aff1d89da478af0af62b725f3acb2a03d">DrawArraysInstanced</a> (<a class="el" href="structnvn_1_1_draw_primitive.html">DrawPrimitive</a> mode, int first, int count, int baseInstance, int instanceCount)</td></tr>
<tr class="memdesc:aff1d89da478af0af62b725f3acb2a03d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render multiple copies (instances) of a primitive with consecutive vertex indices.  <a href="classnvn_1_1_command_buffer.html#aff1d89da478af0af62b725f3acb2a03d">More...</a><br /></td></tr>
<tr class="separator:aff1d89da478af0af62b725f3acb2a03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471babeb6b1971ba35fd006ecee180e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a471babeb6b1971ba35fd006ecee180e8">DrawElements</a> (<a class="el" href="structnvn_1_1_draw_primitive.html">DrawPrimitive</a> mode, <a class="el" href="structnvn_1_1_index_type.html">IndexType</a> type, int count, <a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> indexBuffer)</td></tr>
<tr class="memdesc:a471babeb6b1971ba35fd006ecee180e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render a primitive with vertex indices fetched from an index buffer.  <a href="classnvn_1_1_command_buffer.html#a471babeb6b1971ba35fd006ecee180e8">More...</a><br /></td></tr>
<tr class="separator:a471babeb6b1971ba35fd006ecee180e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bc25b22d24b6e68ed35ccc7fd860ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a14bc25b22d24b6e68ed35ccc7fd860ce">DrawElements_fastpath</a> (<a class="el" href="structnvn_1_1_draw_primitive.html">DrawPrimitive</a> mode, <a class="el" href="structnvn_1_1_index_type.html">IndexType</a> type, int count, <a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> indexBuffer)</td></tr>
<tr class="memdesc:a14bc25b22d24b6e68ed35ccc7fd860ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render a primitive with vertex indices fetched from an index buffer.  <a href="classnvn_1_1_command_buffer.html#a14bc25b22d24b6e68ed35ccc7fd860ce">More...</a><br /></td></tr>
<tr class="separator:a14bc25b22d24b6e68ed35ccc7fd860ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7e64dec4570204b5ef80c5776b9135"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a7a7e64dec4570204b5ef80c5776b9135">DrawElementsBaseVertex</a> (<a class="el" href="structnvn_1_1_draw_primitive.html">DrawPrimitive</a> mode, <a class="el" href="structnvn_1_1_index_type.html">IndexType</a> type, int count, <a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> indexBuffer, int baseVertex)</td></tr>
<tr class="memdesc:a7a7e64dec4570204b5ef80c5776b9135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render a primitive with vertex indices fetched from an index buffer, with a base vertex value added to each fetched index.  <a href="classnvn_1_1_command_buffer.html#a7a7e64dec4570204b5ef80c5776b9135">More...</a><br /></td></tr>
<tr class="separator:a7a7e64dec4570204b5ef80c5776b9135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01f121b63f5ad2e555acd587f7837bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#ae01f121b63f5ad2e555acd587f7837bf">DrawElementsIndirect</a> (<a class="el" href="structnvn_1_1_draw_primitive.html">DrawPrimitive</a> mode, <a class="el" href="structnvn_1_1_index_type.html">IndexType</a> type, <a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> indexBuffer, <a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> indirectBuffer)</td></tr>
<tr class="memdesc:ae01f121b63f5ad2e555acd587f7837bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render primitives with vertex indices fetched from an index buffer, using draw parameters fetched from an indirect data buffer.  <a href="classnvn_1_1_command_buffer.html#ae01f121b63f5ad2e555acd587f7837bf">More...</a><br /></td></tr>
<tr class="separator:ae01f121b63f5ad2e555acd587f7837bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad006e85876e24f910ca224279ef15e56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#ad006e85876e24f910ca224279ef15e56">DrawElementsInstanced</a> (<a class="el" href="structnvn_1_1_draw_primitive.html">DrawPrimitive</a> mode, <a class="el" href="structnvn_1_1_index_type.html">IndexType</a> type, int count, <a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> indexBuffer, int baseVertex, int baseInstance, int instanceCount)</td></tr>
<tr class="memdesc:ad006e85876e24f910ca224279ef15e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render multiple copies (instances) of a primitive with vertex indices fetched from an index buffer.  <a href="classnvn_1_1_command_buffer.html#ad006e85876e24f910ca224279ef15e56">More...</a><br /></td></tr>
<tr class="separator:ad006e85876e24f910ca224279ef15e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0ab209349d35ddaa3166571bc66039"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a4c0ab209349d35ddaa3166571bc66039">DrawTexture</a> (<a class="el" href="group__nvn__cpp__handle.html#gafe744b035d9582a86872d256349c5e08">TextureHandle</a> texture, NVN_NOESCAPE const <a class="el" href="structnvn_1_1_draw_texture_region.html">DrawTextureRegion</a> *dstRegion, NVN_NOESCAPE const <a class="el" href="structnvn_1_1_draw_texture_region.html">DrawTextureRegion</a> *srcRegion)</td></tr>
<tr class="memdesc:a4c0ab209349d35ddaa3166571bc66039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws an on-screen rectangle displaying the contents of a provided texture.  <a href="classnvn_1_1_command_buffer.html#a4c0ab209349d35ddaa3166571bc66039">More...</a><br /></td></tr>
<tr class="separator:a4c0ab209349d35ddaa3166571bc66039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab04f8a0370eb42f81c9d307016f7cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a9ab04f8a0370eb42f81c9d307016f7cb">DrawTransformFeedback</a> (<a class="el" href="structnvn_1_1_draw_primitive.html">DrawPrimitive</a> mode, <a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> buffer)</td></tr>
<tr class="memdesc:a9ab04f8a0370eb42f81c9d307016f7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw primitives captured in a previous transform feedback (stream output) operation.  <a href="classnvn_1_1_command_buffer.html#a9ab04f8a0370eb42f81c9d307016f7cb">More...</a><br /></td></tr>
<tr class="separator:a9ab04f8a0370eb42f81c9d307016f7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce9763420147218acf41e01380c84bf"><td class="memItemLeft" align="right" valign="top"><a id="a7ce9763420147218acf41e01380c84bf"></a>
<a class="el" href="group__nvn__cpp__handle.html#ga48a6926aea0b934109f96ae32027b7fb">CommandHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a7ce9763420147218acf41e01380c84bf">EndRecording</a> ()</td></tr>
<tr class="memdesc:a7ce9763420147218acf41e01380c84bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete recording a new set of commands in this <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a> object. <br /></td></tr>
<tr class="separator:a7ce9763420147218acf41e01380c84bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6086eb5893574fe192d08454c246972"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#ab6086eb5893574fe192d08454c246972">EndTransformFeedback</a> (<a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> buffer)</td></tr>
<tr class="memdesc:ab6086eb5893574fe192d08454c246972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete a transform feedback (stream output) operation.  <a href="classnvn_1_1_command_buffer.html#ab6086eb5893574fe192d08454c246972">More...</a><br /></td></tr>
<tr class="separator:ab6086eb5893574fe192d08454c246972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0a2ade0434ed01f886cd52aeac1a23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#adc0a2ade0434ed01f886cd52aeac1a23">FenceSync</a> (<a class="el" href="classnvn_1_1_sync.html">Sync</a> *sync, <a class="el" href="structnvn_1_1_sync_condition.html">SyncCondition</a> condition, <a class="el" href="structnvn_1_1_sync_flag_bits.html">SyncFlagBits</a> flags)</td></tr>
<tr class="memdesc:adc0a2ade0434ed01f886cd52aeac1a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a <a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress.">Sync</a> object as signaled when all previous commands have completed in the <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a> object.  <a href="classnvn_1_1_command_buffer.html#adc0a2ade0434ed01f886cd52aeac1a23">More...</a><br /></td></tr>
<tr class="separator:adc0a2ade0434ed01f886cd52aeac1a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f051d9b59715ee1d64f025bf4f30f1"><td class="memItemLeft" align="right" valign="top"><a id="aa1f051d9b59715ee1d64f025bf4f30f1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#aa1f051d9b59715ee1d64f025bf4f30f1">Finalize</a> ()</td></tr>
<tr class="memdesc:aa1f051d9b59715ee1d64f025bf4f30f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a> object. <br /></td></tr>
<tr class="separator:aa1f051d9b59715ee1d64f025bf4f30f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac49f0ab25fa651a0f4913a1b962c34f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#aac49f0ab25fa651a0f4913a1b962c34f">GetCommandMemoryFree</a> () const</td></tr>
<tr class="memdesc:aac49f0ab25fa651a0f4913a1b962c34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unused size in bytes of the command memory block that was lastly added to the <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a>.  <a href="classnvn_1_1_command_buffer.html#aac49f0ab25fa651a0f4913a1b962c34f">More...</a><br /></td></tr>
<tr class="separator:aac49f0ab25fa651a0f4913a1b962c34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29294f5d9eb53ec74c59e2ed6df4afd9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a29294f5d9eb53ec74c59e2ed6df4afd9">GetCommandMemorySize</a> () const</td></tr>
<tr class="memdesc:a29294f5d9eb53ec74c59e2ed6df4afd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total size in bytes of the command memory block that was lastly added to the <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a>.  <a href="classnvn_1_1_command_buffer.html#a29294f5d9eb53ec74c59e2ed6df4afd9">More...</a><br /></td></tr>
<tr class="separator:a29294f5d9eb53ec74c59e2ed6df4afd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a4a7e4e8a7da91a1627d836548f788"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a93a4a7e4e8a7da91a1627d836548f788">GetCommandMemoryUsed</a> () const</td></tr>
<tr class="memdesc:a93a4a7e4e8a7da91a1627d836548f788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the used size in bytes of the command memory block that was lastly added to the <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a>.  <a href="classnvn_1_1_command_buffer.html#a93a4a7e4e8a7da91a1627d836548f788">More...</a><br /></td></tr>
<tr class="separator:a93a4a7e4e8a7da91a1627d836548f788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c494a15150ea651feb87e44aeb0f67"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#ad6c494a15150ea651feb87e44aeb0f67">GetControlMemoryFree</a> () const</td></tr>
<tr class="memdesc:ad6c494a15150ea651feb87e44aeb0f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unused size in bytes of the control memory block that was lastly added to the <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a>.  <a href="classnvn_1_1_command_buffer.html#ad6c494a15150ea651feb87e44aeb0f67">More...</a><br /></td></tr>
<tr class="separator:ad6c494a15150ea651feb87e44aeb0f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c8fa0255e9e0845c46e7d5162de17c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a19c8fa0255e9e0845c46e7d5162de17c">GetControlMemorySize</a> () const</td></tr>
<tr class="memdesc:a19c8fa0255e9e0845c46e7d5162de17c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total size in bytes of the control memory block that was lastly added to the <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a>.  <a href="classnvn_1_1_command_buffer.html#a19c8fa0255e9e0845c46e7d5162de17c">More...</a><br /></td></tr>
<tr class="separator:a19c8fa0255e9e0845c46e7d5162de17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec66e4ec6d42caca35de9f3fcfbf638"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#abec66e4ec6d42caca35de9f3fcfbf638">GetControlMemoryUsed</a> () const</td></tr>
<tr class="memdesc:abec66e4ec6d42caca35de9f3fcfbf638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the used size in bytes of the control memory block that was lastly added to the <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a>.  <a href="classnvn_1_1_command_buffer.html#abec66e4ec6d42caca35de9f3fcfbf638">More...</a><br /></td></tr>
<tr class="separator:abec66e4ec6d42caca35de9f3fcfbf638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f8f5b97048424ce3e7fa5de6e53830"><td class="memItemLeft" align="right" valign="top"><a id="a73f8f5b97048424ce3e7fa5de6e53830"></a>
ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a73f8f5b97048424ce3e7fa5de6e53830">GetCopyImageStride</a> () const</td></tr>
<tr class="memdesc:a73f8f5b97048424ce3e7fa5de6e53830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current copy image stride stored in a <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a> object. <br /></td></tr>
<tr class="separator:a73f8f5b97048424ce3e7fa5de6e53830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf14069b32a9075946a691920a8ddef"><td class="memItemLeft" align="right" valign="top"><a id="a8bf14069b32a9075946a691920a8ddef"></a>
ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a8bf14069b32a9075946a691920a8ddef">GetCopyRowStride</a> () const</td></tr>
<tr class="memdesc:a8bf14069b32a9075946a691920a8ddef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current copy row stride stored in a <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a> object. <br /></td></tr>
<tr class="separator:a8bf14069b32a9075946a691920a8ddef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e452642e76b5f9a2c95d41220092f5a"><td class="memItemLeft" align="right" valign="top"><a id="a6e452642e76b5f9a2c95d41220092f5a"></a>
<a class="el" href="group__nvn__cpp__funcptrs.html#ga6b2c74544158547abb83cc4753f3a5cf">CommandBufferMemoryCallbackFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a6e452642e76b5f9a2c95d41220092f5a">GetMemoryCallback</a> () const</td></tr>
<tr class="memdesc:a6e452642e76b5f9a2c95d41220092f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query a callback function for a <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a> object that will be called if it runs out of memory. <br /></td></tr>
<tr class="separator:a6e452642e76b5f9a2c95d41220092f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb6d1ec9f5b4d7c3e935c9781724a10"><td class="memItemLeft" align="right" valign="top"><a id="aceb6d1ec9f5b4d7c3e935c9781724a10"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#aceb6d1ec9f5b4d7c3e935c9781724a10">GetMemoryCallbackData</a> () const</td></tr>
<tr class="memdesc:aceb6d1ec9f5b4d7c3e935c9781724a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query a generic pointer that will be passed to a callback function if the command buffer runs out of memory. <br /></td></tr>
<tr class="separator:aceb6d1ec9f5b4d7c3e935c9781724a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab065aa237a8b8c7c96d1f7eef1cdfae4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#ab065aa237a8b8c7c96d1f7eef1cdfae4">Initialize</a> (<a class="el" href="classnvn_1_1_device.html">Device</a> *device)</td></tr>
<tr class="memdesc:ab065aa237a8b8c7c96d1f7eef1cdfae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a> object for the specified device.  <a href="classnvn_1_1_command_buffer.html#ab065aa237a8b8c7c96d1f7eef1cdfae4">More...</a><br /></td></tr>
<tr class="separator:ab065aa237a8b8c7c96d1f7eef1cdfae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1dcfd6c8ea0149c2d399f37b405584e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#ae1dcfd6c8ea0149c2d399f37b405584e">InsertCheckpointDynamic</a> (NVN_NOESCAPE const void *markerData, size_t markerDataSize)</td></tr>
<tr class="memdesc:ae1dcfd6c8ea0149c2d399f37b405584e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a checkpoint event marker to the command set.  <a href="classnvn_1_1_command_buffer.html#ae1dcfd6c8ea0149c2d399f37b405584e">More...</a><br /></td></tr>
<tr class="separator:ae1dcfd6c8ea0149c2d399f37b405584e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac563deb3fad19e40cc044ead3405da66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#ac563deb3fad19e40cc044ead3405da66">InsertCheckpointStatic</a> (const void *markerData, size_t markerDataSize)</td></tr>
<tr class="memdesc:ac563deb3fad19e40cc044ead3405da66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a checkpoint event marker to the command set.  <a href="classnvn_1_1_command_buffer.html#ac563deb3fad19e40cc044ead3405da66">More...</a><br /></td></tr>
<tr class="separator:ac563deb3fad19e40cc044ead3405da66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0136544d13e04ed57e24ef1571efc4d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a0136544d13e04ed57e24ef1571efc4d4">InsertDebugMarker</a> (const char *description)</td></tr>
<tr class="memdesc:a0136544d13e04ed57e24ef1571efc4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a debug event marker to the command stream.  <a href="classnvn_1_1_command_buffer.html#a0136544d13e04ed57e24ef1571efc4d4">More...</a><br /></td></tr>
<tr class="separator:a0136544d13e04ed57e24ef1571efc4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20918b52737d705120dd9ae045438783"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a20918b52737d705120dd9ae045438783">InsertDebugMarkerDynamic</a> (uint32_t domainId, NVN_NOESCAPE const char *description)</td></tr>
<tr class="memdesc:a20918b52737d705120dd9ae045438783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a debug event marker to the command stream.  <a href="classnvn_1_1_command_buffer.html#a20918b52737d705120dd9ae045438783">More...</a><br /></td></tr>
<tr class="separator:a20918b52737d705120dd9ae045438783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f79eabcd9a1d050d35c7dbed083063"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#ae5f79eabcd9a1d050d35c7dbed083063">InsertDebugMarkerStatic</a> (uint32_t domainId, const char *description)</td></tr>
<tr class="memdesc:ae5f79eabcd9a1d050d35c7dbed083063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a debug event marker to the command stream.  <a href="classnvn_1_1_command_buffer.html#ae5f79eabcd9a1d050d35c7dbed083063">More...</a><br /></td></tr>
<tr class="separator:ae5f79eabcd9a1d050d35c7dbed083063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc63cb352e55cb62e5accc5983d9d1a"><td class="memItemLeft" align="right" valign="top"><a id="a3fc63cb352e55cb62e5accc5983d9d1a"></a>
<a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a3fc63cb352e55cb62e5accc5983d9d1a">IsRecording</a> () const</td></tr>
<tr class="memdesc:a3fc63cb352e55cb62e5accc5983d9d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the command buffer is currently recording. <br /></td></tr>
<tr class="separator:a3fc63cb352e55cb62e5accc5983d9d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb65434a9927e837c8824130ea71de1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a8bb65434a9927e837c8824130ea71de1">MultiDrawArraysIndirectCount</a> (<a class="el" href="structnvn_1_1_draw_primitive.html">DrawPrimitive</a> mode, <a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> indirectBuffer, <a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> parameterBuffer, int maxDrawCount, ptrdiff_t stride)</td></tr>
<tr class="memdesc:a8bb65434a9927e837c8824130ea71de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render multiple primitives with vertices fetched from a vertex buffer, using draw parameters fetched from an indirect data buffer and the number of primitives fetched from a parameter buffer.  <a href="classnvn_1_1_command_buffer.html#a8bb65434a9927e837c8824130ea71de1">More...</a><br /></td></tr>
<tr class="separator:a8bb65434a9927e837c8824130ea71de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8572e7834fcaff511baf47464075f172"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a8572e7834fcaff511baf47464075f172">MultiDrawElementsIndirectCount</a> (<a class="el" href="structnvn_1_1_draw_primitive.html">DrawPrimitive</a> mode, <a class="el" href="structnvn_1_1_index_type.html">IndexType</a> type, <a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> indexBuffer, <a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> indirectBuffer, <a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> parameterBuffer, int maxDrawCount, ptrdiff_t stride)</td></tr>
<tr class="memdesc:a8572e7834fcaff511baf47464075f172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render multiple primitives with vertex indices fetched from an index buffer, using draw parameters fetched from an indirect data buffer and the number of primitives fetched from a parameter buffer.  <a href="classnvn_1_1_command_buffer.html#a8572e7834fcaff511baf47464075f172">More...</a><br /></td></tr>
<tr class="separator:a8572e7834fcaff511baf47464075f172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26124ee79d34155d0bb4c18bf6c60ce1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a26124ee79d34155d0bb4c18bf6c60ce1">OverrideSubtileSize</a> (<a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> override, int subtileSize)</td></tr>
<tr class="memdesc:a26124ee79d34155d0bb4c18bf6c60ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override the default number of fragment shader warps in a single subtile.  <a href="classnvn_1_1_command_buffer.html#a26124ee79d34155d0bb4c18bf6c60ce1">More...</a><br /></td></tr>
<tr class="separator:a26124ee79d34155d0bb4c18bf6c60ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2263122bab5991d4a99212493657b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#acf2263122bab5991d4a99212493657b7">PauseTransformFeedback</a> (<a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> buffer)</td></tr>
<tr class="memdesc:acf2263122bab5991d4a99212493657b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause a transform feedback (stream output) operation.  <a href="classnvn_1_1_command_buffer.html#acf2263122bab5991d4a99212493657b7">More...</a><br /></td></tr>
<tr class="separator:acf2263122bab5991d4a99212493657b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c191488de5f8de314d57431bc2ac98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#aa7c191488de5f8de314d57431bc2ac98">PopDebugGroup</a> ()</td></tr>
<tr class="memdesc:aa7c191488de5f8de314d57431bc2ac98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops the active debug group off the command stream.  <a href="classnvn_1_1_command_buffer.html#aa7c191488de5f8de314d57431bc2ac98">More...</a><br /></td></tr>
<tr class="separator:aa7c191488de5f8de314d57431bc2ac98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254c728bee850ebdb48b18b128165552"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a254c728bee850ebdb48b18b128165552">PopDebugGroupId</a> (uint32_t domainId)</td></tr>
<tr class="memdesc:a254c728bee850ebdb48b18b128165552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops the active debug group off the command stream.  <a href="classnvn_1_1_command_buffer.html#a254c728bee850ebdb48b18b128165552">More...</a><br /></td></tr>
<tr class="separator:a254c728bee850ebdb48b18b128165552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8acf5fdb35b068637c19659fde37b92c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a8acf5fdb35b068637c19659fde37b92c">PushDebugGroup</a> (const char *description)</td></tr>
<tr class="memdesc:a8acf5fdb35b068637c19659fde37b92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a debug group into the command stream.  <a href="classnvn_1_1_command_buffer.html#a8acf5fdb35b068637c19659fde37b92c">More...</a><br /></td></tr>
<tr class="separator:a8acf5fdb35b068637c19659fde37b92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37661d498010fdd4a2864b3431a125bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a37661d498010fdd4a2864b3431a125bf">PushDebugGroupDynamic</a> (uint32_t domainId, NVN_NOESCAPE const char *description)</td></tr>
<tr class="memdesc:a37661d498010fdd4a2864b3431a125bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a debug group into the command stream.  <a href="classnvn_1_1_command_buffer.html#a37661d498010fdd4a2864b3431a125bf">More...</a><br /></td></tr>
<tr class="separator:a37661d498010fdd4a2864b3431a125bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca414869c25fb9412a0154b2eaa161a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a1ca414869c25fb9412a0154b2eaa161a">PushDebugGroupStatic</a> (uint32_t domainId, const char *description)</td></tr>
<tr class="memdesc:a1ca414869c25fb9412a0154b2eaa161a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a debug group into the command stream.  <a href="classnvn_1_1_command_buffer.html#a1ca414869c25fb9412a0154b2eaa161a">More...</a><br /></td></tr>
<tr class="separator:a1ca414869c25fb9412a0154b2eaa161a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e3b104004b6188f83dfaa755a50936"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a97e3b104004b6188f83dfaa755a50936">ReportCounter</a> (<a class="el" href="structnvn_1_1_counter_type.html">CounterType</a> counter, <a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> buffer)</td></tr>
<tr class="memdesc:a97e3b104004b6188f83dfaa755a50936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a GPU counter and timestamp into buffer object memory.  <a href="classnvn_1_1_command_buffer.html#a97e3b104004b6188f83dfaa755a50936">More...</a><br /></td></tr>
<tr class="separator:a97e3b104004b6188f83dfaa755a50936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc42b659aad608e9e4a976aeb083c7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a0dc42b659aad608e9e4a976aeb083c7d">ReportValue</a> (uint32_t value, <a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> buffer)</td></tr>
<tr class="memdesc:a0dc42b659aad608e9e4a976aeb083c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a GPU counter report and timestamp into buffer object memory using an application-provided value.  <a href="classnvn_1_1_command_buffer.html#a0dc42b659aad608e9e4a976aeb083c7d">More...</a><br /></td></tr>
<tr class="separator:a0dc42b659aad608e9e4a976aeb083c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d15a39c7a1f8391aef376768a37d02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a64d15a39c7a1f8391aef376768a37d02">ResetCounter</a> (<a class="el" href="structnvn_1_1_counter_type.html">CounterType</a> counter)</td></tr>
<tr class="memdesc:a64d15a39c7a1f8391aef376768a37d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset a GPU counter to zero.  <a href="classnvn_1_1_command_buffer.html#a64d15a39c7a1f8391aef376768a37d02">More...</a><br /></td></tr>
<tr class="separator:a64d15a39c7a1f8391aef376768a37d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac239d2cc3ff8bc71004e3eeccac58e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a0ac239d2cc3ff8bc71004e3eeccac58e">ResolveDepthBuffer</a> ()</td></tr>
<tr class="memdesc:a0ac239d2cc3ff8bc71004e3eeccac58e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve depth values in a compressible depth render target.  <a href="classnvn_1_1_command_buffer.html#a0ac239d2cc3ff8bc71004e3eeccac58e">More...</a><br /></td></tr>
<tr class="separator:a0ac239d2cc3ff8bc71004e3eeccac58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2cecb42e2c89078f75da69200e5ada"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#aac2cecb42e2c89078f75da69200e5ada">RestoreZCullData</a> (<a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> src, size_t size)</td></tr>
<tr class="memdesc:aac2cecb42e2c89078f75da69200e5ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the current ZCull state to use saved state from a previous render target.  <a href="classnvn_1_1_command_buffer.html#aac2cecb42e2c89078f75da69200e5ada">More...</a><br /></td></tr>
<tr class="separator:aac2cecb42e2c89078f75da69200e5ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69b628752585094f50ff22cbba8ab69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#ae69b628752585094f50ff22cbba8ab69">ResumeTransformFeedback</a> (<a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> buffer)</td></tr>
<tr class="memdesc:ae69b628752585094f50ff22cbba8ab69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume a transform feedback (stream output) operation.  <a href="classnvn_1_1_command_buffer.html#ae69b628752585094f50ff22cbba8ab69">More...</a><br /></td></tr>
<tr class="separator:ae69b628752585094f50ff22cbba8ab69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8dd92449da43b69fe613e94cd67ade"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a9e8dd92449da43b69fe613e94cd67ade">SaveZCullData</a> (<a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> dst, size_t size)</td></tr>
<tr class="memdesc:a9e8dd92449da43b69fe613e94cd67ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the current ZCull state for the current depth render target.  <a href="classnvn_1_1_command_buffer.html#a9e8dd92449da43b69fe613e94cd67ade">More...</a><br /></td></tr>
<tr class="separator:a9e8dd92449da43b69fe613e94cd67ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7edd6a2e5bceb5db2ab83cbc9724221e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a7edd6a2e5bceb5db2ab83cbc9724221e">SetAlphaRef</a> (float ref)</td></tr>
<tr class="memdesc:a7edd6a2e5bceb5db2ab83cbc9724221e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a reference value to use for alpha testing.  <a href="classnvn_1_1_command_buffer.html#a7edd6a2e5bceb5db2ab83cbc9724221e">More...</a><br /></td></tr>
<tr class="separator:a7edd6a2e5bceb5db2ab83cbc9724221e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a986e1674a5b2182666efb95538c89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a89a986e1674a5b2182666efb95538c89">SetBlendColor</a> (NVN_NOESCAPE const float *blendColor)</td></tr>
<tr class="memdesc:a89a986e1674a5b2182666efb95538c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a constant color that may be used by blending functions.  <a href="classnvn_1_1_command_buffer.html#a89a986e1674a5b2182666efb95538c89">More...</a><br /></td></tr>
<tr class="separator:a89a986e1674a5b2182666efb95538c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e75447a4581e7722183ecd0a96e79d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#ad3e75447a4581e7722183ecd0a96e79d">SetColorReductionEnable</a> (<a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable)</td></tr>
<tr class="memdesc:ad3e75447a4581e7722183ecd0a96e79d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable lossy color reduction.  <a href="classnvn_1_1_command_buffer.html#ad3e75447a4581e7722183ecd0a96e79d">More...</a><br /></td></tr>
<tr class="separator:ad3e75447a4581e7722183ecd0a96e79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372c68297e7725dd87f78278078c7755"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a372c68297e7725dd87f78278078c7755">SetColorReductionThresholds</a> (<a class="el" href="structnvn_1_1_format_class.html">FormatClass</a> formatClass, int thresholdConservative, int thresholdAggressive)</td></tr>
<tr class="memdesc:a372c68297e7725dd87f78278078c7755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify new lossy color reduction thresholds for a format class.  <a href="classnvn_1_1_command_buffer.html#a372c68297e7725dd87f78278078c7755">More...</a><br /></td></tr>
<tr class="separator:a372c68297e7725dd87f78278078c7755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6f7480a9f868cffe1d348b8f076dc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#aec6f7480a9f868cffe1d348b8f076dc9">SetCommandMemoryCallbackEnabled</a> (<a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enabled)</td></tr>
<tr class="memdesc:aec6f7480a9f868cffe1d348b8f076dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the memory callback when out of command memory.  <a href="classnvn_1_1_command_buffer.html#aec6f7480a9f868cffe1d348b8f076dc9">More...</a><br /></td></tr>
<tr class="separator:aec6f7480a9f868cffe1d348b8f076dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608a08a70a0908e53cad3b7a62dd6a13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a608a08a70a0908e53cad3b7a62dd6a13">SetCommandMemoryCallbackEnabled_fastpath</a> (<a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enabled)</td></tr>
<tr class="memdesc:a608a08a70a0908e53cad3b7a62dd6a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the memory callback when out of command memory.  <a href="classnvn_1_1_command_buffer.html#a608a08a70a0908e53cad3b7a62dd6a13">More...</a><br /></td></tr>
<tr class="separator:a608a08a70a0908e53cad3b7a62dd6a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c86df94525318a4cb2116b4f9194c03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a7c86df94525318a4cb2116b4f9194c03">SetConservativeRasterDilate</a> (float dilate)</td></tr>
<tr class="memdesc:a7c86df94525318a4cb2116b4f9194c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the degree of primitive dilation when conservative rasterization is enabled.  <a href="classnvn_1_1_command_buffer.html#a7c86df94525318a4cb2116b4f9194c03">More...</a><br /></td></tr>
<tr class="separator:a7c86df94525318a4cb2116b4f9194c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91972f2ddf79b233d4abf26838c82f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#aa91972f2ddf79b233d4abf26838c82f5">SetConservativeRasterEnable</a> (<a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable)</td></tr>
<tr class="memdesc:aa91972f2ddf79b233d4abf26838c82f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable conservative rasterization of rendered primitives.  <a href="classnvn_1_1_command_buffer.html#aa91972f2ddf79b233d4abf26838c82f5">More...</a><br /></td></tr>
<tr class="separator:aa91972f2ddf79b233d4abf26838c82f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed848d8f9360fa17c44e9570a6d8bc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a9ed848d8f9360fa17c44e9570a6d8bc4">SetCopyImageStride</a> (ptrdiff_t stride)</td></tr>
<tr class="memdesc:a9ed848d8f9360fa17c44e9570a6d8bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the image stride used for copies between buffer and texture memory.  <a href="classnvn_1_1_command_buffer.html#a9ed848d8f9360fa17c44e9570a6d8bc4">More...</a><br /></td></tr>
<tr class="separator:a9ed848d8f9360fa17c44e9570a6d8bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0207cc2151b50b8b0fd1957612482e67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a0207cc2151b50b8b0fd1957612482e67">SetCopyRowStride</a> (ptrdiff_t stride)</td></tr>
<tr class="memdesc:a0207cc2151b50b8b0fd1957612482e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the row stride used for copies between buffer and texture memory.  <a href="classnvn_1_1_command_buffer.html#a0207cc2151b50b8b0fd1957612482e67">More...</a><br /></td></tr>
<tr class="separator:a0207cc2151b50b8b0fd1957612482e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d715b1c09063d8b3820d4d3f63e719f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a8d715b1c09063d8b3820d4d3f63e719f">SetDebugLabel</a> (const char *label)</td></tr>
<tr class="memdesc:a8d715b1c09063d8b3820d4d3f63e719f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug label string for a <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a> object.  <a href="classnvn_1_1_command_buffer.html#a8d715b1c09063d8b3820d4d3f63e719f">More...</a><br /></td></tr>
<tr class="separator:a8d715b1c09063d8b3820d4d3f63e719f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89b302622bedfbe4d1efe8f6c070f5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#ac89b302622bedfbe4d1efe8f6c070f5a">SetDepthBounds</a> (<a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable, float n, float f)</td></tr>
<tr class="memdesc:ac89b302622bedfbe4d1efe8f6c070f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control the operation of the depth bounds test.  <a href="classnvn_1_1_command_buffer.html#ac89b302622bedfbe4d1efe8f6c070f5a">More...</a><br /></td></tr>
<tr class="separator:ac89b302622bedfbe4d1efe8f6c070f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1198f8f3d6d2a20bf4e2b254c679f523"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a1198f8f3d6d2a20bf4e2b254c679f523">SetDepthClamp</a> (<a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> clamp)</td></tr>
<tr class="memdesc:a1198f8f3d6d2a20bf4e2b254c679f523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable depth clamping of rendered primitives.  <a href="classnvn_1_1_command_buffer.html#a1198f8f3d6d2a20bf4e2b254c679f523">More...</a><br /></td></tr>
<tr class="separator:a1198f8f3d6d2a20bf4e2b254c679f523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8271958565ab72d7a3dc216a5bcf13c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a8271958565ab72d7a3dc216a5bcf13c7">SetDepthRange</a> (float n, float f)</td></tr>
<tr class="memdesc:a8271958565ab72d7a3dc216a5bcf13c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the range of depth values for rendered primitives.  <a href="classnvn_1_1_command_buffer.html#a8271958565ab72d7a3dc216a5bcf13c7">More...</a><br /></td></tr>
<tr class="separator:a8271958565ab72d7a3dc216a5bcf13c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e4979f26c85f912363be9b5f1ab121"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a64e4979f26c85f912363be9b5f1ab121">SetDepthRanges</a> (int first, int count, NVN_NOESCAPE const float *ranges)</td></tr>
<tr class="memdesc:a64e4979f26c85f912363be9b5f1ab121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets multiple ranges of depth values for rendered primitives.  <a href="classnvn_1_1_command_buffer.html#a64e4979f26c85f912363be9b5f1ab121">More...</a><br /></td></tr>
<tr class="separator:a64e4979f26c85f912363be9b5f1ab121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4491406f044f024bcca908a1a6f9b27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#ae4491406f044f024bcca908a1a6f9b27">SetInnerTessellationLevels</a> (NVN_NOESCAPE const float *levels)</td></tr>
<tr class="memdesc:ae4491406f044f024bcca908a1a6f9b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify default inner tessellation levels when rendering patch primitives.  <a href="classnvn_1_1_command_buffer.html#ae4491406f044f024bcca908a1a6f9b27">More...</a><br /></td></tr>
<tr class="separator:ae4491406f044f024bcca908a1a6f9b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f74340d8bd83898f7dda56cc0461e51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a0f74340d8bd83898f7dda56cc0461e51">SetLineWidth</a> (float lineWidth)</td></tr>
<tr class="memdesc:a0f74340d8bd83898f7dda56cc0461e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the width (in pixels) of line primitives to render.  <a href="classnvn_1_1_command_buffer.html#a0f74340d8bd83898f7dda56cc0461e51">More...</a><br /></td></tr>
<tr class="separator:a0f74340d8bd83898f7dda56cc0461e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aab9ff6d4872bd1bc75feb264dc5734"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a0aab9ff6d4872bd1bc75feb264dc5734">SetMemoryCallback</a> (<a class="el" href="group__nvn__cpp__funcptrs.html#ga6b2c74544158547abb83cc4753f3a5cf">CommandBufferMemoryCallbackFunc</a> callback)</td></tr>
<tr class="memdesc:a0aab9ff6d4872bd1bc75feb264dc5734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a callback function for a <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a> object that will be called if it runs out of memory.  <a href="classnvn_1_1_command_buffer.html#a0aab9ff6d4872bd1bc75feb264dc5734">More...</a><br /></td></tr>
<tr class="separator:a0aab9ff6d4872bd1bc75feb264dc5734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89bf59fb5a193439c2289387f33fb196"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a89bf59fb5a193439c2289387f33fb196">SetMemoryCallbackData</a> (void *callbackData)</td></tr>
<tr class="memdesc:a89bf59fb5a193439c2289387f33fb196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a generic pointer that will be passed to a callback function if the command buffer runs out of memory.  <a href="classnvn_1_1_command_buffer.html#a89bf59fb5a193439c2289387f33fb196">More...</a><br /></td></tr>
<tr class="separator:a89bf59fb5a193439c2289387f33fb196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953c968a32947a0bfd7cf38ccf89d925"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a953c968a32947a0bfd7cf38ccf89d925">SetOuterTessellationLevels</a> (NVN_NOESCAPE const float *levels)</td></tr>
<tr class="memdesc:a953c968a32947a0bfd7cf38ccf89d925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify default outer tessellation levels when rendering patch primitives.  <a href="classnvn_1_1_command_buffer.html#a953c968a32947a0bfd7cf38ccf89d925">More...</a><br /></td></tr>
<tr class="separator:a953c968a32947a0bfd7cf38ccf89d925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580ce64d255d8aa9a7f0bfbda34ae995"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a580ce64d255d8aa9a7f0bfbda34ae995">SetPatchSize</a> (int size)</td></tr>
<tr class="memdesc:a580ce64d255d8aa9a7f0bfbda34ae995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the number of vertices in each patch when rendering patch primitives.  <a href="classnvn_1_1_command_buffer.html#a580ce64d255d8aa9a7f0bfbda34ae995">More...</a><br /></td></tr>
<tr class="separator:a580ce64d255d8aa9a7f0bfbda34ae995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dca4b84f62fb292de2ec41305209c55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a5dca4b84f62fb292de2ec41305209c55">SetPointSize</a> (float pointSize)</td></tr>
<tr class="memdesc:a5dca4b84f62fb292de2ec41305209c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the size (in pixels) of point primitives to render.  <a href="classnvn_1_1_command_buffer.html#a5dca4b84f62fb292de2ec41305209c55">More...</a><br /></td></tr>
<tr class="separator:a5dca4b84f62fb292de2ec41305209c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720e42e18e9818a05cc73ed7fa04a748"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a720e42e18e9818a05cc73ed7fa04a748">SetPolygonOffsetClamp</a> (float factor, float units, float clamp)</td></tr>
<tr class="memdesc:a720e42e18e9818a05cc73ed7fa04a748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies values used to compute a depth offset value when polygon offset is enabled.  <a href="classnvn_1_1_command_buffer.html#a720e42e18e9818a05cc73ed7fa04a748">More...</a><br /></td></tr>
<tr class="separator:a720e42e18e9818a05cc73ed7fa04a748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81df57774190f2c44f29ff3da16f996e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a81df57774190f2c44f29ff3da16f996e">SetPrimitiveRestart</a> (<a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable, int index)</td></tr>
<tr class="memdesc:a81df57774190f2c44f29ff3da16f996e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable and disable primitive restart and specify a primitive restart index.  <a href="classnvn_1_1_command_buffer.html#a81df57774190f2c44f29ff3da16f996e">More...</a><br /></td></tr>
<tr class="separator:a81df57774190f2c44f29ff3da16f996e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e968d43bfc4919804bf951101a17b65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a7e968d43bfc4919804bf951101a17b65">SetProgramSubroutines</a> (<a class="el" href="classnvn_1_1_program.html">Program</a> *program, <a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a> stage, const int first, const int count, NVN_NOESCAPE const int *values)</td></tr>
<tr class="memdesc:a7e968d43bfc4919804bf951101a17b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the subroutine uniform parameters.  <a href="classnvn_1_1_command_buffer.html#a7e968d43bfc4919804bf951101a17b65">More...</a><br /></td></tr>
<tr class="separator:a7e968d43bfc4919804bf951101a17b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20400dc9d0edb9f7069d83c3b6106b38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a20400dc9d0edb9f7069d83c3b6106b38">SetRasterizerDiscard</a> (<a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> discard)</td></tr>
<tr class="memdesc:a20400dc9d0edb9f7069d83c3b6106b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable rasterizer discard.  <a href="classnvn_1_1_command_buffer.html#a20400dc9d0edb9f7069d83c3b6106b38">More...</a><br /></td></tr>
<tr class="separator:a20400dc9d0edb9f7069d83c3b6106b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebb910789d3d56aab05ba1f0dfb6c3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#acebb910789d3d56aab05ba1f0dfb6c3f">SetRenderEnable</a> (<a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable)</td></tr>
<tr class="memdesc:acebb910789d3d56aab05ba1f0dfb6c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the render enable for a queue.  <a href="classnvn_1_1_command_buffer.html#acebb910789d3d56aab05ba1f0dfb6c3f">More...</a><br /></td></tr>
<tr class="separator:acebb910789d3d56aab05ba1f0dfb6c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae228acd137da5415f118f5c8268c867a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#ae228acd137da5415f118f5c8268c867a">SetRenderEnableConditional</a> (<a class="el" href="structnvn_1_1_conditional_render_mode.html">ConditionalRenderMode</a> mode, <a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> counters)</td></tr>
<tr class="memdesc:ae228acd137da5415f118f5c8268c867a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables rendering for a queue, depending on the equality of counters.  <a href="classnvn_1_1_command_buffer.html#ae228acd137da5415f118f5c8268c867a">More...</a><br /></td></tr>
<tr class="separator:ae228acd137da5415f118f5c8268c867a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4940982011cd1c5c8cc1c9e25262f70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#ad4940982011cd1c5c8cc1c9e25262f70">SetRenderTargets</a> (int numColors, NVN_NOESCAPE const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *const *colors, NVN_NOESCAPE const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *const *colorViews, const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *depthStencil, NVN_NOESCAPE const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *depthStencilView)</td></tr>
<tr class="memdesc:ad4940982011cd1c5c8cc1c9e25262f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets color and depth/stencil textures in the framebuffer.  <a href="classnvn_1_1_command_buffer.html#ad4940982011cd1c5c8cc1c9e25262f70">More...</a><br /></td></tr>
<tr class="separator:ad4940982011cd1c5c8cc1c9e25262f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aecd213fbf83199c53b4ce455fab481"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a4aecd213fbf83199c53b4ce455fab481">SetSampleMask</a> (int mask)</td></tr>
<tr class="memdesc:a4aecd213fbf83199c53b4ce455fab481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a mask of samples that may be covered by rendered primitives.  <a href="classnvn_1_1_command_buffer.html#a4aecd213fbf83199c53b4ce455fab481">More...</a><br /></td></tr>
<tr class="separator:a4aecd213fbf83199c53b4ce455fab481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36725731839793d678ce0243df56f94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#ad36725731839793d678ce0243df56f94">SetSamplerPool</a> (const <a class="el" href="classnvn_1_1_sampler_pool.html">SamplerPool</a> *samplerPool)</td></tr>
<tr class="memdesc:ad36725731839793d678ce0243df56f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a new sampler pool used for subsequent rendering operations.  <a href="classnvn_1_1_command_buffer.html#ad36725731839793d678ce0243df56f94">More...</a><br /></td></tr>
<tr class="separator:ad36725731839793d678ce0243df56f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f511de71b6bec1603e68bb8fd5ba424"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a5f511de71b6bec1603e68bb8fd5ba424">SetScissor</a> (int x, int y, int w, int h)</td></tr>
<tr class="memdesc:a5f511de71b6bec1603e68bb8fd5ba424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the scissor rectangle used for clipping primitives and clears.  <a href="classnvn_1_1_command_buffer.html#a5f511de71b6bec1603e68bb8fd5ba424">More...</a><br /></td></tr>
<tr class="separator:a5f511de71b6bec1603e68bb8fd5ba424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af379c72c350eeb7623d498d10067b8f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#af379c72c350eeb7623d498d10067b8f3">SetScissors</a> (int first, int count, NVN_NOESCAPE const int *rects)</td></tr>
<tr class="memdesc:af379c72c350eeb7623d498d10067b8f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify one or more scissor rectangles.  <a href="classnvn_1_1_command_buffer.html#af379c72c350eeb7623d498d10067b8f3">More...</a><br /></td></tr>
<tr class="separator:af379c72c350eeb7623d498d10067b8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a65c1f2c4f9cde0395aa082526d52f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a2a65c1f2c4f9cde0395aa082526d52f6">SetShaderScratchMemory</a> (const <a class="el" href="classnvn_1_1_memory_pool.html">MemoryPool</a> *pool, ptrdiff_t offset, size_t size)</td></tr>
<tr class="memdesc:a2a65c1f2c4f9cde0395aa082526d52f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify scratch memory required for shader execution.  <a href="classnvn_1_1_command_buffer.html#a2a65c1f2c4f9cde0395aa082526d52f6">More...</a><br /></td></tr>
<tr class="separator:a2a65c1f2c4f9cde0395aa082526d52f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170337752e305883654a1d57a4727672"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a170337752e305883654a1d57a4727672">SetStencilCullCriteria</a> (<a class="el" href="structnvn_1_1_stencil_func.html">StencilFunc</a> func, int ref, int mask)</td></tr>
<tr class="memdesc:a170337752e305883654a1d57a4727672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the criteria that is used by the ZCull HW for stencil culling.  <a href="classnvn_1_1_command_buffer.html#a170337752e305883654a1d57a4727672">More...</a><br /></td></tr>
<tr class="separator:a170337752e305883654a1d57a4727672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6ae23a1825ecc510d9e9ec06c743ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a5c6ae23a1825ecc510d9e9ec06c743ee">SetStencilMask</a> (<a class="el" href="structnvn_1_1_face.html">Face</a> faces, int mask)</td></tr>
<tr class="memdesc:a5c6ae23a1825ecc510d9e9ec06c743ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a mask to apply to stencil values written by the stencil test.  <a href="classnvn_1_1_command_buffer.html#a5c6ae23a1825ecc510d9e9ec06c743ee">More...</a><br /></td></tr>
<tr class="separator:a5c6ae23a1825ecc510d9e9ec06c743ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33326a59db6cab792fd729fbbd223512"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a33326a59db6cab792fd729fbbd223512">SetStencilRef</a> (<a class="el" href="structnvn_1_1_face.html">Face</a> faces, int ref)</td></tr>
<tr class="memdesc:a33326a59db6cab792fd729fbbd223512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a stencil reference value used by the stencil test.  <a href="classnvn_1_1_command_buffer.html#a33326a59db6cab792fd729fbbd223512">More...</a><br /></td></tr>
<tr class="separator:a33326a59db6cab792fd729fbbd223512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719b4e44b46242d14ff81d3af76af169"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a719b4e44b46242d14ff81d3af76af169">SetStencilValueMask</a> (<a class="el" href="structnvn_1_1_face.html">Face</a> faces, int mask)</td></tr>
<tr class="memdesc:a719b4e44b46242d14ff81d3af76af169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a mask that will be applied to the stencil index and reference values prior to performing the stencil test.  <a href="classnvn_1_1_command_buffer.html#a719b4e44b46242d14ff81d3af76af169">More...</a><br /></td></tr>
<tr class="separator:a719b4e44b46242d14ff81d3af76af169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea06553acf05d4707402343486a0125c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#aea06553acf05d4707402343486a0125c">SetSubpixelPrecisionBias</a> (int xBits, int yBits)</td></tr>
<tr class="memdesc:aea06553acf05d4707402343486a0125c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the number of additional bits of subpixel precision to be used for primitive rasterization when conservative rasterization is enabled.  <a href="classnvn_1_1_command_buffer.html#aea06553acf05d4707402343486a0125c">More...</a><br /></td></tr>
<tr class="separator:aea06553acf05d4707402343486a0125c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f10e3257fe549de368e842e61ee8ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a25f10e3257fe549de368e842e61ee8ee">SetTexturePool</a> (const <a class="el" href="classnvn_1_1_texture_pool.html">TexturePool</a> *texturePool)</td></tr>
<tr class="memdesc:a25f10e3257fe549de368e842e61ee8ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a new texture pool used for subsequent rendering operations.  <a href="classnvn_1_1_command_buffer.html#a25f10e3257fe549de368e842e61ee8ee">More...</a><br /></td></tr>
<tr class="separator:a25f10e3257fe549de368e842e61ee8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9013640ac6720f99139509a1763df6c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a9013640ac6720f99139509a1763df6c1">SetTiledCacheAction</a> (<a class="el" href="structnvn_1_1_tiled_cache_action.html">TiledCacheAction</a> action)</td></tr>
<tr class="memdesc:a9013640ac6720f99139509a1763df6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a specified operation related to tiled caching.  <a href="classnvn_1_1_command_buffer.html#a9013640ac6720f99139509a1763df6c1">More...</a><br /></td></tr>
<tr class="separator:a9013640ac6720f99139509a1763df6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0390349017d16e8481942f520fba95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a9c0390349017d16e8481942f520fba95">SetTiledCacheTileSize</a> (int tileWidth, int tileHeight)</td></tr>
<tr class="memdesc:a9c0390349017d16e8481942f520fba95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the tile size used for tiled caching.  <a href="classnvn_1_1_command_buffer.html#a9c0390349017d16e8481942f520fba95">More...</a><br /></td></tr>
<tr class="separator:a9c0390349017d16e8481942f520fba95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7f8f6b72d99364f85dbe0e5ebdcaa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a0c7f8f6b72d99364f85dbe0e5ebdcaa4">SetViewport</a> (int x, int y, int w, int h)</td></tr>
<tr class="memdesc:a0c7f8f6b72d99364f85dbe0e5ebdcaa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the rectangle for viewport 0.  <a href="classnvn_1_1_command_buffer.html#a0c7f8f6b72d99364f85dbe0e5ebdcaa4">More...</a><br /></td></tr>
<tr class="separator:a0c7f8f6b72d99364f85dbe0e5ebdcaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373958d6d0ef429a0b66c37c92abf7b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a373958d6d0ef429a0b66c37c92abf7b2">SetViewports</a> (int first, int count, NVN_NOESCAPE const float *ranges)</td></tr>
<tr class="memdesc:a373958d6d0ef429a0b66c37c92abf7b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify one or more viewport rectangles.  <a href="classnvn_1_1_command_buffer.html#a373958d6d0ef429a0b66c37c92abf7b2">More...</a><br /></td></tr>
<tr class="separator:a373958d6d0ef429a0b66c37c92abf7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1777a493572b56e2f832d4ea7a646d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#aad1777a493572b56e2f832d4ea7a646d">SetViewportSwizzles</a> (int first, int count, NVN_NOESCAPE const <a class="el" href="structnvn_1_1_viewport_swizzle.html">ViewportSwizzle</a> *swizzles)</td></tr>
<tr class="memdesc:aad1777a493572b56e2f832d4ea7a646d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a set of viewport swizzle selectors for one or more viewport rectangles.  <a href="classnvn_1_1_command_buffer.html#aad1777a493572b56e2f832d4ea7a646d">More...</a><br /></td></tr>
<tr class="separator:aad1777a493572b56e2f832d4ea7a646d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867ce7911d6dd0a54ed509459ed7d744"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a867ce7911d6dd0a54ed509459ed7d744">SetZCullZF32CompressionEnable</a> (<a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable)</td></tr>
<tr class="memdesc:a867ce7911d6dd0a54ed509459ed7d744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables/Disables the compression for ZF32 values in the ZCull <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a>.  <a href="classnvn_1_1_command_buffer.html#a867ce7911d6dd0a54ed509459ed7d744">More...</a><br /></td></tr>
<tr class="separator:a867ce7911d6dd0a54ed509459ed7d744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042cb09825770079f08e777509e6d8fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a042cb09825770079f08e777509e6d8fe">SignalEvent</a> (const <a class="el" href="classnvn_1_1_event.html">Event</a> *event, <a class="el" href="structnvn_1_1_event_signal_mode.html">EventSignalMode</a> mode, <a class="el" href="structnvn_1_1_event_signal_location.html">EventSignalLocation</a> location, <a class="el" href="structnvn_1_1_event_signal_flags.html">EventSignalFlags</a> flags, uint32_t value)</td></tr>
<tr class="memdesc:a042cb09825770079f08e777509e6d8fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the GPU to signal an <a class="el" href="classnvn_1_1_event.html" title="Event object.">Event</a> object.  <a href="classnvn_1_1_command_buffer.html#a042cb09825770079f08e777509e6d8fe">More...</a><br /></td></tr>
<tr class="separator:a042cb09825770079f08e777509e6d8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8cc57c04b2dcdcf17636155dfdb66d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#ae8cc57c04b2dcdcf17636155dfdb66d4">TiledDownsample</a> (const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *src, const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *dst)</td></tr>
<tr class="memdesc:ae8cc57c04b2dcdcf17636155dfdb66d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a filtered version of a multisample source texture to produce a single-sample destination texture.  <a href="classnvn_1_1_command_buffer.html#ae8cc57c04b2dcdcf17636155dfdb66d4">More...</a><br /></td></tr>
<tr class="separator:ae8cc57c04b2dcdcf17636155dfdb66d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77dd8f52363143f81f6cd5ce7eaf7a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#af77dd8f52363143f81f6cd5ce7eaf7a1">TiledDownsampleTextureView</a> (const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *src, NVN_NOESCAPE const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *srcView, const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *dst, NVN_NOESCAPE const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *dstView)</td></tr>
<tr class="memdesc:af77dd8f52363143f81f6cd5ce7eaf7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a filtered version of a multisample source texture texture view to produce a single-sample destination texture view.  <a href="classnvn_1_1_command_buffer.html#af77dd8f52363143f81f6cd5ce7eaf7a1">More...</a><br /></td></tr>
<tr class="separator:af77dd8f52363143f81f6cd5ce7eaf7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0c771367c9d655052cfc1657aa70ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a2a0c771367c9d655052cfc1657aa70ca">UpdateUniformBuffer</a> (<a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> buffer, size_t bufferSize, ptrdiff_t updateOffset, size_t updateSize, NVN_NOESCAPE const void *data)</td></tr>
<tr class="memdesc:a2a0c771367c9d655052cfc1657aa70ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the contents of a uniform buffer.  <a href="classnvn_1_1_command_buffer.html#a2a0c771367c9d655052cfc1657aa70ca">More...</a><br /></td></tr>
<tr class="separator:a2a0c771367c9d655052cfc1657aa70ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae682e63441faaed6a3ffdf4fff89850d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#ae682e63441faaed6a3ffdf4fff89850d">UpdateUniformBuffer_fastpath</a> (<a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a> buffer, size_t bufferSize, ptrdiff_t updateOffset, size_t updateSize, NVN_NOESCAPE const void *data)</td></tr>
<tr class="memdesc:ae682e63441faaed6a3ffdf4fff89850d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the contents of a uniform buffer.  <a href="classnvn_1_1_command_buffer.html#ae682e63441faaed6a3ffdf4fff89850d">More...</a><br /></td></tr>
<tr class="separator:ae682e63441faaed6a3ffdf4fff89850d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ada95e92249e9b1f3b1b166dbbf5f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a64ada95e92249e9b1f3b1b166dbbf5f5">WaitEvent</a> (const <a class="el" href="classnvn_1_1_event.html">Event</a> *event, <a class="el" href="structnvn_1_1_event_wait_mode.html">EventWaitMode</a> waitMode, uint32_t value)</td></tr>
<tr class="memdesc:a64ada95e92249e9b1f3b1b166dbbf5f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause work on the GPU until an event is signaled.  <a href="classnvn_1_1_command_buffer.html#a64ada95e92249e9b1f3b1b166dbbf5f5">More...</a><br /></td></tr>
<tr class="separator:a64ada95e92249e9b1f3b1b166dbbf5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ce30782d28ebc2f6d97cbc8658cd41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_command_buffer.html#a39ce30782d28ebc2f6d97cbc8658cd41">WaitSync</a> (const <a class="el" href="classnvn_1_1_sync.html">Sync</a> *sync)</td></tr>
<tr class="memdesc:a39ce30782d28ebc2f6d97cbc8658cd41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a <a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress.">Sync</a> object to be signaled on the GPU before processing any further commands in the specified <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a> object.  <a href="classnvn_1_1_command_buffer.html#a39ce30782d28ebc2f6d97cbc8658cd41">More...</a><br /></td></tr>
<tr class="separator:a39ce30782d28ebc2f6d97cbc8658cd41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Collection of commands to send to the GPU via queues. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_graphics_command_buffer_8cpp-example.html#_a0">NvnSimple/NvnSimpleSharedLib/GraphicsCommandBuffer.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_graphics_render_state_8cpp-example.html#_a1">NvnSimple/NvnSimpleSharedLib/GraphicsRenderState.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_graphics_shader_8cpp-example.html#_a46">NvnSimple/NvnSimpleSharedLib/GraphicsShader.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_graphics_system_8cpp-example.html#_a57">NvnSimple/NvnSimpleSharedLib/GraphicsSystem.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_graphics_texture_manager_8cpp-example.html#_a19">NvnSimple/NvnSimpleSharedLib/GraphicsTextureManager.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_graphics_utilities_8cpp-example.html#_a5">NvnSimple/NvnSimpleSharedLib/GraphicsUtilities.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_simple_framework_8cpp-example.html#_a43">NvnSimple/NvnSimpleSharedLib/SimpleFramework.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_simple_primitive_renderer_8cpp-example.html#_a14">NvnSimple/NvnSimpleSharedLib/SimplePrimitiveRenderer.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_simple_text_renderer_8cpp-example.html#_a32">NvnSimple/NvnSimpleSharedLib/SimpleTextRenderer.cpp</a>, <a class="el" href="_nvn_simple01_screen_space_triangles_2_screen_space_triangles_8cpp-example.html#_a6">NvnSimple01ScreenSpaceTriangles/ScreenSpaceTriangles.cpp</a>, <a class="el" href="_nvn_simple02_world_space_triangles_2_world_space_triangles_8cpp-example.html#_a11">NvnSimple02WorldSpaceTriangles/WorldSpaceTriangles.cpp</a>, <a class="el" href="_nvn_simple03_textured_cube_2_textured_cube_8cpp-example.html#_a41">NvnSimple03TexturedCube/TexturedCube.cpp</a>, <a class="el" href="_nvn_simple04_render_to_texture_2_render_to_texture_8cpp-example.html#_a34">NvnSimple04RenderToTexture/RenderToTexture.cpp</a>, <a class="el" href="_nvn_simple04_render_to_texture_2_shape_8cpp-example.html#_a5">NvnSimple04RenderToTexture/Shape.cpp</a>, <a class="el" href="_nvn_simple04_render_to_texture_2_shape_8h-example.html#_a2">NvnSimple04RenderToTexture/Shape.h</a>, <a class="el" href="_nvn_simple05_font_rendering_2_font_rendering_8cpp-example.html#_a3">NvnSimple05FontRendering/FontRendering.cpp</a>, <a class="el" href="_nvn_simple06_multi_command_set_2_multi_command_set_8cpp-example.html#_a10">NvnSimple06MultiCommandSet/MultiCommandSet.cpp</a>, <a class="el" href="_nvn_simple07_dynamic_resolution_2_dynamic_resolution_8cpp-example.html#_a24">NvnSimple07DynamicResolution/DynamicResolution.cpp</a>, <a class="el" href="nvnsimple_2_nvn_simple_shared_lib_2_graphics_command_buffer_8h-example.html#_a1">nvnsimple/NvnSimpleSharedLib/GraphicsCommandBuffer.h</a>, <a class="el" href="nvnsimple_2_nvn_simple_shared_lib_2_graphics_render_state_8h-example.html#_a1">nvnsimple/NvnSimpleSharedLib/GraphicsRenderState.h</a>, <a class="el" href="nvnsimple_2_nvn_simple_shared_lib_2_graphics_utilities_8h-example.html#_a4">nvnsimple/NvnSimpleSharedLib/GraphicsUtilities.h</a>, and <a class="el" href="nvnsimple_2_nvn_simple_shared_lib_2_simple_text_renderer_8h-example.html#_a1">nvnsimple/NvnSimpleSharedLib/SimpleTextRenderer.h</a>.</dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ab065aa237a8b8c7c96d1f7eef1cdfae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab065aa237a8b8c7c96d1f7eef1cdfae4">&#9670;&nbsp;</a></span>Initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvn::CommandBuffer::Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnvn_1_1_device.html">Device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a> object for the specified device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td><a class="el" href="classnvn_1_1_device.html" title="API class used to represent a specific GPU/device.">Device</a> owning the <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d715b1c09063d8b3820d4d3f63e719f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d715b1c09063d8b3820d4d3f63e719f">&#9670;&nbsp;</a></span>SetDebugLabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetDebugLabel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debug label string for a <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a> object. </p>
<p>Annotates a <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a> object with a descriptive text label. This label may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Text string used to annotate the <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0aab9ff6d4872bd1bc75feb264dc5734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aab9ff6d4872bd1bc75feb264dc5734">&#9670;&nbsp;</a></span>SetMemoryCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetMemoryCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__funcptrs.html#ga6b2c74544158547abb83cc4753f3a5cf">CommandBufferMemoryCallbackFunc</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a callback function for a <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a> object that will be called if it runs out of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Callback function to use on out-of-memory events. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89bf59fb5a193439c2289387f33fb196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89bf59fb5a193439c2289387f33fb196">&#9670;&nbsp;</a></span>SetMemoryCallbackData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetMemoryCallbackData </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a generic pointer that will be passed to a callback function if the command buffer runs out of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">callbackData</td><td>Callback data to be passed in an out-of-memory event callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec6f7480a9f868cffe1d348b8f076dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6f7480a9f868cffe1d348b8f076dc9">&#9670;&nbsp;</a></span>SetCommandMemoryCallbackEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetCommandMemoryCallbackEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the memory callback when out of command memory. </p>
<p>If a sequence of commands is known to fit within allocated command memory, applications can prevent the driver from conservatively invoking the out-of-memory callback when previously allocated command memory is nearly exhausted. This function does not affect behavior related to control memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>True (default) if the out-of-memory callback should be enabled; false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a608a08a70a0908e53cad3b7a62dd6a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608a08a70a0908e53cad3b7a62dd6a13">&#9670;&nbsp;</a></span>SetCommandMemoryCallbackEnabled_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetCommandMemoryCallbackEnabled_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the memory callback when out of command memory. </p>
<p>Fastpath variant.</p>
<p>If a sequence of commands is known to fit within allocated command memory, applications can prevent the driver from conservatively invoking the out-of-memory callback when previously allocated command memory is nearly exhausted. This function does not affect behavior related to control memory.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to <a class="el" href="classnvn_1_1_command_buffer.html#aec6f7480a9f868cffe1d348b8f076dc9" title="Enable or disable the memory callback when out of command memory.">CommandBuffer::SetCommandMemoryCallbackEnabled</a>, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>True (default) if the out-of-memory callback should be enabled; false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6b7a5a37fd5f91e4b50fb22498a992d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b7a5a37fd5f91e4b50fb22498a992d">&#9670;&nbsp;</a></span>AddCommandMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::AddCommandMemory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_memory_pool.html">MemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add command data memory for a <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a> object. </p>
<p>This can be called at any time, even outside an out-of-memory callback or while recording or not recording. Any leftover space in the previous command memory will remain unused. Only the last provided block is consumed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>Memory pool used to store commands.</td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) relative to pool of the memory used to store commands. Must be a multiple of 4 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da54532052e54a769035427d04034ee985" title="Minimum alignment for command data in a command builder.">nvn::DeviceInfo::COMMAND_BUFFER_COMMAND_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of memory used to store commands. Must be a multiple of 4 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da54532052e54a769035427d04034ee985" title="Minimum alignment for command data in a command builder.">nvn::DeviceInfo::COMMAND_BUFFER_COMMAND_ALIGNMENT</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4fd1a23d42725f00f814de03270d17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4fd1a23d42725f00f814de03270d17a">&#9670;&nbsp;</a></span>AddControlMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::AddControlMemory </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add control memory for a <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a> object. </p>
<p>This can be called at any time, even outside an out-of-memory callback or while recording or not recording. Any leftover space in the previous control memory will remain unused. Only the last provided block is consumed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">memory</td><td>Storage used for the command buffer control information. Must be a multiple of 8 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da3efcbbe368b1fbad7af0a91d7cbe2546" title="Minimum alignment for control data in a command builder.">nvn::DeviceInfo::COMMAND_BUFFER_CONTROL_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">size</td><td>Size (in bytes) of memory used to store control information. Must be a multiple of 8 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da3efcbbe368b1fbad7af0a91d7cbe2546" title="Minimum alignment for control data in a command builder.">nvn::DeviceInfo::COMMAND_BUFFER_CONTROL_ALIGNMENT</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29294f5d9eb53ec74c59e2ed6df4afd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29294f5d9eb53ec74c59e2ed6df4afd9">&#9670;&nbsp;</a></span>GetCommandMemorySize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvn::CommandBuffer::GetCommandMemorySize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total size in bytes of the command memory block that was lastly added to the <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a>. </p>
<p>Please see the <a class="el" href="nvn_index.html#nvn_guide_command_buffer_memory_management">Command Buffer Memory Management</a> section of the NVN Programming Guide for further detail. </p>

</div>
</div>
<a id="a93a4a7e4e8a7da91a1627d836548f788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a4a7e4e8a7da91a1627d836548f788">&#9670;&nbsp;</a></span>GetCommandMemoryUsed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvn::CommandBuffer::GetCommandMemoryUsed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the used size in bytes of the command memory block that was lastly added to the <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a>. </p>
<p>Please see the <a class="el" href="nvn_index.html#nvn_guide_command_buffer_memory_management">Command Buffer Memory Management</a> section of the NVN Programming Guide for further detail. </p>

</div>
</div>
<a id="aac49f0ab25fa651a0f4913a1b962c34f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac49f0ab25fa651a0f4913a1b962c34f">&#9670;&nbsp;</a></span>GetCommandMemoryFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvn::CommandBuffer::GetCommandMemoryFree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the unused size in bytes of the command memory block that was lastly added to the <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a>. </p>
<p>Please see the <a class="el" href="nvn_index.html#nvn_guide_command_buffer_memory_management">Command Buffer Memory Management</a> section of the NVN Programming Guide for further detail. </p>

</div>
</div>
<a id="a19c8fa0255e9e0845c46e7d5162de17c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19c8fa0255e9e0845c46e7d5162de17c">&#9670;&nbsp;</a></span>GetControlMemorySize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvn::CommandBuffer::GetControlMemorySize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total size in bytes of the control memory block that was lastly added to the <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a>. </p>
<p>Please see the <a class="el" href="nvn_index.html#nvn_guide_command_buffer_memory_management">Command Buffer Memory Management</a> section of the NVN Programming Guide for further detail. </p>

</div>
</div>
<a id="abec66e4ec6d42caca35de9f3fcfbf638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abec66e4ec6d42caca35de9f3fcfbf638">&#9670;&nbsp;</a></span>GetControlMemoryUsed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvn::CommandBuffer::GetControlMemoryUsed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the used size in bytes of the control memory block that was lastly added to the <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a>. </p>
<p>Please see the <a class="el" href="nvn_index.html#nvn_guide_command_buffer_memory_management">Command Buffer Memory Management</a> section of the NVN Programming Guide for further detail. </p>

</div>
</div>
<a id="ad6c494a15150ea651feb87e44aeb0f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6c494a15150ea651feb87e44aeb0f67">&#9670;&nbsp;</a></span>GetControlMemoryFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvn::CommandBuffer::GetControlMemoryFree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the unused size in bytes of the control memory block that was lastly added to the <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a>. </p>
<p>Please see the <a class="el" href="nvn_index.html#nvn_guide_command_buffer_memory_management">Command Buffer Memory Management</a> section of the NVN Programming Guide for further detail. </p>

</div>
</div>
<a id="a24d6195ed2b397b50771255376b455e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d6195ed2b397b50771255376b455e6">&#9670;&nbsp;</a></span>BeginRecording_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BeginRecording_fastpath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin recording a new set of commands in this <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to <a class="el" href="classnvn_1_1_command_buffer.html#a569698f00f43c1074330c137b97f9e81" title="Begin recording a new set of commands in this CommandBuffer object.">CommandBuffer::BeginRecording</a>, but should be faster in common cases. Not compatible with the NVN debug layer. </dd></dl>

</div>
</div>
<a id="ac26cc174e1b801e022cff2c5405726b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26cc174e1b801e022cff2c5405726b0">&#9670;&nbsp;</a></span>CallCommands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::CallCommands </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numCommands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="group__nvn__cpp__handle.html#ga48a6926aea0b934109f96ae32027b7fb">CommandHandle</a> *&#160;</td>
          <td class="paramname"><em>handles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert calls to previously recorded command sets into the command set under construction. </p>
<p>CallCommands will copy control data from the previously recorded command sets into the new command set. Command data from these command sets are called directly. The command buffer under construction must hold sufficient memory to hold the control data. The command data from called command sets must not be freed until all command sets referencing the data are no longer in use. The command data in the called command sets should be recorded in a memory pool using <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356ac8d67a6455dce7ff64bb8b593a144369" title="Indicates that the memory pool will be accessed by the CPU without caching.">MemoryPoolFlags::CPU_UNCACHED</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numCommands</td><td>Number of command sets to call.</td></tr>
    <tr><td class="paramname">handles</td><td>Array of numCommands command set handles to call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2792fadaef65c9a39fc28127fb64bf00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2792fadaef65c9a39fc28127fb64bf00">&#9670;&nbsp;</a></span>CallCommands_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::CallCommands_fastpath </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numCommands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="group__nvn__cpp__handle.html#ga48a6926aea0b934109f96ae32027b7fb">CommandHandle</a> *&#160;</td>
          <td class="paramname"><em>handles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert calls to previously recorded command sets into the command set under construction. </p>
<p>Fastpath variant.</p>
<p>CallCommands will copy control data from the previously recorded command sets into the new command set. Command data from these command sets are called directly. The command buffer under construction must hold sufficient memory to hold the control data. The command data from called command sets must not be freed until all command sets referencing the data are no longer in use. The command data in the called command sets should be recorded in a memory pool using <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356ac8d67a6455dce7ff64bb8b593a144369" title="Indicates that the memory pool will be accessed by the CPU without caching.">MemoryPoolFlags::CPU_UNCACHED</a>.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to <a class="el" href="classnvn_1_1_command_buffer.html#ac26cc174e1b801e022cff2c5405726b0" title="Insert calls to previously recorded command sets into the command set under construction.">CommandBuffer::CallCommands</a>, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numCommands</td><td>Number of command sets to call.</td></tr>
    <tr><td class="paramname">handles</td><td>Array of numCommands command set handles to call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d1d30a924b48b7691a509f28783ae55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1d30a924b48b7691a509f28783ae55">&#9670;&nbsp;</a></span>CopyCommands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::CopyCommands </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numCommands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="group__nvn__cpp__handle.html#ga48a6926aea0b934109f96ae32027b7fb">CommandHandle</a> *&#160;</td>
          <td class="paramname"><em>handles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert copies of previously recorded command sets into the command set under construction. </p>
<p>CopyCommands will copy command and control data from the previously recorded command sets into the new command set. The command buffer must hold sufficient memory to hold the copied data. The command data in the called command sets should be recorded in a memory pool using <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a99a56351eafbaab331298fbc1a78e152" title="Indicates that the memory pool will be accessed by the CPU with caching.">MemoryPoolFlags::CPU_CACHED</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numCommands</td><td>Number of command sets to copy.</td></tr>
    <tr><td class="paramname">handles</td><td>Array of numCommands command set handles to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a328628b7afb78c07dc84fed234782b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328628b7afb78c07dc84fed234782b6d">&#9670;&nbsp;</a></span>BindBlendState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindBlendState </td>
          <td>(</td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="classnvn_1_1_blend_state.html">BlendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a new <a class="el" href="classnvn_1_1_blend_state.html" title="API state object controlling blending for one color target.">BlendState</a> object to bind for subsequent commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="classnvn_1_1_blend_state.html" title="API state object controlling blending for one color target.">BlendState</a> object to be bound. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a797044107ce1574da45a9d4dcbe3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a797044107ce1574da45a9d4dcbe3b2">&#9670;&nbsp;</a></span>BindChannelMaskState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindChannelMaskState </td>
          <td>(</td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="classnvn_1_1_channel_mask_state.html">ChannelMaskState</a> *&#160;</td>
          <td class="paramname"><em>channelMask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a new <a class="el" href="classnvn_1_1_channel_mask_state.html" title="API state object holding per-channel write masks for all color buffers.">ChannelMaskState</a> object to bind for subsequent commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channelMask</td><td><a class="el" href="classnvn_1_1_channel_mask_state.html" title="API state object holding per-channel write masks for all color buffers.">ChannelMaskState</a> object to be bound. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76d9cbd74906a5c23c4eefffaca5b0a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d9cbd74906a5c23c4eefffaca5b0a7">&#9670;&nbsp;</a></span>BindColorState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindColorState </td>
          <td>(</td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="classnvn_1_1_color_state.html">ColorState</a> *&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a new <a class="el" href="classnvn_1_1_color_state.html" title="API state object controlling processing of color values.">ColorState</a> object to bind for subsequent commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td><a class="el" href="classnvn_1_1_color_state.html" title="API state object controlling processing of color values.">ColorState</a> object to be bound. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada98a813425af1616714bb465233ffe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada98a813425af1616714bb465233ffe8">&#9670;&nbsp;</a></span>BindMultisampleState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindMultisampleState </td>
          <td>(</td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="classnvn_1_1_multisample_state.html">MultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a new <a class="el" href="classnvn_1_1_multisample_state.html" title="API state object controlling multisample rasterization and sample processing.">MultisampleState</a> object to bind for subsequent commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="classnvn_1_1_multisample_state.html" title="API state object controlling multisample rasterization and sample processing.">MultisampleState</a> object to be bound. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adab5d1dedfe29fb0ca07d8f48be7eace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab5d1dedfe29fb0ca07d8f48be7eace">&#9670;&nbsp;</a></span>BindPolygonState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindPolygonState </td>
          <td>(</td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="classnvn_1_1_polygon_state.html">PolygonState</a> *&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a new <a class="el" href="classnvn_1_1_polygon_state.html" title="API state object controlling rasterization of polygons.">PolygonState</a> object to bind for subsequent commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td><a class="el" href="classnvn_1_1_polygon_state.html" title="API state object controlling rasterization of polygons.">PolygonState</a> object to be bound. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f3602d565b4fb17392a1d3ade9513be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3602d565b4fb17392a1d3ade9513be">&#9670;&nbsp;</a></span>BindDepthStencilState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindDepthStencilState </td>
          <td>(</td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="classnvn_1_1_depth_stencil_state.html">DepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a new <a class="el" href="classnvn_1_1_depth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">DepthStencilState</a> object to bind for subsequent commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="classnvn_1_1_depth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">DepthStencilState</a> object to be bound. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa57223468c54a870cd07cee18752a1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57223468c54a870cd07cee18752a1a9">&#9670;&nbsp;</a></span>BindVertexAttribState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindVertexAttribState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numAttribs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="classnvn_1_1_vertex_attrib_state.html">VertexAttribState</a> *&#160;</td>
          <td class="paramname"><em>attribs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a vertex attribute layout for subsequent commands. </p>
<p>All attributes beyond <em>numAttribs</em> are disabled, and fetching from them in the shader will return zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numAttribs</td><td>Number of vertex attributes to bind. Must be less than or equal to 16 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dafaaae98bd5984a6301a3f474b3a75a80" title="Number of vertex attributes.">nvn::DeviceInfo::VERTEX_ATTRIBUTES</a>).</td></tr>
    <tr><td class="paramname">attribs</td><td><a class="el" href="classnvn_1_1_vertex_attrib_state.html" title="API state object controlling vertex attrib state.">VertexAttribState</a> objects to be bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_nvn_simple01_screen_space_triangles_2_screen_space_triangles_8cpp-example.html#a9">NvnSimple01ScreenSpaceTriangles/ScreenSpaceTriangles.cpp</a>, <a class="el" href="_nvn_simple02_world_space_triangles_2_world_space_triangles_8cpp-example.html#a15">NvnSimple02WorldSpaceTriangles/WorldSpaceTriangles.cpp</a>, <a class="el" href="_nvn_simple03_textured_cube_2_textured_cube_8cpp-example.html#a46">NvnSimple03TexturedCube/TexturedCube.cpp</a>, <a class="el" href="_nvn_simple04_render_to_texture_2_render_to_texture_8cpp-example.html#a41">NvnSimple04RenderToTexture/RenderToTexture.cpp</a>, and <a class="el" href="_nvn_simple07_dynamic_resolution_2_dynamic_resolution_8cpp-example.html#a30">NvnSimple07DynamicResolution/DynamicResolution.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a5c5c1896e8850f177606530b2599226f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5c1896e8850f177606530b2599226f">&#9670;&nbsp;</a></span>BindVertexStreamState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindVertexStreamState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numStreams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="classnvn_1_1_vertex_stream_state.html">VertexStreamState</a> *&#160;</td>
          <td class="paramname"><em>streams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a vertex stream layout for subsequent commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numStreams</td><td>Number of vertex streams to bind. Must be less than or equal to 16 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da87e9a34487b82716c678332aa2379f58" title="Number of vertex buffer binding points.">nvn::DeviceInfo::VERTEX_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">streams</td><td><a class="el" href="classnvn_1_1_vertex_stream_state.html" title="API state object controlling vertex stream state.">VertexStreamState</a> objects to be bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_nvn_simple01_screen_space_triangles_2_screen_space_triangles_8cpp-example.html#a10">NvnSimple01ScreenSpaceTriangles/ScreenSpaceTriangles.cpp</a>, <a class="el" href="_nvn_simple02_world_space_triangles_2_world_space_triangles_8cpp-example.html#a16">NvnSimple02WorldSpaceTriangles/WorldSpaceTriangles.cpp</a>, <a class="el" href="_nvn_simple03_textured_cube_2_textured_cube_8cpp-example.html#a47">NvnSimple03TexturedCube/TexturedCube.cpp</a>, <a class="el" href="_nvn_simple04_render_to_texture_2_render_to_texture_8cpp-example.html#a42">NvnSimple04RenderToTexture/RenderToTexture.cpp</a>, and <a class="el" href="_nvn_simple07_dynamic_resolution_2_dynamic_resolution_8cpp-example.html#a31">NvnSimple07DynamicResolution/DynamicResolution.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a533458762741e1851a0d64a766593b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a533458762741e1851a0d64a766593b5d">&#9670;&nbsp;</a></span>BindProgram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindProgram </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_program.html">Program</a> *&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_shader_stage_bits.html">ShaderStageBits</a>&#160;</td>
          <td class="paramname"><em>stages</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind or unbind shaders in a <a class="el" href="classnvn_1_1_program.html" title="Collection of programmable shaders used to process primitives.">Program</a> object for subsequent rendering commands. </p>
<p>This command binds all shaders present in <em>program</em>, and optionally disables additional shader stages based on the bitfield <em>stages</em>. If <em>program</em> is NULL, all shader stages specified in the bitfield <em>stages</em> are disabled. If <em>program</em> is non-NULL, all shaders present in <em>program</em> will be bound and any stages in <em>stages</em> that don't have shaders in <em>program</em> are disabled. For example, using <a class="el" href="structnvn_1_1_shader_stage_bits.html#ab94211e8ac3af9676ae234f19f5cf0a6a750eb0191263fe5faa14bd4bff59eb65" title="Specifies all shader stages used to process graphics primitives.">ShaderStageBits::ALL_GRAPHICS_BITS</a> with a program with only a vertex and fragment shader will bind the vertex and fragment shaders in the program and disable the optional tessellation control, tessellation evaluation, and geometry shader stages.</p>
<dl class="section warning"><dt>Warning</dt><dd>When <em>program</em> is non-NULL, all stages present in <em>program</em> must be enabled in the bitfield <em>stages</em>.</dd>
<dd>
In the C interface, it is possible to pass enums of the type NVNshaderStage (NVN_VERTEX_SHADER) in <em>stages</em>. This is not legal; <em>stages</em> requires a bitfield built from values of type NVNshaderStageBits (NVN_VERTEX_SHADER_BIT).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td><a class="el" href="classnvn_1_1_program.html" title="Collection of programmable shaders used to process primitives.">Program</a> object to be bound.</td></tr>
    <tr><td class="paramname">stages</td><td>Bitfield identifying the set of shader stages to be updated. See <a class="el" href="structnvn_1_1_shader_stage_bits.html" title="Specifies a set of programmable shader stages.">nvn::ShaderStageBits</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5187aa77bf5509c1a02bae33ea3b17c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5187aa77bf5509c1a02bae33ea3b17c">&#9670;&nbsp;</a></span>BindVertexBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindVertexBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a range of a <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object to use for fetching vertex attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Vertex buffer binding point number to update. Must be less than 16 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da87e9a34487b82716c678332aa2379f58" title="Number of vertex buffer binding points.">nvn::DeviceInfo::VERTEX_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of vertex buffer memory to bind.</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the range of the <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object to bind. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_nvn_simple02_world_space_triangles_2_world_space_triangles_8cpp-example.html#a18">NvnSimple02WorldSpaceTriangles/WorldSpaceTriangles.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aede2e0a0dfbbbf18dc19a3e3804e9a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede2e0a0dfbbbf18dc19a3e3804e9a87">&#9670;&nbsp;</a></span>BindVertexBuffer_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindVertexBuffer_fastpath </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a range of a <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object to use for fetching vertex attributes. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to <a class="el" href="classnvn_1_1_command_buffer.html#ad5187aa77bf5509c1a02bae33ea3b17c" title="Bind a range of a Buffer object to use for fetching vertex attributes.">CommandBuffer::BindVertexBuffer</a>, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Vertex buffer binding point number to update. Must be less than 16 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da87e9a34487b82716c678332aa2379f58" title="Number of vertex buffer binding points.">nvn::DeviceInfo::VERTEX_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of vertex buffer memory to bind.</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the range of the <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64dd97ba97b852b4b149a73451c8c70a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64dd97ba97b852b4b149a73451c8c70a">&#9670;&nbsp;</a></span>BindVertexBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindVertexBuffers </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="structnvn_1_1_buffer_range.html">BufferRange</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object ranges to use for fetching vertex attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>First vertex buffer binding point number to update. Must be less than 16 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da87e9a34487b82716c678332aa2379f58" title="Number of vertex buffer binding points.">nvn::DeviceInfo::VERTEX_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous vertex buffer binding points to update. Must be greater than or equal to zero. Must be less than or equal to 16 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da87e9a34487b82716c678332aa2379f58" title="Number of vertex buffer binding points.">nvn::DeviceInfo::VERTEX_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">buffers</td><td>Array of vertex buffer ranges to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe9165f6db2a89abe261119ef7775fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe9165f6db2a89abe261119ef7775fec">&#9670;&nbsp;</a></span>BindVertexBuffers_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindVertexBuffers_fastpath </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="structnvn_1_1_buffer_range.html">BufferRange</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object ranges to use for fetching vertex attributes. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to <a class="el" href="classnvn_1_1_command_buffer.html#a64dd97ba97b852b4b149a73451c8c70a" title="Bind one or more Buffer object ranges to use for fetching vertex attributes.">CommandBuffer::BindVertexBuffers</a>, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>First vertex buffer binding point number to update. Must be less than 16 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da87e9a34487b82716c678332aa2379f58" title="Number of vertex buffer binding points.">nvn::DeviceInfo::VERTEX_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous vertex buffer binding points to update. Must be greater than or equal to zero. Must be less than or equal to 16 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da87e9a34487b82716c678332aa2379f58" title="Number of vertex buffer binding points.">nvn::DeviceInfo::VERTEX_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">buffers</td><td>Array of vertex buffer ranges to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a486ff1b4cd3e5dc02263c20e65e23081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486ff1b4cd3e5dc02263c20e65e23081">&#9670;&nbsp;</a></span>BindUniformBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindUniformBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a range of a <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object to use for fetching shader uniform values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding point to update.</td></tr>
    <tr><td class="paramname">index</td><td>Uniform buffer binding point number to update. Must be greater than or equal to zero. Must be less than 14 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da6c482c43aff448a5e4888a2e3a426841" title="Number of uniform buffer bindings supported for each shader stage.">nvn::DeviceInfo::UNIFORM_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of buffer object memory to bind. Must be a multiple of 256 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da0ac709daa04fb931cc36587cf69e7c97" title="Minimum alignment of uniform buffer bindings.">nvn::DeviceInfo::UNIFORM_BUFFER_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the range of the <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object to bind. Must be less than or equal to 65536 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dad61dee2ea2974320c3ebcc9f638b00ab" title="Maximum size (in bytes) of a bound uniform buffer.">nvn::DeviceInfo::MAX_UNIFORM_BUFFER_SIZE</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03dc7240d4b99bac5429e43f0f34e0f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03dc7240d4b99bac5429e43f0f34e0f3">&#9670;&nbsp;</a></span>BindUniformBuffer_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindUniformBuffer_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a range of a <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object to use for fetching shader uniform values. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to <a class="el" href="classnvn_1_1_command_buffer.html#a486ff1b4cd3e5dc02263c20e65e23081" title="Bind a range of a Buffer object to use for fetching shader uniform values.">CommandBuffer::BindUniformBuffer</a>, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding point to update.</td></tr>
    <tr><td class="paramname">index</td><td>Uniform buffer binding point number to update. Must be greater than or equal to zero. Must be less than 14 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da6c482c43aff448a5e4888a2e3a426841" title="Number of uniform buffer bindings supported for each shader stage.">nvn::DeviceInfo::UNIFORM_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of buffer object memory to bind. Must be a multiple of 256 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da0ac709daa04fb931cc36587cf69e7c97" title="Minimum alignment of uniform buffer bindings.">nvn::DeviceInfo::UNIFORM_BUFFER_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the range of the <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object to bind. Must be less than or equal to 65536 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dad61dee2ea2974320c3ebcc9f638b00ab" title="Maximum size (in bytes) of a bound uniform buffer.">nvn::DeviceInfo::MAX_UNIFORM_BUFFER_SIZE</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb9743dc0cc5c7fbf449053aca7cb562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9743dc0cc5c7fbf449053aca7cb562">&#9670;&nbsp;</a></span>BindUniformBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindUniformBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="structnvn_1_1_buffer_range.html">BufferRange</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object ranges to use for fetching shader uniform values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding point to update.</td></tr>
    <tr><td class="paramname">first</td><td>First uniform buffer binding point number to update. Must be less than 14 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da6c482c43aff448a5e4888a2e3a426841" title="Number of uniform buffer bindings supported for each shader stage.">nvn::DeviceInfo::UNIFORM_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous uniform buffer binding points to update. Must be greater than or equal to zero. Must be less than or equal to 14 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da6c482c43aff448a5e4888a2e3a426841" title="Number of uniform buffer bindings supported for each shader stage.">nvn::DeviceInfo::UNIFORM_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">buffers</td><td>Array of buffer object ranges to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f301b7e9b087d8984d8a286f6c107d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f301b7e9b087d8984d8a286f6c107d1">&#9670;&nbsp;</a></span>BindUniformBuffers_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindUniformBuffers_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="structnvn_1_1_buffer_range.html">BufferRange</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object ranges to use for fetching shader uniform values. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to <a class="el" href="classnvn_1_1_command_buffer.html#aeb9743dc0cc5c7fbf449053aca7cb562" title="Bind one or more Buffer object ranges to use for fetching shader uniform values.">CommandBuffer::BindUniformBuffers</a>, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding point to update.</td></tr>
    <tr><td class="paramname">first</td><td>First uniform buffer binding point number to update. Must be less than 14 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da6c482c43aff448a5e4888a2e3a426841" title="Number of uniform buffer bindings supported for each shader stage.">nvn::DeviceInfo::UNIFORM_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous uniform buffer binding points to update. Must be greater than or equal to zero. Must be less than or equal to 14 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da6c482c43aff448a5e4888a2e3a426841" title="Number of uniform buffer bindings supported for each shader stage.">nvn::DeviceInfo::UNIFORM_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">buffers</td><td>Array of buffer object ranges to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64d347b1239f9b48390e326adf270b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d347b1239f9b48390e326adf270b91">&#9670;&nbsp;</a></span>BindUniformBuffersDeferred()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindUniformBuffersDeferred </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnvn_1_1_buffer_range.html">BufferRange</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object ranges to use for fetching shader uniform values. </p>
<p>When recording this command, the pointer to the set of buffer object ranges is not dereferenced when the command set is recorded. Instead, it is dereferenced only when the command set containing this command is submitted to a queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding point to update.</td></tr>
    <tr><td class="paramname">first</td><td>First uniform buffer binding point number to update. Must be less than 14 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da6c482c43aff448a5e4888a2e3a426841" title="Number of uniform buffer bindings supported for each shader stage.">nvn::DeviceInfo::UNIFORM_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous uniform buffer binding points to update. Must be greater than or equal to zero. Must be less than or equal to 14 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da6c482c43aff448a5e4888a2e3a426841" title="Number of uniform buffer bindings supported for each shader stage.">nvn::DeviceInfo::UNIFORM_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">buffers</td><td>Array of buffer object ranges to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a542941c3d6ad7f3adf1438784e26ce61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542941c3d6ad7f3adf1438784e26ce61">&#9670;&nbsp;</a></span>BindUniformBuffersDeferred_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindUniformBuffersDeferred_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnvn_1_1_buffer_range.html">BufferRange</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object ranges to use for fetching shader uniform values. </p>
<p>Fastpath variant.</p>
<p>When recording this command, the pointer to the set of buffer object ranges is not dereferenced when the command set is recorded. Instead, it is dereferenced only when the command set containing this command is submitted to a queue.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to <a class="el" href="classnvn_1_1_command_buffer.html#a64d347b1239f9b48390e326adf270b91" title="Bind one or more Buffer object ranges to use for fetching shader uniform values.">CommandBuffer::BindUniformBuffersDeferred</a>, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding point to update.</td></tr>
    <tr><td class="paramname">first</td><td>First uniform buffer binding point number to update. Must be less than 14 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da6c482c43aff448a5e4888a2e3a426841" title="Number of uniform buffer bindings supported for each shader stage.">nvn::DeviceInfo::UNIFORM_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous uniform buffer binding points to update. Must be greater than or equal to zero. Must be less than or equal to 14 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da6c482c43aff448a5e4888a2e3a426841" title="Number of uniform buffer bindings supported for each shader stage.">nvn::DeviceInfo::UNIFORM_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">buffers</td><td>Array of buffer object ranges to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d2ad7d6b0e29930b13d8590026a074c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d2ad7d6b0e29930b13d8590026a074c">&#9670;&nbsp;</a></span>BindTransformFeedbackBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindTransformFeedbackBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a range of a <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object to use for capturing transformed vertex data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Transform feedback buffer binding point number to update. Must be less than 4 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da0ecb647d1d322fe3cff105adc1358e4b" title="Number of transform feedback buffer binding points.">nvn::DeviceInfo::TRANSFORM_FEEDBACK_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of transform feedback buffer memory to bind. If specified as zero, no data should be captured for the updated binding point. Must be a multiple of 4 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da5d6b04fdae598a02b51f766a2ff67c4a" title="Minimum alignment of transform feedback buffer bindings.">nvn::DeviceInfo::TRANSFORM_FEEDBACK_BUFFER_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the range of the <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object to bind. Must be a multiple of 4 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da5d6b04fdae598a02b51f766a2ff67c4a" title="Minimum alignment of transform feedback buffer bindings.">nvn::DeviceInfo::TRANSFORM_FEEDBACK_BUFFER_ALIGNMENT</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9594fd76317f902d6c3dc6f74e71e8a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9594fd76317f902d6c3dc6f74e71e8a4">&#9670;&nbsp;</a></span>BindTransformFeedbackBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindTransformFeedbackBuffers </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="structnvn_1_1_buffer_range.html">BufferRange</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object ranges to use for capturing transformed vertex data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>First transform feedback buffer binding point number to update. Must be less than 4 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da0ecb647d1d322fe3cff105adc1358e4b" title="Number of transform feedback buffer binding points.">nvn::DeviceInfo::TRANSFORM_FEEDBACK_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous transform feedback buffer binding points to update. Must be greater than or equal to zero. Must be less than or equal to 4 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da0ecb647d1d322fe3cff105adc1358e4b" title="Number of transform feedback buffer binding points.">nvn::DeviceInfo::TRANSFORM_FEEDBACK_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">buffers</td><td>Array of buffer object ranges to bind. If specified as zero, no data should be captured for the updated binding point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e8f4df985fe6d64ede82ae19a5ee9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8f4df985fe6d64ede82ae19a5ee9d7">&#9670;&nbsp;</a></span>BindStorageBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindStorageBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a range of a <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object to use for random-access reads and writes in shaders. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding point to update.</td></tr>
    <tr><td class="paramname">index</td><td>Shader storage buffer binding point number to update. Must be less than 16 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da4f9f3f339d86d0c300b76a79b570c709" title="Number of shader storage buffer bindings supported for each shader stage.">nvn::DeviceInfo::SHADER_STORAGE_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of buffer object memory to bind.</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the range of the <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23714ab975ced5fe2a5502504e34a59c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23714ab975ced5fe2a5502504e34a59c">&#9670;&nbsp;</a></span>BindStorageBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindStorageBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="structnvn_1_1_buffer_range.html">BufferRange</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object ranges to use for random-access reads and writes in shaders. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding point to update.</td></tr>
    <tr><td class="paramname">first</td><td>First shader storage buffer binding point number to update. Must be less than 16 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da4f9f3f339d86d0c300b76a79b570c709" title="Number of shader storage buffer bindings supported for each shader stage.">nvn::DeviceInfo::SHADER_STORAGE_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous shader storage buffer binding points to update. Must be greater than or equal to zero. Must be less than or equal to 16 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da4f9f3f339d86d0c300b76a79b570c709" title="Number of shader storage buffer bindings supported for each shader stage.">nvn::DeviceInfo::SHADER_STORAGE_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">buffers</td><td>Array of buffer object ranges to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38c27d787401033c1a1202e5566b0ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c27d787401033c1a1202e5566b0ff4">&#9670;&nbsp;</a></span>BindStorageBuffersDeferred()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindStorageBuffersDeferred </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnvn_1_1_buffer_range.html">BufferRange</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object ranges to use for random-access reads and writes in shaders. </p>
<p>When recording this command, the pointer to the set of buffer object ranges is not dereferenced when the command set is recorded. Instead, it is dereferenced only when the command set containing this command is submitted to a queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding point to update.</td></tr>
    <tr><td class="paramname">first</td><td>First shader storage buffer binding point number to update. Must be less than 16 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da4f9f3f339d86d0c300b76a79b570c709" title="Number of shader storage buffer bindings supported for each shader stage.">nvn::DeviceInfo::SHADER_STORAGE_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous shader storage buffer binding points to update. Must be greater than or equal to zero. Must be less than or equal to 16 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da4f9f3f339d86d0c300b76a79b570c709" title="Number of shader storage buffer bindings supported for each shader stage.">nvn::DeviceInfo::SHADER_STORAGE_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">buffers</td><td>Array of buffer object ranges to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01eed4ca62a3cd835e5a840e906c25a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01eed4ca62a3cd835e5a840e906c25a2">&#9670;&nbsp;</a></span>BindStorageBuffersDeferred_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindStorageBuffersDeferred_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnvn_1_1_buffer_range.html">BufferRange</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object ranges to use for random-access reads and writes in shaders. </p>
<p>Fastpath variant.</p>
<p>When recording this command, the pointer to the set of buffer object ranges is not dereferenced when the command set is recorded. Instead, it is dereferenced only when the command set containing this command is submitted to a queue.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to <a class="el" href="classnvn_1_1_command_buffer.html#a38c27d787401033c1a1202e5566b0ff4" title="Bind one or more Buffer object ranges to use for random-access reads and writes in shaders.">CommandBuffer::BindStorageBuffersDeferred</a>, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding point to update.</td></tr>
    <tr><td class="paramname">first</td><td>First shader storage buffer binding point number to update. Must be less than 16 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da4f9f3f339d86d0c300b76a79b570c709" title="Number of shader storage buffer bindings supported for each shader stage.">nvn::DeviceInfo::SHADER_STORAGE_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous shader storage buffer binding points to update. Must be greater than or equal to zero. Must be less than or equal to 16 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da4f9f3f339d86d0c300b76a79b570c709" title="Number of shader storage buffer bindings supported for each shader stage.">nvn::DeviceInfo::SHADER_STORAGE_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">buffers</td><td>Array of buffer object ranges to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f1b66c1660d5692b9e337db1262f901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f1b66c1660d5692b9e337db1262f901">&#9670;&nbsp;</a></span>BindTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gafe744b035d9582a86872d256349c5e08">TextureHandle</a>&#160;</td>
          <td class="paramname"><em>texture</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a Texture/Sampler pair to use for texture mapping in shaders. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding point to update.</td></tr>
    <tr><td class="paramname">index</td><td>Texture/sampler binding point number to update. Must be less than 32 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da29f706670764624e94f1e9e27205339a" title="Number of texture and sampler bindings supported for each shader stage.">nvn::DeviceInfo::TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">texture</td><td>Handle for the pair of <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> and <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">Sampler</a> objects to bind. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_nvn_simple03_textured_cube_2_textured_cube_8cpp-example.html#a48">NvnSimple03TexturedCube/TexturedCube.cpp</a>, <a class="el" href="_nvn_simple04_render_to_texture_2_render_to_texture_8cpp-example.html#a43">NvnSimple04RenderToTexture/RenderToTexture.cpp</a>, and <a class="el" href="_nvn_simple07_dynamic_resolution_2_dynamic_resolution_8cpp-example.html#a32">NvnSimple07DynamicResolution/DynamicResolution.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3256b8853627d7b5cf003c2e4e807f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3256b8853627d7b5cf003c2e4e807f2d">&#9670;&nbsp;</a></span>BindTextures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindTextures </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="group__nvn__cpp__handle.html#gafe744b035d9582a86872d256349c5e08">TextureHandle</a> *&#160;</td>
          <td class="paramname"><em>textures</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more Texture/Sampler pairs to use for texture mapping in shaders. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding points to update.</td></tr>
    <tr><td class="paramname">first</td><td>First texture/sampler binding point number to update. Must be less than 32 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da29f706670764624e94f1e9e27205339a" title="Number of texture and sampler bindings supported for each shader stage.">nvn::DeviceInfo::TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous texture/sampler binding points to update. Must be less than or equal to 32 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da29f706670764624e94f1e9e27205339a" title="Number of texture and sampler bindings supported for each shader stage.">nvn::DeviceInfo::TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">textures</td><td>Array of handles for pairs of <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> and <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">Sampler</a> objects to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ef859ca8cf0402a8e4d1f7ef602d89c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef859ca8cf0402a8e4d1f7ef602d89c">&#9670;&nbsp;</a></span>BindTexturesDeferred()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindTexturesDeferred </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__nvn__cpp__handle.html#gafe744b035d9582a86872d256349c5e08">TextureHandle</a> *&#160;</td>
          <td class="paramname"><em>textures</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more Texture/Sampler pairs to use for texture mapping in shaders. </p>
<p>When recording this command, the pointer to the set of texture handles is not dereferenced when the command set is recorded. Instead, it is dereferenced only when the command set containing this command is submitted to a queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding points to update.</td></tr>
    <tr><td class="paramname">first</td><td>First texture/sampler binding point number to update. Must be less than 32 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da29f706670764624e94f1e9e27205339a" title="Number of texture and sampler bindings supported for each shader stage.">nvn::DeviceInfo::TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous texture/sampler binding points to update. Must be less than or equal to 32 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da29f706670764624e94f1e9e27205339a" title="Number of texture and sampler bindings supported for each shader stage.">nvn::DeviceInfo::TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">textures</td><td>Array of handles for pairs of <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> and <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">Sampler</a> objects to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2a41e95f94942dd7d6f2722d98bdddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a41e95f94942dd7d6f2722d98bdddb">&#9670;&nbsp;</a></span>BindTexturesDeferred_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindTexturesDeferred_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__nvn__cpp__handle.html#gafe744b035d9582a86872d256349c5e08">TextureHandle</a> *&#160;</td>
          <td class="paramname"><em>textures</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more Texture/Sampler pairs to use for texture mapping in shaders. </p>
<p>Fastpath variant.</p>
<p>When recording this command, the pointer to the set of texture handles is not dereferenced when the command set is recorded. Instead, it is dereferenced only when the command set containing this command is submitted to a queue.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to <a class="el" href="classnvn_1_1_command_buffer.html#a3ef859ca8cf0402a8e4d1f7ef602d89c" title="Bind one or more Texture/Sampler pairs to use for texture mapping in shaders.">CommandBuffer::BindTexturesDeferred</a>, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding points to update.</td></tr>
    <tr><td class="paramname">first</td><td>First texture/sampler binding point number to update. Must be less than 32 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da29f706670764624e94f1e9e27205339a" title="Number of texture and sampler bindings supported for each shader stage.">nvn::DeviceInfo::TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous texture/sampler binding points to update. Must be less than or equal to 32 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da29f706670764624e94f1e9e27205339a" title="Number of texture and sampler bindings supported for each shader stage.">nvn::DeviceInfo::TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">textures</td><td>Array of handles for pairs of <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> and <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">Sampler</a> objects to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4748cba765d583a25c409e57645c7ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4748cba765d583a25c409e57645c7ab">&#9670;&nbsp;</a></span>BindImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#ga0ad8373f5da7065f67ab5d14eed99ac2">ImageHandle</a>&#160;</td>
          <td class="paramname"><em>image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> to use for image loads and stores in shaders. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding point to update.</td></tr>
    <tr><td class="paramname">index</td><td>Image binding point number to update. Must be less than 8 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da8a151fcc8352ec54b6b1b7ad95036511" title="Number of image bindings supported for each shader stage.">nvn::DeviceInfo::IMAGE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">image</td><td>Image handle for the <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> object to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a419c6e03d540096c3cc4ddf1ec04183b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419c6e03d540096c3cc4ddf1ec04183b">&#9670;&nbsp;</a></span>BindImages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindImages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="group__nvn__cpp__handle.html#ga0ad8373f5da7065f67ab5d14eed99ac2">ImageHandle</a> *&#160;</td>
          <td class="paramname"><em>images</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more Textures to use for image loads and stores in shaders. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding points to update.</td></tr>
    <tr><td class="paramname">first</td><td>First image binding point number to update. Must be less than 8 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da8a151fcc8352ec54b6b1b7ad95036511" title="Number of image bindings supported for each shader stage.">nvn::DeviceInfo::IMAGE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous image binding points to update. Must be less than or equal to 8 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da8a151fcc8352ec54b6b1b7ad95036511" title="Number of image bindings supported for each shader stage.">nvn::DeviceInfo::IMAGE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">images</td><td>Array of handles for <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> objects to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac6b61951fb49c5720eafe6e174b2011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac6b61951fb49c5720eafe6e174b2011">&#9670;&nbsp;</a></span>BindImagesDeferred()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindImagesDeferred </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__nvn__cpp__handle.html#ga0ad8373f5da7065f67ab5d14eed99ac2">ImageHandle</a> *&#160;</td>
          <td class="paramname"><em>images</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more Textures to use for image loads and stores in shaders. </p>
<p>When recording this command, the pointer to the set of image handles is not dereferenced when the command set is recorded. Instead, it is dereferenced only when the command set containing this command is submitted to a queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding points to update.</td></tr>
    <tr><td class="paramname">first</td><td>First image binding point number to update. Must be less than 8 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da8a151fcc8352ec54b6b1b7ad95036511" title="Number of image bindings supported for each shader stage.">nvn::DeviceInfo::IMAGE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous image binding points to update. Must be less than or equal to 8 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da8a151fcc8352ec54b6b1b7ad95036511" title="Number of image bindings supported for each shader stage.">nvn::DeviceInfo::IMAGE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">images</td><td>Array of handles for <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> objects to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a585c02d8f766d6972fd1054a0e93c449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585c02d8f766d6972fd1054a0e93c449">&#9670;&nbsp;</a></span>BindImagesDeferred_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindImagesDeferred_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__nvn__cpp__handle.html#ga0ad8373f5da7065f67ab5d14eed99ac2">ImageHandle</a> *&#160;</td>
          <td class="paramname"><em>images</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more Textures to use for image loads and stores in shaders. </p>
<p>Fastpath variant.</p>
<p>When recording this command, the pointer to the set of image handles is not dereferenced when the command set is recorded. Instead, it is dereferenced only when the command set containing this command is submitted to a queue.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to <a class="el" href="classnvn_1_1_command_buffer.html#aac6b61951fb49c5720eafe6e174b2011" title="Bind one or more Textures to use for image loads and stores in shaders.">CommandBuffer::BindImagesDeferred</a>, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding points to update.</td></tr>
    <tr><td class="paramname">first</td><td>First image binding point number to update. Must be less than 8 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da8a151fcc8352ec54b6b1b7ad95036511" title="Number of image bindings supported for each shader stage.">nvn::DeviceInfo::IMAGE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous image binding points to update. Must be less than or equal to 8 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da8a151fcc8352ec54b6b1b7ad95036511" title="Number of image bindings supported for each shader stage.">nvn::DeviceInfo::IMAGE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">images</td><td>Array of handles for <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> objects to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a580ce64d255d8aa9a7f0bfbda34ae995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580ce64d255d8aa9a7f0bfbda34ae995">&#9670;&nbsp;</a></span>SetPatchSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetPatchSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the number of vertices in each patch when rendering patch primitives. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Number of vertices present in each patch. Must be greater than zero. Must be less than or equal to 32 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da3a16681fe4a7e2af09fb5c4d16932ad6" title="Maximum number of vertices in each patch primitive.">nvn::DeviceInfo::MAX_PATCH_SIZE</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4491406f044f024bcca908a1a6f9b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4491406f044f024bcca908a1a6f9b27">&#9670;&nbsp;</a></span>SetInnerTessellationLevels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetInnerTessellationLevels </td>
          <td>(</td>
          <td class="paramtype">NVN_NOESCAPE const float *&#160;</td>
          <td class="paramname"><em>levels</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify default inner tessellation levels when rendering patch primitives. </p>
<p>The default inner and outer tessellation levels are used when a tessellation evaluation shader is bound without a tessellation control shader. When a tessellation control shader is bound, default levels are ignored.</p>
<dl class="section note"><dt>Note</dt><dd>Tessellation levels are clamped to the range [1.0, 64.0], and may be further clamped according to the tessellation spacing.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">levels</td><td>Two floating-point inner tessellation levels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a953c968a32947a0bfd7cf38ccf89d925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953c968a32947a0bfd7cf38ccf89d925">&#9670;&nbsp;</a></span>SetOuterTessellationLevels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetOuterTessellationLevels </td>
          <td>(</td>
          <td class="paramtype">NVN_NOESCAPE const float *&#160;</td>
          <td class="paramname"><em>levels</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify default outer tessellation levels when rendering patch primitives. </p>
<p>The default inner and outer tessellation levels are used when a tessellation evaluation shader is bound without a tessellation control shader. When a tessellation control shader is bound, default levels are ignored.</p>
<dl class="section note"><dt>Note</dt><dd>If any outer tessellation level is less than or equal to zero, a patch will be discarded, except for the fourth level when processing triangular patches.</dd>
<dd>
Tessellation levels greater than zero are clamped to the range [1.0, 64.0] and may be further clamped according to the tessellation spacing.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">levels</td><td>Four floating-point outer tessellation levels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81df57774190f2c44f29ff3da16f996e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81df57774190f2c44f29ff3da16f996e">&#9670;&nbsp;</a></span>SetPrimitiveRestart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetPrimitiveRestart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable and disable primitive restart and specify a primitive restart index. </p>
<p>When enabled, a primitive is restarted (with the same primitive type) whenever an index value matching the restart index value is found.</p>
<dl class="section note"><dt>Note</dt><dd>The vertex index value must match the restart index exactly. For example, primitives rendered using the index type <a class="el" href="structnvn_1_1_index_type.html#a99f2df4cf5709bf0fe3adf7126beca02a1b53b2d49b1bac70dc8b8dcceb047f36" title="Index values are specified as (8-bit) unsigned bytes.">IndexType::UNSIGNED_BYTE</a> wil not be restarted if the restart index is outside the range [0,255].</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Enable (TRUE) or disable (FALSE) primitive restart operations.</td></tr>
    <tr><td class="paramname">index</td><td>Index value used to indicate that a primitive should be restarted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e05f90c241cb01ffe07862ae2afaad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e05f90c241cb01ffe07862ae2afaad5">&#9670;&nbsp;</a></span>BeginTransformFeedback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BeginTransformFeedback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a transform feedback (stream output) operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>GPU address of buffer memory holding 32 bytes of control information used by the transform feedback operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Must point to valid buffer storage. Must be a multiple of 4 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da0dbdda786c1b7ec300462cfc8ba11732" title="Minimum alignment of transform feedback control data.">nvn::DeviceInfo::TRANSFORM_FEEDBACK_CONTROL_ALIGNMENT</a>). </dd></dl>

</div>
</div>
<a id="ab6086eb5893574fe192d08454c246972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6086eb5893574fe192d08454c246972">&#9670;&nbsp;</a></span>EndTransformFeedback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::EndTransformFeedback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complete a transform feedback (stream output) operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>GPU address of buffer memory holding 32 bytes of control information used by the transform feedback operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Must point to valid buffer storage. Must be a multiple of 4 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da0dbdda786c1b7ec300462cfc8ba11732" title="Minimum alignment of transform feedback control data.">nvn::DeviceInfo::TRANSFORM_FEEDBACK_CONTROL_ALIGNMENT</a>). </dd></dl>

</div>
</div>
<a id="acf2263122bab5991d4a99212493657b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf2263122bab5991d4a99212493657b7">&#9670;&nbsp;</a></span>PauseTransformFeedback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::PauseTransformFeedback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pause a transform feedback (stream output) operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>GPU address of buffer memory holding 32 bytes of control information used by the transform feedback operation. The provided address may be zero, in which case, no control information will be written to memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If an address of zero is used, the current state of the transform feedback operation is not saved to memory. If any other transform feedback operation is performed before resuming, or if transform feedback is resumed using a non-zero address, this state is lost. Must be a multiple of 4 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da0dbdda786c1b7ec300462cfc8ba11732" title="Minimum alignment of transform feedback control data.">nvn::DeviceInfo::TRANSFORM_FEEDBACK_CONTROL_ALIGNMENT</a>). </dd></dl>

</div>
</div>
<a id="ae69b628752585094f50ff22cbba8ab69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69b628752585094f50ff22cbba8ab69">&#9670;&nbsp;</a></span>ResumeTransformFeedback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::ResumeTransformFeedback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume a transform feedback (stream output) operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>GPU address of buffer memory holding 32 bytes of control information used by the transform feedback operation. The provided address may be zero, in which case, no control information will be read from memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If an address of zero is used, the state of the previously paused transform feedback operation is not restored from memory. If any other transform feedback operation is performed before resuming with a zero address, this state is lost. Must be a multiple of 4 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da0dbdda786c1b7ec300462cfc8ba11732" title="Minimum alignment of transform feedback control data.">nvn::DeviceInfo::TRANSFORM_FEEDBACK_CONTROL_ALIGNMENT</a>). </dd></dl>

</div>
</div>
<a id="a9ab04f8a0370eb42f81c9d307016f7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab04f8a0370eb42f81c9d307016f7cb">&#9670;&nbsp;</a></span>DrawTransformFeedback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::DrawTransformFeedback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_draw_primitive.html">DrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw primitives captured in a previous transform feedback (stream output) operation. </p>
<dl class="section warning"><dt>Warning</dt><dd>Applications must call <a class="el" href="classnvn_1_1_command_buffer.html#a1d9df9457cbd501a6035720f31979752" title="Specify a barrier ordering execution of GPU commands and invalidating internal GPU caches.">CommandBuffer::Barrier</a> with the <a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5af28c9a9c0844d5e10b871341d9ce66a4" title="Ensure that all work before the barrier completes before fetching per-draw data for indirect draws an...">BarrierBits::ORDER_INDIRECT_DATA</a> bit set to ensure that the GPU doesn't fetch the indirect data before previous commands are finished writing the data. Waiting via <a class="el" href="classnvn_1_1_queue.html#aca51bcfefab8f580172fb0fd43a0431f" title="Wait until all commands previously submitted to a queue have completed execution.">Queue::Finish</a>, <a class="el" href="classnvn_1_1_queue.html#a339d246e329a173e81d8e1cf2a550113" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">Queue::WaitSync</a>, or <a class="el" href="classnvn_1_1_command_buffer.html#a39ce30782d28ebc2f6d97cbc8658cd41" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">CommandBuffer::WaitSync</a> is not sufficient to ensure that GPU-produced indirect data are not fetched prematurely.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Type of primitive to render. When rendering primitives captured by transform feedback, this parameter should typically be POINTS, LINES, or TRIANGLES, since transform feedback captures only independent primitives (even if the original geometry were provided as strips).</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of buffer memory holding 32 bytes of control information used by the transform feedback operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Must point to valid buffer storage. Must be a multiple of 4 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da0dbdda786c1b7ec300462cfc8ba11732" title="Minimum alignment of transform feedback control data.">nvn::DeviceInfo::TRANSFORM_FEEDBACK_CONTROL_ALIGNMENT</a>). </dd></dl>

</div>
</div>
<a id="a9da364199d8c432151e8c18234ddde61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da364199d8c432151e8c18234ddde61">&#9670;&nbsp;</a></span>DrawArrays()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::DrawArrays </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_draw_primitive.html">DrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render a primitive with consecutive vertex indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Type of the primitive to render.</td></tr>
    <tr><td class="paramname">first</td><td>Index of the first vertex in the primitive.</td></tr>
    <tr><td class="paramname">count</td><td>Number of vertices in the primitive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a471babeb6b1971ba35fd006ecee180e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a471babeb6b1971ba35fd006ecee180e8">&#9670;&nbsp;</a></span>DrawElements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::DrawElements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_draw_primitive.html">DrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_index_type.html">IndexType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>indexBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render a primitive with vertex indices fetched from an index buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Type of the primitive to render.</td></tr>
    <tr><td class="paramname">type</td><td>Type of index values stored in the index buffer.</td></tr>
    <tr><td class="paramname">count</td><td>Number of vertices in the primitive.</td></tr>
    <tr><td class="paramname">indexBuffer</td><td>GPU address of buffer object memory used as the index buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_nvn_simple01_screen_space_triangles_2_screen_space_triangles_8cpp-example.html#a11">NvnSimple01ScreenSpaceTriangles/ScreenSpaceTriangles.cpp</a>, <a class="el" href="_nvn_simple02_world_space_triangles_2_world_space_triangles_8cpp-example.html#a19">NvnSimple02WorldSpaceTriangles/WorldSpaceTriangles.cpp</a>, <a class="el" href="_nvn_simple03_textured_cube_2_textured_cube_8cpp-example.html#a49">NvnSimple03TexturedCube/TexturedCube.cpp</a>, <a class="el" href="_nvn_simple04_render_to_texture_2_render_to_texture_8cpp-example.html#a44">NvnSimple04RenderToTexture/RenderToTexture.cpp</a>, and <a class="el" href="_nvn_simple07_dynamic_resolution_2_dynamic_resolution_8cpp-example.html#a34">NvnSimple07DynamicResolution/DynamicResolution.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a14bc25b22d24b6e68ed35ccc7fd860ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14bc25b22d24b6e68ed35ccc7fd860ce">&#9670;&nbsp;</a></span>DrawElements_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::DrawElements_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_draw_primitive.html">DrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_index_type.html">IndexType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>indexBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render a primitive with vertex indices fetched from an index buffer. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to <a class="el" href="classnvn_1_1_command_buffer.html#a471babeb6b1971ba35fd006ecee180e8" title="Render a primitive with vertex indices fetched from an index buffer.">CommandBuffer::DrawElements</a>, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Type of the primitive to render.</td></tr>
    <tr><td class="paramname">type</td><td>Type of index values stored in the index buffer.</td></tr>
    <tr><td class="paramname">count</td><td>Number of vertices in the primitive.</td></tr>
    <tr><td class="paramname">indexBuffer</td><td>GPU address of buffer object memory used as the index buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a7e64dec4570204b5ef80c5776b9135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a7e64dec4570204b5ef80c5776b9135">&#9670;&nbsp;</a></span>DrawElementsBaseVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::DrawElementsBaseVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_draw_primitive.html">DrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_index_type.html">IndexType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>indexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseVertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render a primitive with vertex indices fetched from an index buffer, with a base vertex value added to each fetched index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Type of the primitive to render.</td></tr>
    <tr><td class="paramname">type</td><td>Type of index values stored in the index buffer.</td></tr>
    <tr><td class="paramname">count</td><td>Number of vertices in the primitive.</td></tr>
    <tr><td class="paramname">indexBuffer</td><td>GPU address of buffer object memory used as the index buffer.</td></tr>
    <tr><td class="paramname">baseVertex</td><td>Base vertex value, added to each index fetched from the index buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff1d89da478af0af62b725f3acb2a03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff1d89da478af0af62b725f3acb2a03d">&#9670;&nbsp;</a></span>DrawArraysInstanced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::DrawArraysInstanced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_draw_primitive.html">DrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instanceCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render multiple copies (instances) of a primitive with consecutive vertex indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Type of the primitive to render.</td></tr>
    <tr><td class="paramname">first</td><td>Index of the first vertex in the primitive.</td></tr>
    <tr><td class="paramname">count</td><td>Number of vertices in the primitive.</td></tr>
    <tr><td class="paramname">baseInstance</td><td>Instance number of the first primitive instance.</td></tr>
    <tr><td class="paramname">instanceCount</td><td>Number of primitive instances to render. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad006e85876e24f910ca224279ef15e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad006e85876e24f910ca224279ef15e56">&#9670;&nbsp;</a></span>DrawElementsInstanced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::DrawElementsInstanced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_draw_primitive.html">DrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_index_type.html">IndexType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>indexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instanceCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render multiple copies (instances) of a primitive with vertex indices fetched from an index buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Type of the primitive to render.</td></tr>
    <tr><td class="paramname">type</td><td>Type of index values stored in the index buffer.</td></tr>
    <tr><td class="paramname">count</td><td>Number of vertices in the primitive.</td></tr>
    <tr><td class="paramname">indexBuffer</td><td>GPU address of buffer object memory used as the index buffer.</td></tr>
    <tr><td class="paramname">baseVertex</td><td>Base vertex value, added to each index fetched from the index buffer.</td></tr>
    <tr><td class="paramname">baseInstance</td><td>Instance number of the first primitive instance.</td></tr>
    <tr><td class="paramname">instanceCount</td><td>Number of primitive instances to render. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae646d84699c45f2fbb8f19228d09c552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae646d84699c45f2fbb8f19228d09c552">&#9670;&nbsp;</a></span>DrawArraysIndirect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::DrawArraysIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_draw_primitive.html">DrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>indirectBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render primitives with consecutive vertex indices, using draw parameters fetched from an indirect data buffer. </p>
<p>The parameters of the draw are stored in <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object memory using the <a class="el" href="structnvn_1_1_draw_arrays_indirect_data.html" title="Data structure representing values used by indirect DrawArrays commands.">DrawArraysIndirectData</a> structure.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the indirect data are produced by previous commands executed on the GPU, applications must call <a class="el" href="classnvn_1_1_command_buffer.html#a1d9df9457cbd501a6035720f31979752" title="Specify a barrier ordering execution of GPU commands and invalidating internal GPU caches.">CommandBuffer::Barrier</a> with the <a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5af28c9a9c0844d5e10b871341d9ce66a4" title="Ensure that all work before the barrier completes before fetching per-draw data for indirect draws an...">BarrierBits::ORDER_INDIRECT_DATA</a> bit set to ensure that the GPU doesn't fetch the indirect data before previous commands are finished writing the data. Waiting via <a class="el" href="classnvn_1_1_queue.html#aca51bcfefab8f580172fb0fd43a0431f" title="Wait until all commands previously submitted to a queue have completed execution.">Queue::Finish</a>, <a class="el" href="classnvn_1_1_queue.html#a339d246e329a173e81d8e1cf2a550113" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">Queue::WaitSync</a>, or <a class="el" href="classnvn_1_1_command_buffer.html#a39ce30782d28ebc2f6d97cbc8658cd41" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">CommandBuffer::WaitSync</a> is not sufficient to ensure that GPU-produced indirect data are not fetched prematurely.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Type of the primitive to render.</td></tr>
    <tr><td class="paramname">indirectBuffer</td><td>GPU address of buffer object memory holding the indirect draw data. Must be a multiple of 4 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da82b87ce9b727711c195258d53623de05" title="Minimum alignment of indirect draw data.">nvn::DeviceInfo::INDIRECT_DRAW_ALIGNMENT</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae01f121b63f5ad2e555acd587f7837bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae01f121b63f5ad2e555acd587f7837bf">&#9670;&nbsp;</a></span>DrawElementsIndirect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::DrawElementsIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_draw_primitive.html">DrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_index_type.html">IndexType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>indexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>indirectBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render primitives with vertex indices fetched from an index buffer, using draw parameters fetched from an indirect data buffer. </p>
<p>The parameters of the draw are stored in <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object memory using the <a class="el" href="structnvn_1_1_draw_elements_indirect_data.html" title="Data structure representing values used by indirect DrawElements commands.">DrawElementsIndirectData</a> structure.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the indirect data are produced by previous commands executed on the GPU, applications must call <a class="el" href="classnvn_1_1_command_buffer.html#a1d9df9457cbd501a6035720f31979752" title="Specify a barrier ordering execution of GPU commands and invalidating internal GPU caches.">CommandBuffer::Barrier</a> with the <a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5af28c9a9c0844d5e10b871341d9ce66a4" title="Ensure that all work before the barrier completes before fetching per-draw data for indirect draws an...">BarrierBits::ORDER_INDIRECT_DATA</a> bit set to ensure that the GPU doesn't fetch the indirect data before previous commands are finished writing the data. Waiting via <a class="el" href="classnvn_1_1_queue.html#aca51bcfefab8f580172fb0fd43a0431f" title="Wait until all commands previously submitted to a queue have completed execution.">Queue::Finish</a>, <a class="el" href="classnvn_1_1_queue.html#a339d246e329a173e81d8e1cf2a550113" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">Queue::WaitSync</a>, or <a class="el" href="classnvn_1_1_command_buffer.html#a39ce30782d28ebc2f6d97cbc8658cd41" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">CommandBuffer::WaitSync</a> is not sufficient to ensure that GPU-produced indirect data are not fetched prematurely.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Type of the primitive to render.</td></tr>
    <tr><td class="paramname">type</td><td>Type of index values stored in the index buffer.</td></tr>
    <tr><td class="paramname">indexBuffer</td><td>GPU address of buffer object memory used as the index buffer.</td></tr>
    <tr><td class="paramname">indirectBuffer</td><td>GPU address of buffer object memory holding the indirect draw data. Must be a multiple of 4 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da82b87ce9b727711c195258d53623de05" title="Minimum alignment of indirect draw data.">nvn::DeviceInfo::INDIRECT_DRAW_ALIGNMENT</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bb65434a9927e837c8824130ea71de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb65434a9927e837c8824130ea71de1">&#9670;&nbsp;</a></span>MultiDrawArraysIndirectCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::MultiDrawArraysIndirectCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_draw_primitive.html">DrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>indirectBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>parameterBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxDrawCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render multiple primitives with vertices fetched from a vertex buffer, using draw parameters fetched from an indirect data buffer and the number of primitives fetched from a parameter buffer. </p>
<p>The parameters of the draw are stored in <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object memory using the <a class="el" href="structnvn_1_1_draw_arrays_indirect_data.html" title="Data structure representing values used by indirect DrawArrays commands.">DrawArraysIndirectData</a> structure.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the indirect data or the draw count data are produced by previous commands executed on the GPU, applications must call <a class="el" href="classnvn_1_1_command_buffer.html#a1d9df9457cbd501a6035720f31979752" title="Specify a barrier ordering execution of GPU commands and invalidating internal GPU caches.">CommandBuffer::Barrier</a> with the <a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5af28c9a9c0844d5e10b871341d9ce66a4" title="Ensure that all work before the barrier completes before fetching per-draw data for indirect draws an...">BarrierBits::ORDER_INDIRECT_DATA</a> bit set to ensure that the GPU doesn't fetch the indirect data before previous commands are finished writing the data. Waiting via <a class="el" href="classnvn_1_1_queue.html#aca51bcfefab8f580172fb0fd43a0431f" title="Wait until all commands previously submitted to a queue have completed execution.">Queue::Finish</a>, <a class="el" href="classnvn_1_1_queue.html#a339d246e329a173e81d8e1cf2a550113" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">Queue::WaitSync</a>, or <a class="el" href="classnvn_1_1_command_buffer.html#a39ce30782d28ebc2f6d97cbc8658cd41" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">CommandBuffer::WaitSync</a> is not sufficient to ensure that GPU-produced indirect data are not fetched prematurely.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Type of the primitive to render.</td></tr>
    <tr><td class="paramname">indirectBuffer</td><td>GPU address of buffer object memory holding the indirect draw data. Must be a multiple of 4 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da82b87ce9b727711c195258d53623de05" title="Minimum alignment of indirect draw data.">nvn::DeviceInfo::INDIRECT_DRAW_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">parameterBuffer</td><td>GPU address of buffer object memory holding the draw count. Must be a multiple of 4 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da82b87ce9b727711c195258d53623de05" title="Minimum alignment of indirect draw data.">nvn::DeviceInfo::INDIRECT_DRAW_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">maxDrawCount</td><td>Specifies the maximum number of draws that are allowed. If the draw count in GPU memory pointed to by <em>parameterBuffer</em> is greater than <em>maxDrawCount</em>, only the first <em>maxDrawCount</em> primitives will be drawn.</td></tr>
    <tr><td class="paramname">stride</td><td>Stride (in bytes) between elements in <em>indirectBuffer</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8572e7834fcaff511baf47464075f172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8572e7834fcaff511baf47464075f172">&#9670;&nbsp;</a></span>MultiDrawElementsIndirectCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::MultiDrawElementsIndirectCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_draw_primitive.html">DrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_index_type.html">IndexType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>indexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>indirectBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>parameterBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxDrawCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render multiple primitives with vertex indices fetched from an index buffer, using draw parameters fetched from an indirect data buffer and the number of primitives fetched from a parameter buffer. </p>
<p>The parameters of the draw are stored in buffer object memory using the <a class="el" href="structnvn_1_1_draw_elements_indirect_data.html" title="Data structure representing values used by indirect DrawElements commands.">DrawElementsIndirectData</a> structure.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the indirect data or the draw count data are produced by previous commands executed on the GPU, applications must call <a class="el" href="classnvn_1_1_command_buffer.html#a1d9df9457cbd501a6035720f31979752" title="Specify a barrier ordering execution of GPU commands and invalidating internal GPU caches.">CommandBuffer::Barrier</a> with the <a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5af28c9a9c0844d5e10b871341d9ce66a4" title="Ensure that all work before the barrier completes before fetching per-draw data for indirect draws an...">BarrierBits::ORDER_INDIRECT_DATA</a> bit set to ensure that the GPU doesn't fetch the indirect data before previous commands are finished writing the data. Waiting via <a class="el" href="classnvn_1_1_queue.html#aca51bcfefab8f580172fb0fd43a0431f" title="Wait until all commands previously submitted to a queue have completed execution.">Queue::Finish</a>, <a class="el" href="classnvn_1_1_queue.html#a339d246e329a173e81d8e1cf2a550113" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">Queue::WaitSync</a>, or <a class="el" href="classnvn_1_1_command_buffer.html#a39ce30782d28ebc2f6d97cbc8658cd41" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">CommandBuffer::WaitSync</a> is not sufficient to ensure that GPU-produced indirect data are not fetched prematurely.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Type of the primitive to render.</td></tr>
    <tr><td class="paramname">type</td><td>Type of index values stored in the index buffer.</td></tr>
    <tr><td class="paramname">indexBuffer</td><td>GPU address of buffer object memory used as the index buffer.</td></tr>
    <tr><td class="paramname">indirectBuffer</td><td>GPU address of buffer object memory holding the indirect draw data. Must be a multiple of 4 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da82b87ce9b727711c195258d53623de05" title="Minimum alignment of indirect draw data.">nvn::DeviceInfo::INDIRECT_DRAW_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">parameterBuffer</td><td>GPU address of buffer object memory holding the draw count. Must be a multiple of 4 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da82b87ce9b727711c195258d53623de05" title="Minimum alignment of indirect draw data.">nvn::DeviceInfo::INDIRECT_DRAW_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">maxDrawCount</td><td>Specifies the maximum number of draws that are allowed. If the draw count in GPU memory pointed to by <em>parameterBuffer</em> is greater than <em>maxDrawCount</em>, only the first <em>maxDrawCount</em> primitives will be drawn.</td></tr>
    <tr><td class="paramname">stride</td><td>Stride (in bytes) between elements in <em>indirectBuffer</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61e04c4a4003648f60f65ce05ce8b61f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e04c4a4003648f60f65ce05ce8b61f">&#9670;&nbsp;</a></span>ClearColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::ClearColor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const float *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_clear_color_mask.html">ClearColorMask</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a color buffer using floating-point clear color values. </p>
<p>This command should be used only to clear color buffers with floating-point or <em>normalized</em> signed or unsigned integer components. When clearing color buffers with unnormalized integer components (with formats ending in "I" or "UI"), the values in <code>color</code> will be re-interpreted as integers. For example, clearing an integer color buffer to the value 1.0 will instead clear to 0x3F800000, the IEEE-754 encoding of 1.0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the color target to clear. Must be less than 8 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da51d53fd5085bbb13d9e154bc22e79da4" title="Number of color buffer binding points.">nvn::DeviceInfo::COLOR_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">color</td><td>Array of four floating-point (RGBA) clear color values.</td></tr>
    <tr><td class="paramname">mask</td><td>Bitfield indicating which color channels should be cleared. See <a class="el" href="structnvn_1_1_clear_color_mask.html" title="Specifies the set of color buffer channels enabled for writing.">nvn::ClearColorMask</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_nvn_simple01_screen_space_triangles_2_screen_space_triangles_8cpp-example.html#a7">NvnSimple01ScreenSpaceTriangles/ScreenSpaceTriangles.cpp</a>, <a class="el" href="_nvn_simple02_world_space_triangles_2_world_space_triangles_8cpp-example.html#a12">NvnSimple02WorldSpaceTriangles/WorldSpaceTriangles.cpp</a>, <a class="el" href="_nvn_simple03_textured_cube_2_textured_cube_8cpp-example.html#a42">NvnSimple03TexturedCube/TexturedCube.cpp</a>, <a class="el" href="_nvn_simple04_render_to_texture_2_render_to_texture_8cpp-example.html#a38">NvnSimple04RenderToTexture/RenderToTexture.cpp</a>, <a class="el" href="_nvn_simple05_font_rendering_2_font_rendering_8cpp-example.html#a4">NvnSimple05FontRendering/FontRendering.cpp</a>, <a class="el" href="_nvn_simple06_multi_command_set_2_multi_command_set_8cpp-example.html#a11">NvnSimple06MultiCommandSet/MultiCommandSet.cpp</a>, and <a class="el" href="_nvn_simple07_dynamic_resolution_2_dynamic_resolution_8cpp-example.html#a27">NvnSimple07DynamicResolution/DynamicResolution.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae2279d44a44fd246ef9f9392b8f9e8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2279d44a44fd246ef9f9392b8f9e8bf">&#9670;&nbsp;</a></span>ClearColori()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::ClearColori </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const int *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_clear_color_mask.html">ClearColorMask</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a color buffer using signed integer clear color values. </p>
<p>This command should be used only to clear color buffers with <em>unnormalized</em> signed integer components (with formats ending in "I"). When clearing color buffers with floating-point or normalized integer components, the values in <code>color</code> will be re-interpreted as floating-point values. For example, clearing a floating-point color buffer to the value 0x3F800000 will instead clear to 1.0 (the IEEE-754 floating-point equivalent). When clearing color buffers with unsigned integer components, the signed clear color will be re-interpreted as unsigned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the color target to clear. Must be less than 8 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da51d53fd5085bbb13d9e154bc22e79da4" title="Number of color buffer binding points.">nvn::DeviceInfo::COLOR_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">color</td><td>Array of four signed integer (RGBA) clear color values.</td></tr>
    <tr><td class="paramname">mask</td><td>Bitfield indicating which color channels should be cleared. See <a class="el" href="structnvn_1_1_clear_color_mask.html" title="Specifies the set of color buffer channels enabled for writing.">nvn::ClearColorMask</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b88ad85195c8749ebe41a3c4e9ee250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b88ad85195c8749ebe41a3c4e9ee250">&#9670;&nbsp;</a></span>ClearColorui()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::ClearColorui </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const uint32_t *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_clear_color_mask.html">ClearColorMask</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a color buffer using unsigned integer clear color values. </p>
<p>This command should be used only to clear color buffers with <em>unnormalized</em> unsigned integer components (with formats ending in "UI"). When clearing color buffers with floating-point or normalized integer components, the values in <code>color</code> will be re-interpreted as floating-point values. For example, clearing a floating-point color buffer to the value 0x3F800000 will instead clear to 1.0 (the IEEE-754 floating-point equivalent). When clearing color buffers with signed integer components, the unsigned clear color will be re-interpreted as signed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the color target to clear. Must be less than 8 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da51d53fd5085bbb13d9e154bc22e79da4" title="Number of color buffer binding points.">nvn::DeviceInfo::COLOR_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">color</td><td>Array of four unsigned integer (RGBA) clear color values.</td></tr>
    <tr><td class="paramname">mask</td><td>Bitfield indicating which color channels should be cleared. See <a class="el" href="structnvn_1_1_clear_color_mask.html" title="Specifies the set of color buffer channels enabled for writing.">nvn::ClearColorMask</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a0f6d9771cdf2c4d2ec99fcbc366640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a0f6d9771cdf2c4d2ec99fcbc366640">&#9670;&nbsp;</a></span>ClearDepthStencil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::ClearDepthStencil </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>depthValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>depthMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stencilValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stencilMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a depth/stencil buffer. </p>
<p>This command clears depth and stencil buffers of all formats.</p>
<dl class="section warning"><dt>Warning</dt><dd>On NX and the Windows reference implementation for Turing and older GPUs, calling <a class="el" href="classnvn_1_1_command_buffer.html#a1d9df9457cbd501a6035720f31979752" title="Specify a barrier ordering execution of GPU commands and invalidating internal GPU caches.">CommandBuffer::Barrier</a> with the barrier <a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5a14ad18f3abf9b6bdcf34d22751d399d7" title="Ensure that fragments from after the barrier don&#39;t start until all fragments from before the barrier ...">BarrierBits::ORDER_FRAGMENTS</a> is not sufficient to ensure that previous rendering using the depth/stencil buffer as a texture completes before the depth/stencil buffer clear starts. In such cases, a heavier barrier like <a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5a06a52602108f785ae61f729672885dee" title="Ensure that primitives and compute dispatches from after the barrier don&#39;t start until all such work ...">BarrierBits::ORDER_PRIMITIVES</a> is necessary to ensure that the clear does not corrupt rendering commands submitted prior to the barrier.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthValue</td><td>Floating-point depth clear value (in the range [0.0, 1.0]).</td></tr>
    <tr><td class="paramname">depthMask</td><td>Enable (TRUE) or disable (FALSE) clearing of the depth channel.</td></tr>
    <tr><td class="paramname">stencilValue</td><td>Stencil clear value.</td></tr>
    <tr><td class="paramname">stencilMask</td><td>Mask indicating the bits of the stencil buffer to clear. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_nvn_simple02_world_space_triangles_2_world_space_triangles_8cpp-example.html#a14">NvnSimple02WorldSpaceTriangles/WorldSpaceTriangles.cpp</a>, <a class="el" href="_nvn_simple03_textured_cube_2_textured_cube_8cpp-example.html#a44">NvnSimple03TexturedCube/TexturedCube.cpp</a>, <a class="el" href="_nvn_simple04_render_to_texture_2_render_to_texture_8cpp-example.html#a40">NvnSimple04RenderToTexture/RenderToTexture.cpp</a>, <a class="el" href="_nvn_simple06_multi_command_set_2_multi_command_set_8cpp-example.html#a13">NvnSimple06MultiCommandSet/MultiCommandSet.cpp</a>, and <a class="el" href="_nvn_simple07_dynamic_resolution_2_dynamic_resolution_8cpp-example.html#a29">NvnSimple07DynamicResolution/DynamicResolution.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a0bbd3065ed66e5d9060d0b996a08f427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bbd3065ed66e5d9060d0b996a08f427">&#9670;&nbsp;</a></span>DispatchCompute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::DispatchCompute </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>groupsX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>groupsY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>groupsZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch a new grid of compute shader work groups for processing. </p>
<p>Each compute shader dispatch spawns a three-dimensional array of work groups for processing. Each work group is processed independently, with a three-dimensional array of threads whose size is specified in the compute shader.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupsX</td><td>The number of compute work groups in the X dimension. Must be less than or equal to 65535 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da849abacc772f1a104ea13f836aa1a5e2" title="Maximum number of work groups in the X dimension supported in a compute dispatch.">nvn::DeviceInfo::MAX_COMPUTE_DISPATCH_WORK_GROUPS_X</a>).</td></tr>
    <tr><td class="paramname">groupsY</td><td>The number of compute work groups in the Y dimension. Must be less than or equal to 65535 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da833290b1ad50b175f812c131ecd1f04b" title="Maximum number of work groups in the Y dimension supported in a compute dispatch.">nvn::DeviceInfo::MAX_COMPUTE_DISPATCH_WORK_GROUPS_Y</a>).</td></tr>
    <tr><td class="paramname">groupsZ</td><td>The number of compute work groups in the Z dimension. Must be less than or equal to 65535 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da4b16961c6becc2777028d62df43aa133" title="Maximum number of work groups in the Z dimension supported in a compute dispatch.">nvn::DeviceInfo::MAX_COMPUTE_DISPATCH_WORK_GROUPS_Z</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a007a24940c8df5f378f27832ef65424f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a007a24940c8df5f378f27832ef65424f">&#9670;&nbsp;</a></span>DispatchComputeIndirect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::DispatchComputeIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>indirectBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch a new grid of compute shader work groups for processing. </p>
<p>Each compute shader dispatch spawns a three-dimensional array of work groups for processing. Each work group is processed independently, with a three-dimensional array of threads whose size is specified in the compute shader. The number of compute workgroups in each dimension is read from buffer memory.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the indirect data are produced by previous commands executed on the GPU, applications must call <a class="el" href="classnvn_1_1_command_buffer.html#a1d9df9457cbd501a6035720f31979752" title="Specify a barrier ordering execution of GPU commands and invalidating internal GPU caches.">CommandBuffer::Barrier</a> with the <a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5af28c9a9c0844d5e10b871341d9ce66a4" title="Ensure that all work before the barrier completes before fetching per-draw data for indirect draws an...">BarrierBits::ORDER_INDIRECT_DATA</a> bit set to ensure that the GPU doesn't fetch the indirect data before previous commands are finished writing the data. Waiting via <a class="el" href="classnvn_1_1_queue.html#aca51bcfefab8f580172fb0fd43a0431f" title="Wait until all commands previously submitted to a queue have completed execution.">Queue::Finish</a>, <a class="el" href="classnvn_1_1_queue.html#a339d246e329a173e81d8e1cf2a550113" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">Queue::WaitSync</a>, or <a class="el" href="classnvn_1_1_command_buffer.html#a39ce30782d28ebc2f6d97cbc8658cd41" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">CommandBuffer::WaitSync</a> is not sufficient to ensure that GPU-produced indirect data are not fetched prematurely.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indirectBuffer</td><td>GPU address of buffer object memory holding the indirect dispatch data. Must be a multiple of 4 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da5063e6883b07fbfee84a3833812a7b1d" title="Minimum alignment of indirect dispatch data.">nvn::DeviceInfo::INDIRECT_DISPATCH_ALIGNMENT</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c7f8f6b72d99364f85dbe0e5ebdcaa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c7f8f6b72d99364f85dbe0e5ebdcaa4">&#9670;&nbsp;</a></span>SetViewport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetViewport </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the rectangle for viewport 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Smallest X coordinate of the viewport rectangle.</td></tr>
    <tr><td class="paramname">y</td><td>Smallest Y coordinate of the viewport rectangle.</td></tr>
    <tr><td class="paramname">w</td><td>Width of the viewport rectangle.</td></tr>
    <tr><td class="paramname">h</td><td>Height of the viewport rectangle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_graphics_system_8cpp-example.html#a66">NvnSimple/NvnSimpleSharedLib/GraphicsSystem.cpp</a>, <a class="el" href="_nvn_simple04_render_to_texture_2_render_to_texture_8cpp-example.html#a37">NvnSimple04RenderToTexture/RenderToTexture.cpp</a>, and <a class="el" href="_nvn_simple07_dynamic_resolution_2_dynamic_resolution_8cpp-example.html#a26">NvnSimple07DynamicResolution/DynamicResolution.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a373958d6d0ef429a0b66c37c92abf7b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a373958d6d0ef429a0b66c37c92abf7b2">&#9670;&nbsp;</a></span>SetViewports()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetViewports </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const float *&#160;</td>
          <td class="paramname"><em>ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify one or more viewport rectangles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Index of the first viewport to modify.</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous viewports to set.</td></tr>
    <tr><td class="paramname">ranges</td><td>An array of values to use for the viewports. The array must contain 4 * <em>count</em> values corresponding to the range of viewports specified by <em>first</em> and <em>count</em>. Each quartet of values corresponds to, in order: the smallest X coordinate of the viewport, the smallest Y coordinate of the viewport, the width of the viewport, and the height of the viewport. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad1777a493572b56e2f832d4ea7a646d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1777a493572b56e2f832d4ea7a646d">&#9670;&nbsp;</a></span>SetViewportSwizzles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetViewportSwizzles </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="structnvn_1_1_viewport_swizzle.html">ViewportSwizzle</a> *&#160;</td>
          <td class="paramname"><em>swizzles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a set of viewport swizzle selectors for one or more viewport rectangles. </p>
<p>As part of the viewport transformation, each vertex is transformed by the viewport swizzle operation before the vertex is transformed to screen space. The viewport swizzle produces a four-component swizzled position, where each component is produced by selecting and optionally negating one of the four compenents of the original vertex position. This command specifies sets of four swizzle selectors used to produce the transformed position. The default swizzles for each viewport are POSITIVE_X, POSITIVE_Y, POSITIVE_Z, and POSITIVE_W, which specify no change to the incoming position.</p>
<dl class="section note"><dt>Note</dt><dd>There is a separate set of four viewport swizzle values for each viewport. A primitive broadcast to multiple viewports will have a separate swizzle applied for each viewport.</dd>
<dd>
Viewport swizzles rasterization is only supported on NX and second-generation Maxwell and later GPUs. Query the SUPPORTS_VIEWPORT_SWIZZLE device property to determine if this command is supported.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Index of the first viewport to modify.</td></tr>
    <tr><td class="paramname">count</td><td>Number of consecutive viewports to update.</td></tr>
    <tr><td class="paramname">swizzles</td><td>An array of swizzle values to use for the viewports. This array must contain 4 * <em>count</em> values corresponding to the range of viewports specified by <em>first</em> and <em>count</em>. Each set of four values identifies the input position component used for the X, Y, Z, and W components, respectively, of the position vector produced by the viewport swizzle operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f511de71b6bec1603e68bb8fd5ba424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f511de71b6bec1603e68bb8fd5ba424">&#9670;&nbsp;</a></span>SetScissor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetScissor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the scissor rectangle used for clipping primitives and clears. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Smallest X coordinate of the scissor rectangle.</td></tr>
    <tr><td class="paramname">y</td><td>Smallest Y coordinate of the scissor rectangle.</td></tr>
    <tr><td class="paramname">w</td><td>Width of the scissor rectangle.</td></tr>
    <tr><td class="paramname">h</td><td>Height of the scissor rectangle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_graphics_system_8cpp-example.html#a65">NvnSimple/NvnSimpleSharedLib/GraphicsSystem.cpp</a>, <a class="el" href="_nvn_simple04_render_to_texture_2_render_to_texture_8cpp-example.html#a36">NvnSimple04RenderToTexture/RenderToTexture.cpp</a>, and <a class="el" href="_nvn_simple07_dynamic_resolution_2_dynamic_resolution_8cpp-example.html#a25">NvnSimple07DynamicResolution/DynamicResolution.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af379c72c350eeb7623d498d10067b8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af379c72c350eeb7623d498d10067b8f3">&#9670;&nbsp;</a></span>SetScissors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetScissors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const int *&#160;</td>
          <td class="paramname"><em>rects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify one or more scissor rectangles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Index of the first scissor rectangle to modify.</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous scissor rectangles to set.</td></tr>
    <tr><td class="paramname">rects</td><td>An array of values to use for the scissor rectangles. The array must contain 4 * <em>count</em> values corresponding to the range of scissor rectangles specified by <em>first</em> and <em>count</em>. Each quartet of values corresponds to, in order: the smallest X coordinate of the rectangle, the smallest Y coordinate of the rectangle, the width of the rectangle, and the height of the rectangle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8271958565ab72d7a3dc216a5bcf13c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8271958565ab72d7a3dc216a5bcf13c7">&#9670;&nbsp;</a></span>SetDepthRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetDepthRange </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the range of depth values for rendered primitives. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Depth value corresponding to the near clip plane.</td></tr>
    <tr><td class="paramname">f</td><td>Depth value corresponding to the far clip plane. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac89b302622bedfbe4d1efe8f6c070f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89b302622bedfbe4d1efe8f6c070f5a">&#9670;&nbsp;</a></span>SetDepthBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetDepthBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control the operation of the depth bounds test. </p>
<p>This command lets applications enable or disable the depth bounds test. When enabled, the depth bounds test will discard any fragments where the stored Z value in the depth buffer is outside the range [<em>n</em>, <em>f</em>]. By default, the depth bounds test is disabled.</p>
<dl class="section warning"><dt>Warning</dt><dd>When the depth bounds test is enabled, <em>n</em> must be less than or equal to <em>f</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Enable or disable the depth bounds test.</td></tr>
    <tr><td class="paramname">n</td><td>Minimum value of the depth bounds test range.</td></tr>
    <tr><td class="paramname">f</td><td>Maximum value of the depth bounds test range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64e4979f26c85f912363be9b5f1ab121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e4979f26c85f912363be9b5f1ab121">&#9670;&nbsp;</a></span>SetDepthRanges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetDepthRanges </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const float *&#160;</td>
          <td class="paramname"><em>ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets multiple ranges of depth values for rendered primitives. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Index of the first depth range to modify.</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous depth ranges to set.</td></tr>
    <tr><td class="paramname">ranges</td><td>An array of values to use for the depth ranges. It must contain <em>count</em> pairs of values corresponding to the depth ranges specified by <em>first</em> and <em>count</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9013640ac6720f99139509a1763df6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9013640ac6720f99139509a1763df6c1">&#9670;&nbsp;</a></span>SetTiledCacheAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetTiledCacheAction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_tiled_cache_action.html">TiledCacheAction</a>&#160;</td>
          <td class="paramname"><em>action</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a specified operation related to tiled caching. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>Tiled caching operation to perform. Actions include enabling, disabling, or flushing the tiled cache binner. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c0390349017d16e8481942f520fba95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c0390349017d16e8481942f520fba95">&#9670;&nbsp;</a></span>SetTiledCacheTileSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetTiledCacheTileSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tileWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tileHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the tile size used for tiled caching. </p>
<p>If the tile size has changed, the hardware will automatically flush the tiled cache binner. The tile size is clamped to [16, 16384] in either dimension.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tileWidth</td><td>Sets the tile width, in pixels.</td></tr>
    <tr><td class="paramname">tileHeight</td><td>Sets the tile height, in pixels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c573173dbcfeda3576f8bf6ed55407e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c573173dbcfeda3576f8bf6ed55407e">&#9670;&nbsp;</a></span>BindSeparateTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindSeparateTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_separate_texture_handle.html">SeparateTextureHandle</a>&#160;</td>
          <td class="paramname"><em>textureHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a separate <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> to use for texture mapping in shaders. </p>
<p>This command binds a separate texture handle (without sampler information) for use with shaders using separate texture types. These bindings are not used for variables with combined sampler types (such as "sampler2D" in GLSL shaders).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>Shader stage owning the separate <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> binding point to update.</td></tr>
    <tr><td class="paramname">index</td><td>Separate <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> binding point number to update. Must be less than 128 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da25359ca20239ea0f5fbc532549f60c65" title="Number of separate texture bindings supported for each shader stage.">nvn::DeviceInfo::SEPARATE_TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">textureHandle</td><td>Separate <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> handle for the separate <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> object to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab753effba29b618dcf425e42ecb392c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab753effba29b618dcf425e42ecb392c6">&#9670;&nbsp;</a></span>bindSeparateTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::bindSeparateTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_separate_texture_handle.html">SeparateTextureHandle</a>&#160;</td>
          <td class="paramname"><em>textureHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a separate <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> to use for texture mapping in shaders. </p>
<p>Deprecated in favor of <a class="el" href="classnvn_1_1_command_buffer.html#a3c573173dbcfeda3576f8bf6ed55407e" title="Bind a separate Texture to use for texture mapping in shaders.">CommandBuffer::BindSeparateTexture</a>.</p>
<p>This command binds a separate texture handle (without sampler information) for use with shaders using separate texture types. These bindings are not used for variables with combined sampler types (such as "sampler2D" in GLSL shaders).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>Shader stage owning the separate <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> binding point to update.</td></tr>
    <tr><td class="paramname">index</td><td>Separate <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> binding point number to update. Must be less than 128 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da25359ca20239ea0f5fbc532549f60c65" title="Number of separate texture bindings supported for each shader stage.">nvn::DeviceInfo::SEPARATE_TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">textureHandle</td><td>Separate <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> handle for the separate <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> object to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32a0cf86766888156ef4f1b50f2095e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a0cf86766888156ef4f1b50f2095e1">&#9670;&nbsp;</a></span>BindSeparateSampler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindSeparateSampler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_separate_sampler_handle.html">SeparateSamplerHandle</a>&#160;</td>
          <td class="paramname"><em>samplerHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a separate <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">Sampler</a> to use for texture mapping in shaders. </p>
<p>This command binds a separate sampler handle (without texture information) for use with shaders using separate sampler types. These bindings are not used for variables with combined sampler types (such as "sampler2D" in GLSL shaders).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>Shader stage owning the separate <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">Sampler</a> binding point to update.</td></tr>
    <tr><td class="paramname">index</td><td>Separate <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">Sampler</a> binding point number to update. Must be less than 32 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dace1448da822e985f3a949b09f7827a8b" title="Number of separate sampler bindings supported for each shader stage.">nvn::DeviceInfo::SEPARATE_SAMPLER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">samplerHandle</td><td>Separate <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">Sampler</a> handle for the separate <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">Sampler</a> object to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a148ad5b6d2eda66976f2161bb7729b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a148ad5b6d2eda66976f2161bb7729b89">&#9670;&nbsp;</a></span>bindSeparateSampler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::bindSeparateSampler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_separate_sampler_handle.html">SeparateSamplerHandle</a>&#160;</td>
          <td class="paramname"><em>samplerHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a separate <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">Sampler</a> to use for texture mapping in shaders. </p>
<p>Deprecated in favor of <a class="el" href="classnvn_1_1_command_buffer.html#a32a0cf86766888156ef4f1b50f2095e1" title="Bind a separate Sampler to use for texture mapping in shaders.">CommandBuffer::BindSeparateSampler</a>.</p>
<p>This command binds a separate sampler handle (without texture information) for use with shaders using separate sampler types. These bindings are not used for variables with combined sampler types (such as "sampler2D" in GLSL shaders).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>Shader stage owning the separate <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">Sampler</a> binding point to update.</td></tr>
    <tr><td class="paramname">index</td><td>Separate <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">Sampler</a> binding point number to update. Must be less than 32 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dace1448da822e985f3a949b09f7827a8b" title="Number of separate sampler bindings supported for each shader stage.">nvn::DeviceInfo::SEPARATE_SAMPLER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">samplerHandle</td><td>Separate <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">Sampler</a> handle for the separate <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">Sampler</a> object to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e12db39b6d1672fee21a7915219c621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e12db39b6d1672fee21a7915219c621">&#9670;&nbsp;</a></span>BindSeparateTextures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindSeparateTextures </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="structnvn_1_1_separate_texture_handle.html">SeparateTextureHandle</a> *&#160;</td>
          <td class="paramname"><em>textureHandles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more separate textures to use for texture mapping in shaders. </p>
<p>This command binds one or more separate texture handles (without sampler information) for use with shaders using separate texture types. These bindings are not used for variables with combined sampler types (such as "sampler2D" in GLSL shaders). This command is equivalent to making multiple calls to BindSeparateTexture.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding points to update.</td></tr>
    <tr><td class="paramname">first</td><td>First separate texture binding point number to update. Must be less than 128 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da25359ca20239ea0f5fbc532549f60c65" title="Number of separate texture bindings supported for each shader stage.">nvn::DeviceInfo::SEPARATE_TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous separate texture binding points to update. Must be less than or equal to 128 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da25359ca20239ea0f5fbc532549f60c65" title="Number of separate texture bindings supported for each shader stage.">nvn::DeviceInfo::SEPARATE_TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">textureHandles</td><td>Array of handles of separate <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> objects to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80cb59e7b9cf2c3722d5b9f90815f57c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80cb59e7b9cf2c3722d5b9f90815f57c">&#9670;&nbsp;</a></span>BindSeparateSamplers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindSeparateSamplers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="structnvn_1_1_separate_sampler_handle.html">SeparateSamplerHandle</a> *&#160;</td>
          <td class="paramname"><em>samplerHandles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more Samplers to use for texture mapping in shaders. </p>
<p>This command binds one or more separate sampler handles (without texture information) for use with shaders using separate sampler types. These bindings are not used for variables with combined sampler types (such as "sampler2D" in GLSL shaders). This command is equivalent to making multiple calls to BindSeparateSampler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding points to update.</td></tr>
    <tr><td class="paramname">first</td><td>First separate sampler binding point number to update. Must be less than 32 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dace1448da822e985f3a949b09f7827a8b" title="Number of separate sampler bindings supported for each shader stage.">nvn::DeviceInfo::SEPARATE_SAMPLER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous separate sampler binding points to update. Must be less than or equal to 32 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dace1448da822e985f3a949b09f7827a8b" title="Number of separate sampler bindings supported for each shader stage.">nvn::DeviceInfo::SEPARATE_SAMPLER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">samplerHandles</td><td>Array of handles of separate <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">Sampler</a> objects to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36a1ea897a32a20f0603f86d372e8c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a1ea897a32a20f0603f86d372e8c52">&#9670;&nbsp;</a></span>BindSeparateTexturesDeferred()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindSeparateTexturesDeferred </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnvn_1_1_separate_texture_handle.html">SeparateTextureHandle</a> *&#160;</td>
          <td class="paramname"><em>textureHandles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more separate textures to use for texture mapping in shaders. </p>
<p>This command binds one or more separate texture handles (without sampler information) for use with shaders using separate texture types. These bindings are not used for variables with combined sampler types (such as "sampler2D" in GLSL shaders). This command is equivalent to making multiple calls to BindSeparateTexture.</p>
<p>When recording this command, the pointer to the set of separate texture handles is not dereferenced when the command set is recorded. Instead, it is dereferenced only when the command set containing this command is submitted to a queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding points to update.</td></tr>
    <tr><td class="paramname">first</td><td>First separate texture binding point number to update. Must be less than 128 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da25359ca20239ea0f5fbc532549f60c65" title="Number of separate texture bindings supported for each shader stage.">nvn::DeviceInfo::SEPARATE_TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous separate texture binding points to update. Must be less than or equal to 128 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da25359ca20239ea0f5fbc532549f60c65" title="Number of separate texture bindings supported for each shader stage.">nvn::DeviceInfo::SEPARATE_TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">textureHandles</td><td>Array of handles of separate <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> objects to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2da8679714d52e36ff1aaf5190255866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da8679714d52e36ff1aaf5190255866">&#9670;&nbsp;</a></span>BindSeparateTexturesDeferred_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindSeparateTexturesDeferred_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnvn_1_1_separate_texture_handle.html">SeparateTextureHandle</a> *&#160;</td>
          <td class="paramname"><em>textureHandles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more separate textures to use for texture mapping in shaders. </p>
<p>Fastpath variant.</p>
<p>This command binds one or more separate texture handles (without sampler information) for use with shaders using separate texture types. These bindings are not used for variables with combined sampler types (such as "sampler2D" in GLSL shaders). This command is equivalent to making multiple calls to BindSeparateTexture.</p>
<p>When recording this command, the pointer to the set of separate texture handles is not dereferenced when the command set is recorded. Instead, it is dereferenced only when the command set containing this command is submitted to a queue.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to <a class="el" href="classnvn_1_1_command_buffer.html#a36a1ea897a32a20f0603f86d372e8c52" title="Bind one or more separate textures to use for texture mapping in shaders.">CommandBuffer::BindSeparateTexturesDeferred</a>, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding points to update.</td></tr>
    <tr><td class="paramname">first</td><td>First separate texture binding point number to update. Must be less than 128 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da25359ca20239ea0f5fbc532549f60c65" title="Number of separate texture bindings supported for each shader stage.">nvn::DeviceInfo::SEPARATE_TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous separate texture binding points to update. Must be less than or equal to 128 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da25359ca20239ea0f5fbc532549f60c65" title="Number of separate texture bindings supported for each shader stage.">nvn::DeviceInfo::SEPARATE_TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">textureHandles</td><td>Array of handles of separate <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> objects to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad92b5310f827c5a5490107e794a73c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad92b5310f827c5a5490107e794a73c0e">&#9670;&nbsp;</a></span>BindSeparateSamplersDeferred()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindSeparateSamplersDeferred </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnvn_1_1_separate_sampler_handle.html">SeparateSamplerHandle</a> *&#160;</td>
          <td class="paramname"><em>samplerHandles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more Samplers to use for texture mapping in shaders. </p>
<p>This command binds one or more separate sampler handles (without texture information) for use with shaders using separate sampler types. These bindings are not used for variables with combined sampler types (such as "sampler2D" in GLSL shaders). This command is equivalent to making multiple calls to BindSeparateSampler.</p>
<p>When recording this command, the pointer to the set of separate sampler handles is not dereferenced when the command set is recorded. Instead, it is dereferenced only when the command set containing this command is submitted to a queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding points to update.</td></tr>
    <tr><td class="paramname">first</td><td>First separate sampler binding point number to update. Must be less than 32 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dace1448da822e985f3a949b09f7827a8b" title="Number of separate sampler bindings supported for each shader stage.">nvn::DeviceInfo::SEPARATE_SAMPLER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous separate sampler binding points to update. Must be less than or equal to 32 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dace1448da822e985f3a949b09f7827a8b" title="Number of separate sampler bindings supported for each shader stage.">nvn::DeviceInfo::SEPARATE_SAMPLER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">samplerHandles</td><td>Array of handles of separate <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">Sampler</a> objects to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48dcbbf6918247308a2b3ec2edf04c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48dcbbf6918247308a2b3ec2edf04c7e">&#9670;&nbsp;</a></span>BindSeparateSamplersDeferred_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindSeparateSamplersDeferred_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnvn_1_1_separate_sampler_handle.html">SeparateSamplerHandle</a> *&#160;</td>
          <td class="paramname"><em>samplerHandles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more Samplers to use for texture mapping in shaders. </p>
<p>Fastpath variant.</p>
<p>This command binds one or more separate sampler handles (without texture information) for use with shaders using separate sampler types. These bindings are not used for variables with combined sampler types (such as "sampler2D" in GLSL shaders). This command is equivalent to making multiple calls to BindSeparateSampler.</p>
<p>When recording this command, the pointer to the set of separate sampler handles is not dereferenced when the command set is recorded. Instead, it is dereferenced only when the command set containing this command is submitted to a queue.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to <a class="el" href="classnvn_1_1_command_buffer.html#ad92b5310f827c5a5490107e794a73c0e" title="Bind one or more Samplers to use for texture mapping in shaders.">CommandBuffer::BindSeparateSamplersDeferred</a>, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding points to update.</td></tr>
    <tr><td class="paramname">first</td><td>First separate sampler binding point number to update. Must be less than 32 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dace1448da822e985f3a949b09f7827a8b" title="Number of separate sampler bindings supported for each shader stage.">nvn::DeviceInfo::SEPARATE_SAMPLER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous separate sampler binding points to update. Must be less than or equal to 32 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dace1448da822e985f3a949b09f7827a8b" title="Number of separate sampler bindings supported for each shader stage.">nvn::DeviceInfo::SEPARATE_SAMPLER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">samplerHandles</td><td>Array of handles of separate <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">Sampler</a> objects to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a719b4e44b46242d14ff81d3af76af169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719b4e44b46242d14ff81d3af76af169">&#9670;&nbsp;</a></span>SetStencilValueMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetStencilValueMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_face.html">Face</a>&#160;</td>
          <td class="paramname"><em>faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a mask that will be applied to the stencil index and reference values prior to performing the stencil test. </p>
<p>There are separate stencil value masks for front- and back-facing primitives. This function can update the value of either or both masks. If stencil testing is disabled, the stencil value mask has no effect. The default value for both front and back masks is 0xFF (all bits set).</p>
<dl class="section note"><dt>Note</dt><dd>In API versions prior to 53.8, the default mask was unintentionally set to zero.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">faces</td><td>Specifies the face(s) (front and/or back) using the new stencil value mask.</td></tr>
    <tr><td class="paramname">mask</td><td>Mask to be applied to stencil index and reference values prior to the stencil test </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c6ae23a1825ecc510d9e9ec06c743ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c6ae23a1825ecc510d9e9ec06c743ee">&#9670;&nbsp;</a></span>SetStencilMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetStencilMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_face.html">Face</a>&#160;</td>
          <td class="paramname"><em>faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a mask to apply to stencil values written by the stencil test. </p>
<p>Bits in the existing stencil index corresponding to zero bits in the stencil mask will not be updated by the stencil test. There are separate stencil masks for front- and back-facing primitives. This function can update the value of either or both masks. If stencil testing is disabled, the stencil mask has no effect. The default value for both front and back masks is 0xFF (all bits set).</p>
<dl class="section note"><dt>Note</dt><dd>In API versions prior to 53.8, the default mask was unintentionally set to zero.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">faces</td><td>Specifies the face(s) (front and/or back) using the new stencil mask.</td></tr>
    <tr><td class="paramname">mask</td><td>Mask to apply to stencil values written by the stencil test. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33326a59db6cab792fd729fbbd223512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33326a59db6cab792fd729fbbd223512">&#9670;&nbsp;</a></span>SetStencilRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetStencilRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_face.html">Face</a>&#160;</td>
          <td class="paramname"><em>faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a stencil reference value used by the stencil test. </p>
<p>There are separate reference values for front- and back-facing primitives. This function can update the value of either or both values. If stencil testing is disabled, the stencil reference value has no effect. The default reference value for both front and back is zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">faces</td><td>Specifies the face(s) (front and/or back) using the new stencil reference value.</td></tr>
    <tr><td class="paramname">ref</td><td>Stencil reference value used by the stencil test. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89a986e1674a5b2182666efb95538c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a986e1674a5b2182666efb95538c89">&#9670;&nbsp;</a></span>SetBlendColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetBlendColor </td>
          <td>(</td>
          <td class="paramtype">NVN_NOESCAPE const float *&#160;</td>
          <td class="paramname"><em>blendColor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies a constant color that may be used by blending functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blendColor</td><td>Array of four floating-point (RGBA) blend color values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5dca4b84f62fb292de2ec41305209c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dca4b84f62fb292de2ec41305209c55">&#9670;&nbsp;</a></span>SetPointSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetPointSize </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pointSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the size (in pixels) of point primitives to render. </p>
<p>If the last enabled vertex, tessellation control, tessellation evaluation, or geometry shader writes to gl_PointSize, this value is ignored and point size written in that shader will be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointSize</td><td>Size (in pixels) of point primitives to render. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f74340d8bd83898f7dda56cc0461e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f74340d8bd83898f7dda56cc0461e51">&#9670;&nbsp;</a></span>SetLineWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetLineWidth </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lineWidth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the width (in pixels) of line primitives to render. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lineWidth</td><td>Width (in pixels) of line primitives to render. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a720e42e18e9818a05cc73ed7fa04a748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a720e42e18e9818a05cc73ed7fa04a748">&#9670;&nbsp;</a></span>SetPolygonOffsetClamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetPolygonOffsetClamp </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>units</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>clamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies values used to compute a depth offset value when polygon offset is enabled. </p>
<p>The offset is computed by multiplying the maximum depth slope of the primitive [sqrt((dz/dx)^2 + (dz/dy)^2)] by <em>factor</em>, adding in the minimum resolvable difference in depth values multiplied by <em>units</em>, and clamping the result as described in the documentation for <em>clamp</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>Value multiplied by the maximum depth slope when computing offset.</td></tr>
    <tr><td class="paramname">units</td><td>Value multiplied by the minimum resolvable depth difference when computing offset.</td></tr>
    <tr><td class="paramname">clamp</td><td>Value used to clamp the computed offset. If <code>clamp</code> is positive, the computed depth offset will be clamped to a value less than or equal to <code>clamp</code>. If <code>clamp</code> is negative, the computed depth offset will be clamped to a value greater than or equal to <code>clamp</code>. If <code>clamp</code> is zero, the computed depth offset will not be clamped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7edd6a2e5bceb5db2ab83cbc9724221e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7edd6a2e5bceb5db2ab83cbc9724221e">&#9670;&nbsp;</a></span>SetAlphaRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetAlphaRef </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies a reference value to use for alpha testing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref</td><td>Reference value for the alpha test. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4aecd213fbf83199c53b4ce455fab481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aecd213fbf83199c53b4ce455fab481">&#9670;&nbsp;</a></span>SetSampleMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetSampleMask </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies a mask of samples that may be covered by rendered primitives. </p>
<p>If bit N is zero in the provided mask, sample N will never be considered to be covered when rasterizing primitives.</p>
<p>The default sample mask is ~0 (all bits enabled).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Mask of samples that may be covered by rendered primitives. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20400dc9d0edb9f7069d83c3b6106b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20400dc9d0edb9f7069d83c3b6106b38">&#9670;&nbsp;</a></span>SetRasterizerDiscard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetRasterizerDiscard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>discard</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable rasterizer discard. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">discard</td><td>True if primitives should be discarded; false (default) otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1198f8f3d6d2a20bf4e2b254c679f523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1198f8f3d6d2a20bf4e2b254c679f523">&#9670;&nbsp;</a></span>SetDepthClamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetDepthClamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>clamp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/disable depth clamping of rendered primitives. </p>
<p>When enabled, primitives are not clipped to the near and far clip planes. Instead, primitives are rasterized without clipping in Z, and interpolated Z values are clamped to the extents of the depth range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clamp</td><td>TRUE if depth clamping should be enabled; FALSE otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa91972f2ddf79b233d4abf26838c82f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91972f2ddf79b233d4abf26838c82f5">&#9670;&nbsp;</a></span>SetConservativeRasterEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetConservativeRasterEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/disable conservative rasterization of rendered primitives. </p>
<p>Conservative rasterization is only supported on second-generation Maxwell and later GPUs. Query the SUPPORTS_CONSERVATIVE_RASTER device property to determine support.</p>
<p>By default, conservative rasterization is disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>TRUE if conservative rasterization should be enabled; FALSE, otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c86df94525318a4cb2116b4f9194c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c86df94525318a4cb2116b4f9194c03">&#9670;&nbsp;</a></span>SetConservativeRasterDilate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetConservativeRasterDilate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dilate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the degree of primitive dilation when conservative rasterization is enabled. </p>
<p>This provides a mechanism for "over-conservative" rasterization by dilating (expanding) primitives prior to rasterization. <em>dilate</em> is automatically clamped to the range [0.0, 0.75] and rounded up to a multiple of 0.25. When <em>dilate</em> is 0.0, ordinary conservative rasterization is performed. When dilate is greater than 0.0, rasterized primitives are dilated by <em>dilate</em> pixels. If conservative rasterization is disabled, dilation has no effect on rasterization. This function is only supported on second-generation Maxwell and later GPUs. Query the SUPPORTS_CONSERVATIVE_RASTER device property to determine support.</p>
<p>By default, conservative rasterization is disabled.</p>
<dl class="section warning"><dt>Warning</dt><dd>Changing the dilation setting requires idling the GPU and results in reduced performance. Applications should avoid changing the dilation factor frequently.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dilate</td><td>The fraction of a pixel by which to dilate rasterized primitives. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea06553acf05d4707402343486a0125c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea06553acf05d4707402343486a0125c">&#9670;&nbsp;</a></span>SetSubpixelPrecisionBias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetSubpixelPrecisionBias </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>yBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the number of additional bits of subpixel precision to be used for primitive rasterization when conservative rasterization is enabled. </p>
<p>When vertices are transformed to window coordinates, they are snapped to fixed-point positions. By default, the number of bits of fractional precision within a pixel is given by the device property SUBPIXEL_BITS. This function enables applications to increase the subpixel precision for snapped vertex positions. If conservative rasterization is disabled, additional bias bits have no effect on rasterization.</p>
<p>Additional subpixel precision allows for consistent conservative rasterization when rendering the same geometry at different resolutions. Rasterizing a scene at 64x64 with 3 extra subpixel bits in X and Y will have the same snapping behavior as rasterizing the same scene at 512x512 with no extra subpixel bits.</p>
<p>By default, the subpixel precision bias is 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xBits</td><td>The number of additional bits of subpixel precision in the horizontal direction. Must be less than or equal to 8 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da0a093fe4329331a5678ccbe2070ad523" title="The maximum number of additional bits of subpixel precision that can be used to represent vertex wind...">nvn::DeviceInfo::MAX_SUBPIXEL_BIAS_BITS</a>).</td></tr>
    <tr><td class="paramname">yBits</td><td>The number of additional bits of subpixel precision in the vertical direction. Must be less than or equal to 8 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da0a093fe4329331a5678ccbe2070ad523" title="The maximum number of additional bits of subpixel precision that can be used to represent vertex wind...">nvn::DeviceInfo::MAX_SUBPIXEL_BIAS_BITS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3573269dfa045bfc0673173a8f55fb34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3573269dfa045bfc0673173a8f55fb34">&#9670;&nbsp;</a></span>CopyBufferToTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::CopyBufferToTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *&#160;</td>
          <td class="paramname"><em>dstTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *&#160;</td>
          <td class="paramname"><em>dstView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="structnvn_1_1_copy_region.html">CopyRegion</a> *&#160;</td>
          <td class="paramname"><em>dstRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_copy_flags.html">CopyFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy texture data from buffer memory into a region of a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Address of the buffer holding the source data for the copy.</td></tr>
    <tr><td class="paramname">dstTexture</td><td><a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> object used as the destination for the copy.</td></tr>
    <tr><td class="paramname">dstView</td><td>View of the texture object used as the destination for the copy. A texture view, if specified, can be used to override properties of the corresponding texture <em>dstTexture</em>. This parameter identifies a specific mipmap level, set of layers or alternate format in the specified texture. Other fields, such as swizzle, are ignored. If NULL is specified, the base level of the texture <em>dstTexture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">dstRegion</td><td>Region of the destination texture to update for the copy.</td></tr>
    <tr><td class="paramname">flags</td><td>Specifies options used when performing the copy. See <a class="el" href="structnvn_1_1_copy_flags.html" title="Flags controlling the operation of copy commands.">nvn::CopyFlags</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a776e2215df7bf908253d82689ead67b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776e2215df7bf908253d82689ead67b5">&#9670;&nbsp;</a></span>CopyTextureToBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::CopyTextureToBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *&#160;</td>
          <td class="paramname"><em>srcTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *&#160;</td>
          <td class="paramname"><em>srcView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="structnvn_1_1_copy_region.html">CopyRegion</a> *&#160;</td>
          <td class="paramname"><em>srcRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_copy_flags.html">CopyFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy texture data from a region of a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> object into buffer memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcTexture</td><td><a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> object used as the source for the copy.</td></tr>
    <tr><td class="paramname">srcView</td><td>View of the texture object used as the source for the copy. A texture view, if specified, can be used to override properties of the corresponding texture <em>srcTexture</em>. This parameter identifies a specific mipmap level, set of layers or alternate format in the specified texture. Other fields, such as swizzle, are ignored. If NULL is specified, the base level of the texture <em>srcTexture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">srcRegion</td><td>Region of the source texture to copy from.</td></tr>
    <tr><td class="paramname">dst</td><td>Address of the buffer holding the destination data for the copy.</td></tr>
    <tr><td class="paramname">flags</td><td>Specifies options used when performing the copy. See <a class="el" href="structnvn_1_1_copy_flags.html" title="Flags controlling the operation of copy commands.">nvn::CopyFlags</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc27996fe951eb5f8f9c852c0dca88f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc27996fe951eb5f8f9c852c0dca88f7">&#9670;&nbsp;</a></span>CopyTextureToTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::CopyTextureToTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *&#160;</td>
          <td class="paramname"><em>srcTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *&#160;</td>
          <td class="paramname"><em>srcView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="structnvn_1_1_copy_region.html">CopyRegion</a> *&#160;</td>
          <td class="paramname"><em>srcRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *&#160;</td>
          <td class="paramname"><em>dstTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *&#160;</td>
          <td class="paramname"><em>dstView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="structnvn_1_1_copy_region.html">CopyRegion</a> *&#160;</td>
          <td class="paramname"><em>dstRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_copy_flags.html">CopyFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy texture data from a region of one <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> object into a region of another <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> object. </p>
<p>Copies texture data from the region <em>srcRegion</em> of a view of the source texture to the region <em>dstRegion</em> of a view of the destination texture. If <em>srcRegion</em> and <em>dstRegion</em> are of different sizes, the source region will be scaled when copying. If <a class="el" href="structnvn_1_1_copy_flags.html#a842a139af223dd08e0db4b17204272b2af6f7c3a32fa4f4fb75acb0ec66d1c527" title="Enable linear filtering for texture-to-texture copies.">CopyFlags::LINEAR_FILTER</a> is set in <em>flags</em> when scaling, the copy will average texels from the source. Otherwise, the copy will select the nearest source texel for each destination texel.</p>
<dl class="section note"><dt>Note</dt><dd>If the source and destination regions overlap in memory, the results of the copy will be undefined.</dd>
<dd>
Filtering across layers of a source texture is not supported; the number of layers in <em>srcRegion</em> and <em>dstRegion</em> must match.</dd>
<dd>
Linear filtering is supported for a limited subset of source and destination formats, as documented in the Programming Guide.</dd>
<dd>
Copies involving multisample textures are not supported.</dd>
<dd>
Copies of compressed formats must be aligned on compression block boundaries and do not support scaling.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcTexture</td><td><a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> object holding the source data for the copy.</td></tr>
    <tr><td class="paramname">srcView</td><td>View of the texture object used as the source for the copy. A texture view, if specified, can be used to override properties of the corresponding texture <em>srcTexture</em>. This parameter identifies a specific mipmap level, set of layers or alternate format in the specified texture. Other fields, such as swizzle, are ignored. If NULL is specified, the base level of the texture <em>srcTexture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">srcRegion</td><td>Region of the source texture to read from.</td></tr>
    <tr><td class="paramname">dstTexture</td><td><a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> object used as the destination for the copy.</td></tr>
    <tr><td class="paramname">dstView</td><td>View of the texture object used as the destination for the copy. A texture view, if specified, can be used to override properties of the corresponding texture <em>dstTexture</em>. This parameter identifies a specific mipmap level, set of layers or alternate format in the specified texture. Other fields, such as swizzle, are ignored. If NULL is specified, the base level of the texture <em>dstTexture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">dstRegion</td><td>Region of the destination texture to write to.</td></tr>
    <tr><td class="paramname">flags</td><td>Specifies options used when performing the copy. See <a class="el" href="structnvn_1_1_copy_flags.html" title="Flags controlling the operation of copy commands.">nvn::CopyFlags</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6785390e813c50f1394d8f3e44de924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6785390e813c50f1394d8f3e44de924">&#9670;&nbsp;</a></span>CopyBufferToBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::CopyBufferToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_copy_flags.html">CopyFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule a copy of data from one <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object into another <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Address of the buffer holding the source data for the copy.</td></tr>
    <tr><td class="paramname">dst</td><td>Address of the buffer holding the destination data for the copy.</td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to copy between source and destination buffers.</td></tr>
    <tr><td class="paramname">flags</td><td>Specifies options used when performing the copy. See of <a class="el" href="structnvn_1_1_copy_flags.html" title="Flags controlling the operation of copy commands.">nvn::CopyFlags</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af55c2ab50e7a8e474a12f55c640b0e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af55c2ab50e7a8e474a12f55c640b0e8c">&#9670;&nbsp;</a></span>ClearBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::ClearBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a buffer to a 32-bit integer value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>Address of the buffer holding the destination data for the clear. This address should be aligned to 4 bytes.</td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to clear. Size must be a multiple of four. Clears with zero size are treated as no-ops.</td></tr>
    <tr><td class="paramname">value</td><td>32-bit integer value to clear with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acba967469608c76841e41d2b4546f8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba967469608c76841e41d2b4546f8bd">&#9670;&nbsp;</a></span>ClearTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::ClearTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *&#160;</td>
          <td class="paramname"><em>dstTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *&#160;</td>
          <td class="paramname"><em>dstView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="structnvn_1_1_copy_region.html">CopyRegion</a> *&#160;</td>
          <td class="paramname"><em>dstRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const float *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_clear_color_mask.html">ClearColorMask</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a color buffer using floating point clear color values. </p>
<p>Clears texture data from the region <em>region</em> of a view of the destination texture.</p>
<p>This command supports only texture formats that can be bound as a render target. Please refer to the 'Render' column in the programming guide's <a class="el" href="nvn_index.html#nvn_guide_formats_table">formats table</a> for supported formats.</p>
<dl class="section warning"><dt>Warning</dt><dd>Unlike Copy commands, ClearTexure renders to the texture using the 3D Engine. Before accessing the cleared texture, applications must ensure that the GPU commands producing the new data have completed with <a class="el" href="structnvn_1_1_barrier_bits.html" title="Controls the ordering of commands and invalidation of caches for CommandBuffer::Barrier.">BarrierBits</a> of ORDER_FRAGMENTS and INVALIDATE_TEXTURE or by waiting on a <a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress.">Sync</a> object. When clearing a linear texture, the texture must have been created with the LINEAR_RENDER_TARGET flag set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dstTexture</td><td><a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> object used as the destination for the clear.</td></tr>
    <tr><td class="paramname">dstView</td><td>View of the texture object used as the destination for the clear. A texture view, if specified, can be used to override properties of the corresponding texture <em>dstTexture</em>. If NULL is specified, the base level of the texture <em>dstTexture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">dstRegion</td><td>Region of the destination texture to write to.</td></tr>
    <tr><td class="paramname">color</td><td>Array of four floating-point (RGBA) clear color values.</td></tr>
    <tr><td class="paramname">mask</td><td>Bitfield indicating which color channels should be cleared. See of <a class="el" href="structnvn_1_1_clear_color_mask.html" title="Specifies the set of color buffer channels enabled for writing.">nvn::ClearColorMask</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c37d217f9cdcc5dd083986aa785d17b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c37d217f9cdcc5dd083986aa785d17b">&#9670;&nbsp;</a></span>ClearTexturei()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::ClearTexturei </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *&#160;</td>
          <td class="paramname"><em>dstTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *&#160;</td>
          <td class="paramname"><em>dstView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="structnvn_1_1_copy_region.html">CopyRegion</a> *&#160;</td>
          <td class="paramname"><em>dstRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const int *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_clear_color_mask.html">ClearColorMask</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a color buffer using signed integer clear color values. </p>
<p>Clears texture data from the region <em>region</em> of a view of the destination texture.</p>
<p>This command supports only texture formats that can be bound as a render target. Please refer to the 'Render' column in the programming guide's <a class="el" href="nvn_index.html#nvn_guide_formats_table">formats table</a> for supported formats.</p>
<dl class="section warning"><dt>Warning</dt><dd>Unlike Copy commands, ClearTexure renders to the texture using the 3D Engine. Before accessing the cleared texture, applications must ensure that the GPU commands producing the new data have completed with <a class="el" href="structnvn_1_1_barrier_bits.html" title="Controls the ordering of commands and invalidation of caches for CommandBuffer::Barrier.">BarrierBits</a> of ORDER_FRAGMENTS and INVALIDATE_TEXTURE or by waiting on a <a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress.">Sync</a> object. When clearing a linear texture, the texture must have been created with the LINEAR_RENDER_TARGET flag set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dstTexture</td><td><a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> object used as the destination for the clear.</td></tr>
    <tr><td class="paramname">dstView</td><td>View of the texture object used as the destination for the clear. A texture view, if specified, can be used to override properties of the corresponding texture <em>dstTexture</em>. If NULL is specified, the base level of the texture <em>dstTexture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">dstRegion</td><td>Region of the destination texture to write to.</td></tr>
    <tr><td class="paramname">color</td><td>Array of four signed integer (RGBA) clear color values.</td></tr>
    <tr><td class="paramname">mask</td><td>Bitfield indicating which color channels should be cleared. See <a class="el" href="structnvn_1_1_clear_color_mask.html" title="Specifies the set of color buffer channels enabled for writing.">nvn::ClearColorMask</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4313e5838e0b2528870bb3437a18bf5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4313e5838e0b2528870bb3437a18bf5d">&#9670;&nbsp;</a></span>ClearTextureui()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::ClearTextureui </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *&#160;</td>
          <td class="paramname"><em>dstTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *&#160;</td>
          <td class="paramname"><em>dstView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="structnvn_1_1_copy_region.html">CopyRegion</a> *&#160;</td>
          <td class="paramname"><em>dstRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const uint32_t *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_clear_color_mask.html">ClearColorMask</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a color buffer using unsigned integer clear color values. </p>
<p>Clears texture data from the region <em>region</em> of a view of the destination texture.</p>
<p>This command supports only texture formats that can be bound as a render target. Please refer to the 'Render' column in the programming guide's <a class="el" href="nvn_index.html#nvn_guide_formats_table">formats table</a> for supported formats.</p>
<dl class="section warning"><dt>Warning</dt><dd>Unlike Copy commands, ClearTexure renders to the texture using the 3D Engine. Before accessing the cleared texture, applications must ensure that the GPU commands producing the new data have completed with <a class="el" href="structnvn_1_1_barrier_bits.html" title="Controls the ordering of commands and invalidation of caches for CommandBuffer::Barrier.">BarrierBits</a> of ORDER_FRAGMENTS and INVALIDATE_TEXTURE or by waiting on a <a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress.">Sync</a> object. When clearing a linear texture, the texture must have been created with the LINEAR_RENDER_TARGET flag set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dstTexture</td><td><a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> object used as the destination for the clear.</td></tr>
    <tr><td class="paramname">dstView</td><td>View of the texture object used as the destination for the clear. A texture view, if specified, can be used to override properties of the corresponding texture <em>dstTexture</em>. If NULL is specified, the base level of the texture <em>dstTexture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">dstRegion</td><td>Region of the destination texture to write to.</td></tr>
    <tr><td class="paramname">color</td><td>Array of four unsigned integer (RGBA) clear color values.</td></tr>
    <tr><td class="paramname">mask</td><td>Bitfield indicating which color channels should be cleared. See of <a class="el" href="structnvn_1_1_clear_color_mask.html" title="Specifies the set of color buffer channels enabled for writing.">nvn::ClearColorMask</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a0c771367c9d655052cfc1657aa70ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0c771367c9d655052cfc1657aa70ca">&#9670;&nbsp;</a></span>UpdateUniformBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::UpdateUniformBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>updateOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>updateSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the contents of a uniform buffer. </p>
<p>This command schedules an update of the contents of a uniform buffer, which will execute without waiting for previous draw calls prior to the update. The update will wait on the completion of previous compute dispatches. Draw calls and compute dispatches issued after the update will use the new uniform buffer values. Calls before the update will use the old values.</p>
<p>To get correct ordering of updates, the range of buffer memory identified by <em>buffer</em> and <em>bufferSize</em> must exactly match the memory range bound via <a class="el" href="classnvn_1_1_command_buffer.html#a486ff1b4cd3e5dc02263c20e65e23081" title="Bind a range of a Buffer object to use for fetching shader uniform values.">CommandBuffer::BindUniformBuffer</a>. If any other uniform buffer binding (using a different base address or size) overlaps the range of memory updated by this command, shader accesses using that binding (from commands before or after the update) will return undefined values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>GPU address of the full uniform buffer to update. Must be a multiple of 256 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da0ac709daa04fb931cc36587cf69e7c97" title="Minimum alignment of uniform buffer bindings.">nvn::DeviceInfo::UNIFORM_BUFFER_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">bufferSize</td><td>Size (in bytes) of the full uniform buffer to update. Must be less than or equal to 65536 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dad61dee2ea2974320c3ebcc9f638b00ab" title="Maximum size (in bytes) of a bound uniform buffer.">nvn::DeviceInfo::MAX_UNIFORM_BUFFER_SIZE</a>).</td></tr>
    <tr><td class="paramname">updateOffset</td><td>Offset (in bytes) of the first byte to update inside the uniform buffer. Must be a multiple of 4 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da9d0b199f8fb8b36a057459d5b9f25a61" title="Alignment required (in bytes) for the offset and size of uniform buffer updates via CommandBuffer::Up...">nvn::DeviceInfo::UNIFORM_BUFFER_UPDATE_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">updateSize</td><td>Number of bytes to update inside the uniform buffer. Must be less than or equal to 65536 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dad61dee2ea2974320c3ebcc9f638b00ab" title="Maximum size (in bytes) of a bound uniform buffer.">nvn::DeviceInfo::MAX_UNIFORM_BUFFER_SIZE</a>). Must be a multiple of 4 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da9d0b199f8fb8b36a057459d5b9f25a61" title="Alignment required (in bytes) for the offset and size of uniform buffer updates via CommandBuffer::Up...">nvn::DeviceInfo::UNIFORM_BUFFER_UPDATE_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">data</td><td>New data to write into the uniform buffer. The data is consumed before the call returns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae682e63441faaed6a3ffdf4fff89850d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae682e63441faaed6a3ffdf4fff89850d">&#9670;&nbsp;</a></span>UpdateUniformBuffer_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::UpdateUniformBuffer_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>updateOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>updateSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the contents of a uniform buffer. </p>
<p>Fastpath variant.</p>
<p>This command schedules an update of the contents of a uniform buffer, which will execute without waiting for previous draw calls prior to the update. The update will wait on the completion of previous compute dispatches. Draw calls and compute dispatches issued after the update will use the new uniform buffer values. Calls before the update will use the old values.</p>
<p>To get correct ordering of updates, the range of buffer memory identified by <em>buffer</em> and <em>bufferSize</em> must exactly match the memory range bound via <a class="el" href="classnvn_1_1_command_buffer.html#a486ff1b4cd3e5dc02263c20e65e23081" title="Bind a range of a Buffer object to use for fetching shader uniform values.">CommandBuffer::BindUniformBuffer</a>. If any other uniform buffer binding (using a different base address or size) overlaps the range of memory updated by this command, shader accesses using that binding (from commands before or after the update) will return undefined values.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to <a class="el" href="classnvn_1_1_command_buffer.html#a2a0c771367c9d655052cfc1657aa70ca" title="Update the contents of a uniform buffer.">CommandBuffer::UpdateUniformBuffer</a>, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>GPU address of the full uniform buffer to update. Must be a multiple of 256 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da0ac709daa04fb931cc36587cf69e7c97" title="Minimum alignment of uniform buffer bindings.">nvn::DeviceInfo::UNIFORM_BUFFER_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">bufferSize</td><td>Size (in bytes) of the full uniform buffer to update. Must be less than or equal to 65536 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dad61dee2ea2974320c3ebcc9f638b00ab" title="Maximum size (in bytes) of a bound uniform buffer.">nvn::DeviceInfo::MAX_UNIFORM_BUFFER_SIZE</a>).</td></tr>
    <tr><td class="paramname">updateOffset</td><td>Offset (in bytes) of the first byte to update inside the uniform buffer. Must be a multiple of 4 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da9d0b199f8fb8b36a057459d5b9f25a61" title="Alignment required (in bytes) for the offset and size of uniform buffer updates via CommandBuffer::Up...">nvn::DeviceInfo::UNIFORM_BUFFER_UPDATE_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">updateSize</td><td>Number of bytes to update inside the uniform buffer. Must be less than or equal to 65536 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dad61dee2ea2974320c3ebcc9f638b00ab" title="Maximum size (in bytes) of a bound uniform buffer.">nvn::DeviceInfo::MAX_UNIFORM_BUFFER_SIZE</a>). Must be a multiple of 4 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da9d0b199f8fb8b36a057459d5b9f25a61" title="Alignment required (in bytes) for the offset and size of uniform buffer updates via CommandBuffer::Up...">nvn::DeviceInfo::UNIFORM_BUFFER_UPDATE_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">data</td><td>New data to write into the uniform buffer. The data is consumed before the call returns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97e3b104004b6188f83dfaa755a50936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e3b104004b6188f83dfaa755a50936">&#9670;&nbsp;</a></span>ReportCounter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::ReportCounter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_counter_type.html">CounterType</a>&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a GPU counter and timestamp into buffer object memory. </p>
<p>The GPU maintains a set of counters for each queue that will be incremented on certain events. This function requests that the current value of the counter be written to a specified offset in the specified buffer object. 16 bytes will be written to the buffer object.</p>
<p>Except for the <a class="el" href="structnvn_1_1_counter_type.html#af2829028dc9ed7cdb59e5a2d3d3ffe29ab596aefd86769826ce49dc48c92623ef" title="Report zcull counters.">CounterType::ZCULL_STATS</a> counter, the first 8 bytes hold the 64-bit counter value and the second 8 bytes hold a timestamp when the counter value was reported. <a class="el" href="structnvn_1_1_counter_type.html#af2829028dc9ed7cdb59e5a2d3d3ffe29ab596aefd86769826ce49dc48c92623ef" title="Report zcull counters.">CounterType::ZCULL_STATS</a> reports four 32-bit counter values.</p>
<dl class="section note"><dt>Note</dt><dd>If tiled caching is enabled, this command will trigger an implicit tiled cache flush.</dd>
<dd>
For timestamp, please refer to the <a class="el" href="nvn_index.html#nvn_guide_counter_resolution_of_timestamp">NVN Programming Guide</a> for details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">counter</td><td>Type of counter that will be written.</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of buffer memory where the counter will be written. Must be a multiple of 16 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da5d58b89be73dafd06ac63b62a3da932b" title="Minimum alignment for counter reports.">nvn::DeviceInfo::COUNTER_ALIGNMENT</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_graphics_system_8cpp-example.html#a58">NvnSimple/NvnSimpleSharedLib/GraphicsSystem.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a64d15a39c7a1f8391aef376768a37d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d15a39c7a1f8391aef376768a37d02">&#9670;&nbsp;</a></span>ResetCounter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::ResetCounter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_counter_type.html">CounterType</a>&#160;</td>
          <td class="paramname"><em>counter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset a GPU counter to zero. </p>
<p>The GPU maintains a set of counters for each queue that will be incremented on certain events. This function resets the current value of the counter to zero.</p>
<dl class="section note"><dt>Note</dt><dd>If tiled caching is enabled, this command will trigger an implicit tiled cache flush.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">counter</td><td>Type of counter that will be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0dc42b659aad608e9e4a976aeb083c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc42b659aad608e9e4a976aeb083c7d">&#9670;&nbsp;</a></span>ReportValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::ReportValue </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a GPU counter report and timestamp into buffer object memory using an application-provided value. </p>
<p>This command will cause the GPU to write a counter report (of type <a class="el" href="structnvn_1_1_counter_data.html" title="Data structure describing how counter values are written to buffer memory.">CounterData</a>) to buffer object memory, with the counter value replaced by an unsigned 32-bit value provided in the command. In the report, the first 8 bytes hold a 64-bit integer set to the provided report value and the second 8 bytes hold a timestamp when the report was performed.</p>
<dl class="section note"><dt>Note</dt><dd>If tiled caching is enabled, this command will trigger an implicit tiled cache flush.</dd>
<dd>
For timestamp, please refer to the <a class="el" href="nvn_index.html#nvn_guide_counter_resolution_of_timestamp">NVN Programming Guide</a> for the details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value that be written in the counter report.</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of buffer memory where the counter will be written. Must be a multiple of 16 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da5d58b89be73dafd06ac63b62a3da932b" title="Minimum alignment for counter reports.">nvn::DeviceInfo::COUNTER_ALIGNMENT</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acebb910789d3d56aab05ba1f0dfb6c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acebb910789d3d56aab05ba1f0dfb6c3f">&#9670;&nbsp;</a></span>SetRenderEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetRenderEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the render enable for a queue. </p>
<p>The render enable allows applications to disable all rendering to a queue unconditionally. If rendering is disabled for a queue, all rendering commands (framebuffer clears, Draw commands) will be discarded without any processing. Commands changing queue state will be executed even if rendering is disabled and will affect subsequent rendering commands if/when rendering is re-enabled. SetRenderEnable and SetRenderEnableConditional affect the same state in the queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>NVN_TRUE if rendering should be enabled; NVN_FALSE if rendering should be disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae228acd137da5415f118f5c8268c867a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae228acd137da5415f118f5c8268c867a">&#9670;&nbsp;</a></span>SetRenderEnableConditional()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetRenderEnableConditional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_conditional_render_mode.html">ConditionalRenderMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>counters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables rendering for a queue, depending on the equality of counters. </p>
<p>Enable or disable rendering based on whether two 64-bit values in buffer memory are equal. If the values are written using the SAMPLES_PASSED counter, this function can be used in an implementation of occlusion culling. SetRenderEnable and SetRenderEnableConditional affect the same state in the queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>NVN_CONDITIONAL_RENDER_MODE_RENDER_IF_EQUAL if rendering should be enabled if the buffer values are equal, NVN_CONDITIONAL_RENDER_MODE_RENDER_IF_NOT_EQUAL otherwise.</td></tr>
    <tr><td class="paramname">counters</td><td><a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a> address of the two values to be compared. There must be at least 32 bytes of buffer memory starting at this address. The first value is contained in the first eight bytes starting at this address, and the second value is contained in the eight bytes starting at <em>bufferAddress</em> + 16. Note that this layout is consistent with two counter query results stored consecutively in memory. Must be a multiple of 16 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da5d58b89be73dafd06ac63b62a3da932b" title="Minimum alignment for counter reports.">nvn::DeviceInfo::COUNTER_ALIGNMENT</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4940982011cd1c5c8cc1c9e25262f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4940982011cd1c5c8cc1c9e25262f70">&#9670;&nbsp;</a></span>SetRenderTargets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetRenderTargets </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numColors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *const *&#160;</td>
          <td class="paramname"><em>colors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *const *&#160;</td>
          <td class="paramname"><em>colorViews</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *&#160;</td>
          <td class="paramname"><em>depthStencilView</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets color and depth/stencil textures in the framebuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numColors</td><td>Number of color textures in the framebuffer. If zero is specified, the framebuffer will be programmed with no color textures. Any color binding point numbered <em>numColors</em> or higher will be programmed with no color texture. Must be less than or equal to 8 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da51d53fd5085bbb13d9e154bc22e79da4" title="Number of color buffer binding points.">nvn::DeviceInfo::COLOR_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">colors</td><td>Array of <em>numColors</em> color textures to program in the framebuffer. If any element in the array is set to NULL, the corresponding color target in the framebuffer will be programmed with no texture.</td></tr>
    <tr><td class="paramname">colorViews</td><td>Array of <em>numColors</em> color texture views to program in the framebuffer. The texture views, if specified, can be used to override properties of the corresponding texture in the array <em>colors</em>. If NULL is specified, all textures in <em>colors</em> will be used as-is. If a non-NULL array of views is specified but one or more entries in that array is NULL, the corresponding textures in <em>colors</em> will be used as-is.</td></tr>
    <tr><td class="paramname">depthStencil</td><td>Depth/stencil texture to program in the framebuffer. If NULL is specified, the framebuffer will be programmed with no depth/stencil buffer.</td></tr>
    <tr><td class="paramname">depthStencilView</td><td>Depth/stencil texture view to program in the framebuffer. A texture view, if specified, can be used to override properties of the corresponding texture <em>depthStencil</em>. If NULL is specified, the texture <em>depthStencil</em> will be used as-is. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_graphics_system_8cpp-example.html#a64">NvnSimple/NvnSimpleSharedLib/GraphicsSystem.cpp</a>, and <a class="el" href="_nvn_simple04_render_to_texture_2_render_to_texture_8cpp-example.html#a35">NvnSimple04RenderToTexture/RenderToTexture.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a51f6b826ef568486e1ec5875663bb980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f6b826ef568486e1ec5875663bb980">&#9670;&nbsp;</a></span>DiscardColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::DiscardColor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discard the contents of the specified bound color render target. </p>
<p>After discarding the contents of a color render target, its values will become undefined. This command can be useful for saving memory bandwidth for 'transient' rendering operations such as rendering to a multisample texture. After rendering to a multisample texture, the contents are often filtered to produce single-sample texels using <a class="el" href="classnvn_1_1_command_buffer.html#af3f0fd0366d48cd3ba8f9c2cfea40e23" title="Computes a filtered version of a multisample source texture to produce a single-sample destination te...">CommandBuffer::Downsample</a>. Discarding the contents of a multisample texture after the downsample allows the GPU to throw away its contents before writing values to memory.</p>
<p>Only the portion of the render target contained inside the current scissor rectangle will be discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Number of the color target whose contents should be discarded. Must be less than 8 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da51d53fd5085bbb13d9e154bc22e79da4" title="Number of color buffer binding points.">nvn::DeviceInfo::COLOR_BUFFER_BINDINGS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8c508e0b02295d5ac10849239c1499a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c508e0b02295d5ac10849239c1499a">&#9670;&nbsp;</a></span>DiscardDepthStencil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::DiscardDepthStencil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discard the contents of the currently bound depth/stencil render target. </p>
<p>After discarding the contents of a depth/stencil render target, its values will become undefined. This command can be useful for saving memory bandwidth for 'transient' rendering operations such as rendering to a depth/stencil buffer that is only used to generate a color buffer image in the same frame. Discarding the contents of a texture allows the GPU to throw away its contents before writing values to main memory.</p>
<p>Only the portion of the render target contained inside the current scissor rectangle will be discarded. </p>

</div>
</div>
<a id="af3f0fd0366d48cd3ba8f9c2cfea40e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f0fd0366d48cd3ba8f9c2cfea40e23">&#9670;&nbsp;</a></span>Downsample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::Downsample </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a filtered version of a multisample source texture to produce a single-sample destination texture. </p>
<p>This command completes the execution of all previous rendering commands before performing the downsample operation. In particular, it will flush all primitives accumulated by tiled caching logic. When using tiled caching, <a class="el" href="classnvn_1_1_command_buffer.html#ae8cc57c04b2dcdcf17636155dfdb66d4" title="Computes a filtered version of a multisample source texture to produce a single-sample destination te...">CommandBuffer::TiledDownsample</a> will perform better. This command is performed by the RSTR2D unit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source texture for the downsample operation.</td></tr>
    <tr><td class="paramname">dst</td><td>Destination texture for the downsample operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8cc57c04b2dcdcf17636155dfdb66d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8cc57c04b2dcdcf17636155dfdb66d4">&#9670;&nbsp;</a></span>TiledDownsample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::TiledDownsample </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a filtered version of a multisample source texture to produce a single-sample destination texture. </p>
<p>When tiled caching is enabled, the downsample operation performed by this command will be accumulated along with other rendered primitives. The actual downsample will be performed on a tile-by-tile basis, and may complete on one tile before regular rendering for another tile begins. When tiled caching is disabled, this command will behave similarly to <a class="el" href="classnvn_1_1_command_buffer.html#af3f0fd0366d48cd3ba8f9c2cfea40e23" title="Computes a filtered version of a multisample source texture to produce a single-sample destination te...">CommandBuffer::Downsample</a>, which fully flushes previous work before starting the downsample operation. This command is performed by the 3D pipeline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source texture for the downsample operation.</td></tr>
    <tr><td class="paramname">dst</td><td>Destination texture for the downsample operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad675ea33fa4fd4ce4815ed5db5c320a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad675ea33fa4fd4ce4815ed5db5c320a">&#9670;&nbsp;</a></span>DownsampleTextureView()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::DownsampleTextureView </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *&#160;</td>
          <td class="paramname"><em>srcView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *&#160;</td>
          <td class="paramname"><em>dstView</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a filtered version of a multisample source texture and texture view to produce a single-sample destination texture through a texture view. </p>
<p>This command completes the execution of all previous rendering commands before performing the downsample operation. In particular, it will flush all primitives accumulated by tiled caching logic. When using tiled caching, <a class="el" href="classnvn_1_1_command_buffer.html#ae8cc57c04b2dcdcf17636155dfdb66d4" title="Computes a filtered version of a multisample source texture to produce a single-sample destination te...">CommandBuffer::TiledDownsample</a> will perform better. This command is performed by the RSTR2D unit. The texture views may only describe one single level/layer of a texture.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source texture for the downsample operation.</td></tr>
    <tr><td class="paramname">srcView</td><td>Source texture view for the downsample operation. Selects one level/layer.</td></tr>
    <tr><td class="paramname">dst</td><td>Destination texture for the downsample operation.</td></tr>
    <tr><td class="paramname">dstView</td><td>Destination texture view for the downsample operation. Selects one level/layer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af77dd8f52363143f81f6cd5ce7eaf7a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af77dd8f52363143f81f6cd5ce7eaf7a1">&#9670;&nbsp;</a></span>TiledDownsampleTextureView()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::TiledDownsampleTextureView </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *&#160;</td>
          <td class="paramname"><em>srcView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *&#160;</td>
          <td class="paramname"><em>dstView</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a filtered version of a multisample source texture texture view to produce a single-sample destination texture view. </p>
<p>When tiled caching is enabled, the downsample operation performed by this command will be accumulated along with other rendered primitives. The actual downsample will be performed on a tile-by-tile basis, and may complete on one tile before regular rendering for another tile begins. When tiled caching is disabled, this command will behave similarly to <a class="el" href="classnvn_1_1_command_buffer.html#af3f0fd0366d48cd3ba8f9c2cfea40e23" title="Computes a filtered version of a multisample source texture to produce a single-sample destination te...">CommandBuffer::Downsample</a>, which fully flushes previous work before starting the downsample operation. This command is performed by the 3D pipeline. The texture views must each describe only a single level/layer of a texture.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source texture for the downsample operation.</td></tr>
    <tr><td class="paramname">srcView</td><td>Source texture view for the downsample operation. Selects one level/layer.</td></tr>
    <tr><td class="paramname">dst</td><td>Destination texture for the downsample operation.</td></tr>
    <tr><td class="paramname">dstView</td><td>Destination texture view for the downsample operation. Selects one level/layer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d9df9457cbd501a6035720f31979752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d9df9457cbd501a6035720f31979752">&#9670;&nbsp;</a></span>Barrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::Barrier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_barrier_bits.html">BarrierBits</a>&#160;</td>
          <td class="paramname"><em>barrier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a barrier ordering execution of GPU commands and invalidating internal GPU caches. </p>
<p>Rendering and compute dispatch commands sent to NVN queues are executed on the GPU using a hardware pipeline, with no guarantee that work for one draw call or dispatch completes before work on the next draw call or dispatch starts. Additionally, some units of the GPU maintain caches that are not automatically invalidated when cached data are overwritten by the CPU or other units of the GPU. This command allows applications to order the processing of commands sent before and after the barrier and to invalidate GPU caches before processing commands sent after the barrier.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">barrier</td><td>Bitfield controlling the order of commands before and after the barrier and the invalidation of GPU caches for commands after the barrier. See <a class="el" href="structnvn_1_1_barrier_bits.html" title="Controls the ordering of commands and invalidation of caches for CommandBuffer::Barrier.">nvn::BarrierBits</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_graphics_system_8cpp-example.html#a60">NvnSimple/NvnSimpleSharedLib/GraphicsSystem.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a39ce30782d28ebc2f6d97cbc8658cd41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ce30782d28ebc2f6d97cbc8658cd41">&#9670;&nbsp;</a></span>WaitSync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::WaitSync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_sync.html">Sync</a> *&#160;</td>
          <td class="paramname"><em>sync</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a <a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress.">Sync</a> object to be signaled on the GPU before processing any further commands in the specified <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync</td><td><a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress.">Sync</a> object to wait on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc0a2ade0434ed01f886cd52aeac1a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0a2ade0434ed01f886cd52aeac1a23">&#9670;&nbsp;</a></span>FenceSync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::FenceSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnvn_1_1_sync.html">Sync</a> *&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_sync_condition.html">SyncCondition</a>&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_sync_flag_bits.html">SyncFlagBits</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a <a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress.">Sync</a> object as signaled when all previous commands have completed in the <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a> object. </p>
<dl class="section warning"><dt>Warning</dt><dd>FenceSync commands are not automatically flushed for processing by the GPU. Before waiting on a FenceSync call with the CPU using <a class="el" href="classnvn_1_1_sync.html#ad1eb41d009bcd4e48bebe3573bb32397" title="Wait for a Sync object to be signaled on the CPU before returning.">Sync::Wait</a> or from another <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU.">Queue</a> using <a class="el" href="classnvn_1_1_queue.html#a339d246e329a173e81d8e1cf2a550113" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">Queue::WaitSync</a>, applications must ensure that the previous FenceSync call was flushed using <a class="el" href="classnvn_1_1_queue.html#abf561605d8b58cc923342539f90466f1" title="Flush commands previously submitted to a queue for processing.">Queue::Flush</a>. Waiting on a FenceSync call using <a class="el" href="classnvn_1_1_queue.html#a339d246e329a173e81d8e1cf2a550113" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">Queue::WaitSync</a> in the same queue requires no manual flush.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If tiled caching is enabled, this command will trigger an implicit tiled cache flush.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync</td><td><a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress.">Sync</a> object to mark as signaled when commands complete.</td></tr>
    <tr><td class="paramname">condition</td><td>Type of command completion to wait for.</td></tr>
    <tr><td class="paramname">flags</td><td>Bitfield of additional operations to perform before signaling. See <a class="el" href="structnvn_1_1_sync_flag_bits.html" title="Specifies additional operations performed when a FenceSync command is processed.">nvn::SyncFlagBits</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25f10e3257fe549de368e842e61ee8ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f10e3257fe549de368e842e61ee8ee">&#9670;&nbsp;</a></span>SetTexturePool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetTexturePool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_texture_pool.html">TexturePool</a> *&#160;</td>
          <td class="paramname"><em>texturePool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a new texture pool used for subsequent rendering operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texturePool</td><td><a class="el" href="classnvn_1_1_texture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">TexturePool</a> object to be programmed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad36725731839793d678ce0243df56f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36725731839793d678ce0243df56f94">&#9670;&nbsp;</a></span>SetSamplerPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetSamplerPool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_sampler_pool.html">SamplerPool</a> *&#160;</td>
          <td class="paramname"><em>samplerPool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a new sampler pool used for subsequent rendering operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">samplerPool</td><td><a class="el" href="classnvn_1_1_sampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">SamplerPool</a> object to be programmed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a65c1f2c4f9cde0395aa082526d52f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a65c1f2c4f9cde0395aa082526d52f6">&#9670;&nbsp;</a></span>SetShaderScratchMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetShaderScratchMemory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_memory_pool.html">MemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify scratch memory required for shader execution. </p>
<p>The scratch memory provided by this function allows shaders to require temporary (scratch) memory during execution to save the results of intermediate computations or flow control state. Each queue has its own block of scratch memory, programmed via command buffers. Scratch memory will be shared by all active shaders running on the queue. Multiple queues can share the same block of scratch memory.</p>
<p>Each compiled shader will report a minimum and recommended amount of scratch memory required. We recommend that applications provide the largest recommended amount of scratch memory for optimal performance. Providing less memory may resolve in lower shader performance, and providing less than the minimum amount of memory will result in crashes. For more information, consult the programming guide.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>Memory pool providing storage for the shader scratch memory.</td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) of the first byte of shader scratch memory. Must be a multiple of 4096 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da680a0b084aacbf2e3ee8cf18b72e60f6" title="Alignment required (in bytes) for the shader scratch memory.">nvn::DeviceInfo::SHADER_SCRATCH_MEMORY_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the scratch memory. Must be a multiple of 131072 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da8b8ab4e85b70b3f1308efc8693a6291f" title="Required granularity for shader scratch memory provided to NVN.">nvn::DeviceInfo::SHADER_SCRATCH_MEMORY_GRANULARITY</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e8dd92449da43b69fe613e94cd67ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8dd92449da43b69fe613e94cd67ade">&#9670;&nbsp;</a></span>SaveZCullData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SaveZCullData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the current ZCull state for the current depth render target. </p>
<p>The ZCull unit of the GPU tracks the contents of the currently bound depth render target and uses this information to perform high-speed depth and stencil testing. When applications switch between depth render targets, ZCull discards tracking information for the old render target. This command allows applications to instead save the ZCull state to buffer memory so that it can be later restored when switching back to the old target. When saving information for a depth render target, SaveZCullData should be called immediately before switching render targets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>GPU address of buffer object memory where the ZCull contents will be stored. Must be a multiple of 32 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61daf4b271b11114e1c43afe1f7006c84059" title="Minimum alignment for ZCull save/restore buffers.">nvn::DeviceInfo::ZCULL_SAVE_RESTORE_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the destination buffer. To determine the amount of memory required to save and restore ZCull data, call <a class="el" href="classnvn_1_1_texture.html#a4ca44a91efd53f8881e902ba7c3aa31c" title="Returns the amount of memory (in bytes) required to hold a ZCull save/restore buffer for a depth text...">Texture::GetZCullStorageSize()</a> or <a class="el" href="classnvn_1_1_texture_builder.html#aea5111b082fa47a28ac458c810bf004e" title="Returns the amount of memory (in bytes) required to hold a ZCull save/restore buffer for a depth text...">TextureBuilder::GetZCullStorageSize()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac2cecb42e2c89078f75da69200e5ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac2cecb42e2c89078f75da69200e5ada">&#9670;&nbsp;</a></span>RestoreZCullData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::RestoreZCullData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd">BufferAddress</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the current ZCull state to use saved state from a previous render target. </p>
<p>The ZCull unit of the GPU tracks the contents of the currently bound depth render target and uses this information to perform high-speed depth and stencil testing. When applications switch between depth render targets, ZCull discards tracking information for the old render target. This command allows applications restore previously saved ZCull state from buffer memory so that it can be used when continuing to render to the new target. When restoring information for a depth render target, RestoreZCullData should be called immediately after switching render targets.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data restored by this command must have been previously saved by <a class="el" href="classnvn_1_1_command_buffer.html#a9e8dd92449da43b69fe613e94cd67ade" title="Save the current ZCull state for the current depth render target.">CommandBuffer::SaveZCullData</a>. Additionally, the same depth/stencil texture and texture view must be bound as a render target at the time of the restore and the previous save. In case of a mismatch, the results of the restore are undefined and may result in GPU exceptions.</dd>
<dd>
If the current contents of the depth render target are inconsistent with the contents of the render target when SaveZCullData was called, the state written by RestoreZCullData is invalid and the results of depth and stencil testing are undefined.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>GPU address of buffer object memory where the ZCull contents will be loaded from. Must be a multiple of 32 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61daf4b271b11114e1c43afe1f7006c84059" title="Minimum alignment for ZCull save/restore buffers.">nvn::DeviceInfo::ZCULL_SAVE_RESTORE_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the source buffer. To determine the amount of memory required to save and restore ZCull data, call <a class="el" href="classnvn_1_1_texture.html#a4ca44a91efd53f8881e902ba7c3aa31c" title="Returns the amount of memory (in bytes) required to hold a ZCull save/restore buffer for a depth text...">Texture::GetZCullStorageSize()</a> or <a class="el" href="classnvn_1_1_texture_builder.html#aea5111b082fa47a28ac458c810bf004e" title="Returns the amount of memory (in bytes) required to hold a ZCull save/restore buffer for a depth text...">TextureBuilder::GetZCullStorageSize()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0207cc2151b50b8b0fd1957612482e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0207cc2151b50b8b0fd1957612482e67">&#9670;&nbsp;</a></span>SetCopyRowStride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetCopyRowStride </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>stride</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the row stride used for copies between buffer and texture memory. </p>
<p>This command sets the stride (in bytes) between rows of texels in buffer memory when copying texels between buffer and texture memory. With the default stride of zero (default), texel data in buffer memory will be treated as densely packed, where each new row in memory starts immediately after the end of the previous row.</p>
<dl class="section note"><dt>Note</dt><dd>Setting a stride affects any subsequent calls to <a class="el" href="classnvn_1_1_command_buffer.html#a3573269dfa045bfc0673173a8f55fb34" title="Copy texture data from buffer memory into a region of a Texture object.">CommandBuffer::CopyBufferToTexture</a> and <a class="el" href="classnvn_1_1_command_buffer.html#a776e2215df7bf908253d82689ead67b5" title="Copy texture data from a region of a Texture object into buffer memory.">CommandBuffer::CopyTextureToBuffer</a> using this command buffer. Unlike most <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a> calls, this command does not store the stride in command or control memory and does not affect future submissions of previously recorded copy commands or copy commands recorded using other command buffers.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stride</td><td>Stride (in bytes) between rows of texels in buffer memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ed848d8f9360fa17c44e9570a6d8bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed848d8f9360fa17c44e9570a6d8bc4">&#9670;&nbsp;</a></span>SetCopyImageStride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetCopyImageStride </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>stride</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the image stride used for copies between buffer and texture memory. </p>
<p>This command sets the stride (in bytes) between layers of texels in buffer memory when copying texels between buffer and texture memory. With the default stride of zero (default), texel data in buffer memory will be treated as densely packed, where each new layer in memory starts immediately after the end of the previous layer.</p>
<dl class="section note"><dt>Note</dt><dd>Setting a stride affects any subsequent calls to <a class="el" href="classnvn_1_1_command_buffer.html#a3573269dfa045bfc0673173a8f55fb34" title="Copy texture data from buffer memory into a region of a Texture object.">CommandBuffer::CopyBufferToTexture</a> and <a class="el" href="classnvn_1_1_command_buffer.html#a776e2215df7bf908253d82689ead67b5" title="Copy texture data from a region of a Texture object into buffer memory.">CommandBuffer::CopyTextureToBuffer</a> using this command buffer. Unlike most <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">CommandBuffer</a> calls, this command does not store the stride in command or control memory and does not affect future submissions of previously recorded copy commands or copy commands recorded using other command buffers.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stride</td><td>Stride (in bytes) between 2D arrays of texels in buffer memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c0ab209349d35ddaa3166571bc66039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0ab209349d35ddaa3166571bc66039">&#9670;&nbsp;</a></span>DrawTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::DrawTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#gafe744b035d9582a86872d256349c5e08">TextureHandle</a>&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="structnvn_1_1_draw_texture_region.html">DrawTextureRegion</a> *&#160;</td>
          <td class="paramname"><em>dstRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="structnvn_1_1_draw_texture_region.html">DrawTextureRegion</a> *&#160;</td>
          <td class="paramname"><em>srcRegion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draws an on-screen rectangle displaying the contents of a provided texture. </p>
<p>This command renders an axis-aligned rectangle into color target zero of the framebuffer, displaying some or all of the contents of a two-dimensional texture or rectangle texture. The caller specifies a texture handle identifying the source texture, a destination region in window coordinates, and a source region in non-normalized texture coordinates. For each fragment produced by the rectangle, DrawTexture computes coordinates in the source region, performs a texture lookup, and uses the texture result as the fragment color. Most per-fragment operations (including blending) are performed, and the results are written into color target zero.</p>
<p>DrawTexture has a number of limitations. Using illegal state may result in undefined behavior or GPU errors:</p><ul>
<li>The source texture must be two-dimensional (or rectangle).</li>
<li>Level of detail selection is not supported; level zero of the original texture is used.</li>
<li>Calling DrawTexture with multiple color targets is illegal.</li>
<li>Calling DrawTexture with blend modes selecting a second source color is illegal.</li>
<li>Conservative rasterization is treated as disabled.</li>
<li>Depth, depth bounds, and stencil tests are treated as disabled.</li>
<li>Anisotropic filtering and wrap modes that mirror or repeat are unsupported.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>Handle for the pair of <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> and <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">Sampler</a> objects to use.</td></tr>
    <tr><td class="paramname">dstRegion</td><td>Region identifying the portion of the color target to update. Coordinates (x0,y0) and (x1,y1) identify opposite corners of the region, in screen coordinates. All coordinates must be in the range [-65536, +65535], and x1-x0 and y1-y0 must be in the range [0, 65535].</td></tr>
    <tr><td class="paramname">srcRegion</td><td>Region identifying the portion of <em>texture</em> to access. Coordinates (x0,y0) and (x1,y1) identify opposite corners of the region, in non-normalized texel coordinates. All coordinates must be in the range [-65536, +65535]. The texture region will be mirrored horizontally and/or vertically if x0 &gt; x1 or y0 &gt; y1, respectively. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e968d43bfc4919804bf951101a17b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e968d43bfc4919804bf951101a17b65">&#9670;&nbsp;</a></span>SetProgramSubroutines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetProgramSubroutines </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnvn_1_1_program.html">Program</a> *&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_shader_stage.html">ShaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const int *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the subroutine uniform parameters. </p>
<p>Sets subroutine uniform parameters for program subroutine, similar to the ARB_shader_subroutine functionality in OpenGL. Subroutines allow a application to dynamically switch between using different sets of functions instead without having to recompile the program, similar to setting function pointers in C-based languages. In order to use this feature, some linkage information from the offline compiler needs to be set in the program first via a call to SetSubroutineLinkage. This function allows a program to set a range of uniform locations to point to the input subroutines denoted by the index values in the array <em>values</em>. See the offline compiler documentation and the NVN documentation for more information on how to use this feature.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td><a class="el" href="classnvn_1_1_program.html" title="Collection of programmable shaders used to process primitives.">Program</a> object to perform the operation on.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage to update.</td></tr>
    <tr><td class="paramname">first</td><td>First subroutine uniform location in the program to update, and corresponds to the first array entry in the <em>values</em> input.</td></tr>
    <tr><td class="paramname">count</td><td>Number of subroutine uniform locations to update, starting with uniform with location <em>first</em>, and corresponds to the number of entries in the input array <em>values</em>.</td></tr>
    <tr><td class="paramname">values</td><td>An array of <em>count</em> subroutine index values to be assigned to successive subroutine uniform locations, where the first entry in the array corresponds to subroutine uniform location <em>first</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a590a471152f386345e26f39e98890d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a590a471152f386345e26f39e98890d60">&#9670;&nbsp;</a></span>BindCoverageModulationTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::BindCoverageModulationTable </td>
          <td>(</td>
          <td class="paramtype">NVN_NOESCAPE const float *&#160;</td>
          <td class="paramname"><em>entries</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds or unbinds a coverage modulation table used for target-independent rasterization. </p>
<p>By default, the color modulation feature of target-independent rasterization scales color using a factor based on the fraction of covered samples. For example, if three out of four samples for a fragment are covered, the default modulation factor will be 0.75. This function allows applications to override this behavior by specifying a 16-element table of modulation factors. If the modulation table is used with a render target with N raster samples per color sample and M samples are covered in a fragment, the modulation factor will be <em>entries</em>[(M-1) * 16 / N]. If no modulation table is bound (i.e., <em>entries</em> is NULL), the modulation factor will be M / N.</p>
<p>By default, no modulation table is bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entries</td><td>Table of color modulation factors. If NULL, color modulation will use the fraction of covered raster samples as the color modulation factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ac239d2cc3ff8bc71004e3eeccac58e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ac239d2cc3ff8bc71004e3eeccac58e">&#9670;&nbsp;</a></span>ResolveDepthBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::ResolveDepthBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve depth values in a compressible depth render target. </p>
<p>Compressible depth render targets may store depth values in a compressed form, where individual values are reconstructed using compressed depth data and the current set of sample locations. This command decompresses the depth buffer, resolving individual depth values based on the current sample locations. This command should be used in the unlikely event that an application needs to change sample locations for a render target but use depth values that reflect the old locations. It is not necessary to decompress depth render targets for any other reason, including to use them for texture mapping. If there is no current depth render target, this command will have no effect. </p>

</div>
</div>
<a id="ad3e75447a4581e7722183ecd0a96e79d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e75447a4581e7722183ecd0a96e79d">&#9670;&nbsp;</a></span>SetColorReductionEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetColorReductionEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable lossy color reduction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>If NVN_TRUE, enable lossy color reduction. Otherwise disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a372c68297e7725dd87f78278078c7755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a372c68297e7725dd87f78278078c7755">&#9670;&nbsp;</a></span>SetColorReductionThresholds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetColorReductionThresholds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_format_class.html">FormatClass</a>&#160;</td>
          <td class="paramname"><em>formatClass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thresholdConservative</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thresholdAggressive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify new lossy color reduction thresholds for a format class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">formatClass</td><td><a class="el" href="structnvn_1_1_format.html" title="Identifies how data elements stored in texture or buffer objects are encoded.">Format</a> class for which to set thresholds</td></tr>
    <tr><td class="paramname">thresholdConservative</td><td>Color reduction threshold for possible primitive edges. This threshold is used if a tile is used for more than one rasterization operation before flushing to L2 cache.</td></tr>
    <tr><td class="paramname">thresholdAggressive</td><td>Color reduction threshold for interior pixels. This threshold is used if a tile is used for exactly once in a rasterization operation before flushing to L2 cache. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ca414869c25fb9412a0154b2eaa161a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca414869c25fb9412a0154b2eaa161a">&#9670;&nbsp;</a></span>PushDebugGroupStatic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::PushDebugGroupStatic </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pushes a debug group into the command stream. </p>
<p>Debug groups provide a method for annotating a command stream with discrete groups of commands using a descriptive name. New debug groups are pushed to the top of the debug group stack. Debug groups are strictly hierarchical and their sequences may be nested within other debug groups but can not overlap. These groups may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<p>This entry point is for use with debug groups whose description is composed of a static string. The contents of <code>description</code> are not copied. Applications must ensure the string storage used by <code>description</code> is not reclaimed as long as the command set can be executed on a queue, or it is part of a debug group stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>Debug domain ID. It is given by <a class="el" href="classnvn_1_1_device.html#a69e3e5dbe332486255a99e42cd232d69" title="This returns a unique ID by atomically incrementing a global counter on each request.">nvn::Device::GenerateDebugDomainId</a>. Different domain identifiers help debug tools to discriminate between concurrent, possibly overlapping, debug group stacks.</td></tr>
    <tr><td class="paramname">description</td><td>Text string used to annotate the debug group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37661d498010fdd4a2864b3431a125bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37661d498010fdd4a2864b3431a125bf">&#9670;&nbsp;</a></span>PushDebugGroupDynamic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::PushDebugGroupDynamic </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const char *&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pushes a debug group into the command stream. </p>
<p>Debug groups provide a method for annotating a command stream with discrete groups of commands using a descriptive name. New debug groups are pushed to the top of the debug group stack. Debug groups are strictly hierarchical and their sequences may be nested within other debug groups but can not overlap. These groups may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<p>This entry point is for use with debug groups whose description is composed of a dynamic string. The description string can be freed immediately after this function returns, unlike <a class="el" href="classnvn_1_1_command_buffer.html#a1ca414869c25fb9412a0154b2eaa161a" title="Pushes a debug group into the command stream.">nvn::CommandBuffer::PushDebugGroupStatic</a>. The contents of <code>description</code> are copied, and the copy is automatically stored as long as necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>Debug domain ID. It is given by <a class="el" href="classnvn_1_1_device.html#a69e3e5dbe332486255a99e42cd232d69" title="This returns a unique ID by atomically incrementing a global counter on each request.">nvn::Device::GenerateDebugDomainId</a>. Different domain identifiers help debug tools to discriminate between concurrent, possibly overlapping, debug group stacks.</td></tr>
    <tr><td class="paramname">description</td><td>Text string used to annotate the debug group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8acf5fdb35b068637c19659fde37b92c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8acf5fdb35b068637c19659fde37b92c">&#9670;&nbsp;</a></span>PushDebugGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::PushDebugGroup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pushes a debug group into the command stream. </p>
<p>Debug groups provide a method for annotating a command stream with discrete groups of commands using a descriptive name. New debug groups are pushed to the top of the debug group stack. Debug groups are strictly hierarchical and their sequences may be nested within other debug groups but can not overlap. These groups may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<p>This entry point is equivalent to calling <a class="el" href="classnvn_1_1_command_buffer.html#a1ca414869c25fb9412a0154b2eaa161a" title="Pushes a debug group into the command stream.">nvn::CommandBuffer::PushDebugGroupStatic</a> with a debug domain ID of 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">description</td><td>Text string used to annotate the debug group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7c191488de5f8de314d57431bc2ac98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c191488de5f8de314d57431bc2ac98">&#9670;&nbsp;</a></span>PopDebugGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::PopDebugGroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pops the active debug group off the command stream. </p>
<p>This entry point is equivalent to calling <a class="el" href="classnvn_1_1_command_buffer.html#a254c728bee850ebdb48b18b128165552" title="Pops the active debug group off the command stream.">nvn::CommandBuffer::PopDebugGroupId</a> with a debug domain ID of 0. </p>

</div>
</div>
<a id="a254c728bee850ebdb48b18b128165552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254c728bee850ebdb48b18b128165552">&#9670;&nbsp;</a></span>PopDebugGroupId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::PopDebugGroupId </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>domainId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pops the active debug group off the command stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>Debug domain ID. It is given by <a class="el" href="classnvn_1_1_device.html#a69e3e5dbe332486255a99e42cd232d69" title="This returns a unique ID by atomically incrementing a global counter on each request.">nvn::Device::GenerateDebugDomainId</a>. Different domain identifiers help debug tools to discriminate between concurrent, possibly overlapping, debug group stacks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5f79eabcd9a1d050d35c7dbed083063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f79eabcd9a1d050d35c7dbed083063">&#9670;&nbsp;</a></span>InsertDebugMarkerStatic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::InsertDebugMarkerStatic </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a debug event marker to the command stream. </p>
<p>Inserts a debug marker to annotate a command stream with a descriptive text marker. These event markers may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<p>This entry point is for use with debug markers whose description is composed of a static string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>Debug domain ID. It is given by <a class="el" href="classnvn_1_1_device.html#a69e3e5dbe332486255a99e42cd232d69" title="This returns a unique ID by atomically incrementing a global counter on each request.">nvn::Device::GenerateDebugDomainId</a>. Different domain identifiers help debug tools to discriminate between concurrent, possibly overlapping, debug group stacks.</td></tr>
    <tr><td class="paramname">description</td><td>Text string used to annotate the event marker. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20918b52737d705120dd9ae045438783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20918b52737d705120dd9ae045438783">&#9670;&nbsp;</a></span>InsertDebugMarkerDynamic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::InsertDebugMarkerDynamic </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const char *&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a debug event marker to the command stream. </p>
<p>Inserts a debug marker to annotate a command stream with a descriptive text marker. These event markers may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<p>This entry point can be used with dynamically allocated strings, as it copies the data onto the command buffer itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>Debug domain ID. It is given by <a class="el" href="classnvn_1_1_device.html#a69e3e5dbe332486255a99e42cd232d69" title="This returns a unique ID by atomically incrementing a global counter on each request.">nvn::Device::GenerateDebugDomainId</a>. Different domain identifiers help debug tools to discriminate between concurrent, possibly overlapping, debug group stacks.</td></tr>
    <tr><td class="paramname">description</td><td>Text string used to annotate the event marker. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0136544d13e04ed57e24ef1571efc4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0136544d13e04ed57e24ef1571efc4d4">&#9670;&nbsp;</a></span>InsertDebugMarker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::InsertDebugMarker </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a debug event marker to the command stream. </p>
<p>Inserts a debug marker to annotate a command stream with a descriptive text marker. These event markers may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<p>This entry point is identical to <a class="el" href="classnvn_1_1_command_buffer.html#ae5f79eabcd9a1d050d35c7dbed083063" title="Inserts a debug event marker to the command stream.">nvn::CommandBuffer::InsertDebugMarkerStatic</a> with a domainId of 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">description</td><td>Text string used to annotate the event marker. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64ada95e92249e9b1f3b1b166dbbf5f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ada95e92249e9b1f3b1b166dbbf5f5">&#9670;&nbsp;</a></span>WaitEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::WaitEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_event.html">Event</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_event_wait_mode.html">EventWaitMode</a>&#160;</td>
          <td class="paramname"><em>waitMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pause work on the GPU until an event is signaled. </p>
<p>When applications use this command, they are required to ensure that the memory associated with the event will eventually contain a value that passes the test specified by <em>waitMode</em>. If not, a GPU timeout error will occur.</p>
<dl class="section warning"><dt>Warning</dt><dd>On the Windows reference implementation, <a class="el" href="classnvn_1_1_event.html" title="Event object.">Event</a> objects do not support synchronization between queues. Submitting a command set containing a WaitEvent command on one queue to wait on an event signaled by a <a class="el" href="classnvn_1_1_command_buffer.html#a042cb09825770079f08e777509e6d8fe" title="Use the GPU to signal an Event object.">CommandBuffer::SignalEvent</a> command submitted to another queue may result in GPU timeout errors. Applications can use <a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress.">Sync</a> objects to reliably synchronize between queues on all platforms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td><a class="el" href="classnvn_1_1_event.html" title="Event object.">Event</a> object to wait on.</td></tr>
    <tr><td class="paramname">waitMode</td><td><a class="el" href="classnvn_1_1_event.html" title="Event object.">Event</a> wait mode. The wait mode specifies a test use to compare the value in memory associated with the <a class="el" href="classnvn_1_1_event.html" title="Event object.">Event</a> object and the <em>value</em> provided in this command. The event is considered to be signaled when this test passes.</td></tr>
    <tr><td class="paramname">value</td><td>Value to compare to the value in the <a class="el" href="classnvn_1_1_event.html" title="Event object.">Event</a> object's memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a042cb09825770079f08e777509e6d8fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a042cb09825770079f08e777509e6d8fe">&#9670;&nbsp;</a></span>SignalEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SignalEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_event.html">Event</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_event_signal_mode.html">EventSignalMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_event_signal_location.html">EventSignalLocation</a>&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_event_signal_flags.html">EventSignalFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the GPU to signal an <a class="el" href="classnvn_1_1_event.html" title="Event object.">Event</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td><a class="el" href="classnvn_1_1_event.html" title="Event object.">Event</a> object to signal.</td></tr>
    <tr><td class="paramname">mode</td><td>Method used to update the memory associated with the <a class="el" href="classnvn_1_1_event.html" title="Event object.">Event</a> object.</td></tr>
    <tr><td class="paramname">location</td><td>Location in the GPU pipeline that the command must reach before the signal operation is performed.</td></tr>
    <tr><td class="paramname">flags</td><td>Flags used to control the signal operation. See <a class="el" href="structnvn_1_1_event_signal_flags.html" title="Flags controlling the behavior of CommandBuffer::SignalEvent.">nvn::EventSignalFlags</a>.</td></tr>
    <tr><td class="paramname">value</td><td>Value used to update the memory associated with the <a class="el" href="classnvn_1_1_event.html" title="Event object.">Event</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a170337752e305883654a1d57a4727672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a170337752e305883654a1d57a4727672">&#9670;&nbsp;</a></span>SetStencilCullCriteria()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetStencilCullCriteria </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_stencil_func.html">StencilFunc</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the criteria that is used by the ZCull HW for stencil culling. </p>
<p>This function sets the criteria that is used by the ZCull HW for stencil culling. ZCull will only try to discard pixels/fragments if the cull criteria matches the current stencil state and if the depth texture of the current render target was created using the ZCULL_SUPPORT_STENCIL flag. Note that calling this function will make the current ZCull region invalid until the next clear. This might have a negative impact on the depth culling performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Stencil function to be used for stencil culling.</td></tr>
    <tr><td class="paramname">ref</td><td>Specify a stencil reference value used for stencil culling.</td></tr>
    <tr><td class="paramname">mask</td><td>Mask used for stencil culling. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26124ee79d34155d0bb4c18bf6c60ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26124ee79d34155d0bb4c18bf6c60ce1">&#9670;&nbsp;</a></span>OverrideSubtileSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::OverrideSubtileSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>override</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subtileSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override the default number of fragment shader warps in a single subtile. </p>
<p>Fragments generated by rasterization are arranged into groups called <em>subtiles</em>, which are processed as a unit by the fragment shading hardware. The subtile size is configured by the NVN driver, which computes a default subtile size based on properties of the fragment shader and GPU hardware. Larger subtiles can result in better locality for memory accesses, but also have increased overhead when launching, synchronizing, and retiring the larger sets of fragment shaders. This command allows applications to override the default subtile size in cases where the defaults are non-optimal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">override</td><td>Override the default subtile size. If true, use the subtile size specified by <em>subtileSize</em>. Otherwise, use a default subtile size derived from program state.</td></tr>
    <tr><td class="paramname">subtileSize</td><td>Subtile size used when overriding is enabled. When <em>override</em> is true, this specifies a limit on the maximum number of fragment shader warps contained in a single subtile. This parameter is expressed as a fraction of the maximum possible subtile size, with 128 specifying the maximum size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac563deb3fad19e40cc044ead3405da66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac563deb3fad19e40cc044ead3405da66">&#9670;&nbsp;</a></span>InsertCheckpointStatic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvn::CommandBuffer::InsertCheckpointStatic </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>markerData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>markerDataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a checkpoint event marker to the command set. </p>
<p>Inserts a checkpoint event marker into a command set. In case of a GPU crash, the checkpoint event markers that were last processed by the GPU will be included in NVN Aftermath crash dumps to aid in narrowing down the command that has led to the crash. The lifetime of the marker data specified when calling this entry point is managed by the application. The data is not copied and the application must ensure the memory pointed to by markerData is valid at least as long as the currently recorded command set can still be executed on a queue. If the checkpoint is set sucessfully, NVN_TRUE is returned. If any of the passed in parameters is invalid or a problem occurs when setting the checkpoint, NVN_FALSE is returned and no checkpoint is set.</p>
<dl class="section note"><dt>Note</dt><dd>This function is a no-op if the application is not linked with the NVN Aftermath target library.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">markerData</td><td>Data to associate with the checkpoint event marker.</td></tr>
    <tr><td class="paramname">markerDataSize</td><td>Size (in bytes) of the checkpoint event marker data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1dcfd6c8ea0149c2d399f37b405584e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1dcfd6c8ea0149c2d399f37b405584e">&#9670;&nbsp;</a></span>InsertCheckpointDynamic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvn::CommandBuffer::InsertCheckpointDynamic </td>
          <td>(</td>
          <td class="paramtype">NVN_NOESCAPE const void *&#160;</td>
          <td class="paramname"><em>markerData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>markerDataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a checkpoint event marker to the command set. </p>
<p>Inserts a checkpoint event marker into a command set. In case of a GPU crash, the checkpoint event markers that were last processed by the GPU will be included in NVN Aftermath crash dumps to aid in narrowing down the command that has led to the crash. The lifetime of the marker data specified when calling this entry point only needs to extend for the duration of the call. A copy of the data is made and the application can free the passed in marker data buffer immediately after this function returns. If the checkpoint is set sucessfully, NVN_TRUE is returned. If any of the passed in parameters is invalid or a problem occurs when setting the checkpoint, NVN_FALSE is returned and no checkpoint is set.</p>
<dl class="section note"><dt>Note</dt><dd>This function is a no-op if the application is not linked with the NVN Aftermath target library.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">markerData</td><td>Data to associate with the checkpoint event marker.</td></tr>
    <tr><td class="paramname">markerDataSize</td><td>Size (in bytes) of the checkpoint event marker data. Must be less than or equal to 256 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da59ee1b0df65ffd67b76253229da80801" title="Maximum size (in bytes) of dynamic checkpoint marker data.">nvn::DeviceInfo::CHECKPOINT_MAXIMUM_DYNAMIC_MARKER_DATA_SIZE</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a867ce7911d6dd0a54ed509459ed7d744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a867ce7911d6dd0a54ed509459ed7d744">&#9670;&nbsp;</a></span>SetZCullZF32CompressionEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::CommandBuffer::SetZCullZF32CompressionEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables/Disables the compression for ZF32 values in the ZCull <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">Buffer</a>. </p>
<p>By default ZF32 values (i.e., the contents of <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a0cb28bb8f5f7fefa56888fa11c373c81" title="A 32-bit floating-point depth component.">nvn::Format::DEPTH32F</a> or <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a57b3319d5b05a91d1599dfbbf4edc924" title="A 32-bit floating-point depth component packed with an 8-bit unsigned integer stencil component.">nvn::Format::DEPTH32F_STENCIL8</a> depth buffers) are compressed in the ZCull buffer, i.e. equivalent to setting 'enable' to 'true'. Since the compression is lossy, this can significantly reduce the ZCull performance for depth values near 0.0. When using GREATER as depth function it is recommended to disable ZF32Compression for the case where precision near 0.0 is required. Toggling the ZF32 compression mode is a comparatively slow operation. Frequent toggles may adversely affect performance. After toggling, the result of any ZCull test will be undefined until after a depth buffer is cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>If NVN_TRUE, enable ZF32 compression. Otherwise disable it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
