<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nvn::Queue Class Reference | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenvn.html">nvn</a></li><li class="navelem"><a class="el" href="classnvn_1_1_queue.html">Queue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classnvn_1_1_queue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">nvn::Queue Class Reference<div class="ingroups"><a class="el" href="group__nvn__cpp__interface.html">NVN C++ API Bindings</a> &raquo; <a class="el" href="group__nvn__cpp__apiclasses.html">API Classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>API class used to send commands to the GPU.  
 <a href="classnvn_1_1_queue.html#details">More...</a></p>

<p><code>#include &lt;nvn/nvn_Cpp.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae1f5ed18214950f9d34a55cc61ab9ef6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_queue.html#ae1f5ed18214950f9d34a55cc61ab9ef6">FenceSync</a> (<a class="el" href="classnvn_1_1_sync.html">Sync</a> *sync, <a class="el" href="structnvn_1_1_sync_condition.html">SyncCondition</a> condition, <a class="el" href="structnvn_1_1_sync_flag_bits.html">SyncFlagBits</a> flags)</td></tr>
<tr class="memdesc:ae1f5ed18214950f9d34a55cc61ab9ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a <a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress.">Sync</a> object as signaled when all previous commands have completed in the <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU.">Queue</a> object.  <a href="classnvn_1_1_queue.html#ae1f5ed18214950f9d34a55cc61ab9ef6">More...</a><br /></td></tr>
<tr class="separator:ae1f5ed18214950f9d34a55cc61ab9ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f835fbb1c61e33764e40456ab0a95a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_queue.html#a73f835fbb1c61e33764e40456ab0a95a">Finalize</a> ()</td></tr>
<tr class="memdesc:a73f835fbb1c61e33764e40456ab0a95a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU.">Queue</a> object.  <a href="classnvn_1_1_queue.html#a73f835fbb1c61e33764e40456ab0a95a">More...</a><br /></td></tr>
<tr class="separator:a73f835fbb1c61e33764e40456ab0a95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca51bcfefab8f580172fb0fd43a0431f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_queue.html#aca51bcfefab8f580172fb0fd43a0431f">Finish</a> ()</td></tr>
<tr class="memdesc:aca51bcfefab8f580172fb0fd43a0431f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until all commands previously submitted to a queue have completed execution.  <a href="classnvn_1_1_queue.html#aca51bcfefab8f580172fb0fd43a0431f">More...</a><br /></td></tr>
<tr class="separator:aca51bcfefab8f580172fb0fd43a0431f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf561605d8b58cc923342539f90466f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_queue.html#abf561605d8b58cc923342539f90466f1">Flush</a> ()</td></tr>
<tr class="memdesc:abf561605d8b58cc923342539f90466f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush commands previously submitted to a queue for processing.  <a href="classnvn_1_1_queue.html#abf561605d8b58cc923342539f90466f1">More...</a><br /></td></tr>
<tr class="separator:abf561605d8b58cc923342539f90466f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbf84856df0276128ffef1c6c4cd05c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnvn_1_1_queue_get_error_result.html">QueueGetErrorResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_queue.html#acdbf84856df0276128ffef1c6c4cd05c">GetError</a> (<a class="el" href="unionnvn_1_1_queue_error_info.html">QueueErrorInfo</a> *errorInfo)</td></tr>
<tr class="memdesc:acdbf84856df0276128ffef1c6c4cd05c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get GPU error status of the queue.  <a href="classnvn_1_1_queue.html#acdbf84856df0276128ffef1c6c4cd05c">More...</a><br /></td></tr>
<tr class="separator:acdbf84856df0276128ffef1c6c4cd05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139c7e7a7e280f1a87e0a56436009142"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_queue.html#a139c7e7a7e280f1a87e0a56436009142">GetTotalCommandMemoryUsed</a> ()</td></tr>
<tr class="memdesc:a139c7e7a7e280f1a87e0a56436009142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query total queue command memory usage.  <a href="classnvn_1_1_queue.html#a139c7e7a7e280f1a87e0a56436009142">More...</a><br /></td></tr>
<tr class="separator:a139c7e7a7e280f1a87e0a56436009142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d7fd9337d254e9a81bc7e2fb3e0756"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_queue.html#a95d7fd9337d254e9a81bc7e2fb3e0756">GetTotalComputeMemoryUsed</a> ()</td></tr>
<tr class="memdesc:a95d7fd9337d254e9a81bc7e2fb3e0756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query total queue compute memory usage.  <a href="classnvn_1_1_queue.html#a95d7fd9337d254e9a81bc7e2fb3e0756">More...</a><br /></td></tr>
<tr class="separator:a95d7fd9337d254e9a81bc7e2fb3e0756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32700aee92f014ff277f5a27f1665b5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_queue.html#ad32700aee92f014ff277f5a27f1665b5">GetTotalControlMemoryUsed</a> ()</td></tr>
<tr class="memdesc:ad32700aee92f014ff277f5a27f1665b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query total queue control memory usage.  <a href="classnvn_1_1_queue.html#ad32700aee92f014ff277f5a27f1665b5">More...</a><br /></td></tr>
<tr class="separator:ad32700aee92f014ff277f5a27f1665b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6962c3ca8109ba904a8bff54a5b1d2be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_queue.html#a6962c3ca8109ba904a8bff54a5b1d2be">Initialize</a> (const <a class="el" href="classnvn_1_1_queue_builder.html">QueueBuilder</a> *builder)</td></tr>
<tr class="memdesc:a6962c3ca8109ba904a8bff54a5b1d2be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU.">Queue</a> object from a queue builder.  <a href="classnvn_1_1_queue.html#a6962c3ca8109ba904a8bff54a5b1d2be">More...</a><br /></td></tr>
<tr class="separator:a6962c3ca8109ba904a8bff54a5b1d2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e0218cebe6125389832d447d4b0e54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_queue.html#a62e0218cebe6125389832d447d4b0e54">PresentTexture</a> (<a class="el" href="classnvn_1_1_window.html">Window</a> *window, int textureIndex)</td></tr>
<tr class="memdesc:a62e0218cebe6125389832d447d4b0e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display the contents of a texture into the window.  <a href="classnvn_1_1_queue.html#a62e0218cebe6125389832d447d4b0e54">More...</a><br /></td></tr>
<tr class="separator:a62e0218cebe6125389832d447d4b0e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e41fc089298232cd421f614def75cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_queue.html#aa6e41fc089298232cd421f614def75cb">ResetMemoryUsageCounts</a> ()</td></tr>
<tr class="memdesc:aa6e41fc089298232cd421f614def75cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset usage counters for command, control and compute memory.  <a href="classnvn_1_1_queue.html#aa6e41fc089298232cd421f614def75cb">More...</a><br /></td></tr>
<tr class="separator:aa6e41fc089298232cd421f614def75cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd642a1c65a354234270815e5359340"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_queue.html#a6dd642a1c65a354234270815e5359340">SetDebugLabel</a> (const char *label)</td></tr>
<tr class="memdesc:a6dd642a1c65a354234270815e5359340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug label string for a <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU.">Queue</a> object.  <a href="classnvn_1_1_queue.html#a6dd642a1c65a354234270815e5359340">More...</a><br /></td></tr>
<tr class="separator:a6dd642a1c65a354234270815e5359340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3211beb342c3d0c4752ac00019a4aca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_queue.html#ab3211beb342c3d0c4752ac00019a4aca">SubmitCommands</a> (int numCommands, const <a class="el" href="group__nvn__cpp__handle.html#ga48a6926aea0b934109f96ae32027b7fb">CommandHandle</a> *handles)</td></tr>
<tr class="memdesc:ab3211beb342c3d0c4752ac00019a4aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit commands encapsulated in command buffers to a queue for processing.  <a href="classnvn_1_1_queue.html#ab3211beb342c3d0c4752ac00019a4aca">More...</a><br /></td></tr>
<tr class="separator:ab3211beb342c3d0c4752ac00019a4aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339d246e329a173e81d8e1cf2a550113"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_queue.html#a339d246e329a173e81d8e1cf2a550113">WaitSync</a> (const <a class="el" href="classnvn_1_1_sync.html">Sync</a> *sync)</td></tr>
<tr class="memdesc:a339d246e329a173e81d8e1cf2a550113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a <a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress.">Sync</a> object to be signaled on the GPU before processing any further commands in the specified <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU.">Queue</a> object.  <a href="classnvn_1_1_queue.html#a339d246e329a173e81d8e1cf2a550113">More...</a><br /></td></tr>
<tr class="separator:a339d246e329a173e81d8e1cf2a550113"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>API class used to send commands to the GPU. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="nvnsimple_2_nvn_simple_shared_lib_2_graphics_system_8h-example.html#_a4">nvnsimple/NvnSimpleSharedLib/GraphicsSystem.h</a>.</dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="acdbf84856df0276128ffef1c6c4cd05c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdbf84856df0276128ffef1c6c4cd05c">&#9670;&nbsp;</a></span>GetError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnvn_1_1_queue_get_error_result.html">QueueGetErrorResult</a> nvn::Queue::GetError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionnvn_1_1_queue_error_info.html">QueueErrorInfo</a> *&#160;</td>
          <td class="paramname"><em>errorInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get GPU error status of the queue. </p>
<p>Applications can use this function to check if queue encountered unrecoverable GPU error such as invalid GPU memory accesses, invalid command, timeout or other errors. After GPU error queue is in faulted state and following behavior is expected:</p><ol type="1">
<li><a class="el" href="group__nvn__c__functions.html#gaab3c15f657cefdff33dab453795ff38f" title="Wait until all commands previously submitted to a queue have completed execution.">nvnQueueFinish()</a> returns immediately.</li>
<li><a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress.">Sync</a> objects placed into faulted queue signal completion.</li>
<li>Faulted queue can be finalized to free resources.</li>
<li>Remaining nvnQueue API calls for faulted queue are ignored or return error.</li>
<li>Other device queues are not affected or blocked by faulted queue.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">errorInfo</td><td>Pointer to structure to save information about error. If set to NULL, information will not be retrieved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a139c7e7a7e280f1a87e0a56436009142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139c7e7a7e280f1a87e0a56436009142">&#9670;&nbsp;</a></span>GetTotalCommandMemoryUsed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvn::Queue::GetTotalCommandMemoryUsed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query total queue command memory usage. </p>
<p>This command returns the total amount of queue command memory (in bytes) used by queue commands since the queue was initialized or since usage counts were last reset by <a class="el" href="classnvn_1_1_queue.html#aa6e41fc089298232cd421f614def75cb" title="Reset usage counters for command, control and compute memory.">Queue::ResetMemoryUsageCounts</a>. The total memory usage count can be used by application developers to determine the amount of memory to provide when initializing a queue. Note that memory usage counts may exceed the total amount of memory provided to the queue since the NVN driver will automatically reuse queue memory when required. </p>

</div>
</div>
<a id="ad32700aee92f014ff277f5a27f1665b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad32700aee92f014ff277f5a27f1665b5">&#9670;&nbsp;</a></span>GetTotalControlMemoryUsed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvn::Queue::GetTotalControlMemoryUsed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query total queue control memory usage. </p>
<p>This command returns the total amount of queue control memory (in bytes) used by queue commands since the queue was initialized or since usage counts were last reset by <a class="el" href="classnvn_1_1_queue.html#aa6e41fc089298232cd421f614def75cb" title="Reset usage counters for command, control and compute memory.">Queue::ResetMemoryUsageCounts</a>. The total memory usage count can be used by application developers to determine the amount of memory to provide when initializing a queue. Note that memory usage counts may exceed the total amount of memory provided to the queue since the NVN driver will automatically reuse queue memory when required. </p>

</div>
</div>
<a id="a95d7fd9337d254e9a81bc7e2fb3e0756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d7fd9337d254e9a81bc7e2fb3e0756">&#9670;&nbsp;</a></span>GetTotalComputeMemoryUsed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvn::Queue::GetTotalComputeMemoryUsed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query total queue compute memory usage. </p>
<p>This command returns the total amount of queue compute memory (in bytes) used by queue commands since the queue was initialized or since usage counts were last reset by <a class="el" href="classnvn_1_1_queue.html#aa6e41fc089298232cd421f614def75cb" title="Reset usage counters for command, control and compute memory.">Queue::ResetMemoryUsageCounts</a>. The total memory usage count can be used by application developers to determine the amount of memory to provide when initializing a queue. Note that memory usage counts may exceed the total amount of memory provided to the queue since the NVN driver will automatically reuse queue memory when required. </p>

</div>
</div>
<a id="aa6e41fc089298232cd421f614def75cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e41fc089298232cd421f614def75cb">&#9670;&nbsp;</a></span>ResetMemoryUsageCounts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Queue::ResetMemoryUsageCounts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset usage counters for command, control and compute memory. </p>
<p>This command resets the accumulated usage counters for queue command, control, and compute memory.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU.">Queue</a> memory consumed by GPU commands may not be added to the usage counters reset by this command until the queue is next flushed. When total queue memory usage is queried, any memory used by unflushed commands will be added to the total usage counters. As a result, querying memory usage immediately after resetting counters may return non-zero values if the queue has unflushed commands. </dd></dl>

</div>
</div>
<a id="a6962c3ca8109ba904a8bff54a5b1d2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6962c3ca8109ba904a8bff54a5b1d2be">&#9670;&nbsp;</a></span>Initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvn::Queue::Initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_queue_builder.html">QueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU.">Queue</a> object from a queue builder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="classnvn_1_1_queue_builder.html" title="Object specifying state used to construct new queue objects.">QueueBuilder</a> object holding properties of the new <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU.">Queue</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73f835fbb1c61e33764e40456ab0a95a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f835fbb1c61e33764e40456ab0a95a">&#9670;&nbsp;</a></span>Finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Queue::Finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU.">Queue</a> object. </p>
<dl class="section note"><dt>Note</dt><dd>Finalizing a queue will wait for the completion of all commands previously submitted to the queue, including those sent by the driver during queue initialization. </dd></dl>

</div>
</div>
<a id="a6dd642a1c65a354234270815e5359340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd642a1c65a354234270815e5359340">&#9670;&nbsp;</a></span>SetDebugLabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Queue::SetDebugLabel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debug label string for a <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU.">Queue</a> object. </p>
<p>Annotates a <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU.">Queue</a> object with a descriptive text label. This label may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Text string used to annotate the <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU.">Queue</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3211beb342c3d0c4752ac00019a4aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3211beb342c3d0c4752ac00019a4aca">&#9670;&nbsp;</a></span>SubmitCommands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Queue::SubmitCommands </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numCommands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__nvn__cpp__handle.html#ga48a6926aea0b934109f96ae32027b7fb">CommandHandle</a> *&#160;</td>
          <td class="paramname"><em>handles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit commands encapsulated in command buffers to a queue for processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numCommands</td><td>Number of command buffers to send.</td></tr>
    <tr><td class="paramname">handles</td><td>Array of numCommands handles for the command buffers to send. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf561605d8b58cc923342539f90466f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf561605d8b58cc923342539f90466f1">&#9670;&nbsp;</a></span>Flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Queue::Flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush commands previously submitted to a queue for processing. </p>
<p>Commands submitted to <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU.">Queue</a> objects may be batched up by the implementation to avoid the overhead that would be involved in flushing each command immediately after it is submitted. Flush can be used to manually flush commands that were previously batched up. </p>

</div>
</div>
<a id="aca51bcfefab8f580172fb0fd43a0431f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca51bcfefab8f580172fb0fd43a0431f">&#9670;&nbsp;</a></span>Finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Queue::Finish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until all commands previously submitted to a queue have completed execution. </p>
<p>This command will not return to the caller until the previously submitted commands have completed. To determine if submitted commands have completed without blocking, applications can use <a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress.">Sync</a> objects and Sync::WaitSync(). Finish will automatically flush the previously submitted commands as part of its operation. </p>

</div>
</div>
<a id="a62e0218cebe6125389832d447d4b0e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e0218cebe6125389832d447d4b0e54">&#9670;&nbsp;</a></span>PresentTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Queue::PresentTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnvn_1_1_window.html">Window</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>textureIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Display the contents of a texture into the window. </p>
<p>This command presents the texture specified by <em>textureIndex</em> in the native window associated with <em>window</em>. It also triggers an implicit call to <a class="el" href="classnvn_1_1_queue.html#abf561605d8b58cc923342539f90466f1" title="Flush commands previously submitted to a queue for processing.">Queue::Flush</a> so that the texture is guaranteed to be shown on the screen in finite time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>The window where the texture should be presented.</td></tr>
    <tr><td class="paramname">textureIndex</td><td>The index of the texture to be displayed on-screen. The texture must be previously acquired from <em>window</em> using <a class="el" href="classnvn_1_1_window.html#a2be5d9eb053d407b738dd18bf86801e8" title="Acquire a texture from the window.">Window::AcquireTexture</a>. <a class="el" href="classnvn_1_1_queue.html#a62e0218cebe6125389832d447d4b0e54" title="Display the contents of a texture into the window.">Queue::PresentTexture</a> transfers the ownership of the texture back to the platform windowing system, and the application must re-acquire it with <a class="el" href="classnvn_1_1_window.html#a2be5d9eb053d407b738dd18bf86801e8" title="Acquire a texture from the window.">Window::AcquireTexture</a> before using it again. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1f5ed18214950f9d34a55cc61ab9ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f5ed18214950f9d34a55cc61ab9ef6">&#9670;&nbsp;</a></span>FenceSync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Queue::FenceSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnvn_1_1_sync.html">Sync</a> *&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_sync_condition.html">SyncCondition</a>&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_sync_flag_bits.html">SyncFlagBits</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a <a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress.">Sync</a> object as signaled when all previous commands have completed in the <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU.">Queue</a> object. </p>
<dl class="section warning"><dt>Warning</dt><dd>FenceSync commands are not automatically flushed for processing by the GPU. Before waiting on a FenceSync call with the CPU using <a class="el" href="classnvn_1_1_sync.html#ad1eb41d009bcd4e48bebe3573bb32397" title="Wait for a Sync object to be signaled on the CPU before returning.">Sync::Wait</a> or from another <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU.">Queue</a> using <a class="el" href="classnvn_1_1_queue.html#a339d246e329a173e81d8e1cf2a550113" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">Queue::WaitSync</a>, applications must ensure that the previous FenceSync call was flushed using <a class="el" href="classnvn_1_1_queue.html#abf561605d8b58cc923342539f90466f1" title="Flush commands previously submitted to a queue for processing.">Queue::Flush</a>. Waiting on a FenceSync call using <a class="el" href="classnvn_1_1_queue.html#a339d246e329a173e81d8e1cf2a550113" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">Queue::WaitSync</a> in the same queue requires no manual flush.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If tiled caching is enabled, this command will trigger an implicit tiled cache flush.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync</td><td><a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress.">Sync</a> object to mark as signaled when commands complete.</td></tr>
    <tr><td class="paramname">condition</td><td>Type of command completion to wait for.</td></tr>
    <tr><td class="paramname">flags</td><td>Bitfield of additional operations to perform before signaling. See <a class="el" href="structnvn_1_1_sync_flag_bits.html" title="Specifies additional operations performed when a FenceSync command is processed.">nvn::SyncFlagBits</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a339d246e329a173e81d8e1cf2a550113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a339d246e329a173e81d8e1cf2a550113">&#9670;&nbsp;</a></span>WaitSync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvn::Queue::WaitSync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_sync.html">Sync</a> *&#160;</td>
          <td class="paramname"><em>sync</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a <a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress.">Sync</a> object to be signaled on the GPU before processing any further commands in the specified <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU.">Queue</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync</td><td><a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress.">Sync</a> object to wait on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
