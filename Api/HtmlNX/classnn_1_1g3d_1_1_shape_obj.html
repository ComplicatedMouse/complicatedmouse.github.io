<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nn::g3d::ShapeObj Class Reference | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenn.html">nn</a></li><li class="navelem"><a class="el" href="namespacenn_1_1g3d.html">g3d</a></li><li class="navelem"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html">ShapeObj</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="classnn_1_1g3d_1_1_shape_obj-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">nn::g3d::ShapeObj Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Shape instances.  
 <a href="classnn_1_1g3d_1_1_shape_obj.html#details">More...</a></p>

<p><code>#include &lt;nn/g3d/g3d_ShapeObj.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj_1_1_builder.html">Builder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class that builds the <code><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html" title="Shape instances.">ShapeObj</a></code> instance.  <a href="classnn_1_1g3d_1_1_shape_obj_1_1_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj_1_1_initialize_argument.html">InitializeArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <b>The use of internal features is prohibited.</b> Parameter passed to <code>ShapeObj::Initialize()</code> to perform initialization.  <a href="classnn_1_1g3d_1_1_shape_obj_1_1_initialize_argument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a324377c158258439ceb8d5c2573d8bb8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a324377c158258439ceb8d5c2573d8bb8">Alignment</a> { <a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a324377c158258439ceb8d5c2573d8bb8a6083dd58eaffe3866fecd81fb437a0b9">Alignment_Buffer</a> = MatrixVectorAlignment
 }</td></tr>
<tr class="memdesc:a324377c158258439ceb8d5c2573d8bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Required alignment size of the buffer that is passed when the instance is being built.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a324377c158258439ceb8d5c2573d8bb8">More...</a><br /></td></tr>
<tr class="separator:a324377c158258439ceb8d5c2573d8bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and Destructors</div></td></tr>
<tr class="memitem:af6d03e27a48f193a0aaafa2380c13919"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#af6d03e27a48f193a0aaafa2380c13919">ShapeObj</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af6d03e27a48f193a0aaafa2380c13919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classnn_1_1g3d_1_1_shape_obj.html#af6d03e27a48f193a0aaafa2380c13919">More...</a><br /></td></tr>
<tr class="separator:af6d03e27a48f193a0aaafa2380c13919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba82136231db018f912733940a36dc4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a0ba82136231db018f912733940a36dc4">CalculateBlockBufferSize</a> (<a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *pDevice) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0ba82136231db018f912733940a36dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the uniform block size.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a0ba82136231db018f912733940a36dc4">More...</a><br /></td></tr>
<tr class="separator:a0ba82136231db018f912733940a36dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cabdabea5964ffbfb204dd0e4bd5bf1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a7cabdabea5964ffbfb204dd0e4bd5bf1">SetupBlockBuffer</a> (<a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *pDevice, <a class="el" href="namespacenn_1_1gfx.html#ad620d8208dd309eb7c4dd5973a6aeee5">nn::gfx::MemoryPool</a> *pMemoryPool, ptrdiff_t offset, size_t memoryPoolSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7cabdabea5964ffbfb204dd0e4bd5bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passes a memory pool and builds a uniform block.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a7cabdabea5964ffbfb204dd0e4bd5bf1">More...</a><br /></td></tr>
<tr class="separator:a7cabdabea5964ffbfb204dd0e4bd5bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62907045e2b301d7f347752106eec7af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a62907045e2b301d7f347752106eec7af">CleanupBlockBuffer</a> (<a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *pDevice) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a62907045e2b301d7f347752106eec7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the uniform block.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a62907045e2b301d7f347752106eec7af">More...</a><br /></td></tr>
<tr class="separator:a62907045e2b301d7f347752106eec7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Updating</div></td></tr>
<tr class="memitem:afa580dfcb0fac318789e05bf22ab949c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#afa580dfcb0fac318789e05bf22ab949c">CalculateBounding</a> (const <a class="el" href="classnn_1_1g3d_1_1_skeleton_obj.html">SkeletonObj</a> *pSkeleton) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:afa580dfcb0fac318789e05bf22ab949c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the bounding sphere for mesh 0.  <a href="classnn_1_1g3d_1_1_shape_obj.html#afa580dfcb0fac318789e05bf22ab949c">More...</a><br /></td></tr>
<tr class="separator:afa580dfcb0fac318789e05bf22ab949c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1a0c59dab38304e64db8d6831ce75d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a3e1a0c59dab38304e64db8d6831ce75d">CalculateBounding</a> (const <a class="el" href="classnn_1_1g3d_1_1_skeleton_obj.html">SkeletonObj</a> *pSkeleton, int meshIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3e1a0c59dab38304e64db8d6831ce75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the bounding sphere for the specified mesh.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a3e1a0c59dab38304e64db8d6831ce75d">More...</a><br /></td></tr>
<tr class="separator:a3e1a0c59dab38304e64db8d6831ce75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3875fc401453548f6e5fdf3928abdee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ad3875fc401453548f6e5fdf3928abdee">CalculateSubMeshBounding</a> (const <a class="el" href="classnn_1_1g3d_1_1_skeleton_obj.html">SkeletonObj</a> *pSkeleton) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad3875fc401453548f6e5fdf3928abdee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the bounding box for the submeshes of mesh 0.  <a href="classnn_1_1g3d_1_1_shape_obj.html#ad3875fc401453548f6e5fdf3928abdee">More...</a><br /></td></tr>
<tr class="separator:ad3875fc401453548f6e5fdf3928abdee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4ed8a8cbc3c3e702b1f1b20d2a5536"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a5d4ed8a8cbc3c3e702b1f1b20d2a5536">CalculateSubMeshBounding</a> (const <a class="el" href="classnn_1_1g3d_1_1_skeleton_obj.html">SkeletonObj</a> *pSkeleton, int meshIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5d4ed8a8cbc3c3e702b1f1b20d2a5536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the bounding box for the submeshes of the specified mesh.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a5d4ed8a8cbc3c3e702b1f1b20d2a5536">More...</a><br /></td></tr>
<tr class="separator:a5d4ed8a8cbc3c3e702b1f1b20d2a5536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b2fc3bb7e76ccac3700abfa9bd5ab8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ac9b2fc3bb7e76ccac3700abfa9bd5ab8">CalculateShape</a> (int viewIndex, const <a class="el" href="namespacenn_1_1util.html#afb360b0e9579454c6af5804cc476c101">nn::util::Matrix4x3fType</a> &amp;worldMtx, int bufferIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac9b2fc3bb7e76ccac3700abfa9bd5ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates render resources for shapes.  <a href="classnn_1_1g3d_1_1_shape_obj.html#ac9b2fc3bb7e76ccac3700abfa9bd5ab8">More...</a><br /></td></tr>
<tr class="separator:ac9b2fc3bb7e76ccac3700abfa9bd5ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad274ec723501d412ea5d513e69c64a73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ad274ec723501d412ea5d513e69c64a73">ClearDynamicVertexBuffer</a> (int bufferIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad274ec723501d412ea5d513e69c64a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the value of the dynamic vertex buffer, restoring it to the original vertex buffer value.  <a href="classnn_1_1g3d_1_1_shape_obj.html#ad274ec723501d412ea5d513e69c64a73">More...</a><br /></td></tr>
<tr class="separator:ad274ec723501d412ea5d513e69c64a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Getting and Setting</div></td></tr>
<tr class="memitem:a8f7bc2a51ba63d4488ff2d6d7d5e0937"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a8f7bc2a51ba63d4488ff2d6d7d5e0937">GetBlockBufferAlignment</a> (<a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *pDevice) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8f7bc2a51ba63d4488ff2d6d7d5e0937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the alignment required by the uniform block.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a8f7bc2a51ba63d4488ff2d6d7d5e0937">More...</a><br /></td></tr>
<tr class="separator:a8f7bc2a51ba63d4488ff2d6d7d5e0937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877f7c0f4f853151966321c4b969c45b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnn_1_1g3d_1_1_res_shape.html">ResShape</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a877f7c0f4f853151966321c4b969c45b">GetResource</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a877f7c0f4f853151966321c4b969c45b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a resource.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a877f7c0f4f853151966321c4b969c45b">More...</a><br /></td></tr>
<tr class="separator:a877f7c0f4f853151966321c4b969c45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160c8f620f415ad2c3fcfcc0da86ea4f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a160c8f620f415ad2c3fcfcc0da86ea4f">GetBufferPtr</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a160c8f620f415ad2c3fcfcc0da86ea4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the buffer passed when <code><a class="el" href="classnn_1_1g3d_1_1_shape_obj_1_1_builder.html" title="The class that builds the ShapeObj instance.">Builder</a></code> called the <code>Build()</code> function.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a160c8f620f415ad2c3fcfcc0da86ea4f">More...</a><br /></td></tr>
<tr class="separator:a160c8f620f415ad2c3fcfcc0da86ea4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ca4b89b13c955925424be0dfeb79d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1gfx.html#ad620d8208dd309eb7c4dd5973a6aeee5">nn::gfx::MemoryPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ad1ca4b89b13c955925424be0dfeb79d5">GetMemoryPoolPtr</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad1ca4b89b13c955925424be0dfeb79d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to the memory pool that was passed when <code><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a7cabdabea5964ffbfb204dd0e4bd5bf1" title="Passes a memory pool and builds a uniform block.">SetupBlockBuffer()</a></code> was called.  <a href="classnn_1_1g3d_1_1_shape_obj.html#ad1ca4b89b13c955925424be0dfeb79d5">More...</a><br /></td></tr>
<tr class="separator:ad1ca4b89b13c955925424be0dfeb79d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad133182bc588fb9fc2285cadd3423de0"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ad133182bc588fb9fc2285cadd3423de0">GetMemoryPoolOffset</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad133182bc588fb9fc2285cadd3423de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the offset of the memory pool that was passed when <code><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a7cabdabea5964ffbfb204dd0e4bd5bf1" title="Passes a memory pool and builds a uniform block.">SetupBlockBuffer()</a></code> was called.  <a href="classnn_1_1g3d_1_1_shape_obj.html#ad133182bc588fb9fc2285cadd3423de0">More...</a><br /></td></tr>
<tr class="separator:ad133182bc588fb9fc2285cadd3423de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e08f29f39bbbfc84101739e7a23c02"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a96e08f29f39bbbfc84101739e7a23c02">IsBlockBufferValid</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a96e08f29f39bbbfc84101739e7a23c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the uniform block has been built.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a96e08f29f39bbbfc84101739e7a23c02">More...</a><br /></td></tr>
<tr class="separator:a96e08f29f39bbbfc84101739e7a23c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada67c3109b9cda5212bcdeca8d2348bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ada67c3109b9cda5212bcdeca8d2348bf">IsDynamicVertexBufferValid</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ada67c3109b9cda5212bcdeca8d2348bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the dynamic vertex buffer has been built.  <a href="classnn_1_1g3d_1_1_shape_obj.html#ada67c3109b9cda5212bcdeca8d2348bf">More...</a><br /></td></tr>
<tr class="separator:ada67c3109b9cda5212bcdeca8d2348bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40ab5352dfd30bc5e42f9aff17a70dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#af40ab5352dfd30bc5e42f9aff17a70dc">GetMaterialIndex</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af40ab5352dfd30bc5e42f9aff17a70dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the index to the referenced <code><a class="el" href="classnn_1_1g3d_1_1_res_material.html" title="The material resource.">ResMaterial</a></code>.  <a href="classnn_1_1g3d_1_1_shape_obj.html#af40ab5352dfd30bc5e42f9aff17a70dc">More...</a><br /></td></tr>
<tr class="separator:af40ab5352dfd30bc5e42f9aff17a70dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2779416450c45a319b2c7bc2abfa5a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a4e2779416450c45a319b2c7bc2abfa5a">GetBoneIndex</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4e2779416450c45a319b2c7bc2abfa5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the index to the referenced <code><a class="el" href="classnn_1_1g3d_1_1_res_bone.html" title="Bone resource.">ResBone</a></code>.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a4e2779416450c45a319b2c7bc2abfa5a">More...</a><br /></td></tr>
<tr class="separator:a4e2779416450c45a319b2c7bc2abfa5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff949952a39b416c12e09018666f555"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a9ff949952a39b416c12e09018666f555">GetVertexIndex</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9ff949952a39b416c12e09018666f555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the index to the referenced <code><a class="el" href="classnn_1_1g3d_1_1_res_vertex.html" title="Vertex information resources.">ResVertex</a></code>.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a9ff949952a39b416c12e09018666f555">More...</a><br /></td></tr>
<tr class="separator:a9ff949952a39b416c12e09018666f555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75f67b6366474039749b9e4106780ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ac75f67b6366474039749b9e4106780ba">GetVertexSkinCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac75f67b6366474039749b9e4106780ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of bones needed for smooth skinning.  <a href="classnn_1_1g3d_1_1_shape_obj.html#ac75f67b6366474039749b9e4106780ba">More...</a><br /></td></tr>
<tr class="separator:ac75f67b6366474039749b9e4106780ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94497b52f362ce706ce19d95e83621e6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a94497b52f362ce706ce19d95e83621e6">IsRigidBody</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a94497b52f362ce706ce19d95e83621e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a shape is a rigid body shape.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a94497b52f362ce706ce19d95e83621e6">More...</a><br /></td></tr>
<tr class="separator:a94497b52f362ce706ce19d95e83621e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7df9878fca8f101db113b28eed9b272"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ab7df9878fca8f101db113b28eed9b272">IsRigidSkinning</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab7df9878fca8f101db113b28eed9b272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a shape uses rigid skinning.  <a href="classnn_1_1g3d_1_1_shape_obj.html#ab7df9878fca8f101db113b28eed9b272">More...</a><br /></td></tr>
<tr class="separator:ab7df9878fca8f101db113b28eed9b272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca46c9cc157f944073e1a20cb720f99"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a0ca46c9cc157f944073e1a20cb720f99">IsSmoothSkinning</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0ca46c9cc157f944073e1a20cb720f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a shape uses smooth skinning.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a0ca46c9cc157f944073e1a20cb720f99">More...</a><br /></td></tr>
<tr class="separator:a0ca46c9cc157f944073e1a20cb720f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4250dd1621b8717ab126aa3d43a18fa8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnn_1_1g3d_1_1_res_mesh.html">ResMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a4250dd1621b8717ab126aa3d43a18fa8">GetResMesh</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4250dd1621b8717ab126aa3d43a18fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a mesh.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a4250dd1621b8717ab126aa3d43a18fa8">More...</a><br /></td></tr>
<tr class="separator:a4250dd1621b8717ab126aa3d43a18fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193348f627beda4bfa8a47cc2980f12d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnn_1_1g3d_1_1_res_mesh.html">ResMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a193348f627beda4bfa8a47cc2980f12d">GetResMesh</a> (int meshIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a193348f627beda4bfa8a47cc2980f12d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a mesh.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a193348f627beda4bfa8a47cc2980f12d">More...</a><br /></td></tr>
<tr class="separator:a193348f627beda4bfa8a47cc2980f12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3880bc46da44ec036bedb940b5b3d5d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#af3880bc46da44ec036bedb940b5b3d5d">GetMeshCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af3880bc46da44ec036bedb940b5b3d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of meshes.  <a href="classnn_1_1g3d_1_1_shape_obj.html#af3880bc46da44ec036bedb940b5b3d5d">More...</a><br /></td></tr>
<tr class="separator:af3880bc46da44ec036bedb940b5b3d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9932dc0d155a493eaa6d4abd18970fa0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a9932dc0d155a493eaa6d4abd18970fa0">GetViewCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9932dc0d155a493eaa6d4abd18970fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of views.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a9932dc0d155a493eaa6d4abd18970fa0">More...</a><br /></td></tr>
<tr class="separator:a9932dc0d155a493eaa6d4abd18970fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07131b7bd1633a73acff2b021ebd45a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a07131b7bd1633a73acff2b021ebd45a7">GetSubMeshCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a07131b7bd1633a73acff2b021ebd45a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of submeshes.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a07131b7bd1633a73acff2b021ebd45a7">More...</a><br /></td></tr>
<tr class="separator:a07131b7bd1633a73acff2b021ebd45a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6072233b7f32e07f3fdbeda866258c40"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a6072233b7f32e07f3fdbeda866258c40">GetSubMeshCount</a> (int meshIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6072233b7f32e07f3fdbeda866258c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of submeshes for the specified mesh.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a6072233b7f32e07f3fdbeda866258c40">More...</a><br /></td></tr>
<tr class="separator:a6072233b7f32e07f3fdbeda866258c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db7c7b7e7b3be79c4a06722bf2c7bcd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a5db7c7b7e7b3be79c4a06722bf2c7bcd">IsViewDependent</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5db7c7b7e7b3be79c4a06722bf2c7bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the shape is view-dependent.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a5db7c7b7e7b3be79c4a06722bf2c7bcd">More...</a><br /></td></tr>
<tr class="separator:a5db7c7b7e7b3be79c4a06722bf2c7bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962fd9c318f3763a92bf3549a2396c4e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a962fd9c318f3763a92bf3549a2396c4e">GetShapeBlockCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a962fd9c318f3763a92bf3549a2396c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of uniform blocks for each shape.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a962fd9c318f3763a92bf3549a2396c4e">More...</a><br /></td></tr>
<tr class="separator:a962fd9c318f3763a92bf3549a2396c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90eb0caf66948a4bab1ab07bc0eae384"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a90eb0caf66948a4bab1ab07bc0eae384">GetShapeBlock</a> (int viewIndex, int bufferIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a90eb0caf66948a4bab1ab07bc0eae384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the buffer for the uniform block per shape.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a90eb0caf66948a4bab1ab07bc0eae384">More...</a><br /></td></tr>
<tr class="separator:a90eb0caf66948a4bab1ab07bc0eae384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f887028ec44b37b074a8ead5256c298"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a0f887028ec44b37b074a8ead5256c298">GetShapeBlock</a> (int viewIndex, int bufferIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0f887028ec44b37b074a8ead5256c298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the buffer for the uniform block per shape.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a0f887028ec44b37b074a8ead5256c298">More...</a><br /></td></tr>
<tr class="separator:a0f887028ec44b37b074a8ead5256c298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661802cb989edfb1f765e53a9ada92f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a661802cb989edfb1f765e53a9ada92f1">GetBufferingCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a661802cb989edfb1f765e53a9ada92f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of uniform blocks for buffering.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a661802cb989edfb1f765e53a9ada92f1">More...</a><br /></td></tr>
<tr class="separator:a661802cb989edfb1f765e53a9ada92f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a96b326ce84b4dc7867b09a3c2fad1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a59a96b326ce84b4dc7867b09a3c2fad1">IsBlockSwapEnabled</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a59a96b326ce84b4dc7867b09a3c2fad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether an endian swap will be conducted for the uniform block.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a59a96b326ce84b4dc7867b09a3c2fad1">More...</a><br /></td></tr>
<tr class="separator:a59a96b326ce84b4dc7867b09a3c2fad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035541674c664057eb66b958c3d763cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a035541674c664057eb66b958c3d763cf">SetUserPtr</a> (void *pUserPtr) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a035541674c664057eb66b958c3d763cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a user pointer.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a035541674c664057eb66b958c3d763cf">More...</a><br /></td></tr>
<tr class="separator:a035541674c664057eb66b958c3d763cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53aeee059d9dc6b38482bb4f4cc2eb9a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a53aeee059d9dc6b38482bb4f4cc2eb9a">GetUserPtr</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a53aeee059d9dc6b38482bb4f4cc2eb9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the user pointer.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a53aeee059d9dc6b38482bb4f4cc2eb9a">More...</a><br /></td></tr>
<tr class="separator:a53aeee059d9dc6b38482bb4f4cc2eb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205405441aa99765f735d51f82e0d205"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a205405441aa99765f735d51f82e0d205">GetUserPtr</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a205405441aa99765f735d51f82e0d205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the user pointer.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a205405441aa99765f735d51f82e0d205">More...</a><br /></td></tr>
<tr class="separator:a205405441aa99765f735d51f82e0d205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81206653da41f37c6b924f4f3fcd2bb5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a81206653da41f37c6b924f4f3fcd2bb5"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a81206653da41f37c6b924f4f3fcd2bb5">GetUserPtr</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a81206653da41f37c6b924f4f3fcd2bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the user pointer.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a81206653da41f37c6b924f4f3fcd2bb5">More...</a><br /></td></tr>
<tr class="separator:a81206653da41f37c6b924f4f3fcd2bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1680667038c121f969470d162d933af"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af1680667038c121f969470d162d933af"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#af1680667038c121f969470d162d933af">GetUserPtr</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af1680667038c121f969470d162d933af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the user pointer.  <a href="classnn_1_1g3d_1_1_shape_obj.html#af1680667038c121f969470d162d933af">More...</a><br /></td></tr>
<tr class="separator:af1680667038c121f969470d162d933af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cbc2ed0a34709b6ec841559e92abb0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a13cbc2ed0a34709b6ec841559e92abb0">GetName</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a13cbc2ed0a34709b6ec841559e92abb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the shape name.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a13cbc2ed0a34709b6ec841559e92abb0">More...</a><br /></td></tr>
<tr class="separator:a13cbc2ed0a34709b6ec841559e92abb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366192ea48975363a42b6793469b484c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a366192ea48975363a42b6793469b484c">GetUserArea</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a366192ea48975363a42b6793469b484c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to the user area.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a366192ea48975363a42b6793469b484c">More...</a><br /></td></tr>
<tr class="separator:a366192ea48975363a42b6793469b484c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af057a8b378cb6d7ee94a8b95c545fcb4"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#af057a8b378cb6d7ee94a8b95c545fcb4">GetUserArea</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af057a8b378cb6d7ee94a8b95c545fcb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to the user area.  <a href="classnn_1_1g3d_1_1_shape_obj.html#af057a8b378cb6d7ee94a8b95c545fcb4">More...</a><br /></td></tr>
<tr class="separator:af057a8b378cb6d7ee94a8b95c545fcb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadace6bf4ef3fd23b28664052981a336"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aadace6bf4ef3fd23b28664052981a336"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#aadace6bf4ef3fd23b28664052981a336">GetUserArea</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aadace6bf4ef3fd23b28664052981a336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to the user area.  <a href="classnn_1_1g3d_1_1_shape_obj.html#aadace6bf4ef3fd23b28664052981a336">More...</a><br /></td></tr>
<tr class="separator:aadace6bf4ef3fd23b28664052981a336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5d31af5f0d71847aaca41377ba1212"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acc5d31af5f0d71847aaca41377ba1212"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#acc5d31af5f0d71847aaca41377ba1212">GetUserArea</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acc5d31af5f0d71847aaca41377ba1212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to the user area.  <a href="classnn_1_1g3d_1_1_shape_obj.html#acc5d31af5f0d71847aaca41377ba1212">More...</a><br /></td></tr>
<tr class="separator:acc5d31af5f0d71847aaca41377ba1212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67c5f9f13e2158953143b56433cae26"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ab67c5f9f13e2158953143b56433cae26">GetUserAreaSize</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab67c5f9f13e2158953143b56433cae26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the user area.  <a href="classnn_1_1g3d_1_1_shape_obj.html#ab67c5f9f13e2158953143b56433cae26">More...</a><br /></td></tr>
<tr class="separator:ab67c5f9f13e2158953143b56433cae26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Vertex Information</div></td></tr>
<tr class="memitem:acd76605a682a3ca3676ab91d6fe62c24"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnn_1_1g3d_1_1_res_vertex.html">ResVertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#acd76605a682a3ca3676ab91d6fe62c24">GetResVertex</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acd76605a682a3ca3676ab91d6fe62c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the referenced <code><a class="el" href="classnn_1_1g3d_1_1_res_vertex.html" title="Vertex information resources.">ResVertex</a></code>.  <a href="classnn_1_1g3d_1_1_shape_obj.html#acd76605a682a3ca3676ab91d6fe62c24">More...</a><br /></td></tr>
<tr class="separator:acd76605a682a3ca3676ab91d6fe62c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987abf75f6288206255df95bbd891cde"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a987abf75f6288206255df95bbd891cde">GetVertexAttrCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a987abf75f6288206255df95bbd891cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of vertex attributes of the referenced <code><a class="el" href="classnn_1_1g3d_1_1_res_vertex.html" title="Vertex information resources.">ResVertex</a></code>.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a987abf75f6288206255df95bbd891cde">More...</a><br /></td></tr>
<tr class="separator:a987abf75f6288206255df95bbd891cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae44347c36040e406258524943d95d40"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnn_1_1g3d_1_1_res_vertex_attr.html">ResVertexAttr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#aae44347c36040e406258524943d95d40">GetResVertexAttr</a> (int attrIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aae44347c36040e406258524943d95d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vertex attributes by looking up the index.  <a href="classnn_1_1g3d_1_1_shape_obj.html#aae44347c36040e406258524943d95d40">More...</a><br /></td></tr>
<tr class="separator:aae44347c36040e406258524943d95d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7115a44dc383289e8887b4c20c00313"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnn_1_1g3d_1_1_res_vertex_attr.html">ResVertexAttr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#aa7115a44dc383289e8887b4c20c00313">FindResVertexAttr</a> (const char *name) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa7115a44dc383289e8887b4c20c00313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vertex attributes by looking up the name.  <a href="classnn_1_1g3d_1_1_shape_obj.html#aa7115a44dc383289e8887b4c20c00313">More...</a><br /></td></tr>
<tr class="separator:aa7115a44dc383289e8887b4c20c00313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065d7bd66a8484c0a818e6fa6dac7b8f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a065d7bd66a8484c0a818e6fa6dac7b8f">GetVertexAttrName</a> (int attribIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a065d7bd66a8484c0a818e6fa6dac7b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vertex attribute name from the index.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a065d7bd66a8484c0a818e6fa6dac7b8f">More...</a><br /></td></tr>
<tr class="separator:a065d7bd66a8484c0a818e6fa6dac7b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d864c5b51adbbe0f8ac2568c1052240"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a2d864c5b51adbbe0f8ac2568c1052240">FindVertexAttrIndex</a> (const char *name) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2d864c5b51adbbe0f8ac2568c1052240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the index from the vertex attribute name.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a2d864c5b51adbbe0f8ac2568c1052240">More...</a><br /></td></tr>
<tr class="separator:a2d864c5b51adbbe0f8ac2568c1052240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38bfb2f1f02e9f47bf4a8796194c08e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a38bfb2f1f02e9f47bf4a8796194c08e8">GetVertexBufferCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a38bfb2f1f02e9f47bf4a8796194c08e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of vertex buffers for the referenced <code><a class="el" href="classnn_1_1g3d_1_1_res_vertex.html" title="Vertex information resources.">ResVertex</a></code>.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a38bfb2f1f02e9f47bf4a8796194c08e8">More...</a><br /></td></tr>
<tr class="separator:a38bfb2f1f02e9f47bf4a8796194c08e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c79150775d457e82c04d5ba635ef7c5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a1c79150775d457e82c04d5ba635ef7c5">GetVertexBuffer</a> (int bufferIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1c79150775d457e82c04d5ba635ef7c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a vertex buffer from an index.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a1c79150775d457e82c04d5ba635ef7c5">More...</a><br /></td></tr>
<tr class="separator:a1c79150775d457e82c04d5ba635ef7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69e4c2322bd35a5bc750dd5df3574f9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnn_1_1gfx_1_1_buffer_info.html">nn::gfx::BufferInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ac69e4c2322bd35a5bc750dd5df3574f9">GetVertexBufferInfo</a> (int bufferIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac69e4c2322bd35a5bc750dd5df3574f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vertex buffer information from an index.  <a href="classnn_1_1g3d_1_1_shape_obj.html#ac69e4c2322bd35a5bc750dd5df3574f9">More...</a><br /></td></tr>
<tr class="separator:ac69e4c2322bd35a5bc750dd5df3574f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Bounding</div></td></tr>
<tr class="memitem:a311a863e4d0810ddffa988344af47974"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1g3d_1_1_sphere.html">Sphere</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a311a863e4d0810ddffa988344af47974">GetBounding</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a311a863e4d0810ddffa988344af47974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the bounding sphere on the world coordinate system for the shape.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a311a863e4d0810ddffa988344af47974">More...</a><br /></td></tr>
<tr class="separator:a311a863e4d0810ddffa988344af47974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2ab901b61469513d334f5a6d29d535"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1g3d_1_1_sphere.html">Sphere</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a1b2ab901b61469513d334f5a6d29d535">GetBounding</a> (int meshIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1b2ab901b61469513d334f5a6d29d535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the bounding sphere in world coordinates for the specified mesh.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a1b2ab901b61469513d334f5a6d29d535">More...</a><br /></td></tr>
<tr class="separator:a1b2ab901b61469513d334f5a6d29d535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35c8f2e29190cfc6012aad9c671edf3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structnn_1_1g3d_1_1_sphere.html">Sphere</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ad35c8f2e29190cfc6012aad9c671edf3">GetBounding</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad35c8f2e29190cfc6012aad9c671edf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the bounding sphere on the world coordinate system for the shape.  <a href="classnn_1_1g3d_1_1_shape_obj.html#ad35c8f2e29190cfc6012aad9c671edf3">More...</a><br /></td></tr>
<tr class="separator:ad35c8f2e29190cfc6012aad9c671edf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d123d46ed75284aec03f721b9d7b45"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structnn_1_1g3d_1_1_sphere.html">Sphere</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#aa7d123d46ed75284aec03f721b9d7b45">GetBounding</a> (int meshIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa7d123d46ed75284aec03f721b9d7b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the bounding sphere in world coordinates for the specified mesh.  <a href="classnn_1_1g3d_1_1_shape_obj.html#aa7d123d46ed75284aec03f721b9d7b45">More...</a><br /></td></tr>
<tr class="separator:aa7d123d46ed75284aec03f721b9d7b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584937fcde20904ba97d7df31366f0d0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structnn_1_1g3d_1_1_aabb.html">Aabb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a584937fcde20904ba97d7df31366f0d0">GetSubMeshBoundingArray</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a584937fcde20904ba97d7df31366f0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the submesh AABB array in world coordinates.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a584937fcde20904ba97d7df31366f0d0">More...</a><br /></td></tr>
<tr class="separator:a584937fcde20904ba97d7df31366f0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309a21916d5b1921a5106bce6c872b9f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structnn_1_1g3d_1_1_aabb.html">Aabb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a309a21916d5b1921a5106bce6c872b9f">GetSubMeshBoundingArray</a> (int meshIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a309a21916d5b1921a5106bce6c872b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the AABB array in world coordinates for the submeshes of the specified mesh.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a309a21916d5b1921a5106bce6c872b9f">More...</a><br /></td></tr>
<tr class="separator:a309a21916d5b1921a5106bce6c872b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c0526e70aef8f5ac9512196c1f5d14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a25c0526e70aef8f5ac9512196c1f5d14">TestSubMeshIntersection</a> (<a class="el" href="structnn_1_1g3d_1_1_culling_context.html">CullingContext</a> *pCtx, const <a class="el" href="structnn_1_1g3d_1_1_view_volume.html">ViewVolume</a> &amp;volume) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a25c0526e70aef8f5ac9512196c1f5d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets serial submeshes that intersect with the view volume.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a25c0526e70aef8f5ac9512196c1f5d14">More...</a><br /></td></tr>
<tr class="separator:a25c0526e70aef8f5ac9512196c1f5d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc539bbe698f6a400f2e9f4fb1daeaea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#afc539bbe698f6a400f2e9f4fb1daeaea">TestSubMeshIntersection</a> (<a class="el" href="structnn_1_1g3d_1_1_culling_context.html">CullingContext</a> *pCtx, const <a class="el" href="structnn_1_1g3d_1_1_view_volume.html">ViewVolume</a> &amp;volume, int meshIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:afc539bbe698f6a400f2e9f4fb1daeaea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the contiguous submeshes that intersect with the view volume for the specified mesh.  <a href="classnn_1_1g3d_1_1_shape_obj.html#afc539bbe698f6a400f2e9f4fb1daeaea">More...</a><br /></td></tr>
<tr class="separator:afc539bbe698f6a400f2e9f4fb1daeaea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64775081aa11a283658bfef401c7694"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ab64775081aa11a283658bfef401c7694">TestSubMeshLodIntersection</a> (<a class="el" href="structnn_1_1g3d_1_1_culling_context.html">CullingContext</a> *pCtx, const <a class="el" href="structnn_1_1g3d_1_1_view_volume.html">ViewVolume</a> &amp;volume, <a class="el" href="structnn_1_1g3d_1_1_i_calculate_lod_level_functor.html">ICalculateLodLevelFunctor</a> &amp;calcLodFunctor) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab64775081aa11a283658bfef401c7694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets serial submeshes with equal LOD levels that intersect with the view volume.  <a href="classnn_1_1g3d_1_1_shape_obj.html#ab64775081aa11a283658bfef401c7694">More...</a><br /></td></tr>
<tr class="separator:ab64775081aa11a283658bfef401c7694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7a151dcaf87f835b29b9e09404c21c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a2c7a151dcaf87f835b29b9e09404c21c">MakeSubMeshRange</a> (<a class="el" href="structnn_1_1g3d_1_1_sub_mesh_range.html">SubMeshRange</a> *pRangeArray, const <a class="el" href="structnn_1_1g3d_1_1_view_volume.html">ViewVolume</a> &amp;volume) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2c7a151dcaf87f835b29b9e09404c21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a range array for connected submeshes that intersect with the view volume.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a2c7a151dcaf87f835b29b9e09404c21c">More...</a><br /></td></tr>
<tr class="separator:a2c7a151dcaf87f835b29b9e09404c21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9151525ed04761e24e47ac9370c8db96"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a9151525ed04761e24e47ac9370c8db96">MakeSubMeshRange</a> (<a class="el" href="structnn_1_1g3d_1_1_sub_mesh_range.html">SubMeshRange</a> *pRangeArray, const <a class="el" href="structnn_1_1g3d_1_1_view_volume.html">ViewVolume</a> &amp;volume, int meshIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9151525ed04761e24e47ac9370c8db96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the contiguous submesh range array that intersects with the view volume, with a specified mesh index.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a9151525ed04761e24e47ac9370c8db96">More...</a><br /></td></tr>
<tr class="separator:a9151525ed04761e24e47ac9370c8db96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc83b0a0933cef444306411994a2720b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#adc83b0a0933cef444306411994a2720b">MakeSubMeshLodRange</a> (<a class="el" href="structnn_1_1g3d_1_1_sub_mesh_range.html">SubMeshRange</a> *pRangeArray, const <a class="el" href="structnn_1_1g3d_1_1_view_volume.html">ViewVolume</a> &amp;volume, <a class="el" href="structnn_1_1g3d_1_1_i_calculate_lod_level_functor.html">ICalculateLodLevelFunctor</a> &amp;calcLodFunctor) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:adc83b0a0933cef444306411994a2720b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a range array of serial submeshes with equal LOD levels that intersect with the view volume.  <a href="classnn_1_1g3d_1_1_shape_obj.html#adc83b0a0933cef444306411994a2720b">More...</a><br /></td></tr>
<tr class="separator:adc83b0a0933cef444306411994a2720b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Key Shapes</div></td></tr>
<tr class="memitem:a7b0e8fd440a0a3a99cf4fc71793f9484"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a7b0e8fd440a0a3a99cf4fc71793f9484">GetKeyShapeCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7b0e8fd440a0a3a99cf4fc71793f9484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of key shapes.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a7b0e8fd440a0a3a99cf4fc71793f9484">More...</a><br /></td></tr>
<tr class="separator:a7b0e8fd440a0a3a99cf4fc71793f9484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae682c5ed1aee0a94d64c85aae80daf0f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnn_1_1g3d_1_1_res_key_shape.html">ResKeyShape</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ae682c5ed1aee0a94d64c85aae80daf0f">GetResKeyShape</a> (int keyShapeIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae682c5ed1aee0a94d64c85aae80daf0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the key shape by looking up the index.  <a href="classnn_1_1g3d_1_1_shape_obj.html#ae682c5ed1aee0a94d64c85aae80daf0f">More...</a><br /></td></tr>
<tr class="separator:ae682c5ed1aee0a94d64c85aae80daf0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d6937bdfdb9d9374bcb8b48cccd07f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnn_1_1g3d_1_1_res_key_shape.html">ResKeyShape</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ac7d6937bdfdb9d9374bcb8b48cccd07f">FindResKeyShape</a> (const char *name) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac7d6937bdfdb9d9374bcb8b48cccd07f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the key shape by looking up the name.  <a href="classnn_1_1g3d_1_1_shape_obj.html#ac7d6937bdfdb9d9374bcb8b48cccd07f">More...</a><br /></td></tr>
<tr class="separator:ac7d6937bdfdb9d9374bcb8b48cccd07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89891c755056ab332f0b1cdcf6bb3190"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a89891c755056ab332f0b1cdcf6bb3190">GetKeyShapeName</a> (int keyShapeIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a89891c755056ab332f0b1cdcf6bb3190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the key shape name from the index.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a89891c755056ab332f0b1cdcf6bb3190">More...</a><br /></td></tr>
<tr class="separator:a89891c755056ab332f0b1cdcf6bb3190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850c286d793fca69dea82b4d15612fca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a850c286d793fca69dea82b4d15612fca">FindKeyShapeIndex</a> (const char *name) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a850c286d793fca69dea82b4d15612fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the index from the key shape name.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a850c286d793fca69dea82b4d15612fca">More...</a><br /></td></tr>
<tr class="separator:a850c286d793fca69dea82b4d15612fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30fa8adfe8b77687b7f416d9026757e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ac30fa8adfe8b77687b7f416d9026757e">GetTargetAttribCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac30fa8adfe8b77687b7f416d9026757e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of vertex attributes of key shapes.  <a href="classnn_1_1g3d_1_1_shape_obj.html#ac30fa8adfe8b77687b7f416d9026757e">More...</a><br /></td></tr>
<tr class="separator:ac30fa8adfe8b77687b7f416d9026757e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e6561517350f639c148c701992fad9"><td class="memItemLeft" align="right" valign="top"><a id="aa8e6561517350f639c148c701992fad9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#aa8e6561517350f639c148c701992fad9">ClearBlendWeights</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa8e6561517350f639c148c701992fad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the blend weights of key shapes. <br /></td></tr>
<tr class="separator:aa8e6561517350f639c148c701992fad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69625ebe1a4a5920e0cc48cf02be2d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ab69625ebe1a4a5920e0cc48cf02be2d7">HasValidBlendWeight</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab69625ebe1a4a5920e0cc48cf02be2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the object has a valid key shape blending weight.  <a href="classnn_1_1g3d_1_1_shape_obj.html#ab69625ebe1a4a5920e0cc48cf02be2d7">More...</a><br /></td></tr>
<tr class="separator:ab69625ebe1a4a5920e0cc48cf02be2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0aadad1cc0cc4ed59b0777886932936"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#af0aadad1cc0cc4ed59b0777886932936">SetBlendWeight</a> (int keyShapeIndex, float weight) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af0aadad1cc0cc4ed59b0777886932936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the blend weights of key shapes.  <a href="classnn_1_1g3d_1_1_shape_obj.html#af0aadad1cc0cc4ed59b0777886932936">More...</a><br /></td></tr>
<tr class="separator:af0aadad1cc0cc4ed59b0777886932936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e4e6ea528f00f34f5c6a2913a435d9"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a60e4e6ea528f00f34f5c6a2913a435d9">GetBlendWeight</a> (int keyShapeIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a60e4e6ea528f00f34f5c6a2913a435d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the blend weights of key shapes.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a60e4e6ea528f00f34f5c6a2913a435d9">More...</a><br /></td></tr>
<tr class="separator:a60e4e6ea528f00f34f5c6a2913a435d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f338c38b6c82c09d6aa85edc5b47d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#af0f338c38b6c82c09d6aa85edc5b47d2">IsBlendWeightValid</a> (int keyShapeIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af0f338c38b6c82c09d6aa85edc5b47d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the blend weights of key shapes are enabled.  <a href="classnn_1_1g3d_1_1_shape_obj.html#af0f338c38b6c82c09d6aa85edc5b47d2">More...</a><br /></td></tr>
<tr class="separator:af0f338c38b6c82c09d6aa85edc5b47d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622d803b4f893d861e563fa1ef70f2ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a622d803b4f893d861e563fa1ef70f2ff">CountValidBlendWeight</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a622d803b4f893d861e563fa1ef70f2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of valid key shape blending weights.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a622d803b4f893d861e563fa1ef70f2ff">More...</a><br /></td></tr>
<tr class="separator:a622d803b4f893d861e563fa1ef70f2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Shape Animation</h2></td></tr>
<tr class="memitem:ade842941f47fbbe74a09e389491a4089"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ade842941f47fbbe74a09e389491a4089">Flag</a> { <br />
&#160;&#160;<a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ade842941f47fbbe74a09e389491a4089aa030233056f81a0e7a8d7d6b20f4eb34">Flag_BlockBufferValid</a> = 0x1 &lt;&lt; 0
, <br />
&#160;&#160;<a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ade842941f47fbbe74a09e389491a4089ac2c408f15f62b0af48bb38c5054ab1b6">Flag_BlendWeightValid</a> = 0x1 &lt;&lt; 1
, <br />
&#160;&#160;<a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ade842941f47fbbe74a09e389491a4089aa8d1ad92b6c3560cd0b604a8467ee403">Flag_DynamicVertexBufferValid</a> = 0x1 &lt;&lt; 2
, <br />
&#160;&#160;<a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ade842941f47fbbe74a09e389491a4089ac7fc49a2b3c56d5e773ef878dd4918b2">Flag_ShapeAnimCalculationEnabled</a> = 0x1 &lt;&lt; 3
<br />
 }</td></tr>
<tr class="memdesc:ade842941f47fbbe74a09e389491a4089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag representing the shape state.  <a href="classnn_1_1g3d_1_1_shape_obj.html#ade842941f47fbbe74a09e389491a4089">More...</a><br /></td></tr>
<tr class="separator:ade842941f47fbbe74a09e389491a4089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4a3bb0f3b5b441b59ea06290f5c3e9"><td class="memItemLeft" align="right" valign="top"><a id="aba4a3bb0f3b5b441b59ea06290f5c3e9"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>BoundingCoord</b> </td></tr>
<tr class="separator:aba4a3bb0f3b5b441b59ea06290f5c3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa636a5bcd302aa52cf9bbd7458a7f3be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#aa636a5bcd302aa52cf9bbd7458a7f3be">SetShapeAnimCalculationEnabled</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa636a5bcd302aa52cf9bbd7458a7f3be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the setting to calculate the shape animation result in the CPU and apply that result to the dynamic vertex buffer.  <a href="classnn_1_1g3d_1_1_shape_obj.html#aa636a5bcd302aa52cf9bbd7458a7f3be">More...</a><br /></td></tr>
<tr class="separator:aa636a5bcd302aa52cf9bbd7458a7f3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec368ccdfe5304756ef9794790725634"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#aec368ccdfe5304756ef9794790725634">SetShapeAnimCalculationDisabled</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aec368ccdfe5304756ef9794790725634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the setting to calculate the shape animation result in the CPU and apply that result to the dynamic vertex buffer.  <a href="classnn_1_1g3d_1_1_shape_obj.html#aec368ccdfe5304756ef9794790725634">More...</a><br /></td></tr>
<tr class="separator:aec368ccdfe5304756ef9794790725634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ab340a171e3e6a865fd488a1286ab8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ab9ab340a171e3e6a865fd488a1286ab8">IsShapeAnimCalculationEnabled</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab9ab340a171e3e6a865fd488a1286ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the setting has been enabled to calculate the shape animation result in the CPU and apply that result to the dynamic vertex buffer.  <a href="classnn_1_1g3d_1_1_shape_obj.html#ab9ab340a171e3e6a865fd488a1286ab8">More...</a><br /></td></tr>
<tr class="separator:ab9ab340a171e3e6a865fd488a1286ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b2ae60fa6b3f6e9f5e2cf0934143c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a49b2ae60fa6b3f6e9f5e2cf0934143c6">CalculateShapeAnimResult</a> (int bufferIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a49b2ae60fa6b3f6e9f5e2cf0934143c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the dynamic vertex buffer from the key shape and blending weight.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a49b2ae60fa6b3f6e9f5e2cf0934143c6">More...</a><br /></td></tr>
<tr class="separator:a49b2ae60fa6b3f6e9f5e2cf0934143c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153dbe394d39548d8336b3d3ba87652e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a153dbe394d39548d8336b3d3ba87652e">GetDynamicVertexBuffer</a> (int vertexBufferIndex, int bufferIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a153dbe394d39548d8336b3d3ba87652e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a dynamic vertex buffer from an index.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a153dbe394d39548d8336b3d3ba87652e">More...</a><br /></td></tr>
<tr class="separator:a153dbe394d39548d8336b3d3ba87652e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba77fbe6ff27faf4ee74987655b22ecf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#aba77fbe6ff27faf4ee74987655b22ecf">IsDynamicVertexAttr</a> (int vertexAttrIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aba77fbe6ff27faf4ee74987655b22ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a vertex attribute specified by its index is included in the dynamic vertex buffer.  <a href="classnn_1_1g3d_1_1_shape_obj.html#aba77fbe6ff27faf4ee74987655b22ecf">More...</a><br /></td></tr>
<tr class="separator:aba77fbe6ff27faf4ee74987655b22ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6be9b6a4067792ff55b9665a5660a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a2e6be9b6a4067792ff55b9665a5660a7">SetShapeBlockArray</a> (<a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a> *pBlockArray) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2e6be9b6a4067792ff55b9665a5660a7"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <b>The use of internal features is prohibited.</b> Sets the buffer array for uniform blocks.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a2e6be9b6a4067792ff55b9665a5660a7">More...</a><br /></td></tr>
<tr class="separator:a2e6be9b6a4067792ff55b9665a5660a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49dd09490b1b087accb0df529831c20e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a49dd09490b1b087accb0df529831c20e">GetShapeBlockArray</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a49dd09490b1b087accb0df529831c20e"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <b>The use of internal features is prohibited.</b> Gets the buffer array for uniform blocks.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a49dd09490b1b087accb0df529831c20e">More...</a><br /></td></tr>
<tr class="separator:a49dd09490b1b087accb0df529831c20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274da3f4ecd7deda5fe4431c9c24c7d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a274da3f4ecd7deda5fe4431c9c24c7d8">GetDynamicVertexBufferArray</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a274da3f4ecd7deda5fe4431c9c24c7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <b>The use of internal features is prohibited.</b> Gets a pointer to the dynamic vertex buffer array.  <a href="classnn_1_1g3d_1_1_shape_obj.html#a274da3f4ecd7deda5fe4431c9c24c7d8">More...</a><br /></td></tr>
<tr class="separator:a274da3f4ecd7deda5fe4431c9c24c7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Shape instances. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_shape_animation_8cpp-example.html#_a75">G3dDemo/ShapeAnimation.cpp</a>, <a class="el" href="_g3d_demo_2_simple_8cpp-example.html#_a83">G3dDemo/Simple.cpp</a>, and <a class="el" href="_g3d_demo_2_town_8cpp-example.html#_a116">G3dDemo/Town.cpp</a>.</dd>
</dl>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a324377c158258439ceb8d5c2573d8bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324377c158258439ceb8d5c2573d8bb8">&#9670;&nbsp;</a></span>Alignment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a324377c158258439ceb8d5c2573d8bb8">nn::g3d::ShapeObj::Alignment</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Required alignment size of the buffer that is passed when the instance is being built. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a324377c158258439ceb8d5c2573d8bb8a6083dd58eaffe3866fecd81fb437a0b9"></a>Alignment_Buffer&#160;</td><td class="fielddoc"><p>The alignment size required for the buffer passed to <code><a class="el" href="classnn_1_1g3d_1_1_shape_obj_1_1_builder.html" title="The class that builds the ShapeObj instance.">Builder</a></code>. </p>
</td></tr>
</table>

</div>
</div>
<a id="ade842941f47fbbe74a09e389491a4089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade842941f47fbbe74a09e389491a4089">&#9670;&nbsp;</a></span>Flag</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ade842941f47fbbe74a09e389491a4089">nn::g3d::ShapeObj::Flag</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag representing the shape state. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ade842941f47fbbe74a09e389491a4089aa030233056f81a0e7a8d7d6b20f4eb34"></a>Flag_BlockBufferValid&#160;</td><td class="fielddoc"><p> <b>The use of internal features is prohibited.</b> Flag indicating whether the uniform block has been built. </p>
</td></tr>
<tr><td class="fieldname"><a id="ade842941f47fbbe74a09e389491a4089ac2c408f15f62b0af48bb38c5054ab1b6"></a>Flag_BlendWeightValid&#160;</td><td class="fielddoc"><p> <b>The use of internal features is prohibited.</b> Flag indicating whether the key shape's blend weight was changed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ade842941f47fbbe74a09e389491a4089aa8d1ad92b6c3560cd0b604a8467ee403"></a>Flag_DynamicVertexBufferValid&#160;</td><td class="fielddoc"><p> <b>The use of internal features is prohibited.</b> Flag indicating whether the dynamic vertex buffer has been built. </p>
</td></tr>
<tr><td class="fieldname"><a id="ade842941f47fbbe74a09e389491a4089ac7fc49a2b3c56d5e773ef878dd4918b2"></a>Flag_ShapeAnimCalculationEnabled&#160;</td><td class="fielddoc"><p> <b>The use of internal features is prohibited.</b> Flag indicating whether to apply the shape animation calculation result to the vertex buffer. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af6d03e27a48f193a0aaafa2380c13919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d03e27a48f193a0aaafa2380c13919">&#9670;&nbsp;</a></span>ShapeObj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nn::g3d::ShapeObj::ShapeObj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p><code><a class="el" href="classnn_1_1g3d_1_1_shape_obj_1_1_builder.html" title="The class that builds the ShapeObj instance.">Builder</a></code> performs the actual building. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0ba82136231db018f912733940a36dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba82136231db018f912733940a36dc4">&#9670;&nbsp;</a></span>CalculateBlockBufferSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::g3d::ShapeObj::CalculateBlockBufferSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *&#160;</td>
          <td class="paramname"><em>pDevice</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the uniform block size. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the calculated buffer size. </dd></dl>

</div>
</div>
<a id="a7cabdabea5964ffbfb204dd0e4bd5bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cabdabea5964ffbfb204dd0e4bd5bf1">&#9670;&nbsp;</a></span>SetupBlockBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::ShapeObj::SetupBlockBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *&#160;</td>
          <td class="paramname"><em>pDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1gfx.html#ad620d8208dd309eb7c4dd5973a6aeee5">nn::gfx::MemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pMemoryPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>memoryPoolSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Passes a memory pool and builds a uniform block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDevice</td><td>Pointer to the device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pMemoryPool</td><td>Pointer to the memory pool. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset to the region to use for the memory pool. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memoryPoolSize</td><td>The size of the available memory pool beyond <code><em>offset</em></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if building succeeded, or <code>false</code> otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDevice</em></code> is initialized.</li>
<li><code><em>pMemoryPool</em></code> is initialized.</li>
<li>The position of the memory pool specified by <code><em>offset</em></code> is aligned to the value of <code><a class="el" href="classnn_1_1gfx_1_1_t_buffer.html#a99b1cd500e55e26460655d68eee13842" title="Gets the alignment required for the buffer.">nn::gfx::Buffer::GetBufferAlignment()</a></code>.</li>
<li><code><em>memoryPoolSize</em></code> is at least the size of <code><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a0ba82136231db018f912733940a36dc4" title="Calculates the uniform block size.">CalculateBlockBufferSize()</a></code>.</li>
<li>The uniform block is not built.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The uniform block is built.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
</p><ul>
<li>We recommend using <code>CpuCached</code> as the memory pool characteristic when accessing the CPU from the post-build dynamic vertex buffer, or when the <code><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#aa636a5bcd302aa52cf9bbd7458a7f3be" title="Enables the setting to calculate the shape animation result in the CPU and apply that result to the d...">SetShapeAnimCalculationEnabled()</a></code> function is called to enable application of shape animations.</li>
<li>Performance will be lower if you set <code>CpuUncached</code>. </li>
</ul>

</div>
</div>
<a id="a62907045e2b301d7f347752106eec7af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62907045e2b301d7f347752106eec7af">&#9670;&nbsp;</a></span>CleanupBlockBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::ShapeObj::CleanupBlockBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *&#160;</td>
          <td class="paramname"><em>pDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the uniform block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDevice</td><td>Pointer to the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDevice</em></code> is initialized.</li>
<li>The uniform block is built.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The uniform block is destroyed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="afa580dfcb0fac318789e05bf22ab949c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa580dfcb0fac318789e05bf22ab949c">&#9670;&nbsp;</a></span>CalculateBounding() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::ShapeObj::CalculateBounding </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnn_1_1g3d_1_1_skeleton_obj.html">SkeletonObj</a> *&#160;</td>
          <td class="paramname"><em>pSkeleton</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the bounding sphere for mesh 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSkeleton</td><td>Pointer to <code><a class="el" href="classnn_1_1g3d_1_1_skeleton_obj.html" title="Skeleton instance.">SkeletonObj</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><a class="el" href="structnn_1_1g3d_1_1_bounding.html" title="The AABB (Axis-Aligned-Bounding-Box) bounding data.">Bounding</a> calculations are enabled during object creation.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function does nothing if the preconditions are not met. </p>

</div>
</div>
<a id="a3e1a0c59dab38304e64db8d6831ce75d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1a0c59dab38304e64db8d6831ce75d">&#9670;&nbsp;</a></span>CalculateBounding() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::ShapeObj::CalculateBounding </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnn_1_1g3d_1_1_skeleton_obj.html">SkeletonObj</a> *&#160;</td>
          <td class="paramname"><em>pSkeleton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the bounding sphere for the specified mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSkeleton</td><td>Pointer to <code><a class="el" href="classnn_1_1g3d_1_1_skeleton_obj.html" title="Skeleton instance.">SkeletonObj</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">meshIndex</td><td>The index of the mesh. The LOD level.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><a class="el" href="structnn_1_1g3d_1_1_bounding.html" title="The AABB (Axis-Aligned-Bounding-Box) bounding data.">Bounding</a> calculations are enabled during object creation.</li>
<li>The index is within the range of the number of meshes.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function does nothing if the preconditions are not met. </p>

</div>
</div>
<a id="ad3875fc401453548f6e5fdf3928abdee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3875fc401453548f6e5fdf3928abdee">&#9670;&nbsp;</a></span>CalculateSubMeshBounding() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::ShapeObj::CalculateSubMeshBounding </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnn_1_1g3d_1_1_skeleton_obj.html">SkeletonObj</a> *&#160;</td>
          <td class="paramname"><em>pSkeleton</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the bounding box for the submeshes of mesh 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSkeleton</td><td>Pointer to <code><a class="el" href="classnn_1_1g3d_1_1_skeleton_obj.html" title="Skeleton instance.">SkeletonObj</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><a class="el" href="structnn_1_1g3d_1_1_bounding.html" title="The AABB (Axis-Aligned-Bounding-Box) bounding data.">Bounding</a> calculations are enabled during object creation.</li>
<li>The object is a rigid body.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function does nothing if the preconditions are not met. </p>

</div>
</div>
<a id="a5d4ed8a8cbc3c3e702b1f1b20d2a5536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d4ed8a8cbc3c3e702b1f1b20d2a5536">&#9670;&nbsp;</a></span>CalculateSubMeshBounding() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::ShapeObj::CalculateSubMeshBounding </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnn_1_1g3d_1_1_skeleton_obj.html">SkeletonObj</a> *&#160;</td>
          <td class="paramname"><em>pSkeleton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the bounding box for the submeshes of the specified mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSkeleton</td><td>Pointer to <code><a class="el" href="classnn_1_1g3d_1_1_skeleton_obj.html" title="Skeleton instance.">SkeletonObj</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">meshIndex</td><td>The index of the mesh. The LOD level.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><a class="el" href="structnn_1_1g3d_1_1_bounding.html" title="The AABB (Axis-Aligned-Bounding-Box) bounding data.">Bounding</a> calculations are enabled during object creation.</li>
<li>The object is a rigid body.</li>
<li>The index is within the range of the number of meshes.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function does nothing if the preconditions are not met. </p>

</div>
</div>
<a id="ac9b2fc3bb7e76ccac3700abfa9bd5ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b2fc3bb7e76ccac3700abfa9bd5ab8">&#9670;&nbsp;</a></span>CalculateShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::ShapeObj::CalculateShape </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>viewIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1util.html#afb360b0e9579454c6af5804cc476c101">nn::util::Matrix4x3fType</a> &amp;&#160;</td>
          <td class="paramname"><em>worldMtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufferIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates render resources for shapes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">viewIndex</td><td>Index of the view that applies the calculation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">worldMtx</td><td>World transformation matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferIndex</td><td>Index to the uniform block that applies the calculation.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
 Because buffers accessed by the graphics processing unit (GPU) are overwritten, this process must be called after GPU access for the previous rendering process completes. It is assumed that either double buffering has been set as a build option, or that the process is called while copying out the framebuffer. </p>

</div>
</div>
<a id="ad274ec723501d412ea5d513e69c64a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad274ec723501d412ea5d513e69c64a73">&#9670;&nbsp;</a></span>ClearDynamicVertexBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::ShapeObj::ClearDynamicVertexBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufferIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the value of the dynamic vertex buffer, restoring it to the original vertex buffer value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferIndex</td><td>The index of the buffer to clear.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
 Because buffers accessed by the graphics processing unit (GPU) are overwritten, this process must be called after GPU access for the previous rendering process completes. It is assumed that either double buffering has been set as a build option, or that the process is called while copying out the framebuffer. </p>

</div>
</div>
<a id="a8f7bc2a51ba63d4488ff2d6d7d5e0937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f7bc2a51ba63d4488ff2d6d7d5e0937">&#9670;&nbsp;</a></span>GetBlockBufferAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::g3d::ShapeObj::GetBlockBufferAlignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *&#160;</td>
          <td class="paramname"><em>pDevice</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the alignment required by the uniform block. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the alignment required by the uniform block. </dd></dl>

</div>
</div>
<a id="a877f7c0f4f853151966321c4b969c45b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877f7c0f4f853151966321c4b969c45b">&#9670;&nbsp;</a></span>GetResource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnn_1_1g3d_1_1_res_shape.html">ResShape</a>* nn::g3d::ShapeObj::GetResource </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a resource. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer to <code><a class="el" href="classnn_1_1g3d_1_1_res_shape.html" title="Shape resources.">ResShape</a></code>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_simple_8cpp-example.html#a84">G3dDemo/Simple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a160c8f620f415ad2c3fcfcc0da86ea4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a160c8f620f415ad2c3fcfcc0da86ea4f">&#9670;&nbsp;</a></span>GetBufferPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::g3d::ShapeObj::GetBufferPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the buffer passed when <code><a class="el" href="classnn_1_1g3d_1_1_shape_obj_1_1_builder.html" title="The class that builds the ShapeObj instance.">Builder</a></code> called the <code>Build()</code> function. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the buffer passed when <code><a class="el" href="classnn_1_1g3d_1_1_shape_obj_1_1_builder.html" title="The class that builds the ShapeObj instance.">Builder</a></code> called the <code>Build()</code> function </dd></dl>

</div>
</div>
<a id="ad1ca4b89b13c955925424be0dfeb79d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ca4b89b13c955925424be0dfeb79d5">&#9670;&nbsp;</a></span>GetMemoryPoolPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1gfx.html#ad620d8208dd309eb7c4dd5973a6aeee5">nn::gfx::MemoryPool</a>* nn::g3d::ShapeObj::GetMemoryPoolPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a pointer to the memory pool that was passed when <code><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a7cabdabea5964ffbfb204dd0e4bd5bf1" title="Passes a memory pool and builds a uniform block.">SetupBlockBuffer()</a></code> was called. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer to the memory pool. </dd></dl>

</div>
</div>
<a id="ad133182bc588fb9fc2285cadd3423de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad133182bc588fb9fc2285cadd3423de0">&#9670;&nbsp;</a></span>GetMemoryPoolOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t nn::g3d::ShapeObj::GetMemoryPoolOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the offset of the memory pool that was passed when <code><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a7cabdabea5964ffbfb204dd0e4bd5bf1" title="Passes a memory pool and builds a uniform block.">SetupBlockBuffer()</a></code> was called. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the memory pool offset. </dd></dl>

</div>
</div>
<a id="a96e08f29f39bbbfc84101739e7a23c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96e08f29f39bbbfc84101739e7a23c02">&#9670;&nbsp;</a></span>IsBlockBufferValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::ShapeObj::IsBlockBufferValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the uniform block has been built. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if built, or <code>false</code> otherwise. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_simple_8cpp-example.html#a137">G3dDemo/Simple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ada67c3109b9cda5212bcdeca8d2348bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada67c3109b9cda5212bcdeca8d2348bf">&#9670;&nbsp;</a></span>IsDynamicVertexBufferValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::ShapeObj::IsDynamicVertexBufferValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the dynamic vertex buffer has been built. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if built, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="af40ab5352dfd30bc5e42f9aff17a70dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40ab5352dfd30bc5e42f9aff17a70dc">&#9670;&nbsp;</a></span>GetMaterialIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::GetMaterialIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the index to the referenced <code><a class="el" href="classnn_1_1g3d_1_1_res_material.html" title="The material resource.">ResMaterial</a></code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the index to the referenced <code><a class="el" href="classnn_1_1g3d_1_1_res_material.html" title="The material resource.">ResMaterial</a></code>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_edit_8cpp-example.html#a73">G3dDemo/Edit.cpp</a>, <a class="el" href="_g3d_demo_2_simple_8cpp-example.html#a150">G3dDemo/Simple.cpp</a>, and <a class="el" href="_g3d_demo_2_town_8cpp-example.html#a293">G3dDemo/Town.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a4e2779416450c45a319b2c7bc2abfa5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e2779416450c45a319b2c7bc2abfa5a">&#9670;&nbsp;</a></span>GetBoneIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::GetBoneIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the index to the referenced <code><a class="el" href="classnn_1_1g3d_1_1_res_bone.html" title="Bone resource.">ResBone</a></code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the index to the referenced <code><a class="el" href="classnn_1_1g3d_1_1_res_bone.html" title="Bone resource.">ResBone</a></code>. </dd></dl>

</div>
</div>
<a id="a9ff949952a39b416c12e09018666f555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff949952a39b416c12e09018666f555">&#9670;&nbsp;</a></span>GetVertexIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::GetVertexIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the index to the referenced <code><a class="el" href="classnn_1_1g3d_1_1_res_vertex.html" title="Vertex information resources.">ResVertex</a></code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the index to the referenced <code><a class="el" href="classnn_1_1g3d_1_1_res_vertex.html" title="Vertex information resources.">ResVertex</a></code>. </dd></dl>

</div>
</div>
<a id="ac75f67b6366474039749b9e4106780ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75f67b6366474039749b9e4106780ba">&#9670;&nbsp;</a></span>GetVertexSkinCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::GetVertexSkinCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of bones needed for smooth skinning. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bones needed for smooth skinning. </dd></dl>

</div>
</div>
<a id="a94497b52f362ce706ce19d95e83621e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94497b52f362ce706ce19d95e83621e6">&#9670;&nbsp;</a></span>IsRigidBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::ShapeObj::IsRigidBody </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a shape is a rigid body shape. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the shape is a rigid body, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ab7df9878fca8f101db113b28eed9b272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7df9878fca8f101db113b28eed9b272">&#9670;&nbsp;</a></span>IsRigidSkinning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::ShapeObj::IsRigidSkinning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a shape uses rigid skinning. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the shape uses rigid skinning, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a0ca46c9cc157f944073e1a20cb720f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca46c9cc157f944073e1a20cb720f99">&#9670;&nbsp;</a></span>IsSmoothSkinning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::ShapeObj::IsSmoothSkinning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a shape uses smooth skinning. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the shape uses smooth skinning, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a4250dd1621b8717ab126aa3d43a18fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4250dd1621b8717ab126aa3d43a18fa8">&#9670;&nbsp;</a></span>GetResMesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnn_1_1g3d_1_1_res_mesh.html">ResMesh</a>* nn::g3d::ShapeObj::GetResMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a mesh. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to <code><a class="el" href="classnn_1_1g3d_1_1_res_mesh.html" title="The mesh resources. Retains the index buffer.">ResMesh</a></code>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_shape_animation_8cpp-example.html#a140">G3dDemo/ShapeAnimation.cpp</a>, <a class="el" href="_g3d_demo_2_simple_8cpp-example.html#a158">G3dDemo/Simple.cpp</a>, and <a class="el" href="_g3d_demo_2_town_8cpp-example.html#a119">G3dDemo/Town.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a193348f627beda4bfa8a47cc2980f12d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193348f627beda4bfa8a47cc2980f12d">&#9670;&nbsp;</a></span>GetResMesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnn_1_1g3d_1_1_res_mesh.html">ResMesh</a>* nn::g3d::ShapeObj::GetResMesh </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshIndex</td><td>The index of the mesh. The LOD level.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to <code><a class="el" href="classnn_1_1g3d_1_1_res_mesh.html" title="The mesh resources. Retains the index buffer.">ResMesh</a></code>. </dd></dl>

</div>
</div>
<a id="af3880bc46da44ec036bedb940b5b3d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3880bc46da44ec036bedb940b5b3d5d">&#9670;&nbsp;</a></span>GetMeshCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::GetMeshCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of meshes. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of meshes. </dd></dl>

</div>
</div>
<a id="a9932dc0d155a493eaa6d4abd18970fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9932dc0d155a493eaa6d4abd18970fa0">&#9670;&nbsp;</a></span>GetViewCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::GetViewCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of views. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of views. </dd></dl>

</div>
</div>
<a id="a07131b7bd1633a73acff2b021ebd45a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07131b7bd1633a73acff2b021ebd45a7">&#9670;&nbsp;</a></span>GetSubMeshCount() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::GetSubMeshCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of submeshes. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of submeshes. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_town_8cpp-example.html#a252">G3dDemo/Town.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a6072233b7f32e07f3fdbeda866258c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6072233b7f32e07f3fdbeda866258c40">&#9670;&nbsp;</a></span>GetSubMeshCount() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::GetSubMeshCount </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of submeshes for the specified mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshIndex</td><td>The index of the mesh. The LOD level.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of submeshes. </dd></dl>

</div>
</div>
<a id="a5db7c7b7e7b3be79c4a06722bf2c7bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db7c7b7e7b3be79c4a06722bf2c7bcd">&#9670;&nbsp;</a></span>IsViewDependent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::ShapeObj::IsViewDependent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the shape is view-dependent. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the shape is view-dependent, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a962fd9c318f3763a92bf3549a2396c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a962fd9c318f3763a92bf3549a2396c4e">&#9670;&nbsp;</a></span>GetShapeBlockCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::GetShapeBlockCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of uniform blocks for each shape. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of uniform blocks for each shape. </dd></dl>

</div>
</div>
<a id="a90eb0caf66948a4bab1ab07bc0eae384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90eb0caf66948a4bab1ab07bc0eae384">&#9670;&nbsp;</a></span>GetShapeBlock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a>* nn::g3d::ShapeObj::GetShapeBlock </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>viewIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufferIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the buffer for the uniform block per shape. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">viewIndex</td><td>View index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferIndex</td><td>Index of the uniform block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer to <code>nn::gfx::BufferView</code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>viewIndex</em></code> is within the number of views held by the material.</li>
<li><code><em>bufferIndex</em></code> is within the range of the number of buffers held by the material.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Each view has the number of buffers for uniform blocks that was specified as the buffer count when <code>Build()</code> was executed. Returns <code>NULL</code> if the uniform block has not been built. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_simple_8cpp-example.html#a136">G3dDemo/Simple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a0f887028ec44b37b074a8ead5256c298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f887028ec44b37b074a8ead5256c298">&#9670;&nbsp;</a></span>GetShapeBlock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a>* nn::g3d::ShapeObj::GetShapeBlock </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>viewIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufferIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the buffer for the uniform block per shape. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">viewIndex</td><td>View index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferIndex</td><td>Index of the uniform block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer to <code>nn::gfx::BufferView</code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>viewIndex</em></code> is within the number of views held by the material.</li>
<li><code><em>bufferIndex</em></code> is within the range of the number of buffers held by the material.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Each view has the number of buffers for uniform blocks that was specified as the buffer count when <code>Build()</code> was executed. Returns <code>NULL</code> if the uniform block has not been built. </p>

</div>
</div>
<a id="a661802cb989edfb1f765e53a9ada92f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a661802cb989edfb1f765e53a9ada92f1">&#9670;&nbsp;</a></span>GetBufferingCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::GetBufferingCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of uniform blocks for buffering. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of uniform blocks for buffering. </dd></dl>

</div>
</div>
<a id="a59a96b326ce84b4dc7867b09a3c2fad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a96b326ce84b4dc7867b09a3c2fad1">&#9670;&nbsp;</a></span>IsBlockSwapEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::ShapeObj::IsBlockSwapEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether an endian swap will be conducted for the uniform block. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if an endian swap will be conducted for the uniform block, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a035541674c664057eb66b958c3d763cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a035541674c664057eb66b958c3d763cf">&#9670;&nbsp;</a></span>SetUserPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::ShapeObj::SetUserPtr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pUserPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a user pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUserPtr</td><td>A pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_simple_8cpp-example.html#a236">G3dDemo/Simple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a53aeee059d9dc6b38482bb4f4cc2eb9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53aeee059d9dc6b38482bb4f4cc2eb9a">&#9670;&nbsp;</a></span>GetUserPtr() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::g3d::ShapeObj::GetUserPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the user pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer set by the <code><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a035541674c664057eb66b958c3d763cf" title="Sets a user pointer.">SetUserPtr()</a></code> function. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_simple_8cpp-example.html#a153">G3dDemo/Simple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a205405441aa99765f735d51f82e0d205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a205405441aa99765f735d51f82e0d205">&#9670;&nbsp;</a></span>GetUserPtr() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* nn::g3d::ShapeObj::GetUserPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the user pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer set by the <code><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a035541674c664057eb66b958c3d763cf" title="Sets a user pointer.">SetUserPtr()</a></code> function. </dd></dl>

</div>
</div>
<a id="a81206653da41f37c6b924f4f3fcd2bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81206653da41f37c6b924f4f3fcd2bb5">&#9670;&nbsp;</a></span>GetUserPtr() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* nn::g3d::ShapeObj::GetUserPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the user pointer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type when getting a pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer set by the <code><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a035541674c664057eb66b958c3d763cf" title="Sets a user pointer.">SetUserPtr()</a></code> function. </dd></dl>

</div>
</div>
<a id="af1680667038c121f969470d162d933af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1680667038c121f969470d162d933af">&#9670;&nbsp;</a></span>GetUserPtr() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* nn::g3d::ShapeObj::GetUserPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the user pointer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type when getting a pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer set by the <code><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a035541674c664057eb66b958c3d763cf" title="Sets a user pointer.">SetUserPtr()</a></code> function. </dd></dl>

</div>
</div>
<a id="a13cbc2ed0a34709b6ec841559e92abb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13cbc2ed0a34709b6ec841559e92abb0">&#9670;&nbsp;</a></span>GetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* nn::g3d::ShapeObj::GetName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the shape name. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the <code><a class="el" href="classnn_1_1g3d_1_1_res_shape.html" title="Shape resources.">ResShape</a></code> shape name. </dd></dl>

</div>
</div>
<a id="a366192ea48975363a42b6793469b484c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366192ea48975363a42b6793469b484c">&#9670;&nbsp;</a></span>GetUserArea() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::g3d::ShapeObj::GetUserArea </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a pointer to the user area. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the user area. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_town_8cpp-example.html#a120">G3dDemo/Town.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af057a8b378cb6d7ee94a8b95c545fcb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af057a8b378cb6d7ee94a8b95c545fcb4">&#9670;&nbsp;</a></span>GetUserArea() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* nn::g3d::ShapeObj::GetUserArea </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a pointer to the user area. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the user area. </dd></dl>

</div>
</div>
<a id="aadace6bf4ef3fd23b28664052981a336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadace6bf4ef3fd23b28664052981a336">&#9670;&nbsp;</a></span>GetUserArea() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* nn::g3d::ShapeObj::GetUserArea </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a pointer to the user area. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type when getting a pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the user area. </dd></dl>

</div>
</div>
<a id="acc5d31af5f0d71847aaca41377ba1212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5d31af5f0d71847aaca41377ba1212">&#9670;&nbsp;</a></span>GetUserArea() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* nn::g3d::ShapeObj::GetUserArea </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a pointer to the user area. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type when getting a pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the user area. </dd></dl>

</div>
</div>
<a id="ab67c5f9f13e2158953143b56433cae26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67c5f9f13e2158953143b56433cae26">&#9670;&nbsp;</a></span>GetUserAreaSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::g3d::ShapeObj::GetUserAreaSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of the user area. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the size of the user area. </dd></dl>

</div>
</div>
<a id="acd76605a682a3ca3676ab91d6fe62c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd76605a682a3ca3676ab91d6fe62c24">&#9670;&nbsp;</a></span>GetResVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnn_1_1g3d_1_1_res_vertex.html">ResVertex</a>* nn::g3d::ShapeObj::GetResVertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the referenced <code><a class="el" href="classnn_1_1g3d_1_1_res_vertex.html" title="Vertex information resources.">ResVertex</a></code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to <code><a class="el" href="classnn_1_1g3d_1_1_res_vertex.html" title="Vertex information resources.">ResVertex</a></code>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_shape_animation_8cpp-example.html#a114">G3dDemo/ShapeAnimation.cpp</a>, <a class="el" href="_g3d_demo_2_simple_8cpp-example.html#a86">G3dDemo/Simple.cpp</a>, and <a class="el" href="_mii_g3d_headwear_2_mii_g3d_headwear_8cpp-example.html#a216">MiiG3dHeadwear/MiiG3dHeadwear.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a987abf75f6288206255df95bbd891cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a987abf75f6288206255df95bbd891cde">&#9670;&nbsp;</a></span>GetVertexAttrCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::GetVertexAttrCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of vertex attributes of the referenced <code><a class="el" href="classnn_1_1g3d_1_1_res_vertex.html" title="Vertex information resources.">ResVertex</a></code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of vertex attributes of the referenced <code><a class="el" href="classnn_1_1g3d_1_1_res_vertex.html" title="Vertex information resources.">ResVertex</a></code>. </dd></dl>

</div>
</div>
<a id="aae44347c36040e406258524943d95d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae44347c36040e406258524943d95d40">&#9670;&nbsp;</a></span>GetResVertexAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnn_1_1g3d_1_1_res_vertex_attr.html">ResVertexAttr</a>* nn::g3d::ShapeObj::GetResVertexAttr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attrIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the vertex attributes by looking up the index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">attrIndex</td><td>The vertex attribute index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer to <code><a class="el" href="classnn_1_1g3d_1_1_res_vertex_attr.html" title="The vertex attribute resources.">ResVertexAttr</a></code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The index is within the number of vertex attributes held by the shape. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa7115a44dc383289e8887b4c20c00313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7115a44dc383289e8887b4c20c00313">&#9670;&nbsp;</a></span>FindResVertexAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnn_1_1g3d_1_1_res_vertex_attr.html">ResVertexAttr</a>* nn::g3d::ShapeObj::FindResVertexAttr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the vertex attributes by looking up the name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Pointer to the vertex attribute name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer to <code><a class="el" href="classnn_1_1g3d_1_1_res_vertex_attr.html" title="The vertex attribute resources.">ResVertexAttr</a></code>.</dd></dl>
<p> <b>Details</b> <br  />
 Returns <code>NULL</code> when no vertex attribute with the specified name exists.</p>
<p>Looking up indices is faster than looking up names. We recommend registering the index after you get it, and normally using index lookup. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_shape_animation_8cpp-example.html#a100">G3dDemo/ShapeAnimation.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a065d7bd66a8484c0a818e6fa6dac7b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a065d7bd66a8484c0a818e6fa6dac7b8f">&#9670;&nbsp;</a></span>GetVertexAttrName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* nn::g3d::ShapeObj::GetVertexAttrName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attribIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the vertex attribute name from the index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">attribIndex</td><td>The index of the vertex attributes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the name of the vertex attribute.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The index is within the number of vertex attributes held by the shape. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2d864c5b51adbbe0f8ac2568c1052240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d864c5b51adbbe0f8ac2568c1052240">&#9670;&nbsp;</a></span>FindVertexAttrIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::FindVertexAttrIndex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the index from the vertex attribute name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Pointer to the vertex attribute name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the vertex attribute index.</dd></dl>
<p> <b>Details</b> <br  />
 Returns <code><a class="el" href="classnn_1_1util_1_1_res_dic.html#a825d9c73f03e6d02e9f8d0050b0e11a6" title="Specifies an invalid index.">nn::util::ResDic::Npos</a></code> when no vertex attribute with the specified name exists. </p>

</div>
</div>
<a id="a38bfb2f1f02e9f47bf4a8796194c08e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38bfb2f1f02e9f47bf4a8796194c08e8">&#9670;&nbsp;</a></span>GetVertexBufferCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::GetVertexBufferCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of vertex buffers for the referenced <code><a class="el" href="classnn_1_1g3d_1_1_res_vertex.html" title="Vertex information resources.">ResVertex</a></code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of vertex buffers for the referenced <code><a class="el" href="classnn_1_1g3d_1_1_res_vertex.html" title="Vertex information resources.">ResVertex</a></code>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_shape_animation_8cpp-example.html#a84">G3dDemo/ShapeAnimation.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1c79150775d457e82c04d5ba635ef7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c79150775d457e82c04d5ba635ef7c5">&#9670;&nbsp;</a></span>GetVertexBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a>* nn::g3d::ShapeObj::GetVertexBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufferIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a vertex buffer from an index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferIndex</td><td>The index of the vertex buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to <code><a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85" title="The type definition representing a buffer.">nn::gfx::Buffer</a></code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The index is within the range of the number of vertex buffers held by the shape.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
</p><ul>
<li>To get the dynamic vertex buffer, use the <code><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a153dbe394d39548d8336b3d3ba87652e" title="Gets a dynamic vertex buffer from an index.">GetDynamicVertexBuffer()</a></code> function. </li>
</ul>

</div>
</div>
<a id="ac69e4c2322bd35a5bc750dd5df3574f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac69e4c2322bd35a5bc750dd5df3574f9">&#9670;&nbsp;</a></span>GetVertexBufferInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnn_1_1gfx_1_1_buffer_info.html">nn::gfx::BufferInfo</a>* nn::g3d::ShapeObj::GetVertexBufferInfo </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufferIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the vertex buffer information from an index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferIndex</td><td>The index of the vertex buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to <code><a class="el" href="classnn_1_1gfx_1_1_buffer_info.html" title="The class representing information for initializing a buffer.">nn::gfx::BufferInfo</a></code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The index is within the range of the number of vertex buffers held by the shape. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_shape_animation_8cpp-example.html#a138">G3dDemo/ShapeAnimation.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a311a863e4d0810ddffa988344af47974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a311a863e4d0810ddffa988344af47974">&#9670;&nbsp;</a></span>GetBounding() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1g3d_1_1_sphere.html">Sphere</a>* nn::g3d::ShapeObj::GetBounding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the bounding sphere on the world coordinate system for the shape. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the bounding sphere for the shape in the world coordinate system.</dd></dl>
<p> <b>Details</b> <br  />
 Returns <code>NULL</code> when bounding is unavailable during building. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_town_8cpp-example.html#a196">G3dDemo/Town.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1b2ab901b61469513d334f5a6d29d535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2ab901b61469513d334f5a6d29d535">&#9670;&nbsp;</a></span>GetBounding() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1g3d_1_1_sphere.html">Sphere</a>* nn::g3d::ShapeObj::GetBounding </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the bounding sphere in world coordinates for the specified mesh. </p>
<p>param[in] meshIndex The mesh index.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer to the bounding sphere in world coordinates for the specified mesh.</dd></dl>
<p> <b>Details</b> <br  />
 Returns <code>NULL</code> when bounding is unavailable during building. </p>

</div>
</div>
<a id="ad35c8f2e29190cfc6012aad9c671edf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35c8f2e29190cfc6012aad9c671edf3">&#9670;&nbsp;</a></span>GetBounding() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structnn_1_1g3d_1_1_sphere.html">Sphere</a>* nn::g3d::ShapeObj::GetBounding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the bounding sphere on the world coordinate system for the shape. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the bounding sphere for the shape in the world coordinate system.</dd></dl>
<p> <b>Details</b> <br  />
 Returns <code>NULL</code> when bounding is unavailable during building. </p>

</div>
</div>
<a id="aa7d123d46ed75284aec03f721b9d7b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7d123d46ed75284aec03f721b9d7b45">&#9670;&nbsp;</a></span>GetBounding() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structnn_1_1g3d_1_1_sphere.html">Sphere</a>* nn::g3d::ShapeObj::GetBounding </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the bounding sphere in world coordinates for the specified mesh. </p>
<p>param[in] meshIndex The mesh index.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer to the bounding sphere in world coordinates for the specified mesh.</dd></dl>
<p> <b>Details</b> <br  />
 Returns <code>NULL</code> when bounding is unavailable during building. </p>

</div>
</div>
<a id="a584937fcde20904ba97d7df31366f0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a584937fcde20904ba97d7df31366f0d0">&#9670;&nbsp;</a></span>GetSubMeshBoundingArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structnn_1_1g3d_1_1_aabb.html">Aabb</a>* nn::g3d::ShapeObj::GetSubMeshBoundingArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the submesh AABB array in world coordinates. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the submesh AABB array in world coordinates.</dd></dl>
<p> <b>Details</b> <br  />
 Returns <code>NULL</code> when bounding is unavailable during building. </p>

</div>
</div>
<a id="a309a21916d5b1921a5106bce6c872b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309a21916d5b1921a5106bce6c872b9f">&#9670;&nbsp;</a></span>GetSubMeshBoundingArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structnn_1_1g3d_1_1_aabb.html">Aabb</a>* nn::g3d::ShapeObj::GetSubMeshBoundingArray </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the AABB array in world coordinates for the submeshes of the specified mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshIndex</td><td>The index of the mesh. The LOD level.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the submesh AABB array in world coordinates.</dd></dl>
<p> <b>Details</b> <br  />
 Returns <code>NULL</code> when bounding is unavailable during building. </p>

</div>
</div>
<a id="a25c0526e70aef8f5ac9512196c1f5d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c0526e70aef8f5ac9512196c1f5d14">&#9670;&nbsp;</a></span>TestSubMeshIntersection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::ShapeObj::TestSubMeshIntersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1g3d_1_1_culling_context.html">CullingContext</a> *&#160;</td>
          <td class="paramname"><em>pCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1g3d_1_1_view_volume.html">ViewVolume</a> &amp;&#160;</td>
          <td class="paramname"><em>volume</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets serial submeshes that intersect with the view volume. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>Pointer to the context that holds the series of submeshes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">volume</td><td>Reference to the view volume.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if a submesh intersects or is contained, or <code>false</code> otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><a class="el" href="structnn_1_1g3d_1_1_bounding.html" title="The AABB (Axis-Aligned-Bounding-Box) bounding data.">Bounding</a> calculations are enabled during object creation.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Searches the series of submeshes stored by the constructor and then writes intersecting or inclusive contiguous submeshes to the constructor. <code><a class="el" href="structnn_1_1g3d_1_1_culling_context.html" title="Culling contexts.">CullingContext</a>::<em>submeshIndex</em></code> stores the index of the first submesh inside the view volume, and <code><a class="el" href="structnn_1_1g3d_1_1_culling_context.html" title="Culling contexts.">CullingContext</a>::<em>submeshCount</em></code> stores the number of contiguous submeshes starting from the first submesh index inside the view volume.</p>
<p>The function ends and returns the result after the search has reached the last submesh, or after the search for submeshes inside the view volume finds a submesh that is not inside the view volume. By retaining the data of <code><em>pCtx</em></code> and continuing to call this function, you can learn about all the submeshes inside the view volume.</p>
<p>You can cull submeshes by calling the <code><a class="el" href="classnn_1_1g3d_1_1_res_mesh.html#a81aeebb2ad882470c6be182f018c209b" title="Renders a submesh in the specified range.">nn::g3d::ResMesh::DrawSubMesh()</a></code> function based on the obtained <code><a class="el" href="structnn_1_1g3d_1_1_culling_context.html" title="Culling contexts.">CullingContext</a></code> and repeating this procedure until the <code><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a25c0526e70aef8f5ac9512196c1f5d14" title="Gets serial submeshes that intersect with the view volume.">TestSubMeshIntersection()</a></code> function returns <code>false</code>. </p>

</div>
</div>
<a id="afc539bbe698f6a400f2e9f4fb1daeaea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc539bbe698f6a400f2e9f4fb1daeaea">&#9670;&nbsp;</a></span>TestSubMeshIntersection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::ShapeObj::TestSubMeshIntersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1g3d_1_1_culling_context.html">CullingContext</a> *&#160;</td>
          <td class="paramname"><em>pCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1g3d_1_1_view_volume.html">ViewVolume</a> &amp;&#160;</td>
          <td class="paramname"><em>volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the contiguous submeshes that intersect with the view volume for the specified mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>Pointer to the context that holds the series of submeshes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">volume</td><td>Reference to the view volume. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">meshIndex</td><td>The index of the mesh. The LOD level.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if a submesh intersects or is contained, or <code>false</code> otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><a class="el" href="structnn_1_1g3d_1_1_bounding.html" title="The AABB (Axis-Aligned-Bounding-Box) bounding data.">Bounding</a> calculations are enabled during object creation.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Searches the series of submeshes stored by the constructor and then writes intersecting or inclusive contiguous submeshes to the constructor. <code><a class="el" href="structnn_1_1g3d_1_1_culling_context.html" title="Culling contexts.">CullingContext</a>::<em>submeshIndex</em></code> stores the index of the first submesh inside the view volume, and <code><a class="el" href="structnn_1_1g3d_1_1_culling_context.html" title="Culling contexts.">CullingContext</a>::<em>submeshCount</em></code> stores the number of contiguous submeshes starting from the first submesh index inside the view volume.</p>
<p>The function ends and returns the result after the search has reached the last submesh, or after the search for submeshes inside the view volume finds a submesh that is not inside the view volume. By retaining the data of <code><em>pCtx</em></code> and continuing to call this function, you can learn about all the submeshes inside the view volume.</p>
<p>You can cull submeshes by calling the <code><a class="el" href="classnn_1_1g3d_1_1_res_mesh.html#a81aeebb2ad882470c6be182f018c209b" title="Renders a submesh in the specified range.">nn::g3d::ResMesh::DrawSubMesh()</a></code> function based on the obtained <code><a class="el" href="structnn_1_1g3d_1_1_culling_context.html" title="Culling contexts.">CullingContext</a></code> and repeating this procedure until the <code><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a25c0526e70aef8f5ac9512196c1f5d14" title="Gets serial submeshes that intersect with the view volume.">TestSubMeshIntersection()</a></code> function returns <code>false</code>.</p>
<p>If a value larger than the mesh count maintained by <code><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html" title="Shape instances.">ShapeObj</a></code> is set for <code><em>meshIndex</em></code>, nothing is written to the context and <code>false</code> is quickly returned. </p>

</div>
</div>
<a id="ab64775081aa11a283658bfef401c7694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64775081aa11a283658bfef401c7694">&#9670;&nbsp;</a></span>TestSubMeshLodIntersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::ShapeObj::TestSubMeshLodIntersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1g3d_1_1_culling_context.html">CullingContext</a> *&#160;</td>
          <td class="paramname"><em>pCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1g3d_1_1_view_volume.html">ViewVolume</a> &amp;&#160;</td>
          <td class="paramname"><em>volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1g3d_1_1_i_calculate_lod_level_functor.html">ICalculateLodLevelFunctor</a> &amp;&#160;</td>
          <td class="paramname"><em>calcLodFunctor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets serial submeshes with equal LOD levels that intersect with the view volume. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pCtx</td><td>Pointer to the context that holds the series of submeshes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">volume</td><td>Reference to the view volume. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">calcLodFunctor</td><td>Reference to the function object to use for determining the LOD.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if a submesh intersects or is contained, or <code>false</code> otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><a class="el" href="structnn_1_1g3d_1_1_bounding.html" title="The AABB (Axis-Aligned-Bounding-Box) bounding data.">Bounding</a> calculations are enabled during object creation.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Searches the series of submeshes stored by the constructor and then writes those intersecting or inclusive contiguous submeshes that are at the same LOD level to the constructor. <code><a class="el" href="structnn_1_1g3d_1_1_culling_context.html" title="Culling contexts.">CullingContext</a>::<em>submeshIndex</em></code> stores the index of the first submesh inside the view volume, and <code><a class="el" href="structnn_1_1g3d_1_1_culling_context.html" title="Culling contexts.">CullingContext</a>::<em>submeshCount</em></code> stores the number of contiguous submeshes starting from the first submesh index inside the view volume.</p>
<p>The function ends and returns the result after the search has reached the last submesh, or after the search for submeshes inside the view volume finds a submesh that is not inside the view volume. By retaining the data of <code><em>pCtx</em></code> and continuing to call this function, you can learn about all the submeshes inside the view volume.</p>
<p>You can cull submeshes by calling the <code><a class="el" href="classnn_1_1g3d_1_1_res_mesh.html#a81aeebb2ad882470c6be182f018c209b" title="Renders a submesh in the specified range.">nn::g3d::ResMesh::DrawSubMesh()</a></code> function based on the obtained <code><a class="el" href="structnn_1_1g3d_1_1_culling_context.html" title="Culling contexts.">CullingContext</a></code> and repeating this procedure until the <code><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a25c0526e70aef8f5ac9512196c1f5d14" title="Gets serial submeshes that intersect with the view volume.">TestSubMeshIntersection()</a></code> function returns <code>false</code>.</p>
<p>This function performs calculations using the bounding information of LOD level 0. You might not get the expected result if the bounding of each LOD model differs significantly from that of LOD level 0. </p>

</div>
</div>
<a id="a2c7a151dcaf87f835b29b9e09404c21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c7a151dcaf87f835b29b9e09404c21c">&#9670;&nbsp;</a></span>MakeSubMeshRange() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::MakeSubMeshRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1g3d_1_1_sub_mesh_range.html">SubMeshRange</a> *&#160;</td>
          <td class="paramname"><em>pRangeArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1g3d_1_1_view_volume.html">ViewVolume</a> &amp;&#160;</td>
          <td class="paramname"><em>volume</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a range array for connected submeshes that intersect with the view volume. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pRangeArray</td><td>Pointer to a <code><a class="el" href="structnn_1_1g3d_1_1_sub_mesh_range.html" title="The submesh range.">SubMeshRange</a></code> array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">volume</td><td>Reference to the view volume.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of submeshes that intersect the view volume.</dd></dl>
<p> <b>Details</b> <br  />
 <code><em>pRangeArray</em></code> ends with a <code><a class="el" href="structnn_1_1g3d_1_1_sub_mesh_range.html" title="The submesh range.">SubMeshRange</a></code> for which <code><em>index</em></code>, <code><em>count</em></code>, and <code><em>lodLevel</em></code> are all <code>0</code>. This function returns the number of submeshes not including the terminating element. If <code><em>N</em></code> is the number of submeshes for a shape, the maximum number of <code><a class="el" href="structnn_1_1g3d_1_1_sub_mesh_range.html" title="The submesh range.">SubMeshRange</a></code> objects is <code>(<em>N</em>+1)/2</code>. (Does not include the terminating element.) </p>

</div>
</div>
<a id="a9151525ed04761e24e47ac9370c8db96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9151525ed04761e24e47ac9370c8db96">&#9670;&nbsp;</a></span>MakeSubMeshRange() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::MakeSubMeshRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1g3d_1_1_sub_mesh_range.html">SubMeshRange</a> *&#160;</td>
          <td class="paramname"><em>pRangeArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1g3d_1_1_view_volume.html">ViewVolume</a> &amp;&#160;</td>
          <td class="paramname"><em>volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the contiguous submesh range array that intersects with the view volume, with a specified mesh index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pRangeArray</td><td>Pointer to a <code><a class="el" href="structnn_1_1g3d_1_1_sub_mesh_range.html" title="The submesh range.">SubMeshRange</a></code> array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">volume</td><td>Reference to the view volume. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">meshIndex</td><td>The index of the mesh. The LOD level.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of submeshes that intersect the view volume.</dd></dl>
<p> <b>Details</b> <br  />
 <code><em>pRangeArray</em></code> ends with a <code><a class="el" href="structnn_1_1g3d_1_1_sub_mesh_range.html" title="The submesh range.">SubMeshRange</a></code> for which <code><em>index</em></code>, <code><em>count</em></code>, and <code><em>lodLevel</em></code> are all <code>0</code>. This function returns the number of submeshes not including the terminating element. If <code><em>N</em></code> is the number of submeshes for a shape, the maximum number of <code><a class="el" href="structnn_1_1g3d_1_1_sub_mesh_range.html" title="The submesh range.">SubMeshRange</a></code> objects is <code>(<em>N</em>+1)/2</code>. (Does not include the terminating element.) </p>

</div>
</div>
<a id="adc83b0a0933cef444306411994a2720b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc83b0a0933cef444306411994a2720b">&#9670;&nbsp;</a></span>MakeSubMeshLodRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::MakeSubMeshLodRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1g3d_1_1_sub_mesh_range.html">SubMeshRange</a> *&#160;</td>
          <td class="paramname"><em>pRangeArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1g3d_1_1_view_volume.html">ViewVolume</a> &amp;&#160;</td>
          <td class="paramname"><em>volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1g3d_1_1_i_calculate_lod_level_functor.html">ICalculateLodLevelFunctor</a> &amp;&#160;</td>
          <td class="paramname"><em>calcLodFunctor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a range array of serial submeshes with equal LOD levels that intersect with the view volume. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pRangeArray</td><td>Pointer to a <code><a class="el" href="structnn_1_1g3d_1_1_sub_mesh_range.html" title="The submesh range.">SubMeshRange</a></code> array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">volume</td><td>Reference to the view volume. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">calcLodFunctor</td><td>Reference to the function object to use for determining the LOD.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of submeshes that intersect the view volume.</dd></dl>
<p> <b>Details</b> <br  />
 <code><em>pRangeArray</em></code> ends with a <code><a class="el" href="structnn_1_1g3d_1_1_sub_mesh_range.html" title="The submesh range.">SubMeshRange</a></code> for which <code><em>index</em></code>, <code><em>count</em></code>, and <code><em>lodLevel</em></code> are all <code>0</code>. This function returns the number of submeshes not including the terminating element. If <code><em>N</em></code> is the number of submeshes for a shape, the maximum number of <code><a class="el" href="structnn_1_1g3d_1_1_sub_mesh_range.html" title="The submesh range.">SubMeshRange</a></code> objects is <code><em>N</em></code>. (Does not include the terminating element.) </p>

</div>
</div>
<a id="a7b0e8fd440a0a3a99cf4fc71793f9484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b0e8fd440a0a3a99cf4fc71793f9484">&#9670;&nbsp;</a></span>GetKeyShapeCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::GetKeyShapeCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of key shapes. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of key shapes. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_shape_animation_8cpp-example.html#a63">G3dDemo/ShapeAnimation.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae682c5ed1aee0a94d64c85aae80daf0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae682c5ed1aee0a94d64c85aae80daf0f">&#9670;&nbsp;</a></span>GetResKeyShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnn_1_1g3d_1_1_res_key_shape.html">ResKeyShape</a>* nn::g3d::ShapeObj::GetResKeyShape </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keyShapeIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the key shape by looking up the index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keyShapeIndex</td><td>The index of the key shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to <code><a class="el" href="classnn_1_1g3d_1_1_res_key_shape.html" title="Key shape resources.">ResKeyShape</a></code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The index is within the number of key shapes held by the shape. </dd></dl>

</div>
</div>
<a id="ac7d6937bdfdb9d9374bcb8b48cccd07f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d6937bdfdb9d9374bcb8b48cccd07f">&#9670;&nbsp;</a></span>FindResKeyShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnn_1_1g3d_1_1_res_key_shape.html">ResKeyShape</a>* nn::g3d::ShapeObj::FindResKeyShape </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the key shape by looking up the name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Pointer to the key shape name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to <code><a class="el" href="classnn_1_1g3d_1_1_res_key_shape.html" title="Key shape resources.">ResKeyShape</a></code>.</dd></dl>
<p> <b>Details</b> <br  />
 Returns <code>NULL</code> when no key shape with the specified name exists.</p>
<p>Looking up indices is faster than looking up names. We recommend registering the index after you get it, and normally using index lookup. </p>

</div>
</div>
<a id="a89891c755056ab332f0b1cdcf6bb3190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89891c755056ab332f0b1cdcf6bb3190">&#9670;&nbsp;</a></span>GetKeyShapeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* nn::g3d::ShapeObj::GetKeyShapeName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keyShapeIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the key shape name from the index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keyShapeIndex</td><td>The index of the key shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the key shape name.</dd></dl>
<p> <b>Details</b> <br  />
 The index is within the number of key shapes held by the shape. </p>

</div>
</div>
<a id="a850c286d793fca69dea82b4d15612fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a850c286d793fca69dea82b4d15612fca">&#9670;&nbsp;</a></span>FindKeyShapeIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::FindKeyShapeIndex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the index from the key shape name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Pointer to the key shape name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the key shape.</dd></dl>
<p> <b>Details</b> <br  />
 Returns <code><a class="el" href="classnn_1_1util_1_1_res_dic.html#a825d9c73f03e6d02e9f8d0050b0e11a6" title="Specifies an invalid index.">nn::util::ResDic::Npos</a></code> when no key shape with the specified name exists. </p>

</div>
</div>
<a id="ac30fa8adfe8b77687b7f416d9026757e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30fa8adfe8b77687b7f416d9026757e">&#9670;&nbsp;</a></span>GetTargetAttribCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::GetTargetAttribCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of vertex attributes of key shapes. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of vertex attributes held by key shapes. </dd></dl>

</div>
</div>
<a id="ab69625ebe1a4a5920e0cc48cf02be2d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab69625ebe1a4a5920e0cc48cf02be2d7">&#9670;&nbsp;</a></span>HasValidBlendWeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::ShapeObj::HasValidBlendWeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the object has a valid key shape blending weight. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> when <code><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#af0aadad1cc0cc4ed59b0777886932936" title="Sets the blend weights of key shapes.">SetBlendWeight()</a></code> has been invoked after <code><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#aa8e6561517350f639c148c701992fad9" title="Initializes the blend weights of key shapes.">ClearBlendWeights()</a></code>, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="af0aadad1cc0cc4ed59b0777886932936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0aadad1cc0cc4ed59b0777886932936">&#9670;&nbsp;</a></span>SetBlendWeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::ShapeObj::SetBlendWeight </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keyShapeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the blend weights of key shapes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keyShapeIndex</td><td>The index of the key shape. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>Blend weight.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>keyShapeIndex</em></code> is within the number of key shapes held by the shape. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a60e4e6ea528f00f34f5c6a2913a435d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e4e6ea528f00f34f5c6a2913a435d9">&#9670;&nbsp;</a></span>GetBlendWeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::g3d::ShapeObj::GetBlendWeight </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keyShapeIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the blend weights of key shapes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keyShapeIndex</td><td>The index of the key shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the blend weight.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>keyShapeIndex</em></code> is within the number of key shapes held by the shape. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_shape_animation_8cpp-example.html#a80">G3dDemo/ShapeAnimation.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af0f338c38b6c82c09d6aa85edc5b47d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f338c38b6c82c09d6aa85edc5b47d2">&#9670;&nbsp;</a></span>IsBlendWeightValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::ShapeObj::IsBlendWeightValid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keyShapeIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the blend weights of key shapes are enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keyShapeIndex</td><td>The index of the key shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> when <code>SetBlendWeight(<em>keyShapeIndex</em>)</code> has been invoked after <code><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#aa8e6561517350f639c148c701992fad9" title="Initializes the blend weights of key shapes.">ClearBlendWeights()</a></code>, or <code>false</code> otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>keyShapeIndex</em></code> is within the range of the number of key shapes held by the shape. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a622d803b4f893d861e563fa1ef70f2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622d803b4f893d861e563fa1ef70f2ff">&#9670;&nbsp;</a></span>CountValidBlendWeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::CountValidBlendWeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of valid key shape blending weights. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of valid key shape blending weights. </dd></dl>

</div>
</div>
<a id="aa636a5bcd302aa52cf9bbd7458a7f3be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa636a5bcd302aa52cf9bbd7458a7f3be">&#9670;&nbsp;</a></span>SetShapeAnimCalculationEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::ShapeObj::SetShapeAnimCalculationEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the setting to calculate the shape animation result in the CPU and apply that result to the dynamic vertex buffer. </p>
<p> <b>Details</b> <br  />
</p><ul>
<li>By disabling the setting to update with the CPU and implementing a process to update the dynamic vertex buffer with the GPU, the shape animation calculation result can be quickly applied in the vertex buffer.</li>
<li>The calculation process is not performed if a dynamic vertex buffer has not been created. </li>
</ul>

</div>
</div>
<a id="aec368ccdfe5304756ef9794790725634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec368ccdfe5304756ef9794790725634">&#9670;&nbsp;</a></span>SetShapeAnimCalculationDisabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::ShapeObj::SetShapeAnimCalculationDisabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the setting to calculate the shape animation result in the CPU and apply that result to the dynamic vertex buffer. </p>
<p> <b>Details</b> <br  />
</p><ul>
<li>By disabling the setting to update with the CPU and implementing a process to update the dynamic vertex buffer with the GPU, the shape animation calculation result can be quickly applied in the vertex buffer. </li>
</ul>

</div>
</div>
<a id="ab9ab340a171e3e6a865fd488a1286ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9ab340a171e3e6a865fd488a1286ab8">&#9670;&nbsp;</a></span>IsShapeAnimCalculationEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::ShapeObj::IsShapeAnimCalculationEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the setting has been enabled to calculate the shape animation result in the CPU and apply that result to the dynamic vertex buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the setting has been enabled to calculate the shape animation result in the CPU and apply that result to the dynamic vertex buffer, or <code>false</code> if it has been disabled. </dd></dl>

</div>
</div>
<a id="a49b2ae60fa6b3f6e9f5e2cf0934143c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b2ae60fa6b3f6e9f5e2cf0934143c6">&#9670;&nbsp;</a></span>CalculateShapeAnimResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::ShapeObj::CalculateShapeAnimResult </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufferIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the dynamic vertex buffer from the key shape and blending weight. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferIndex</td><td>The buffering index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>bufferIndex</em></code> &gt;= <code>0</code> &amp;&amp; <code><em>bufferIndex</em></code> &lt; <code><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a661802cb989edfb1f765e53a9ada92f1" title="Gets the number of uniform blocks for buffering.">GetBufferingCount()</a></code>.</li>
<li><code><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a7b0e8fd440a0a3a99cf4fc71793f9484" title="Gets the number of key shapes.">GetKeyShapeCount()</a></code> &gt; <code>0</code>.</li>
<li><code><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ada67c3109b9cda5212bcdeca8d2348bf" title="Determines whether the dynamic vertex buffer has been built.">IsDynamicVertexBufferValid()</a></code></li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
</p><ul>
<li>Calculations are skipped when <code><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ab69625ebe1a4a5920e0cc48cf02be2d7" title="Determines whether the object has a valid key shape blending weight.">HasValidBlendWeight()</a></code> returns <code>false</code>.</li>
<li>Explicitly calling this function can update the dynamic vertex buffer even when <code><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#aa636a5bcd302aa52cf9bbd7458a7f3be" title="Enables the setting to calculate the shape animation result in the CPU and apply that result to the d...">SetShapeAnimCalculationEnabled()</a></code> has not been called. </li>
</ul>

</div>
</div>
<a id="a153dbe394d39548d8336b3d3ba87652e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a153dbe394d39548d8336b3d3ba87652e">&#9670;&nbsp;</a></span>GetDynamicVertexBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a>* nn::g3d::ShapeObj::GetDynamicVertexBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertexBufferIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufferIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a dynamic vertex buffer from an index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertexBufferIndex</td><td>The dynamic vertex buffer index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferIndex</td><td>The buffering index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the dynamic vertex buffer.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>vertexBufferIndex</em></code> &gt;= <code>0</code> &amp;&amp; <code><em>vertexBufferIndex</em></code> &lt; <code><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a38bfb2f1f02e9f47bf4a8796194c08e8" title="Gets the number of vertex buffers for the referenced ResVertex.">GetVertexBufferCount()</a></code>.</li>
<li><code><em>bufferIndex</em></code> &gt;= <code>0</code> &amp;&amp; <code><em>bufferIndex</em></code> &lt; <code><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a661802cb989edfb1f765e53a9ada92f1" title="Gets the number of uniform blocks for buffering.">GetBufferingCount()</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
</p><ul>
<li>The data structure and size are the same as those for the buffer you get using <code>GetVertexBuffer(<em>vertexBufferIndex</em>)</code>.</li>
<li>Returns <code>NULL</code> if there is no dynamic vertex buffer corresponding to the index.</li>
<li>By calling <code><a class="el" href="classnn_1_1g3d_1_1_res_vertex_attr.html#a3b05433c4145d9c2cbb609bfef18a6e2" title="Enables the inclusion of the vertex attribute when a dynamic vertex buffer is being created.">ResVertexAttr::SetDynamicVertexAttrEnabled()</a></code> you can create a dynamic vertex buffer including any vertex attribute you want.</li>
<li>The dynamic vertex buffer can be accessed as an unordered access buffer. </li>
</ul>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_shape_animation_8cpp-example.html#a137">G3dDemo/ShapeAnimation.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aba77fbe6ff27faf4ee74987655b22ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba77fbe6ff27faf4ee74987655b22ecf">&#9670;&nbsp;</a></span>IsDynamicVertexAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::ShapeObj::IsDynamicVertexAttr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertexAttrIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a vertex attribute specified by its index is included in the dynamic vertex buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertexAttrIndex</td><td>The vertex attribute index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if it is included in the dynamic vertex buffer, and <code>false</code> if not.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>vertexAttrIndex</em></code> &gt;= <code>0</code> &amp;&amp; <code><em>vertexAttrIndex</em></code> &lt; <code><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a987abf75f6288206255df95bbd891cde" title="Gets the number of vertex attributes of the referenced ResVertex.">GetVertexAttrCount()</a></code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2e6be9b6a4067792ff55b9665a5660a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6be9b6a4067792ff55b9665a5660a7">&#9670;&nbsp;</a></span>SetShapeBlockArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::ShapeObj::SetShapeBlockArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a> *&#160;</td>
          <td class="paramname"><em>pBlockArray</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p> <b>The use of internal features is prohibited.</b> Sets the buffer array for uniform blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBlockArray</td><td>Pointer to the buffer array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49dd09490b1b087accb0df529831c20e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49dd09490b1b087accb0df529831c20e">&#9670;&nbsp;</a></span>GetShapeBlockArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a>* nn::g3d::ShapeObj::GetShapeBlockArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p> <b>The use of internal features is prohibited.</b> Gets the buffer array for uniform blocks. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the buffer array. </dd></dl>

</div>
</div>
<a id="a274da3f4ecd7deda5fe4431c9c24c7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274da3f4ecd7deda5fe4431c9c24c7d8">&#9670;&nbsp;</a></span>GetDynamicVertexBufferArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a>** nn::g3d::ShapeObj::GetDynamicVertexBufferArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p> <b>The use of internal features is prohibited.</b> Gets a pointer to the dynamic vertex buffer array. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the dynamic buffer array. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
