<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nn::mem::StandardAllocator Class Reference | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenn.html">nn</a></li><li class="navelem"><a class="el" href="namespacenn_1_1mem.html">mem</a></li><li class="navelem"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html">StandardAllocator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="classnn_1_1mem_1_1_standard_allocator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">nn::mem::StandardAllocator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for managing memory.  
 <a href="classnn_1_1mem_1_1_standard_allocator.html#details">More...</a></p>

<p><code>#include &lt;nn/mem/mem_StandardAllocator.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1mem_1_1_standard_allocator_1_1_allocator_hash.html">AllocatorHash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for getting the internal state of the allocator.  <a href="structnn_1_1mem_1_1_standard_allocator_1_1_allocator_hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a95dd2800aef14ef0508282fd508fedcb"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a95dd2800aef14ef0508282fd508fedcb">WalkCallback</a>) (void *addr, size_t size, void *userPtr)</td></tr>
<tr class="memdesc:a95dd2800aef14ef0508282fd508fedcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the callback function that is called when cycling through allocated memory regions.  <a href="classnn_1_1mem_1_1_standard_allocator.html#a95dd2800aef14ef0508282fd508fedcb">More...</a><br /></td></tr>
<tr class="separator:a95dd2800aef14ef0508282fd508fedcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and Destructors</div></td></tr>
<tr class="memitem:a0e7e99aededf6ded0c7bdf01fbef21e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a0e7e99aededf6ded0c7bdf01fbef21e1">StandardAllocator</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0e7e99aededf6ded0c7bdf01fbef21e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classnn_1_1mem_1_1_standard_allocator.html#a0e7e99aededf6ded0c7bdf01fbef21e1">More...</a><br /></td></tr>
<tr class="separator:a0e7e99aededf6ded0c7bdf01fbef21e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3efc1b684befdaa9d3ea4c08fc8c23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a1e3efc1b684befdaa9d3ea4c08fc8c23">StandardAllocator</a> (void *addr, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1e3efc1b684befdaa9d3ea4c08fc8c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classnn_1_1mem_1_1_standard_allocator.html#a1e3efc1b684befdaa9d3ea4c08fc8c23">More...</a><br /></td></tr>
<tr class="separator:a1e3efc1b684befdaa9d3ea4c08fc8c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdb91a0ab9c236c97866b385659d35e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#affdb91a0ab9c236c97866b385659d35e">StandardAllocator</a> (void *addr, size_t size, bool isCacheEnable) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:affdb91a0ab9c236c97866b385659d35e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classnn_1_1mem_1_1_standard_allocator.html#affdb91a0ab9c236c97866b385659d35e">More...</a><br /></td></tr>
<tr class="separator:affdb91a0ab9c236c97866b385659d35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254da7aa9f98eb4947ce540c28727644"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a254da7aa9f98eb4947ce540c28727644">~StandardAllocator</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a254da7aa9f98eb4947ce540c28727644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classnn_1_1mem_1_1_standard_allocator.html#a254da7aa9f98eb4947ce540c28727644">More...</a><br /></td></tr>
<tr class="separator:a254da7aa9f98eb4947ce540c28727644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Initialization and Finalization</div></td></tr>
<tr class="memitem:acdb0dd01602811a4f469c87c348d3ed1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#acdb0dd01602811a4f469c87c348d3ed1">Initialize</a> (void *addr, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acdb0dd01602811a4f469c87c348d3ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the specified memory region to be managed by <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="Class for managing memory.">StandardAllocator</a></code>.  <a href="classnn_1_1mem_1_1_standard_allocator.html#acdb0dd01602811a4f469c87c348d3ed1">More...</a><br /></td></tr>
<tr class="separator:acdb0dd01602811a4f469c87c348d3ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb339622a4d7801fd791afe25a8ed81a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#aeb339622a4d7801fd791afe25a8ed81a">Initialize</a> (void *addr, size_t size, bool isCacheEnable) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aeb339622a4d7801fd791afe25a8ed81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the specified memory region to be managed by <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="Class for managing memory.">StandardAllocator</a></code>.  <a href="classnn_1_1mem_1_1_standard_allocator.html#aeb339622a4d7801fd791afe25a8ed81a">More...</a><br /></td></tr>
<tr class="separator:aeb339622a4d7801fd791afe25a8ed81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6027bb6b016064edb1b007651d4af419"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a6027bb6b016064edb1b007651d4af419">Finalize</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6027bb6b016064edb1b007651d4af419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the allocator.  <a href="classnn_1_1mem_1_1_standard_allocator.html#a6027bb6b016064edb1b007651d4af419">More...</a><br /></td></tr>
<tr class="separator:a6027bb6b016064edb1b007651d4af419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Memory Region Operation API Resources</div></td></tr>
<tr class="memitem:a53438b7a6199e4f100c59312d2f123cf"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a53438b7a6199e4f100c59312d2f123cf">Allocate</a> (size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a53438b7a6199e4f100c59312d2f123cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a memory region.  <a href="classnn_1_1mem_1_1_standard_allocator.html#a53438b7a6199e4f100c59312d2f123cf">More...</a><br /></td></tr>
<tr class="separator:a53438b7a6199e4f100c59312d2f123cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7fc331f7bbcac7221fd7416366ef87a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#ac7fc331f7bbcac7221fd7416366ef87a">Allocate</a> (size_t size, size_t alignment) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac7fc331f7bbcac7221fd7416366ef87a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory with a specific alignment.  <a href="classnn_1_1mem_1_1_standard_allocator.html#ac7fc331f7bbcac7221fd7416366ef87a">More...</a><br /></td></tr>
<tr class="separator:ac7fc331f7bbcac7221fd7416366ef87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81377b59c5e1532869b003cd9b5f318"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#ad81377b59c5e1532869b003cd9b5f318">Free</a> (void *addr) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad81377b59c5e1532869b003cd9b5f318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a memory region.  <a href="classnn_1_1mem_1_1_standard_allocator.html#ad81377b59c5e1532869b003cd9b5f318">More...</a><br /></td></tr>
<tr class="separator:ad81377b59c5e1532869b003cd9b5f318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b6984b5dac190453d450e819041633"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a83b6984b5dac190453d450e819041633">Reallocate</a> (void *addr, size_t newSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a83b6984b5dac190453d450e819041633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocates a memory region of the specified size.  <a href="classnn_1_1mem_1_1_standard_allocator.html#a83b6984b5dac190453d450e819041633">More...</a><br /></td></tr>
<tr class="separator:a83b6984b5dac190453d450e819041633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3df3357faccf930389b6bca6f0cdda"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a0f3df3357faccf930389b6bca6f0cdda">Shrink</a> (void *addr, size_t newSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0f3df3357faccf930389b6bca6f0cdda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrinks the memory space to the specified size without changing the starting address.  <a href="classnn_1_1mem_1_1_standard_allocator.html#a0f3df3357faccf930389b6bca6f0cdda">More...</a><br /></td></tr>
<tr class="separator:a0f3df3357faccf930389b6bca6f0cdda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b942ec23f715b66f82c02150727fa08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a2b942ec23f715b66f82c02150727fa08">ClearThreadCache</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2b942ec23f715b66f82c02150727fa08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the cached free space for specific threads so that it is available for all threads.  <a href="classnn_1_1mem_1_1_standard_allocator.html#a2b942ec23f715b66f82c02150727fa08">More...</a><br /></td></tr>
<tr class="separator:a2b942ec23f715b66f82c02150727fa08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4858268238de9bf46d6e86b1783349"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a1e4858268238de9bf46d6e86b1783349">CleanUpManagementArea</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1e4858268238de9bf46d6e86b1783349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up the allocator management region.  <a href="classnn_1_1mem_1_1_standard_allocator.html#a1e4858268238de9bf46d6e86b1783349">More...</a><br /></td></tr>
<tr class="separator:a1e4858268238de9bf46d6e86b1783349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">API Resources for Debugging</div></td></tr>
<tr class="memitem:a45744a752336aa336842674bdccb4210"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a45744a752336aa336842674bdccb4210">GetSizeOf</a> (const void *addr) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a45744a752336aa336842674bdccb4210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the specified allocated memory region.  <a href="classnn_1_1mem_1_1_standard_allocator.html#a45744a752336aa336842674bdccb4210">More...</a><br /></td></tr>
<tr class="separator:a45744a752336aa336842674bdccb4210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad236cc9a53ffcaa18e94ec1432fa5c68"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#ad236cc9a53ffcaa18e94ec1432fa5c68">GetTotalFreeSize</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad236cc9a53ffcaa18e94ec1432fa5c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total available memory for the allocator.  <a href="classnn_1_1mem_1_1_standard_allocator.html#ad236cc9a53ffcaa18e94ec1432fa5c68">More...</a><br /></td></tr>
<tr class="separator:ad236cc9a53ffcaa18e94ec1432fa5c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8b81f5b47c9ade27986951bea02d45"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a5d8b81f5b47c9ade27986951bea02d45">GetAllocatableSize</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5d8b81f5b47c9ade27986951bea02d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the largest size that can be allocated from the allocator.  <a href="classnn_1_1mem_1_1_standard_allocator.html#a5d8b81f5b47c9ade27986951bea02d45">More...</a><br /></td></tr>
<tr class="separator:a5d8b81f5b47c9ade27986951bea02d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1196844b494e896ea391df672050776b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a1196844b494e896ea391df672050776b">WalkAllocatedBlocks</a> (<a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a95dd2800aef14ef0508282fd508fedcb">WalkCallback</a> callback, void *userPtr) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1196844b494e896ea391df672050776b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a callback function for allocated memory regions.  <a href="classnn_1_1mem_1_1_standard_allocator.html#a1196844b494e896ea391df672050776b">More...</a><br /></td></tr>
<tr class="separator:a1196844b494e896ea391df672050776b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644b9a162b9b8bf22a3e429966e53c9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a644b9a162b9b8bf22a3e429966e53c9f">Dump</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a644b9a162b9b8bf22a3e429966e53c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays the information in the allocator.  <a href="classnn_1_1mem_1_1_standard_allocator.html#a644b9a162b9b8bf22a3e429966e53c9f">More...</a><br /></td></tr>
<tr class="separator:a644b9a162b9b8bf22a3e429966e53c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6de9d17a7aaa6f54e95a3125a96dbda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1mem_1_1_standard_allocator_1_1_allocator_hash.html">AllocatorHash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#af6de9d17a7aaa6f54e95a3125a96dbda">Hash</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af6de9d17a7aaa6f54e95a3125a96dbda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a hash based on information in the allocator.  <a href="classnn_1_1mem_1_1_standard_allocator.html#af6de9d17a7aaa6f54e95a3125a96dbda">More...</a><br /></td></tr>
<tr class="separator:af6de9d17a7aaa6f54e95a3125a96dbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for managing memory. </p>
<p> <b>Details</b> <br  />
 <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="Class for managing memory.">nn::mem::StandardAllocator</a></code> is a class for allocating and freeing memory. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#_a1">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#_a1">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#_a42">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#_a1">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#_a1">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#_a1">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#_a1">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_out_2_audio_out_8cpp-example.html#_a34">AudioOut/AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_2_audio_out_with_resampler_8cpp-example.html#_a34">AudioOutWithResampler/AudioOutWithResampler.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#_a1">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#_a1">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#_a1">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#_a1">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_aac_decoder_2_codec_aac_decoder_8cpp-example.html#_a5">CodecAacDecoder/CodecAacDecoder.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#_a18">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#_a49">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#_a5">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#_a6">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>, <a class="el" href="_demo1_2_demo1_8cpp-example.html#_a2">Demo1/Demo1.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#_a3">FontDemo/Main.cpp</a>, <a class="el" href="_gfx_primitive_renderer_2_gfx_primitive_renderer_8cpp-example.html#_a231">GfxPrimitiveRenderer/GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__main_8cpp-example.html#_a18">HidControllerSequence/HidControllerSequence_Main.cpp</a>, <a class="el" href="_hid_npad_six_axis_sensor_2_hid_npad_six_axis_sensor__main_8cpp-example.html#_a76">HidNpadSixAxisSensor/HidNpadSixAxisSensor_Main.cpp</a>, <a class="el" href="_hid_vibration_basic_2_hid_vibration_basic_8cpp-example.html#_a0">HidVibrationBasic/HidVibrationBasic.cpp</a>, <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#_a1">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>, <a class="el" href="_hid_vibration_rolling_ball_2_hid_vibration_rolling_ball_8cpp-example.html#_a0">HidVibrationRollingBall/HidVibrationRollingBall.cpp</a>, <a class="el" href="_init_startup_with_malloc_2_init_startup_with_malloc_8cpp-example.html#_a2">InitStartupWithMalloc/InitStartupWithMalloc.cpp</a>, <a class="el" href="_ir_sensor_viewer_2_ir_sensor_viewer_8cpp-example.html#_a0">IrSensorViewer/IrSensorViewer.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#_a5">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_multi_program_application_2_main_2_main_8cpp-example.html#_a3">MultiProgramApplication/Main/Main.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_file_cache_8cpp-example.html#_a0">NvnSimple/NvnSimpleSharedLib/FileCache.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_file_system_8cpp-example.html#_a0">NvnSimple/NvnSimpleSharedLib/FileSystem.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_font_8cpp-example.html#_a2">NvnSimple/NvnSimpleSharedLib/Font.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_graphics_context_8cpp-example.html#_a5">NvnSimple/NvnSimpleSharedLib/GraphicsContext.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_graphics_system_8cpp-example.html#_a0">NvnSimple/NvnSimpleSharedLib/GraphicsSystem.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_simple_framework_8cpp-example.html#_a0">NvnSimple/NvnSimpleSharedLib/SimpleFramework.cpp</a>, <a class="el" href="_spy_audio_2_spy_audio_8cpp-example.html#_a0">SpyAudio/SpyAudio.cpp</a>, <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#_a10">Ui2dDemo/Main.cpp</a>, <a class="el" href="nvnsimple_2_nvn_simple_shared_lib_2_file_cache_8h-example.html#_a1">nvnsimple/NvnSimpleSharedLib/FileCache.h</a>, <a class="el" href="nvnsimple_2_nvn_simple_shared_lib_2_file_system_8h-example.html#_a0">nvnsimple/NvnSimpleSharedLib/FileSystem.h</a>, <a class="el" href="nvnsimple_2_nvn_simple_shared_lib_2_font_8h-example.html#_a1">nvnsimple/NvnSimpleSharedLib/Font.h</a>, <a class="el" href="nvnsimple_2_nvn_simple_shared_lib_2_graphics_system_8h-example.html#_a2">nvnsimple/NvnSimpleSharedLib/GraphicsSystem.h</a>, and <a class="el" href="nvntutorial_2_aligned_allocator_8h-example.html#_a1">nvntutorial/AlignedAllocator.h</a>.</dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a95dd2800aef14ef0508282fd508fedcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95dd2800aef14ef0508282fd508fedcb">&#9670;&nbsp;</a></span>WalkCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* nn::mem::StandardAllocator::WalkCallback) (void *addr, size_t size, void *userPtr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the callback function that is called when cycling through allocated memory regions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Starting address of allocated memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the allocated memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userPtr</td><td>Pointer passed from the user.</td></tr>
  </table>
  </dd>
</dl>
<p><br  />
 </p><dl class="retval"><dt><b><a class="el" href="retval.html#_retval000114">Return Values:</a></b></dt><dd><p class="startdd"><b>0</b> The <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a1196844b494e896ea391df672050776b" title="Calls a callback function for allocated memory regions.">WalkAllocatedBlocks()</a></code> function has completed. <br  />
 </p>
<p class="enddd"><b>1</b> The <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a1196844b494e896ea391df672050776b" title="Calls a callback function for allocated memory regions.">WalkAllocatedBlocks()</a></code> function is continuing to run.</p>
</dd></dl>
<p> <b>Details</b> <br  />
 The type of the callback function used by the <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a1196844b494e896ea391df672050776b" title="Calls a callback function for allocated memory regions.">WalkAllocatedBlocks()</a></code> function.<br  />
 If you are going to allocate and free memory within the callback, make sure to return <code>0</code>. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0e7e99aededf6ded0c7bdf01fbef21e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7e99aededf6ded0c7bdf01fbef21e1">&#9670;&nbsp;</a></span>StandardAllocator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nn::mem::StandardAllocator::StandardAllocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p> <b>Details</b> <br  />
 This constructor does not initialize memory regions. At a later point, call the <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#acdb0dd01602811a4f469c87c348d3ed1" title="Initializes the specified memory region to be managed by StandardAllocator.">Initialize()</a></code> function to initialize memory regions managed by <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="Class for managing memory.">StandardAllocator</a></code>.<br  />
<br  />
 This function is not thread-safe. </p>

</div>
</div>
<a id="a1e3efc1b684befdaa9d3ea4c08fc8c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3efc1b684befdaa9d3ea4c08fc8c23">&#9670;&nbsp;</a></span>StandardAllocator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nn::mem::StandardAllocator::StandardAllocator </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Starting address of the memory region to be used by the allocator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the region to be used by the allocator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The memory region is larger than the allocator's management region. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The allocator is initialized.</dd></dl>
<p> <b>Details</b> <br  />
 Initializes the specified memory region to be managed by <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="Class for managing memory.">StandardAllocator</a></code>.<br  />
<br  />
 This allocator uses the memory region passed to it, after performing a 4-KB alignment.<br  />
 For maximum efficiency, set both <code><em>addr</em></code> and <code><em>size</em></code> to multiples of 4 KB.<br  />
 In addition, the allocator's management region requires at least 16 KB, so you must specify values greater than 16 KB that are 4-KB aligned.<br  />
<br  />
 If <code>nullptr</code> is passed to <code><em>addr</em></code>, virtual address space is reserved for the size specified by <code><em>size</em></code>. Physical memory is assigned as necessary in the reserved virtual address space. Physical memory is assigned when it becomes necessary. Physical memory that is no longer needed is freed. This feature is only available when <code><a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="Determines whether virtual address memory management is available.">nn::os::IsVirtualAddressMemoryEnabled()</a></code> returns <code>true</code>. For more information, see <code><a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="Determines whether virtual address memory management is available.">nn::os::IsVirtualAddressMemoryEnabled()</a></code>.<br  />
<br  />
 This function is not thread-safe.<br  />
 Do not perform any actions on the allocator while this API is running. </p>

</div>
</div>
<a id="affdb91a0ab9c236c97866b385659d35e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affdb91a0ab9c236c97866b385659d35e">&#9670;&nbsp;</a></span>StandardAllocator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nn::mem::StandardAllocator::StandardAllocator </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isCacheEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>You can select whether to enable or disable the cache feature for each thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Starting address of the memory region to be used by the allocator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the region to be used by the allocator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isCacheEnable</td><td>Whether to enable the memory cache feature of each thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The memory region is larger than the allocator's management region. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The allocator is initialized.</dd></dl>
<p> <b>Details</b> <br  />
 Initializes the specified memory region to be managed by <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="Class for managing memory.">StandardAllocator</a></code>.<br  />
<br  />
 This allocator uses the memory region passed to it, after performing a 4-KB alignment.<br  />
 For maximum efficiency, set both <code><em>addr</em></code> and <code><em>size</em></code> to multiples of 4 KB.<br  />
 In addition, the allocator's management region requires at least 16 KB, so you must specify values greater than 16 KB that are 4-KB aligned.<br  />
<br  />
 Pass <code>true</code> to <code><em>isCacheEnable</em></code> to enable a feature to improve the speed of allocating and freeing memory during multithreading.<br  />
 This feature uses one TLS slot.<br  />
 For more information about allocating and freeing memory when <code><em>isCacheEnable</em></code> is <code>true</code>, see <a href="../../Package/contents/Pages/Page_89102552.html">StandardAllocator</a> in the <code>mem</code> library manual in NintendoSDK Documents.<br  />
<br  />
 If <code>nullptr</code> is passed to <code><em>addr</em></code>, virtual address space is reserved for the size specified by <code><em>size</em></code>. Physical memory is assigned as necessary in the reserved virtual address space. Physical memory is assigned when it becomes necessary. Physical memory that is no longer needed is freed. This feature is only available when <code><a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="Determines whether virtual address memory management is available.">nn::os::IsVirtualAddressMemoryEnabled()</a></code> returns <code>true</code>. For more information, see <code><a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="Determines whether virtual address memory management is available.">nn::os::IsVirtualAddressMemoryEnabled()</a></code>.<br  />
<br  />
 This function is not thread-safe.<br  />
 Do not perform any actions on the allocator while this API is running. </p>

</div>
</div>
<a id="a254da7aa9f98eb4947ce540c28727644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254da7aa9f98eb4947ce540c28727644">&#9670;&nbsp;</a></span>~StandardAllocator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nn::mem::StandardAllocator::~StandardAllocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p> <b>Details</b> <br  />
 If the allocator has been initialized, call the <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a6027bb6b016064edb1b007651d4af419" title="Frees the allocator.">Finalize()</a></code> function to release it.<br  />
<br  />
 This function is not thread-safe. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acdb0dd01602811a4f469c87c348d3ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb0dd01602811a4f469c87c348d3ed1">&#9670;&nbsp;</a></span>Initialize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::mem::StandardAllocator::Initialize </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the specified memory region to be managed by <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="Class for managing memory.">StandardAllocator</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Starting address of the memory region to be used by the allocator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the region to be used by the allocator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The allocator is not initialized. </dd>
<dd>
The memory region is larger than the allocator's management region. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The allocator is initialized.</dd></dl>
<p> <b>Details</b> <br  />
 Initializes the specified memory region to be managed by <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="Class for managing memory.">StandardAllocator</a></code>.<br  />
<br  />
 This allocator uses the memory region passed to it, after performing a 4-KB alignment.<br  />
 For maximum efficiency, set both <code><em>addr</em></code> and <code><em>size</em></code> to multiples of 4 KB.<br  />
 In addition, the allocator's management region requires at least 16 KB, so you must specify values greater than 16 KB that are 4-KB aligned.<br  />
<br  />
 If <code>nullptr</code> is passed to <code><em>addr</em></code>, virtual address space is reserved for the size specified by <code><em>size</em></code>. Physical memory is assigned as necessary in the reserved virtual address space. Physical memory is assigned when it becomes necessary. Physical memory that is no longer needed is freed. This feature is only available when <code><a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="Determines whether virtual address memory management is available.">nn::os::IsVirtualAddressMemoryEnabled()</a></code> returns <code>true</code>. For more information, see <code><a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="Determines whether virtual address memory management is available.">nn::os::IsVirtualAddressMemoryEnabled()</a></code>.<br  />
<br  />
 This function is not thread-safe.<br  />
 Do not perform any actions on the allocator while this API is running. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a65">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_demo1_2_demo1_8cpp-example.html#a7">Demo1/Demo1.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#a92">FontDemo/Main.cpp</a>, <a class="el" href="_gfx_primitive_renderer_2_gfx_primitive_renderer_8cpp-example.html#a235">GfxPrimitiveRenderer/GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__main_8cpp-example.html#a19">HidControllerSequence/HidControllerSequence_Main.cpp</a>, <a class="el" href="_hid_npad_six_axis_sensor_2_hid_npad_six_axis_sensor__main_8cpp-example.html#a77">HidNpadSixAxisSensor/HidNpadSixAxisSensor_Main.cpp</a>, <a class="el" href="_hid_vibration_basic_2_hid_vibration_basic_8cpp-example.html#a2">HidVibrationBasic/HidVibrationBasic.cpp</a>, <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a44">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>, <a class="el" href="_hid_vibration_rolling_ball_2_hid_vibration_rolling_ball_8cpp-example.html#a3">HidVibrationRollingBall/HidVibrationRollingBall.cpp</a>, <a class="el" href="_ir_sensor_viewer_2_ir_sensor_viewer_8cpp-example.html#a4">IrSensorViewer/IrSensorViewer.cpp</a>, <a class="el" href="_multi_program_application_2_main_2_main_8cpp-example.html#a7">MultiProgramApplication/Main/Main.cpp</a>, and <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#a130">Ui2dDemo/Main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aeb339622a4d7801fd791afe25a8ed81a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb339622a4d7801fd791afe25a8ed81a">&#9670;&nbsp;</a></span>Initialize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::mem::StandardAllocator::Initialize </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isCacheEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the specified memory region to be managed by <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="Class for managing memory.">StandardAllocator</a></code>. </p>
<p>You can select whether to enable or disable the cache feature for each thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Starting address of the memory region to be used by the allocator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the region to be used by the allocator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isCacheEnable</td><td>Whether to enable the memory cache feature of each thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The allocator is not initialized. </dd>
<dd>
The memory region is larger than the allocator's management region. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The allocator is initialized.</dd></dl>
<p> <b>Details</b> <br  />
 Initializes the specified memory region to be managed by <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="Class for managing memory.">StandardAllocator</a></code>.<br  />
<br  />
 This allocator uses the memory region passed to it, after performing a 4-KB alignment.<br  />
 For maximum efficiency, set both <code><em>addr</em></code> and <code><em>size</em></code> to multiples of 4 KB.<br  />
 In addition, the allocator's management region requires at least 16 KB, so you must specify values greater than 16 KB that are 4-KB aligned.<br  />
<br  />
 Pass <code>true</code> to <code><em>isCacheEnable</em></code> to enable a feature to improve the speed of allocating and freeing memory during multithreading.<br  />
 This feature uses one TLS slot.<br  />
 For more information about allocating and freeing memory when <code><em>isCacheEnable</em></code> is <code>true</code>, see <a href="../../Package/contents/Pages/Page_89102552.html">StandardAllocator</a> in the <code>mem</code> library manual in NintendoSDK Documents.<br  />
<br  />
 If <code>nullptr</code> is passed to <code><em>addr</em></code>, virtual address space is reserved for the size specified by <code><em>size</em></code>. Physical memory is assigned as necessary in the reserved virtual address space. Physical memory is assigned when it becomes necessary. Physical memory that is no longer needed is freed. This feature is only available when <code><a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="Determines whether virtual address memory management is available.">nn::os::IsVirtualAddressMemoryEnabled()</a></code> returns <code>true</code>. For more information, see <code><a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="Determines whether virtual address memory management is available.">nn::os::IsVirtualAddressMemoryEnabled()</a></code>.<br  />
<br  />
 This function is not thread-safe.<br  />
 Do not perform any actions on the allocator while this API is running. </p>

</div>
</div>
<a id="a6027bb6b016064edb1b007651d4af419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6027bb6b016064edb1b007651d4af419">&#9670;&nbsp;</a></span>Finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::mem::StandardAllocator::Finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the allocator. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The allocator is initialized. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The allocator is uninitialized.</dd></dl>
<p> <b>Details</b> <br  />
 Frees the allocator.<br  />
 This function is not thread-safe.<br  />
 Do not perform any actions on the allocator while this API is running. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a71">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_demo1_2_demo1_8cpp-example.html#a15">Demo1/Demo1.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#a104">FontDemo/Main.cpp</a>, <a class="el" href="_gfx_primitive_renderer_2_gfx_primitive_renderer_8cpp-example.html#a243">GfxPrimitiveRenderer/GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__main_8cpp-example.html#a34">HidControllerSequence/HidControllerSequence_Main.cpp</a>, <a class="el" href="_hid_vibration_basic_2_hid_vibration_basic_8cpp-example.html#a18">HidVibrationBasic/HidVibrationBasic.cpp</a>, <a class="el" href="_hid_vibration_rolling_ball_2_hid_vibration_rolling_ball_8cpp-example.html#a11">HidVibrationRollingBall/HidVibrationRollingBall.cpp</a>, <a class="el" href="_ir_sensor_viewer_2_ir_sensor_viewer_8cpp-example.html#a19">IrSensorViewer/IrSensorViewer.cpp</a>, and <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#a151">Ui2dDemo/Main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a53438b7a6199e4f100c59312d2f123cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53438b7a6199e4f100c59312d2f123cf">&#9670;&nbsp;</a></span>Allocate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::mem::StandardAllocator::Allocate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a memory region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size, in bytes, of the memory to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the starting address of the allocated memory. If it fails, <code>NULL</code> is returned.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The allocator is initialized. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The starting address of the memory region allocated from the allocator is returned.</dd></dl>
<p> <b>Details</b> <br  />
 Allocates a memory block of the specified size from the allocator.<br  />
 The default value of the allocated memory region is indefinite.<br  />
 The allocated memory region has a starting address with a byte alignment of <code><a class="el" href="nn___macro_8h.html#ac6f80ca2ebf15f619391e35806e9635f" title="Gets the byte alignment.">NN_ALIGNOF(std::max_align_t)</a></code>.<br  />
 When <code><em>size</em></code> is <code>0</code>, no memory is allocated and <code>NULL</code> is returned.<br  />
 The size of the allocated memory block might end up being larger than the requested size. It is padded to a multiple of <code><em>sizeof</em>(std::max_align_t)</code>.<br  />
<br  />
 This function is thread-safe. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a4">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#a9">FontDemo/Main.cpp</a>, <a class="el" href="_gfx_primitive_renderer_2_gfx_primitive_renderer_8cpp-example.html#a233">GfxPrimitiveRenderer/GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_hid_npad_six_axis_sensor_2_hid_npad_six_axis_sensor__main_8cpp-example.html#a80">HidNpadSixAxisSensor/HidNpadSixAxisSensor_Main.cpp</a>, <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a12">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>, <a class="el" href="_ir_sensor_viewer_2_ir_sensor_viewer_8cpp-example.html#a14">IrSensorViewer/IrSensorViewer.cpp</a>, <a class="el" href="_multi_program_application_2_main_2_main_8cpp-example.html#a5">MultiProgramApplication/Main/Main.cpp</a>, <a class="el" href="_spy_audio_2_spy_audio_8cpp-example.html#a8">SpyAudio/SpyAudio.cpp</a>, and <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#a12">Ui2dDemo/Main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac7fc331f7bbcac7221fd7416366ef87a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7fc331f7bbcac7221fd7416366ef87a">&#9670;&nbsp;</a></span>Allocate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::mem::StandardAllocator::Allocate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory with a specific alignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size, in bytes, of the memory to allocate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>Alignment of the memory to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the starting address of the allocated memory. If it fails, <code>NULL</code> is returned.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The allocator is initialized. </dd>
<dd>
<code><em>size</em></code> &gt; <code>0</code>. </dd>
<dd>
<code><em>alignment</em></code> is a positive power of 2. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The starting address of the memory region allocated from the allocator is returned.</dd></dl>
<p> <b>Details</b> <br  />
 Allocates a memory block of the specified size and alignment from the allocator.<br  />
 The default value of the allocated memory region is indefinite.<br  />
 For <code><em>alignment</em></code>, specify a positive power of 2.<br  />
 When <code><em>size</em></code> is <code>0</code>, no memory is allocated and <code>NULL</code> is returned.<br  />
 The size of the allocated memory block might end up being larger than the requested size. It is padded to a multiple of <code><em>sizeof</em>(std::max_align_t)</code>.<br  />
<br  />
 This function is thread-safe. </p>

</div>
</div>
<a id="ad81377b59c5e1532869b003cd9b5f318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad81377b59c5e1532869b003cd9b5f318">&#9670;&nbsp;</a></span>Free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::mem::StandardAllocator::Free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a memory region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Starting address of the memory region to free.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The allocator is initialized. </dd>
<dd>
<code><em>addr</em></code> is the starting address of a memory region allocated from the allocator.</dd></dl>
<p> <b>Details</b> <br  />
 Frees a memory region.</p>
<p>This function is thread-safe. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a63">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#a11">FontDemo/Main.cpp</a>, <a class="el" href="_gfx_primitive_renderer_2_gfx_primitive_renderer_8cpp-example.html#a234">GfxPrimitiveRenderer/GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a14">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>, <a class="el" href="_ir_sensor_viewer_2_ir_sensor_viewer_8cpp-example.html#a18">IrSensorViewer/IrSensorViewer.cpp</a>, <a class="el" href="_multi_program_application_2_main_2_main_8cpp-example.html#a6">MultiProgramApplication/Main/Main.cpp</a>, <a class="el" href="_spy_audio_2_spy_audio_8cpp-example.html#a10">SpyAudio/SpyAudio.cpp</a>, and <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#a13">Ui2dDemo/Main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a83b6984b5dac190453d450e819041633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83b6984b5dac190453d450e819041633">&#9670;&nbsp;</a></span>Reallocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::mem::StandardAllocator::Reallocate </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocates a memory region of the specified size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The starting address of an allocated memory region. Works in the same way as the <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a53438b7a6199e4f100c59312d2f123cf" title="Allocates a memory region.">Allocate()</a></code> function when <code>NULL</code> is specified. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newSize</td><td>The size to newly allocate. Works in the same way as the <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#ad81377b59c5e1532869b003cd9b5f318" title="Frees a memory region.">Free()</a></code> function when <code>0</code> is specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the starting address of the reallocated memory region. If the operation fails, <code>NULL</code> is returned.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The allocator is initialized. </dd>
<dd>
<code><em>addr</em></code> must be an address allocated using the <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a53438b7a6199e4f100c59312d2f123cf" title="Allocates a memory region.">Allocate()</a></code> function from <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="Class for managing memory.">StandardAllocator</a></code>.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The starting address of the memory region reallocated from the allocator is returned.</dd></dl>
<p> <b>Details</b> <br  />
 Takes an allocated memory region, and reallocates it to a specified size.<br  />
 If the new size is larger, all data from the old memory region is copied.<br  />
 The default value of the increased memory region is indefinite.<br  />
 If the new size is smaller, only data in the amount equal to <code><em>newSize</em></code> is copied from the old memory region.<br  />
 The address of the memory region may change, regardless of whether the size increases or decreases.<br  />
 Newly allocated memory areas do not maintain the <code><em>addr</em></code> alignment. The starting address has a byte alignment of <code><a class="el" href="nn___macro_8h.html#ac6f80ca2ebf15f619391e35806e9635f" title="Gets the byte alignment.">NN_ALIGNOF(std::max_align_t)</a></code>.<br  />
<br  />
 This function is thread-safe. </p>

</div>
</div>
<a id="a0f3df3357faccf930389b6bca6f0cdda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3df3357faccf930389b6bca6f0cdda">&#9670;&nbsp;</a></span>Shrink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::mem::StandardAllocator::Shrink </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shrinks the memory space to the specified size without changing the starting address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The starting address of an allocated memory space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newSize</td><td>This function fails if the specified size is larger that the originally allocated size of memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the size of the memory space after it has been reduced. If the process fails the function returns <code>0</code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The allocator is initialized. </dd>
<dd>
<code><em>addr</em></code> must be an address allocated using the <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a53438b7a6199e4f100c59312d2f123cf" title="Allocates a memory region.">Allocate()</a></code> function from <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="Class for managing memory.">StandardAllocator</a></code>.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Reduces the memory space allocated to <code><em>addr</em></code> and returns the newly assigned size.</dd></dl>
<p> <b>Details</b> <br  />
 The size of the allocated memory space is reduced to the assigned size without changing the starting address of the allocated space.<br  />
 This function might fail, depending on the value of <code><em>newSize</em></code>, the original size, and the allocation status in the allocator.<br  />
 After shrinking, the memory size is assured of being less than the original size, but it does not necessarily match <code><em>newSize</em></code>.<br  />
<br  />
 This function is thread-safe. </p>

</div>
</div>
<a id="a2b942ec23f715b66f82c02150727fa08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b942ec23f715b66f82c02150727fa08">&#9670;&nbsp;</a></span>ClearThreadCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::mem::StandardAllocator::ClearThreadCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the cached free space for specific threads so that it is available for all threads. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The allocator is initialized.</dd></dl>
<p> <b>Details</b> <br  />
 Frees the cached free space using the memory cache feature for each thread, and makes the free space allocatable from all threads.<br  />
 This function is only enabled when <code><em>isCacheEnable</em></code> is <code>true</code> when calling the constructor or when calling the <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#acdb0dd01602811a4f469c87c348d3ed1" title="Initializes the specified memory region to be managed by StandardAllocator.">Initialize()</a></code> function.<br  />
 Otherwise no processing is performed and <code>return</code> is issued.<br  />
 The only cache memory that is freed is the cache in the thread that called this function, and if any other threads have cache memory that cache is not freed.<br  />
 If you want to free the cache in all threads, you must call this function in every thread.<br  />
<br  />
 This function is thread-safe. </p>

</div>
</div>
<a id="a1e4858268238de9bf46d6e86b1783349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4858268238de9bf46d6e86b1783349">&#9670;&nbsp;</a></span>CleanUpManagementArea()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::mem::StandardAllocator::CleanUpManagementArea </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cleans up the allocator management region. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The allocator is initialized.</dd></dl>
<p> <b>Details</b> <br  />
 The size of the allocator management region changes dynamically.<br  />
 Although this management region gets automatically cleaned up as necessary during allocation, calling this function allows you to start the cleanup process explicitly. In some cases, this can prevent or reduce memory fragmentation.<br  />
 Also, calling this function may increase the values returned by subsequent calls to <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a5d8b81f5b47c9ade27986951bea02d45" title="Gets the largest size that can be allocated from the allocator.">GetAllocatableSize()</a></code> and <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#ad236cc9a53ffcaa18e94ec1432fa5c68" title="Gets the total available memory for the allocator.">GetTotalFreeSize()</a></code>.<br  />
<br  />
 This function is thread-safe. </p>

</div>
</div>
<a id="a45744a752336aa336842674bdccb4210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45744a752336aa336842674bdccb4210">&#9670;&nbsp;</a></span>GetSizeOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::mem::StandardAllocator::GetSizeOf </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of the specified allocated memory region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Starting address of the memory region for which the size is to be acquired.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The allocator is initialized. </dd>
<dd>
<code><em>addr</em></code> must be an address allocated using the <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a53438b7a6199e4f100c59312d2f123cf" title="Allocates a memory region.">Allocate()</a></code> function from <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="Class for managing memory.">StandardAllocator</a></code>.</dd></dl>
<p> <b>Details</b> <br  />
 Gets the size of the specified allocated memory region.<br  />
 The size that can be obtained by this function is the actual size of the memory region that was allocated, not the size that is specified when using the <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a53438b7a6199e4f100c59312d2f123cf" title="Allocates a memory region.">Allocate()</a></code> function.<br  />
<br  />
 This function is thread-safe. </p>

</div>
</div>
<a id="ad236cc9a53ffcaa18e94ec1432fa5c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad236cc9a53ffcaa18e94ec1432fa5c68">&#9670;&nbsp;</a></span>GetTotalFreeSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::mem::StandardAllocator::GetTotalFreeSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the total available memory for the allocator. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total amount of free space.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The allocator is initialized.</dd></dl>
<p> <b>Details</b> <br  />
 Gets the total available memory managed by the allocator.<br  />
 When there are multiple available memory regions, the actual allocatable size is smaller than the total size.<br  />
 Use the <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a5d8b81f5b47c9ade27986951bea02d45" title="Gets the largest size that can be allocated from the allocator.">GetAllocatableSize()</a></code> function to get the actual allocatable size.<br  />
<br  />
 This function can take time, depending on the allocation or release state inside the allocator.<br  />
<br  />
 Returns the size of the empty area to which physical memory can be allocated if the virtual address management feature is enabled and the virtual address space specified by <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="Class for managing memory.">StandardAllocator</a></code> is larger than the physical space.<br  />
<br  />
 This function is thread-safe if the <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="Class for managing memory.">StandardAllocator</a> virtual address management feature is disabled, and not thread-safe if the feature is enabled. </p>

</div>
</div>
<a id="a5d8b81f5b47c9ade27986951bea02d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8b81f5b47c9ade27986951bea02d45">&#9670;&nbsp;</a></span>GetAllocatableSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::mem::StandardAllocator::GetAllocatableSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the largest size that can be allocated from the allocator. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the size of allocatable memory.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The allocator is initialized.</dd></dl>
<p> <b>Details</b> <br  />
 Gets the largest size that can be allocated from the allocator.<br  />
 When there are multiple available memory regions, gets the size of the largest among them.<br  />
<br  />
 The size returned by this API will always be allocatable. However, sometimes the algorithm might allocate a region greater than the size returned by this API.<br  />
<br  />
 This function can take time, depending on the allocation or release state inside the allocator.<br  />
<br  />
 Returns the size of the empty area to which physical memory can be allocated if the virtual address management feature is enabled and the virtual address space specified by <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="Class for managing memory.">StandardAllocator</a></code> is larger than the physical space.<br  />
<br  />
 This function is thread-safe if the <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="Class for managing memory.">StandardAllocator</a> virtual address management feature is disabled, and not thread-safe if the feature is enabled. </p>

</div>
</div>
<a id="a1196844b494e896ea391df672050776b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1196844b494e896ea391df672050776b">&#9670;&nbsp;</a></span>WalkAllocatedBlocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::mem::StandardAllocator::WalkAllocatedBlocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a95dd2800aef14ef0508282fd508fedcb">WalkCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls a callback function for allocated memory regions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback function called for each memory region. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userPtr</td><td>Pointer passed to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The allocator is initialized. </dd>
<dd>
If <code>true</code> was specified for <code><em>isCacheEnable</em></code> when <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#acdb0dd01602811a4f469c87c348d3ed1" title="Initializes the specified memory region to be managed by StandardAllocator.">Initialize()</a></code> was called and writing of data to the allocated memory space takes place inside the callback function, you must call this function right after calling <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a2b942ec23f715b66f82c02150727fa08" title="Frees the cached free space for specific threads so that it is available for all threads.">ClearThreadCache()</a></code> in every thread.</dd></dl>
<p> <b>Details</b> <br  />
 Calls a callback function for all allocated memory regions.<br  />
<br  />
 If <code>true</code> was specified for <code><em>isCacheEnable</em></code> when <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#acdb0dd01602811a4f469c87c348d3ed1" title="Initializes the specified memory region to be managed by StandardAllocator.">Initialize()</a></code> was called and the memory cache feature is enabled in every thread, this function also calls the callback function for those cache regions.<br  />
 For this reason, if you will be writing to memory regions allocated using this function, make sure that you call this function right after calling <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a2b942ec23f715b66f82c02150727fa08" title="Frees the cached free space for specific threads so that it is available for all threads.">ClearThreadCache()</a></code> in all threads.<br  />
<br  />
 This function is thread-safe. </p>

</div>
</div>
<a id="a644b9a162b9b8bf22a3e429966e53c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644b9a162b9b8bf22a3e429966e53c9f">&#9670;&nbsp;</a></span>Dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::mem::StandardAllocator::Dump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays the information in the allocator. </p>
<p> <b>Details</b> <br  />
 Returns the internal state of the allocator.<br  />
<br  />
 For more information about the output format, see <a href="../../Package/contents/Pages/Page_89102552.html">StandardAllocator</a> in the <code>mem</code> library manual in NintendoSDK Documents. </p>

</div>
</div>
<a id="af6de9d17a7aaa6f54e95a3125a96dbda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6de9d17a7aaa6f54e95a3125a96dbda">&#9670;&nbsp;</a></span>Hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1mem_1_1_standard_allocator_1_1_allocator_hash.html">AllocatorHash</a> nn::mem::StandardAllocator::Hash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a hash based on information in the allocator. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the internal state of the allocator.</dd></dl>
<p> <b>Details</b> <br  />
 Gets the internal state of the allocator. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
