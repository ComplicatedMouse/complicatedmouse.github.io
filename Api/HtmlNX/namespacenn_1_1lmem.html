<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nn::lmem Namespace Reference | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenn.html">nn</a></li><li class="navelem"><a class="el" href="namespacenn_1_1lmem.html">lmem</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">nn::lmem Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A dynamic memory allocation library namespace with the same type of features as those found in the Cafe and CTR SDKs.  
<a href="namespacenn_1_1lmem.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1lmem_1_1_frame_heap_state.html">FrameHeapState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that saves the state of the frame heap.  <a href="structnn_1_1lmem_1_1_frame_heap_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1lmem_1_1_memory_range.html">MemoryRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that indicates a range of memory.  <a href="structnn_1_1lmem_1_1_memory_range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a26608eb2d71f7595fca7793432c30f6f"><td class="memItemLeft" align="right" valign="top">typedef detail::HeapHead&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a26608eb2d71f7595fca7793432c30f6f">HeapCommonHead</a></td></tr>
<tr class="memdesc:a26608eb2d71f7595fca7793432c30f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The heap common header.  <a href="namespacenn_1_1lmem.html#a26608eb2d71f7595fca7793432c30f6f">More...</a><br /></td></tr>
<tr class="separator:a26608eb2d71f7595fca7793432c30f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab893a05f9834a881447ea604c7d60400"><td class="memItemLeft" align="right" valign="top">typedef struct detail::HeapHead *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a></td></tr>
<tr class="memdesc:ab893a05f9834a881447ea604c7d60400"><td class="mdescLeft">&#160;</td><td class="mdescRight">The heap common handle.  <a href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">More...</a><br /></td></tr>
<tr class="separator:ab893a05f9834a881447ea604c7d60400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f98df324bfdc3ff6e67337aa06232ef"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a0f98df324bfdc3ff6e67337aa06232ef">HeapVisitor</a>) (void *pBlock, <a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, uintptr_t userParam)</td></tr>
<tr class="memdesc:a0f98df324bfdc3ff6e67337aa06232ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the callback function that is called when cycling through memory blocks.  <a href="namespacenn_1_1lmem.html#a0f98df324bfdc3ff6e67337aa06232ef">More...</a><br /></td></tr>
<tr class="separator:a0f98df324bfdc3ff6e67337aa06232ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a18e9eac338e3880aeee1459519b00886"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a18e9eac338e3880aeee1459519b00886">AdjustMode</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a18e9eac338e3880aeee1459519b00886a5c25952febdf7156503bf7dd70f1e703">AdjustMode_Tail</a> = 1
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a18e9eac338e3880aeee1459519b00886a5c7383dad293f4b1c10380b8a41f59d1">AdjustMode_Head</a> = -1
<br />
 }</td></tr>
<tr class="memdesc:a18e9eac338e3880aeee1459519b00886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant representing the ways to shrink heap memory regions.  <a href="namespacenn_1_1lmem.html#a18e9eac338e3880aeee1459519b00886">More...</a><br /></td></tr>
<tr class="separator:a18e9eac338e3880aeee1459519b00886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4302ad21b1a099adf611aa15400cd06b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a4302ad21b1a099adf611aa15400cd06b">AllocationDirection</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a4302ad21b1a099adf611aa15400cd06ba7f33d3263e63f24f45a768189a9ee8e9">AllocationDirection_Front</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a4302ad21b1a099adf611aa15400cd06babe4b1359d27860a53a1ad5e1b3b628c8">AllocationDirection_Rear</a> = 1
<br />
 }</td></tr>
<tr class="memdesc:a4302ad21b1a099adf611aa15400cd06b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant used to specify the direction of memory block allocation.  <a href="namespacenn_1_1lmem.html#a4302ad21b1a099adf611aa15400cd06b">More...</a><br /></td></tr>
<tr class="separator:a4302ad21b1a099adf611aa15400cd06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7319ff4369a7278582dd53a1129f73"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a4a7319ff4369a7278582dd53a1129f73">AllocationMode</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a4a7319ff4369a7278582dd53a1129f73a101b6b812bb866cd80f042ef3ff95168">AllocationMode_FirstFit</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a4a7319ff4369a7278582dd53a1129f73ae6e6a0e6cddfc1146e912f4017c1c161">AllocationMode_BestFit</a> = 1
<br />
 }</td></tr>
<tr class="memdesc:a4a7319ff4369a7278582dd53a1129f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mode in which memory blocks are allocated.  <a href="namespacenn_1_1lmem.html#a4a7319ff4369a7278582dd53a1129f73">More...</a><br /></td></tr>
<tr class="separator:a4a7319ff4369a7278582dd53a1129f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5200a4ef197dbd700f31a3111eacf5b2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a5200a4ef197dbd700f31a3111eacf5b2">CreationOption</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a5200a4ef197dbd700f31a3111eacf5b2a30c3b2cd8b36e40049c5c88b7c47a45f">CreationOption_NoOption</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a5200a4ef197dbd700f31a3111eacf5b2a00853f3b9861cc1c8c36508a2d4c8b4a">CreationOption_ZeroClear</a> = (1 &lt;&lt; 0)
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a5200a4ef197dbd700f31a3111eacf5b2a74d1c66b53b6339b870393957e6d1a83">CreationOption_DebugFill</a> = (1 &lt;&lt; 1)
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a5200a4ef197dbd700f31a3111eacf5b2a59bbf55542967a55d01a7257c1131735">CreationOption_ThreadSafe</a> = (1 &lt;&lt; 2)
<br />
 }</td></tr>
<tr class="memdesc:a5200a4ef197dbd700f31a3111eacf5b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant that represents the option when creating the heap.  <a href="namespacenn_1_1lmem.html#a5200a4ef197dbd700f31a3111eacf5b2">More...</a><br /></td></tr>
<tr class="separator:a5200a4ef197dbd700f31a3111eacf5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3db4663e81681986f86c9cd7cb4cae9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#ab3db4663e81681986f86c9cd7cb4cae9">ErrorOption</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#ab3db4663e81681986f86c9cd7cb4cae9aa196d3e16ed8b40056ee88759da8c581">ErrorOption_NoOption</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#ab3db4663e81681986f86c9cd7cb4cae9ad3c0eafafaf1f86fe048b63e495b5ada">ErrorOption_Print</a> = (1 &lt;&lt; 0)
<br />
 }</td></tr>
<tr class="memdesc:ab3db4663e81681986f86c9cd7cb4cae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant that represents the option specific to errors.  <a href="namespacenn_1_1lmem.html#ab3db4663e81681986f86c9cd7cb4cae9">More...</a><br /></td></tr>
<tr class="separator:ab3db4663e81681986f86c9cd7cb4cae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4483dceb5521988f7c9afb0e32da8d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a9e4483dceb5521988f7c9afb0e32da8d">FillType</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a9e4483dceb5521988f7c9afb0e32da8dabf82da361e5cf28b646fb212d043d675">FillType_Unallocated</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a9e4483dceb5521988f7c9afb0e32da8da530964fed21e85308d519e88654526bc">FillType_Allocate</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a9e4483dceb5521988f7c9afb0e32da8da8bf8579aec1f8bef0015b939eca65c6a">FillType_Free</a>
, <br />
&#160;&#160;<b>FillType_Max</b>
<br />
 }</td></tr>
<tr class="memdesc:a9e4483dceb5521988f7c9afb0e32da8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant representing the types of ways to fill the heap.  <a href="namespacenn_1_1lmem.html#a9e4483dceb5521988f7c9afb0e32da8d">More...</a><br /></td></tr>
<tr class="separator:a9e4483dceb5521988f7c9afb0e32da8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d378823d086c69e88ee7465eb246b3f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a0d378823d086c69e88ee7465eb246b3f">FreeMode</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a0d378823d086c69e88ee7465eb246b3fa30222a68322eef67b45eb8274a9696a8">FreeMode_Front</a> = (1 &lt;&lt; 0)
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a0d378823d086c69e88ee7465eb246b3fa75d4886d4d122c1c366f8351404a91fd">FreeMode_Rear</a> = (1 &lt;&lt; 1)
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a0d378823d086c69e88ee7465eb246b3faeb0b94c8ebeb50ebe978d075b8bdcf2b">FreeMode_All</a> = (FreeMode_Front | FreeMode_Rear)
<br />
 }</td></tr>
<tr class="memdesc:a0d378823d086c69e88ee7465eb246b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant used to specify the method of memory block freeing.  <a href="namespacenn_1_1lmem.html#a0d378823d086c69e88ee7465eb246b3f">More...</a><br /></td></tr>
<tr class="separator:a0d378823d086c69e88ee7465eb246b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1164e3a948696645a06c70e009f8c2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#abd1164e3a948696645a06c70e009f8c2">InfoPlacement</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#abd1164e3a948696645a06c70e009f8c2ace7eca4a020808cce9d41929c2776f92">InfoPlacement_Head</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#abd1164e3a948696645a06c70e009f8c2a0443b9a0d25f781bb734f60972c021db">InfoPlacement_Tail</a>
<br />
 }</td></tr>
<tr class="memdesc:abd1164e3a948696645a06c70e009f8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constant that determines the location for the placement of the heap common header (the heap management region).  <a href="namespacenn_1_1lmem.html#abd1164e3a948696645a06c70e009f8c2">More...</a><br /></td></tr>
<tr class="separator:abd1164e3a948696645a06c70e009f8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Heap Common API Resources</div></td></tr>
<tr class="memitem:aacdf9e8d0b3673ee2041a93353f4b3cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#aacdf9e8d0b3673ee2041a93353f4b3cb">SetFillValue</a> (<a class="el" href="namespacenn_1_1lmem.html#a9e4483dceb5521988f7c9afb0e32da8d">FillType</a> type, Bit32 value) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aacdf9e8d0b3673ee2041a93353f4b3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value for the fill for each type used to fill the heap.  <a href="namespacenn_1_1lmem.html#aacdf9e8d0b3673ee2041a93353f4b3cb">More...</a><br /></td></tr>
<tr class="separator:aacdf9e8d0b3673ee2041a93353f4b3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af868f872b74bcd1bf22d414f7f31af5e"><td class="memItemLeft" align="right" valign="top">Bit32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#af868f872b74bcd1bf22d414f7f31af5e">GetFillValue</a> (const <a class="el" href="namespacenn_1_1lmem.html#a9e4483dceb5521988f7c9afb0e32da8d">FillType</a> type) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af868f872b74bcd1bf22d414f7f31af5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value used to fill the heap.  <a href="namespacenn_1_1lmem.html#af868f872b74bcd1bf22d414f7f31af5e">More...</a><br /></td></tr>
<tr class="separator:af868f872b74bcd1bf22d414f7f31af5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e599544385b8f298f4a6303fd7d5d67"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a2e599544385b8f298f4a6303fd7d5d67">GetTotalSize</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2e599544385b8f298f4a6303fd7d5d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the memory region used by the heap.  <a href="namespacenn_1_1lmem.html#a2e599544385b8f298f4a6303fd7d5d67">More...</a><br /></td></tr>
<tr class="separator:a2e599544385b8f298f4a6303fd7d5d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64dd4f95c8fc55068b221d18fc1ffe4b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a64dd4f95c8fc55068b221d18fc1ffe4b">GetStartAddress</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a64dd4f95c8fc55068b221d18fc1ffe4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the starting address of the memory region used by the heap.  <a href="namespacenn_1_1lmem.html#a64dd4f95c8fc55068b221d18fc1ffe4b">More...</a><br /></td></tr>
<tr class="separator:a64dd4f95c8fc55068b221d18fc1ffe4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8cf0f54fa6ba157762657ef1f6e103"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a4f8cf0f54fa6ba157762657ef1f6e103">HasAddress</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, void *address) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4f8cf0f54fa6ba157762657ef1f6e103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified address is located within a heap.  <a href="namespacenn_1_1lmem.html#a4f8cf0f54fa6ba157762657ef1f6e103">More...</a><br /></td></tr>
<tr class="separator:a4f8cf0f54fa6ba157762657ef1f6e103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Expanded Heap: Heap Region Operation API Resources</div></td></tr>
<tr class="memitem:a3d46d370c3b53aed4a127962761ed0fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc">CreateExpHeap</a> (void *startAddress, size_t size, int option) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3d46d370c3b53aed4a127962761ed0fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an expanded heap.  <a href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc">More...</a><br /></td></tr>
<tr class="separator:a3d46d370c3b53aed4a127962761ed0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f5ea9ad1df5559ac024fee0564744a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#af8f5ea9ad1df5559ac024fee0564744a">DestroyExpHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af8f5ea9ad1df5559ac024fee0564744a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the expanded heap.  <a href="namespacenn_1_1lmem.html#af8f5ea9ad1df5559ac024fee0564744a">More...</a><br /></td></tr>
<tr class="separator:af8f5ea9ad1df5559ac024fee0564744a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b21c96cee5ec4ae3bb5048fdb483666"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1lmem_1_1_memory_range.html">MemoryRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a3b21c96cee5ec4ae3bb5048fdb483666">AdjustExpHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3b21c96cee5ec4ae3bb5048fdb483666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the empty region of the heap from the back end, reducing the amount of memory used.  <a href="namespacenn_1_1lmem.html#a3b21c96cee5ec4ae3bb5048fdb483666">More...</a><br /></td></tr>
<tr class="separator:a3b21c96cee5ec4ae3bb5048fdb483666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Expanded Heap: Memory Block Operation API Resources</div></td></tr>
<tr class="memitem:a96055cfc77bfd3eac47da134a3746aa9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a96055cfc77bfd3eac47da134a3746aa9">AllocateFromExpHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a96055cfc77bfd3eac47da134a3746aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a memory region.  <a href="namespacenn_1_1lmem.html#a96055cfc77bfd3eac47da134a3746aa9">More...</a><br /></td></tr>
<tr class="separator:a96055cfc77bfd3eac47da134a3746aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c4062e0fa7e47cc9a604681317525a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a64c4062e0fa7e47cc9a604681317525a">AllocateFromExpHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, size_t size, int alignment) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a64c4062e0fa7e47cc9a604681317525a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a memory region of the specified alignment.  <a href="namespacenn_1_1lmem.html#a64c4062e0fa7e47cc9a604681317525a">More...</a><br /></td></tr>
<tr class="separator:a64c4062e0fa7e47cc9a604681317525a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b756491ff15ef5937719943d7146a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#aa8b756491ff15ef5937719943d7146a5">FreeToExpHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, void *pBlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa8b756491ff15ef5937719943d7146a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a memory region.  <a href="namespacenn_1_1lmem.html#aa8b756491ff15ef5937719943d7146a5">More...</a><br /></td></tr>
<tr class="separator:aa8b756491ff15ef5937719943d7146a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacfd64bdeac5be2b33f2f5f79656379"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#adacfd64bdeac5be2b33f2f5f79656379">ResizeExpHeapBlock</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, void *pBlock, size_t newSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:adacfd64bdeac5be2b33f2f5f79656379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the size of a memory block that was allocated from the extended heap.  <a href="namespacenn_1_1lmem.html#adacfd64bdeac5be2b33f2f5f79656379">More...</a><br /></td></tr>
<tr class="separator:adacfd64bdeac5be2b33f2f5f79656379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Expanded Heap: API Resources for Setting and Getting Heap Information</div></td></tr>
<tr class="memitem:aaecc883dba00f234bd0d3e123d1365d2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#aaecc883dba00f234bd0d3e123d1365d2">GetExpHeapTotalFreeSize</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aaecc883dba00f234bd0d3e123d1365d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the free memory size.  <a href="namespacenn_1_1lmem.html#aaecc883dba00f234bd0d3e123d1365d2">More...</a><br /></td></tr>
<tr class="separator:aaecc883dba00f234bd0d3e123d1365d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a9bfe39ef9ba8ac6500bcd39defde8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a65a9bfe39ef9ba8ac6500bcd39defde8">GetExpHeapAllocatableSize</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, int alignment) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a65a9bfe39ef9ba8ac6500bcd39defde8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the memory block that can be allocated.  <a href="namespacenn_1_1lmem.html#a65a9bfe39ef9ba8ac6500bcd39defde8">More...</a><br /></td></tr>
<tr class="separator:a65a9bfe39ef9ba8ac6500bcd39defde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0215a6fd274ee1b7f82356aca8ff4ac7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a0215a6fd274ee1b7f82356aca8ff4ac7">SetExpHeapAllocationMode</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, <a class="el" href="namespacenn_1_1lmem.html#a4a7319ff4369a7278582dd53a1129f73">AllocationMode</a> allocationMode) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0215a6fd274ee1b7f82356aca8ff4ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the mode to use for memory allocation.  <a href="namespacenn_1_1lmem.html#a0215a6fd274ee1b7f82356aca8ff4ac7">More...</a><br /></td></tr>
<tr class="separator:a0215a6fd274ee1b7f82356aca8ff4ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7958c3154e912e2f1d4df040a03dccb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1lmem.html#a4a7319ff4369a7278582dd53a1129f73">AllocationMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a7958c3154e912e2f1d4df040a03dccb7">GetExpHeapAllocationMode</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7958c3154e912e2f1d4df040a03dccb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the mode to use for memory allocation.  <a href="namespacenn_1_1lmem.html#a7958c3154e912e2f1d4df040a03dccb7">More...</a><br /></td></tr>
<tr class="separator:a7958c3154e912e2f1d4df040a03dccb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a7f1f27f38901e2dcedd42ca0ab2ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a48a7f1f27f38901e2dcedd42ca0ab2ab">SetExpHeapUseMarginOfAlignment</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, bool reuse) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a48a7f1f27f38901e2dcedd42ca0ab2ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether to reuse fragmented space caused by alignment when allocating memory.  <a href="namespacenn_1_1lmem.html#a48a7f1f27f38901e2dcedd42ca0ab2ab">More...</a><br /></td></tr>
<tr class="separator:a48a7f1f27f38901e2dcedd42ca0ab2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b29bb41e1795da84b1f8ec5544a594a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a6b29bb41e1795da84b1f8ec5544a594a">GetExpHeapUseMarginOfAlignment</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6b29bb41e1795da84b1f8ec5544a594a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether to reuse fragmented space caused by alignment when allocating memory.  <a href="namespacenn_1_1lmem.html#a6b29bb41e1795da84b1f8ec5544a594a">More...</a><br /></td></tr>
<tr class="separator:a6b29bb41e1795da84b1f8ec5544a594a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5de7bf254d6a4182e9c4070a94e1b9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#ab5de7bf254d6a4182e9c4070a94e1b9c">SetExpHeapGroupId</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, Bit16 groupId) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab5de7bf254d6a4182e9c4070a94e1b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the group ID used during memory allocation.  <a href="namespacenn_1_1lmem.html#ab5de7bf254d6a4182e9c4070a94e1b9c">More...</a><br /></td></tr>
<tr class="separator:ab5de7bf254d6a4182e9c4070a94e1b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd47c4651a7f6385ba616a076d0a1457"><td class="memItemLeft" align="right" valign="top">Bit16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#afd47c4651a7f6385ba616a076d0a1457">GetExpHeapGroupId</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:afd47c4651a7f6385ba616a076d0a1457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the group ID.  <a href="namespacenn_1_1lmem.html#afd47c4651a7f6385ba616a076d0a1457">More...</a><br /></td></tr>
<tr class="separator:afd47c4651a7f6385ba616a076d0a1457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c92d4f94738d803197c67a268c1705"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#aa4c92d4f94738d803197c67a268c1705">GetExpHeapBlockSize</a> (const void *pBlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa4c92d4f94738d803197c67a268c1705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of an allocated memory block.  <a href="namespacenn_1_1lmem.html#aa4c92d4f94738d803197c67a268c1705">More...</a><br /></td></tr>
<tr class="separator:aa4c92d4f94738d803197c67a268c1705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb1220e2063a1660e5e1c1ca8f87d94"><td class="memItemLeft" align="right" valign="top">Bit16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a3fb1220e2063a1660e5e1c1ca8f87d94">GetExpHeapGroupIdOfBlock</a> (const void *pBlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3fb1220e2063a1660e5e1c1ca8f87d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the group ID of an allocated memory block.  <a href="namespacenn_1_1lmem.html#a3fb1220e2063a1660e5e1c1ca8f87d94">More...</a><br /></td></tr>
<tr class="separator:a3fb1220e2063a1660e5e1c1ca8f87d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7e706930f05cd5e4e17f2eb2f30ade"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1lmem.html#a4302ad21b1a099adf611aa15400cd06b">AllocationDirection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a8f7e706930f05cd5e4e17f2eb2f30ade">GetExpHeapAllocationDirectionOfBlock</a> (const void *pBlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8f7e706930f05cd5e4e17f2eb2f30ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the direction in which a memory block was allocated.  <a href="namespacenn_1_1lmem.html#a8f7e706930f05cd5e4e17f2eb2f30ade">More...</a><br /></td></tr>
<tr class="separator:a8f7e706930f05cd5e4e17f2eb2f30ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Expanded Heap: API Resources For Debugging</div></td></tr>
<tr class="memitem:a04838ca06b67385b6eb99e63684444a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a04838ca06b67385b6eb99e63684444a9">CheckExpHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, int option) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a04838ca06b67385b6eb99e63684444a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the extended heap has been destroyed.  <a href="namespacenn_1_1lmem.html#a04838ca06b67385b6eb99e63684444a9">More...</a><br /></td></tr>
<tr class="separator:a04838ca06b67385b6eb99e63684444a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761bf1d98698d5fd19019e748f4d0ecf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a761bf1d98698d5fd19019e748f4d0ecf">CheckExpHeapBlock</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, const void *pBlock, int option) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a761bf1d98698d5fd19019e748f4d0ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks memory blocks that have been allocated from the extended heap.  <a href="namespacenn_1_1lmem.html#a761bf1d98698d5fd19019e748f4d0ecf">More...</a><br /></td></tr>
<tr class="separator:a761bf1d98698d5fd19019e748f4d0ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59c5a804990cae8619eab581b693ace"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#ae59c5a804990cae8619eab581b693ace">VisitExpHeapAllBlocks</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, <a class="el" href="namespacenn_1_1lmem.html#a0f98df324bfdc3ff6e67337aa06232ef">HeapVisitor</a> visitor, uintptr_t userParam) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae59c5a804990cae8619eab581b693ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a user-specified <code>visitor</code> function on all memory blocks that have been allocated.  <a href="namespacenn_1_1lmem.html#ae59c5a804990cae8619eab581b693ace">More...</a><br /></td></tr>
<tr class="separator:ae59c5a804990cae8619eab581b693ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba05f8df1e914f5748889a52daf7ec7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a3ba05f8df1e914f5748889a52daf7ec7">DumpExpHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3ba05f8df1e914f5748889a52daf7ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays the information in the expanded heap.  <a href="namespacenn_1_1lmem.html#a3ba05f8df1e914f5748889a52daf7ec7">More...</a><br /></td></tr>
<tr class="separator:a3ba05f8df1e914f5748889a52daf7ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Frame Heap: Heap Region Operation API Resources</div></td></tr>
<tr class="memitem:a90727fbcf266c220ae9409106a467a49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49">CreateFrameHeap</a> (void *startAddress, size_t size, int option) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a90727fbcf266c220ae9409106a467a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a frame heap.  <a href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49">More...</a><br /></td></tr>
<tr class="separator:a90727fbcf266c220ae9409106a467a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd38b1a1f739530aa18143e8d7dfc4ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#acd38b1a1f739530aa18143e8d7dfc4ee">CreateFrameHeap</a> (void *startAddress, size_t size, int option, <a class="el" href="namespacenn_1_1lmem.html#a26608eb2d71f7595fca7793432c30f6f">HeapCommonHead</a> *pHeapHead) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acd38b1a1f739530aa18143e8d7dfc4ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a frame heap.  <a href="namespacenn_1_1lmem.html#acd38b1a1f739530aa18143e8d7dfc4ee">More...</a><br /></td></tr>
<tr class="separator:acd38b1a1f739530aa18143e8d7dfc4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcec58c14f1288a97cc8853c65215ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a5fcec58c14f1288a97cc8853c65215ad">DestroyFrameHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5fcec58c14f1288a97cc8853c65215ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a frame heap.  <a href="namespacenn_1_1lmem.html#a5fcec58c14f1288a97cc8853c65215ad">More...</a><br /></td></tr>
<tr class="separator:a5fcec58c14f1288a97cc8853c65215ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2530fa487300d192b1d7ed6ed33d1a4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1lmem_1_1_memory_range.html">MemoryRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a2530fa487300d192b1d7ed6ed33d1a4a">AdjustFrameHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, <a class="el" href="namespacenn_1_1lmem.html#a18e9eac338e3880aeee1459519b00886">AdjustMode</a> adjustMode) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2530fa487300d192b1d7ed6ed33d1a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the empty region of the heap, reducing the amount of memory used.  <a href="namespacenn_1_1lmem.html#a2530fa487300d192b1d7ed6ed33d1a4a">More...</a><br /></td></tr>
<tr class="separator:a2530fa487300d192b1d7ed6ed33d1a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Frame Heap: Memory Block Operation API Resources</div></td></tr>
<tr class="memitem:a7c6889dbc9c14c96fdc10f89b69a3c96"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a7c6889dbc9c14c96fdc10f89b69a3c96">AllocateFromFrameHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7c6889dbc9c14c96fdc10f89b69a3c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a memory region.  <a href="namespacenn_1_1lmem.html#a7c6889dbc9c14c96fdc10f89b69a3c96">More...</a><br /></td></tr>
<tr class="separator:a7c6889dbc9c14c96fdc10f89b69a3c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490bafe2b4b3cbbae2990949be3824d5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a490bafe2b4b3cbbae2990949be3824d5">AllocateFromFrameHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, size_t size, int alignment) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a490bafe2b4b3cbbae2990949be3824d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a memory region of the specified alignment.  <a href="namespacenn_1_1lmem.html#a490bafe2b4b3cbbae2990949be3824d5">More...</a><br /></td></tr>
<tr class="separator:a490bafe2b4b3cbbae2990949be3824d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7c2693342c1151c427651a6323969a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a2c7c2693342c1151c427651a6323969a">FreeToFrameHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, <a class="el" href="namespacenn_1_1lmem.html#a0d378823d086c69e88ee7465eb246b3f">FreeMode</a> mode) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2c7c2693342c1151c427651a6323969a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a memory region.  <a href="namespacenn_1_1lmem.html#a2c7c2693342c1151c427651a6323969a">More...</a><br /></td></tr>
<tr class="separator:a2c7c2693342c1151c427651a6323969a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6f50b6ef046e66428d0c4978a2e3d4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a4c6f50b6ef046e66428d0c4978a2e3d4">ResizeFrameHeapBlock</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, void *pBlock, size_t newSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4c6f50b6ef046e66428d0c4978a2e3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the memory block that was most recently allocated from the frame heap.  <a href="namespacenn_1_1lmem.html#a4c6f50b6ef046e66428d0c4978a2e3d4">More...</a><br /></td></tr>
<tr class="separator:a4c6f50b6ef046e66428d0c4978a2e3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Frame Heap: API Resources for Setting and Getting Heap Information</div></td></tr>
<tr class="memitem:abf40e7cffb9c7527baa746570b6de07e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#abf40e7cffb9c7527baa746570b6de07e">GetFrameHeapAllocatableSize</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, int alignment) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:abf40e7cffb9c7527baa746570b6de07e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the memory block that can be allocated.  <a href="namespacenn_1_1lmem.html#abf40e7cffb9c7527baa746570b6de07e">More...</a><br /></td></tr>
<tr class="separator:abf40e7cffb9c7527baa746570b6de07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd347d006c6676ca3c2c652b56b5540a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1lmem_1_1_frame_heap_state.html">FrameHeapState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#abd347d006c6676ca3c2c652b56b5540a">GetFrameHeapState</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:abd347d006c6676ca3c2c652b56b5540a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the state of the frame heap.  <a href="namespacenn_1_1lmem.html#abd347d006c6676ca3c2c652b56b5540a">More...</a><br /></td></tr>
<tr class="separator:abd347d006c6676ca3c2c652b56b5540a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb70197d0fac93ff1c51605de577c0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#acdb70197d0fac93ff1c51605de577c0e">RestoreFrameHeapState</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, const <a class="el" href="structnn_1_1lmem_1_1_frame_heap_state.html">FrameHeapState</a> &amp;state) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acdb70197d0fac93ff1c51605de577c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores the state of the frame heap.  <a href="namespacenn_1_1lmem.html#acdb70197d0fac93ff1c51605de577c0e">More...</a><br /></td></tr>
<tr class="separator:acdb70197d0fac93ff1c51605de577c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Frame Heap: API Resources For Debugging</div></td></tr>
<tr class="memitem:adb56e12364c2c984f7e41fd745b5251e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#adb56e12364c2c984f7e41fd745b5251e">DumpFrameHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:adb56e12364c2c984f7e41fd745b5251e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays the information in the frame heap.  <a href="namespacenn_1_1lmem.html#adb56e12364c2c984f7e41fd745b5251e">More...</a><br /></td></tr>
<tr class="separator:adb56e12364c2c984f7e41fd745b5251e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Unit Heap: Heap Region Operation API Resources</div></td></tr>
<tr class="memitem:a7d3359350e669a5fcc493ce5df5d010c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a7d3359350e669a5fcc493ce5df5d010c">CreateUnitHeap</a> (void *startAddress, size_t size, size_t unitSize, int option) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7d3359350e669a5fcc493ce5df5d010c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a unit heap.  <a href="namespacenn_1_1lmem.html#a7d3359350e669a5fcc493ce5df5d010c">More...</a><br /></td></tr>
<tr class="separator:a7d3359350e669a5fcc493ce5df5d010c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e408afe1b891b1827d340897319386"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a37e408afe1b891b1827d340897319386">CreateUnitHeap</a> (void *startAddress, size_t size, size_t unitSize, int option, int alignment, <a class="el" href="namespacenn_1_1lmem.html#abd1164e3a948696645a06c70e009f8c2">InfoPlacement</a> placement) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a37e408afe1b891b1827d340897319386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a unit heap.  <a href="namespacenn_1_1lmem.html#a37e408afe1b891b1827d340897319386">More...</a><br /></td></tr>
<tr class="separator:a37e408afe1b891b1827d340897319386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a0b4af7e50ed9ce91b68df40225bdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a48a0b4af7e50ed9ce91b68df40225bdf">CreateUnitHeap</a> (void *startAddress, size_t size, size_t unitSize, int option, int alignment, <a class="el" href="namespacenn_1_1lmem.html#a26608eb2d71f7595fca7793432c30f6f">HeapCommonHead</a> *pHeapHead) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a48a0b4af7e50ed9ce91b68df40225bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a unit heap.  <a href="namespacenn_1_1lmem.html#a48a0b4af7e50ed9ce91b68df40225bdf">More...</a><br /></td></tr>
<tr class="separator:a48a0b4af7e50ed9ce91b68df40225bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e9905bd641416421fb108f487b5d4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a03e9905bd641416421fb108f487b5d4f">DestroyUnitHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a03e9905bd641416421fb108f487b5d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a unit heap.  <a href="namespacenn_1_1lmem.html#a03e9905bd641416421fb108f487b5d4f">More...</a><br /></td></tr>
<tr class="separator:a03e9905bd641416421fb108f487b5d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca8ffeb524244ca4f9968d116817257"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a4ca8ffeb524244ca4f9968d116817257">InvalidateUnitHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4ca8ffeb524244ca4f9968d116817257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates the heap.  <a href="namespacenn_1_1lmem.html#a4ca8ffeb524244ca4f9968d116817257">More...</a><br /></td></tr>
<tr class="separator:a4ca8ffeb524244ca4f9968d116817257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64765b319b7e98292e4ce5f70dbce73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#ac64765b319b7e98292e4ce5f70dbce73">ExtendUnitHeapArea</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac64765b319b7e98292e4ce5f70dbce73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends the region passed as a heap.  <a href="namespacenn_1_1lmem.html#ac64765b319b7e98292e4ce5f70dbce73">More...</a><br /></td></tr>
<tr class="separator:ac64765b319b7e98292e4ce5f70dbce73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Unit Heap: Memory Block Operation API Resources</div></td></tr>
<tr class="memitem:a1d1eec8ea87ca5a847eae04fb21c7a36"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a1d1eec8ea87ca5a847eae04fb21c7a36">AllocateFromUnitHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1d1eec8ea87ca5a847eae04fb21c7a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a memory region.  <a href="namespacenn_1_1lmem.html#a1d1eec8ea87ca5a847eae04fb21c7a36">More...</a><br /></td></tr>
<tr class="separator:a1d1eec8ea87ca5a847eae04fb21c7a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab190d0a00216c4d8cd2e3134680d3a45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#ab190d0a00216c4d8cd2e3134680d3a45">FreeToUnitHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, void *pBlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab190d0a00216c4d8cd2e3134680d3a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a memory region.  <a href="namespacenn_1_1lmem.html#ab190d0a00216c4d8cd2e3134680d3a45">More...</a><br /></td></tr>
<tr class="separator:ab190d0a00216c4d8cd2e3134680d3a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Unit Heap: API Resources for Setting and Getting Heap Information</div></td></tr>
<tr class="memitem:a4f73af475a54358322fe7b3c8bf78ef6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a4f73af475a54358322fe7b3c8bf78ef6">GetUnitHeapUnitSize</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4f73af475a54358322fe7b3c8bf78ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the unit size of the unit heap.  <a href="namespacenn_1_1lmem.html#a4f73af475a54358322fe7b3c8bf78ef6">More...</a><br /></td></tr>
<tr class="separator:a4f73af475a54358322fe7b3c8bf78ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2b6be8b9c2077fec92fb19c5e8aeb1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#abe2b6be8b9c2077fec92fb19c5e8aeb1">GetUnitHeapAllocatableCount</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:abe2b6be8b9c2077fec92fb19c5e8aeb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of blank units.  <a href="namespacenn_1_1lmem.html#abe2b6be8b9c2077fec92fb19c5e8aeb1">More...</a><br /></td></tr>
<tr class="separator:abe2b6be8b9c2077fec92fb19c5e8aeb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1ae99b4baab79444c503a383345154"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#aaa1ae99b4baab79444c503a383345154">GetUnitHeapAllocatedCount</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aaa1ae99b4baab79444c503a383345154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of units that are currently being allocated from this heap.  <a href="namespacenn_1_1lmem.html#aaa1ae99b4baab79444c503a383345154">More...</a><br /></td></tr>
<tr class="separator:aaa1ae99b4baab79444c503a383345154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a08003a1b715eded61e040c3cd087a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a8a08003a1b715eded61e040c3cd087a9">GetUnitHeapAlignment</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8a08003a1b715eded61e040c3cd087a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the unit alignment.  <a href="namespacenn_1_1lmem.html#a8a08003a1b715eded61e040c3cd087a9">More...</a><br /></td></tr>
<tr class="separator:a8a08003a1b715eded61e040c3cd087a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac10912318a3d5f45687fa1885c89be"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a8ac10912318a3d5f45687fa1885c89be">GetRequiredUnitHeapSize</a> (size_t unitSize, int unitNum, int alignment, bool hasHeadInternally) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8ac10912318a3d5f45687fa1885c89be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the minimum size of heap memory required to manage the specified number of blocks of the specified unit size and alignment.  <a href="namespacenn_1_1lmem.html#a8ac10912318a3d5f45687fa1885c89be">More...</a><br /></td></tr>
<tr class="separator:a8ac10912318a3d5f45687fa1885c89be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Unit Heap: API Resources For Debugging</div></td></tr>
<tr class="memitem:a1deefa949a2c36e348db0fe808cad2de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a1deefa949a2c36e348db0fe808cad2de">DumpUnitHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1deefa949a2c36e348db0fe808cad2de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays the information in the unit heap.  <a href="namespacenn_1_1lmem.html#a1deefa949a2c36e348db0fe808cad2de">More...</a><br /></td></tr>
<tr class="separator:a1deefa949a2c36e348db0fe808cad2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a9b73760b843761bad7afb25be502c4b0"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a9b73760b843761bad7afb25be502c4b0">DefaultAlignment</a> = 8</td></tr>
<tr class="memdesc:a9b73760b843761bad7afb25be502c4b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default alignment occurs for memory allocation.  <a href="namespacenn_1_1lmem.html#a9b73760b843761bad7afb25be502c4b0">More...</a><br /></td></tr>
<tr class="separator:a9b73760b843761bad7afb25be502c4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A dynamic memory allocation library namespace with the same type of features as those found in the Cafe and CTR SDKs. </p>
<p> <b>Details</b> <br  />
 This namespace is available for heaps with the same features as those found in the Cafe and CTR SDKs.<br  />
 Newly available heaps not found in either the Cafe or the CTR SDK are placed in the <code><a class="el" href="namespacenn_1_1mem.html" title="Namespace of the dynamic memory allocation library for fast allocation and deallocation.">nn::mem</a></code> namespace. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ab893a05f9834a881447ea604c7d60400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab893a05f9834a881447ea604c7d60400">&#9670;&nbsp;</a></span>HeapHandle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct detail::HeapHead* <a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">nn::lmem::HeapHandle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The heap common handle. </p>
<p> <b>Details</b> <br  />
 Type to represent the heap handle. </p>

</div>
</div>
<a id="a26608eb2d71f7595fca7793432c30f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26608eb2d71f7595fca7793432c30f6f">&#9670;&nbsp;</a></span>HeapCommonHead</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef detail::HeapHead <a class="el" href="namespacenn_1_1lmem.html#a26608eb2d71f7595fca7793432c30f6f">nn::lmem::HeapCommonHead</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The heap common header. </p>
<p> <b>Details</b> <br  />
 The heap's management region.<br  />
 A heap common header is always created for heaps.<br  />
 If you do not want to create the heap common header within the heap, allocate this type to another region and then pass it as a parameter when creating the heap. This method creates a heap without a header within it. </p>

</div>
</div>
<a id="a0f98df324bfdc3ff6e67337aa06232ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f98df324bfdc3ff6e67337aa06232ef">&#9670;&nbsp;</a></span>HeapVisitor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* nn::lmem::HeapVisitor) (void *pBlock, <a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, uintptr_t userParam)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the callback function that is called when cycling through memory blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBlock</td><td>The pointer to a memory block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap with a memory block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userParam</td><td>A parameter for the user.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
 Used in the <code><a class="el" href="namespacenn_1_1lmem.html#ae59c5a804990cae8619eab581b693ace" title="Calls a user-specified visitor function on all memory blocks that have been allocated.">VisitExpHeapAllBlocks()</a></code> function. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a5200a4ef197dbd700f31a3111eacf5b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5200a4ef197dbd700f31a3111eacf5b2">&#9670;&nbsp;</a></span>CreationOption</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1lmem.html#a5200a4ef197dbd700f31a3111eacf5b2">nn::lmem::CreationOption</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant that represents the option when creating the heap. </p>
<p> <b>Details</b> <br  />
 Specified as an option for the heap creation function for the expanded heap, frame heap, and unit heap. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5200a4ef197dbd700f31a3111eacf5b2a30c3b2cd8b36e40049c5c88b7c47a45f"></a>CreationOption_NoOption&#160;</td><td class="fielddoc"><p>No option specified. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5200a4ef197dbd700f31a3111eacf5b2a00853f3b9861cc1c8c36508a2d4c8b4a"></a>CreationOption_ZeroClear&#160;</td><td class="fielddoc"><p>Zero-fill memory when memory is allocated. </p>
<p>This option is for debugging only. The code is invalidated in production environments. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5200a4ef197dbd700f31a3111eacf5b2a74d1c66b53b6339b870393957e6d1a83"></a>CreationOption_DebugFill&#160;</td><td class="fielddoc"><p>Memory can be filled with a specific value when creating a heap, allocating memory, or releasing memory. </p>
<p>For more information about heap creation for each type of heap, see the API Reference. This option is for debugging only. The code is invalidated in production environments. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5200a4ef197dbd700f31a3111eacf5b2a59bbf55542967a55d01a7257c1131735"></a>CreationOption_ThreadSafe&#160;</td><td class="fielddoc"><p>Enables the mutual exclusion between threads. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab3db4663e81681986f86c9cd7cb4cae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3db4663e81681986f86c9cd7cb4cae9">&#9670;&nbsp;</a></span>ErrorOption</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1lmem.html#ab3db4663e81681986f86c9cd7cb4cae9">nn::lmem::ErrorOption</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant that represents the option specific to errors. </p>
<p> <b>Details</b> <br  />
 You can specify whether to output errors. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab3db4663e81681986f86c9cd7cb4cae9aa196d3e16ed8b40056ee88759da8c581"></a>ErrorOption_NoOption&#160;</td><td class="fielddoc"><p>No option specified. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab3db4663e81681986f86c9cd7cb4cae9ad3c0eafafaf1f86fe048b63e495b5ada"></a>ErrorOption_Print&#160;</td><td class="fielddoc"><p>Enables error output. </p>
</td></tr>
</table>

</div>
</div>
<a id="a9e4483dceb5521988f7c9afb0e32da8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4483dceb5521988f7c9afb0e32da8d">&#9670;&nbsp;</a></span>FillType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1lmem.html#a9e4483dceb5521988f7c9afb0e32da8d">nn::lmem::FillType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant representing the types of ways to fill the heap. </p>
<p> <b>Details</b> <br  />
 Represents the timing at which memory is filled. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9e4483dceb5521988f7c9afb0e32da8dabf82da361e5cf28b646fb212d043d675"></a>FillType_Unallocated&#160;</td><td class="fielddoc"><p>Fills unused memory (when creating the heap). </p>
</td></tr>
<tr><td class="fieldname"><a id="a9e4483dceb5521988f7c9afb0e32da8da530964fed21e85308d519e88654526bc"></a>FillType_Allocate&#160;</td><td class="fielddoc"><p>Fills memory at allocation. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9e4483dceb5521988f7c9afb0e32da8da8bf8579aec1f8bef0015b939eca65c6a"></a>FillType_Free&#160;</td><td class="fielddoc"><p>Fills memory at release. </p>
</td></tr>
</table>

</div>
</div>
<a id="a18e9eac338e3880aeee1459519b00886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e9eac338e3880aeee1459519b00886">&#9670;&nbsp;</a></span>AdjustMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1lmem.html#a18e9eac338e3880aeee1459519b00886">nn::lmem::AdjustMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant representing the ways to shrink heap memory regions. </p>
<p> <b>Details</b> <br  />
 You can specify the direction in which to shrink heap memory. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a18e9eac338e3880aeee1459519b00886a5c25952febdf7156503bf7dd70f1e703"></a>AdjustMode_Tail&#160;</td><td class="fielddoc"><p>Shrinks heap memory from the end toward the front. </p>
</td></tr>
<tr><td class="fieldname"><a id="a18e9eac338e3880aeee1459519b00886a5c7383dad293f4b1c10380b8a41f59d1"></a>AdjustMode_Head&#160;</td><td class="fielddoc"><p>Shrinks heap memory from the front toward the end. </p>
</td></tr>
</table>

</div>
</div>
<a id="a4a7319ff4369a7278582dd53a1129f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a7319ff4369a7278582dd53a1129f73">&#9670;&nbsp;</a></span>AllocationMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1lmem.html#a4a7319ff4369a7278582dd53a1129f73">nn::lmem::AllocationMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mode in which memory blocks are allocated. </p>
<p> <b>Details</b> <br  />
 Determines by which method blocks are found when allocating memory blocks. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4a7319ff4369a7278582dd53a1129f73a101b6b812bb866cd80f042ef3ff95168"></a>AllocationMode_FirstFit&#160;</td><td class="fielddoc"><p>Allocates a memory block from the first free region that is at least the size of the memory block to allocate. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4a7319ff4369a7278582dd53a1129f73ae6e6a0e6cddfc1146e912f4017c1c161"></a>AllocationMode_BestFit&#160;</td><td class="fielddoc"><p>Searches for a free region nearest in size to the memory block to allocate, and then allocates the memory block from this free region. </p>
</td></tr>
</table>

</div>
</div>
<a id="a4302ad21b1a099adf611aa15400cd06b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4302ad21b1a099adf611aa15400cd06b">&#9670;&nbsp;</a></span>AllocationDirection</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1lmem.html#a4302ad21b1a099adf611aa15400cd06b">nn::lmem::AllocationDirection</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant used to specify the direction of memory block allocation. </p>
<p> <b>Details</b> <br  />
 You can select whether memory block allocation will occur from the front or the back of the heap. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4302ad21b1a099adf611aa15400cd06ba7f33d3263e63f24f45a768189a9ee8e9"></a>AllocationDirection_Front&#160;</td><td class="fielddoc"><p>Allocates memory blocks starting from the front of the empty region of the heap. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4302ad21b1a099adf611aa15400cd06babe4b1359d27860a53a1ad5e1b3b628c8"></a>AllocationDirection_Rear&#160;</td><td class="fielddoc"><p>Allocates memory blocks starting from the back of the empty region of the heap. </p>
</td></tr>
</table>

</div>
</div>
<a id="a0d378823d086c69e88ee7465eb246b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d378823d086c69e88ee7465eb246b3f">&#9670;&nbsp;</a></span>FreeMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1lmem.html#a0d378823d086c69e88ee7465eb246b3f">nn::lmem::FreeMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant used to specify the method of memory block freeing. </p>
<p> <b>Details</b> <br  />
 You can specify which memory blocks, allocated from which direction, you will free. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0d378823d086c69e88ee7465eb246b3fa30222a68322eef67b45eb8274a9696a8"></a>FreeMode_Front&#160;</td><td class="fielddoc"><p>Frees all memory blocks allocated from the front of the heap. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0d378823d086c69e88ee7465eb246b3fa75d4886d4d122c1c366f8351404a91fd"></a>FreeMode_Rear&#160;</td><td class="fielddoc"><p>Frees all memory blocks allocated from the back of the heap. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0d378823d086c69e88ee7465eb246b3faeb0b94c8ebeb50ebe978d075b8bdcf2b"></a>FreeMode_All&#160;</td><td class="fielddoc"><p>Frees all memory blocks within the heap. </p>
</td></tr>
</table>

</div>
</div>
<a id="abd1164e3a948696645a06c70e009f8c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1164e3a948696645a06c70e009f8c2">&#9670;&nbsp;</a></span>InfoPlacement</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1lmem.html#abd1164e3a948696645a06c70e009f8c2">nn::lmem::InfoPlacement</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The constant that determines the location for the placement of the heap common header (the heap management region). </p>
<p> <b>Details</b> <br  />
 You can specify whether to locate the heap management region at the front end or the back end of the memory region. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abd1164e3a948696645a06c70e009f8c2ace7eca4a020808cce9d41929c2776f92"></a>InfoPlacement_Head&#160;</td><td class="fielddoc"><p>Locates the heap management region at the front end of the memory region. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd1164e3a948696645a06c70e009f8c2a0443b9a0d25f781bb734f60972c021db"></a>InfoPlacement_Tail&#160;</td><td class="fielddoc"><p>Locates the heap management region at the back end of the memory region. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aacdf9e8d0b3673ee2041a93353f4b3cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacdf9e8d0b3673ee2041a93353f4b3cb">&#9670;&nbsp;</a></span>SetFillValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::SetFillValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#a9e4483dceb5521988f7c9afb0e32da8d">FillType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bit32&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value for the fill for each type used to fill the heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The type of fill used to fill the heap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value used to fill the heap.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
 Fills occur at the 4-byte level, using specified 32-bit values.<br  />
 The fill value is used in common between all heaps.<br  />
<br  />
 This function is not thread-safe.<br  />
 Do not call other heap APIs at the same time as calling this API. </p>

</div>
</div>
<a id="af868f872b74bcd1bf22d414f7f31af5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af868f872b74bcd1bf22d414f7f31af5e">&#9670;&nbsp;</a></span>GetFillValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bit32 nn::lmem::GetFillValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1lmem.html#a9e4483dceb5521988f7c9afb0e32da8d">FillType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the value used to fill the heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The type of fill used to fill the heap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the value used for the specified fill type.</dd></dl>
<p> <b>Details</b> <br  />
 Specifies the <code>FillType</code> enumerated type, and gets the value that will be filled when the fill occurs.<br  />
<br  />
 This function is not thread-safe.<br  />
 Do not call other <code><a class="el" href="namespacenn_1_1lmem.html#aacdf9e8d0b3673ee2041a93353f4b3cb" title="Sets the value for the fill for each type used to fill the heap.">SetFillValue()</a></code> at the same time as calling this API. </p>

</div>
</div>
<a id="a2e599544385b8f298f4a6303fd7d5d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e599544385b8f298f4a6303fd7d5d67">&#9670;&nbsp;</a></span>GetTotalSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::lmem::GetTotalSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the memory region used by the heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the size in bytes of the memory region used by the heap. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> has been initialized in advance. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The return value will be the size in bytes as the memory region used by the heap.</dd></dl>
<p> <b>Details</b> <br  />
 Gets the size of the memory region used by the heap from the heap handle.<br  />
 Also includes cases where the heap management region has been created within the heap.<br  />
<br  />
 This API is thread-safe when the heap was created by specifying the <code>CreationOption_ThreadSafe</code> option.<br  />
 In all other cases, operations on a heap handled by the same <code><em>heapHandle</em></code> are not thread-safe. </p>

</div>
</div>
<a id="a64dd4f95c8fc55068b221d18fc1ffe4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64dd4f95c8fc55068b221d18fc1ffe4b">&#9670;&nbsp;</a></span>GetStartAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::lmem::GetStartAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the starting address of the memory region used by the heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the starting address of the memory region used by the heap. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> has been initialized in advance. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The return value will be the starting address of the memory region used by the heap.</dd></dl>
<p> <b>Details</b> <br  />
 Gets the starting address of the memory region used by the heap from the heap handle.<br  />
<br  />
 This API is thread-safe when the heap was created by specifying the <code>CreationOption_ThreadSafe</code> option.<br  />
 In all other cases, operations on a heap handled by the same <code><em>heapHandle</em></code> are not thread-safe. </p>

</div>
</div>
<a id="a4f8cf0f54fa6ba157762657ef1f6e103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8cf0f54fa6ba157762657ef1f6e103">&#9670;&nbsp;</a></span>HasAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::lmem::HasAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the specified address is located within a heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Address to target the review in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the specified address is within a heap.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> has been initialized in advance. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>true</code> is returned if the specified address is within a heap.</dd></dl>
<p> <b>Details</b> <br  />
 Determines whether the specified address is located within a heap.<br  />
<br  />
 This API is thread-safe when the heap was created by specifying the <code>CreationOption_ThreadSafe</code> option.<br  />
 In all other cases, operations on a heap handled by the same <code><em>heapHandle</em></code> are not thread-safe. </p>

</div>
</div>
<a id="a3d46d370c3b53aed4a127962761ed0fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d46d370c3b53aed4a127962761ed0fc">&#9670;&nbsp;</a></span>CreateExpHeap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> nn::lmem::CreateExpHeap </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>startAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an expanded heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startAddress</td><td>Starting address of the memory block assigned to a heap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size, in bytes, of the memory block assigned to a heap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>Option for debugging (using a <code>CreationOption</code> enumerated type).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the expanded heap handle when the function succeeds. If it fails, <code>NULL</code> is returned.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>startAddress</em></code> is not <code>NULL</code>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>An expanded heap is created to the specified memory block.</dd></dl>
<p> <b>Details</b> <br  />
 When a heap is created, a heap management region (the heap common header) is also created.<br  />
 That heap management region is created within the heap.<br  />
 As a result, the region available for use for the expanded heap is not the size specified by <code><em>size</em></code> but rather that value minus the amount of the heap management region (<code><a class="el" href="namespacenn_1_1lmem.html#a26608eb2d71f7595fca7793432c30f6f" title="The heap common header.">nn::lmem::HeapCommonHead</a></code>).<br  />
<br  />
 By default, the allocation mode when allocating memory is <code>AllocationMode_FirstFit</code>.<br  />
 This mode can be changed by using the <code><a class="el" href="namespacenn_1_1lmem.html#a0215a6fd274ee1b7f82356aca8ff4ac7" title="Sets the mode to use for memory allocation.">SetExpHeapAllocationMode()</a></code> function.<br  />
<br  />
 Values from the <code>CreationOption</code> enumerated type can be specified for <code><em>option</em></code>. Specify multiple values using an OR designation.<br  />
 To disable options, specify <code>CreationOption_NoOption</code> for <code><em>option</em></code>.<br  />
 To zero-clear the memory with which this heap was allocated, specify <code>CreationOption_ZeroClear</code> for <code><em>option</em></code>.<br  />
 To fill memory with a specific value when creating a heap, allocating memory, or freeing memory, specify <code>CreationOption_DebugFill</code> for <code><em>option</em></code>.<br  />
 By default, the following fill values are used with the <code>CreationOption_DebugFill</code> option.<br  />
 </p><ul>
<li>When creating a heap: <code>0xC3C3C3C3</code> </li>
<li>When allocating memory: <code>0xF3F3F3F3</code> </li>
<li>When freeing memory: <code>0xD3D3D3D3</code> When <code>CreationOption_ZeroClear</code> and <code>CreationOption_DebugFill</code> are specified with an OR, the fill value for <code>CreationOption_DebugFill</code> is used when creating a heap or freeing memory, but memory is zero-cleared when allocating memory.<br  />
 These values can be changed by using the <code><a class="el" href="namespacenn_1_1lmem.html#aacdf9e8d0b3673ee2041a93353f4b3cb" title="Sets the value for the fill for each type used to fill the heap.">SetFillValue()</a></code> function.<br  />
<br  />
 The multithreading mutual exclusion is enabled by specifying <code>CreationOption_ThreadSafe</code> for <code><em>option</em></code>.<br  />
<br  />
 This function is not thread-safe. </li>
</ul>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a0">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af8f5ea9ad1df5559ac024fee0564744a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f5ea9ad1df5559ac024fee0564744a">&#9670;&nbsp;</a></span>DestroyExpHeap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::DestroyExpHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the expanded heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> must be initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The specified expanded heap is released.</dd></dl>
<p> <b>Details</b> <br  />
 Releases the heap specified by the heap handle.<br  />
 This function is not thread-safe. </p>

</div>
</div>
<a id="a3b21c96cee5ec4ae3bb5048fdb483666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b21c96cee5ec4ae3bb5048fdb483666">&#9670;&nbsp;</a></span>AdjustExpHeap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1lmem_1_1_memory_range.html">MemoryRange</a> nn::lmem::AdjustExpHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the empty region of the heap from the back end, reducing the amount of memory used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a range of empty memory blocks resulting from adjusting the heap.<br  />
 If the heap cannot be reduced, the size of the <code><a class="el" href="structnn_1_1lmem_1_1_memory_range.html" title="Structure that indicates a range of memory.">MemoryRange</a></code> object returns <code>0</code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> must be initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The expanded heap has only been reduced by the amount indicated in the return value.</dd></dl>
<p> <b>Details</b> <br  />
 This function fails when a memory block allocated after the heap space exists.<br  />
<br  />
 This API is thread-safe when specifying the <code>CreationOption_ThreadSafe</code> option when using <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> to create the heap.<br  />
 In all other cases, operations on a heap handled by the same <code><em>heapHandle</em></code> are not thread-safe. </p>

</div>
</div>
<a id="a96055cfc77bfd3eac47da134a3746aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96055cfc77bfd3eac47da134a3746aa9">&#9670;&nbsp;</a></span>AllocateFromExpHeap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::lmem::AllocateFromExpHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a memory region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size, in bytes, of the memory to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the start of the memory region if the function succeeds, or a null pointer otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> must be initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>A memory region of <code><em>size</em></code> bytes in size is allocated from the pointer indicated as the return value.</dd></dl>
<p> <b>Details</b> <br  />
 Allocates memory in the expanded heap.<br  />
 <code>DefaultAlignment</code> is used for the alignment.<br  />
<br  />
 This API is thread-safe when specifying the <code>CreationOption_ThreadSafe</code> option when using <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> to create the heap.<br  />
 In all other cases, operations on a heap handled by the same <code><em>heapHandle</em></code> are not thread-safe. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a2">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a64c4062e0fa7e47cc9a604681317525a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c4062e0fa7e47cc9a604681317525a">&#9670;&nbsp;</a></span>AllocateFromExpHeap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::lmem::AllocateFromExpHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a memory region of the specified alignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size, in bytes, of the memory to allocate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>Alignment of the memory to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the start of the memory region if the function succeeds, or a null pointer otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> must be initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> function.<br  />
 The alignment is a positive or negative power of two. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>A memory region of <code><em>size</em></code> bytes in size is allocated from the pointer indicated as the return value.</dd></dl>
<p> <b>Details</b> <br  />
 Allocates memory in the expanded heap.<br  />
 For <code><em>alignment</em></code>, specify a positive or negative power of two.<br  />
 When a negative value is specified for <code><em>alignment</em></code>, memory is allocated from the back end of the heap.<br  />
<br  />
 Memory gaps that occur due to alignment are not reused by default.<br  />
 You can use the <code><a class="el" href="namespacenn_1_1lmem.html#a48a7f1f27f38901e2dcedd42ca0ab2ab" title="Sets whether to reuse fragmented space caused by alignment when allocating memory.">SetExpHeapUseMarginOfAlignment()</a></code> function to set the gaps caused by alignment to be reused as free space.<br  />
 Note, however, that performance can be adversely impacted if memory is allocated with a specified alignment greater than <code>32</code> or less than <code>-32</code> and small empty blocks are added to the gaps in between memory blocks.<br  />
 In addition, when the alignment is set to greater than <code>128</code> or less than <code>-128</code>, the free space is automatically used regardless of the value set by the <code><a class="el" href="namespacenn_1_1lmem.html#a48a7f1f27f38901e2dcedd42ca0ab2ab" title="Sets whether to reuse fragmented space caused by alignment when allocating memory.">SetExpHeapUseMarginOfAlignment()</a></code> function.<br  />
<br  />
 This API is thread-safe when specifying the <code>CreationOption_ThreadSafe</code> option when using <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> to create the heap.<br  />
 In all other cases, operations on a heap handled by the same <code><em>heapHandle</em></code> are not thread-safe. </p>

</div>
</div>
<a id="aa8b756491ff15ef5937719943d7146a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b756491ff15ef5937719943d7146a5">&#9670;&nbsp;</a></span>FreeToExpHeap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::FreeToExpHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a memory region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBlock</td><td>Starting address of the memory block to free.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> must be initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The specified memory region is freed.</dd></dl>
<p> <b>Details</b> <br  />
 Frees the memory allocated in the expanded heap.<br  />
<br  />
 This API is thread-safe when specifying the <code>CreationOption_ThreadSafe</code> option when using <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> to create the heap.<br  />
 In all other cases, operations on a heap handled by the same <code><em>heapHandle</em></code> are not thread-safe. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a4">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="adacfd64bdeac5be2b33f2f5f79656379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adacfd64bdeac5be2b33f2f5f79656379">&#9670;&nbsp;</a></span>ResizeExpHeapBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::lmem::ResizeExpHeapBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the size of a memory block that was allocated from the extended heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBlock</td><td>Starting address of the memory block whose size is being changed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newSize</td><td>The new size (in bytes) of the memory block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the new size (in bytes) of the memory block. If it fails, returns <code>0</code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> must be initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The size of the memory block specified by <code><em>pBlock</em></code> is <code><em>newSize</em></code>.</dd></dl>
<p> <b>Details</b> <br  />
 Sufficient empty space must exist after a memory block when making it larger than its current size. The function fails and returns <code>0</code> when there is insufficient empty space. The memory block size may be larger than requested when growing the memory block size is successful.<br  />
 Shrinking the memory block by a small amount, such as several bytes, may fail from being unable to create an empty space. In this case, the current memory block size is returned.<br  />
<br  />
 This API is not like the C standard library <code>realloc</code>. It does not assign a new address to a resized memory block.<br  />
<br  />
 This API is thread-safe when specifying the <code>CreationOption_ThreadSafe</code> option when using <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> to create the heap.<br  />
 In all other cases, operations on a heap handled by the same <code><em>heapHandle</em></code> are not thread-safe. </p>

</div>
</div>
<a id="aaecc883dba00f234bd0d3e123d1365d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaecc883dba00f234bd0d3e123d1365d2">&#9670;&nbsp;</a></span>GetExpHeapTotalFreeSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::lmem::GetExpHeapTotalFreeSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the free memory size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the total size (in bytes) of free memory in the extended heap.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> must be initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The return value is the size in bytes of free memory in the expanded heap.</dd></dl>
<p> <b>Details</b> <br  />
 Gets the total size (in bytes) of free memory in the extended heap.<br  />
<br  />
 This API is thread-safe when specifying the <code>CreationOption_ThreadSafe</code> option when using <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> to create the heap.<br  />
 In all other cases, operations on a heap handled by the same <code><em>heapHandle</em></code> are not thread-safe. </p>

</div>
</div>
<a id="a65a9bfe39ef9ba8ac6500bcd39defde8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a9bfe39ef9ba8ac6500bcd39defde8">&#9670;&nbsp;</a></span>GetExpHeapAllocatableSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::lmem::GetExpHeapAllocatableSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of the memory block that can be allocated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>The alignment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the largest size, in bytes, of a memory block that can be allocated from the available space in the expanded heap.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> must be initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> function.<br  />
 The alignment is a positive power of two. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The return value is the largest size, in bytes, of a memory block that can be allocated from the frame heap's available space.</dd></dl>
<p> <b>Details</b> <br  />
 Gets the size of the memory block that can be allocated in the expanded heap.<br  />
 For <code><em>alignment</em></code>, specify a positive power of 2.<br  />
<br  />
 This API is thread-safe when specifying the <code>CreationOption_ThreadSafe</code> option when using <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> to create the heap.<br  />
 In all other cases, operations on a heap handled by the same <code><em>heapHandle</em></code> are not thread-safe. </p>

</div>
</div>
<a id="a0215a6fd274ee1b7f82356aca8ff4ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0215a6fd274ee1b7f82356aca8ff4ac7">&#9670;&nbsp;</a></span>SetExpHeapAllocationMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::SetExpHeapAllocationMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#a4a7319ff4369a7278582dd53a1129f73">AllocationMode</a>&#160;</td>
          <td class="paramname"><em>allocationMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the mode to use for memory allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocationMode</td><td>The mode used during memory allocation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> must be initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The mode to use for memory allocation is set in the expanded heap.</dd></dl>
<p> <b>Details</b> <br  />
 The default is <code>AllocationMode_FirstFit</code>.<br  />
<br  />
 This API is thread-safe when specifying the <code>CreationOption_ThreadSafe</code> option when using <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> to create the heap.<br  />
 In all other cases, operations on a heap handled by the same <code><em>heapHandle</em></code> are not thread-safe. </p>

</div>
</div>
<a id="a7958c3154e912e2f1d4df040a03dccb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7958c3154e912e2f1d4df040a03dccb7">&#9670;&nbsp;</a></span>GetExpHeapAllocationMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1lmem.html#a4a7319ff4369a7278582dd53a1129f73">AllocationMode</a> nn::lmem::GetExpHeapAllocationMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the mode to use for memory allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the mode to use for memory allocation in the expanded heap.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> must be initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The return value is the mode to use for memory allocation in the expanded heap.</dd></dl>
<p> <b>Details</b> <br  />
 This API is thread-safe when specifying the <code>CreationOption_ThreadSafe</code> option when using <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> to create the heap.<br  />
 In all other cases, operations on a heap handled by the same <code><em>heapHandle</em></code> are not thread-safe. </p>

</div>
</div>
<a id="a48a7f1f27f38901e2dcedd42ca0ab2ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a7f1f27f38901e2dcedd42ca0ab2ab">&#9670;&nbsp;</a></span>SetExpHeapUseMarginOfAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::SetExpHeapUseMarginOfAlignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reuse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether to reuse fragmented space caused by alignment when allocating memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reuse</td><td>Whether to reuse the gaps in memory that occur during alignment</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> must be initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The specified setting is applied to the expanded heap.</dd></dl>
<p> <b>Details</b> <br  />
 The default is <code>false</code>. Although it may be possible to efficiently use small memory blocks if <code>true</code> is specified, there is a risk that performance will decline when allocating memory because of generating a large number of free blocks.<br  />
 Note, however, that space fragmented by relatively large alignment of 128 bytes or more is automatically reused regardless of the value set by this function.<br  />
<br  />
 This API is thread-safe when specifying the <code>CreationOption_ThreadSafe</code> option when using <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> to create the heap.<br  />
 In all other cases, operations on a heap handled by the same <code><em>heapHandle</em></code> are not thread-safe. </p>

</div>
</div>
<a id="a6b29bb41e1795da84b1f8ec5544a594a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b29bb41e1795da84b1f8ec5544a594a">&#9670;&nbsp;</a></span>GetExpHeapUseMarginOfAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::lmem::GetExpHeapUseMarginOfAlignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether to reuse fragmented space caused by alignment when allocating memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the gaps caused by alignment are reused.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> must be initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The return value specifies whether the expanded heap reuses the memory space in gaps caused by alignment.</dd></dl>
<p> <b>Details</b> <br  />
 The default is <code>false</code>.<br  />
<br  />
 This API is thread-safe when specifying the <code>CreationOption_ThreadSafe</code> option when using <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> to create the heap.<br  />
 In all other cases, operations on a heap handled by the same <code><em>heapHandle</em></code> are not thread-safe. </p>

</div>
</div>
<a id="ab5de7bf254d6a4182e9c4070a94e1b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5de7bf254d6a4182e9c4070a94e1b9c">&#9670;&nbsp;</a></span>SetExpHeapGroupId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::SetExpHeapGroupId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bit16&#160;</td>
          <td class="paramname"><em>groupId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the group ID used during memory allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">groupId</td><td>The group ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> must be initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> function.<br  />
 You must specify a positive integer ranging from <code>0</code> through <code>255</code> for <code><em>groupId</em></code>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The group ID is set in the expanded heap.</dd></dl>
<p> <b>Details</b> <br  />
 Sets the group ID of the expanded heap.<br  />
 When allocating memory with the <code><a class="el" href="namespacenn_1_1lmem.html#a96055cfc77bfd3eac47da134a3746aa9" title="Allocates a memory region.">AllocateFromExpHeap()</a></code> function, each memory block is assigned the same group ID as the expanded heap.<br  />
 Use the <code><a class="el" href="namespacenn_1_1lmem.html#afd47c4651a7f6385ba616a076d0a1457" title="Gets the group ID.">GetExpHeapGroupId()</a></code> function to check the group ID set in the expanded heap, and the <code><a class="el" href="namespacenn_1_1lmem.html#a3fb1220e2063a1660e5e1c1ca8f87d94" title="Gets the group ID of an allocated memory block.">GetExpHeapGroupIdOfBlock()</a></code> function to check the group ID set in a memory block.<br  />
 The default value of the group ID is <code>0</code>.<br  />
<br  />
 This API is thread-safe when specifying the <code>CreationOption_ThreadSafe</code> option when using <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> to create the heap.<br  />
 In all other cases, operations on a heap handled by the same <code><em>heapHandle</em></code> are not thread-safe. </p>

</div>
</div>
<a id="afd47c4651a7f6385ba616a076d0a1457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd47c4651a7f6385ba616a076d0a1457">&#9670;&nbsp;</a></span>GetExpHeapGroupId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bit16 nn::lmem::GetExpHeapGroupId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the group ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the group ID of the expanded heap.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> must be initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The return value is the group ID of the expanded heap.</dd></dl>
<p> <b>Details</b> <br  />
 Use the <code><a class="el" href="namespacenn_1_1lmem.html#a3fb1220e2063a1660e5e1c1ca8f87d94" title="Gets the group ID of an allocated memory block.">GetExpHeapGroupIdOfBlock()</a></code> function to check the group ID set in a memory block.<br  />
<br  />
 This API is thread-safe when specifying the <code>CreationOption_ThreadSafe</code> option when using <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> to create the heap.<br  />
 In all other cases, operations on a heap handled by the same <code><em>heapHandle</em></code> are not thread-safe. </p>

</div>
</div>
<a id="aa4c92d4f94738d803197c67a268c1705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c92d4f94738d803197c67a268c1705">&#9670;&nbsp;</a></span>GetExpHeapBlockSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::lmem::GetExpHeapBlockSize </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pBlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of an allocated memory block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBlock</td><td>Starting address of the memory block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the size of the memory block that was allocated from the extended heap. The value returned by this function may be larger than the size allocated due to alignment and other restrictions.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The memory block specified in <code><em>pBlock</em></code> must have been allocated from an expanded heap. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The return value is the size of the memory block allocated from the expanded heap.</dd></dl>
<p> <b>Details</b> <br  />
 Gets the size of the memory block that was allocated from the extended heap.<br  />
<br  />
 This function is not thread-safe.<br  />
 Do not call the following APIs at the same time as this API against a heap including the <code><em>pBlock</em></code> space. </p><ul>
<li><a class="el" href="namespacenn_1_1lmem.html#af8f5ea9ad1df5559ac024fee0564744a" title="Destroys the expanded heap.">DestroyExpHeap()</a> </li>
<li><a class="el" href="namespacenn_1_1lmem.html#aa8b756491ff15ef5937719943d7146a5" title="Frees a memory region.">FreeToExpHeap()</a> </li>
<li><a class="el" href="namespacenn_1_1lmem.html#adacfd64bdeac5be2b33f2f5f79656379" title="Changes the size of a memory block that was allocated from the extended heap.">ResizeExpHeapBlock()</a> </li>
</ul>

</div>
</div>
<a id="a3fb1220e2063a1660e5e1c1ca8f87d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb1220e2063a1660e5e1c1ca8f87d94">&#9670;&nbsp;</a></span>GetExpHeapGroupIdOfBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bit16 nn::lmem::GetExpHeapGroupIdOfBlock </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pBlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the group ID of an allocated memory block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBlock</td><td>Starting address of the memory block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the group ID of the memory block that was allocated from the extended heap.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The memory block specified in <code><em>pBlock</em></code> must have been allocated from an expanded heap. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The return value is the group ID of the memory block allocated from the expanded heap.</dd></dl>
<p> <b>Details</b> <br  />
 Gets the group ID of a memory block that was allocated from the extended heap.<br  />
<br  />
 This function is not thread-safe.<br  />
 Do not call the following APIs at the same time as this API against a heap including the <code><em>pBlock</em></code> space. </p><ul>
<li><a class="el" href="namespacenn_1_1lmem.html#af8f5ea9ad1df5559ac024fee0564744a" title="Destroys the expanded heap.">DestroyExpHeap()</a> </li>
<li><a class="el" href="namespacenn_1_1lmem.html#ab5de7bf254d6a4182e9c4070a94e1b9c" title="Sets the group ID used during memory allocation.">SetExpHeapGroupId()</a> </li>
<li><a class="el" href="namespacenn_1_1lmem.html#aa8b756491ff15ef5937719943d7146a5" title="Frees a memory region.">FreeToExpHeap()</a> </li>
</ul>

</div>
</div>
<a id="a8f7e706930f05cd5e4e17f2eb2f30ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f7e706930f05cd5e4e17f2eb2f30ade">&#9670;&nbsp;</a></span>GetExpHeapAllocationDirectionOfBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1lmem.html#a4302ad21b1a099adf611aa15400cd06b">AllocationDirection</a> nn::lmem::GetExpHeapAllocationDirectionOfBlock </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pBlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the direction in which a memory block was allocated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBlock</td><td>Starting address of the memory block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the direction in which memory blocks are allocated from the extended heap.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The memory block specified in <code><em>pBlock</em></code> must have been allocated from an expanded heap. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The return value is the allocation direction of the memory block allocated from the expanded heap.</dd></dl>
<p> <b>Details</b> <br  />
 Gets the direction in which memory blocks are allocated from the extended heap.<br  />
<br  />
 This function is not thread-safe.<br  />
 Do not call the following APIs at the same time as this API against a heap including the <code><em>pBlock</em></code> space. </p><ul>
<li><a class="el" href="namespacenn_1_1lmem.html#af8f5ea9ad1df5559ac024fee0564744a" title="Destroys the expanded heap.">DestroyExpHeap()</a> </li>
<li><a class="el" href="namespacenn_1_1lmem.html#aa8b756491ff15ef5937719943d7146a5" title="Frees a memory region.">FreeToExpHeap()</a> </li>
</ul>

</div>
</div>
<a id="a04838ca06b67385b6eb99e63684444a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04838ca06b67385b6eb99e63684444a9">&#9670;&nbsp;</a></span>CheckExpHeap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::lmem::CheckExpHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the extended heap has been destroyed. </p>
<p>(For debugging.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>Options (<code>ErrorOption</code> enumerated type).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the check succeeded, or <code>false</code> otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> must be initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The return value is the result of the check.</dd></dl>
<p> <b>Details</b> <br  />
 When <code><em>option</em></code> is set to <code>ErrorOption_Print</code>, error output is enabled for the check results.<br  />
<br  />
 This API is thread-safe when specifying the <code>CreationOption_ThreadSafe</code> option when using <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> to create the heap.<br  />
 In all other cases, operations on a heap handled by the same <code><em>heapHandle</em></code> are not thread-safe. </p>

</div>
</div>
<a id="a761bf1d98698d5fd19019e748f4d0ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a761bf1d98698d5fd19019e748f4d0ecf">&#9670;&nbsp;</a></span>CheckExpHeapBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::lmem::CheckExpHeapBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks memory blocks that have been allocated from the extended heap. </p>
<p>(For debugging.)</p>
<p>When <code><em>option</em></code> is set to <code>ErrorOption_Print</code>, error output is enabled for the check results.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBlock</td><td>Starting address of the memory block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>Options (<code>ErrorOption</code> enumerated type).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the check succeeded, or <code>false</code> otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> must be initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The return value is the result of the check.</dd></dl>
<p> <b>Details</b> <br  />
 When <code><em>option</em></code> is set to <code>ErrorOption_Print</code>, error output is enabled for the check results.<br  />
<br  />
 This API is thread-safe when specifying the <code>CreationOption_ThreadSafe</code> option when using <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> to create the heap.<br  />
 In all other cases, operations on a heap handled by the same <code><em>heapHandle</em></code> are not thread-safe. </p>

</div>
</div>
<a id="ae59c5a804990cae8619eab581b693ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae59c5a804990cae8619eab581b693ace">&#9670;&nbsp;</a></span>VisitExpHeapAllBlocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::VisitExpHeapAllBlocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#a0f98df324bfdc3ff6e67337aa06232ef">HeapVisitor</a>&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>userParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls a user-specified <code>visitor</code> function on all memory blocks that have been allocated. </p>
<p>(For debugging.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">visitor</td><td>The function to call for each memory block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userParam</td><td>The arguments to pass to the <code><em>visitor</em></code> function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> must be initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The specified function is called on each memory block.</dd></dl>
<p> <b>Details</b> <br  />
 For all memory blocks that are allocated from expanded heaps, the functions specified by the user are called.<br  />
 The order of the memory blocks called by the visitor function is the order in which they were allocated.<br  />
<br  />
 This API is thread-safe when specifying the <code>CreationOption_ThreadSafe</code> option when using <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> to create the heap.<br  />
 In all other cases, operations on a heap handled by the same <code><em>heapHandle</em></code> are not thread-safe. </p>

</div>
</div>
<a id="a3ba05f8df1e914f5748889a52daf7ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba05f8df1e914f5748889a52daf7ec7">&#9670;&nbsp;</a></span>DumpExpHeap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::DumpExpHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays the information in the expanded heap. </p>
<p>(For debugging.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> must be initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The internal information of the expanded heap is output.</dd></dl>
<p> <b>Details</b> <br  />
 Dumps the following expanded heap information.<br  />
 </p><ul>
<li>Whether each block was allocated from the front or the back. </li>
<li>The address of each block. </li>
<li>The size of each block. </li>
<li>The group ID of each block. </li>
<li>The alignment of each block. </li>
<li>The address of the next block pointed to by each block. </li>
<li>The address of the previous block pointed to by each block. </li>
<li>The size of the entire heap. </li>
<li>The size of the used portion of the heap. <br  />
 This API is thread-safe when specifying the <code>CreationOption_ThreadSafe</code> option when using <code><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="Creates an expanded heap.">CreateExpHeap()</a></code> to create the heap.<br  />
 In all other cases, operations on a heap handled by the same <code><em>heapHandle</em></code> are not thread-safe. </li>
</ul>

</div>
</div>
<a id="a90727fbcf266c220ae9409106a467a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90727fbcf266c220ae9409106a467a49">&#9670;&nbsp;</a></span>CreateFrameHeap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> nn::lmem::CreateFrameHeap </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>startAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a frame heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startAddress</td><td>Starting address of the memory block assigned to a heap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size, in bytes, of the memory block assigned to a heap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>Option for debugging (using a <code>CreationOption</code> enumerated type).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the frame heap handle when the function succeeds. If it fails, <code>NULL</code> is returned.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>startAddress</em></code> is not <code>NULL</code>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>A frame heap is created to the specified memory block.</dd></dl>
<p> <b>Details</b> <br  />
 When a heap is created, a heap management region (the heap common header) is also created. That heap management region is created within the heap. As a result, the region available for use to the frame heap is not the size specified by <code><em>size</em></code> but rather that value minus the amount of the heap management region (<code><a class="el" href="namespacenn_1_1lmem.html#a26608eb2d71f7595fca7793432c30f6f" title="The heap common header.">nn::lmem::HeapCommonHead</a></code>).</p>
<p>Values from the <code>CreationOption</code> enumerated type can be specified for <code><em>option</em></code>. Specify multiple values using an OR designation. To disable options, specify <code>CreationOption_NoOption</code> for <code><em>option</em></code>. To zero-clear the memory with which this heap was allocated, specify <code>CreationOption_ZeroClear</code> for <code><em>option</em></code>. To fill memory with a specific value when creating a heap, allocating memory, or freeing memory, specify <code>CreationOption_DebugFill</code> for <code><em>option</em></code>. By default, the following fill values are used with the <code>CreationOption_DebugFill</code> option. </p><ul>
<li>When creating a heap: <code>0xC3C3C3C3</code> </li>
<li>When allocating memory: <code>0xF3F3F3F3</code> </li>
<li>When freeing memory: <code>0xD3D3D3D3</code> When <code>CreationOption_ZeroClear</code> and <code>CreationOption_DebugFill</code> are specified with an OR, the fill value for <code>CreationOption_DebugFill</code> is used when creating a heap or freeing memory, but memory is zero-cleared when allocating memory. These values can be changed by using the <code><a class="el" href="namespacenn_1_1lmem.html#aacdf9e8d0b3673ee2041a93353f4b3cb" title="Sets the value for the fill for each type used to fill the heap.">SetFillValue()</a></code> function.</li>
</ul>
<p>The multithreading mutual exclusion is enabled by specifying <code>CreationOption_ThreadSafe</code> for <code><em>option</em></code>.</p>
<p>This function is not thread-safe. </p>

</div>
</div>
<a id="acd38b1a1f739530aa18143e8d7dfc4ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd38b1a1f739530aa18143e8d7dfc4ee">&#9670;&nbsp;</a></span>CreateFrameHeap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> nn::lmem::CreateFrameHeap </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>startAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#a26608eb2d71f7595fca7793432c30f6f">HeapCommonHead</a> *&#160;</td>
          <td class="paramname"><em>pHeapHead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a frame heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startAddress</td><td>Starting address of the memory block assigned to a heap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size, in bytes, of the memory block assigned to a heap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>Option for debugging (using a <code>CreationOption</code> enumerated type). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pHeapHead</td><td>The heap common header.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the frame heap handle when the function succeeds. If it fails, <code>NULL</code> is returned.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>startAddress</em></code> is not <code>NULL</code>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>A frame heap is created to the specified memory block.</dd></dl>
<p> <b>Details</b> <br  />
 The region passed in the <code><em>pHeapHead</em></code> parameter is used as the heap management region. </p><pre class="fragment">        Values from the &lt;tt&gt;CreationOption&lt;/tt&gt; enumerated type can be specified for &lt;tt&gt;&lt;var&gt;option&lt;/var&gt;&lt;/tt&gt;. Specify multiple values using an OR designation.
        To disable options, specify &lt;tt&gt;CreationOption_NoOption&lt;/tt&gt; for &lt;tt&gt;&lt;var&gt;option&lt;/var&gt;&lt;/tt&gt;.
        To zero-clear the memory with which this heap was allocated, specify &lt;tt&gt;CreationOption_ZeroClear&lt;/tt&gt; for &lt;tt&gt;&lt;var&gt;option&lt;/var&gt;&lt;/tt&gt;.
        To fill memory with a specific value when creating a heap, allocating memory, or freeing memory, specify &lt;tt&gt;CreationOption_DebugFill&lt;/tt&gt; for &lt;tt&gt;&lt;var&gt;option&lt;/var&gt;&lt;/tt&gt;.
        By default, the following fill values are used with the &lt;tt&gt;CreationOption_DebugFill&lt;/tt&gt; option.
        @li  When creating a heap: &lt;tt&gt;0xC3C3C3C3&lt;/tt&gt;
        @li  When allocating memory: &lt;tt&gt;0xF3F3F3F3&lt;/tt&gt;
        @li  When freeing memory: &lt;tt&gt;0xD3D3D3D3&lt;/tt&gt;
        When &lt;tt&gt;CreationOption_ZeroClear&lt;/tt&gt; and &lt;tt&gt;CreationOption_DebugFill&lt;/tt&gt; are specified with an OR, the fill value for &lt;tt&gt;CreationOption_DebugFill&lt;/tt&gt; is used when creating a heap or freeing memory, but memory is zero-cleared when allocating memory.
        These values can be changed by using the &lt;tt&gt;SetFillValue()&lt;/tt&gt; function.

        The multithreading mutual exclusion is enabled by specifying &lt;tt&gt;CreationOption_ThreadSafe&lt;/tt&gt; for &lt;tt&gt;&lt;var&gt;option&lt;/var&gt;&lt;/tt&gt;.

        This function is not thread-safe.
</pre> 
</div>
</div>
<a id="a5fcec58c14f1288a97cc8853c65215ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fcec58c14f1288a97cc8853c65215ad">&#9670;&nbsp;</a></span>DestroyFrameHeap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::DestroyFrameHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases a frame heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> must be initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="Creates a frame heap.">CreateFrameHeap()</a></code> function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The specified frame heap is released.</dd></dl>
<p> <b>Details</b> <br  />
 Releases the heap specified by the heap handle. </p><pre class="fragment">        This function is not thread-safe.
</pre> 
</div>
</div>
<a id="a2530fa487300d192b1d7ed6ed33d1a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2530fa487300d192b1d7ed6ed33d1a4a">&#9670;&nbsp;</a></span>AdjustFrameHeap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1lmem_1_1_memory_range.html">MemoryRange</a> nn::lmem::AdjustFrameHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#a18e9eac338e3880aeee1459519b00886">AdjustMode</a>&#160;</td>
          <td class="paramname"><em>adjustMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the empty region of the heap, reducing the amount of memory used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">adjustMode</td><td>Specifies whether to reduce the heap starting from the tail or from the head.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a range of empty memory blocks resulting from adjusting the heap. If the heap cannot be reduced, the size of the <code><a class="el" href="structnn_1_1lmem_1_1_memory_range.html" title="Structure that indicates a range of memory.">MemoryRange</a></code> object returns <code>0</code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> must be initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="Creates a frame heap.">CreateFrameHeap()</a></code> function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The frame heap has only been reduced by the amount indicated in the return value,</dd></dl>
<p> <b>Details</b> <br  />
 Frees the empty region of the heap, reducing the amount of memory used by the frame heap. This function fails and returns <code>0</code> when both of the following occur: <code>AdjustMode_Head</code> is specified for <code><em>adjustMode</em></code>, and a common header is created in the heap region when the heap is created by the <code><a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="Creates a frame heap.">CreateFrameHeap()</a></code> function.</p>
<p>This API is thread-safe if the <code>CreationOption_ThreadSafe</code> option is specified when the heap is created using <code><a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="Creates a frame heap.">CreateFrameHeap()</a></code>. In all other cases, operations on a heap handled by the same <code><em>heapHandle</em></code> are not thread-safe. </p>

</div>
</div>
<a id="a7c6889dbc9c14c96fdc10f89b69a3c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c6889dbc9c14c96fdc10f89b69a3c96">&#9670;&nbsp;</a></span>AllocateFromFrameHeap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::lmem::AllocateFromFrameHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a memory region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size, in bytes, of the memory to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the start of the memory region if the function succeeds, or a null pointer otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> must be initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="Creates a frame heap.">CreateFrameHeap()</a></code> function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>A memory region of <code><em>size</em></code> bytes in size is allocated from the pointer indicated as the return value.</dd></dl>
<p> <b>Details</b> <br  />
 Allocates memory in the frame heap. <code>DefaultAlignment</code> is used for the alignment.</p>
<p>This API is thread-safe if the <code>CreationOption_ThreadSafe</code> option is specified when the heap is created using <code><a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="Creates a frame heap.">CreateFrameHeap()</a></code>. In all other cases, operations on a heap handled by the same <code><em>heapHandle</em></code> are not thread-safe. </p>

</div>
</div>
<a id="a490bafe2b4b3cbbae2990949be3824d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a490bafe2b4b3cbbae2990949be3824d5">&#9670;&nbsp;</a></span>AllocateFromFrameHeap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::lmem::AllocateFromFrameHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a memory region of the specified alignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size, in bytes, of the memory to allocate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>Alignment of the memory to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the start of the memory region if the function succeeds, or a null pointer otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> must be initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="Creates a frame heap.">CreateFrameHeap()</a></code> function. The alignment is a positive or negative power of two. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>A memory region of <code><em>size</em></code> bytes in size is allocated from the pointer indicated as the return value.</dd></dl>
<p> <b>Details</b> <br  />
 Allocates memory in the frame heap. For <code><em>alignment</em></code>, specify a positive or negative power of two. When a negative value is specified for <code><em>alignment</em></code>, memory is allocated from the back end of the heap.</p>
<p>This API is thread-safe if the <code>CreationOption_ThreadSafe</code> option is specified when the heap is created using <code><a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="Creates a frame heap.">CreateFrameHeap()</a></code>. In all other cases, operations on a heap handled by the same <code><em>heapHandle</em></code> are not thread-safe. </p>

</div>
</div>
<a id="a2c7c2693342c1151c427651a6323969a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c7c2693342c1151c427651a6323969a">&#9670;&nbsp;</a></span>FreeToFrameHeap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::FreeToFrameHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#a0d378823d086c69e88ee7465eb246b3f">FreeMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a memory region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Method used to free the memory blocks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> must be initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="Creates a frame heap.">CreateFrameHeap()</a></code> function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The memory region is freed by the specified method.</dd></dl>
<p> <b>Details</b> <br  />
 Frees the memory allocated in the frame heap. </p><pre class="fragment">        This API is thread-safe if the &lt;tt&gt;CreationOption_ThreadSafe&lt;/tt&gt; option is specified when the heap is created using &lt;tt&gt;CreateFrameHeap()&lt;/tt&gt;.
        In all other cases, operations on a heap handled by the same &lt;tt&gt;&lt;var&gt;heapHandle&lt;/var&gt;&lt;/tt&gt; are not thread-safe.
</pre> 
</div>
</div>
<a id="a4c6f50b6ef046e66428d0c4978a2e3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6f50b6ef046e66428d0c4978a2e3d4">&#9670;&nbsp;</a></span>ResizeFrameHeapBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::lmem::ResizeFrameHeapBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes the memory block that was most recently allocated from the frame heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBlock</td><td>Starting address of the memory block whose size is being changed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newSize</td><td>The new size (in bytes) of the memory block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the new size (in bytes) of the memory block. If it fails, returns <code>0</code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> must be initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="Creates a frame heap.">CreateFrameHeap()</a></code> function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The size of the memory block specified by <code><em>pBlock</em></code> is <code><em>newSize</em></code>.</dd></dl>
<p> <b>Details</b> <br  />
 Resizes the memory block that was most recently allocated from the frame heap. This can only be used on memory blocks that were allocated at the front of the frame heap.</p>
<p>This API is thread-safe if the <code>CreationOption_ThreadSafe</code> option is specified when the heap is created using <code><a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="Creates a frame heap.">CreateFrameHeap()</a></code>. In all other cases, operations on a heap handled by the same <code><em>heapHandle</em></code> are not thread-safe. </p>

</div>
</div>
<a id="abf40e7cffb9c7527baa746570b6de07e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf40e7cffb9c7527baa746570b6de07e">&#9670;&nbsp;</a></span>GetFrameHeapAllocatableSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::lmem::GetFrameHeapAllocatableSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of the memory block that can be allocated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>The alignment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the largest size, in bytes, of a memory block that can be allocated from the available space in the frame heap.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> must be initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="Creates a frame heap.">CreateFrameHeap()</a></code> function. The alignment is a positive power of two. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The return value is the largest size, in bytes, of a memory block that can be allocated from the frame heap's available space.</dd></dl>
<p> <b>Details</b> <br  />
 Gets the size of the memory block that can be allocated in the frame heap. For <code><em>alignment</em></code>, specify a positive power of 2.</p>
<p>This API is thread-safe if the <code>CreationOption_ThreadSafe</code> option is specified when the heap is created using <code><a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="Creates a frame heap.">CreateFrameHeap()</a></code>. In all other cases, operations on a heap handled by the same <code><em>heapHandle</em></code> are not thread-safe. </p>

</div>
</div>
<a id="abd347d006c6676ca3c2c652b56b5540a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd347d006c6676ca3c2c652b56b5540a">&#9670;&nbsp;</a></span>GetFrameHeapState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1lmem_1_1_frame_heap_state.html">FrameHeapState</a> nn::lmem::GetFrameHeapState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the state of the frame heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the current state of the frame heap.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> must be initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="Creates a frame heap.">CreateFrameHeap()</a></code> function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The return value is the <code><a class="el" href="structnn_1_1lmem_1_1_frame_heap_state.html" title="Structure that saves the state of the frame heap.">FrameHeapState</a></code> structure, representing the current state of the heap.</dd></dl>
<p> <b>Details</b> <br  />
 Returns the current state of the frame heap. To restore the current state of the frame heap, pass the <code><a class="el" href="structnn_1_1lmem_1_1_frame_heap_state.html" title="Structure that saves the state of the frame heap.">FrameHeapState</a></code> structure obtained here as a parameter to the <code><a class="el" href="namespacenn_1_1lmem.html#acdb70197d0fac93ff1c51605de577c0e" title="Restores the state of the frame heap.">RestoreFrameHeapState()</a></code> function.</p>
<p>This API is thread-safe if the <code>CreationOption_ThreadSafe</code> option is specified when the heap is created using <code><a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="Creates a frame heap.">CreateFrameHeap()</a></code>. In all other cases, operations on a heap handled by the same <code><em>heapHandle</em></code> are not thread-safe. </p>

</div>
</div>
<a id="acdb70197d0fac93ff1c51605de577c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb70197d0fac93ff1c51605de577c0e">&#9670;&nbsp;</a></span>RestoreFrameHeapState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::RestoreFrameHeapState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1lmem_1_1_frame_heap_state.html">FrameHeapState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restores the state of the frame heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>The state of the frame heap to be restored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> must be initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="Creates a frame heap.">CreateFrameHeap()</a></code> function. The <code><a class="el" href="namespacenn_1_1lmem.html#a2c7c2693342c1151c427651a6323969a" title="Frees a memory region.">FreeToFrameHeap()</a></code> function must have never been called in the interval between the time of the state you want to restore (<code><em>pState</em></code>) and the calling of this function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The frame heap returns to the state of <code><em>pState</em></code>.</dd></dl>
<p> <b>Details</b> <br  />
 Restores the state of the frame heap based on <code><em>pState</em></code>. If the <code><a class="el" href="namespacenn_1_1lmem.html#a2c7c2693342c1151c427651a6323969a" title="Frees a memory region.">FreeToFrameHeap()</a></code> function has been called and memory has been freed, you cannot restore the state to one prior to the freeing of memory.</p>
<p>This API is thread-safe if the <code>CreationOption_ThreadSafe</code> option is specified when the heap is created using <code><a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="Creates a frame heap.">CreateFrameHeap()</a></code>. In all other cases, operations on a heap handled by the same <code><em>heapHandle</em></code> are not thread-safe. </p>

</div>
</div>
<a id="adb56e12364c2c984f7e41fd745b5251e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb56e12364c2c984f7e41fd745b5251e">&#9670;&nbsp;</a></span>DumpFrameHeap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::DumpFrameHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays the information in the frame heap. </p>
<p>(For debugging.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> must be initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="Creates a frame heap.">CreateFrameHeap()</a></code> function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The information in the frame heap is output.</dd></dl>
<p> <b>Details</b> <br  />
 Dumps the following frame heap information. </p><ul>
<li>Address range for memory regions allocated from the front end. </li>
<li>Address range for memory regions allocated from the back end. </li>
<li>The size of the entire heap. </li>
<li>The size of the used portion of the heap.</li>
</ul>
<p>This API is thread-safe if the <code>CreationOption_ThreadSafe</code> option is specified when the heap is created using <code><a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="Creates a frame heap.">CreateFrameHeap()</a></code>. In all other cases, operations on a heap handled by the same <code><em>heapHandle</em></code> are not thread-safe. </p>

</div>
</div>
<a id="a7d3359350e669a5fcc493ce5df5d010c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d3359350e669a5fcc493ce5df5d010c">&#9670;&nbsp;</a></span>CreateUnitHeap() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> nn::lmem::CreateUnitHeap </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>startAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unitSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a unit heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startAddress</td><td>Starting address of the memory block assigned to a heap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size, in bytes, of the memory block assigned to a heap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitSize</td><td>Specifies the size, in bytes, of a memory block, or unit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>Option for debugging (using a <code>CreationOption</code> enumerated type).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the unit heap handle when the function succeeds. If it fails, <code>NULL</code> is returned.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>startAddress</em></code> is not <code>NULL</code>. <code><em>unitSize</em></code> must be at least the pointer size of <code>sizeof(uintptr_t)</code>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>A unit heap is created to the specified memory block.</dd></dl>
<p> <b>Details</b> <br  />
 When a heap is created, a heap management region (the heap common header) is also created. That heap management region is created within the heap. As a result, the region available for use to the unit heap is not the size specified by <code><em>size</em></code> but rather that value minus the amount of the heap management region (<code><a class="el" href="namespacenn_1_1lmem.html#a26608eb2d71f7595fca7793432c30f6f" title="The heap common header.">nn::lmem::HeapCommonHead</a></code>).</p>
<p>The heap management region is created at the start of the heap; <code>DefaultAlignment</code> is used for the alignment.</p>
<p>Values from the <code>CreationOption</code> enumerated type can be specified for <code><em>option</em></code>. Specify multiple values using an OR designation. To disable options, specify <code>CreationOption_NoOption</code> for <code><em>option</em></code>. To zero-clear the memory with which this heap was allocated, specify <code>CreationOption_ZeroClear</code> for <code><em>option</em></code>. To fill memory with a specific value when creating a heap, allocating memory, or freeing memory, specify <code>CreationOption_DebugFill</code> for <code><em>option</em></code>. By default, the following fill values are used with the <code>CreationOption_DebugFill</code> option. </p><ul>
<li>When creating a heap: <code>0xC3C3C3C3</code> </li>
<li>When allocating memory: <code>0xF3F3F3F3</code> </li>
<li>When freeing memory: <code>0xD3D3D3D3</code> When <code>CreationOption_ZeroClear</code> and <code>CreationOption_DebugFill</code> are specified with an OR, the fill value for <code>CreationOption_DebugFill</code> is used when creating a heap or freeing memory, but memory is zero-cleared when allocating memory. These values can be changed by using the <code><a class="el" href="namespacenn_1_1lmem.html#aacdf9e8d0b3673ee2041a93353f4b3cb" title="Sets the value for the fill for each type used to fill the heap.">SetFillValue()</a></code> function. Within the internal algorithm, the portion for the pointer size, starting from the beginning of the memory block, is not filled when creating a heap or deallocating memory.</li>
</ul>
<p>The multithreading mutual exclusion is enabled by specifying <code>CreationOption_ThreadSafe</code> for <code><em>option</em></code>.</p>
<p>This function is not thread-safe. </p>

</div>
</div>
<a id="a37e408afe1b891b1827d340897319386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37e408afe1b891b1827d340897319386">&#9670;&nbsp;</a></span>CreateUnitHeap() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> nn::lmem::CreateUnitHeap </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>startAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unitSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#abd1164e3a948696645a06c70e009f8c2">InfoPlacement</a>&#160;</td>
          <td class="paramname"><em>placement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a unit heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startAddress</td><td>Starting address of the memory block assigned to a heap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size, in bytes, of the memory block assigned to a heap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitSize</td><td>Size, in bytes, of a memory block, or unit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>Option for debugging (using a <code>CreationOption</code> enumerated type). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>Alignment of the memory block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">placement</td><td>The position to locate the heap management region (the heap common header).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the unit heap handle when the function succeeds. If it fails, <code>NULL</code> is returned.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>startAddress</em></code> is not <code>NULL</code>. <code><em>unitSize</em></code> must be at least the pointer size of <code>sizeof(uintptr_t)</code>. The alignment must be specified as a positive number that is a power of two. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>A unit heap is created to the specified memory block.</dd></dl>
<p> <b>Details</b> <br  />
 When a heap is created, a heap management region (the heap common header) is also created. That heap management region is created within the heap. As a result, the region available for use to the unit heap is not the size specified by <code><em>size</em></code> but instead that size minus the amount of the heap management region (<code>HeapCommonHead</code>).</p>
<p>For <code><em>alignment</em></code>, specify a power of two. If a value less than <code>alignof(void*)</code> has been specified for the alignment, the alignment is treated as <code>alignof(void*)</code>.</p>
<p>Values from the <code>CreationOption</code> enumerated type can be specified for <code><em>option</em></code>. Specify multiple values using an OR designation. To disable options, specify <code>CreationOption_NoOption</code> for <code><em>option</em></code>. To zero-clear the memory with which this heap was allocated, specify <code>CreationOption_ZeroClear</code> for <code><em>option</em></code>. To fill memory with a specific value when creating a heap, allocating memory, or freeing memory, specify <code>CreationOption_DebugFill</code> for <code><em>option</em></code>. By default, the following fill values are used with the <code>CreationOption_DebugFill</code> option. </p><ul>
<li>When creating a heap: <code>0xC3C3C3C3</code> </li>
<li>When allocating memory: <code>0xF3F3F3F3</code> </li>
<li>When freeing memory: <code>0xD3D3D3D3</code> When <code>CreationOption_ZeroClear</code> and <code>CreationOption_DebugFill</code> are specified with an OR, the fill value for <code>CreationOption_DebugFill</code> is used when creating a heap or freeing memory, but memory is zero-cleared when allocating memory. These values can be changed by using the <code><a class="el" href="namespacenn_1_1lmem.html#aacdf9e8d0b3673ee2041a93353f4b3cb" title="Sets the value for the fill for each type used to fill the heap.">SetFillValue()</a></code> function. Within the internal algorithm, the portion for the pointer size, starting from the beginning of the memory block, is not filled when creating a heap or deallocating memory.</li>
</ul>
<p>The multithreading mutual exclusion is enabled by specifying <code>CreationOption_ThreadSafe</code> for <code><em>option</em></code>.</p>
<p>This function is not thread-safe. </p>

</div>
</div>
<a id="a48a0b4af7e50ed9ce91b68df40225bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a0b4af7e50ed9ce91b68df40225bdf">&#9670;&nbsp;</a></span>CreateUnitHeap() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> nn::lmem::CreateUnitHeap </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>startAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unitSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#a26608eb2d71f7595fca7793432c30f6f">HeapCommonHead</a> *&#160;</td>
          <td class="paramname"><em>pHeapHead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a unit heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startAddress</td><td>Starting address of the memory block assigned to a heap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size, in bytes, of the memory block assigned to a heap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitSize</td><td>Size, in bytes, of a memory block, or unit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>Option for debugging (using a <code>CreationOption</code> enumerated type). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>Alignment of the memory block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pHeapHead</td><td>The heap common header.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the unit heap handle when the function succeeds. If it fails, <code>NULL</code> is returned.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>startAddress</em></code> is not <code>NULL</code>. <code><em>unitSize</em></code> must be at least the pointer size of <code>sizeof(uintptr_t)</code>. The alignment must be specified as a positive number that is a power of two. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>A unit heap is created to the specified memory block.</dd></dl>
<p> <b>Details</b> <br  />
 The region passed in the <code><em>pHeapHead</em></code> parameter is used as the heap management region. </p><pre class="fragment">        For &lt;tt&gt;&lt;var&gt;alignment&lt;/var&gt;&lt;/tt&gt;, specify a power of two.
        If a value less than &lt;tt&gt;alignof(void*)&lt;/tt&gt; has been specified for the alignment, the alignment is treated as &lt;tt&gt;alignof(void*)&lt;/tt&gt;.

        Values from the &lt;tt&gt;CreationOption&lt;/tt&gt; enumerated type can be specified for &lt;tt&gt;&lt;var&gt;option&lt;/var&gt;&lt;/tt&gt;. Specify multiple values using an OR designation.
        To disable options, specify &lt;tt&gt;CreationOption_NoOption&lt;/tt&gt; for &lt;tt&gt;&lt;var&gt;option&lt;/var&gt;&lt;/tt&gt;.
        To zero-clear the memory with which this heap was allocated, specify &lt;tt&gt;CreationOption_ZeroClear&lt;/tt&gt; for &lt;tt&gt;&lt;var&gt;option&lt;/var&gt;&lt;/tt&gt;.
        To fill memory with a specific value when creating a heap, allocating memory, or freeing memory, specify &lt;tt&gt;CreationOption_DebugFill&lt;/tt&gt; for &lt;tt&gt;&lt;var&gt;option&lt;/var&gt;&lt;/tt&gt;.
        By default, the following fill values are used with the &lt;tt&gt;CreationOption_DebugFill&lt;/tt&gt; option.
        @li  When creating a heap: &lt;tt&gt;0xC3C3C3C3&lt;/tt&gt;
        @li  When allocating memory: &lt;tt&gt;0xF3F3F3F3&lt;/tt&gt;
        @li  When freeing memory: &lt;tt&gt;0xD3D3D3D3&lt;/tt&gt;
        When &lt;tt&gt;CreationOption_ZeroClear&lt;/tt&gt; and &lt;tt&gt;CreationOption_DebugFill&lt;/tt&gt; are specified with an OR, the fill value for &lt;tt&gt;CreationOption_DebugFill&lt;/tt&gt; is used when creating a heap or freeing memory, but memory is zero-cleared when allocating memory.
        These values can be changed by using the &lt;tt&gt;SetFillValue()&lt;/tt&gt; function.
        Within the internal algorithm, the portion for the pointer size, starting from the beginning of the memory block, is not filled when creating a heap or deallocating memory.

        The multithreading mutual exclusion is enabled by specifying &lt;tt&gt;CreationOption_ThreadSafe&lt;/tt&gt; for &lt;tt&gt;&lt;var&gt;option&lt;/var&gt;&lt;/tt&gt;.

        This function is not thread-safe.
</pre> 
</div>
</div>
<a id="a03e9905bd641416421fb108f487b5d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e9905bd641416421fb108f487b5d4f">&#9670;&nbsp;</a></span>DestroyUnitHeap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::DestroyUnitHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases a unit heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> has been initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a7d3359350e669a5fcc493ce5df5d010c" title="Creates a unit heap.">CreateUnitHeap()</a></code> function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The specified unit heap is released.</dd></dl>
<p> <b>Details</b> <br  />
 Releases the heap specified by the heap handle. </p><pre class="fragment">        This function is not thread-safe.
</pre> 
</div>
</div>
<a id="a4ca8ffeb524244ca4f9968d116817257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca8ffeb524244ca4f9968d116817257">&#9670;&nbsp;</a></span>InvalidateUnitHeap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::InvalidateUnitHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidates the heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> has been initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a7d3359350e669a5fcc493ce5df5d010c" title="Creates a unit heap.">CreateUnitHeap()</a></code> function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The specified unit heap is invalidated.</dd></dl>
<p> <b>Details</b> <br  />
 After this function is called, no operations except <code>Finalize</code> can be performed on the heap. </p><pre class="fragment">        This API is thread-safe when specifying the &lt;tt&gt;CreationOption_ThreadSafe&lt;/tt&gt; option when using &lt;tt&gt;CreateUnitHeap()&lt;/tt&gt; to create the heap.
        In all other cases, operations on a heap handled by the same &lt;tt&gt;&lt;var&gt;heapHandle&lt;/var&gt;&lt;/tt&gt; are not thread-safe.
</pre> 
</div>
</div>
<a id="ac64765b319b7e98292e4ce5f70dbce73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64765b319b7e98292e4ce5f70dbce73">&#9670;&nbsp;</a></span>ExtendUnitHeapArea()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::ExtendUnitHeapArea </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extends the region passed as a heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Extension size. This needs to be a multiple of the unit size that was specified during initialization.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> has been initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a7d3359350e669a5fcc493ce5df5d010c" title="Creates a unit heap.">CreateUnitHeap()</a></code> function.</dd></dl>
<p> <b>Details</b> <br  />
 Extends the heap size backward and adds units. </p>

</div>
</div>
<a id="a1d1eec8ea87ca5a847eae04fb21c7a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1eec8ea87ca5a847eae04fb21c7a36">&#9670;&nbsp;</a></span>AllocateFromUnitHeap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::lmem::AllocateFromUnitHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a memory region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the start of the memory region if the function succeeds, or a null pointer otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> has been initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a7d3359350e669a5fcc493ce5df5d010c" title="Creates a unit heap.">CreateUnitHeap()</a></code> function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>A memory region is allocated from the pointer indicated as the return value.</dd></dl>
<p> <b>Details</b> <br  />
 Allocates memory in the unit heap. </p><pre class="fragment">        This API is thread-safe when specifying the &lt;tt&gt;CreationOption_ThreadSafe&lt;/tt&gt; option when using &lt;tt&gt;CreateUnitHeap()&lt;/tt&gt; to create the heap.
        In all other cases, operations on a heap handled by the same &lt;tt&gt;&lt;var&gt;heapHandle&lt;/var&gt;&lt;/tt&gt; are not thread-safe.
</pre> 
</div>
</div>
<a id="ab190d0a00216c4d8cd2e3134680d3a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab190d0a00216c4d8cd2e3134680d3a45">&#9670;&nbsp;</a></span>FreeToUnitHeap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::FreeToUnitHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a memory region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBlock</td><td>Starting address of the memory block, or unit, to free.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> has been initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a7d3359350e669a5fcc493ce5df5d010c" title="Creates a unit heap.">CreateUnitHeap()</a></code> function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The specified memory region is freed.</dd></dl>
<p> <b>Details</b> <br  />
 Frees the memory allocated in the unit heap. </p><pre class="fragment">        This API is thread-safe when specifying the &lt;tt&gt;CreationOption_ThreadSafe&lt;/tt&gt; option when using &lt;tt&gt;CreateUnitHeap()&lt;/tt&gt; to create the heap.
        In all other cases, operations on a heap handled by the same &lt;tt&gt;&lt;var&gt;heapHandle&lt;/var&gt;&lt;/tt&gt; are not thread-safe.
</pre> 
</div>
</div>
<a id="a4f73af475a54358322fe7b3c8bf78ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f73af475a54358322fe7b3c8bf78ef6">&#9670;&nbsp;</a></span>GetUnitHeapUnitSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::lmem::GetUnitHeapUnitSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the unit size of the unit heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the size of a memory block, or unit, of a unit heap.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> has been initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a7d3359350e669a5fcc493ce5df5d010c" title="Creates a unit heap.">CreateUnitHeap()</a></code> function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The return value is the unit size of the unit heap.</dd></dl>
<p> <b>Details</b> <br  />
 Gets the size of a memory block, or unit, of a unit heap. </p><pre class="fragment">        This function is thread-safe.
</pre> 
</div>
</div>
<a id="abe2b6be8b9c2077fec92fb19c5e8aeb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe2b6be8b9c2077fec92fb19c5e8aeb1">&#9670;&nbsp;</a></span>GetUnitHeapAllocatableCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::lmem::GetUnitHeapAllocatableCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of blank units. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of units not allocated.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> has been initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a7d3359350e669a5fcc493ce5df5d010c" title="Creates a unit heap.">CreateUnitHeap()</a></code> function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The return value is the number of blank units of the unit heap.</dd></dl>
<p> <b>Details</b> <br  />
 Gets the number of units, out of all the units in the unit heap, that have not been allocated. </p><pre class="fragment">        This API is thread-safe when specifying the &lt;tt&gt;CreationOption_ThreadSafe&lt;/tt&gt; option when using &lt;tt&gt;CreateUnitHeap()&lt;/tt&gt; to create the heap.
        In all other cases, operations on a heap handled by the same &lt;tt&gt;&lt;var&gt;heapHandle&lt;/var&gt;&lt;/tt&gt; are not thread-safe.
</pre> 
</div>
</div>
<a id="aaa1ae99b4baab79444c503a383345154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa1ae99b4baab79444c503a383345154">&#9670;&nbsp;</a></span>GetUnitHeapAllocatedCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::lmem::GetUnitHeapAllocatedCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of units that are currently being allocated from this heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of units being allocated.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> has been initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a7d3359350e669a5fcc493ce5df5d010c" title="Creates a unit heap.">CreateUnitHeap()</a></code> function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The return value is the number of allocated units of the unit heap.</dd></dl>
<p> <b>Details</b> <br  />
 Gets the number of units, out of all the units in the unit heap, that have been allocated. </p><pre class="fragment">        This API is thread-safe when specifying the &lt;tt&gt;CreationOption_ThreadSafe&lt;/tt&gt; option when using &lt;tt&gt;CreateUnitHeap()&lt;/tt&gt; to create the heap.
        In all other cases, operations on a heap handled by the same &lt;tt&gt;&lt;var&gt;heapHandle&lt;/var&gt;&lt;/tt&gt; are not thread-safe.
</pre> 
</div>
</div>
<a id="a8a08003a1b715eded61e040c3cd087a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a08003a1b715eded61e040c3cd087a9">&#9670;&nbsp;</a></span>GetUnitHeapAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::lmem::GetUnitHeapAlignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the unit alignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the unit alignment.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> has been initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a7d3359350e669a5fcc493ce5df5d010c" title="Creates a unit heap.">CreateUnitHeap()</a></code> function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The return value is the unit alignment.</dd></dl>
<p> <b>Details</b> <br  />
 Gets the alignment of each memory block, or unit, of a unit heap. </p><pre class="fragment">        This function is thread-safe.
</pre> 
</div>
</div>
<a id="a8ac10912318a3d5f45687fa1885c89be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ac10912318a3d5f45687fa1885c89be">&#9670;&nbsp;</a></span>GetRequiredUnitHeapSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::lmem::GetRequiredUnitHeapSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unitSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>unitNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hasHeadInternally</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the minimum size of heap memory required to manage the specified number of blocks of the specified unit size and alignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">unitSize</td><td>Unit size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitNum</td><td>Number of units. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>Alignment. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hasHeadInternally</td><td>Whether the heap has a management region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the memory size required with the specified conditions.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>startAddress</em></code> is not <code>NULL</code>. <code><em>unitSize</em></code> must be at least the pointer size of <code>sizeof(uintptr_t)</code>. The alignment must be specified as a positive number that is a power of two.</dd></dl>
<p> <b>Details</b> <br  />
 Calculates and gets the memory size required to create a unit heap meeting the conditions as provided in the parameters. </p><pre class="fragment">        For &lt;tt&gt;&lt;var&gt;alignment&lt;/var&gt;&lt;/tt&gt;, specify a power of two.
        If a value less than &lt;tt&gt;alignof(void*)&lt;/tt&gt; has been specified for the alignment, the alignment is treated as &lt;tt&gt;alignof(void*)&lt;/tt&gt;.

        When creating a heap management region within the heap and creating a unit heap with the &lt;tt&gt;CreateUnitHeap()&lt;/tt&gt; function, set &lt;tt&gt;&lt;var&gt;hasHeadInternally&lt;/var&gt;&lt;/tt&gt; to &lt;tt&gt;true&lt;/tt&gt;.
        When allocating the heap management region outside the heap, set &lt;tt&gt;&lt;var&gt;hasHeadInternally&lt;/var&gt;&lt;/tt&gt; to &lt;tt&gt;false&lt;/tt&gt;.

        The value obtained by this function assumes that the &lt;tt&gt;&lt;var&gt;startAddress&lt;/var&gt;&lt;/tt&gt; parameter of the &lt;tt&gt;nn::lmem::CreateUnitHeap()&lt;/tt&gt; function is aligned to &lt;tt&gt;alignof(void*)&lt;/tt&gt;.
        For this reason, if the &lt;tt&gt;&lt;var&gt;startAddress&lt;/var&gt;&lt;/tt&gt; passed to &lt;tt&gt;nn::lmem::CreateUnitHeap()&lt;/tt&gt; is not aligned to &lt;tt&gt;alignof(void*)&lt;/tt&gt;, you might need a larger size than the value obtained by this function.

        This function is thread-safe.
</pre> 
</div>
</div>
<a id="a1deefa949a2c36e348db0fe808cad2de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1deefa949a2c36e348db0fe808cad2de">&#9670;&nbsp;</a></span>DumpUnitHeap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::DumpUnitHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays the information in the unit heap. </p>
<p>(For debugging.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>The heap handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>heapHandle</em></code> has been initialized in advance by the <code><a class="el" href="namespacenn_1_1lmem.html#a7d3359350e669a5fcc493ce5df5d010c" title="Creates a unit heap.">CreateUnitHeap()</a></code> function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The information in the unit heap is output.</dd></dl>
<p> <b>Details</b> <br  />
 Dumps the following unit heap information. </p><ul>
<li>The address range and size for each unit. </li>
<li>The address range and size for the heap as a whole. </li>
<li>The size of the used portion of the heap and the use ratio.</li>
</ul>
<p>This API is thread-safe when specifying the <code>CreationOption_ThreadSafe</code> option when using <code><a class="el" href="namespacenn_1_1lmem.html#a7d3359350e669a5fcc493ce5df5d010c" title="Creates a unit heap.">CreateUnitHeap()</a></code> to create the heap. In all other cases, operations on a heap handled by the same <code><em>heapHandle</em></code> are not thread-safe. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a9b73760b843761bad7afb25be502c4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b73760b843761bad7afb25be502c4b0">&#9670;&nbsp;</a></span>DefaultAlignment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int nn::lmem::DefaultAlignment = 8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default alignment occurs for memory allocation. </p>
<p> <b>Details</b> <br  />
 The alignment specified by default is used for memory allocation. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
