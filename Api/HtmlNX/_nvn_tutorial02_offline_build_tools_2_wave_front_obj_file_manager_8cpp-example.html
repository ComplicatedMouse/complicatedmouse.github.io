<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NvnTutorial02OfflineBuildTools/WaveFrontObjFileManager.cpp | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">NvnTutorial02OfflineBuildTools/WaveFrontObjFileManager.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<p>For an explanation of the source code, see <a class="el" href="_page_sample_nvn_tutorial02.html">NVN Tutorial 02: GPU Offline Build Tools</a> and <tt>NvnTutorial02OfflineBuildTools/WaveFrontObjFileManager.cpp</tt>.</p>
<div class="fragment"><div class="line"><span class="comment">/*--------------------------------------------------------------------------------*</span></div>
<div class="line"><span class="comment">  Copyright (C)Nintendo All rights reserved.</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  These coded instructions, statements, and computer programs contain proprietary</span></div>
<div class="line"><span class="comment">  information of Nintendo and/or its licensed developers and are protected by</span></div>
<div class="line"><span class="comment">  national and international copyright laws. They may not be disclosed to third</span></div>
<div class="line"><span class="comment">  parties or copied or duplicated in any form, in whole or in part, without the</span></div>
<div class="line"><span class="comment">  prior written consent of Nintendo.</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  The content herein is highly confidential and should be handled accordingly.</span></div>
<div class="line"><span class="comment"> *--------------------------------------------------------------------------------*/</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define TINYOBJLOADER_IMPLEMENTATION</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_wave_front_obj_file_manager_8h.html">WaveFrontObjFileManager.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstring&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="util___vector_8h.html">nn/util/util_Vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_p_b_r_model_binary_file_headers_8h.html">PBRModelBinaryFileHeaders.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;tuple&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * WaveFrontObjFileManager Constructor</span></div>
<div class="line"><span class="comment"> * -----------------------------------</span></div>
<div class="line"><span class="comment"> * Empty constructor.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">WaveFrontObjFileManager::WaveFrontObjFileManager()</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * WaveFrontObjFileManager Destructor</span></div>
<div class="line"><span class="comment"> * ----------------------------------</span></div>
<div class="line"><span class="comment"> * Empty destructor.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">WaveFrontObjFileManager::~WaveFrontObjFileManager()</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * WaveFrontObjFileManager::LoadObjFile</span></div>
<div class="line"><span class="comment"> * ------------------------------------</span></div>
<div class="line"><span class="comment"> * Loads the .obj and .mtl files into memory and hands</span></div>
<div class="line"><span class="comment"> * that off to tiny_obj to parse.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">bool</span> WaveFrontObjFileManager::LoadObjFile(<span class="keyword">const</span> std::string&amp; pathName,</div>
<div class="line">                                          <span class="keyword">const</span> std::string&amp; objFileName,</div>
<div class="line">                                          tinyobj::attrib_t&amp; attrib,</div>
<div class="line">                                          std::vector&lt;tinyobj::shape_t&gt;&amp; shapes,</div>
<div class="line">                                          std::vector&lt;tinyobj::material_t&gt;&amp; materials)</div>
<div class="line">{</div>
<div class="line">    std::ifstream objFile;</div>
<div class="line">    objFile.open(pathName + objFileName);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!objFile.is_open())</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to open object file: &quot;</span> &lt;&lt; objFileName &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Loading WaveFrontObj File: &quot;</span> &lt;&lt; objFileName &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    std::stringstream objStream;</div>
<div class="line">    objStream &lt;&lt; objFile.rdbuf();</div>
<div class="line"> </div>
<div class="line">    std::string file = objStream.str();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">size_t</span> libPos = file.find(<span class="stringliteral">&quot;mtllib&quot;</span>, 0);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (libPos == std::string::npos)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to find mtl file name for obj: &quot;</span> &lt;&lt; objFileName &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* pMaterialFileName = file.c_str() + libPos;</div>
<div class="line"> </div>
<div class="line">    pMaterialFileName += 7;</div>
<div class="line"> </div>
<div class="line">    std::string mtlFileName;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">char</span> read = *pMaterialFileName;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">do</span></div>
<div class="line">    {</div>
<div class="line">        mtlFileName += read;</div>
<div class="line"> </div>
<div class="line">        pMaterialFileName += 1;</div>
<div class="line">        read = *pMaterialFileName;</div>
<div class="line">    } <span class="keywordflow">while</span> (read != <span class="charliteral">&#39;\n&#39;</span> &amp;&amp; read != <span class="charliteral">&#39;\r&#39;</span>);</div>
<div class="line"> </div>
<div class="line">    std::ifstream mtlFile;</div>
<div class="line">    mtlFile.open(pathName + mtlFileName);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!mtlFile.is_open())</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to open material file: &quot;</span> &lt;&lt; mtlFileName &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::stringstream mtlStream;</div>
<div class="line">    mtlStream &lt;&lt; mtlFile.rdbuf();</div>
<div class="line"> </div>
<div class="line">    tinyobj::MaterialStreamReader matSSReader(mtlStream);</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Entering tiny_obj code: &quot;</span> &lt;&lt; objFileName &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    std::string err;</div>
<div class="line">    <span class="keywordtype">bool</span> ret = tinyobj::LoadObj(&amp;attrib, &amp;shapes, &amp;materials, &amp;err, &amp;objStream, &amp;matSSReader);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!ret)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to load obj\n&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Finished loading: &quot;</span> &lt;&lt; objFileName &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * WaveFrontObjFileManager::ProcessData</span></div>
<div class="line"><span class="comment"> * ------------------------------------</span></div>
<div class="line"><span class="comment"> * For each of the shapes found by tiny_obj, create</span></div>
<div class="line"><span class="comment"> * and setup a new WaveFrontMeshData struct. If the</span></div>
<div class="line"><span class="comment"> * shape references multiple materials, split it into</span></div>
<div class="line"><span class="comment"> * multiple meshes based on the material ids.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> WaveFrontObjFileManager::ProcessData(<span class="keyword">const</span> tinyobj::attrib_t&amp; attrib,</div>
<div class="line">                                          <span class="keyword">const</span> std::vector&lt;tinyobj::shape_t&gt;&amp; shapes,</div>
<div class="line">                                          std::vector&lt;WaveFrontMeshData*&gt;&amp; meshes)</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Processing data\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* For each shape */</span></div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; shapes.size(); ++i)</div>
<div class="line">    {</div>
<div class="line">        std::vector&lt;uint32_t&gt; materialIDs;</div>
<div class="line">        materialIDs.push_back(shapes[i].mesh.material_ids[0]);</div>
<div class="line"> </div>
<div class="line">        std::vector&lt;uint32_t&gt; splitIndices;</div>
<div class="line">        splitIndices.push_back(0);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/*</span></div>
<div class="line"><span class="comment">             * Figure out if the mesh uses multiple materials</span></div>
<div class="line"><span class="comment">             * and keep track of where the splits occur.</span></div>
<div class="line"><span class="comment">             */</span></div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t j = 1; j &lt; shapes[i].mesh.material_ids.size(); ++j)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (shapes[i].mesh.material_ids[j] != materialIDs.back())</div>
<div class="line">            {</div>
<div class="line">                materialIDs.push_back(shapes[i].mesh.material_ids[j]);</div>
<div class="line">                splitIndices.push_back(j);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        splitIndices.push_back(<span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(shapes[i].mesh.material_ids.size()));</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* If no splits, just create a new mesh */</span></div>
<div class="line">        <span class="keywordflow">if</span> (materialIDs.size() == 1)</div>
<div class="line">        {</div>
<div class="line">            WaveFrontMeshData* mesh = <span class="keyword">new</span> WaveFrontMeshData();</div>
<div class="line"> </div>
<div class="line">            mesh-&gt;SetupData(shapes[i], attrib);</div>
<div class="line"> </div>
<div class="line">            meshes.push_back(mesh);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">                <span class="comment">/*</span></div>
<div class="line"><span class="comment">                 * If the mesh needs to be split, create a</span></div>
<div class="line"><span class="comment">                 * temporary shape using the split indices</span></div>
<div class="line"><span class="comment">                 * per material and pass each of those to a</span></div>
<div class="line"><span class="comment">                 * new mesh.</span></div>
<div class="line"><span class="comment">                 */</span></div>
<div class="line">            <span class="keywordflow">for</span> (uint32_t j = 0; j &lt; materialIDs.size(); ++j)</div>
<div class="line">            {</div>
<div class="line">                tinyobj::shape_t subMesh;</div>
<div class="line">                subMesh.mesh.material_ids.push_back(materialIDs[j]);</div>
<div class="line"> </div>
<div class="line">                subMesh.mesh.indices = std::vector&lt;tinyobj::index_t&gt;(shapes[i].mesh.indices.begin() + splitIndices[j] * 3, shapes[i].mesh.indices.begin() + splitIndices[j + 1] * 3);</div>
<div class="line">                subMesh.mesh.tags = shapes[i].mesh.tags;</div>
<div class="line">                subMesh.name = shapes[i].name;</div>
<div class="line"> </div>
<div class="line">                WaveFrontMeshData* mesh = <span class="keyword">new</span> WaveFrontMeshData();</div>
<div class="line"> </div>
<div class="line">                mesh-&gt;SetupData(subMesh, attrib);</div>
<div class="line"> </div>
<div class="line">                meshes.push_back(mesh);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Finished processing data\n&quot;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * WaveFrontObjFileManager::WriteBinaryFile</span></div>
<div class="line"><span class="comment"> * ----------------------------------------</span></div>
<div class="line"><span class="comment"> * Writes the mesh data to a binary output file.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">bool</span> WaveFrontObjFileManager::WriteBinaryFile(<span class="keyword">const</span> std::string&amp; pathName,</div>
<div class="line">                                              <span class="keyword">const</span> std::string&amp; objFileName,</div>
<div class="line">                                              <span class="keyword">const</span> WaveFrontObjConfig&amp; <span class="keywordtype">object</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">size_t</span> periodPos = objFileName.find(<span class="charliteral">&#39;.&#39;</span>);</div>
<div class="line"> </div>
<div class="line">    std::string::const_iterator endItr;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (periodPos == std::string::npos)</div>
<div class="line">        endItr = objFileName.end();</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        endItr = objFileName.begin() + periodPos;</div>
<div class="line"> </div>
<div class="line">    std::string name(objFileName.begin(), endItr);</div>
<div class="line"> </div>
<div class="line">    std::string filePath = pathName + name + <span class="stringliteral">&quot;.out&quot;</span>;</div>
<div class="line">    FILE* outputFile;</div>
<div class="line">    fopen_s(&amp;outputFile, filePath.c_str(), <span class="stringliteral">&quot;wb&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!outputFile)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to open output file for: &quot;</span> &lt;&lt; objFileName &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Writing file: &quot;</span> &lt;&lt; name &lt;&lt; <span class="stringliteral">&quot;.out\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Start processing headers\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    PBRModelBinary::FileHeader fileHeader;</div>
<div class="line"> </div>
<div class="line">    PBRModelBinary::MeshBlockHeader meshBlockHeader;</div>
<div class="line">    memset(&amp;meshBlockHeader, 0, <span class="keyword">sizeof</span>(meshBlockHeader));</div>
<div class="line">    std::vector&lt;PBRModelBinary::MeshHeader&gt; meshHeaders;</div>
<div class="line">    meshHeaders.resize(<span class="keywordtype">object</span>.m_Meshes.size());</div>
<div class="line"> </div>
<div class="line">    PBRModelBinary::MaterialBlockHeader materialBlockHeader;</div>
<div class="line">    memset(&amp;materialBlockHeader, 0, <span class="keyword">sizeof</span>(materialBlockHeader));</div>
<div class="line">    std::vector&lt;PBRModelBinary::MaterialHeader&gt; materialHeaders;</div>
<div class="line">    materialHeaders.resize(<span class="keywordtype">object</span>.m_Meshes.size());</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;PBRModelBinary::DataHeader&gt; dataHeaders;</div>
<div class="line"> </div>
<div class="line">    uint64_t currentOffset = 0;</div>
<div class="line"> </div>
<div class="line">    currentOffset += <span class="keyword">sizeof</span>(PBRModelBinary::FileHeader);</div>
<div class="line"> </div>
<div class="line">    fileHeader.m_MeshBlockOffset = currentOffset;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">size_t</span> meshOffsetListSize = meshHeaders.size() * <span class="keyword">sizeof</span>(uint64_t);</div>
<div class="line">    currentOffset += <span class="keyword">sizeof</span>(PBRModelBinary::MeshBlockHeader::m_NumMeshes);</div>
<div class="line">    currentOffset += meshOffsetListSize;</div>
<div class="line"> </div>
<div class="line">    fileHeader.m_MaterialBlockOffset = currentOffset;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">size_t</span> materialOffsetListSize = materialHeaders.size() * <span class="keyword">sizeof</span>(uint64_t);</div>
<div class="line">    currentOffset += <span class="keyword">sizeof</span>(PBRModelBinary::MaterialBlockHeader::m_NumMaterials);</div>
<div class="line">    currentOffset += materialOffsetListSize;</div>
<div class="line"> </div>
<div class="line">    meshBlockHeader.m_NumMeshes = meshHeaders.size();</div>
<div class="line">    meshBlockHeader.m_pMeshOffsets = (uint64_t*)malloc(meshOffsetListSize);</div>
<div class="line"> </div>
<div class="line">    uint32_t numDataHeaders = 0;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Create the mesh headers */</span></div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; <span class="keywordtype">object</span>.m_Meshes.size(); ++i)</div>
<div class="line">    {</div>
<div class="line">        memset(&amp;meshHeaders[i], 0, <span class="keyword">sizeof</span>(PBRModelBinary::MeshHeader));</div>
<div class="line"> </div>
<div class="line">        meshHeaders[i].m_MagicPadding = 0;</div>
<div class="line">        meshHeaders[i].m_NumIndices = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(<span class="keywordtype">object</span>.m_Meshes[i]-&gt;m_Indices.size());</div>
<div class="line">        meshHeaders[i].m_NumVertices = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(<span class="keywordtype">object</span>.m_Meshes[i]-&gt;m_Positions.size() / 3);</div>
<div class="line">        meshHeaders[i].m_MaterialIndex = i;</div>
<div class="line"> </div>
<div class="line">        meshBlockHeader.m_pMeshOffsets[i] = currentOffset;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keywordtype">object</span>.m_Meshes[i]-&gt;m_Positions.size())</div>
<div class="line">        {</div>
<div class="line">            ++numDataHeaders;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keywordtype">object</span>.m_Meshes[i]-&gt;m_Normals.size())</div>
<div class="line">        {</div>
<div class="line">            ++numDataHeaders;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keywordtype">object</span>.m_Meshes[i]-&gt;m_TexCoords.size())</div>
<div class="line">        {</div>
<div class="line">            ++numDataHeaders;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keywordtype">object</span>.m_Meshes[i]-&gt;m_Binormals.size())</div>
<div class="line">        {</div>
<div class="line">            ++numDataHeaders;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keywordtype">object</span>.m_Meshes[i]-&gt;m_Tangents.size())</div>
<div class="line">        {</div>
<div class="line">            ++numDataHeaders;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keywordtype">object</span>.m_Meshes[i]-&gt;m_Indices.size())</div>
<div class="line">        {</div>
<div class="line">            ++numDataHeaders;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        currentOffset += <span class="keyword">sizeof</span>(PBRModelBinary::MeshHeader);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    materialBlockHeader.m_NumMaterials = materialHeaders.size();</div>
<div class="line">    materialBlockHeader.m_pMaterialOffsets = (uint64_t*)malloc(materialOffsetListSize);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Create the material headers */</span></div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; <span class="keywordtype">object</span>.m_Meshes.size(); ++i)</div>
<div class="line">    {</div>
<div class="line">        uint32_t matIndex = <span class="keywordtype">object</span>.m_Meshes[i]-&gt;m_MaterialIndex;</div>
<div class="line"> </div>
<div class="line">        memset(&amp;materialHeaders[i], 0, <span class="keyword">sizeof</span>(PBRModelBinary::MaterialHeader));</div>
<div class="line"> </div>
<div class="line">        memcpy(materialHeaders[i].m_Diffuse, <span class="keywordtype">object</span>.m_Materials[matIndex].diffuse, <span class="keyword">sizeof</span>(materialHeaders[i].m_Diffuse));</div>
<div class="line">        materialHeaders[i].m_Specular = <span class="keywordtype">object</span>.m_Materials[matIndex].specular[0];</div>
<div class="line">        memcpy(materialHeaders[i].m_Emissive, <span class="keywordtype">object</span>.m_Materials[matIndex].emission, <span class="keyword">sizeof</span>(materialHeaders[i].m_Emissive));</div>
<div class="line"> </div>
<div class="line">        materialHeaders[i].m_Roughness = <span class="keywordtype">object</span>.m_Materials[matIndex].roughness;</div>
<div class="line">        materialHeaders[i].m_Metallic = <span class="keywordtype">object</span>.m_Materials[matIndex].metallic;</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/*</span></div>
<div class="line"><span class="comment">             * In our material model, the texture option &quot;turbulence&quot;</span></div>
<div class="line"><span class="comment">             * is repurposed as a multiplicative modifier for the</span></div>
<div class="line"><span class="comment">             * value sampled from the texture. The default value for</span></div>
<div class="line"><span class="comment">             * turbulence defined by tiny_obj is (0.0f, 0.0f, 0.0f).</span></div>
<div class="line"><span class="comment">             * Here we check for this value and use (1.0f, 1.0f, 1.0f)</span></div>
<div class="line"><span class="comment">             * instead.</span></div>
<div class="line"><span class="comment">             */</span></div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Diffuse */</span></div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keywordtype">object</span>.m_Materials[matIndex].diffuse_texname.size())</div>
<div class="line">        {</div>
<div class="line">            memcpy(materialHeaders[i].m_DiffuseMapMod, <span class="keywordtype">object</span>.m_Materials[matIndex].diffuse_texopt.scale, <span class="keyword">sizeof</span>(materialHeaders[i].m_DiffuseMapMod));</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (<span class="keywordtype">object</span>.m_Materials[matIndex].diffuse_texopt.turbulence[0] == 0.0f &amp;&amp;</div>
<div class="line">                <span class="keywordtype">object</span>.m_Materials[matIndex].diffuse_texopt.turbulence[1] == 0.0f &amp;&amp;</div>
<div class="line">                <span class="keywordtype">object</span>.m_Materials[matIndex].diffuse_texopt.turbulence[2] == 0.0f)</div>
<div class="line">            {</div>
<div class="line">                materialHeaders[i].m_DiffuseValMod[0] = 1.0f;</div>
<div class="line">                materialHeaders[i].m_DiffuseValMod[1] = 1.0f;</div>
<div class="line">                materialHeaders[i].m_DiffuseValMod[2] = 1.0f;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                memcpy(materialHeaders[i].m_DiffuseValMod, <span class="keywordtype">object</span>.m_Materials[matIndex].diffuse_texopt.turbulence, <span class="keyword">sizeof</span>(materialHeaders[i].m_DiffuseValMod));</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            ++numDataHeaders;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            memset(materialHeaders[i].m_DiffuseValMod, 0, <span class="keyword">sizeof</span>(materialHeaders[i].m_DiffuseValMod));</div>
<div class="line">            memset(materialHeaders[i].m_DiffuseMapMod, 0, <span class="keyword">sizeof</span>(materialHeaders[i].m_DiffuseMapMod));</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Specular */</span></div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keywordtype">object</span>.m_Materials[matIndex].specular_texname.size())</div>
<div class="line">        {</div>
<div class="line">            memcpy(materialHeaders[i].m_SpecularMapMod, <span class="keywordtype">object</span>.m_Materials[matIndex].specular_texopt.scale, <span class="keyword">sizeof</span>(materialHeaders[i].m_SpecularMapMod));</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (<span class="keywordtype">object</span>.m_Materials[matIndex].specular_texopt.turbulence[0] == 0.0f)</div>
<div class="line">            {</div>
<div class="line">                materialHeaders[i].m_SpecularValMod = 1.0f;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                memcpy(&amp;materialHeaders[i].m_SpecularValMod, <span class="keywordtype">object</span>.m_Materials[matIndex].specular_texopt.turbulence, <span class="keyword">sizeof</span>(materialHeaders[i].m_SpecularValMod));</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            ++numDataHeaders;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            memset(&amp;materialHeaders[i].m_SpecularValMod, 0, <span class="keyword">sizeof</span>(materialHeaders[i].m_SpecularValMod));</div>
<div class="line">            memset(materialHeaders[i].m_SpecularMapMod, 0, <span class="keyword">sizeof</span>(materialHeaders[i].m_SpecularMapMod));</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Emissive */</span></div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keywordtype">object</span>.m_Materials[matIndex].emissive_texname.size())</div>
<div class="line">        {</div>
<div class="line">            memcpy(materialHeaders[i].m_EmissiveMapMod, <span class="keywordtype">object</span>.m_Materials[matIndex].emissive_texopt.scale, <span class="keyword">sizeof</span>(materialHeaders[i].m_EmissiveMapMod));</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (<span class="keywordtype">object</span>.m_Materials[matIndex].emissive_texopt.turbulence[0] == 0.0f &amp;&amp;</div>
<div class="line">                <span class="keywordtype">object</span>.m_Materials[matIndex].emissive_texopt.turbulence[1] == 0.0f &amp;&amp;</div>
<div class="line">                <span class="keywordtype">object</span>.m_Materials[matIndex].emissive_texopt.turbulence[2] == 0.0f)</div>
<div class="line">            {</div>
<div class="line">                materialHeaders[i].m_EmissiveValMod[0] = 1.0f;</div>
<div class="line">                materialHeaders[i].m_EmissiveValMod[1] = 1.0f;</div>
<div class="line">                materialHeaders[i].m_EmissiveValMod[2] = 1.0f;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                memcpy(materialHeaders[i].m_EmissiveValMod, <span class="keywordtype">object</span>.m_Materials[matIndex].emissive_texopt.turbulence, <span class="keyword">sizeof</span>(materialHeaders[i].m_EmissiveValMod));</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            ++numDataHeaders;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            memset(materialHeaders[i].m_EmissiveValMod, 0, <span class="keyword">sizeof</span>(materialHeaders[i].m_EmissiveValMod));</div>
<div class="line">            memset(materialHeaders[i].m_EmissiveMapMod, 0, <span class="keyword">sizeof</span>(materialHeaders[i].m_EmissiveMapMod));</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Roughness */</span></div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keywordtype">object</span>.m_Materials[matIndex].roughness_texname.size())</div>
<div class="line">        {</div>
<div class="line">            memcpy(materialHeaders[i].m_RoughnessMapMod, <span class="keywordtype">object</span>.m_Materials[matIndex].roughness_texopt.scale, <span class="keyword">sizeof</span>(materialHeaders[i].m_RoughnessMapMod));</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (<span class="keywordtype">object</span>.m_Materials[matIndex].roughness_texopt.turbulence[0] == 0.0f)</div>
<div class="line">            {</div>
<div class="line">                materialHeaders[i].m_RoughnessValMod = 1.0f;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                memcpy(&amp;materialHeaders[i].m_RoughnessValMod, <span class="keywordtype">object</span>.m_Materials[matIndex].roughness_texopt.turbulence, <span class="keyword">sizeof</span>(materialHeaders[i].m_RoughnessValMod));</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            ++numDataHeaders;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            memset(&amp;materialHeaders[i].m_RoughnessValMod, 0, <span class="keyword">sizeof</span>(materialHeaders[i].m_RoughnessValMod));</div>
<div class="line">            memset(materialHeaders[i].m_RoughnessMapMod, 0, <span class="keyword">sizeof</span>(materialHeaders[i].m_RoughnessMapMod));</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Roughness */</span></div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keywordtype">object</span>.m_Materials[matIndex].metallic_texname.size())</div>
<div class="line">        {</div>
<div class="line">            memcpy(materialHeaders[i].m_MetallicMapMod, <span class="keywordtype">object</span>.m_Materials[matIndex].metallic_texopt.scale, <span class="keyword">sizeof</span>(materialHeaders[i].m_MetallicMapMod));</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (<span class="keywordtype">object</span>.m_Materials[matIndex].metallic_texopt.turbulence[0] == 0.0f)</div>
<div class="line">            {</div>
<div class="line">                materialHeaders[i].m_MetallicValMod = 1.0f;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                memcpy(&amp;materialHeaders[i].m_MetallicValMod, <span class="keywordtype">object</span>.m_Materials[matIndex].metallic_texopt.turbulence, <span class="keyword">sizeof</span>(materialHeaders[i].m_MetallicValMod));</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            ++numDataHeaders;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            memset(&amp;materialHeaders[i].m_MetallicValMod, 0, <span class="keyword">sizeof</span>(materialHeaders[i].m_MetallicValMod));</div>
<div class="line">            memset(materialHeaders[i].m_MetallicMapMod, 0, <span class="keyword">sizeof</span>(materialHeaders[i].m_MetallicMapMod));</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Normals */</span></div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keywordtype">object</span>.m_Materials[matIndex].normal_texname.size())</div>
<div class="line">        {</div>
<div class="line">            memcpy(materialHeaders[i].m_NormalMapMod, <span class="keywordtype">object</span>.m_Materials[matIndex].normal_texopt.scale, <span class="keyword">sizeof</span>(materialHeaders[i].m_NormalMapMod));</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (<span class="keywordtype">object</span>.m_Materials[matIndex].normal_texopt.turbulence[0] == 0.0f &amp;&amp;</div>
<div class="line">                <span class="keywordtype">object</span>.m_Materials[matIndex].normal_texopt.turbulence[1] == 0.0f &amp;&amp;</div>
<div class="line">                <span class="keywordtype">object</span>.m_Materials[matIndex].normal_texopt.turbulence[2] == 0.0f)</div>
<div class="line">            {</div>
<div class="line">                materialHeaders[i].m_NormalValMod[0] = 1.0f;</div>
<div class="line">                materialHeaders[i].m_NormalValMod[1] = 1.0f;</div>
<div class="line">                materialHeaders[i].m_NormalValMod[2] = 1.0f;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                memcpy(materialHeaders[i].m_NormalValMod, <span class="keywordtype">object</span>.m_Materials[matIndex].normal_texopt.turbulence, <span class="keyword">sizeof</span>(materialHeaders[i].m_NormalValMod));</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            ++numDataHeaders;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            memset(materialHeaders[i].m_NormalValMod, 0, <span class="keyword">sizeof</span>(materialHeaders[i].m_NormalValMod));</div>
<div class="line">            memset(materialHeaders[i].m_NormalMapMod, 0, <span class="keyword">sizeof</span>(materialHeaders[i].m_NormalMapMod));</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Alpha Map */</span></div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keywordtype">object</span>.m_Materials[matIndex].alpha_texname.size())</div>
<div class="line">        {</div>
<div class="line">            memcpy(materialHeaders[i].m_AlphaMapMod, <span class="keywordtype">object</span>.m_Materials[matIndex].alpha_texopt.scale, <span class="keyword">sizeof</span>(materialHeaders[i].m_AlphaMapMod));</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (<span class="keywordtype">object</span>.m_Materials[matIndex].alpha_texopt.turbulence[0] == 0.0f)</div>
<div class="line">            {</div>
<div class="line">                materialHeaders[i].m_AlphaValMod = 1.0f;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                memcpy(&amp;materialHeaders[i].m_AlphaValMod, <span class="keywordtype">object</span>.m_Materials[matIndex].alpha_texopt.turbulence, <span class="keyword">sizeof</span>(materialHeaders[i].m_AlphaValMod));</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            ++numDataHeaders;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            memset(&amp;materialHeaders[i].m_AlphaValMod, 0, <span class="keyword">sizeof</span>(materialHeaders[i].m_AlphaValMod));</div>
<div class="line">            memset(materialHeaders[i].m_AlphaMapMod, 0, <span class="keyword">sizeof</span>(materialHeaders[i].m_AlphaMapMod));</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        materialBlockHeader.m_pMaterialOffsets[i] = currentOffset;</div>
<div class="line"> </div>
<div class="line">        currentOffset += <span class="keyword">sizeof</span>(PBRModelBinary::MaterialHeader);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    dataHeaders.resize(numDataHeaders);</div>
<div class="line"> </div>
<div class="line">    uint32_t currentDataHeader = 0;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Setup the data headers for each mesh */</span></div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; <span class="keywordtype">object</span>.m_Meshes.size(); ++i)</div>
<div class="line">    {</div>
<div class="line">        WaveFrontMeshData* meshData = <span class="keywordtype">object</span>.m_Meshes[i];</div>
<div class="line">        PBRModelBinary::MeshHeader&amp; meshHeader = meshHeaders[i];</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (meshData-&gt;m_Indices.size())</div>
<div class="line">        {</div>
<div class="line">            SetupDataHeader(dataHeaders[currentDataHeader],</div>
<div class="line">                            meshData-&gt;m_Indices.size() * <span class="keyword">sizeof</span>(meshData-&gt;m_Indices[0]),</div>
<div class="line">                            &amp;meshData-&gt;m_Indices[0]);</div>
<div class="line"> </div>
<div class="line">            meshHeader.m_IndexOffset = currentOffset;</div>
<div class="line">            currentOffset += <span class="keyword">sizeof</span>(dataHeaders[currentDataHeader].m_DataSize) + dataHeaders[currentDataHeader].m_DataSize + dataHeaders[currentDataHeader].m_PaddingBytes;</div>
<div class="line"> </div>
<div class="line">            ++currentDataHeader;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (meshData-&gt;m_Positions.size())</div>
<div class="line">        {</div>
<div class="line">            SetupDataHeader(dataHeaders[currentDataHeader],</div>
<div class="line">                            meshData-&gt;m_Positions.size() * <span class="keyword">sizeof</span>(meshData-&gt;m_Positions[0]),</div>
<div class="line">                            &amp;meshData-&gt;m_Positions[0]);</div>
<div class="line"> </div>
<div class="line">            meshHeader.m_PositionOffset = currentOffset;</div>
<div class="line">            currentOffset += <span class="keyword">sizeof</span>(dataHeaders[currentDataHeader].m_DataSize) + dataHeaders[currentDataHeader].m_DataSize + dataHeaders[currentDataHeader].m_PaddingBytes;</div>
<div class="line"> </div>
<div class="line">            ++currentDataHeader;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (meshData-&gt;m_Normals.size())</div>
<div class="line">        {</div>
<div class="line">            SetupDataHeader(dataHeaders[currentDataHeader],</div>
<div class="line">                            meshData-&gt;m_Normals.size() * <span class="keyword">sizeof</span>(meshData-&gt;m_Normals[0]),</div>
<div class="line">                            &amp;meshData-&gt;m_Normals[0]);</div>
<div class="line"> </div>
<div class="line">            meshHeader.m_NormalOffset = currentOffset;</div>
<div class="line">            currentOffset += <span class="keyword">sizeof</span>(dataHeaders[currentDataHeader].m_DataSize) + dataHeaders[currentDataHeader].m_DataSize + dataHeaders[currentDataHeader].m_PaddingBytes;</div>
<div class="line"> </div>
<div class="line">            ++currentDataHeader;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (meshData-&gt;m_TexCoords.size())</div>
<div class="line">        {</div>
<div class="line">            SetupDataHeader(dataHeaders[currentDataHeader],</div>
<div class="line">                            meshData-&gt;m_TexCoords.size() * <span class="keyword">sizeof</span>(meshData-&gt;m_TexCoords[0]),</div>
<div class="line">                            &amp;meshData-&gt;m_TexCoords[0]);</div>
<div class="line"> </div>
<div class="line">            meshHeader.m_TexCoordOffset = currentOffset;</div>
<div class="line">            currentOffset += <span class="keyword">sizeof</span>(dataHeaders[currentDataHeader].m_DataSize) + dataHeaders[currentDataHeader].m_DataSize + dataHeaders[currentDataHeader].m_PaddingBytes;</div>
<div class="line"> </div>
<div class="line">            ++currentDataHeader;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (meshData-&gt;m_Tangents.size())</div>
<div class="line">        {</div>
<div class="line">            SetupDataHeader(dataHeaders[currentDataHeader],</div>
<div class="line">                            meshData-&gt;m_Tangents.size() * <span class="keyword">sizeof</span>(meshData-&gt;m_Tangents[0]),</div>
<div class="line">                            &amp;meshData-&gt;m_Tangents[0]);</div>
<div class="line"> </div>
<div class="line">            meshHeader.m_TangentOffset = currentOffset;</div>
<div class="line">            currentOffset += <span class="keyword">sizeof</span>(dataHeaders[currentDataHeader].m_DataSize) + dataHeaders[currentDataHeader].m_DataSize + dataHeaders[currentDataHeader].m_PaddingBytes;</div>
<div class="line"> </div>
<div class="line">            ++currentDataHeader;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (meshData-&gt;m_Binormals.size())</div>
<div class="line">        {</div>
<div class="line">            SetupDataHeader(dataHeaders[currentDataHeader],</div>
<div class="line">                            meshData-&gt;m_Binormals.size() * <span class="keyword">sizeof</span>(meshData-&gt;m_Binormals[0]),</div>
<div class="line">                            &amp;meshData-&gt;m_Binormals[0]);</div>
<div class="line"> </div>
<div class="line">            meshHeader.m_BinormalOffset = currentOffset;</div>
<div class="line">            currentOffset += <span class="keyword">sizeof</span>(dataHeaders[currentDataHeader].m_DataSize) + dataHeaders[currentDataHeader].m_DataSize + dataHeaders[currentDataHeader].m_PaddingBytes;</div>
<div class="line"> </div>
<div class="line">            ++currentDataHeader;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Num Mesh Data headers: &quot;</span> &lt;&lt; currentDataHeader &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Setup the data headers for each material */</span></div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; <span class="keywordtype">object</span>.m_Meshes.size(); ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> tinyobj::material_t&amp; materialData = <span class="keywordtype">object</span>.m_Materials[<span class="keywordtype">object</span>.m_Meshes[i]-&gt;m_MaterialIndex];</div>
<div class="line">        PBRModelBinary::MaterialHeader&amp; materialHeader = materialHeaders[i];</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (materialData.diffuse_texname.size())</div>
<div class="line">        {</div>
<div class="line">            SetupDataHeader(dataHeaders[currentDataHeader],</div>
<div class="line">                            materialData.diffuse_texname.size(),</div>
<div class="line">                            materialData.diffuse_texname.c_str());</div>
<div class="line"> </div>
<div class="line">            materialHeader.m_DiffuseTexNameOffset = currentOffset;</div>
<div class="line">            currentOffset += <span class="keyword">sizeof</span>(dataHeaders[currentDataHeader].m_DataSize) + dataHeaders[currentDataHeader].m_DataSize + dataHeaders[currentDataHeader].m_PaddingBytes;</div>
<div class="line"> </div>
<div class="line">            ++currentDataHeader;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (materialData.specular_texname.size())</div>
<div class="line">        {</div>
<div class="line">            SetupDataHeader(dataHeaders[currentDataHeader],</div>
<div class="line">                            materialData.specular_texname.size(),</div>
<div class="line">                            materialData.specular_texname.c_str());</div>
<div class="line"> </div>
<div class="line">            materialHeader.m_SpecularTexNameOffset = currentOffset;</div>
<div class="line">            currentOffset += <span class="keyword">sizeof</span>(dataHeaders[currentDataHeader].m_DataSize) + dataHeaders[currentDataHeader].m_DataSize + dataHeaders[currentDataHeader].m_PaddingBytes;</div>
<div class="line"> </div>
<div class="line">            ++currentDataHeader;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (materialData.emissive_texname.size())</div>
<div class="line">        {</div>
<div class="line">            SetupDataHeader(dataHeaders[currentDataHeader],</div>
<div class="line">                            materialData.emissive_texname.size(),</div>
<div class="line">                            materialData.emissive_texname.c_str());</div>
<div class="line"> </div>
<div class="line">            materialHeader.m_EmissiveTexNameOffset = currentOffset;</div>
<div class="line">            currentOffset += <span class="keyword">sizeof</span>(dataHeaders[currentDataHeader].m_DataSize) + dataHeaders[currentDataHeader].m_DataSize + dataHeaders[currentDataHeader].m_PaddingBytes;</div>
<div class="line"> </div>
<div class="line">            ++currentDataHeader;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (materialData.roughness_texname.size())</div>
<div class="line">        {</div>
<div class="line">            SetupDataHeader(dataHeaders[currentDataHeader],</div>
<div class="line">                            materialData.roughness_texname.size(),</div>
<div class="line">                            materialData.roughness_texname.c_str());</div>
<div class="line"> </div>
<div class="line">            materialHeader.m_RoughnessTexNameOffset = currentOffset;</div>
<div class="line">            currentOffset += <span class="keyword">sizeof</span>(dataHeaders[currentDataHeader].m_DataSize) + dataHeaders[currentDataHeader].m_DataSize + dataHeaders[currentDataHeader].m_PaddingBytes;</div>
<div class="line"> </div>
<div class="line">            ++currentDataHeader;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (materialData.metallic_texname.size())</div>
<div class="line">        {</div>
<div class="line">            SetupDataHeader(dataHeaders[currentDataHeader],</div>
<div class="line">                            materialData.metallic_texname.size(),</div>
<div class="line">                            materialData.metallic_texname.c_str());</div>
<div class="line"> </div>
<div class="line">            materialHeader.m_MetallicTexNameOffset = currentOffset;</div>
<div class="line">            currentOffset += <span class="keyword">sizeof</span>(dataHeaders[currentDataHeader].m_DataSize) + dataHeaders[currentDataHeader].m_DataSize + dataHeaders[currentDataHeader].m_PaddingBytes;</div>
<div class="line"> </div>
<div class="line">            ++currentDataHeader;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (materialData.normal_texname.size())</div>
<div class="line">        {</div>
<div class="line">            SetupDataHeader(dataHeaders[currentDataHeader],</div>
<div class="line">                            materialData.normal_texname.size(),</div>
<div class="line">                            materialData.normal_texname.c_str());</div>
<div class="line"> </div>
<div class="line">            materialHeader.m_NormalTexNameOffset = currentOffset;</div>
<div class="line">            currentOffset += <span class="keyword">sizeof</span>(dataHeaders[currentDataHeader].m_DataSize) + dataHeaders[currentDataHeader].m_DataSize + dataHeaders[currentDataHeader].m_PaddingBytes;</div>
<div class="line"> </div>
<div class="line">            ++currentDataHeader;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (materialData.alpha_texname.size())</div>
<div class="line">        {</div>
<div class="line">            SetupDataHeader(dataHeaders[currentDataHeader],</div>
<div class="line">                            materialData.alpha_texname.size(),</div>
<div class="line">                            materialData.alpha_texname.c_str());</div>
<div class="line"> </div>
<div class="line">            materialHeader.m_AlphaTexNameOffset = currentOffset;</div>
<div class="line">            currentOffset += <span class="keyword">sizeof</span>(dataHeaders[currentDataHeader].m_DataSize) + dataHeaders[currentDataHeader].m_DataSize + dataHeaders[currentDataHeader].m_PaddingBytes;</div>
<div class="line"> </div>
<div class="line">            ++currentDataHeader;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Num Total Data headers: &quot;</span> &lt;&lt; currentDataHeader &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;End processing headers\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* File Header */</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Write file header\n&quot;</span>;</div>
<div class="line">    fwrite(&amp;fileHeader, <span class="keyword">sizeof</span>(PBRModelBinary::FileHeader), 1, outputFile);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Mesh Block Header */</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Write mesh block header\n&quot;</span>;</div>
<div class="line">    fwrite(&amp;meshBlockHeader.m_NumMeshes, <span class="keyword">sizeof</span>(PBRModelBinary::MeshBlockHeader::m_NumMeshes), 1, outputFile);</div>
<div class="line">    fwrite(meshBlockHeader.m_pMeshOffsets, <span class="keyword">sizeof</span>(uint64_t), <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(meshBlockHeader.m_NumMeshes), outputFile);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Material Block Header */</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Write material block header\n&quot;</span>;</div>
<div class="line">    fwrite(&amp;materialBlockHeader.m_NumMaterials, <span class="keyword">sizeof</span>(PBRModelBinary::MaterialBlockHeader::m_NumMaterials), 1, outputFile);</div>
<div class="line">    fwrite(materialBlockHeader.m_pMaterialOffsets, <span class="keyword">sizeof</span>(uint64_t), <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(materialBlockHeader.m_NumMaterials), outputFile);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Mesh Headers */</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Write mesh headers\n&quot;</span>;</div>
<div class="line">    fwrite(&amp;meshHeaders[0], <span class="keyword">sizeof</span>(PBRModelBinary::MeshHeader), meshHeaders.size(), outputFile);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Material Headers */</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Write material headers\n&quot;</span>;</div>
<div class="line">    fwrite(&amp;materialHeaders[0], <span class="keyword">sizeof</span>(PBRModelBinary::MaterialHeader), materialHeaders.size(), outputFile);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Data */</span></div>
<div class="line">    <span class="keywordtype">char</span> dummyPadding[8] = { 0 };</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Write data headers: &quot;</span> &lt;&lt; dataHeaders.size() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; dataHeaders.size(); ++i)</div>
<div class="line">    {</div>
<div class="line">        fwrite(&amp;dataHeaders[i].m_DataSize, <span class="keyword">sizeof</span>(PBRModelBinary::DataHeader::m_DataSize), 1, outputFile);</div>
<div class="line">        fwrite(dataHeaders[i].m_pData, 1, <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(dataHeaders[i].m_DataSize), outputFile);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span>(dataHeaders[i].m_PaddingBytes)</div>
<div class="line">            fwrite(dummyPadding, 1, dataHeaders[i].m_PaddingBytes, outputFile);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    fclose(outputFile);</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Finished writing file\n&quot;</span>;</div>
<div class="line">    free(meshBlockHeader.m_pMeshOffsets);</div>
<div class="line">    free(materialBlockHeader.m_pMaterialOffsets);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}<span class="comment">//NOLINT(impl/function_size)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * WaveFrontObjFileManager::SetupDataHeader</span></div>
<div class="line"><span class="comment"> * ----------------------------------------</span></div>
<div class="line"><span class="comment"> * Sets up a data header with the given data and size.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> WaveFrontObjFileManager::SetupDataHeader(PBRModelBinary::DataHeader&amp; dataHeader, <span class="keyword">const</span> uint64_t&amp; dataSize, <span class="keyword">const</span> <span class="keywordtype">void</span>* data)</div>
<div class="line">{</div>
<div class="line">    dataHeader.m_DataSize = dataSize;</div>
<div class="line">    dataHeader.m_pData = data;</div>
<div class="line">    dataHeader.m_PaddingBytes = (8 - (dataHeader.m_DataSize % 8)) % 8;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * WaveFrontMeshData::SetupData</span></div>
<div class="line"><span class="comment"> * -----------------------------</span></div>
<div class="line"><span class="comment"> * Copies the relevent data out of the tinyobj shape</span></div>
<div class="line"><span class="comment"> * object and calculates the tangent/binormals if needed.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> WaveFrontMeshData::SetupData(<span class="keyword">const</span> tinyobj::shape_t&amp; shape, <span class="keyword">const</span> tinyobj::attrib_t&amp; attrib)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">int</span> numMeshes = 0;</div>
<div class="line">    numMeshes += 1;</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Total Meshes: &quot;</span> &lt;&lt; numMeshes &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    m_MaterialIndex = shape.mesh.material_ids[0];</div>
<div class="line"> </div>
<div class="line">    std::map&lt;std::tuple&lt;uint32_t, uint32_t, uint32_t&gt;, <span class="keywordtype">int</span>&gt; vertexMap;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Copy over the position, normal, and texture coordinate data */</span></div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; shape.mesh.indices.size(); ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> tinyobj::index_t&amp; index = shape.mesh.indices[i];</div>
<div class="line"> </div>
<div class="line">        std::tuple&lt;uint32_t, uint32_t, uint32_t&gt; vertIndices = std::tuple&lt;uint32_t, uint32_t, uint32_t&gt;(index.vertex_index, index.normal_index, index.texcoord_index);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (vertexMap.count(vertIndices) == 0)</div>
<div class="line">        {</div>
<div class="line">            vertexMap[vertIndices] = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(m_Positions.size() / 3);</div>
<div class="line"> </div>
<div class="line">            uint32_t baseVertexIndex = index.vertex_index * 3;</div>
<div class="line">            uint32_t baseNormalIndex = index.normal_index * 3;</div>
<div class="line">            uint32_t baseTexCoordIndex = index.texcoord_index * 2;</div>
<div class="line"> </div>
<div class="line">            m_Positions.push_back(attrib.vertices[baseVertexIndex]);</div>
<div class="line">            m_Positions.push_back(attrib.vertices[baseVertexIndex + 1]);</div>
<div class="line">            m_Positions.push_back(attrib.vertices[baseVertexIndex + 2]);</div>
<div class="line"> </div>
<div class="line">            m_Normals.push_back(attrib.normals[baseNormalIndex]);</div>
<div class="line">            m_Normals.push_back(attrib.normals[baseNormalIndex + 1]);</div>
<div class="line">            m_Normals.push_back(attrib.normals[baseNormalIndex + 2]);</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (attrib.texcoords.size())</div>
<div class="line">            {</div>
<div class="line">                m_TexCoords.push_back(attrib.texcoords[baseTexCoordIndex]);</div>
<div class="line">                m_TexCoords.push_back(attrib.texcoords[baseTexCoordIndex + 1]);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        m_Indices.push_back(vertexMap[vertIndices]);</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    m_NumIndices = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(m_Indices.size());</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Calculate the per vertex tangents and binormals */</span></div>
<div class="line">    <span class="keywordflow">if</span> (m_Normals.size() &amp;&amp; m_TexCoords.size())</div>
<div class="line">    {</div>
<div class="line">        std::vector&lt;std::vector&lt;nn::util::Vector3f&gt; &gt; tangents;</div>
<div class="line">        std::vector&lt;std::vector&lt;nn::util::Vector3f&gt; &gt; binormals;</div>
<div class="line"> </div>
<div class="line">        tangents.resize(m_Positions.size() / 3);</div>
<div class="line">        binormals.resize(m_Positions.size() / 3);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; m_NumIndices; i += 3)</div>
<div class="line">        {</div>
<div class="line">            uint32_t vtxIdx0 = m_Indices[i] * 3;</div>
<div class="line">            uint32_t vtxIdx1 = m_Indices[i + 1] * 3;</div>
<div class="line">            uint32_t vtxIdx2 = m_Indices[i + 2] * 3;</div>
<div class="line">            uint32_t tcIdx0 = m_Indices[i] * 2;</div>
<div class="line">            uint32_t tcIdx1 = m_Indices[i + 1] * 2;</div>
<div class="line">            uint32_t tcIdx2 = m_Indices[i + 2] * 2;</div>
<div class="line"> </div>
<div class="line">            <a name="_a0"></a><a class="code" href="classnn_1_1util_1_1_vector3f.html">nn::util::Vector3f</a> v0 = <a class="code" href="classnn_1_1util_1_1_vector3f.html">nn::util::Vector3f</a>(m_Positions[vtxIdx0], m_Positions[vtxIdx0 + 1], m_Positions[vtxIdx0 + 2]);</div>
<div class="line">            <a class="code" href="classnn_1_1util_1_1_vector3f.html">nn::util::Vector3f</a> v1 = <a class="code" href="classnn_1_1util_1_1_vector3f.html">nn::util::Vector3f</a>(m_Positions[vtxIdx1], m_Positions[vtxIdx1 + 1], m_Positions[vtxIdx1 + 2]);</div>
<div class="line">            <a class="code" href="classnn_1_1util_1_1_vector3f.html">nn::util::Vector3f</a> v2 = <a class="code" href="classnn_1_1util_1_1_vector3f.html">nn::util::Vector3f</a>(m_Positions[vtxIdx2], m_Positions[vtxIdx2 + 1], m_Positions[vtxIdx2 + 2]);</div>
<div class="line"> </div>
<div class="line">            <a class="code" href="classnn_1_1util_1_1_vector3f.html">nn::util::Vector3f</a> t0 = <a class="code" href="classnn_1_1util_1_1_vector3f.html">nn::util::Vector3f</a>(m_TexCoords[tcIdx0], m_TexCoords[tcIdx0 + 1], 0.0f);</div>
<div class="line">            <a class="code" href="classnn_1_1util_1_1_vector3f.html">nn::util::Vector3f</a> t1 = <a class="code" href="classnn_1_1util_1_1_vector3f.html">nn::util::Vector3f</a>(m_TexCoords[tcIdx1], m_TexCoords[tcIdx1 + 1], 0.0f);</div>
<div class="line">            <a class="code" href="classnn_1_1util_1_1_vector3f.html">nn::util::Vector3f</a> t2 = <a class="code" href="classnn_1_1util_1_1_vector3f.html">nn::util::Vector3f</a>(m_TexCoords[tcIdx2], m_TexCoords[tcIdx2 + 1], 0.0f);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">            <a class="code" href="classnn_1_1util_1_1_vector3f.html">nn::util::Vector3f</a> edge1 = v1 - v0;</div>
<div class="line">            <a class="code" href="classnn_1_1util_1_1_vector3f.html">nn::util::Vector3f</a> edge2 = v2 - v0;</div>
<div class="line"> </div>
<div class="line">            <a class="code" href="classnn_1_1util_1_1_vector3f.html">nn::util::Vector3f</a> deltaUV1 = t1 - t0;</div>
<div class="line">            <a class="code" href="classnn_1_1util_1_1_vector3f.html">nn::util::Vector3f</a> deltaUV2 = t2 - t0;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordtype">float</span> denom = 1.0f / (deltaUV1.<a name="a1"></a><a class="code" href="classnn_1_1util_1_1_vector3f.html#a2f69d4207575e05d3ddd7d565194905b">GetX</a>() * deltaUV2.<a name="a2"></a><a class="code" href="classnn_1_1util_1_1_vector3f.html#a3d9bc410087239e149cfedbd4daf5541">GetY</a>() - deltaUV2.<a class="code" href="classnn_1_1util_1_1_vector3f.html#a2f69d4207575e05d3ddd7d565194905b">GetX</a>() * deltaUV1.<a class="code" href="classnn_1_1util_1_1_vector3f.html#a3d9bc410087239e149cfedbd4daf5541">GetY</a>());</div>
<div class="line"> </div>
<div class="line">            <a class="code" href="classnn_1_1util_1_1_vector3f.html">nn::util::Vector3f</a> tangent;</div>
<div class="line">            tangent.<a name="a3"></a><a class="code" href="classnn_1_1util_1_1_vector3f.html#a5fa11ce5b682862607861f3339ab87d1">Set</a>(denom * (deltaUV2.<a class="code" href="classnn_1_1util_1_1_vector3f.html#a3d9bc410087239e149cfedbd4daf5541">GetY</a>() * edge1.<a class="code" href="classnn_1_1util_1_1_vector3f.html#a2f69d4207575e05d3ddd7d565194905b">GetX</a>() - deltaUV1.<a class="code" href="classnn_1_1util_1_1_vector3f.html#a3d9bc410087239e149cfedbd4daf5541">GetY</a>() * edge2.<a class="code" href="classnn_1_1util_1_1_vector3f.html#a2f69d4207575e05d3ddd7d565194905b">GetX</a>()),</div>
<div class="line">                denom * (deltaUV2.<a class="code" href="classnn_1_1util_1_1_vector3f.html#a3d9bc410087239e149cfedbd4daf5541">GetY</a>() * edge1.<a class="code" href="classnn_1_1util_1_1_vector3f.html#a3d9bc410087239e149cfedbd4daf5541">GetY</a>() - deltaUV1.<a class="code" href="classnn_1_1util_1_1_vector3f.html#a3d9bc410087239e149cfedbd4daf5541">GetY</a>() * edge2.<a class="code" href="classnn_1_1util_1_1_vector3f.html#a3d9bc410087239e149cfedbd4daf5541">GetY</a>()),</div>
<div class="line">                denom * (deltaUV2.<a class="code" href="classnn_1_1util_1_1_vector3f.html#a3d9bc410087239e149cfedbd4daf5541">GetY</a>() * edge1.<a name="a4"></a><a class="code" href="classnn_1_1util_1_1_vector3f.html#af8970ad1e115501b853e2ae4245f5e22">GetZ</a>() - deltaUV1.<a class="code" href="classnn_1_1util_1_1_vector3f.html#a3d9bc410087239e149cfedbd4daf5541">GetY</a>() * edge2.<a class="code" href="classnn_1_1util_1_1_vector3f.html#af8970ad1e115501b853e2ae4245f5e22">GetZ</a>()));</div>
<div class="line"> </div>
<div class="line">            tangent.<a name="a5"></a><a class="code" href="classnn_1_1util_1_1_vector3f.html#a0ce10600f2333514e5214fdcd15253ab">Normalize</a>();</div>
<div class="line">            tangents[m_Indices[i]].push_back(tangent);</div>
<div class="line">            tangents[m_Indices[i + 1]].push_back(tangent);</div>
<div class="line">            tangents[m_Indices[i + 2]].push_back(tangent);</div>
<div class="line"> </div>
<div class="line">            <a class="code" href="classnn_1_1util_1_1_vector3f.html">nn::util::Vector3f</a> binormal;</div>
<div class="line">            binormal.<a class="code" href="classnn_1_1util_1_1_vector3f.html#a5fa11ce5b682862607861f3339ab87d1">Set</a>(denom * (-1.0f * deltaUV2.<a class="code" href="classnn_1_1util_1_1_vector3f.html#a2f69d4207575e05d3ddd7d565194905b">GetX</a>() * edge1.<a class="code" href="classnn_1_1util_1_1_vector3f.html#a2f69d4207575e05d3ddd7d565194905b">GetX</a>() + deltaUV1.<a class="code" href="classnn_1_1util_1_1_vector3f.html#a2f69d4207575e05d3ddd7d565194905b">GetX</a>() * edge2.<a class="code" href="classnn_1_1util_1_1_vector3f.html#a2f69d4207575e05d3ddd7d565194905b">GetX</a>()),</div>
<div class="line">                denom * (-1.0f * deltaUV2.<a class="code" href="classnn_1_1util_1_1_vector3f.html#a2f69d4207575e05d3ddd7d565194905b">GetX</a>() * edge1.<a class="code" href="classnn_1_1util_1_1_vector3f.html#a3d9bc410087239e149cfedbd4daf5541">GetY</a>() + deltaUV1.<a class="code" href="classnn_1_1util_1_1_vector3f.html#a2f69d4207575e05d3ddd7d565194905b">GetX</a>() * edge2.<a class="code" href="classnn_1_1util_1_1_vector3f.html#a3d9bc410087239e149cfedbd4daf5541">GetY</a>()),</div>
<div class="line">                denom * (-1.0f * deltaUV2.<a class="code" href="classnn_1_1util_1_1_vector3f.html#a2f69d4207575e05d3ddd7d565194905b">GetX</a>() * edge1.<a class="code" href="classnn_1_1util_1_1_vector3f.html#af8970ad1e115501b853e2ae4245f5e22">GetZ</a>() + deltaUV1.<a class="code" href="classnn_1_1util_1_1_vector3f.html#a2f69d4207575e05d3ddd7d565194905b">GetX</a>() * edge2.<a class="code" href="classnn_1_1util_1_1_vector3f.html#af8970ad1e115501b853e2ae4245f5e22">GetZ</a>()));</div>
<div class="line"> </div>
<div class="line">            binormal.<a class="code" href="classnn_1_1util_1_1_vector3f.html#a0ce10600f2333514e5214fdcd15253ab">Normalize</a>();</div>
<div class="line">            binormals[m_Indices[i]].push_back(binormal);</div>
<div class="line">            binormals[m_Indices[i + 1]].push_back(binormal);</div>
<div class="line">            binormals[m_Indices[i + 2]].push_back(binormal);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; tangents.size(); ++i)</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="classnn_1_1util_1_1_vector3f.html">nn::util::Vector3f</a> finalTangent = <a class="code" href="classnn_1_1util_1_1_vector3f.html">nn::util::Vector3f</a>(0.0f, 0.0f, 0.0f);</div>
<div class="line">            <a class="code" href="classnn_1_1util_1_1_vector3f.html">nn::util::Vector3f</a> finalBinormal = <a class="code" href="classnn_1_1util_1_1_vector3f.html">nn::util::Vector3f</a>(0.0f, 0.0f, 0.0f);</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (uint32_t j = 0; j &lt; tangents[i].size(); ++j)</div>
<div class="line">            {</div>
<div class="line">                finalTangent += tangents[i][j];</div>
<div class="line">                finalBinormal += binormals[i][j];</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            finalTangent *= 1.0f / <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(tangents[i].size());</div>
<div class="line">            finalBinormal *= 1.0f / <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(binormals[i].size());</div>
<div class="line"> </div>
<div class="line">            finalTangent.<a class="code" href="classnn_1_1util_1_1_vector3f.html#a0ce10600f2333514e5214fdcd15253ab">Normalize</a>();</div>
<div class="line">            finalBinormal.<a class="code" href="classnn_1_1util_1_1_vector3f.html#a0ce10600f2333514e5214fdcd15253ab">Normalize</a>();</div>
<div class="line"> </div>
<div class="line">            m_Tangents.push_back(finalTangent.<a class="code" href="classnn_1_1util_1_1_vector3f.html#a2f69d4207575e05d3ddd7d565194905b">GetX</a>());</div>
<div class="line">            m_Tangents.push_back(finalTangent.<a class="code" href="classnn_1_1util_1_1_vector3f.html#a3d9bc410087239e149cfedbd4daf5541">GetY</a>());</div>
<div class="line">            m_Tangents.push_back(finalTangent.<a class="code" href="classnn_1_1util_1_1_vector3f.html#af8970ad1e115501b853e2ae4245f5e22">GetZ</a>());</div>
<div class="line"> </div>
<div class="line">            m_Binormals.push_back(finalBinormal.<a class="code" href="classnn_1_1util_1_1_vector3f.html#a2f69d4207575e05d3ddd7d565194905b">GetX</a>());</div>
<div class="line">            m_Binormals.push_back(finalBinormal.<a class="code" href="classnn_1_1util_1_1_vector3f.html#a3d9bc410087239e149cfedbd4daf5541">GetY</a>());</div>
<div class="line">            m_Binormals.push_back(finalBinormal.<a class="code" href="classnn_1_1util_1_1_vector3f.html#af8970ad1e115501b853e2ae4245f5e22">GetZ</a>());</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="a_p_b_r_model_binary_file_headers_8h_html"><div class="ttname"><a href="_p_b_r_model_binary_file_headers_8h.html">PBRModelBinaryFileHeaders.h</a></div><div class="ttdoc">This file defines the structure of the converted binary model files.</div></div>
<div class="ttc" id="a_wave_front_obj_file_manager_8h_html"><div class="ttname"><a href="_wave_front_obj_file_manager_8h.html">WaveFrontObjFileManager.h</a></div><div class="ttdoc">This files defines some helper classes for loading, processing, and writing out WaveFrontObj model in...</div></div>
<div class="ttc" id="aclassnn_1_1util_1_1_vector3f_html"><div class="ttname"><a href="classnn_1_1util_1_1_vector3f.html">nn::util::Vector3f</a></div><div class="ttdoc">Class that expresses three-dimensional vectors using a single precision floating number type.</div><div class="ttdef"><b>Definition:</b> util_Vector.h:296</div></div>
<div class="ttc" id="aclassnn_1_1util_1_1_vector3f_html_a0ce10600f2333514e5214fdcd15253ab"><div class="ttname"><a href="classnn_1_1util_1_1_vector3f.html#a0ce10600f2333514e5214fdcd15253ab">nn::util::Vector3f::Normalize</a></div><div class="ttdeci">bool Normalize() NN_NOEXCEPT</div><div class="ttdoc">Normalizes a vector.</div></div>
<div class="ttc" id="aclassnn_1_1util_1_1_vector3f_html_a2f69d4207575e05d3ddd7d565194905b"><div class="ttname"><a href="classnn_1_1util_1_1_vector3f.html#a2f69d4207575e05d3ddd7d565194905b">nn::util::Vector3f::GetX</a></div><div class="ttdeci">float GetX() const NN_NOEXCEPT</div><div class="ttdoc">Gets the x-component.</div></div>
<div class="ttc" id="aclassnn_1_1util_1_1_vector3f_html_a3d9bc410087239e149cfedbd4daf5541"><div class="ttname"><a href="classnn_1_1util_1_1_vector3f.html#a3d9bc410087239e149cfedbd4daf5541">nn::util::Vector3f::GetY</a></div><div class="ttdeci">float GetY() const NN_NOEXCEPT</div><div class="ttdoc">Gets the y-component.</div></div>
<div class="ttc" id="aclassnn_1_1util_1_1_vector3f_html_a5fa11ce5b682862607861f3339ab87d1"><div class="ttname"><a href="classnn_1_1util_1_1_vector3f.html#a5fa11ce5b682862607861f3339ab87d1">nn::util::Vector3f::Set</a></div><div class="ttdeci">void Set(float x, float y, float z) NN_NOEXCEPT</div><div class="ttdoc">Sets the value for each component.</div></div>
<div class="ttc" id="aclassnn_1_1util_1_1_vector3f_html_af8970ad1e115501b853e2ae4245f5e22"><div class="ttname"><a href="classnn_1_1util_1_1_vector3f.html#af8970ad1e115501b853e2ae4245f5e22">nn::util::Vector3f::GetZ</a></div><div class="ttdeci">float GetZ() const NN_NOEXCEPT</div><div class="ttdoc">Gets the z-component.</div></div>
<div class="ttc" id="autil___vector_8h_html"><div class="ttname"><a href="util___vector_8h.html">util_Vector.h</a></div><div class="ttdoc">Provides vector calculations.</div></div>
</div><!-- fragment --> </div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
