<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nn::g3d::MaterialObj Class Reference | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenn.html">nn</a></li><li class="navelem"><a class="el" href="namespacenn_1_1g3d.html">g3d</a></li><li class="navelem"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html">MaterialObj</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="classnn_1_1g3d_1_1_material_obj-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">nn::g3d::MaterialObj Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A material instance.  
 <a href="classnn_1_1g3d_1_1_material_obj.html#details">More...</a></p>

<p><code>#include &lt;nn/g3d/g3d_MaterialObj.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj_1_1_builder.html">Builder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class that builds instances of <code><a class="el" href="classnn_1_1g3d_1_1_material_obj.html" title="A material instance.">MaterialObj</a></code>.  <a href="classnn_1_1g3d_1_1_material_obj_1_1_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj_1_1_initialize_argument.html">InitializeArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <b>The use of internal features is prohibited.</b> Parameters passed to the <code>MaterialObj::Initialize()</code> function for initialization.  <a href="classnn_1_1g3d_1_1_material_obj_1_1_initialize_argument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abbcd31769f7b1963488dba4ca1803664"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#abbcd31769f7b1963488dba4ca1803664">Alignment</a> { <a class="el" href="classnn_1_1g3d_1_1_material_obj.html#abbcd31769f7b1963488dba4ca1803664afbdccd6a3b5d1de2ed79f1b75887b26b">Alignment_Buffer</a> = 8
 }</td></tr>
<tr class="memdesc:abbcd31769f7b1963488dba4ca1803664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Required alignment size of the buffer that is passed when the instance is being built.  <a href="classnn_1_1g3d_1_1_material_obj.html#abbcd31769f7b1963488dba4ca1803664">More...</a><br /></td></tr>
<tr class="separator:abbcd31769f7b1963488dba4ca1803664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f91aab9736ea9fbb276f16ef49c796"><td class="memItemLeft" align="right" valign="top"><a id="a76f91aab9736ea9fbb276f16ef49c796"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a76f91aab9736ea9fbb276f16ef49c796">TextureChangeCallback</a>) (<a class="el" href="classnn_1_1g3d_1_1_material_obj.html">MaterialObj</a> *pMaterialObj, int idxTexture)</td></tr>
<tr class="memdesc:a76f91aab9736ea9fbb276f16ef49c796"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <b>The use of internal features is prohibited.</b> Type of callback called during texture replacement <br /></td></tr>
<tr class="separator:a76f91aab9736ea9fbb276f16ef49c796"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and Destructors</div></td></tr>
<tr class="memitem:aa9e4ffe23a0e1b95c64007350e52af89"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#aa9e4ffe23a0e1b95c64007350e52af89">MaterialObj</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa9e4ffe23a0e1b95c64007350e52af89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classnn_1_1g3d_1_1_material_obj.html#aa9e4ffe23a0e1b95c64007350e52af89">More...</a><br /></td></tr>
<tr class="separator:aa9e4ffe23a0e1b95c64007350e52af89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea88251b4d981611ffd922ea202f873b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#aea88251b4d981611ffd922ea202f873b">CalculateBlockBufferSize</a> (<a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *pDevice) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aea88251b4d981611ffd922ea202f873b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the uniform block size.  <a href="classnn_1_1g3d_1_1_material_obj.html#aea88251b4d981611ffd922ea202f873b">More...</a><br /></td></tr>
<tr class="separator:aea88251b4d981611ffd922ea202f873b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1b10f4ba758f171b771c3d7b12fc4c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#aea1b10f4ba758f171b771c3d7b12fc4c">SetupBlockBuffer</a> (<a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *pDevice, <a class="el" href="namespacenn_1_1gfx.html#ad620d8208dd309eb7c4dd5973a6aeee5">nn::gfx::MemoryPool</a> *pMemoryPool, ptrdiff_t offset, size_t memoryPoolSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aea1b10f4ba758f171b771c3d7b12fc4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passes a memory pool and builds a uniform block.  <a href="classnn_1_1g3d_1_1_material_obj.html#aea1b10f4ba758f171b771c3d7b12fc4c">More...</a><br /></td></tr>
<tr class="separator:aea1b10f4ba758f171b771c3d7b12fc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79af0eaa9e755ffe7e2b1f8ece8b3e54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a79af0eaa9e755ffe7e2b1f8ece8b3e54">CleanupBlockBuffer</a> (<a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *pDevice) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a79af0eaa9e755ffe7e2b1f8ece8b3e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the uniform block.  <a href="classnn_1_1g3d_1_1_material_obj.html#a79af0eaa9e755ffe7e2b1f8ece8b3e54">More...</a><br /></td></tr>
<tr class="separator:a79af0eaa9e755ffe7e2b1f8ece8b3e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Update</div></td></tr>
<tr class="memitem:acb09821f66b8cc37c265e6b8207dea33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#acb09821f66b8cc37c265e6b8207dea33">CalculateMaterial</a> (int bufferIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acb09821f66b8cc37c265e6b8207dea33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates render resources for materials.  <a href="classnn_1_1g3d_1_1_material_obj.html#acb09821f66b8cc37c265e6b8207dea33">More...</a><br /></td></tr>
<tr class="separator:acb09821f66b8cc37c265e6b8207dea33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Getting and Setting</div></td></tr>
<tr class="memitem:a7d4f1b5d0f15bb724c7ec7f0ede41907"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a7d4f1b5d0f15bb724c7ec7f0ede41907">GetBlockBufferAlignment</a> (<a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *pDevice) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7d4f1b5d0f15bb724c7ec7f0ede41907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the alignment required by the uniform block.  <a href="classnn_1_1g3d_1_1_material_obj.html#a7d4f1b5d0f15bb724c7ec7f0ede41907">More...</a><br /></td></tr>
<tr class="separator:a7d4f1b5d0f15bb724c7ec7f0ede41907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83012bf24ce5dafd6fed058a9700975"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnn_1_1g3d_1_1_res_material.html">ResMaterial</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#ac83012bf24ce5dafd6fed058a9700975">GetResource</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac83012bf24ce5dafd6fed058a9700975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a resource.  <a href="classnn_1_1g3d_1_1_material_obj.html#ac83012bf24ce5dafd6fed058a9700975">More...</a><br /></td></tr>
<tr class="separator:ac83012bf24ce5dafd6fed058a9700975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4786cffeac9408ffad4806914664336"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#ad4786cffeac9408ffad4806914664336">GetBufferPtr</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad4786cffeac9408ffad4806914664336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the buffer passed by <code><a class="el" href="classnn_1_1g3d_1_1_material_obj_1_1_builder.html" title="The class that builds instances of MaterialObj.">Builder</a></code> at the time of the build.  <a href="classnn_1_1g3d_1_1_material_obj.html#ad4786cffeac9408ffad4806914664336">More...</a><br /></td></tr>
<tr class="separator:ad4786cffeac9408ffad4806914664336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329d29a9cf9f30106921b7bb7b8b1d54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1gfx.html#ad620d8208dd309eb7c4dd5973a6aeee5">nn::gfx::MemoryPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a329d29a9cf9f30106921b7bb7b8b1d54">GetMemoryPoolPtr</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a329d29a9cf9f30106921b7bb7b8b1d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to the memory pool that was passed when <code><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#aea1b10f4ba758f171b771c3d7b12fc4c" title="Passes a memory pool and builds a uniform block.">SetupBlockBuffer()</a></code> was called.  <a href="classnn_1_1g3d_1_1_material_obj.html#a329d29a9cf9f30106921b7bb7b8b1d54">More...</a><br /></td></tr>
<tr class="separator:a329d29a9cf9f30106921b7bb7b8b1d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c6cf24fef727e9a381eaf4e4e62e91"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a00c6cf24fef727e9a381eaf4e4e62e91">GetMemoryPoolOffset</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a00c6cf24fef727e9a381eaf4e4e62e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the offset of the memory pool that was passed when <code><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#aea1b10f4ba758f171b771c3d7b12fc4c" title="Passes a memory pool and builds a uniform block.">SetupBlockBuffer()</a></code> was called.  <a href="classnn_1_1g3d_1_1_material_obj.html#a00c6cf24fef727e9a381eaf4e4e62e91">More...</a><br /></td></tr>
<tr class="separator:a00c6cf24fef727e9a381eaf4e4e62e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64170b747c33200006836a169e8976c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a64170b747c33200006836a169e8976c3">IsBlockBufferValid</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a64170b747c33200006836a169e8976c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the uniform block has been built.  <a href="classnn_1_1g3d_1_1_material_obj.html#a64170b747c33200006836a169e8976c3">More...</a><br /></td></tr>
<tr class="separator:a64170b747c33200006836a169e8976c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef15d5bfda74edf022aa6337f13d52ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#aef15d5bfda74edf022aa6337f13d52ed">GetMaterialBlock</a> (int bufferIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aef15d5bfda74edf022aa6337f13d52ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the buffer for a uniform block retained by the material.  <a href="classnn_1_1g3d_1_1_material_obj.html#aef15d5bfda74edf022aa6337f13d52ed">More...</a><br /></td></tr>
<tr class="separator:aef15d5bfda74edf022aa6337f13d52ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1e45f79fe756a7ffa9ae72766d0efd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a1c1e45f79fe756a7ffa9ae72766d0efd">GetMaterialBlock</a> (int bufferIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1c1e45f79fe756a7ffa9ae72766d0efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the buffer for a uniform block retained by the material.  <a href="classnn_1_1g3d_1_1_material_obj.html#a1c1e45f79fe756a7ffa9ae72766d0efd">More...</a><br /></td></tr>
<tr class="separator:a1c1e45f79fe756a7ffa9ae72766d0efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0215c9275372e3b367aee550cbed1fb1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a0215c9275372e3b367aee550cbed1fb1">GetMaterialBlockSize</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0215c9275372e3b367aee550cbed1fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of a uniform block retained by the material.  <a href="classnn_1_1g3d_1_1_material_obj.html#a0215c9275372e3b367aee550cbed1fb1">More...</a><br /></td></tr>
<tr class="separator:a0215c9275372e3b367aee550cbed1fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3105fad2aac162f0757d6f81562f9736"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a3105fad2aac162f0757d6f81562f9736">GetBufferingCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3105fad2aac162f0757d6f81562f9736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of uniform blocks for buffering.  <a href="classnn_1_1g3d_1_1_material_obj.html#a3105fad2aac162f0757d6f81562f9736">More...</a><br /></td></tr>
<tr class="separator:a3105fad2aac162f0757d6f81562f9736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c9198a850dfaef396bb14e222f9194"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#ac0c9198a850dfaef396bb14e222f9194">IsBlockSwapEnabled</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac0c9198a850dfaef396bb14e222f9194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether an endian swap will be conducted for the uniform block.  <a href="classnn_1_1g3d_1_1_material_obj.html#ac0c9198a850dfaef396bb14e222f9194">More...</a><br /></td></tr>
<tr class="separator:ac0c9198a850dfaef396bb14e222f9194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b2883e75c53b0c5160861dec317f4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a89b2883e75c53b0c5160861dec317f4d">SetUserPtr</a> (void *pUserPtr) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a89b2883e75c53b0c5160861dec317f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a user pointer.  <a href="classnn_1_1g3d_1_1_material_obj.html#a89b2883e75c53b0c5160861dec317f4d">More...</a><br /></td></tr>
<tr class="separator:a89b2883e75c53b0c5160861dec317f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05873a76698ab49ad44ef62e5d3d2046"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a05873a76698ab49ad44ef62e5d3d2046">GetUserPtr</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a05873a76698ab49ad44ef62e5d3d2046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the user pointer.  <a href="classnn_1_1g3d_1_1_material_obj.html#a05873a76698ab49ad44ef62e5d3d2046">More...</a><br /></td></tr>
<tr class="separator:a05873a76698ab49ad44ef62e5d3d2046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c81a7d664ab8109cc901e400a3b2f93"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a4c81a7d664ab8109cc901e400a3b2f93">GetUserPtr</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4c81a7d664ab8109cc901e400a3b2f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the user pointer.  <a href="classnn_1_1g3d_1_1_material_obj.html#a4c81a7d664ab8109cc901e400a3b2f93">More...</a><br /></td></tr>
<tr class="separator:a4c81a7d664ab8109cc901e400a3b2f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea7b8dfeca25ec1aa10f6a0ffecdfed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adea7b8dfeca25ec1aa10f6a0ffecdfed"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#adea7b8dfeca25ec1aa10f6a0ffecdfed">GetUserPtr</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:adea7b8dfeca25ec1aa10f6a0ffecdfed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the user pointer.  <a href="classnn_1_1g3d_1_1_material_obj.html#adea7b8dfeca25ec1aa10f6a0ffecdfed">More...</a><br /></td></tr>
<tr class="separator:adea7b8dfeca25ec1aa10f6a0ffecdfed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fad41412e57c351f0f932b282637168"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0fad41412e57c351f0f932b282637168"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a0fad41412e57c351f0f932b282637168">GetUserPtr</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0fad41412e57c351f0f932b282637168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the user pointer.  <a href="classnn_1_1g3d_1_1_material_obj.html#a0fad41412e57c351f0f932b282637168">More...</a><br /></td></tr>
<tr class="separator:a0fad41412e57c351f0f932b282637168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafae8b03bb46f867b6d8b722df9fd36f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#aafae8b03bb46f867b6d8b722df9fd36f">GetName</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aafae8b03bb46f867b6d8b722df9fd36f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the material name.  <a href="classnn_1_1g3d_1_1_material_obj.html#aafae8b03bb46f867b6d8b722df9fd36f">More...</a><br /></td></tr>
<tr class="separator:aafae8b03bb46f867b6d8b722df9fd36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Shader Parameters</div></td></tr>
<tr class="memitem:a92e4a14e18379878b68e8a1df4906e8f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a92e4a14e18379878b68e8a1df4906e8f">GetShaderParamCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a92e4a14e18379878b68e8a1df4906e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of shader parameters placed under the material.  <a href="classnn_1_1g3d_1_1_material_obj.html#a92e4a14e18379878b68e8a1df4906e8f">More...</a><br /></td></tr>
<tr class="separator:a92e4a14e18379878b68e8a1df4906e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d7594dd997ea0ce862ed400fb82793"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#ad0d7594dd997ea0ce862ed400fb82793">GetShaderParamName</a> (int paramIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad0d7594dd997ea0ce862ed400fb82793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the shader parameter name from the index.  <a href="classnn_1_1g3d_1_1_material_obj.html#ad0d7594dd997ea0ce862ed400fb82793">More...</a><br /></td></tr>
<tr class="separator:ad0d7594dd997ea0ce862ed400fb82793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cadd9eb5405ee5ac830ba7b846a0991"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a7cadd9eb5405ee5ac830ba7b846a0991">FindShaderParamIndex</a> (const char *name) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7cadd9eb5405ee5ac830ba7b846a0991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the index from the shader parameter name.  <a href="classnn_1_1g3d_1_1_material_obj.html#a7cadd9eb5405ee5ac830ba7b846a0991">More...</a><br /></td></tr>
<tr class="separator:a7cadd9eb5405ee5ac830ba7b846a0991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4812352fe216dc9009d89d264794dbcd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnn_1_1g3d_1_1_res_shader_param.html">ResShaderParam</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a4812352fe216dc9009d89d264794dbcd">GetResShaderParam</a> (int paramIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4812352fe216dc9009d89d264794dbcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the shader parameter by looking up the index.  <a href="classnn_1_1g3d_1_1_material_obj.html#a4812352fe216dc9009d89d264794dbcd">More...</a><br /></td></tr>
<tr class="separator:a4812352fe216dc9009d89d264794dbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622efa787657faa431540ca6cd0992bc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnn_1_1g3d_1_1_res_shader_param.html">ResShaderParam</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a622efa787657faa431540ca6cd0992bc">FindResShaderParam</a> (const char *name) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a622efa787657faa431540ca6cd0992bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the shader parameter by looking up the name.  <a href="classnn_1_1g3d_1_1_material_obj.html#a622efa787657faa431540ca6cd0992bc">More...</a><br /></td></tr>
<tr class="separator:a622efa787657faa431540ca6cd0992bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d92b1ba08755e840186f240a598770"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#ae9d92b1ba08755e840186f240a598770">EditShaderParam</a> (int paramIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae9d92b1ba08755e840186f240a598770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the shader parameter so it can be edited.  <a href="classnn_1_1g3d_1_1_material_obj.html#ae9d92b1ba08755e840186f240a598770">More...</a><br /></td></tr>
<tr class="separator:ae9d92b1ba08755e840186f240a598770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1864c83787f076a1bd8edf556ef82c48"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a1864c83787f076a1bd8edf556ef82c48">GetShaderParam</a> (int paramIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1864c83787f076a1bd8edf556ef82c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the shader parameters.  <a href="classnn_1_1g3d_1_1_material_obj.html#a1864c83787f076a1bd8edf556ef82c48">More...</a><br /></td></tr>
<tr class="separator:a1864c83787f076a1bd8edf556ef82c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dec7708013c4c59363a5681193fea28"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5dec7708013c4c59363a5681193fea28"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a5dec7708013c4c59363a5681193fea28">EditShaderParam</a> (int paramIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5dec7708013c4c59363a5681193fea28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the shader parameter so it can be edited.  <a href="classnn_1_1g3d_1_1_material_obj.html#a5dec7708013c4c59363a5681193fea28">More...</a><br /></td></tr>
<tr class="separator:a5dec7708013c4c59363a5681193fea28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864f9151cb24d9869887181b44365d18"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a864f9151cb24d9869887181b44365d18"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a864f9151cb24d9869887181b44365d18">GetShaderParam</a> (int paramIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a864f9151cb24d9869887181b44365d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the shader parameters.  <a href="classnn_1_1g3d_1_1_material_obj.html#a864f9151cb24d9869887181b44365d18">More...</a><br /></td></tr>
<tr class="separator:a864f9151cb24d9869887181b44365d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763b3b157cd35d724b261dbf27700788"><td class="memItemLeft" align="right" valign="top"><a id="a763b3b157cd35d724b261dbf27700788"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a763b3b157cd35d724b261dbf27700788">ClearShaderParam</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a763b3b157cd35d724b261dbf27700788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the shader parameter to resource status. <br /></td></tr>
<tr class="separator:a763b3b157cd35d724b261dbf27700788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b9d18bba7ef2c3fd93b61d2b185892"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a72b9d18bba7ef2c3fd93b61d2b185892">GetSrcParam</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a72b9d18bba7ef2c3fd93b61d2b185892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the buffer for the logical shader parameter before writing to the uniform block.  <a href="classnn_1_1g3d_1_1_material_obj.html#a72b9d18bba7ef2c3fd93b61d2b185892">More...</a><br /></td></tr>
<tr class="separator:a72b9d18bba7ef2c3fd93b61d2b185892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b4e602b10cba5a6b36fb9a882f68b8"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a92b4e602b10cba5a6b36fb9a882f68b8">GetSrcParam</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a92b4e602b10cba5a6b36fb9a882f68b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the buffer for the logical shader parameter before writing to the uniform block.  <a href="classnn_1_1g3d_1_1_material_obj.html#a92b4e602b10cba5a6b36fb9a882f68b8">More...</a><br /></td></tr>
<tr class="separator:a92b4e602b10cba5a6b36fb9a882f68b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af722ab0d9e79e03a6eecf7ded5ca6fa7"><td class="memItemLeft" align="right" valign="top"><a id="af722ab0d9e79e03a6eecf7ded5ca6fa7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#af722ab0d9e79e03a6eecf7ded5ca6fa7">ResetDirtyFlags</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af722ab0d9e79e03a6eecf7ded5ca6fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores the <code>DirtyFlag</code> of all shader parameters to <code>Dirty</code> status. <br /></td></tr>
<tr class="separator:af722ab0d9e79e03a6eecf7ded5ca6fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad522376ee703e8cc6976eb3e864e9b37"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#ad522376ee703e8cc6976eb3e864e9b37">IsMaterialBlockDirty</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad522376ee703e8cc6976eb3e864e9b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether updating with the <code><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#acb09821f66b8cc37c265e6b8207dea33" title="Calculates render resources for materials.">CalculateMaterial()</a></code> function is necessary.  <a href="classnn_1_1g3d_1_1_material_obj.html#ad522376ee703e8cc6976eb3e864e9b37">More...</a><br /></td></tr>
<tr class="separator:ad522376ee703e8cc6976eb3e864e9b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Textures</div></td></tr>
<tr class="memitem:a9ba8a6a18216f2332f4bf74cbef5475c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a9ba8a6a18216f2332f4bf74cbef5475c">GetTextureCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9ba8a6a18216f2332f4bf74cbef5475c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of textures placed under the material.  <a href="classnn_1_1g3d_1_1_material_obj.html#a9ba8a6a18216f2332f4bf74cbef5475c">More...</a><br /></td></tr>
<tr class="separator:a9ba8a6a18216f2332f4bf74cbef5475c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5afd91a6558530d5dbd8bc1b4ab6f74"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#ae5afd91a6558530d5dbd8bc1b4ab6f74">GetTextureName</a> (int texIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae5afd91a6558530d5dbd8bc1b4ab6f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the texture name from the index.  <a href="classnn_1_1g3d_1_1_material_obj.html#ae5afd91a6558530d5dbd8bc1b4ab6f74">More...</a><br /></td></tr>
<tr class="separator:ae5afd91a6558530d5dbd8bc1b4ab6f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b77c44f4e6bdedc0b190c1f1f93448"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1g3d_1_1_texture_ref.html">nn::g3d::TextureRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a57b77c44f4e6bdedc0b190c1f1f93448">GetTexture</a> (int texIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a57b77c44f4e6bdedc0b190c1f1f93448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the texture.  <a href="classnn_1_1g3d_1_1_material_obj.html#a57b77c44f4e6bdedc0b190c1f1f93448">More...</a><br /></td></tr>
<tr class="separator:a57b77c44f4e6bdedc0b190c1f1f93448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431f8932a5e95bc2c559cbf0817c9aed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a431f8932a5e95bc2c559cbf0817c9aed">SetTexture</a> (int texIndex, const <a class="el" href="classnn_1_1g3d_1_1_texture_ref.html">TextureRef</a> &amp;textureRef) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a431f8932a5e95bc2c559cbf0817c9aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the texture.  <a href="classnn_1_1g3d_1_1_material_obj.html#a431f8932a5e95bc2c559cbf0817c9aed">More...</a><br /></td></tr>
<tr class="separator:a431f8932a5e95bc2c559cbf0817c9aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac748dc391720c72f304fc7bd23161c2b"><td class="memItemLeft" align="right" valign="top"><a id="ac748dc391720c72f304fc7bd23161c2b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#ac748dc391720c72f304fc7bd23161c2b">ClearTexture</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac748dc391720c72f304fc7bd23161c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverts the texture to its resource state. <br /></td></tr>
<tr class="separator:ac748dc391720c72f304fc7bd23161c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b90787b3470416fee29cd6b23159a75"><td class="memItemLeft" align="right" valign="top"><a id="a9b90787b3470416fee29cd6b23159a75"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a9b90787b3470416fee29cd6b23159a75">SetTextureChangeCallback</a> (<a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a76f91aab9736ea9fbb276f16ef49c796">TextureChangeCallback</a> pCallback) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9b90787b3470416fee29cd6b23159a75"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <b>The use of internal features is prohibited.</b> Sets the callback to call during texture replacement. <br /></td></tr>
<tr class="separator:a9b90787b3470416fee29cd6b23159a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5e936e66e6bec85b1ad5353926f346"><td class="memItemLeft" align="right" valign="top"><a id="a1b5e936e66e6bec85b1ad5353926f346"></a>
<a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a76f91aab9736ea9fbb276f16ef49c796">TextureChangeCallback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a1b5e936e66e6bec85b1ad5353926f346">GetTextureChangeCallback</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1b5e936e66e6bec85b1ad5353926f346"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <b>The use of internal features is prohibited.</b> Gets the callback to call during texture replacement. <br /></td></tr>
<tr class="separator:a1b5e936e66e6bec85b1ad5353926f346"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Sampler.</h2></td></tr>
<tr class="memitem:a61a1a87bacf65d34d17ac8a686fdc77d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a61a1a87bacf65d34d17ac8a686fdc77d">Flag</a> { <a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a61a1a87bacf65d34d17ac8a686fdc77daa7540e62c45f61ba70a6841e760d4380">Flag_BlockBufferValid</a> = 0x1 &lt;&lt; 0
 }</td></tr>
<tr class="memdesc:a61a1a87bacf65d34d17ac8a686fdc77d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag representing the material state.  <a href="classnn_1_1g3d_1_1_material_obj.html#a61a1a87bacf65d34d17ac8a686fdc77d">More...</a><br /></td></tr>
<tr class="separator:a61a1a87bacf65d34d17ac8a686fdc77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b50b393ce326cbd1221df6b8205ef4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a76b50b393ce326cbd1221df6b8205ef4">GetSamplerCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a76b50b393ce326cbd1221df6b8205ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of samplers placed under the material.  <a href="classnn_1_1g3d_1_1_material_obj.html#a76b50b393ce326cbd1221df6b8205ef4">More...</a><br /></td></tr>
<tr class="separator:a76b50b393ce326cbd1221df6b8205ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf206f7a3b4344a3e5ef949404a73c30"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#abf206f7a3b4344a3e5ef949404a73c30">GetSamplerName</a> (int samplerIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:abf206f7a3b4344a3e5ef949404a73c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sampler name from the index.  <a href="classnn_1_1g3d_1_1_material_obj.html#abf206f7a3b4344a3e5ef949404a73c30">More...</a><br /></td></tr>
<tr class="separator:abf206f7a3b4344a3e5ef949404a73c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22f09045805b2f07cc6f9c4a51d8380"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#ab22f09045805b2f07cc6f9c4a51d8380">FindSamplerIndex</a> (const char *name) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab22f09045805b2f07cc6f9c4a51d8380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the index from the sampler name.  <a href="classnn_1_1g3d_1_1_material_obj.html#ab22f09045805b2f07cc6f9c4a51d8380">More...</a><br /></td></tr>
<tr class="separator:ab22f09045805b2f07cc6f9c4a51d8380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92fd4547dded42b97cc7ca9715d053d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1g3d_1_1_sampler_ref.html">SamplerRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#ac92fd4547dded42b97cc7ca9715d053d">GetSampler</a> (int samplerIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac92fd4547dded42b97cc7ca9715d053d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sampler by looking up the index.  <a href="classnn_1_1g3d_1_1_material_obj.html#ac92fd4547dded42b97cc7ca9715d053d">More...</a><br /></td></tr>
<tr class="separator:ac92fd4547dded42b97cc7ca9715d053d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d175650dcc191070071a45ac2b0c38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1g3d_1_1_sampler_ref.html">SamplerRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a62d175650dcc191070071a45ac2b0c38">FindSampler</a> (const char *name) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a62d175650dcc191070071a45ac2b0c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sampler by looking up the name.  <a href="classnn_1_1g3d_1_1_material_obj.html#a62d175650dcc191070071a45ac2b0c38">More...</a><br /></td></tr>
<tr class="separator:a62d175650dcc191070071a45ac2b0c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042f9c716e8f4af7b0d6442db3eba1f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a042f9c716e8f4af7b0d6442db3eba1f0">SetMaterialBlockArray</a> (<a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a> *pBlockArray) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a042f9c716e8f4af7b0d6442db3eba1f0"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <b>The use of internal features is prohibited.</b> Sets the buffer array for uniform blocks.  <a href="classnn_1_1g3d_1_1_material_obj.html#a042f9c716e8f4af7b0d6442db3eba1f0">More...</a><br /></td></tr>
<tr class="separator:a042f9c716e8f4af7b0d6442db3eba1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3e3bcdd5fea3bb2fd73a62f61d60b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#acd3e3bcdd5fea3bb2fd73a62f61d60b6">GetMaterialBlockArray</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acd3e3bcdd5fea3bb2fd73a62f61d60b6"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <b>The use of internal features is prohibited.</b> Gets the buffer array for uniform blocks.  <a href="classnn_1_1g3d_1_1_material_obj.html#acd3e3bcdd5fea3bb2fd73a62f61d60b6">More...</a><br /></td></tr>
<tr class="separator:acd3e3bcdd5fea3bb2fd73a62f61d60b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd124ef1f5b15fbb0d38c43bb763ead"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a9cd124ef1f5b15fbb0d38c43bb763ead">SetDirtyFlag</a> (int paramIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9cd124ef1f5b15fbb0d38c43bb763ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>DirtyFlag</code> in the shader parameter.  <a href="classnn_1_1g3d_1_1_material_obj.html#a9cd124ef1f5b15fbb0d38c43bb763ead">More...</a><br /></td></tr>
<tr class="separator:a9cd124ef1f5b15fbb0d38c43bb763ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c2dd456913c6bebd2758ca7f0f6c76"><td class="memTemplParams" colspan="2">template&lt;bool swap&gt; </td></tr>
<tr class="memitem:a27c2dd456913c6bebd2758ca7f0f6c76"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a27c2dd456913c6bebd2758ca7f0f6c76">ConvertParams</a> (void *pBuffer) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a27c2dd456913c6bebd2758ca7f0f6c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code>SrcParam</code> and applies it to a uniform block.  <a href="classnn_1_1g3d_1_1_material_obj.html#a27c2dd456913c6bebd2758ca7f0f6c76">More...</a><br /></td></tr>
<tr class="separator:a27c2dd456913c6bebd2758ca7f0f6c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44d1b19fac189403ad83a3be9a62c74"><td class="memTemplParams" colspan="2">template&lt;bool swap&gt; </td></tr>
<tr class="memitem:aa44d1b19fac189403ad83a3be9a62c74"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#aa44d1b19fac189403ad83a3be9a62c74">ConvertDirtyParams</a> (void *pBuffer, Bit32 *pDirtyFlagArray) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa44d1b19fac189403ad83a3be9a62c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code>SrcParam</code> and applies it to a uniform block.  <a href="classnn_1_1g3d_1_1_material_obj.html#aa44d1b19fac189403ad83a3be9a62c74">More...</a><br /></td></tr>
<tr class="separator:aa44d1b19fac189403ad83a3be9a62c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ac9c046b937505db0e37e3d69f4c5d"><td class="memTemplParams" colspan="2">template&lt;bool swap&gt; </td></tr>
<tr class="memitem:a27ac9c046b937505db0e37e3d69f4c5d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a27ac9c046b937505db0e37e3d69f4c5d">ConvertVolatileParams</a> (void *pBuffer) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a27ac9c046b937505db0e37e3d69f4c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code>SrcParam</code> and applies it to a uniform block.  <a href="classnn_1_1g3d_1_1_material_obj.html#a27ac9c046b937505db0e37e3d69f4c5d">More...</a><br /></td></tr>
<tr class="separator:a27ac9c046b937505db0e37e3d69f4c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e830a0f4882be506d510286cd65e2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a14e830a0f4882be506d510286cd65e2b">InitializeDependPointer</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a14e830a0f4882be506d510286cd65e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a pointer to the dependent parameters.  <a href="classnn_1_1g3d_1_1_material_obj.html#a14e830a0f4882be506d510286cd65e2b">More...</a><br /></td></tr>
<tr class="separator:a14e830a0f4882be506d510286cd65e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A material instance. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_edit_8cpp-example.html#_a74">G3dDemo/Edit.cpp</a>, <a class="el" href="_g3d_demo_2_simple_8cpp-example.html#_a105">G3dDemo/Simple.cpp</a>, <a class="el" href="_g3d_demo_2_town_8cpp-example.html#_a205">G3dDemo/Town.cpp</a>, <a class="el" href="_mii_g3d_headwear_2_mii_g3d_headwear_8cpp-example.html#_a324">MiiG3dHeadwear/MiiG3dHeadwear.cpp</a>, and <a class="el" href="_mii_g3d_simple_2_mii_g3d_simple_8cpp-example.html#_a309">MiiG3dSimple/MiiG3dSimple.cpp</a>.</dd>
</dl>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="abbcd31769f7b1963488dba4ca1803664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbcd31769f7b1963488dba4ca1803664">&#9670;&nbsp;</a></span>Alignment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classnn_1_1g3d_1_1_material_obj.html#abbcd31769f7b1963488dba4ca1803664">nn::g3d::MaterialObj::Alignment</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Required alignment size of the buffer that is passed when the instance is being built. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abbcd31769f7b1963488dba4ca1803664afbdccd6a3b5d1de2ed79f1b75887b26b"></a>Alignment_Buffer&#160;</td><td class="fielddoc"><p>The alignment size required for the buffer passed to <code><a class="el" href="classnn_1_1g3d_1_1_material_obj_1_1_builder.html" title="The class that builds instances of MaterialObj.">Builder</a></code>. </p>
</td></tr>
</table>

</div>
</div>
<a id="a61a1a87bacf65d34d17ac8a686fdc77d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a1a87bacf65d34d17ac8a686fdc77d">&#9670;&nbsp;</a></span>Flag</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a61a1a87bacf65d34d17ac8a686fdc77d">nn::g3d::MaterialObj::Flag</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag representing the material state. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a61a1a87bacf65d34d17ac8a686fdc77daa7540e62c45f61ba70a6841e760d4380"></a>Flag_BlockBufferValid&#160;</td><td class="fielddoc"><p> <b>The use of internal features is prohibited.</b> Flag indicating whether the uniform block has been built. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa9e4ffe23a0e1b95c64007350e52af89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e4ffe23a0e1b95c64007350e52af89">&#9670;&nbsp;</a></span>MaterialObj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nn::g3d::MaterialObj::MaterialObj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p> <b>Details</b> <br  />
 <code><a class="el" href="classnn_1_1g3d_1_1_material_obj_1_1_builder.html" title="The class that builds instances of MaterialObj.">Builder</a></code> performs the actual building. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aea88251b4d981611ffd922ea202f873b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea88251b4d981611ffd922ea202f873b">&#9670;&nbsp;</a></span>CalculateBlockBufferSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::g3d::MaterialObj::CalculateBlockBufferSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *&#160;</td>
          <td class="paramname"><em>pDevice</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the uniform block size. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the calculated buffer size. </dd></dl>

</div>
</div>
<a id="aea1b10f4ba758f171b771c3d7b12fc4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1b10f4ba758f171b771c3d7b12fc4c">&#9670;&nbsp;</a></span>SetupBlockBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::MaterialObj::SetupBlockBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *&#160;</td>
          <td class="paramname"><em>pDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1gfx.html#ad620d8208dd309eb7c4dd5973a6aeee5">nn::gfx::MemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pMemoryPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>memoryPoolSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Passes a memory pool and builds a uniform block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDevice</td><td>Pointer to the device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pMemoryPool</td><td>Pointer to the memory pool. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset to the region to use for the memory pool. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memoryPoolSize</td><td>The size of the available memory pool beyond <code><em>offset</em></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if building succeeded, or <code>false</code> otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDevice</em></code> is initialized.</li>
<li><code><em>pMemoryPool</em></code> is initialized.</li>
<li>The position of the memory pool specified by <code><em>offset</em></code> is aligned to the value of <code><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a7d4f1b5d0f15bb724c7ec7f0ede41907" title="Gets the alignment required by the uniform block.">GetBlockBufferAlignment()</a></code>.</li>
<li><code><em>memoryPoolSize</em></code> is at least the size of <code><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#aea88251b4d981611ffd922ea202f873b" title="Calculates the uniform block size.">CalculateBlockBufferSize()</a></code>.</li>
<li>The uniform block is not built.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The uniform block is built.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 In the special case where the value for the resource is set to <code>0</code> by <code><a class="el" href="classnn_1_1g3d_1_1_res_material.html#a3ad8388875be70cd5210f42924e1cc4a" title="Sets the size of the buffer for the shader parameter uniform block.">nn::g3d::ResMaterial::SetRawParamSize()</a></code>, the uniform block is not built and the function returns <code>true</code>. </p>

</div>
</div>
<a id="a79af0eaa9e755ffe7e2b1f8ece8b3e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79af0eaa9e755ffe7e2b1f8ece8b3e54">&#9670;&nbsp;</a></span>CleanupBlockBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::MaterialObj::CleanupBlockBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *&#160;</td>
          <td class="paramname"><em>pDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the uniform block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDevice</td><td>Pointer to the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDevice</em></code> is initialized.</li>
<li>The uniform block is built.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The uniform block is destroyed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="acb09821f66b8cc37c265e6b8207dea33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb09821f66b8cc37c265e6b8207dea33">&#9670;&nbsp;</a></span>CalculateMaterial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::MaterialObj::CalculateMaterial </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufferIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates render resources for materials. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferIndex</td><td>Index to the uniform block that applies the calculation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The index is within the range of the number of uniform blocks for buffering.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Because buffers accessed by the graphics processing unit (GPU) are overwritten, this process must be called after GPU access for the previous rendering process completes. It is assumed that either double buffering has been set as a build option, or that the process is called while copying out the framebuffer. </p>

</div>
</div>
<a id="a7d4f1b5d0f15bb724c7ec7f0ede41907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4f1b5d0f15bb724c7ec7f0ede41907">&#9670;&nbsp;</a></span>GetBlockBufferAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::g3d::MaterialObj::GetBlockBufferAlignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *&#160;</td>
          <td class="paramname"><em>pDevice</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the alignment required by the uniform block. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the alignment required by the uniform block. </dd></dl>

</div>
</div>
<a id="ac83012bf24ce5dafd6fed058a9700975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83012bf24ce5dafd6fed058a9700975">&#9670;&nbsp;</a></span>GetResource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnn_1_1g3d_1_1_res_material.html">ResMaterial</a>* nn::g3d::MaterialObj::GetResource </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a resource. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to <code><a class="el" href="classnn_1_1g3d_1_1_res_material.html" title="The material resource.">ResMaterial</a></code>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_edit_8cpp-example.html#a76">G3dDemo/Edit.cpp</a>, <a class="el" href="_g3d_demo_2_simple_8cpp-example.html#a109">G3dDemo/Simple.cpp</a>, <a class="el" href="_g3d_demo_2_town_8cpp-example.html#a295">G3dDemo/Town.cpp</a>, <a class="el" href="_mii_g3d_headwear_2_mii_g3d_headwear_8cpp-example.html#a355">MiiG3dHeadwear/MiiG3dHeadwear.cpp</a>, and <a class="el" href="_mii_g3d_simple_2_mii_g3d_simple_8cpp-example.html#a330">MiiG3dSimple/MiiG3dSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad4786cffeac9408ffad4806914664336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4786cffeac9408ffad4806914664336">&#9670;&nbsp;</a></span>GetBufferPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::g3d::MaterialObj::GetBufferPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the buffer passed by <code><a class="el" href="classnn_1_1g3d_1_1_material_obj_1_1_builder.html" title="The class that builds instances of MaterialObj.">Builder</a></code> at the time of the build. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer to the buffer passed to <code><a class="el" href="classnn_1_1g3d_1_1_material_obj_1_1_builder.html" title="The class that builds instances of MaterialObj.">Builder</a></code> at the time of the build. </dd></dl>

</div>
</div>
<a id="a329d29a9cf9f30106921b7bb7b8b1d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a329d29a9cf9f30106921b7bb7b8b1d54">&#9670;&nbsp;</a></span>GetMemoryPoolPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1gfx.html#ad620d8208dd309eb7c4dd5973a6aeee5">nn::gfx::MemoryPool</a>* nn::g3d::MaterialObj::GetMemoryPoolPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a pointer to the memory pool that was passed when <code><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#aea1b10f4ba758f171b771c3d7b12fc4c" title="Passes a memory pool and builds a uniform block.">SetupBlockBuffer()</a></code> was called. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer to the memory pool. </dd></dl>

</div>
</div>
<a id="a00c6cf24fef727e9a381eaf4e4e62e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c6cf24fef727e9a381eaf4e4e62e91">&#9670;&nbsp;</a></span>GetMemoryPoolOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t nn::g3d::MaterialObj::GetMemoryPoolOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the offset of the memory pool that was passed when <code><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#aea1b10f4ba758f171b771c3d7b12fc4c" title="Passes a memory pool and builds a uniform block.">SetupBlockBuffer()</a></code> was called. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the memory pool offset. </dd></dl>

</div>
</div>
<a id="a64170b747c33200006836a169e8976c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64170b747c33200006836a169e8976c3">&#9670;&nbsp;</a></span>IsBlockBufferValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::MaterialObj::IsBlockBufferValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the uniform block has been built. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if built, or <code>false</code> otherwise. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_simple_8cpp-example.html#a129">G3dDemo/Simple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aef15d5bfda74edf022aa6337f13d52ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef15d5bfda74edf022aa6337f13d52ed">&#9670;&nbsp;</a></span>GetMaterialBlock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a>* nn::g3d::MaterialObj::GetMaterialBlock </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufferIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the buffer for a uniform block retained by the material. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferIndex</td><td>Index of the uniform block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to <code><a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85" title="The type definition representing a buffer.">nn::gfx::Buffer</a></code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The index is within the range of the number of buffers held by the material.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Returns <code>NULL</code> if the uniform block has not been built. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_edit_8cpp-example.html#a69">G3dDemo/Edit.cpp</a>, <a class="el" href="_g3d_demo_2_nns_g3d_simple_8cpp-example.html#a62">G3dDemo/NnsG3dSimple.cpp</a>, <a class="el" href="_g3d_demo_2_outline_8cpp-example.html#a76">G3dDemo/Outline.cpp</a>, <a class="el" href="_g3d_demo_2_parallel_8cpp-example.html#a102">G3dDemo/Parallel.cpp</a>, <a class="el" href="_g3d_demo_2_shape_animation_8cpp-example.html#a157">G3dDemo/ShapeAnimation.cpp</a>, <a class="el" href="_g3d_demo_2_simple_8cpp-example.html#a128">G3dDemo/Simple.cpp</a>, <a class="el" href="_g3d_demo_2_skeletal_animation_8cpp-example.html#a126">G3dDemo/SkeletalAnimation.cpp</a>, <a class="el" href="_g3d_demo_2_tessellation_8cpp-example.html#a132">G3dDemo/Tessellation.cpp</a>, <a class="el" href="_g3d_demo_2_town_8cpp-example.html#a292">G3dDemo/Town.cpp</a>, <a class="el" href="_mii_g3d_headwear_2_mii_g3d_headwear_8cpp-example.html#a326">MiiG3dHeadwear/MiiG3dHeadwear.cpp</a>, and <a class="el" href="_mii_g3d_simple_2_mii_g3d_simple_8cpp-example.html#a311">MiiG3dSimple/MiiG3dSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1c1e45f79fe756a7ffa9ae72766d0efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c1e45f79fe756a7ffa9ae72766d0efd">&#9670;&nbsp;</a></span>GetMaterialBlock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a>* nn::g3d::MaterialObj::GetMaterialBlock </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufferIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the buffer for a uniform block retained by the material. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferIndex</td><td>Index of the uniform block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to <code><a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85" title="The type definition representing a buffer.">nn::gfx::Buffer</a></code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The index is within the range of the number of buffers held by the material.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Returns <code>NULL</code> if the uniform block has not been built. </p>

</div>
</div>
<a id="a0215c9275372e3b367aee550cbed1fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0215c9275372e3b367aee550cbed1fb1">&#9670;&nbsp;</a></span>GetMaterialBlockSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::g3d::MaterialObj::GetMaterialBlockSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of a uniform block retained by the material. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the size of a uniform block retained by the material. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_simple_8cpp-example.html#a130">G3dDemo/Simple.cpp</a>, <a class="el" href="_mii_g3d_headwear_2_mii_g3d_headwear_8cpp-example.html#a366">MiiG3dHeadwear/MiiG3dHeadwear.cpp</a>, and <a class="el" href="_mii_g3d_simple_2_mii_g3d_simple_8cpp-example.html#a345">MiiG3dSimple/MiiG3dSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3105fad2aac162f0757d6f81562f9736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3105fad2aac162f0757d6f81562f9736">&#9670;&nbsp;</a></span>GetBufferingCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::MaterialObj::GetBufferingCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of uniform blocks for buffering. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of uniform blocks for buffering. </dd></dl>

</div>
</div>
<a id="ac0c9198a850dfaef396bb14e222f9194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c9198a850dfaef396bb14e222f9194">&#9670;&nbsp;</a></span>IsBlockSwapEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::MaterialObj::IsBlockSwapEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether an endian swap will be conducted for the uniform block. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if an endian swap will be conducted for the uniform block, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a89b2883e75c53b0c5160861dec317f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b2883e75c53b0c5160861dec317f4d">&#9670;&nbsp;</a></span>SetUserPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::MaterialObj::SetUserPtr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pUserPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a user pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUserPtr</td><td>A pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05873a76698ab49ad44ef62e5d3d2046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05873a76698ab49ad44ef62e5d3d2046">&#9670;&nbsp;</a></span>GetUserPtr() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::g3d::MaterialObj::GetUserPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the user pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer set by the <code><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a89b2883e75c53b0c5160861dec317f4d" title="Sets a user pointer.">SetUserPtr()</a></code> function. </dd></dl>

</div>
</div>
<a id="a4c81a7d664ab8109cc901e400a3b2f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c81a7d664ab8109cc901e400a3b2f93">&#9670;&nbsp;</a></span>GetUserPtr() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* nn::g3d::MaterialObj::GetUserPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the user pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer set by the <code><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a89b2883e75c53b0c5160861dec317f4d" title="Sets a user pointer.">SetUserPtr()</a></code> function. </dd></dl>

</div>
</div>
<a id="adea7b8dfeca25ec1aa10f6a0ffecdfed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea7b8dfeca25ec1aa10f6a0ffecdfed">&#9670;&nbsp;</a></span>GetUserPtr() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* nn::g3d::MaterialObj::GetUserPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the user pointer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type when getting a pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer set by the <code><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a89b2883e75c53b0c5160861dec317f4d" title="Sets a user pointer.">SetUserPtr()</a></code> function. </dd></dl>

</div>
</div>
<a id="a0fad41412e57c351f0f932b282637168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fad41412e57c351f0f932b282637168">&#9670;&nbsp;</a></span>GetUserPtr() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* nn::g3d::MaterialObj::GetUserPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the user pointer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type when getting a pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer set by the <code><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a89b2883e75c53b0c5160861dec317f4d" title="Sets a user pointer.">SetUserPtr()</a></code> function. </dd></dl>

</div>
</div>
<a id="aafae8b03bb46f867b6d8b722df9fd36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafae8b03bb46f867b6d8b722df9fd36f">&#9670;&nbsp;</a></span>GetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* nn::g3d::MaterialObj::GetName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the material name. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the <code><a class="el" href="classnn_1_1g3d_1_1_res_material.html" title="The material resource.">ResMaterial</a></code> material name. </dd></dl>

</div>
</div>
<a id="a92e4a14e18379878b68e8a1df4906e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e4a14e18379878b68e8a1df4906e8f">&#9670;&nbsp;</a></span>GetShaderParamCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::MaterialObj::GetShaderParamCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of shader parameters placed under the material. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of shader parameters placed under the material. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_town_8cpp-example.html#a207">G3dDemo/Town.cpp</a>, <a class="el" href="_mii_g3d_headwear_2_mii_g3d_headwear_8cpp-example.html#a325">MiiG3dHeadwear/MiiG3dHeadwear.cpp</a>, and <a class="el" href="_mii_g3d_simple_2_mii_g3d_simple_8cpp-example.html#a310">MiiG3dSimple/MiiG3dSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad0d7594dd997ea0ce862ed400fb82793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0d7594dd997ea0ce862ed400fb82793">&#9670;&nbsp;</a></span>GetShaderParamName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* nn::g3d::MaterialObj::GetShaderParamName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>paramIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the shader parameter name from the index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">paramIndex</td><td>The index of the shader parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the shader parameter name.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The index is within the range of the number of shader parameters held by the material. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_town_8cpp-example.html#a208">G3dDemo/Town.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a7cadd9eb5405ee5ac830ba7b846a0991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cadd9eb5405ee5ac830ba7b846a0991">&#9670;&nbsp;</a></span>FindShaderParamIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::MaterialObj::FindShaderParamIndex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the index from the shader parameter name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Pointer to the shader parameter name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the index of the shader parameter.</dd></dl>
<p> <b>Details</b> <br  />
 Returns <code><a class="el" href="classnn_1_1util_1_1_res_dic.html#a825d9c73f03e6d02e9f8d0050b0e11a6" title="Specifies an invalid index.">nn::util::ResDic::Npos</a></code> when no shader parameter with the specified name exists. </p>

</div>
</div>
<a id="a4812352fe216dc9009d89d264794dbcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4812352fe216dc9009d89d264794dbcd">&#9670;&nbsp;</a></span>GetResShaderParam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnn_1_1g3d_1_1_res_shader_param.html">ResShaderParam</a>* nn::g3d::MaterialObj::GetResShaderParam </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>paramIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the shader parameter by looking up the index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">paramIndex</td><td>The index of the shader parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to <code><a class="el" href="classnn_1_1g3d_1_1_res_shader_param.html" title="Shader parameter resource.">ResShaderParam</a></code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The index is within the range of the number of shader parameters held by the material. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a622efa787657faa431540ca6cd0992bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622efa787657faa431540ca6cd0992bc">&#9670;&nbsp;</a></span>FindResShaderParam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnn_1_1g3d_1_1_res_shader_param.html">ResShaderParam</a>* nn::g3d::MaterialObj::FindResShaderParam </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the shader parameter by looking up the name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Pointer to the shader parameter name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to <code><a class="el" href="classnn_1_1g3d_1_1_res_shader_param.html" title="Shader parameter resource.">ResShaderParam</a></code>.</dd></dl>
<p> <b>Details</b> <br  />
 Returns <code>NULL</code> when no shader parameter with the specified name exists.</p>
<p>Looking up indices is faster than looking up names. We recommend registering the index after you get it, and normally using index lookup. </p>

</div>
</div>
<a id="ae9d92b1ba08755e840186f240a598770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d92b1ba08755e840186f240a598770">&#9670;&nbsp;</a></span>EditShaderParam() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::g3d::MaterialObj::EditShaderParam </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>paramIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the shader parameter so it can be edited. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">paramIndex</td><td>The index of the shader parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer to the shader parameter.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The index is within the range of the number of shader parameters held by the material.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The parameter obtained by this function is set with <code>DirtyFlag</code> and applied to the uniform block by calling <code><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#acb09821f66b8cc37c265e6b8207dea33" title="Calculates render resources for materials.">CalculateMaterial()</a></code>. </p>

</div>
</div>
<a id="a1864c83787f076a1bd8edf556ef82c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1864c83787f076a1bd8edf556ef82c48">&#9670;&nbsp;</a></span>GetShaderParam() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* nn::g3d::MaterialObj::GetShaderParam </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>paramIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the shader parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">paramIndex</td><td>The index of the shader parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer to the shader parameter.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The index is within the range of the number of shader parameters held by the material.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Call the <code><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#ae9d92b1ba08755e840186f240a598770" title="Gets the shader parameter so it can be edited.">EditShaderParam()</a></code> function when overwriting the obtained memory. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_town_8cpp-example.html#a209">G3dDemo/Town.cpp</a>, <a class="el" href="_mii_g3d_headwear_2_mii_g3d_headwear_8cpp-example.html#a327">MiiG3dHeadwear/MiiG3dHeadwear.cpp</a>, and <a class="el" href="_mii_g3d_simple_2_mii_g3d_simple_8cpp-example.html#a312">MiiG3dSimple/MiiG3dSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a5dec7708013c4c59363a5681193fea28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dec7708013c4c59363a5681193fea28">&#9670;&nbsp;</a></span>EditShaderParam() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* nn::g3d::MaterialObj::EditShaderParam </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>paramIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the shader parameter so it can be edited. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type when getting a pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">paramIndex</td><td>The index of the shader parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer to the shader parameter.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The index is within the range of the number of shader parameters held by the material.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The parameter obtained by this function is set with <code>DirtyFlag</code> and applied to the uniform block by calling <code><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#acb09821f66b8cc37c265e6b8207dea33" title="Calculates render resources for materials.">CalculateMaterial()</a></code>. A type check is performed by specifying template arguments. Boolean values are stored in 4 bytes, so you must get a 4-byte type like <code>int32_t</code> or <code>uint32_t</code>. </p>

</div>
</div>
<a id="a864f9151cb24d9869887181b44365d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a864f9151cb24d9869887181b44365d18">&#9670;&nbsp;</a></span>GetShaderParam() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* nn::g3d::MaterialObj::GetShaderParam </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>paramIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the shader parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type when getting a pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">paramIndex</td><td>The index of the shader parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer to the shader parameter.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The index is within the range of the number of shader parameters held by the material.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Call the <code><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#ae9d92b1ba08755e840186f240a598770" title="Gets the shader parameter so it can be edited.">EditShaderParam()</a></code> function when overwriting the obtained memory. A type check is performed by specifying template arguments. Boolean values are stored in 4 bytes, so you must get a 4-byte type like <code>int32_t</code> or <code>uint32_t</code>. </p>

</div>
</div>
<a id="a72b9d18bba7ef2c3fd93b61d2b185892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b9d18bba7ef2c3fd93b61d2b185892">&#9670;&nbsp;</a></span>GetSrcParam() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::g3d::MaterialObj::GetSrcParam </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the buffer for the logical shader parameter before writing to the uniform block. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the buffer for the logical shader parameter before writing to the uniform block. </dd></dl>

</div>
</div>
<a id="a92b4e602b10cba5a6b36fb9a882f68b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b4e602b10cba5a6b36fb9a882f68b8">&#9670;&nbsp;</a></span>GetSrcParam() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* nn::g3d::MaterialObj::GetSrcParam </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the buffer for the logical shader parameter before writing to the uniform block. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the buffer for the logical shader parameter before writing to the uniform block. </dd></dl>

</div>
</div>
<a id="ad522376ee703e8cc6976eb3e864e9b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad522376ee703e8cc6976eb3e864e9b37">&#9670;&nbsp;</a></span>IsMaterialBlockDirty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::MaterialObj::IsMaterialBlockDirty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether updating with the <code><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#acb09821f66b8cc37c265e6b8207dea33" title="Calculates render resources for materials.">CalculateMaterial()</a></code> function is necessary. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if updating is necessary, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a9ba8a6a18216f2332f4bf74cbef5475c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba8a6a18216f2332f4bf74cbef5475c">&#9670;&nbsp;</a></span>GetTextureCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::MaterialObj::GetTextureCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of textures placed under the material. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of textures placed under the material. </dd></dl>

</div>
</div>
<a id="ae5afd91a6558530d5dbd8bc1b4ab6f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5afd91a6558530d5dbd8bc1b4ab6f74">&#9670;&nbsp;</a></span>GetTextureName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* nn::g3d::MaterialObj::GetTextureName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>texIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the texture name from the index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">texIndex</td><td>The texture index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer to the texture name.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The index is within the range of the number of textures held by the material.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Causes an assertion failure when the specified index is outside the range. </p>

</div>
</div>
<a id="a57b77c44f4e6bdedc0b190c1f1f93448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b77c44f4e6bdedc0b190c1f1f93448">&#9670;&nbsp;</a></span>GetTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1g3d_1_1_texture_ref.html">nn::g3d::TextureRef</a> nn::g3d::MaterialObj::GetTexture </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>texIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">texIndex</td><td>The texture index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><a class="el" href="classnn_1_1g3d_1_1_texture_ref.html" title="Type that represents the texture view and the descriptor pool that registered that texture view.">nn::g3d::TextureRef</a></code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The index is within the range of the number of textures held by the material.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 A texture referenced by a particular sampler has the same index as that sampler. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_simple_8cpp-example.html#a116">G3dDemo/Simple.cpp</a>, <a class="el" href="_g3d_demo_2_town_8cpp-example.html#a303">G3dDemo/Town.cpp</a>, <a class="el" href="_mii_g3d_headwear_2_mii_g3d_headwear_8cpp-example.html#a369">MiiG3dHeadwear/MiiG3dHeadwear.cpp</a>, and <a class="el" href="_mii_g3d_simple_2_mii_g3d_simple_8cpp-example.html#a348">MiiG3dSimple/MiiG3dSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a431f8932a5e95bc2c559cbf0817c9aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431f8932a5e95bc2c559cbf0817c9aed">&#9670;&nbsp;</a></span>SetTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::MaterialObj::SetTexture </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>texIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnn_1_1g3d_1_1_texture_ref.html">TextureRef</a> &amp;&#160;</td>
          <td class="paramname"><em>textureRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">texIndex</td><td>The texture index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">textureRef</td><td>Reference to <code><a class="el" href="classnn_1_1g3d_1_1_texture_ref.html" title="Type that represents the texture view and the descriptor pool that registered that texture view.">nn::g3d::TextureRef</a></code>, where the view for the replacing texture and the descriptor slot are stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The index is within the range of the number of textures held by the material.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Textures referenced by materials can be replaced. A texture referenced by a particular sampler has the same index as that sampler. </p>

</div>
</div>
<a id="a76b50b393ce326cbd1221df6b8205ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b50b393ce326cbd1221df6b8205ef4">&#9670;&nbsp;</a></span>GetSamplerCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::MaterialObj::GetSamplerCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of samplers placed under the material. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of samplers placed under the material. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_mii_g3d_headwear_2_mii_g3d_headwear_8cpp-example.html#a368">MiiG3dHeadwear/MiiG3dHeadwear.cpp</a>, and <a class="el" href="_mii_g3d_simple_2_mii_g3d_simple_8cpp-example.html#a347">MiiG3dSimple/MiiG3dSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="abf206f7a3b4344a3e5ef949404a73c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf206f7a3b4344a3e5ef949404a73c30">&#9670;&nbsp;</a></span>GetSamplerName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* nn::g3d::MaterialObj::GetSamplerName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>samplerIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the sampler name from the index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">samplerIndex</td><td>Index of the sampler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the sampler name.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The index is within the range of the number of samplers held by the material.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The texture's index will match the index of the referencing sampler. </p>

</div>
</div>
<a id="ab22f09045805b2f07cc6f9c4a51d8380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22f09045805b2f07cc6f9c4a51d8380">&#9670;&nbsp;</a></span>FindSamplerIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::MaterialObj::FindSamplerIndex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the index from the sampler name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Pointer to the sampler name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the index of the sampler.</dd></dl>
<p> <b>Details</b> <br  />
 Returns <code><a class="el" href="classnn_1_1util_1_1_res_dic.html#a825d9c73f03e6d02e9f8d0050b0e11a6" title="Specifies an invalid index.">nn::util::ResDic::Npos</a></code> when no sampler with the specified name exists. The texture's index will match the index of the referencing sampler. </p>

</div>
</div>
<a id="ac92fd4547dded42b97cc7ca9715d053d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92fd4547dded42b97cc7ca9715d053d">&#9670;&nbsp;</a></span>GetSampler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1g3d_1_1_sampler_ref.html">SamplerRef</a> nn::g3d::MaterialObj::GetSampler </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>samplerIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the sampler by looking up the index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">samplerIndex</td><td>Index of the sampler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to <code><a class="el" href="classnn_1_1g3d_1_1_sampler_ref.html" title="Type that represents the sampler and the descriptor pool that registered that sampler.">nn::g3d::SamplerRef</a></code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The index is within the range of the number of samplers held by the material.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The texture's index will match the index of the referencing sampler. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_simple_8cpp-example.html#a114">G3dDemo/Simple.cpp</a>, <a class="el" href="_g3d_demo_2_town_8cpp-example.html#a301">G3dDemo/Town.cpp</a>, <a class="el" href="_mii_g3d_headwear_2_mii_g3d_headwear_8cpp-example.html#a371">MiiG3dHeadwear/MiiG3dHeadwear.cpp</a>, and <a class="el" href="_mii_g3d_simple_2_mii_g3d_simple_8cpp-example.html#a350">MiiG3dSimple/MiiG3dSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a62d175650dcc191070071a45ac2b0c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d175650dcc191070071a45ac2b0c38">&#9670;&nbsp;</a></span>FindSampler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1g3d_1_1_sampler_ref.html">SamplerRef</a> nn::g3d::MaterialObj::FindSampler </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the sampler by looking up the name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Pointer to the sampler name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to <code><a class="el" href="classnn_1_1g3d_1_1_sampler_ref.html" title="Type that represents the sampler and the descriptor pool that registered that sampler.">nn::g3d::SamplerRef</a></code>.</dd></dl>
<p> <b>Details</b> <br  />
 Returns an invalid <code><a class="el" href="classnn_1_1g3d_1_1_sampler_ref.html" title="Type that represents the sampler and the descriptor pool that registered that sampler.">SamplerRef</a></code> when there is no sampler with the specified name. You can use <code><a class="el" href="classnn_1_1g3d_1_1_sampler_ref.html#a2e30a5e3a5c46d2fa2f5edcdffd81980" title="Determines whether nn::g3d::SamplerRef is a valid value.">nn::g3d::SamplerRef::IsValid()</a></code> to check.</p>
<p>Looking up indices is faster than looking up names. We recommend registering the index after you get it, and normally using index lookup. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_outline_8cpp-example.html#a78">G3dDemo/Outline.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a042f9c716e8f4af7b0d6442db3eba1f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a042f9c716e8f4af7b0d6442db3eba1f0">&#9670;&nbsp;</a></span>SetMaterialBlockArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::MaterialObj::SetMaterialBlockArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a> *&#160;</td>
          <td class="paramname"><em>pBlockArray</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p> <b>The use of internal features is prohibited.</b> Sets the buffer array for uniform blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBlockArray</td><td>Pointer to the buffer array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd3e3bcdd5fea3bb2fd73a62f61d60b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd3e3bcdd5fea3bb2fd73a62f61d60b6">&#9670;&nbsp;</a></span>GetMaterialBlockArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a>* nn::g3d::MaterialObj::GetMaterialBlockArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p> <b>The use of internal features is prohibited.</b> Gets the buffer array for uniform blocks. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the buffer array. </dd></dl>

</div>
</div>
<a id="a9cd124ef1f5b15fbb0d38c43bb763ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cd124ef1f5b15fbb0d38c43bb763ead">&#9670;&nbsp;</a></span>SetDirtyFlag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::MaterialObj::SetDirtyFlag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>paramIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <code>DirtyFlag</code> in the shader parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">paramIndex</td><td>The index of the shader parameter.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
 The shader parameter set to <code>DirtyFlag</code> is applied to the uniform block by calling <code><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#acb09821f66b8cc37c265e6b8207dea33" title="Calculates render resources for materials.">CalculateMaterial()</a></code>. </p>

</div>
</div>
<a id="a27c2dd456913c6bebd2758ca7f0f6c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27c2dd456913c6bebd2758ca7f0f6c76">&#9670;&nbsp;</a></span>ConvertParams()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool swap&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::MaterialObj::ConvertParams </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts <code>SrcParam</code> and applies it to a uniform block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBuffer</td><td>Pointer to the buffer for storing the conversion result.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
 Call <code><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#aa44d1b19fac189403ad83a3be9a62c74" title="Converts SrcParam and applies it to a uniform block.">ConvertDirtyParams()</a></code> to take <code>DirtyFlag</code> into consideration and apply it to uniform blocks. </p>

</div>
</div>
<a id="aa44d1b19fac189403ad83a3be9a62c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44d1b19fac189403ad83a3be9a62c74">&#9670;&nbsp;</a></span>ConvertDirtyParams()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool swap&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::MaterialObj::ConvertDirtyParams </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bit32 *&#160;</td>
          <td class="paramname"><em>pDirtyFlagArray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts <code>SrcParam</code> and applies it to a uniform block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBuffer</td><td>Pointer to the buffer for storing the conversion result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pDirtyFlagArray</td><td>Pointer to <code>DirtyFlag</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>Performs conversion processing, taking <code>DirtyFlag</code> into consideration. <code><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#acb09821f66b8cc37c265e6b8207dea33" title="Calculates render resources for materials.">CalculateMaterial()</a></code> is called internally. </p>

</div>
</div>
<a id="a27ac9c046b937505db0e37e3d69f4c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ac9c046b937505db0e37e3d69f4c5d">&#9670;&nbsp;</a></span>ConvertVolatileParams()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool swap&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::MaterialObj::ConvertVolatileParams </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts <code>SrcParam</code> and applies it to a uniform block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBuffer</td><td>Pointer to the buffer for storing the conversion result.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
 <code><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#acb09821f66b8cc37c265e6b8207dea33" title="Calculates render resources for materials.">CalculateMaterial()</a></code> is called internally. </p>

</div>
</div>
<a id="a14e830a0f4882be506d510286cd65e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e830a0f4882be506d510286cd65e2b">&#9670;&nbsp;</a></span>InitializeDependPointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::MaterialObj::InitializeDependPointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a pointer to the dependent parameters. </p>
<p>This function makes calls to <code>Build()</code> and <code><a class="el" href="classnn_1_1g3d_1_1_material_obj.html#a763b3b157cd35d724b261dbf27700788" title="Gets the shader parameter to resource status.">ClearShaderParam()</a></code>. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
