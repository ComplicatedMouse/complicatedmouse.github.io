<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nn::irsensor Namespace Reference | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenn.html">nn</a></li><li class="navelem"><a class="el" href="namespacenn_1_1irsensor.html">irsensor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">nn::irsensor Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The namespace for the IR Motion Camera.  
<a href="namespacenn_1_1irsensor.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1irsensor_1_1_adaptive_clustering_data.html">AdaptiveClusteringData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct for output data of each object.  <a href="structnn_1_1irsensor_1_1_adaptive_clustering_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1irsensor_1_1_adaptive_clustering_processor_config.html">AdaptiveClusteringProcessorConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct for setting of AdaptiveClusteringProcessor.  <a href="structnn_1_1irsensor_1_1_adaptive_clustering_processor_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1irsensor_1_1_adaptive_clustering_processor_state.html">AdaptiveClusteringProcessorState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct for output data from AdaptiveClusteringProcessor.  <a href="structnn_1_1irsensor_1_1_adaptive_clustering_processor_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1irsensor_1_1_arm.html">Arm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for storing arm information.  <a href="structnn_1_1irsensor_1_1_arm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1irsensor_1_1_clustering_data.html">ClusteringData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure that represents the object for the clustering processor.  <a href="structnn_1_1irsensor_1_1_clustering_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1irsensor_1_1_clustering_processor_config.html">ClusteringProcessorConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that configures clustering processors.  <a href="structnn_1_1irsensor_1_1_clustering_processor_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1irsensor_1_1_clustering_processor_state.html">ClusteringProcessorState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure that represents clustering processor results.  <a href="structnn_1_1irsensor_1_1_clustering_processor_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1irsensor_1_1_finger.html">Finger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for storing extended finger information.  <a href="structnn_1_1irsensor_1_1_finger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1irsensor_1_1_hand.html">Hand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for storing hand information.  <a href="structnn_1_1irsensor_1_1_hand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1irsensor_1_1_hand_analysis_config.html">HandAnalysisConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for <code>HandAnalysis</code> mode configuration.  <a href="structnn_1_1irsensor_1_1_hand_analysis_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1irsensor_1_1_hand_analysis_image_state.html">HandAnalysisImageState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for storing image information.  <a href="structnn_1_1irsensor_1_1_hand_analysis_image_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1irsensor_1_1_hand_analysis_silhouette_state.html">HandAnalysisSilhouetteState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for storing the silhouette state.  <a href="structnn_1_1irsensor_1_1_hand_analysis_silhouette_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1irsensor_1_1_image_transfer_processor_config.html">ImageTransferProcessorConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that performs image transfer processor settings.  <a href="structnn_1_1irsensor_1_1_image_transfer_processor_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1irsensor_1_1_image_transfer_processor_ex_config.html">ImageTransferProcessorExConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure for configuring the advanced settings for the image transfer processor.  <a href="structnn_1_1irsensor_1_1_image_transfer_processor_ex_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1irsensor_1_1_image_transfer_processor_state.html">ImageTransferProcessorState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that represents image transfer processor results.  <a href="structnn_1_1irsensor_1_1_image_transfer_processor_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1irsensor_1_1_ir_camera_config.html">IrCameraConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that configures the IR Camera.  <a href="structnn_1_1irsensor_1_1_ir_camera_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The handle for the IR Camera.  <a href="structnn_1_1irsensor_1_1_ir_camera_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1irsensor_1_1_ir_led_processor_config.html">IrLedProcessorConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that configures infrared LED processors.  <a href="structnn_1_1irsensor_1_1_ir_led_processor_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1irsensor_1_1_moment_processor_config.html">MomentProcessorConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that configures moment processors.  <a href="structnn_1_1irsensor_1_1_moment_processor_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1irsensor_1_1_moment_processor_state.html">MomentProcessorState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure that represents moment processor results.  <a href="structnn_1_1irsensor_1_1_moment_processor_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1irsensor_1_1_moment_statistic.html">MomentStatistic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure that represents block statistics.  <a href="structnn_1_1irsensor_1_1_moment_statistic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1irsensor_1_1_palm.html">Palm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for storing palm information.  <a href="structnn_1_1irsensor_1_1_palm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1irsensor_1_1_pointing_processor_state.html">PointingProcessorState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure representing the results of the pointing processor.  <a href="structnn_1_1irsensor_1_1_pointing_processor_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1irsensor_1_1_protrusion.html">Protrusion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for storing protrusion information.  <a href="structnn_1_1irsensor_1_1_protrusion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1irsensor_1_1_rect.html">Rect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A rectangle.  <a href="structnn_1_1irsensor_1_1_rect.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1irsensor_1_1_result_hand_analysis_error.html">ResultHandAnalysisError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>irsensor</code>: <a class="el" href="structnn_1_1irsensor_1_1_hand.html" title="Structure for storing hand information.">Hand</a> analysis error.).  <a href="classnn_1_1irsensor_1_1_result_hand_analysis_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1irsensor_1_1_result_hand_analysis_mode_incorrect.html">ResultHandAnalysisModeIncorrect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>irsensor</code>: The current hand analysis mode does not match the one required by the function.).  <a href="classnn_1_1irsensor_1_1_result_hand_analysis_mode_incorrect.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_error.html">ResultIrsensorDeviceError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>irsensor</code>: The IR Motion Camera is not available because the device is in an invalid state.).  <a href="classnn_1_1irsensor_1_1_result_irsensor_device_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_not_ready.html">ResultIrsensorDeviceNotReady</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>irsensor</code>: No processing results are available immediately while starting the IR Motion Camera device.).  <a href="classnn_1_1irsensor_1_1_result_irsensor_device_not_ready.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_resource_not_available.html">ResultIrsensorDeviceResourceNotAvailable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>irsensor</code>: Cannot be used, either because of the restriction on the number of wireless connections or because device mutual exclusion did not occur appropriately.).  <a href="classnn_1_1irsensor_1_1_result_irsensor_device_resource_not_available.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_firmware_check_incompleted.html">ResultIrsensorFirmwareCheckIncompleted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>irsensor</code>: Confirming the controller firmware version.).  <a href="classnn_1_1irsensor_1_1_result_irsensor_firmware_check_incompleted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_not_ready.html">ResultIrsensorNotReady</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>irsensor</code>: No processing results are available immediately while starting the IR Motion Camera.).  <a href="classnn_1_1irsensor_1_1_result_irsensor_not_ready.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_unavailable.html">ResultIrsensorUnavailable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>irsensor</code>: The IR Motion Camera is not available.).  <a href="classnn_1_1irsensor_1_1_result_irsensor_unavailable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_unconnected.html">ResultIrsensorUnconnected</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>irsensor</code>: Device not connected.).  <a href="classnn_1_1irsensor_1_1_result_irsensor_unconnected.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_unsupported.html">ResultIrsensorUnsupported</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>irsensor</code>: The device does not have an IR Motion Camera.).  <a href="classnn_1_1irsensor_1_1_result_irsensor_unsupported.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1irsensor_1_1_shape.html">Shape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for storing shape information.  <a href="structnn_1_1irsensor_1_1_shape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:abbfdc7e7355cd0407880ef888db64cd3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#abbfdc7e7355cd0407880ef888db64cd3">AdaptiveClusteringAccuracyLevel</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#abbfdc7e7355cd0407880ef888db64cd3a9f9e8883afb2ad48dbbd04f17281ea06">AdaptiveClusteringAccuracyLevel_Low</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#abbfdc7e7355cd0407880ef888db64cd3a579026d9d42a08ff1bc00e2e6f8f9021">AdaptiveClusteringAccuracyLevel_Middle</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#abbfdc7e7355cd0407880ef888db64cd3a787f26a06ff9831c79838ca5d23b88c5">AdaptiveClusteringAccuracyLevel_High</a>
<br />
 }</td></tr>
<tr class="memdesc:abbfdc7e7355cd0407880ef888db64cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The accuracy level of the output of AdaptiveClusteringProcessor.  <a href="namespacenn_1_1irsensor.html#abbfdc7e7355cd0407880ef888db64cd3">More...</a><br /></td></tr>
<tr class="separator:abbfdc7e7355cd0407880ef888db64cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a822e3bff3ebd789816ac6089bd784"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a26a822e3bff3ebd789816ac6089bd784">AdaptiveClusteringMode</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#a26a822e3bff3ebd789816ac6089bd784a0a503d065ec6fb197156a39f266a564d">AdaptiveClusteringMode_StaticFov</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#a26a822e3bff3ebd789816ac6089bd784ae5ae628f21dcceae93fa86606661328b">AdaptiveClusteringMode_DynamicFov</a>
<br />
 }</td></tr>
<tr class="memdesc:a26a822e3bff3ebd789816ac6089bd784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mode of AdaptiveClusteringProcessor.  <a href="namespacenn_1_1irsensor.html#a26a822e3bff3ebd789816ac6089bd784">More...</a><br /></td></tr>
<tr class="separator:a26a822e3bff3ebd789816ac6089bd784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1669e542ddcd94807a8da1bb69f03b02"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a1669e542ddcd94807a8da1bb69f03b02">AdaptiveClusteringTargetDistance</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#a1669e542ddcd94807a8da1bb69f03b02a901417ff5d0fb481a4500abfb26a5be3">AdaptiveClusteringTargetDistance_Near</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#a1669e542ddcd94807a8da1bb69f03b02ad11aff9bc723551bc6b1f2b668c66783">AdaptiveClusteringTargetDistance_Middle</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#a1669e542ddcd94807a8da1bb69f03b02a07c5cceb92b0756eb9a78be1f54c448b">AdaptiveClusteringTargetDistance_Far</a>
<br />
 }</td></tr>
<tr class="memdesc:a1669e542ddcd94807a8da1bb69f03b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto camera setting depends on target distance of AdaptiveClusteringProcessor.  <a href="namespacenn_1_1irsensor.html#a1669e542ddcd94807a8da1bb69f03b02">More...</a><br /></td></tr>
<tr class="separator:a1669e542ddcd94807a8da1bb69f03b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31cf73bd4be6b9c484cc5a4694b42561"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a31cf73bd4be6b9c484cc5a4694b42561">HandAnalysisMode</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#a31cf73bd4be6b9c484cc5a4694b42561acb59771bed210926fe68765b4646df33">HandAnalysisMode_None</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#a31cf73bd4be6b9c484cc5a4694b42561aad8ee4675cf1c521d8503d0c523058de">HandAnalysisMode_Silhouette</a> = 1
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#a31cf73bd4be6b9c484cc5a4694b42561a4066257cab50e9055ce53c9f5af139f4">HandAnalysisMode_Image</a> = 2
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#a31cf73bd4be6b9c484cc5a4694b42561a55074831d40e94759b7991ac932f7718">HandAnalysisMode_SilhouetteAndImage</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#a31cf73bd4be6b9c484cc5a4694b42561aba9f7437b995bf4e2b678831a49d3a8f">HandAnalysisMode_SilhouetteOnly</a> = 4
<br />
 }</td></tr>
<tr class="memdesc:a31cf73bd4be6b9c484cc5a4694b42561"><td class="mdescLeft">&#160;</td><td class="mdescRight">HandAnalysis modes.  <a href="namespacenn_1_1irsensor.html#a31cf73bd4be6b9c484cc5a4694b42561">More...</a><br /></td></tr>
<tr class="separator:a31cf73bd4be6b9c484cc5a4694b42561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af456ff064e5b3f994431ecc41af00c85"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#af456ff064e5b3f994431ecc41af00c85">HandChirality</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#af456ff064e5b3f994431ecc41af00c85a10121024d0f814bdcb851f1b2ec4cf7c">HandChirality_Left</a> = 1
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#af456ff064e5b3f994431ecc41af00c85a7395391e1c5999bd8cc1914b1361d0a3">HandChirality_Right</a> = 2
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#af456ff064e5b3f994431ecc41af00c85a93c3f4a7dc5c76897b03f11fb781ee96">HandChirality_Unknown</a> = 3
<br />
 }</td></tr>
<tr class="memdesc:af456ff064e5b3f994431ecc41af00c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hand chirality.  <a href="namespacenn_1_1irsensor.html#af456ff064e5b3f994431ecc41af00c85">More...</a><br /></td></tr>
<tr class="separator:af456ff064e5b3f994431ecc41af00c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37c0f79e820e853e0cff75e318fe444"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#ab37c0f79e820e853e0cff75e318fe444">HandFinger</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#ab37c0f79e820e853e0cff75e318fe444ad00933a76f79d5d93f1a86940ff14c1a">HandFinger_Thumb</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#ab37c0f79e820e853e0cff75e318fe444a6a582e7888d4c86c72544bd6b9f48e81">HandFinger_Index</a> = 1
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#ab37c0f79e820e853e0cff75e318fe444a9c37c564ae3c1d163977a04992476ff1">HandFinger_Middle</a> = 2
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#ab37c0f79e820e853e0cff75e318fe444a70845e1440242f3e82fb34121fe35df0">HandFinger_Ring</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#ab37c0f79e820e853e0cff75e318fe444ac41ebb708657af6960c3334eb3552931">HandFinger_Little</a> = 4
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#ab37c0f79e820e853e0cff75e318fe444a2b00901c9706aaa764bf601b7ab3525d">HandFinger_Count</a> = 5
<br />
 }</td></tr>
<tr class="memdesc:ab37c0f79e820e853e0cff75e318fe444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hand fingers.  <a href="namespacenn_1_1irsensor.html#ab37c0f79e820e853e0cff75e318fe444">More...</a><br /></td></tr>
<tr class="separator:ab37c0f79e820e853e0cff75e318fe444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255ff51dbfddfbac97abff7fbcaf1d20"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a255ff51dbfddfbac97abff7fbcaf1d20">HandTouchingFingers</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#a255ff51dbfddfbac97abff7fbcaf1d20ab6f66b83b594956f941e08d224552dee">HandTouchingFingers_IndexMiddle</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#a255ff51dbfddfbac97abff7fbcaf1d20a5a022b65c80c7f35b63d4252959e4dc1">HandTouchingFingers_MiddleRing</a> = 1
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#a255ff51dbfddfbac97abff7fbcaf1d20a7a9ff928c23793a378407eea15693165">HandTouchingFingers_RingLittle</a> = 2
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#a255ff51dbfddfbac97abff7fbcaf1d20ac4f2bba61645dc2325c0b3529d1f7506">HandTouchingFingers_Count</a> = 3
<br />
 }</td></tr>
<tr class="memdesc:a255ff51dbfddfbac97abff7fbcaf1d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hand touching fingers enumeration.  <a href="namespacenn_1_1irsensor.html#a255ff51dbfddfbac97abff7fbcaf1d20">More...</a><br /></td></tr>
<tr class="separator:a255ff51dbfddfbac97abff7fbcaf1d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c9901e3b1df19725d41e8351305c2c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a29c9901e3b1df19725d41e8351305c2c">ImageProcessorStatus</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#a29c9901e3b1df19725d41e8351305c2caadeaeed48b15c1b8e14ae2c78ea5d948">ImageProcessorStatus_Stopped</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#a29c9901e3b1df19725d41e8351305c2ca620a77fb69f806db4e29eda5fd0f34bf">ImageProcessorStatus_Running</a>
<br />
 }</td></tr>
<tr class="memdesc:a29c9901e3b1df19725d41e8351305c2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The status of the image processor.  <a href="namespacenn_1_1irsensor.html#a29c9901e3b1df19725d41e8351305c2c">More...</a><br /></td></tr>
<tr class="separator:a29c9901e3b1df19725d41e8351305c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36a4c874ca3be558b04447fde22aae6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#ad36a4c874ca3be558b04447fde22aae6">ImageTransferProcessorFormat</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#ad36a4c874ca3be558b04447fde22aae6a5bb4b89236e4031f1c4dfe2c37d01d25">ImageTransferProcessorFormat_320x240</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#ad36a4c874ca3be558b04447fde22aae6af7a7501509fd95328276d0aba1cceb1e">ImageTransferProcessorFormat_160x120</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#ad36a4c874ca3be558b04447fde22aae6aa45053404d4a481499269f9093b768bf">ImageTransferProcessorFormat_80x60</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#ad36a4c874ca3be558b04447fde22aae6ab5d2f64820e5e8b7234defc29c346c2d">ImageTransferProcessorFormat_40x30</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#ad36a4c874ca3be558b04447fde22aae6a79212d51ccf03c6eae8e2a13a0087e53">ImageTransferProcessorFormat_20x15</a>
, <br />
&#160;&#160;<b>ImageTransferProcessorFormat_Qvga</b> = ImageTransferProcessorFormat_320x240
, <br />
&#160;&#160;<b>ImageTransferProcessorFormat_Qqvga</b> = ImageTransferProcessorFormat_160x120
, <br />
&#160;&#160;<b>ImageTransferProcessorFormat_Qqqvga</b> = ImageTransferProcessorFormat_80x60
<br />
 }</td></tr>
<tr class="memdesc:ad36a4c874ca3be558b04447fde22aae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The image formats available from image transfer processors.  <a href="namespacenn_1_1irsensor.html#ad36a4c874ca3be558b04447fde22aae6">More...</a><br /></td></tr>
<tr class="separator:ad36a4c874ca3be558b04447fde22aae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703533208b1dbc28e3cdaab0273feb57"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a703533208b1dbc28e3cdaab0273feb57">IrCameraAmbientNoiseLevel</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#a703533208b1dbc28e3cdaab0273feb57a5a72368c9075a209575393162d0e2a8f">IrCameraAmbientNoiseLevel_Low</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#a703533208b1dbc28e3cdaab0273feb57a8c918ef02b0622b18ad75fd6fd938e6f">IrCameraAmbientNoiseLevel_Middle</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#a703533208b1dbc28e3cdaab0273feb57aa7f3096c45e6a5605f94a95ab85cf1e8">IrCameraAmbientNoiseLevel_High</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#a703533208b1dbc28e3cdaab0273feb57a9b436fd8e2258f0b568d26e73ebb0171">IrCameraAmbientNoiseLevel_Unknown</a>
<br />
 }</td></tr>
<tr class="memdesc:a703533208b1dbc28e3cdaab0273feb57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure indicating the type of IR Camera environment noise.  <a href="namespacenn_1_1irsensor.html#a703533208b1dbc28e3cdaab0273feb57">More...</a><br /></td></tr>
<tr class="separator:a703533208b1dbc28e3cdaab0273feb57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02bb8cb4cc068779bd279a75ca0a4d5b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a02bb8cb4cc068779bd279a75ca0a4d5b">IrCameraLightTarget</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#a02bb8cb4cc068779bd279a75ca0a4d5ba65940aa7c31b87d9a23ad7252e46f078">IrCameraLightTarget_AllObjects</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#a02bb8cb4cc068779bd279a75ca0a4d5babe196ac31cdb50bf4bbb091d1fd6be43">IrCameraLightTarget_FarObjects</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#a02bb8cb4cc068779bd279a75ca0a4d5ba31f82d47ff3c1578ec7ad09424537fd0">IrCameraLightTarget_NearObjects</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#a02bb8cb4cc068779bd279a75ca0a4d5bab9a6412eeb03f04d01ce4095f4dc7c5c">IrCameraLightTarget_None</a>
<br />
 }</td></tr>
<tr class="memdesc:a02bb8cb4cc068779bd279a75ca0a4d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The IR Camera's lighting settings.  <a href="namespacenn_1_1irsensor.html#a02bb8cb4cc068779bd279a75ca0a4d5b">More...</a><br /></td></tr>
<tr class="separator:a02bb8cb4cc068779bd279a75ca0a4d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb1b253296b92663904ac18e7416b60"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a0fb1b253296b92663904ac18e7416b60">IrCameraStatus</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#a0fb1b253296b92663904ac18e7416b60abbb0ee81209053ee4ba83a445cd88c17">IrCameraStatus_Available</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#a0fb1b253296b92663904ac18e7416b60afa0b85228bb50e658b60831aec2766eb">IrCameraStatus_Unsupported</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#a0fb1b253296b92663904ac18e7416b60a6cb3f3719cad5742b5a1a23b8eddb118">IrCameraStatus_Unconnected</a>
<br />
 }</td></tr>
<tr class="memdesc:a0fb1b253296b92663904ac18e7416b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">The IR Camera state.  <a href="namespacenn_1_1irsensor.html#a0fb1b253296b92663904ac18e7416b60">More...</a><br /></td></tr>
<tr class="separator:a0fb1b253296b92663904ac18e7416b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8254eb1bb4e654b20e04d4c538ca0a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a4d8254eb1bb4e654b20e04d4c538ca0a">MomentProcessorPreprocess</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#a4d8254eb1bb4e654b20e04d4c538ca0aae5cc668084e3269fd017d639f4c88e28">MomentProcessorPreprocess_Binarize</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#a4d8254eb1bb4e654b20e04d4c538ca0aa0bfac7d7deede00897f0f520ada37720">MomentProcessorPreprocess_Cutoff</a>
<br />
 }</td></tr>
<tr class="memdesc:a4d8254eb1bb4e654b20e04d4c538ca0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Image processing before calculating a moment in the moment processor.  <a href="namespacenn_1_1irsensor.html#a4d8254eb1bb4e654b20e04d4c538ca0a">More...</a><br /></td></tr>
<tr class="separator:a4d8254eb1bb4e654b20e04d4c538ca0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b3e972e9bb240d0251809901c28649"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#ae1b3e972e9bb240d0251809901c28649">PointingStatus</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#ae1b3e972e9bb240d0251809901c28649a36621e8b5d4c80fa596e547cd1853256">PointingStatus_DataValid</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1irsensor.html#ae1b3e972e9bb240d0251809901c28649a29c26f2af0a3a1178487809244926d85">PointingStatus_LackOfObjects</a>
<br />
 }</td></tr>
<tr class="memdesc:ae1b3e972e9bb240d0251809901c28649"><td class="mdescLeft">&#160;</td><td class="mdescRight">The status of the data returned by the pointing processor.  <a href="namespacenn_1_1irsensor.html#ae1b3e972e9bb240d0251809901c28649">More...</a><br /></td></tr>
<tr class="separator:ae1b3e972e9bb240d0251809901c28649"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">AdaptiveClusteringProcessor</div></td></tr>
<tr class="memitem:a21c1240337850752888d537a405a3510"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a21c1240337850752888d537a405a3510">GetAdaptiveClusteringProcessorDefaultConfig</a> (<a class="el" href="structnn_1_1irsensor_1_1_adaptive_clustering_processor_config.html">AdaptiveClusteringProcessorConfig</a> *pOutValue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a21c1240337850752888d537a405a3510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get AdaptiveClustering default configuration.  <a href="namespacenn_1_1irsensor.html#a21c1240337850752888d537a405a3510">More...</a><br /></td></tr>
<tr class="separator:a21c1240337850752888d537a405a3510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561f17291cfd5377790181ebe352f14e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a561f17291cfd5377790181ebe352f14e">RunAdaptiveClusteringProcessor</a> (const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;handle, const <a class="el" href="structnn_1_1irsensor_1_1_adaptive_clustering_processor_config.html">AdaptiveClusteringProcessorConfig</a> &amp;config) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a561f17291cfd5377790181ebe352f14e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start AdaptiveClustering mode of IR sensor.  <a href="namespacenn_1_1irsensor.html#a561f17291cfd5377790181ebe352f14e">More...</a><br /></td></tr>
<tr class="separator:a561f17291cfd5377790181ebe352f14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ac056dc32e02615fd272dc24188ce7"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#aa7ac056dc32e02615fd272dc24188ce7">GetAdaptiveClusteringProcessorStates</a> (<a class="el" href="structnn_1_1irsensor_1_1_adaptive_clustering_processor_state.html">AdaptiveClusteringProcessorState</a> *pOutStates, int *pOutCount, int countMax, int64_t infSamplingNumber, const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa7ac056dc32e02615fd272dc24188ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve latest AdaptiveClustering mode data.  <a href="namespacenn_1_1irsensor.html#aa7ac056dc32e02615fd272dc24188ce7">More...</a><br /></td></tr>
<tr class="separator:aa7ac056dc32e02615fd272dc24188ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Clustering Processor</div></td></tr>
<tr class="memitem:a76270dbaa88f201f80bce7702dcfd3df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a76270dbaa88f201f80bce7702dcfd3df">GetClusteringProcessorDefaultConfig</a> (<a class="el" href="structnn_1_1irsensor_1_1_clustering_processor_config.html">ClusteringProcessorConfig</a> *pOutValue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a76270dbaa88f201f80bce7702dcfd3df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default settings for the clustering processor.  <a href="namespacenn_1_1irsensor.html#a76270dbaa88f201f80bce7702dcfd3df">More...</a><br /></td></tr>
<tr class="separator:a76270dbaa88f201f80bce7702dcfd3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a6afcb715377961a0f5382d16408c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a95a6afcb715377961a0f5382d16408c8">RunClusteringProcessor</a> (const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;handle, const <a class="el" href="structnn_1_1irsensor_1_1_clustering_processor_config.html">ClusteringProcessorConfig</a> &amp;config) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a95a6afcb715377961a0f5382d16408c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins processing for the IR Camera and clustering processor.  <a href="namespacenn_1_1irsensor.html#a95a6afcb715377961a0f5382d16408c8">More...</a><br /></td></tr>
<tr class="separator:a95a6afcb715377961a0f5382d16408c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6572060a5c7f41d2c19edde462fb5136"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a6572060a5c7f41d2c19edde462fb5136">GetClusteringProcessorState</a> (<a class="el" href="structnn_1_1irsensor_1_1_clustering_processor_state.html">ClusteringProcessorState</a> *pOutValue, const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6572060a5c7f41d2c19edde462fb5136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the latest results from the clustering processor.  <a href="namespacenn_1_1irsensor.html#a6572060a5c7f41d2c19edde462fb5136">More...</a><br /></td></tr>
<tr class="separator:a6572060a5c7f41d2c19edde462fb5136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83d851b9b53c14d5e661f240ac482c2"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#af83d851b9b53c14d5e661f240ac482c2">GetClusteringProcessorStates</a> (<a class="el" href="structnn_1_1irsensor_1_1_clustering_processor_state.html">ClusteringProcessorState</a> *pOutStates, int *pOutCount, int countMax, const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af83d851b9b53c14d5e661f240ac482c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets earlier clustering processor results.  <a href="namespacenn_1_1irsensor.html#af83d851b9b53c14d5e661f240ac482c2">More...</a><br /></td></tr>
<tr class="separator:af83d851b9b53c14d5e661f240ac482c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">HandAnalysis</div></td></tr>
<tr class="memitem:a51afe6cb83bd86357c696813ff5a1887"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a51afe6cb83bd86357c696813ff5a1887">RunHandAnalysis</a> (const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;handle, const <a class="el" href="structnn_1_1irsensor_1_1_hand_analysis_config.html">HandAnalysisConfig</a> &amp;config) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a51afe6cb83bd86357c696813ff5a1887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start HandAnalysis mode of the IR sensor.  <a href="namespacenn_1_1irsensor.html#a51afe6cb83bd86357c696813ff5a1887">More...</a><br /></td></tr>
<tr class="separator:a51afe6cb83bd86357c696813ff5a1887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28072a0acab4430a22b83bac1411d1fc"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a28072a0acab4430a22b83bac1411d1fc">GetHandAnalysisSilhouetteState</a> (<a class="el" href="structnn_1_1irsensor_1_1_hand_analysis_silhouette_state.html">HandAnalysisSilhouetteState</a> *pOutValueArray, int *pReturnCount, int maxCount, int64_t infSamplingNumber, const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a28072a0acab4430a22b83bac1411d1fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the latest <code>HandAnalysis</code> silhouette mode data.  <a href="namespacenn_1_1irsensor.html#a28072a0acab4430a22b83bac1411d1fc">More...</a><br /></td></tr>
<tr class="separator:a28072a0acab4430a22b83bac1411d1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067ae380c70a0125d0c606bbdcc72391"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a067ae380c70a0125d0c606bbdcc72391">GetHandAnalysisImageState</a> (<a class="el" href="structnn_1_1irsensor_1_1_hand_analysis_image_state.html">HandAnalysisImageState</a> *pOutValueArray, int *pReturnCount, int maxCount, int64_t infSamplingNumber, const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a067ae380c70a0125d0c606bbdcc72391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets reduced compressed IR camera images.  <a href="namespacenn_1_1irsensor.html#a067ae380c70a0125d0c606bbdcc72391">More...</a><br /></td></tr>
<tr class="separator:a067ae380c70a0125d0c606bbdcc72391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Image Processor</div></td></tr>
<tr class="memitem:a3052171f2c63aafc0e4a164366ae22d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a3052171f2c63aafc0e4a164366ae22d7">StopImageProcessor</a> (const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3052171f2c63aafc0e4a164366ae22d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the processing of the IR Motion Camera.  <a href="namespacenn_1_1irsensor.html#a3052171f2c63aafc0e4a164366ae22d7">More...</a><br /></td></tr>
<tr class="separator:a3052171f2c63aafc0e4a164366ae22d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2777438798de9cf9a3bfebbeb48251b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a2777438798de9cf9a3bfebbeb48251b0">StopImageProcessorAsync</a> (const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2777438798de9cf9a3bfebbeb48251b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously stops processing for the IR Motion Camera.  <a href="namespacenn_1_1irsensor.html#a2777438798de9cf9a3bfebbeb48251b0">More...</a><br /></td></tr>
<tr class="separator:a2777438798de9cf9a3bfebbeb48251b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07eb18481070f89065809a60a5928bcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1irsensor.html#a29c9901e3b1df19725d41e8351305c2c">ImageProcessorStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a07eb18481070f89065809a60a5928bcb">GetImageProcessorStatus</a> (const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a07eb18481070f89065809a60a5928bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the status of the image processor.  <a href="namespacenn_1_1irsensor.html#a07eb18481070f89065809a60a5928bcb">More...</a><br /></td></tr>
<tr class="separator:a07eb18481070f89065809a60a5928bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3c4ee95d75d413c596081063dfec18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1irsensor_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#aba3c4ee95d75d413c596081063dfec18">MakeRect</a> (int x, int y, int width, int height) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aba3c4ee95d75d413c596081063dfec18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the <code><a class="el" href="structnn_1_1irsensor_1_1_rect.html" title="A rectangle.">Rect</a></code> structure.  <a href="namespacenn_1_1irsensor.html#aba3c4ee95d75d413c596081063dfec18">More...</a><br /></td></tr>
<tr class="separator:aba3c4ee95d75d413c596081063dfec18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Image Transfer Processor</div></td></tr>
<tr class="memitem:a26ee50f1fe4bcaf8d89d863712801167"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a26ee50f1fe4bcaf8d89d863712801167">GetImageTransferProcessorDefaultConfig</a> (<a class="el" href="structnn_1_1irsensor_1_1_image_transfer_processor_config.html">ImageTransferProcessorConfig</a> *pOutValue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a26ee50f1fe4bcaf8d89d863712801167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the default settings for the image transfer processor.  <a href="namespacenn_1_1irsensor.html#a26ee50f1fe4bcaf8d89d863712801167">More...</a><br /></td></tr>
<tr class="separator:a26ee50f1fe4bcaf8d89d863712801167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075e4a12ff14c3c9026cccfbe27ab876"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a075e4a12ff14c3c9026cccfbe27ab876">GetImageTransferProcessorDefaultConfig</a> (<a class="el" href="structnn_1_1irsensor_1_1_image_transfer_processor_ex_config.html">ImageTransferProcessorExConfig</a> *pOutValue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a075e4a12ff14c3c9026cccfbe27ab876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the default advanced settings for the image transfer processor.  <a href="namespacenn_1_1irsensor.html#a075e4a12ff14c3c9026cccfbe27ab876">More...</a><br /></td></tr>
<tr class="separator:a075e4a12ff14c3c9026cccfbe27ab876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f53ceaaa5d3eaa0de9b45db288a2bc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a9f53ceaaa5d3eaa0de9b45db288a2bc1">RunImageTransferProcessor</a> (const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;handle, const <a class="el" href="structnn_1_1irsensor_1_1_image_transfer_processor_config.html">ImageTransferProcessorConfig</a> &amp;config, void *workBuffer, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9f53ceaaa5d3eaa0de9b45db288a2bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins processing for the IR Camera and image transfer processor.  <a href="namespacenn_1_1irsensor.html#a9f53ceaaa5d3eaa0de9b45db288a2bc1">More...</a><br /></td></tr>
<tr class="separator:a9f53ceaaa5d3eaa0de9b45db288a2bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36475abbe9c4d0f67093bcb652f2f27b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a36475abbe9c4d0f67093bcb652f2f27b">RunImageTransferProcessor</a> (const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;handle, const <a class="el" href="structnn_1_1irsensor_1_1_image_transfer_processor_ex_config.html">ImageTransferProcessorExConfig</a> &amp;config, void *workBuffer, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a36475abbe9c4d0f67093bcb652f2f27b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins processing associated with the advanced settings for the IR Camera and image transfer processor.  <a href="namespacenn_1_1irsensor.html#a36475abbe9c4d0f67093bcb652f2f27b">More...</a><br /></td></tr>
<tr class="separator:a36475abbe9c4d0f67093bcb652f2f27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e5d943258b76d2e90837bd319fa023"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#aa8e5d943258b76d2e90837bd319fa023">GetImageTransferProcessorState</a> (<a class="el" href="structnn_1_1irsensor_1_1_image_transfer_processor_state.html">ImageTransferProcessorState</a> *pOutState, void *pOutImage, size_t size, const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa8e5d943258b76d2e90837bd319fa023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the latest results from the image transfer processor.  <a href="namespacenn_1_1irsensor.html#aa8e5d943258b76d2e90837bd319fa023">More...</a><br /></td></tr>
<tr class="separator:aa8e5d943258b76d2e90837bd319fa023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">IR Camera</div></td></tr>
<tr class="memitem:a4772960359a06fcd86d2b9ffe85059fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a4772960359a06fcd86d2b9ffe85059fc">GetIrCameraHandle</a> (const ::<a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">nn::hid::NpadIdType</a> &amp;npadIdType) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4772960359a06fcd86d2b9ffe85059fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the handle for operating the IR camera in the Npad.  <a href="namespacenn_1_1irsensor.html#a4772960359a06fcd86d2b9ffe85059fc">More...</a><br /></td></tr>
<tr class="separator:a4772960359a06fcd86d2b9ffe85059fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c18eac7fe6430f1c9620e29169cf1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a43c18eac7fe6430f1c9620e29169cf1a">Initialize</a> (const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a43c18eac7fe6430f1c9620e29169cf1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the IR camera.  <a href="namespacenn_1_1irsensor.html#a43c18eac7fe6430f1c9620e29169cf1a">More...</a><br /></td></tr>
<tr class="separator:a43c18eac7fe6430f1c9620e29169cf1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6265f5c6e6d6fc0e67fc6882a8945284"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a6265f5c6e6d6fc0e67fc6882a8945284">Finalize</a> (const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6265f5c6e6d6fc0e67fc6882a8945284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes the IR camera.  <a href="namespacenn_1_1irsensor.html#a6265f5c6e6d6fc0e67fc6882a8945284">More...</a><br /></td></tr>
<tr class="separator:a6265f5c6e6d6fc0e67fc6882a8945284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf66c625dc12cd1fb0d06e79eb1d32a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1irsensor.html#a0fb1b253296b92663904ac18e7416b60">IrCameraStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#acf66c625dc12cd1fb0d06e79eb1d32a5">GetIrCameraStatus</a> (const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acf66c625dc12cd1fb0d06e79eb1d32a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the IR camera state.  <a href="namespacenn_1_1irsensor.html#acf66c625dc12cd1fb0d06e79eb1d32a5">More...</a><br /></td></tr>
<tr class="separator:acf66c625dc12cd1fb0d06e79eb1d32a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d917a320b39f4bc1f29f87d2418819"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#ae2d917a320b39f4bc1f29f87d2418819">CheckFirmwareUpdateNecessity</a> (bool *pOutIsUpdateNeeded, const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae2d917a320b39f4bc1f29f87d2418819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the firmware of the controller for using the IR Motion Camera needs to be updated.  <a href="namespacenn_1_1irsensor.html#ae2d917a320b39f4bc1f29f87d2418819">More...</a><br /></td></tr>
<tr class="separator:ae2d917a320b39f4bc1f29f87d2418819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Infrared LED Processor</div></td></tr>
<tr class="memitem:a11dddbdba407b43dd99418e81f3bcc8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a11dddbdba407b43dd99418e81f3bcc8b">GetIrLedProcessorDefaultConfig</a> (<a class="el" href="structnn_1_1irsensor_1_1_ir_led_processor_config.html">IrLedProcessorConfig</a> *pOutValue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a11dddbdba407b43dd99418e81f3bcc8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the default settings for the infrared LED processor.  <a href="namespacenn_1_1irsensor.html#a11dddbdba407b43dd99418e81f3bcc8b">More...</a><br /></td></tr>
<tr class="separator:a11dddbdba407b43dd99418e81f3bcc8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae776b3b5d6acbd2c9437bd503a94206e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#ae776b3b5d6acbd2c9437bd503a94206e">RunIrLedProcessor</a> (const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;handle, const <a class="el" href="structnn_1_1irsensor_1_1_ir_led_processor_config.html">IrLedProcessorConfig</a> &amp;config) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae776b3b5d6acbd2c9437bd503a94206e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts processing for the IR camera and the infrared LED processor.  <a href="namespacenn_1_1irsensor.html#ae776b3b5d6acbd2c9437bd503a94206e">More...</a><br /></td></tr>
<tr class="separator:ae776b3b5d6acbd2c9437bd503a94206e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cd44d2f79618df0fbb6698db27a24d"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a44cd44d2f79618df0fbb6698db27a24d">GetIrLedProcessorState</a> (const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a44cd44d2f79618df0fbb6698db27a24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the latest results from the infrared LED processor.  <a href="namespacenn_1_1irsensor.html#a44cd44d2f79618df0fbb6698db27a24d">More...</a><br /></td></tr>
<tr class="separator:a44cd44d2f79618df0fbb6698db27a24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Moment Processor</div></td></tr>
<tr class="memitem:aacc1373caac7c89a734b57cae50b506c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#aacc1373caac7c89a734b57cae50b506c">GetMomentProcessorDefaultConfig</a> (<a class="el" href="structnn_1_1irsensor_1_1_moment_processor_config.html">MomentProcessorConfig</a> *pOutValue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aacc1373caac7c89a734b57cae50b506c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the default settings for the moment processor.  <a href="namespacenn_1_1irsensor.html#aacc1373caac7c89a734b57cae50b506c">More...</a><br /></td></tr>
<tr class="separator:aacc1373caac7c89a734b57cae50b506c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0658b45f92e49e1612735574042920e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a0658b45f92e49e1612735574042920e9">RunMomentProcessor</a> (const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;handle, const <a class="el" href="structnn_1_1irsensor_1_1_moment_processor_config.html">MomentProcessorConfig</a> &amp;config) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0658b45f92e49e1612735574042920e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins processing for the IR Camera and moment processor.  <a href="namespacenn_1_1irsensor.html#a0658b45f92e49e1612735574042920e9">More...</a><br /></td></tr>
<tr class="separator:a0658b45f92e49e1612735574042920e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505a4e54e2b1931bd78c4a85f5b67276"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a505a4e54e2b1931bd78c4a85f5b67276">GetMomentProcessorState</a> (<a class="el" href="structnn_1_1irsensor_1_1_moment_processor_state.html">MomentProcessorState</a> *pOutValue, const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a505a4e54e2b1931bd78c4a85f5b67276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the latest results from the moment processor.  <a href="namespacenn_1_1irsensor.html#a505a4e54e2b1931bd78c4a85f5b67276">More...</a><br /></td></tr>
<tr class="separator:a505a4e54e2b1931bd78c4a85f5b67276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d616f420145c9b7ac415d3c3d93523"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a54d616f420145c9b7ac415d3c3d93523">GetMomentProcessorStates</a> (<a class="el" href="structnn_1_1irsensor_1_1_moment_processor_state.html">MomentProcessorState</a> *pOutStates, int *pOutCount, int countMax, const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a54d616f420145c9b7ac415d3c3d93523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets past moment processor results.  <a href="namespacenn_1_1irsensor.html#a54d616f420145c9b7ac415d3c3d93523">More...</a><br /></td></tr>
<tr class="separator:a54d616f420145c9b7ac415d3c3d93523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c192d7cb6147dc50ac8d4b1751d746"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1irsensor_1_1_moment_statistic.html">MomentStatistic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a59c192d7cb6147dc50ac8d4b1751d746">CalculateMomentRegionStatistic</a> (const <a class="el" href="structnn_1_1irsensor_1_1_moment_processor_state.html">MomentProcessorState</a> *pState, const <a class="el" href="structnn_1_1irsensor_1_1_rect.html">Rect</a> &amp;windowOfInterest, int startRow, int startColumn, int rowCount, int columnCount) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a59c192d7cb6147dc50ac8d4b1751d746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the statistics for a rectangular region comprised of multiple blocks.  <a href="namespacenn_1_1irsensor.html#a59c192d7cb6147dc50ac8d4b1751d746">More...</a><br /></td></tr>
<tr class="separator:a59c192d7cb6147dc50ac8d4b1751d746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Pointing Processor</div></td></tr>
<tr class="memitem:a35ef293f2a5162a81e7c07ea3693de82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a35ef293f2a5162a81e7c07ea3693de82">RunPointingProcessor</a> (const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a35ef293f2a5162a81e7c07ea3693de82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins processing for the IR camera and pointing processor.  <a href="namespacenn_1_1irsensor.html#a35ef293f2a5162a81e7c07ea3693de82">More...</a><br /></td></tr>
<tr class="separator:a35ef293f2a5162a81e7c07ea3693de82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe5dbef15c8120623fa7301622502e1"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#affe5dbef15c8120623fa7301622502e1">GetPointingProcessorStates</a> (<a class="el" href="structnn_1_1irsensor_1_1_pointing_processor_state.html">PointingProcessorState</a> *pOutStates, int *pOutCount, int countMax, const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:affe5dbef15c8120623fa7301622502e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets past pointing processor results.  <a href="namespacenn_1_1irsensor.html#affe5dbef15c8120623fa7301622502e1">More...</a><br /></td></tr>
<tr class="separator:affe5dbef15c8120623fa7301622502e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ace509e9d00563f37fae7da0c5fdfeefa"><td class="memItemLeft" align="right" valign="top"><a id="ace509e9d00563f37fae7da0c5fdfeefa"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#ace509e9d00563f37fae7da0c5fdfeefa">AdaptiveClusteringProcessorObjectCountMax</a> = 32</td></tr>
<tr class="memdesc:ace509e9d00563f37fae7da0c5fdfeefa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum object count. <br /></td></tr>
<tr class="separator:ace509e9d00563f37fae7da0c5fdfeefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749c05e24d85d5436c304ab14ceb2854"><td class="memItemLeft" align="right" valign="top"><a id="a749c05e24d85d5436c304ab14ceb2854"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a749c05e24d85d5436c304ab14ceb2854">AdaptiveClusteringProcessorStateCountMax</a> = 5</td></tr>
<tr class="memdesc:a749c05e24d85d5436c304ab14ceb2854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of buffered <a class="el" href="structnn_1_1irsensor_1_1_adaptive_clustering_processor_state.html" title="Struct for output data from AdaptiveClusteringProcessor.">AdaptiveClusteringProcessorState</a>. <br /></td></tr>
<tr class="separator:a749c05e24d85d5436c304ab14ceb2854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f600b878f3b96c8619313c81142b22c"><td class="memItemLeft" align="right" valign="top"><a id="a5f600b878f3b96c8619313c81142b22c"></a>
const ::<a class="el" href="structnn_1_1_time_span_type.html">nn::TimeSpanType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a5f600b878f3b96c8619313c81142b22c">ClusteringProcessorExposureTimeMax</a> = <a class="el" href="structnn_1_1_time_span_type.html#a48044a2e4967433e2f1e9e7251adc6e4">nn::TimeSpanType::FromMicroSeconds</a>(600)</td></tr>
<tr class="memdesc:a5f600b878f3b96c8619313c81142b22c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum exposure time the IR Camera can use when using clustering processors. <br /></td></tr>
<tr class="separator:a5f600b878f3b96c8619313c81142b22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403eb0fe2bdd0ff8ca6459fdde1022cb"><td class="memItemLeft" align="right" valign="top"><a id="a403eb0fe2bdd0ff8ca6459fdde1022cb"></a>
const ::<a class="el" href="structnn_1_1_time_span_type.html">nn::TimeSpanType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a403eb0fe2bdd0ff8ca6459fdde1022cb">ClusteringProcessorExposureTimeMin</a> = <a class="el" href="structnn_1_1_time_span_type.html#a48044a2e4967433e2f1e9e7251adc6e4">nn::TimeSpanType::FromMicroSeconds</a>(7)</td></tr>
<tr class="memdesc:a403eb0fe2bdd0ff8ca6459fdde1022cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum exposure time the IR Camera can use when using clustering processors. <br /></td></tr>
<tr class="separator:a403eb0fe2bdd0ff8ca6459fdde1022cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4681d9b5b813d52003ec67019b1f45"><td class="memItemLeft" align="right" valign="top"><a id="a6d4681d9b5b813d52003ec67019b1f45"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a6d4681d9b5b813d52003ec67019b1f45">ClusteringProcessorObjectCountMax</a> = 16</td></tr>
<tr class="memdesc:a6d4681d9b5b813d52003ec67019b1f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of objects that can be detected at the same time. <br /></td></tr>
<tr class="separator:a6d4681d9b5b813d52003ec67019b1f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4135a303a415a3f7fbd1e7a79deeb53a"><td class="memItemLeft" align="right" valign="top"><a id="a4135a303a415a3f7fbd1e7a79deeb53a"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a4135a303a415a3f7fbd1e7a79deeb53a">ClusteringProcessorObjectPixelCountMax</a> = 76800</td></tr>
<tr class="memdesc:a4135a303a415a3f7fbd1e7a79deeb53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum size of a detectable object. <br /></td></tr>
<tr class="separator:a4135a303a415a3f7fbd1e7a79deeb53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6719e27b18bf4c023b1a54564061155c"><td class="memItemLeft" align="right" valign="top"><a id="a6719e27b18bf4c023b1a54564061155c"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a6719e27b18bf4c023b1a54564061155c">ClusteringProcessorOutObjectPixelCountMax</a> = 65535</td></tr>
<tr class="memdesc:a6719e27b18bf4c023b1a54564061155c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum size for the object to export. <br /></td></tr>
<tr class="separator:a6719e27b18bf4c023b1a54564061155c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ebaaa373036fe0859a0315e33a42fe"><td class="memItemLeft" align="right" valign="top"><a id="a20ebaaa373036fe0859a0315e33a42fe"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a20ebaaa373036fe0859a0315e33a42fe">ClusteringProcessorStateCountMax</a> = 5</td></tr>
<tr class="memdesc:a20ebaaa373036fe0859a0315e33a42fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of <code><a class="el" href="structnn_1_1irsensor_1_1_clustering_processor_state.html" title="The structure that represents clustering processor results.">ClusteringProcessorState</a></code> maintained internally. <br /></td></tr>
<tr class="separator:a20ebaaa373036fe0859a0315e33a42fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cc50f1fb29e6e01d7d2ab7f719da57"><td class="memItemLeft" align="right" valign="top"><a id="a47cc50f1fb29e6e01d7d2ab7f719da57"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a47cc50f1fb29e6e01d7d2ab7f719da57">HandAnalysisProcessorStateCountMax</a> = 5</td></tr>
<tr class="memdesc:a47cc50f1fb29e6e01d7d2ab7f719da57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of buffered <code>HandAnalysisProcessorState</code>. <br /></td></tr>
<tr class="separator:a47cc50f1fb29e6e01d7d2ab7f719da57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85d14d4b35d233ad15582d3a98adbf4"><td class="memItemLeft" align="right" valign="top"><a id="ab85d14d4b35d233ad15582d3a98adbf4"></a>
const ::<a class="el" href="structnn_1_1_time_span_type.html">nn::TimeSpanType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#ab85d14d4b35d233ad15582d3a98adbf4">ImageTransferProcessorExposureTimeMax</a> = <a class="el" href="structnn_1_1_time_span_type.html#a48044a2e4967433e2f1e9e7251adc6e4">nn::TimeSpanType::FromMicroSeconds</a>(600)</td></tr>
<tr class="memdesc:ab85d14d4b35d233ad15582d3a98adbf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum exposure time the IR Camera can use when using image transfer processors. <br /></td></tr>
<tr class="separator:ab85d14d4b35d233ad15582d3a98adbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b762b41f5475c4b89cf22ac508e5631"><td class="memItemLeft" align="right" valign="top"><a id="a6b762b41f5475c4b89cf22ac508e5631"></a>
const ::<a class="el" href="structnn_1_1_time_span_type.html">nn::TimeSpanType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a6b762b41f5475c4b89cf22ac508e5631">ImageTransferProcessorExposureTimeMin</a> = <a class="el" href="structnn_1_1_time_span_type.html#a48044a2e4967433e2f1e9e7251adc6e4">nn::TimeSpanType::FromMicroSeconds</a>(7)</td></tr>
<tr class="memdesc:a6b762b41f5475c4b89cf22ac508e5631"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum exposure time the IR Camera can use when using image transfer processors. <br /></td></tr>
<tr class="separator:a6b762b41f5475c4b89cf22ac508e5631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba826d26024b307179f9548ba6c3c60"><td class="memItemLeft" align="right" valign="top"><a id="aeba826d26024b307179f9548ba6c3c60"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#aeba826d26024b307179f9548ba6c3c60">ImageTransferProcessorImageSize160x120</a> = 160 * 120</td></tr>
<tr class="memdesc:aeba826d26024b307179f9548ba6c3c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of an 8-bit grayscale image set to 160 × 120 pixels. <br /></td></tr>
<tr class="separator:aeba826d26024b307179f9548ba6c3c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0234906a11ddc4737c2316442d64b48"><td class="memItemLeft" align="right" valign="top"><a id="ab0234906a11ddc4737c2316442d64b48"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#ab0234906a11ddc4737c2316442d64b48">ImageTransferProcessorImageSize20x15</a> = 20 * 15</td></tr>
<tr class="memdesc:ab0234906a11ddc4737c2316442d64b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of an 8-bit grayscale image set to 20 × 15 pixels. <br /></td></tr>
<tr class="separator:ab0234906a11ddc4737c2316442d64b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04428ac73bdd0bcd81b3823ad500cc0d"><td class="memItemLeft" align="right" valign="top"><a id="a04428ac73bdd0bcd81b3823ad500cc0d"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a04428ac73bdd0bcd81b3823ad500cc0d">ImageTransferProcessorImageSize320x240</a> = 320 * 240</td></tr>
<tr class="memdesc:a04428ac73bdd0bcd81b3823ad500cc0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of an 8-bit grayscale image set to 320 × 240 pixels. <br /></td></tr>
<tr class="separator:a04428ac73bdd0bcd81b3823ad500cc0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab861349f9b5734ee9995138948919ba6"><td class="memItemLeft" align="right" valign="top"><a id="ab861349f9b5734ee9995138948919ba6"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#ab861349f9b5734ee9995138948919ba6">ImageTransferProcessorImageSize40x30</a> = 40 * 30</td></tr>
<tr class="memdesc:ab861349f9b5734ee9995138948919ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of an 8-bit grayscale image set to 40 × 30 pixels. <br /></td></tr>
<tr class="separator:ab861349f9b5734ee9995138948919ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfb7aa890458187b6f070f30393b364"><td class="memItemLeft" align="right" valign="top"><a id="aacfb7aa890458187b6f070f30393b364"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#aacfb7aa890458187b6f070f30393b364">ImageTransferProcessorImageSize80x60</a> = 80 * 60</td></tr>
<tr class="memdesc:aacfb7aa890458187b6f070f30393b364"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of an 8-bit grayscale image set to 80 × 60 pixels. <br /></td></tr>
<tr class="separator:aacfb7aa890458187b6f070f30393b364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb5b9164d5d38c070f66ac3f1e2538e"><td class="memItemLeft" align="right" valign="top"><a id="a0cb5b9164d5d38c070f66ac3f1e2538e"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a0cb5b9164d5d38c070f66ac3f1e2538e">ImageTransferProcessorWorkBufferSize160x120</a> = 40 * 1024</td></tr>
<tr class="memdesc:a0cb5b9164d5d38c070f66ac3f1e2538e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the working buffer for an 8-bit grayscale image set to 160 × 120 pixels. <br /></td></tr>
<tr class="separator:a0cb5b9164d5d38c070f66ac3f1e2538e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8530010d5f649c6f91dd76e456870c"><td class="memItemLeft" align="right" valign="top"><a id="a2b8530010d5f649c6f91dd76e456870c"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a2b8530010d5f649c6f91dd76e456870c">ImageTransferProcessorWorkBufferSize20x15</a> = 4 * 1024</td></tr>
<tr class="memdesc:a2b8530010d5f649c6f91dd76e456870c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the working buffer for an 8-bit grayscale image set to 20 × 15 pixels. <br /></td></tr>
<tr class="separator:a2b8530010d5f649c6f91dd76e456870c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f78a2c789fca767ee7754f62e3a1666"><td class="memItemLeft" align="right" valign="top"><a id="a4f78a2c789fca767ee7754f62e3a1666"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a4f78a2c789fca767ee7754f62e3a1666">ImageTransferProcessorWorkBufferSize320x240</a> = 152 * 1024</td></tr>
<tr class="memdesc:a4f78a2c789fca767ee7754f62e3a1666"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the working buffer for an 8-bit grayscale image set to 320 × 240 pixels. <br /></td></tr>
<tr class="separator:a4f78a2c789fca767ee7754f62e3a1666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7927c36b75a40cae22ef4cd7afd65b65"><td class="memItemLeft" align="right" valign="top"><a id="a7927c36b75a40cae22ef4cd7afd65b65"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a7927c36b75a40cae22ef4cd7afd65b65">ImageTransferProcessorWorkBufferSize40x30</a> = 4 * 1024</td></tr>
<tr class="memdesc:a7927c36b75a40cae22ef4cd7afd65b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the working buffer for an 8-bit grayscale image set to 40 × 30 pixels. <br /></td></tr>
<tr class="separator:a7927c36b75a40cae22ef4cd7afd65b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19c2200d3f78b135de89b8dc3bc7c7e"><td class="memItemLeft" align="right" valign="top"><a id="aa19c2200d3f78b135de89b8dc3bc7c7e"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#aa19c2200d3f78b135de89b8dc3bc7c7e">ImageTransferProcessorWorkBufferSize80x60</a> = 12 * 1024</td></tr>
<tr class="memdesc:aa19c2200d3f78b135de89b8dc3bc7c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the working buffer for an 8-bit grayscale image set to 80 × 60 pixels. <br /></td></tr>
<tr class="separator:aa19c2200d3f78b135de89b8dc3bc7c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a94a9dd2d62d8b4c757da50e8144837"><td class="memItemLeft" align="right" valign="top"><a id="a4a94a9dd2d62d8b4c757da50e8144837"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a4a94a9dd2d62d8b4c757da50e8144837">IrCameraGainMax</a> = 16</td></tr>
<tr class="memdesc:a4a94a9dd2d62d8b4c757da50e8144837"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum digital gain for the IR Camera. <br /></td></tr>
<tr class="separator:a4a94a9dd2d62d8b4c757da50e8144837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5192169f73e5e3d0ac2f8080f6c7a361"><td class="memItemLeft" align="right" valign="top"><a id="a5192169f73e5e3d0ac2f8080f6c7a361"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a5192169f73e5e3d0ac2f8080f6c7a361">IrCameraGainMin</a> = 1</td></tr>
<tr class="memdesc:a5192169f73e5e3d0ac2f8080f6c7a361"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum digital gain for the IR Camera. <br /></td></tr>
<tr class="separator:a5192169f73e5e3d0ac2f8080f6c7a361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ad760b9f753dd1253b3e4172932baf"><td class="memItemLeft" align="right" valign="top"><a id="ab2ad760b9f753dd1253b3e4172932baf"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#ab2ad760b9f753dd1253b3e4172932baf">IrCameraImageHeight</a> = 240</td></tr>
<tr class="memdesc:ab2ad760b9f753dd1253b3e4172932baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum height of an image that can be captured with the IR Camera. <br /></td></tr>
<tr class="separator:ab2ad760b9f753dd1253b3e4172932baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63bf35bb56e0d8d50733b01a61f1f4a6"><td class="memItemLeft" align="right" valign="top"><a id="a63bf35bb56e0d8d50733b01a61f1f4a6"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a63bf35bb56e0d8d50733b01a61f1f4a6">IrCameraImageWidth</a> = 320</td></tr>
<tr class="memdesc:a63bf35bb56e0d8d50733b01a61f1f4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum width of an image that can be captured with the IR Camera. <br /></td></tr>
<tr class="separator:a63bf35bb56e0d8d50733b01a61f1f4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af786cb096954c1d77477b4efe9b0fced"><td class="memItemLeft" align="right" valign="top"><a id="af786cb096954c1d77477b4efe9b0fced"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#af786cb096954c1d77477b4efe9b0fced">IrCameraIntensityMax</a> = 255</td></tr>
<tr class="memdesc:af786cb096954c1d77477b4efe9b0fced"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum luminance value for the IR Camera. <br /></td></tr>
<tr class="separator:af786cb096954c1d77477b4efe9b0fced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607969894ee12a356bb24afb2e0ee62e"><td class="memItemLeft" align="right" valign="top"><a id="a607969894ee12a356bb24afb2e0ee62e"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a607969894ee12a356bb24afb2e0ee62e">IrHandAnalysisHandCountMax</a> = 2</td></tr>
<tr class="memdesc:a607969894ee12a356bb24afb2e0ee62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of hands. <br /></td></tr>
<tr class="separator:a607969894ee12a356bb24afb2e0ee62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394e8820738ea0619c20cd14255c667c"><td class="memItemLeft" align="right" valign="top"><a id="a394e8820738ea0619c20cd14255c667c"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a394e8820738ea0619c20cd14255c667c">IrHandAnalysisImageHeight</a> = 30</td></tr>
<tr class="memdesc:a394e8820738ea0619c20cd14255c667c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Height of the image in hand analysis image mode. <br /></td></tr>
<tr class="separator:a394e8820738ea0619c20cd14255c667c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af872dc0bc911958515b1159883124be7"><td class="memItemLeft" align="right" valign="top"><a id="af872dc0bc911958515b1159883124be7"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#af872dc0bc911958515b1159883124be7">IrHandAnalysisImageWidth</a> = 40</td></tr>
<tr class="memdesc:af872dc0bc911958515b1159883124be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Width of the image in hand analysis image mode. <br /></td></tr>
<tr class="separator:af872dc0bc911958515b1159883124be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6463a995e11d001e7c2dc658011278"><td class="memItemLeft" align="right" valign="top"><a id="a7a6463a995e11d001e7c2dc658011278"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a7a6463a995e11d001e7c2dc658011278">IrHandAnalysisProtrusionCountMax</a> = 8</td></tr>
<tr class="memdesc:a7a6463a995e11d001e7c2dc658011278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of protrusions in one hand. <br /></td></tr>
<tr class="separator:a7a6463a995e11d001e7c2dc658011278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c5fafa7e56bae008e8cd354354b2c3"><td class="memItemLeft" align="right" valign="top"><a id="ad6c5fafa7e56bae008e8cd354354b2c3"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#ad6c5fafa7e56bae008e8cd354354b2c3">IrHandAnalysisShapeCountMax</a> = 16</td></tr>
<tr class="memdesc:ad6c5fafa7e56bae008e8cd354354b2c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of shapes. <br /></td></tr>
<tr class="separator:ad6c5fafa7e56bae008e8cd354354b2c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b91a9438bfa71369c36118088d97a7"><td class="memItemLeft" align="right" valign="top"><a id="a22b91a9438bfa71369c36118088d97a7"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a22b91a9438bfa71369c36118088d97a7">IrHandAnalysisShapePointCountMax</a> = 512</td></tr>
<tr class="memdesc:a22b91a9438bfa71369c36118088d97a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of points in the shape. <br /></td></tr>
<tr class="separator:a22b91a9438bfa71369c36118088d97a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1eb3129c3c4f712cc2d2abdad6764b"><td class="memItemLeft" align="right" valign="top"><a id="a1d1eb3129c3c4f712cc2d2abdad6764b"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a1d1eb3129c3c4f712cc2d2abdad6764b">MomentProcessorBlockColumnCount</a> = 8</td></tr>
<tr class="memdesc:a1d1eb3129c3c4f712cc2d2abdad6764b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of block divisions in the moment processor's x-axis direction. <br /></td></tr>
<tr class="separator:a1d1eb3129c3c4f712cc2d2abdad6764b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed61a87dec1d4b132b189eccfceb4232"><td class="memItemLeft" align="right" valign="top"><a id="aed61a87dec1d4b132b189eccfceb4232"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#aed61a87dec1d4b132b189eccfceb4232">MomentProcessorBlockCount</a> = <a class="el" href="namespacenn_1_1irsensor.html#a1d1eb3129c3c4f712cc2d2abdad6764b">MomentProcessorBlockColumnCount</a> * <a class="el" href="namespacenn_1_1irsensor.html#a6a72379158ea9356d7a6cda290fbe573">MomentProcessorBlockRowCount</a></td></tr>
<tr class="memdesc:aed61a87dec1d4b132b189eccfceb4232"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of moment processor block divisions. <br /></td></tr>
<tr class="separator:aed61a87dec1d4b132b189eccfceb4232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a72379158ea9356d7a6cda290fbe573"><td class="memItemLeft" align="right" valign="top"><a id="a6a72379158ea9356d7a6cda290fbe573"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a6a72379158ea9356d7a6cda290fbe573">MomentProcessorBlockRowCount</a> = 6</td></tr>
<tr class="memdesc:a6a72379158ea9356d7a6cda290fbe573"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of block divisions in the moment processor's y-axis direction. <br /></td></tr>
<tr class="separator:a6a72379158ea9356d7a6cda290fbe573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02947ecba3dbdc34593b713c29dc7c3"><td class="memItemLeft" align="right" valign="top"><a id="aa02947ecba3dbdc34593b713c29dc7c3"></a>
const ::<a class="el" href="structnn_1_1_time_span_type.html">nn::TimeSpanType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#aa02947ecba3dbdc34593b713c29dc7c3">MomentProcessorExposureTimeMax</a> = <a class="el" href="structnn_1_1_time_span_type.html#a48044a2e4967433e2f1e9e7251adc6e4">nn::TimeSpanType::FromMicroSeconds</a>(600)</td></tr>
<tr class="memdesc:aa02947ecba3dbdc34593b713c29dc7c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum exposure time the IR Camera can use when using moment processors. <br /></td></tr>
<tr class="separator:aa02947ecba3dbdc34593b713c29dc7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039655a501620da7f695a9e46b6e63cd"><td class="memItemLeft" align="right" valign="top"><a id="a039655a501620da7f695a9e46b6e63cd"></a>
const ::<a class="el" href="structnn_1_1_time_span_type.html">nn::TimeSpanType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a039655a501620da7f695a9e46b6e63cd">MomentProcessorExposureTimeMin</a> = <a class="el" href="structnn_1_1_time_span_type.html#a48044a2e4967433e2f1e9e7251adc6e4">nn::TimeSpanType::FromMicroSeconds</a>(7)</td></tr>
<tr class="memdesc:a039655a501620da7f695a9e46b6e63cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum exposure time the IR Camera can use when using moment processors. <br /></td></tr>
<tr class="separator:a039655a501620da7f695a9e46b6e63cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c24a28886e911ee63712d5e7dbec526"><td class="memItemLeft" align="right" valign="top"><a id="a3c24a28886e911ee63712d5e7dbec526"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a3c24a28886e911ee63712d5e7dbec526">MomentProcessorStateCountMax</a> = 5</td></tr>
<tr class="memdesc:a3c24a28886e911ee63712d5e7dbec526"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum for <code><a class="el" href="structnn_1_1irsensor_1_1_moment_processor_state.html" title="The structure that represents moment processor results.">MomentProcessorState</a></code> as it is maintained internally. <br /></td></tr>
<tr class="separator:a3c24a28886e911ee63712d5e7dbec526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f683d918639e67f27b4dc1a6e3e1a35"><td class="memItemLeft" align="right" valign="top"><a id="a6f683d918639e67f27b4dc1a6e3e1a35"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1irsensor.html#a6f683d918639e67f27b4dc1a6e3e1a35">PointingProcessorStateCountMax</a> = 6</td></tr>
<tr class="memdesc:a6f683d918639e67f27b4dc1a6e3e1a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of <code>PointingProcessorStates</code> that are stored internally. <br /></td></tr>
<tr class="separator:a6f683d918639e67f27b4dc1a6e3e1a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The namespace for the IR Motion Camera. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a26a822e3bff3ebd789816ac6089bd784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26a822e3bff3ebd789816ac6089bd784">&#9670;&nbsp;</a></span>AdaptiveClusteringMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1irsensor.html#a26a822e3bff3ebd789816ac6089bd784">nn::irsensor::AdaptiveClusteringMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mode of AdaptiveClusteringProcessor. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a26a822e3bff3ebd789816ac6089bd784a0a503d065ec6fb197156a39f266a564d"></a>AdaptiveClusteringMode_StaticFov&#160;</td><td class="fielddoc"><p>Only camera setting is adaptive. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26a822e3bff3ebd789816ac6089bd784ae5ae628f21dcceae93fa86606661328b"></a>AdaptiveClusteringMode_DynamicFov&#160;</td><td class="fielddoc"><p>Addition to camera settings, change fov adaptively with object tracking. </p>
</td></tr>
</table>

</div>
</div>
<a id="a1669e542ddcd94807a8da1bb69f03b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1669e542ddcd94807a8da1bb69f03b02">&#9670;&nbsp;</a></span>AdaptiveClusteringTargetDistance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1irsensor.html#a1669e542ddcd94807a8da1bb69f03b02">nn::irsensor::AdaptiveClusteringTargetDistance</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auto camera setting depends on target distance of AdaptiveClusteringProcessor. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1669e542ddcd94807a8da1bb69f03b02a901417ff5d0fb481a4500abfb26a5be3"></a>AdaptiveClusteringTargetDistance_Near&#160;</td><td class="fielddoc"><p>Auto camera setting for near range objects (approx, ~30cm). </p>
<p>Robustness for noise is high. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1669e542ddcd94807a8da1bb69f03b02ad11aff9bc723551bc6b1f2b668c66783"></a>AdaptiveClusteringTargetDistance_Middle&#160;</td><td class="fielddoc"><p>Auto camera setting for middle range objects (approx,~1m). </p>
<p>Robustness for noise is middle. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1669e542ddcd94807a8da1bb69f03b02a07c5cceb92b0756eb9a78be1f54c448b"></a>AdaptiveClusteringTargetDistance_Far&#160;</td><td class="fielddoc"><p>Auto camera setting for far range objects (approx, 1m ~). </p>
<p>Robustness for noise is low. </p>
</td></tr>
</table>

</div>
</div>
<a id="abbfdc7e7355cd0407880ef888db64cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbfdc7e7355cd0407880ef888db64cd3">&#9670;&nbsp;</a></span>AdaptiveClusteringAccuracyLevel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1irsensor.html#abbfdc7e7355cd0407880ef888db64cd3">nn::irsensor::AdaptiveClusteringAccuracyLevel</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The accuracy level of the output of AdaptiveClusteringProcessor. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abbfdc7e7355cd0407880ef888db64cd3a9f9e8883afb2ad48dbbd04f17281ea06"></a>AdaptiveClusteringAccuracyLevel_Low&#160;</td><td class="fielddoc"><p>Low quality frame to checking if there is no new object. </p>
<p>In a High quality frame flow, this frame can be ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="abbfdc7e7355cd0407880ef888db64cd3a579026d9d42a08ff1bc00e2e6f8f9021"></a>AdaptiveClusteringAccuracyLevel_Middle&#160;</td><td class="fielddoc"><p>Middle quality frame because the object is captured with a wide FOV. </p>
</td></tr>
<tr><td class="fieldname"><a id="abbfdc7e7355cd0407880ef888db64cd3a787f26a06ff9831c79838ca5d23b88c5"></a>AdaptiveClusteringAccuracyLevel_High&#160;</td><td class="fielddoc"><p>High quality frame because the object is captured with a narrow FOV. </p>
</td></tr>
</table>

</div>
</div>
<a id="a31cf73bd4be6b9c484cc5a4694b42561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31cf73bd4be6b9c484cc5a4694b42561">&#9670;&nbsp;</a></span>HandAnalysisMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1irsensor.html#a31cf73bd4be6b9c484cc5a4694b42561">nn::irsensor::HandAnalysisMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>HandAnalysis modes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a31cf73bd4be6b9c484cc5a4694b42561acb59771bed210926fe68765b4646df33"></a>HandAnalysisMode_None&#160;</td><td class="fielddoc"><p>Invalid compare. </p>
</td></tr>
<tr><td class="fieldname"><a id="a31cf73bd4be6b9c484cc5a4694b42561aad8ee4675cf1c521d8503d0c523058de"></a>HandAnalysisMode_Silhouette&#160;</td><td class="fielddoc"><p>The silhouette mode that provides hand information. </p>
</td></tr>
<tr><td class="fieldname"><a id="a31cf73bd4be6b9c484cc5a4694b42561a4066257cab50e9055ce53c9f5af139f4"></a>HandAnalysisMode_Image&#160;</td><td class="fielddoc"><p>The image mode that returns a compressed 40 × 30 sensor image. </p>
</td></tr>
<tr><td class="fieldname"><a id="a31cf73bd4be6b9c484cc5a4694b42561a55074831d40e94759b7991ac932f7718"></a>HandAnalysisMode_SilhouetteAndImage&#160;</td><td class="fielddoc"><p>The silhouette and compressed image in an interleaved sequence. </p>
</td></tr>
<tr><td class="fieldname"><a id="a31cf73bd4be6b9c484cc5a4694b42561aba9f7437b995bf4e2b678831a49d3a8f"></a>HandAnalysisMode_SilhouetteOnly&#160;</td><td class="fielddoc"><p>The silhouette mode that provides only silhouette information with a faster framerate. </p>
</td></tr>
</table>

</div>
</div>
<a id="af456ff064e5b3f994431ecc41af00c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af456ff064e5b3f994431ecc41af00c85">&#9670;&nbsp;</a></span>HandChirality</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1irsensor.html#af456ff064e5b3f994431ecc41af00c85">nn::irsensor::HandChirality</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1irsensor_1_1_hand.html" title="Structure for storing hand information.">Hand</a> chirality. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af456ff064e5b3f994431ecc41af00c85a10121024d0f814bdcb851f1b2ec4cf7c"></a>HandChirality_Left&#160;</td><td class="fielddoc"><p>Left hand. </p>
</td></tr>
<tr><td class="fieldname"><a id="af456ff064e5b3f994431ecc41af00c85a7395391e1c5999bd8cc1914b1361d0a3"></a>HandChirality_Right&#160;</td><td class="fielddoc"><p>Right hand. </p>
</td></tr>
<tr><td class="fieldname"><a id="af456ff064e5b3f994431ecc41af00c85a93c3f4a7dc5c76897b03f11fb781ee96"></a>HandChirality_Unknown&#160;</td><td class="fielddoc"><p>Left or right hand. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab37c0f79e820e853e0cff75e318fe444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab37c0f79e820e853e0cff75e318fe444">&#9670;&nbsp;</a></span>HandFinger</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1irsensor.html#ab37c0f79e820e853e0cff75e318fe444">nn::irsensor::HandFinger</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1irsensor_1_1_hand.html" title="Structure for storing hand information.">Hand</a> fingers. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab37c0f79e820e853e0cff75e318fe444ad00933a76f79d5d93f1a86940ff14c1a"></a>HandFinger_Thumb&#160;</td><td class="fielddoc"><p>Thumb. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab37c0f79e820e853e0cff75e318fe444a6a582e7888d4c86c72544bd6b9f48e81"></a>HandFinger_Index&#160;</td><td class="fielddoc"><p>Index finger. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab37c0f79e820e853e0cff75e318fe444a9c37c564ae3c1d163977a04992476ff1"></a>HandFinger_Middle&#160;</td><td class="fielddoc"><p>Middle finger. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab37c0f79e820e853e0cff75e318fe444a70845e1440242f3e82fb34121fe35df0"></a>HandFinger_Ring&#160;</td><td class="fielddoc"><p>Ring finger. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab37c0f79e820e853e0cff75e318fe444ac41ebb708657af6960c3334eb3552931"></a>HandFinger_Little&#160;</td><td class="fielddoc"><p>Little finger. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab37c0f79e820e853e0cff75e318fe444a2b00901c9706aaa764bf601b7ab3525d"></a>HandFinger_Count&#160;</td><td class="fielddoc"><p>Number of fingers. </p>
</td></tr>
</table>

</div>
</div>
<a id="a255ff51dbfddfbac97abff7fbcaf1d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a255ff51dbfddfbac97abff7fbcaf1d20">&#9670;&nbsp;</a></span>HandTouchingFingers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1irsensor.html#a255ff51dbfddfbac97abff7fbcaf1d20">nn::irsensor::HandTouchingFingers</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1irsensor_1_1_hand.html" title="Structure for storing hand information.">Hand</a> touching fingers enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a255ff51dbfddfbac97abff7fbcaf1d20ab6f66b83b594956f941e08d224552dee"></a>HandTouchingFingers_IndexMiddle&#160;</td><td class="fielddoc"><p>Index and middle fingers. </p>
</td></tr>
<tr><td class="fieldname"><a id="a255ff51dbfddfbac97abff7fbcaf1d20a5a022b65c80c7f35b63d4252959e4dc1"></a>HandTouchingFingers_MiddleRing&#160;</td><td class="fielddoc"><p>Middle and ring fingers. </p>
</td></tr>
<tr><td class="fieldname"><a id="a255ff51dbfddfbac97abff7fbcaf1d20a7a9ff928c23793a378407eea15693165"></a>HandTouchingFingers_RingLittle&#160;</td><td class="fielddoc"><p>Ring and little fingers. </p>
</td></tr>
<tr><td class="fieldname"><a id="a255ff51dbfddfbac97abff7fbcaf1d20ac4f2bba61645dc2325c0b3529d1f7506"></a>HandTouchingFingers_Count&#160;</td><td class="fielddoc"><p>Count. </p>
</td></tr>
</table>

</div>
</div>
<a id="a29c9901e3b1df19725d41e8351305c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c9901e3b1df19725d41e8351305c2c">&#9670;&nbsp;</a></span>ImageProcessorStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1irsensor.html#a29c9901e3b1df19725d41e8351305c2c">nn::irsensor::ImageProcessorStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The status of the image processor. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a29c9901e3b1df19725d41e8351305c2caadeaeed48b15c1b8e14ae2c78ea5d948"></a>ImageProcessorStatus_Stopped&#160;</td><td class="fielddoc"><p>The image processor is in a stopped state. </p>
</td></tr>
<tr><td class="fieldname"><a id="a29c9901e3b1df19725d41e8351305c2ca620a77fb69f806db4e29eda5fd0f34bf"></a>ImageProcessorStatus_Running&#160;</td><td class="fielddoc"><p>The image processor is in a running state. </p>
</td></tr>
</table>

</div>
</div>
<a id="ad36a4c874ca3be558b04447fde22aae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36a4c874ca3be558b04447fde22aae6">&#9670;&nbsp;</a></span>ImageTransferProcessorFormat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1irsensor.html#ad36a4c874ca3be558b04447fde22aae6">nn::irsensor::ImageTransferProcessorFormat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The image formats available from image transfer processors. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad36a4c874ca3be558b04447fde22aae6a5bb4b89236e4031f1c4dfe2c37d01d25"></a>ImageTransferProcessorFormat_320x240&#160;</td><td class="fielddoc"><p>An 8-bit grayscale image that is 320 × 240 pixels. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad36a4c874ca3be558b04447fde22aae6af7a7501509fd95328276d0aba1cceb1e"></a>ImageTransferProcessorFormat_160x120&#160;</td><td class="fielddoc"><p>An 8-bit grayscale image that is 160 × 120 pixels. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad36a4c874ca3be558b04447fde22aae6aa45053404d4a481499269f9093b768bf"></a>ImageTransferProcessorFormat_80x60&#160;</td><td class="fielddoc"><p>An 8-bit grayscale image that is 80 × 60 pixels. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad36a4c874ca3be558b04447fde22aae6ab5d2f64820e5e8b7234defc29c346c2d"></a>ImageTransferProcessorFormat_40x30&#160;</td><td class="fielddoc"><p>An 8-bit grayscale image that is 40 × 30 pixels. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad36a4c874ca3be558b04447fde22aae6a79212d51ccf03c6eae8e2a13a0087e53"></a>ImageTransferProcessorFormat_20x15&#160;</td><td class="fielddoc"><p>An 8-bit grayscale image that is 20 × 15 pixels. </p>
</td></tr>
</table>

</div>
</div>
<a id="a0fb1b253296b92663904ac18e7416b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fb1b253296b92663904ac18e7416b60">&#9670;&nbsp;</a></span>IrCameraStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1irsensor.html#a0fb1b253296b92663904ac18e7416b60">nn::irsensor::IrCameraStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The IR Camera state. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0fb1b253296b92663904ac18e7416b60abbb0ee81209053ee4ba83a445cd88c17"></a>IrCameraStatus_Available&#160;</td><td class="fielddoc"><p>There is an IR Camera in the device and it is available. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0fb1b253296b92663904ac18e7416b60afa0b85228bb50e658b60831aec2766eb"></a>IrCameraStatus_Unsupported&#160;</td><td class="fielddoc"><p>There is no IR Camera in the device. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0fb1b253296b92663904ac18e7416b60a6cb3f3719cad5742b5a1a23b8eddb118"></a>IrCameraStatus_Unconnected&#160;</td><td class="fielddoc"><p>The device is not connected. </p>
</td></tr>
</table>

</div>
</div>
<a id="a703533208b1dbc28e3cdaab0273feb57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703533208b1dbc28e3cdaab0273feb57">&#9670;&nbsp;</a></span>IrCameraAmbientNoiseLevel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1irsensor.html#a703533208b1dbc28e3cdaab0273feb57">nn::irsensor::IrCameraAmbientNoiseLevel</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Structure indicating the type of IR Camera environment noise. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a703533208b1dbc28e3cdaab0273feb57a5a72368c9075a209575393162d0e2a8f"></a>IrCameraAmbientNoiseLevel_Low&#160;</td><td class="fielddoc"><p>Little environment noise; IR processor can be used normally. </p>
</td></tr>
<tr><td class="fieldname"><a id="a703533208b1dbc28e3cdaab0273feb57a8c918ef02b0622b18ad75fd6fd938e6f"></a>IrCameraAmbientNoiseLevel_Middle&#160;</td><td class="fielddoc"><p>Medium degree of environment noise; IR processor behavior affected. </p>
</td></tr>
<tr><td class="fieldname"><a id="a703533208b1dbc28e3cdaab0273feb57aa7f3096c45e6a5605f94a95ab85cf1e8"></a>IrCameraAmbientNoiseLevel_High&#160;</td><td class="fielddoc"><p>Lots of environment noise; IR processor cannot be used normally. </p>
</td></tr>
<tr><td class="fieldname"><a id="a703533208b1dbc28e3cdaab0273feb57a9b436fd8e2258f0b568d26e73ebb0171"></a>IrCameraAmbientNoiseLevel_Unknown&#160;</td><td class="fielddoc"><p>Ability to gauge environment noise not functioning; noise status unknown. </p>
</td></tr>
</table>

</div>
</div>
<a id="a02bb8cb4cc068779bd279a75ca0a4d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02bb8cb4cc068779bd279a75ca0a4d5b">&#9670;&nbsp;</a></span>IrCameraLightTarget</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1irsensor.html#a02bb8cb4cc068779bd279a75ca0a4d5b">nn::irsensor::IrCameraLightTarget</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The IR Camera's lighting settings. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a02bb8cb4cc068779bd279a75ca0a4d5ba65940aa7c31b87d9a23ad7252e46f078"></a>IrCameraLightTarget_AllObjects&#160;</td><td class="fielddoc"><p>Illuminate all lighting. </p>
<p>The brightest setting. </p>
</td></tr>
<tr><td class="fieldname"><a id="a02bb8cb4cc068779bd279a75ca0a4d5babe196ac31cdb50bf4bbb091d1fd6be43"></a>IrCameraLightTarget_FarObjects&#160;</td><td class="fielddoc"><p>Illuminate only the lighting that shines in a narrow range, to a great distance. </p>
</td></tr>
<tr><td class="fieldname"><a id="a02bb8cb4cc068779bd279a75ca0a4d5ba31f82d47ff3c1578ec7ad09424537fd0"></a>IrCameraLightTarget_NearObjects&#160;</td><td class="fielddoc"><p>Illuminate only the lighting that shines in a broad range, up close. </p>
</td></tr>
<tr><td class="fieldname"><a id="a02bb8cb4cc068779bd279a75ca0a4d5bab9a6412eeb03f04d01ce4095f4dc7c5c"></a>IrCameraLightTarget_None&#160;</td><td class="fielddoc"><p>Extinguish all lighting. </p>
<p>The darkest setting. </p>
</td></tr>
</table>

</div>
</div>
<a id="a4d8254eb1bb4e654b20e04d4c538ca0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8254eb1bb4e654b20e04d4c538ca0a">&#9670;&nbsp;</a></span>MomentProcessorPreprocess</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1irsensor.html#a4d8254eb1bb4e654b20e04d4c538ca0a">nn::irsensor::MomentProcessorPreprocess</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Image processing before calculating a moment in the moment processor. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4d8254eb1bb4e654b20e04d4c538ca0aae5cc668084e3269fd017d639f4c88e28"></a>MomentProcessorPreprocess_Binarize&#160;</td><td class="fielddoc"><p>Sets all luminance values below the threshold to <code>0</code>, and all luminance values above the threshold to <code>IrCameraIntensityMax</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4d8254eb1bb4e654b20e04d4c538ca0aa0bfac7d7deede00897f0f520ada37720"></a>MomentProcessorPreprocess_Cutoff&#160;</td><td class="fielddoc"><p>Sets all luminance values below the threshold to 0. </p>
</td></tr>
</table>

</div>
</div>
<a id="ae1b3e972e9bb240d0251809901c28649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b3e972e9bb240d0251809901c28649">&#9670;&nbsp;</a></span>PointingStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1irsensor.html#ae1b3e972e9bb240d0251809901c28649">nn::irsensor::PointingStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The status of the data returned by the pointing processor. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae1b3e972e9bb240d0251809901c28649a36621e8b5d4c80fa596e547cd1853256"></a>PointingStatus_DataValid&#160;</td><td class="fielddoc"><p>The data is enabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae1b3e972e9bb240d0251809901c28649a29c26f2af0a3a1178487809244926d85"></a>PointingStatus_LackOfObjects&#160;</td><td class="fielddoc"><p>Not enough objects are detected. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a21c1240337850752888d537a405a3510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c1240337850752888d537a405a3510">&#9670;&nbsp;</a></span>GetAdaptiveClusteringProcessorDefaultConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::irsensor::GetAdaptiveClusteringProcessorDefaultConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1irsensor_1_1_adaptive_clustering_processor_config.html">AdaptiveClusteringProcessorConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get AdaptiveClustering default configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValue</td><td>Default configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>pOutValue != nullptr </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ir_sensor_adaptive_clustering_basic_2_ir_sensor_adaptive_clustering_basic_8cpp-example.html#a52">IrSensorAdaptiveClusteringBasic/IrSensorAdaptiveClusteringBasic.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a561f17291cfd5377790181ebe352f14e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561f17291cfd5377790181ebe352f14e">&#9670;&nbsp;</a></span>RunAdaptiveClusteringProcessor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::irsensor::RunAdaptiveClusteringProcessor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_adaptive_clustering_processor_config.html">AdaptiveClusteringProcessorConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start AdaptiveClustering mode of IR sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Handle of IR camera </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Setting for AdaptiveClustering processor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>Handle is already initialized via Initialize API</li>
<li>For given handle, IR camera is not running yet</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 User call Run**() API and IR sensor starts processing User keeps getting data via Get**() API while AdaptiveClustering is running When IR sensor is already running another mode, it stops running mode and starts AdaptiveClustering mode. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ir_sensor_adaptive_clustering_basic_2_ir_sensor_adaptive_clustering_basic_8cpp-example.html#a53">IrSensorAdaptiveClusteringBasic/IrSensorAdaptiveClusteringBasic.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aa7ac056dc32e02615fd272dc24188ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ac056dc32e02615fd272dc24188ce7">&#9670;&nbsp;</a></span>GetAdaptiveClusteringProcessorStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::irsensor::GetAdaptiveClusteringProcessorStates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1irsensor_1_1_adaptive_clustering_processor_state.html">AdaptiveClusteringProcessorState</a> *&#160;</td>
          <td class="paramname"><em>pOutStates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>countMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>infSamplingNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve latest AdaptiveClustering mode data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutStates</td><td>User allocated array that will receive the processed data </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutCount</td><td>Number of elements written to pOutStates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">countMax</td><td>Maximum number of elements that can be written to pOutStates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">infSamplingNumber</td><td>Lowest sampling number of elements you want to retrieve </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Handle of IR sensor</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
 This function retrieves AdaptiveClustering states sent by the IR sensor. You can retrieve several states at the same time. The function will return all the states available where infSamplingNumber &lt;= state.samplingNumber. If your array is not large enough it will return the more recent silhouette states, i.e. the highest sampling numbers. Usually you want infSamplingNumber == 0 for the first call and having infSamplingNumber == lastSamplingNumber + 1 for the next one.</p>
<p>Unlike other irsensor modes (like clustering or moment modes), getting states in the AdaptiveClustering mode will copy and decode data, which is time consuming. The benefit of using infSamplingNumber is to avoid extra computation for states you already received.</p>
<p>When the IR sensor is not functioning properly, the system will display a dialog with an error message. This function blocks the calling thread while the message is displayed. After the user closes the error dialog, the function returns <a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_error.html" title="A class that represents error Result values (irsensor: The IR Motion Camera is not available because ...">nn::irsensor::ResultIrsensorDeviceError</a>.</p>
<p>When the controller firmware needs an update, the system calls the controller support applet to update it. While updating, this function blocks the calling thread. If the update succeeds this function returns <a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_not_ready.html" title="A class that represents error Result values (irsensor: No processing results are available immediatel...">nn::irsensor::ResultIrsensorDeviceNotReady</a>, and otherwise returns <a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_error.html" title="A class that represents error Result values (irsensor: The IR Motion Camera is not available because ...">nn::irsensor::ResultIrsensorDeviceError</a>.</p>
<p>IR sensor is not available when the application uses NFC functions on at least one controller. When there are more than 4 connected controllers, only the first IR sensor is available. If these constraints are not satisfied, this function returns <a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_resource_not_available.html" title="A class that represents error Result values (irsensor: Cannot be used, either because of the restrict...">nn::irsensor::ResultIrsensorDeviceResourceNotAvailable</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_not_ready.html">nn::irsensor::ResultIrsensorDeviceNotReady</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_unavailable.html">nn::irsensor::ResultIrsensorUnavailable</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_error.html">nn::irsensor::ResultIrsensorDeviceError</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_resource_not_available.html">nn::irsensor::ResultIrsensorDeviceResourceNotAvailable</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>Handle is already initialized via Initialize API.</li>
<li>For a given handle, IR camera is running as AdaptiveClustering mode</li>
<li>pOutStates != nullptr</li>
<li>pOutCount != nullptr </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>For all pOutValue in pOutStates .. pOutStates + pOutCount - 1:<ul>
<li>0 &lt;= pOutValue-&gt;objectCount &amp;&amp; pOutValue-&gt;objectCount &lt;= AdaptiveClusteringProcessorObjectCountMax </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ir_sensor_adaptive_clustering_basic_2_ir_sensor_adaptive_clustering_basic_8cpp-example.html#a19">IrSensorAdaptiveClusteringBasic/IrSensorAdaptiveClusteringBasic.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a76270dbaa88f201f80bce7702dcfd3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76270dbaa88f201f80bce7702dcfd3df">&#9670;&nbsp;</a></span>GetClusteringProcessorDefaultConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::irsensor::GetClusteringProcessorDefaultConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1irsensor_1_1_clustering_processor_config.html">ClusteringProcessorConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the default settings for the clustering processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValue</td><td>Default settings for the clustering processor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutValue</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ir_sensor_clustering_basic_2_ir_sensor_clustering_basic_8cpp-example.html#a58">IrSensorClusteringBasic/IrSensorClusteringBasic.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a95a6afcb715377961a0f5382d16408c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a6afcb715377961a0f5382d16408c8">&#9670;&nbsp;</a></span>RunClusteringProcessor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::irsensor::RunClusteringProcessor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_clustering_processor_config.html">ClusteringProcessorConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begins processing for the IR Camera and clustering processor. </p>
<p>If all preprocessors are running, stops the running processors and performs the moment processor processing again. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>IR Camera handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Clustering processor settings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The IR Camera is initialized with the specified handle.</li>
<li><code><em>config</em></code>, the clustering processor settings.<ul>
<li><code>ClusteringProcessorExposureTimeMin</code> &lt;= <code><em>config</em>.irCameraConfig.exposureTime</code>.</li>
<li><code><em>config</em>.irCameraConfig.exposureTime</code> &lt;= <code>ClusteringProcessorExposureTimeMax</code>.</li>
<li><code>IrCameraGainMin</code> &lt;= <code><em>config</em>.irCameraConfig.gain</code></li>
<li><code><em>config</em>.irCameraConfig.gain</code> &lt;= <code>IrCameraGainMax</code>.</li>
<li><code>0</code> &lt;= <code><em>config</em>.windowOfInterest.x</code>.</li>
<li><code>1</code> &lt;= <code><em>config</em>.windowOfInterest.width</code>.</li>
<li><code><em>config</em>.windowOfInterest.x</code> + <code><em>config</em>.windowOfInterest.width</code> &lt;= <code>IrCameraImageWidth</code></li>
<li><code>0</code> &lt;= <code><em>config</em>.windowOfInterest.y</code>.</li>
<li><code>1</code> &lt;= <code><em>config</em>.windowOfInterest.height</code>.</li>
<li><code><em>config</em>.windowOfInterest.y</code> + <code><em>config</em>.windowOfInterest.height</code> &lt;= <code>IrCameraImageHeight</code></li>
<li><code>0</code> &lt;= <code><em>config</em>.objectPixelCountMin</code>.</li>
<li><code><em>config</em>.objectPixelCountMin</code> &lt;= <code>ClusteringProcessorObjectPixelCountMax</code></li>
<li><code>0</code> &lt;= <code><em>config</em>.objectPixelCountMax</code>.</li>
<li><code><em>config</em>.objectPixelCountMin</code> &lt;= <code>ClusteringProcessorObjectPixelCountMax</code> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The IR Camera corresponding to the specified handle is in a state where it is using and running the clustering processor.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 If the IR Camera corresponding to the specified handled is in a stopped state, apply the settings to the IR Camera and cluster processor. Puts the IR Motion Camera into the executing processing state.</p>
<p>If the IR Camera corresponding to the specified handle is in a running state, stops the existing processors, applies settings to the IR Camera and clustering processors, and puts the IR Motion Camera into a running state again. The existing running state processors can be of any type. During this enabled state, IR Camera captures and processing via the clustering processor occur periodically.</p>
<p>You can get results from the clustering processor with <code><a class="el" href="namespacenn_1_1irsensor.html#a6572060a5c7f41d2c19edde462fb5136" title="Gets the latest results from the clustering processor.">GetClusteringProcessorState()</a></code> or <code><a class="el" href="namespacenn_1_1irsensor.html#af83d851b9b53c14d5e661f240ac482c2" title="Gets earlier clustering processor results.">GetClusteringProcessorStates()</a></code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ir_sensor_clustering_basic_2_ir_sensor_clustering_basic_8cpp-example.html#a59">IrSensorClusteringBasic/IrSensorClusteringBasic.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a6572060a5c7f41d2c19edde462fb5136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6572060a5c7f41d2c19edde462fb5136">&#9670;&nbsp;</a></span>GetClusteringProcessorState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::irsensor::GetClusteringProcessorState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1irsensor_1_1_clustering_processor_state.html">ClusteringProcessorState</a> *&#160;</td>
          <td class="paramname"><em>pOutValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the latest results from the clustering processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValue</td><td>The buffer for the process result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>IR Camera handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_not_ready.html">nn::irsensor::ResultIrsensorDeviceNotReady</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_unconnected.html">nn::irsensor::ResultIrsensorUnconnected</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_unsupported.html">nn::irsensor::ResultIrsensorUnsupported</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_error.html">nn::irsensor::ResultIrsensorDeviceError</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_resource_not_available.html">nn::irsensor::ResultIrsensorDeviceResourceNotAvailable</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The IR Camera is initialized with the specified handle.</li>
<li>The IR Camera corresponding to the specified handle is in a state where it is using and running the clustering processor.</li>
<li><code><em>pOutValue</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pOutValue</em></code>, the read processing results.<ul>
<li><code>0</code> &lt;= <code><em>pOutValue</em>-&gt;objectCount</code> &amp;&amp; <code><em>pOutValue</em>-&gt;objectCount</code> &lt;= <code>ClusteringProcessorObjectCountMax</code>.</li>
<li><code>0</code> &lt; <code><em>pOutValue</em>-&gt;objects[j].averageIntensity</code> &amp;&amp; <code><em>pOutValue</em>-&gt;objects[j].averageIntensity</code> &lt;= <code>IrCameraIntensityMax</code>.</li>
<li><code><em>pOutValue</em>-&gt;objects[j].centroid</code> refers to the window of interest (WOI) coordinates set for the clustering processor.</li>
<li><code><em>pOutValue</em>-&gt;objects[j].pixelCount</code> refers to the detectable object size scope set for the clustering processor.</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 When this function returns <code><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">nn::ResultSuccess</a></code>, the same value as when one input state is read with <code><a class="el" href="namespacenn_1_1irsensor.html#af83d851b9b53c14d5e661f240ac482c2" title="Gets earlier clustering processor results.">GetClusteringProcessorStates()</a></code> is returned. When there are no results yet because processing just began, or when the IR Camera is not available, this function returns a value other than <code><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">nn::ResultSuccess</a></code>. Even in such an instance, you can get results (<code><em>pOutValue</em>-&gt;objectCount</code> = <code>0</code>) when the IR Motion Camera is in a state where nothing is displayed. However, <code><a class="el" href="structnn_1_1irsensor_1_1_clustering_processor_state.html#a3c4f3ed1e34e7760c88546351688350d" title="A value, greater than zero, that is incremented upon each receipt of results from a clustering proces...">ClusteringProcessorState::samplingNumber</a></code> and <code><a class="el" href="structnn_1_1irsensor_1_1_clustering_processor_state.html#a2c4ab17911e8ff263c27ca622650d99e" title="Time data for the interval from the start of processing to when the process results are obtained.">ClusteringProcessorState::timeStamp</a></code> will always be <code>0</code>.</p>
<p>If the IR Motion Camera is in an abnormal state, the system will display the relevant error information on the screen. The calling function is blocked while the error is displayed. As the return value, after some user operation, the function returns <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_error.html" title="A class that represents error Result values (irsensor: The IR Motion Camera is not available because ...">nn::irsensor::ResultIrsensorDeviceError</a></code>, and then control returns to the caller.</p>
<p>When the controller firmware requires an update, the controller support applet starts and performs the update. The caller is blocked during the update. When the update is successful, <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_not_ready.html" title="A class that represents error Result values (irsensor: No processing results are available immediatel...">nn::irsensor::ResultIrsensorDeviceNotReady</a></code> is returned. When the update fails, <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_error.html" title="A class that represents error Result values (irsensor: The IR Motion Camera is not available because ...">nn::irsensor::ResultIrsensorDeviceError</a></code> is returned. Control is then returned to the caller.</p>
<p>We recommend calling this function from a thread other than the main loop because this function can block where it is called (as described previously).</p>
<p>At a minimum, you will be unable to use the IR Sensor when at least one controller is using NFP functionality. In addition, you will not be able to use multiple IR Sensors when at least five controllers are connected. If these usage conditions are not satisfied, this function returns <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_resource_not_available.html" title="A class that represents error Result values (irsensor: Cannot be used, either because of the restrict...">nn::irsensor::ResultIrsensorDeviceResourceNotAvailable</a></code> when it is called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ir_sensor_clustering_basic_2_ir_sensor_clustering_basic_8cpp-example.html#a20">IrSensorClusteringBasic/IrSensorClusteringBasic.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af83d851b9b53c14d5e661f240ac482c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af83d851b9b53c14d5e661f240ac482c2">&#9670;&nbsp;</a></span>GetClusteringProcessorStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::irsensor::GetClusteringProcessorStates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1irsensor_1_1_clustering_processor_state.html">ClusteringProcessorState</a> *&#160;</td>
          <td class="paramname"><em>pOutStates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>countMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets earlier clustering processor results. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutStates</td><td>The buffer (array) reading results. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutCount</td><td>The number of read results. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">countMax</td><td>The maximum number of results to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>IR Camera handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_not_ready.html">nn::irsensor::ResultIrsensorDeviceNotReady</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_unconnected.html">nn::irsensor::ResultIrsensorUnconnected</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_unsupported.html">nn::irsensor::ResultIrsensorUnsupported</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_error.html">nn::irsensor::ResultIrsensorDeviceError</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_resource_not_available.html">nn::irsensor::ResultIrsensorDeviceResourceNotAvailable</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The IR Camera is initialized with the specified handle.</li>
<li>The IR Camera corresponding to the specified handle is in a state where it is using and running the clustering processor.</li>
<li><code><em>pOutStates</em></code> != <code>nullptr</code>.</li>
<li><code><em>countMax</em></code> &gt;= <code>0</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>For <code>*<em>pOutCount</em></code>, the number of read results, <code>0</code> &lt;= <code>*<em>pOutCount</em></code> &amp;&amp; <code>*<em>pOutCount</em></code> &lt;= <code><em>countMax</em></code> &amp;&amp; <code>*<em>pOutCount</em></code> &lt;= <code>ClusteringProcessorStateCountMax</code>.</li>
<li><code><em>pOutStates</em>[<em>i</em>]</code>, the read results:<ul>
<li><code>0</code> &lt;= <code><em>pOutStates</em>[<em>i</em>].objectCount</code> &amp;&amp; <code><em>pOutStates</em>[<em>i</em>].objectCount</code> &lt;= <code>ClusteringProcessorObjectCountMax</code>.</li>
<li><code>0</code> &lt; <code><em>pOutStates</em>[<em>i</em>].objects[<em>j</em>].averageIntensity</code> &amp;&amp; <code><em>pOutStates</em>[<em>i</em>].objects[<em>j</em>].averageIntensity</code> &lt;= <code>IrSensorIntensityMax</code>.</li>
<li><code><em>pOutStates</em>[<em>i</em>].objects[<em>j</em>].centroid</code> refers to the window of interest (WOI) coordinates set for the clustering processor.</li>
<li><code><em>pOutStates</em>[<em>i</em>].objects[<em>j</em>].pixelCount</code> refers to the detectable object size scope set for the clustering processor.</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets results from the IR Camera and clustering processor corresponding to the specified handle, reading as many past states as are available, in order, from the most recent. When you specify a buffer (array) that is larger than the number of available results, nothing will be done with the leftover area. The maximum number of results that can be read is the number specified by <code>ClusteringProcessorStateCountMax</code>. The available input states include those that have already been read. If you want to use just the difference, see <code><a class="el" href="structnn_1_1irsensor_1_1_clustering_processor_state.html#a3c4f3ed1e34e7760c88546351688350d" title="A value, greater than zero, that is incremented upon each receipt of results from a clustering proces...">ClusteringProcessorState::samplingNumber</a></code>. When there are no results yet because processing just began, or when the IR Camera is not available, this function returns a value other than <code><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">nn::ResultSuccess</a></code> and <code>0</code> as the number of results.</p>
<p>If the IR Motion Camera is in an abnormal state, the system will display the relevant error information on the screen. The calling function is blocked while the error is displayed. As the return value, after some user operation, the function returns <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_error.html" title="A class that represents error Result values (irsensor: The IR Motion Camera is not available because ...">nn::irsensor::ResultIrsensorDeviceError</a></code>, and then control returns to the caller.</p>
<p>When the controller firmware requires an update, the controller support applet starts and performs the update. The caller is blocked during the update. When the update is successful, <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_not_ready.html" title="A class that represents error Result values (irsensor: No processing results are available immediatel...">nn::irsensor::ResultIrsensorDeviceNotReady</a></code> is returned. When the update fails, <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_error.html" title="A class that represents error Result values (irsensor: The IR Motion Camera is not available because ...">nn::irsensor::ResultIrsensorDeviceError</a></code> is returned. Control is then returned to the caller.</p>
<p>We recommend calling this function from a thread other than the main loop because this function can block where it is called (as described previously).</p>
<p>At a minimum, you will be unable to use the IR Sensor when at least one controller is using NFP functionality. In addition, you will not be able to use multiple IR Sensors when at least five controllers are connected. If these usage conditions are not satisfied, this function will return <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_resource_not_available.html" title="A class that represents error Result values (irsensor: Cannot be used, either because of the restrict...">nn::irsensor::ResultIrsensorDeviceResourceNotAvailable</a></code> when it is called. </p>

</div>
</div>
<a id="a51afe6cb83bd86357c696813ff5a1887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51afe6cb83bd86357c696813ff5a1887">&#9670;&nbsp;</a></span>RunHandAnalysis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::irsensor::RunHandAnalysis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_hand_analysis_config.html">HandAnalysisConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start HandAnalysis mode of the IR sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Handle of the IR camera. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Configuration of HandAnalysis mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether the camera successfully switched to HandAnalysis mode. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The handle is already initialized via the <code>Initialize</code> function.</li>
<li>The IR camera with the specified handle is not running yet.</li>
<li>The configuration can be one of the following.<ul>
<li><code>HandAnalysisMode_Silhouette</code> mode provides the hand silhouette, hand information, and finger information.</li>
<li><code>HandAnalysisMode_Image</code> mode provides the compressed raw image (40x30).</li>
<li><code>HandAnalysisMode_SilhouetteAndImage</code> provides hand information and the coarse image in an interleaved sequence.</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 User sets a configuration to HandAnalysis and IR sensor starts processing. User keeps getting data via the <code>Get**()</code> API while <code>HandAnalysis</code> is running. When the IR sensor is already running another mode, it stops running mode and starts HandAnalysis mode with the specified configuration. </p>

</div>
</div>
<a id="a28072a0acab4430a22b83bac1411d1fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28072a0acab4430a22b83bac1411d1fc">&#9670;&nbsp;</a></span>GetHandAnalysisSilhouetteState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::irsensor::GetHandAnalysisSilhouetteState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1irsensor_1_1_hand_analysis_silhouette_state.html">HandAnalysisSilhouetteState</a> *&#160;</td>
          <td class="paramname"><em>pOutValueArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pReturnCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>infSamplingNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the latest <code>HandAnalysis</code> silhouette mode data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValueArray</td><td>The user-allocated array that receives the processed data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pReturnCount</td><td>Number of elements written to <code><em>pOutValueArray</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxCount</td><td>Maximum number of elements that can be written to <code><em>pOutValueArray</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">infSamplingNumber</td><td>The lowest sampling number of the elements you want to get. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Handle of the IR sensor.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
 This function retrieves silhouette states sent by the IR sensor. You can retrieve several states at the same time. The function will return all the states available where <code><em>infSamplingNumber</em></code> &lt;= <code><em>state</em>.samplingNumber</code>. If the array is not large enough it will return the more recent silhouette states, i.e. the highest sampling numbers. Usually you want <code><em>infSamplingNumber</em></code> == <code>0</code> for the first call and <code><em>infSamplingNumber</em></code> == <code><em>lastSamplingNumber</em></code> + <code>1</code> for the next one.</p>
<p>Unlike other irsensor modes (like clustering or moment modes), getting states in the silhouette mode will copy and decode data, which is time consuming. The benefit of using infSamplingNumber is to avoid extra computation for states you already received.</p>
<p>When the IR sensor is not functioning properly, the system will display a dialog with an error message. This function blocks the calling thread while the message is displayed. After the user closes the error message, the function returns <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_error.html" title="A class that represents error Result values (irsensor: The IR Motion Camera is not available because ...">nn::irsensor::ResultIrsensorDeviceError</a></code>.</p>
<p>When the controller firmware needs an update, the system calls the controller support applet to update it. While updating, this function blocks the calling thread. If the update succeeds this function returns <a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_not_ready.html" title="A class that represents error Result values (irsensor: No processing results are available immediatel...">nn::irsensor::ResultIrsensorDeviceNotReady</a>, and otherwise returns <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_error.html" title="A class that represents error Result values (irsensor: The IR Motion Camera is not available because ...">nn::irsensor::ResultIrsensorDeviceError</a></code>.</p>
<p>We recommend calling this function from a thread other than the main loop because this function can block where it is called (as described previously).</p>
<p>IR sensor is not available when the application uses NFC functions on at least one controller. When more than four controllers are connected, only the first IR sensor is available. If these constraints are not satisfied, this function returns <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_resource_not_available.html" title="A class that represents error Result values (irsensor: Cannot be used, either because of the restrict...">nn::irsensor::ResultIrsensorDeviceResourceNotAvailable</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_not_ready.html">nn::irsensor::ResultIrsensorDeviceNotReady</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_unavailable.html">nn::irsensor::ResultIrsensorUnavailable</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_error.html">nn::irsensor::ResultIrsensorDeviceError</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_hand_analysis_mode_incorrect.html">nn::irsensor::ResultHandAnalysisModeIncorrect</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_resource_not_available.html">nn::irsensor::ResultIrsensorDeviceResourceNotAvailable</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The handle is already initialized using the <code>Initialize</code> function.</li>
<li>For any handle, the IR camera is running as the silhouette mode of <code>HandAnalysis</code>.</li>
<li><code><em>pOutValue</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReturnCount</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>For all <code><em>pOutValue</em></code> in <code><em>pOutValueArray</em></code> ... <code><em>pOutValueArray</em></code> + <code><em>pReturnCount</em></code> - <code>1</code>:<ul>
<li><code>0</code> &lt;= <code><em>pOutValue</em>-&gt;shapeCount</code> &amp;&amp; <code><em>pOutValue</em>-&gt;shapeCount</code> &lt;= <code>IrHandAnalysisShapeCountMax</code>. </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a067ae380c70a0125d0c606bbdcc72391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a067ae380c70a0125d0c606bbdcc72391">&#9670;&nbsp;</a></span>GetHandAnalysisImageState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::irsensor::GetHandAnalysisImageState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1irsensor_1_1_hand_analysis_image_state.html">HandAnalysisImageState</a> *&#160;</td>
          <td class="paramname"><em>pOutValueArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pReturnCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>infSamplingNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets reduced compressed IR camera images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValueArray</td><td>The user-allocated buffer that receives the image. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pReturnCount</td><td>Number of elements written to <code><em>pOutValueArray</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxCount</td><td>Size of <code><em>pOutValueArray</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">infSamplingNumber</td><td>The lowest sampling number of the elements you want to get. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Handle of the IR sensor.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
 The image resolution is (<code>IrHandAnalysisImageWidth</code>, <code>IrHandAnalysisImageHeight</code>). The IR camera image is converted to a 16-bit range in order to compensate for internal camera parameters, so that intensity can be compared between images without taking internal camera parameters into account.</p>
<p>This function retrieves images sent by the IR sensor. You can retrieve several images at the same time. The function will return all the images available where <code><em>infSamplingNumber</em></code> &lt;= <code><em>image</em>.samplingNumber</code>. If the array is not large enough it will return the more recent images, i.e. the highest sampling numbers. Usually you want <code><em>infSamplingNumber</em></code> == <code>0</code> for the first call and <code><em>infSamplingNumber</em></code> == <code><em>lastSamplingNumber</em></code> + <code>1</code> for the next one.</p>
<p>Unlike other irsensor modes (like clustering or moment modes), getting states in the silhouette mode will copy and decode data, which is time consuming. The benefit of using infSamplingNumber is to avoid extra computation for states you already received.</p>
<p>When the IR sensor is not functioning properly, the system will display a dialog with an error message. This function blocks the calling thread while the message is displayed. After the user closes the error message, the function returns <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_error.html" title="A class that represents error Result values (irsensor: The IR Motion Camera is not available because ...">nn::irsensor::ResultIrsensorDeviceError</a></code>.</p>
<p>When the controller firmware needs an update, the system calls the controller support applet to update it. While updating, this function blocks the calling thread. If the update succeeds this function returns <a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_not_ready.html" title="A class that represents error Result values (irsensor: No processing results are available immediatel...">nn::irsensor::ResultIrsensorDeviceNotReady</a>, and otherwise returns <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_error.html" title="A class that represents error Result values (irsensor: The IR Motion Camera is not available because ...">nn::irsensor::ResultIrsensorDeviceError</a></code>.</p>
<p>We recommend calling this function from a thread other than the main loop because this function can block where it is called (as described previously).</p>
<p>IR sensor is not available when the application uses NFC functions on at least one controller. When more than four controllers are connected, only the first IR sensor is available. If these constraints are not satisfied, this function returns <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_resource_not_available.html" title="A class that represents error Result values (irsensor: Cannot be used, either because of the restrict...">nn::irsensor::ResultIrsensorDeviceResourceNotAvailable</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_not_ready.html">nn::irsensor::ResultIrsensorDeviceNotReady</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_unavailable.html">nn::irsensor::ResultIrsensorUnavailable</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_error.html">nn::irsensor::ResultIrsensorDeviceError</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_resource_not_available.html">nn::irsensor::ResultIrsensorDeviceResourceNotAvailable</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The handle is already initialized using the <code>Initialize</code> function.</li>
<li>For any handle, the IR camera is running as the image mode of <code>HandAnalysis</code>.</li>
<li><code><em>pOutValue</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReturnCount</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>For all <code><em>pOutValue</em></code> in <code><em>pOutValueArray</em></code> ... <code><em>pOutValueArray</em></code> + <code><em>pReturnCount</em></code> - <code>1</code>:<ul>
<li><code>0</code> &lt;= <code><em>pOutValue</em>-&gt;image[j]</code> &amp;&amp; <code><em>pOutValue</em>-&gt;image[j]</code> &lt;= <code>65535</code>.</li>
<li><code><em>pOutValue</em>-&gt;image[j]</code> indicates a 16-bit grayscale value where <code><em>j</em></code> is the pixel location of (<code><em>x</em></code> + <code><em>y</em></code> × <code>IrHandAnalysisImageWidth</code>).</li>
<li>Valid pixel locations (<code><em>x</em></code>, <code><em>y</em></code>) are between (<code>0</code>, <code>0</code>) and (<code>IrHandAnalysisImageWidth</code>, <code>IrHandAnalysisImageHeight</code>) </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a3052171f2c63aafc0e4a164366ae22d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3052171f2c63aafc0e4a164366ae22d7">&#9670;&nbsp;</a></span>StopImageProcessor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::irsensor::StopImageProcessor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops the processing of the IR Motion Camera. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>IR camera handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The IR camera is initialized with the specified handle. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The IR camera corresponding to the specified handle is in a stopped state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Stops the processing of the IR Motion Camera corresponding to the specified handle. Regardless of which image processor is in use, you can use this function to halt its processing. An IR Motion Camera continually consumes power when running. Use this function to stop the processing in scenes where it is not required. Blocks until the process of stopping the IR Motion Camera has completed. We recommend calling this function from a thread other than the main loop because this function can block where it is called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ir_sensor_adaptive_clustering_basic_2_ir_sensor_adaptive_clustering_basic_8cpp-example.html#a54">IrSensorAdaptiveClusteringBasic/IrSensorAdaptiveClusteringBasic.cpp</a>, <a class="el" href="_ir_sensor_clustering_basic_2_ir_sensor_clustering_basic_8cpp-example.html#a60">IrSensorClusteringBasic/IrSensorClusteringBasic.cpp</a>, <a class="el" href="_ir_sensor_ir_led_basic_2_ir_sensor_ir_led_basic_8cpp-example.html#a48">IrSensorIrLedBasic/IrSensorIrLedBasic.cpp</a>, <a class="el" href="_ir_sensor_moment_basic_2_ir_sensor_moment_basic_8cpp-example.html#a55">IrSensorMomentBasic/IrSensorMomentBasic.cpp</a>, and <a class="el" href="_ir_sensor_pointing_basic_2_ir_sensor_pointing_basic_8cpp-example.html#a45">IrSensorPointingBasic/IrSensorPointingBasic.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a2777438798de9cf9a3bfebbeb48251b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2777438798de9cf9a3bfebbeb48251b0">&#9670;&nbsp;</a></span>StopImageProcessorAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::irsensor::StopImageProcessorAsync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously stops processing for the IR Motion Camera. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>IR Camera handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The IR Camera is initialized with the specified handle. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The IR camera corresponding to the specified handle is in a queued state to be stopped.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Stops the processing of the IR Motion Camera corresponding to the specified handle. Regardless of which image processor is in use, you can use this function to halt its processing. An IR Motion Camera continually consumes power when running. Use this function to stop the processing in scenes where it is not required. This function stops the IR Motion Camera asynchronously. You can check whether the IR Motion Camera was stopped by calling <code>GetimageProcessorStatus()</code>. </p>

</div>
</div>
<a id="a07eb18481070f89065809a60a5928bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07eb18481070f89065809a60a5928bcb">&#9670;&nbsp;</a></span>GetImageProcessorStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1irsensor.html#a29c9901e3b1df19725d41e8351305c2c">ImageProcessorStatus</a> nn::irsensor::GetImageProcessorStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the status of the image processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>IR Camera handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the image processor specified by the handle for the device. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The IR Camera is initialized with the specified handle.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the status of the image processor specified by the handle of the Npad or device. Regardless of the state returned by this function, you can put the IR Motion Camera in a running state by calling functions like <code><a class="el" href="namespacenn_1_1irsensor.html#a0658b45f92e49e1612735574042920e9" title="Begins processing for the IR Camera and moment processor.">RunMomentProcessor()</a></code> or you can put it in a stopped state by calling functions like <code><a class="el" href="namespacenn_1_1irsensor.html#a3052171f2c63aafc0e4a164366ae22d7" title="Stops the processing of the IR Motion Camera.">StopImageProcessor()</a></code>. </p>

</div>
</div>
<a id="aba3c4ee95d75d413c596081063dfec18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba3c4ee95d75d413c596081063dfec18">&#9670;&nbsp;</a></span>MakeRect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1irsensor_1_1_rect.html">Rect</a> nn::irsensor::MakeRect </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the <code><a class="el" href="structnn_1_1irsensor_1_1_rect.html" title="A rectangle.">Rect</a></code> structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The x-coordinate of the rectangle's origin, in the upper-left corner. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The y-coordinate of the rectangle's origin, in the upper-left corner. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Width. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Height. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an instance of the <code><a class="el" href="structnn_1_1irsensor_1_1_rect.html" title="A rectangle.">Rect</a></code> structure. </dd></dl>

</div>
</div>
<a id="a26ee50f1fe4bcaf8d89d863712801167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ee50f1fe4bcaf8d89d863712801167">&#9670;&nbsp;</a></span>GetImageTransferProcessorDefaultConfig() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::irsensor::GetImageTransferProcessorDefaultConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1irsensor_1_1_image_transfer_processor_config.html">ImageTransferProcessorConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the default settings for the image transfer processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValue</td><td>Default settings for the image transfer processor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutValue</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pOutValue</em></code>, the image transfer processor settings.<ul>
<li><code><em>pOutValue</em>-&gt;format</code> == <code>ImageTransferProcessorFormat_320x240</code>. </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a075e4a12ff14c3c9026cccfbe27ab876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075e4a12ff14c3c9026cccfbe27ab876">&#9670;&nbsp;</a></span>GetImageTransferProcessorDefaultConfig() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::irsensor::GetImageTransferProcessorDefaultConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1irsensor_1_1_image_transfer_processor_ex_config.html">ImageTransferProcessorExConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the default advanced settings for the image transfer processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValue</td><td>Default settings for the image transfer processor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutValue</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pOutValue</em></code>, the image transfer processor settings.<ul>
<li><code><em>pOutValue</em>-&gt;origFormat</code> == <code>ImageTransferProcessorFormat_320x240</code>.</li>
<li><code><em>pOutValue</em>-&gt;trimmingFormat</code> == <code>ImageTransferProcessorFormat_320x240</code>.</li>
<li><code><em>pOutValue</em>-&gt;trimmingStartX</code> == <code>0</code>.</li>
<li><code><em>pOutValue</em>-&gt;trimmingStartY</code> == <code>0</code>. </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a9f53ceaaa5d3eaa0de9b45db288a2bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f53ceaaa5d3eaa0de9b45db288a2bc1">&#9670;&nbsp;</a></span>RunImageTransferProcessor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::irsensor::RunImageTransferProcessor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_image_transfer_processor_config.html">ImageTransferProcessorConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>workBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begins processing for the IR Camera and image transfer processor. </p>
<p>If all preprocessors are running, stops the running processors and performs the moment processor processing again. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>IR Camera handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Settings for the image transfer processor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">workBuffer</td><td>The working buffer used by the image transfer processor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the working buffer used by the image transfer processor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The IR Camera is initialized with the specified handle.</li>
<li><code><em>config</em></code>, the image transfer processor settings.<ul>
<li><code>ImageTransferProcessorExposureTimeMin</code> &lt;= <code><em>config</em>.irCameraConfig.exposureTime</code>.</li>
<li><code><em>config</em>.irCameraConfig.exposureTime</code> &lt;= <code>ImageTransferProcessorExposureTimeMax</code>.</li>
<li><code>IrCameraGainMin</code> &lt;= <code><em>config</em>.irCameraConfig.gain</code></li>
<li><code><em>config</em>.irCameraConfig.gain</code> &lt;= <code>IrCameraGainMax</code>.</li>
<li><code><em>workBuffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>workBuffer</em></code> is aligned to 4 KB.</li>
<li><code><em>size</em></code>:<ul>
<li>When <code><em>config</em>.format</code> == <code>ImageTransferProcessorFormat_320x240</code>, <code><em>size</em></code> == <code>ImageTransferProcessorWorkBufferSize_320x24</code>.</li>
<li>When <code><em>config</em>.format</code> == <code>ImageTransferProcessorFormat_160x120</code>, <code><em>size</em></code> == <code>ImageTransferProcessorWorkBufferSize_160x120</code>.</li>
<li>When <code><em>config</em>.format</code> == <code>ImageTransferProcessorFormat_80x60</code>, <code><em>size</em></code> == <code>ImageTransferProcessorWorkBufferSize_80x60</code>.</li>
<li>When <code><em>config</em>.format</code> == <code>ImageTransferProcessorFormat_40x30</code>, <code><em>size</em></code> == <code>ImageTransferProcessorWorkBufferSize_40x30</code>.</li>
<li>When <code><em>config</em>.format</code> == <code>ImageTransferProcessorFormat_20x15</code>, <code><em>size</em></code> == <code>ImageTransferProcessorWorkBufferSize_20x15</code>. </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The IR Camera corresponding to the specified handle is in a state where it is using and running the image transfer processor.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 If the IR Camera corresponding to the specified handled is stopped, apply the settings to the IR Camera and image transfer processor. Puts the IR Motion Camera into the executing processing state.</p>
<p>If the IR Camera corresponding to the specified handle is in a running state, stops the existing processors, applies settings to the IR Camera and image transfer processor, and puts the IR Motion Camera into a running state again. The existing running state processors can be of any type. During this enabled state, IR Camera captures and processing via the image transfer processor occur periodically.</p>
<p>You can get results from the image transfer processor with <code><a class="el" href="namespacenn_1_1irsensor.html#aa8e5d943258b76d2e90837bd319fa023" title="Gets the latest results from the image transfer processor.">GetImageTransferProcessorState()</a></code>. After this function has been called, you cannot access the specified work buffer until <code><a class="el" href="namespacenn_1_1irsensor.html#a3052171f2c63aafc0e4a164366ae22d7" title="Stops the processing of the IR Motion Camera.">StopImageProcessor()</a></code>, <code><a class="el" href="namespacenn_1_1irsensor.html#a2777438798de9cf9a3bfebbeb48251b0" title="Asynchronously stops processing for the IR Motion Camera.">StopImageProcessorAsync()</a></code>, or some <code>Run</code> function other than <code><a class="el" href="namespacenn_1_1irsensor.html#a9f53ceaaa5d3eaa0de9b45db288a2bc1" title="Begins processing for the IR Camera and image transfer processor.">RunImageTransferProcessor()</a></code> has been called, or until the <code><a class="el" href="namespacenn_1_1irsensor.html#a9f53ceaaa5d3eaa0de9b45db288a2bc1" title="Begins processing for the IR Camera and image transfer processor.">RunImageTransferProcessor()</a></code> function is called again and passes a work buffer other than the one that was originally specified. </p>

</div>
</div>
<a id="a36475abbe9c4d0f67093bcb652f2f27b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36475abbe9c4d0f67093bcb652f2f27b">&#9670;&nbsp;</a></span>RunImageTransferProcessor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::irsensor::RunImageTransferProcessor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_image_transfer_processor_ex_config.html">ImageTransferProcessorExConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>workBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begins processing associated with the advanced settings for the IR Camera and image transfer processor. </p>
<p>If all preprocessors are running, stops the running processors and performs the moment processor processing again. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>IR Camera handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>The advanced settings for the image transfer processor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">workBuffer</td><td>The working buffer used by the image transfer processor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the working buffer used by the image transfer processor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The IR Camera is initialized with the specified handle.</li>
<li><code><em>config</em></code>, the image transfer processor settings.<ul>
<li><code>ImageTransferProcessorExposureTimeMin</code> &lt;= <code><em>config</em>.irCameraConfig.exposureTime</code>.</li>
<li><code><em>config</em>.irCameraConfig.exposureTime</code> &lt;= <code>ImageTransferProcessorExposureTimeMax</code>.</li>
<li><code>IrCameraGainMin</code> &lt;= <code><em>config</em>.irCameraConfig.gain</code></li>
<li><code><em>config</em>.irCameraConfig.gain</code> &lt;= <code>IrCameraGainMax</code>.</li>
<li><code><em>workBuffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>workBuffer</em></code> is aligned to 4 KB.</li>
<li><code><em>size</em></code>:<ul>
<li>When <code><em>config</em>.trimmingFormat</code> == <code>ImageTransferProcessorFormat_320x240</code>, <code><em>size</em></code> == <code>ImageTransferProcessorWorkBufferSize_320x24</code>.</li>
<li>When <code><em>config</em>.trimmingFormat</code> == <code>ImageTransferProcessorFormat_160x120</code>, <code><em>size</em></code> == <code>ImageTransferProcessorWorkBufferSize_160x120</code>.</li>
<li>When <code><em>config</em>.trimmingFormat</code> == <code>ImageTransferProcessorFormat_80x60</code>, <code><em>size</em></code> == <code>ImageTransferProcessorWorkBufferSize_80x60</code>.</li>
<li>When <code><em>config</em>.trimmingFormat</code> == <code>ImageTransferProcessorFormat_40x30</code>, <code><em>size</em></code> == <code>ImageTransferProcessorWorkBufferSize_40x30</code>.</li>
<li>When <code><em>config</em>.trimmingFormat</code> == <code>ImageTransferProcessorFormat_20x15</code>, <code><em>size</em></code> == <code>ImageTransferProcessorWorkBufferSize_20x15</code>.</li>
</ul>
</li>
<li>For <code><em>config</em>.origFormat</code>:<ul>
<li><code><em>config</em>.origFormat</code>&lt;= <code><em>config</em>.trimmingFormat</code>.</li>
<li><code>0</code> &lt;= <code><em>config</em>.trimmingStartX</code>.</li>
<li><code><em>config</em>.trimmingStartX</code> &lt;= The width of <code><em>config</em>.origFormat</code>- the width of <code><em>config</em>.trimmingFormat</code>.</li>
<li><code>0</code> &lt;= <code><em>config</em>.trimmingStartY</code>.</li>
<li><code><em>config</em>.trimmingStartY</code> &lt;= The height of <code><em>config</em>.origFormat</code> - the height of <code><em>config</em>.trimmingFormat</code>. </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The IR Camera corresponding to the specified handle is in a state where it is using and running the image transfer processor.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 If the IR Camera corresponding to the specified handled is stopped, apply the settings to the IR Camera and image transfer processor. Puts the IR Motion Camera into the executing processing state.</p>
<p>If the IR Camera corresponding to the specified handle is in a running state, stops the existing processors, applies settings to the IR Camera and image transfer processor, and puts the IR Motion Camera into a running state again. The existing running state processors can be of any type. During this enabled state, IR Camera captures and processing via the image transfer processor occur periodically.</p>
<p>You can get results from the image transfer processor with <code><a class="el" href="namespacenn_1_1irsensor.html#aa8e5d943258b76d2e90837bd319fa023" title="Gets the latest results from the image transfer processor.">GetImageTransferProcessorState()</a></code>. After this function has been called, you cannot access the specified work buffer until <code><a class="el" href="namespacenn_1_1irsensor.html#a3052171f2c63aafc0e4a164366ae22d7" title="Stops the processing of the IR Motion Camera.">StopImageProcessor()</a></code>, <code><a class="el" href="namespacenn_1_1irsensor.html#a2777438798de9cf9a3bfebbeb48251b0" title="Asynchronously stops processing for the IR Motion Camera.">StopImageProcessorAsync()</a></code>, or some <code>Run</code> function other than <code><a class="el" href="namespacenn_1_1irsensor.html#a9f53ceaaa5d3eaa0de9b45db288a2bc1" title="Begins processing for the IR Camera and image transfer processor.">RunImageTransferProcessor()</a></code> has been called, or until the <code><a class="el" href="namespacenn_1_1irsensor.html#a9f53ceaaa5d3eaa0de9b45db288a2bc1" title="Begins processing for the IR Camera and image transfer processor.">RunImageTransferProcessor()</a></code> function is called again and passes a work buffer other than the one that was originally specified. </p>

</div>
</div>
<a id="aa8e5d943258b76d2e90837bd319fa023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e5d943258b76d2e90837bd319fa023">&#9670;&nbsp;</a></span>GetImageTransferProcessorState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::irsensor::GetImageTransferProcessorState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1irsensor_1_1_image_transfer_processor_state.html">ImageTransferProcessorState</a> *&#160;</td>
          <td class="paramname"><em>pOutState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pOutImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the latest results from the image transfer processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutState</td><td>Buffer to read additional data from the resulting image. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutImage</td><td>Buffer to read the resulting image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the buffer to read the resulting image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>IR Camera handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_not_ready.html">nn::irsensor::ResultIrsensorDeviceNotReady</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_unconnected.html">nn::irsensor::ResultIrsensorUnconnected</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_unsupported.html">nn::irsensor::ResultIrsensorUnsupported</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_error.html">nn::irsensor::ResultIrsensorDeviceError</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_resource_not_available.html">nn::irsensor::ResultIrsensorDeviceResourceNotAvailable</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The IR Camera is initialized with the specified handle.</li>
<li>The IR Camera corresponding to the specified handle is in a state where it is using and running the image transfer processor.</li>
<li><code><em>pOutState</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutImage</em></code> != <code>nullptr</code>.</li>
<li><code><em>config</em>.workBufferSize</code>, as specified by the latest <code><a class="el" href="namespacenn_1_1irsensor.html#a9f53ceaaa5d3eaa0de9b45db288a2bc1" title="Begins processing for the IR Camera and image transfer processor.">RunImageTransferProcessor()</a></code>.<ul>
<li>When <code>ImageTransferProcessorFormat_320x240</code>, <code><em>size</em></code> &gt;= <code>ImageTransferProcessorImageSize_320x240</code>.</li>
<li>When <code>ImageTransferProcessorFormat_160x120</code>, <code><em>size</em></code> &gt;= <code>ImageTransferProcessorImageSize_160x120</code>.</li>
<li>When <code>ImageTransferProcessorFormat_80x60</code>, <code><em>size</em></code> &gt;= <code>ImageTransferProcessorImageSize_80x60</code>.</li>
<li>When <code>ImageTransferProcessorFormat_40x30</code>, <code><em>size</em></code> &gt;= <code>ImageTransferProcessorImageSize_40x30</code>.</li>
<li>When <code>ImageTransferProcessorFormat_20x15</code>, <code><em>size</em></code> &gt;= <code>ImageTransferProcessorImageSize_20x15</code>.</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the results from the IR Camera and image transfer processor corresponding to the latest specified handle. When there are no results yet because processing just began, or when the IR Camera is not available, this function returns a value other than <code><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">nn::ResultSuccess</a></code>. Even in such cases, you can get results where the IR Camera is not capturing anything ( where <code><em>pOutImage</em>[j]</code> = <code>0</code> when <code>0</code> &lt;= <code><em>j</em></code> &lt; the <code><em>config</em>.workBufferSize</code> specified by the most recent call to <code><a class="el" href="namespacenn_1_1irsensor.html#a9f53ceaaa5d3eaa0de9b45db288a2bc1" title="Begins processing for the IR Camera and image transfer processor.">RunImageTransferProcessor()</a></code>), but <code><a class="el" href="structnn_1_1irsensor_1_1_image_transfer_processor_state.html#a6bf6d451b1e654887a0c7686e533e3c2" title="A value, greater than zero, that is incremented upon each receipt of results from an image transfer p...">ImageTransferProcessorState::samplingNumber</a></code> will always be <code>0</code>. </p><pre class="fragment">       If the IR Motion Camera is in an abnormal state, the system will display the relevant error information on the screen.
       The calling function is blocked while the error is displayed.
       As the return value, after some user operation, the function returns &lt;tt&gt;nn::irsensor::ResultIrsensorDeviceError&lt;/tt&gt;, and then control returns to the caller.

       When the controller firmware requires an update, the controller support applet starts and performs the update.
       The caller is blocked during the update.
       When the update is successful, &lt;tt&gt;nn::irsensor::ResultIrsensorDeviceNotReady&lt;/tt&gt; is returned.
</pre><p> When the update fails, <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_error.html" title="A class that represents error Result values (irsensor: The IR Motion Camera is not available because ...">nn::irsensor::ResultIrsensorDeviceError</a></code> is returned. Control is then returned to the caller. </p><pre class="fragment">       We recommend calling this function from a thread other than the main loop because this function can block where it is called (as described previously).

       At a minimum, you will be unable to use the IR Sensor when at least one controller is using NFP functionality.
       In addition, you will not be able to use multiple IR Sensors when at least five controllers are connected.
       If these usage conditions are not satisfied, this function returns &lt;tt&gt;nn::irsensor::ResultIrsensorDeviceResourceNotAvailable&lt;/tt&gt; when it is called.
</pre> 
</div>
</div>
<a id="a4772960359a06fcd86d2b9ffe85059fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4772960359a06fcd86d2b9ffe85059fc">&#9670;&nbsp;</a></span>GetIrCameraHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> nn::irsensor::GetIrCameraHandle </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">nn::hid::NpadIdType</a> &amp;&#160;</td>
          <td class="paramname"><em>npadIdType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the handle for operating the IR camera in the Npad. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">npadIdType</td><td>Npad ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IR camera handle. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The call to <code><a class="el" href="namespacenn_1_1hid.html#a54ad6953b9cef17b4d79171e819b0048" title="Initializes an Npad.">InitializeNpad()</a></code> is completed for the specified Npad ID. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ir_sensor_adaptive_clustering_basic_2_ir_sensor_adaptive_clustering_basic_8cpp-example.html#a49">IrSensorAdaptiveClusteringBasic/IrSensorAdaptiveClusteringBasic.cpp</a>, <a class="el" href="_ir_sensor_clustering_basic_2_ir_sensor_clustering_basic_8cpp-example.html#a55">IrSensorClusteringBasic/IrSensorClusteringBasic.cpp</a>, <a class="el" href="_ir_sensor_ir_led_basic_2_ir_sensor_ir_led_basic_8cpp-example.html#a46">IrSensorIrLedBasic/IrSensorIrLedBasic.cpp</a>, <a class="el" href="_ir_sensor_moment_basic_2_ir_sensor_moment_basic_8cpp-example.html#a50">IrSensorMomentBasic/IrSensorMomentBasic.cpp</a>, and <a class="el" href="_ir_sensor_pointing_basic_2_ir_sensor_pointing_basic_8cpp-example.html#a42">IrSensorPointingBasic/IrSensorPointingBasic.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a43c18eac7fe6430f1c9620e29169cf1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c18eac7fe6430f1c9620e29169cf1a">&#9670;&nbsp;</a></span>Initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::irsensor::Initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the IR camera. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>IR camera handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The IR camera is not initialized with the specified handle. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The IR camera is initialized with the specified handle. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ir_sensor_adaptive_clustering_basic_2_ir_sensor_adaptive_clustering_basic_8cpp-example.html#a50">IrSensorAdaptiveClusteringBasic/IrSensorAdaptiveClusteringBasic.cpp</a>, <a class="el" href="_ir_sensor_clustering_basic_2_ir_sensor_clustering_basic_8cpp-example.html#a56">IrSensorClusteringBasic/IrSensorClusteringBasic.cpp</a>, <a class="el" href="_ir_sensor_ir_led_basic_2_ir_sensor_ir_led_basic_8cpp-example.html#a47">IrSensorIrLedBasic/IrSensorIrLedBasic.cpp</a>, <a class="el" href="_ir_sensor_moment_basic_2_ir_sensor_moment_basic_8cpp-example.html#a51">IrSensorMomentBasic/IrSensorMomentBasic.cpp</a>, and <a class="el" href="_ir_sensor_pointing_basic_2_ir_sensor_pointing_basic_8cpp-example.html#a43">IrSensorPointingBasic/IrSensorPointingBasic.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a6265f5c6e6d6fc0e67fc6882a8945284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6265f5c6e6d6fc0e67fc6882a8945284">&#9670;&nbsp;</a></span>Finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::irsensor::Finalize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalizes the IR camera. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>IR camera handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The IR camera is initialized with the specified handle. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The IR camera is not initialized with the specified handle.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Runs the termination process for the IR Motion Camera for the Npad or device specified by the handle. As a general principle, we recommend terminating the processor in advance using <code><a class="el" href="namespacenn_1_1irsensor.html#a3052171f2c63aafc0e4a164366ae22d7" title="Stops the processing of the IR Motion Camera.">nn::irsensor::StopImageProcessor()</a></code> or <code><a class="el" href="namespacenn_1_1irsensor.html#a2777438798de9cf9a3bfebbeb48251b0" title="Asynchronously stops processing for the IR Motion Camera.">nn::irsensor::StopImageProcessorAsync()</a></code> before running other termination processes. However, if these functions are not called while the processor is active, they can also be called internally before running termination processes. When this is done, this function may block at its call site because it is waiting for the processor to stop. We recommend calling <code><a class="el" href="namespacenn_1_1irsensor.html#a07eb18481070f89065809a60a5928bcb" title="Gets the status of the image processor.">nn::irsensor::GetImageProcessorStatus()</a></code> to confirm that the processor has stopped when using <code><a class="el" href="namespacenn_1_1irsensor.html#a2777438798de9cf9a3bfebbeb48251b0" title="Asynchronously stops processing for the IR Motion Camera.">nn::irsensor::StopImageProcessorAsync()</a></code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ir_sensor_adaptive_clustering_basic_2_ir_sensor_adaptive_clustering_basic_8cpp-example.html#a55">IrSensorAdaptiveClusteringBasic/IrSensorAdaptiveClusteringBasic.cpp</a>, <a class="el" href="_ir_sensor_clustering_basic_2_ir_sensor_clustering_basic_8cpp-example.html#a61">IrSensorClusteringBasic/IrSensorClusteringBasic.cpp</a>, <a class="el" href="_ir_sensor_ir_led_basic_2_ir_sensor_ir_led_basic_8cpp-example.html#a49">IrSensorIrLedBasic/IrSensorIrLedBasic.cpp</a>, <a class="el" href="_ir_sensor_moment_basic_2_ir_sensor_moment_basic_8cpp-example.html#a56">IrSensorMomentBasic/IrSensorMomentBasic.cpp</a>, and <a class="el" href="_ir_sensor_pointing_basic_2_ir_sensor_pointing_basic_8cpp-example.html#a46">IrSensorPointingBasic/IrSensorPointingBasic.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="acf66c625dc12cd1fb0d06e79eb1d32a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf66c625dc12cd1fb0d06e79eb1d32a5">&#9670;&nbsp;</a></span>GetIrCameraStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1irsensor.html#a0fb1b253296b92663904ac18e7416b60">IrCameraStatus</a> nn::irsensor::GetIrCameraStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the IR camera state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>IR camera handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The IR camera state for the device corresponding to the specified handle. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The IR camera is initialized with the specified handle.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the state of the IR camera for the Npad or other device corresponding to the specified handle. Regardless of the state returned by this function, the IR Motion Camera can be put in the running state by calling a function like <code><a class="el" href="namespacenn_1_1irsensor.html#a0658b45f92e49e1612735574042920e9" title="Begins processing for the IR Camera and moment processor.">RunMomentProcessor()</a></code>.</p>
<p>That said, a <code><a class="el" href="classnn_1_1_result.html" title="Represents the generic result of an operation.">nn::Result</a></code> other than <code><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">nn::ResultSuccess</a></code> will be returned when the IR camera is not available when the function that gets image processor results is called. When the called function is one that gets the latest result, such as <code><a class="el" href="namespacenn_1_1irsensor.html#a505a4e54e2b1931bd78c4a85f5b67276" title="Gets the latest results from the moment processor.">GetMomentProcessorState()</a></code>, it returns a result equivalent to nothing appearing in the IR Motion Camera, with <code><em>samplingNumber</em></code> and <code><em>deltaTime</em></code> at <code>0</code>. For functions such as <code><a class="el" href="namespacenn_1_1irsensor.html#a54d616f420145c9b7ac415d3c3d93523" title="Gets past moment processor results.">GetMomentProcessorStates()</a></code> that get previous results, <code>0</code> will be returned as the number of results until the IR Motion Camera becomes available again. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ir_sensor_adaptive_clustering_basic_2_ir_sensor_adaptive_clustering_basic_8cpp-example.html#a14">IrSensorAdaptiveClusteringBasic/IrSensorAdaptiveClusteringBasic.cpp</a>, <a class="el" href="_ir_sensor_clustering_basic_2_ir_sensor_clustering_basic_8cpp-example.html#a15">IrSensorClusteringBasic/IrSensorClusteringBasic.cpp</a>, <a class="el" href="_ir_sensor_ir_led_basic_2_ir_sensor_ir_led_basic_8cpp-example.html#a14">IrSensorIrLedBasic/IrSensorIrLedBasic.cpp</a>, <a class="el" href="_ir_sensor_moment_basic_2_ir_sensor_moment_basic_8cpp-example.html#a15">IrSensorMomentBasic/IrSensorMomentBasic.cpp</a>, and <a class="el" href="_ir_sensor_pointing_basic_2_ir_sensor_pointing_basic_8cpp-example.html#a15">IrSensorPointingBasic/IrSensorPointingBasic.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae2d917a320b39f4bc1f29f87d2418819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d917a320b39f4bc1f29f87d2418819">&#9670;&nbsp;</a></span>CheckFirmwareUpdateNecessity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::irsensor::CheckFirmwareUpdateNecessity </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pOutIsUpdateNeeded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the firmware of the controller for using the IR Motion Camera needs to be updated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutIsUpdateNeeded</td><td>Flag that returns whether an update is required. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>IR camera handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_unconnected.html">nn::irsensor::ResultIrsensorUnconnected</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_unsupported.html">nn::irsensor::ResultIrsensorUnsupported</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_firmware_check_incompleted.html">nn::irsensor::ResultIrsensorFirmwareCheckIncompleted</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The IR camera is initialized with the specified handle.</li>
<li>The processor of the IR Motion Camera, corresponding to the specified handle, is in a stopped state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Asynchronously checks the firmware of the controller equipped with the IR Motion Camera, corresponding to the specified handle. It takes a short time until a value can be obtained. If the function is called during this time, <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_firmware_check_incompleted.html" title="A class that represents error Result values (irsensor: Confirming the controller firmware version....">nn::irsensor::ResultIrsensorFirmwareCheckIncompleted</a></code> is returned, so retry. The same error is returned if the function is called with the application in the background state, so retry.</p>
<p>If the firmware is older than expected, or if it is corrupted, <code>true</code> is returned to <code><em>pOutIsUpdateNeeded</em></code>. If this occurs, call <code><a class="el" href="namespacenn_1_1hid.html#a7533399b957c748b818b5a2114541ca8" title="Displays the UI for updating controller firmware.">nn::hid::ShowControllerFirmwareUpdate</a></code> and update the controller. If the controller can be used without an update, <code>false</code> is returned to <code><em>pOutIsUpdateNeeded</em></code>.</p>
<p>This function provides a feature to check the update necessity before starting the IR Motion Camera, and does not have to be called. If the IR Motion Camera is used when a firmware update is not performed, or when an update has failed, the update will be performed by the firmware check executed when getting data with the <code>Get</code> function for each mode. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ir_sensor_adaptive_clustering_basic_2_ir_sensor_adaptive_clustering_basic_8cpp-example.html#a7">IrSensorAdaptiveClusteringBasic/IrSensorAdaptiveClusteringBasic.cpp</a>, <a class="el" href="_ir_sensor_clustering_basic_2_ir_sensor_clustering_basic_8cpp-example.html#a8">IrSensorClusteringBasic/IrSensorClusteringBasic.cpp</a>, <a class="el" href="_ir_sensor_ir_led_basic_2_ir_sensor_ir_led_basic_8cpp-example.html#a7">IrSensorIrLedBasic/IrSensorIrLedBasic.cpp</a>, <a class="el" href="_ir_sensor_moment_basic_2_ir_sensor_moment_basic_8cpp-example.html#a8">IrSensorMomentBasic/IrSensorMomentBasic.cpp</a>, and <a class="el" href="_ir_sensor_pointing_basic_2_ir_sensor_pointing_basic_8cpp-example.html#a8">IrSensorPointingBasic/IrSensorPointingBasic.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a11dddbdba407b43dd99418e81f3bcc8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11dddbdba407b43dd99418e81f3bcc8b">&#9670;&nbsp;</a></span>GetIrLedProcessorDefaultConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::irsensor::GetIrLedProcessorDefaultConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1irsensor_1_1_ir_led_processor_config.html">IrLedProcessorConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the default settings for the infrared LED processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValue</td><td>Default infrared LED processor settings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutValue</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ir_sensor_ir_led_basic_2_ir_sensor_ir_led_basic_8cpp-example.html#a20">IrSensorIrLedBasic/IrSensorIrLedBasic.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae776b3b5d6acbd2c9437bd503a94206e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae776b3b5d6acbd2c9437bd503a94206e">&#9670;&nbsp;</a></span>RunIrLedProcessor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::irsensor::RunIrLedProcessor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_ir_led_processor_config.html">IrLedProcessorConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts processing for the IR camera and the infrared LED processor. </p>
<p>If all preprocessors are running, stops the running processors and restarts processing for the infrared LED processor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>IR Camera handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Configuration of the infrared LED processor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The IR Camera is initialized with the specified handle. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The processing status of the infrared LED processor used by the IR Motion Camera of the specified handle.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 When the IR Motion Camera specified by the handle is stopped, the settings from the IR Motion Camera and the infrared LED processor are applied. Puts the IR Motion Camera into the executing processing state.</p>
<p>If the IR Motion Camera corresponding to the specified handle is in a running state, this function stops the existing processors, applies the settings to the IR Motion Camera and the infrared LED processor, and puts the IR Motion Camera into a running state again. The existing running state processors can be of any type. IR Motion Camera photography does not occur while processing. The infrared LED state is maintained, corresponding to the content specified using <code><a class="el" href="structnn_1_1irsensor_1_1_ir_led_processor_config.html" title="Structure that configures infrared LED processors.">IrLedProcessorConfig</a></code>. To change the infrared LED state, you must rerun <code>RunIrLedProcessor</code> after changing this config content. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ir_sensor_ir_led_basic_2_ir_sensor_ir_led_basic_8cpp-example.html#a23">IrSensorIrLedBasic/IrSensorIrLedBasic.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a44cd44d2f79618df0fbb6698db27a24d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44cd44d2f79618df0fbb6698db27a24d">&#9670;&nbsp;</a></span>GetIrLedProcessorState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::irsensor::GetIrLedProcessorState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the latest results from the infrared LED processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>IR Camera handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_not_ready.html">nn::irsensor::ResultIrsensorDeviceNotReady</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_unconnected.html">nn::irsensor::ResultIrsensorUnconnected</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_unsupported.html">nn::irsensor::ResultIrsensorUnsupported</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_error.html">nn::irsensor::ResultIrsensorDeviceError</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_resource_not_available.html">nn::irsensor::ResultIrsensorDeviceResourceNotAvailable</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The IR Camera is initialized with the specified handle.</li>
<li>The processing status of the infrared LED processor used by the IR Motion Camera of the specified handle.</li>
<li>pOutValue != nullptr</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function always returns <code><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">nn::ResultSuccess</a></code> while the infrared LED processor is running normally. When there are no results yet because processing just began, or when the IR Camera is not available, this function returns a value other than <code><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">nn::ResultSuccess</a></code>.</p>
<p>If the IR Motion Camera is in an abnormal state, the system will display the relevant error information on the screen. The calling function is blocked while the error is displayed. As the return value, after some user operation, the function returns <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_error.html" title="A class that represents error Result values (irsensor: The IR Motion Camera is not available because ...">nn::irsensor::ResultIrsensorDeviceError</a></code>, and then control returns to the caller.</p>
<p>When the controller firmware requires an update, the controller support applet starts and performs the update. The caller is blocked during the update. When the update is successful, <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_not_ready.html" title="A class that represents error Result values (irsensor: No processing results are available immediatel...">nn::irsensor::ResultIrsensorDeviceNotReady</a></code> is returned. When the update fails, <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_error.html" title="A class that represents error Result values (irsensor: The IR Motion Camera is not available because ...">nn::irsensor::ResultIrsensorDeviceError</a></code> is returned. Control is then returned to the caller.</p>
<p>We recommend calling this function from a thread other than the main loop because this function can block where it is called (as described previously).</p>
<p>At a minimum, you will be unable to use the IR Sensor when at least one controller is using NFP functionality. In addition, you will not be able to use multiple IR Sensors when at least five controllers are connected. If these usage conditions are not satisfied, this function will return <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_resource_not_available.html" title="A class that represents error Result values (irsensor: Cannot be used, either because of the restrict...">nn::irsensor::ResultIrsensorDeviceResourceNotAvailable</a></code> when it is called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ir_sensor_ir_led_basic_2_ir_sensor_ir_led_basic_8cpp-example.html#a18">IrSensorIrLedBasic/IrSensorIrLedBasic.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aacc1373caac7c89a734b57cae50b506c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc1373caac7c89a734b57cae50b506c">&#9670;&nbsp;</a></span>GetMomentProcessorDefaultConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::irsensor::GetMomentProcessorDefaultConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1irsensor_1_1_moment_processor_config.html">MomentProcessorConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the default settings for the moment processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValue</td><td>Default settings for the moment processor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutValue</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ir_sensor_moment_basic_2_ir_sensor_moment_basic_8cpp-example.html#a53">IrSensorMomentBasic/IrSensorMomentBasic.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a0658b45f92e49e1612735574042920e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0658b45f92e49e1612735574042920e9">&#9670;&nbsp;</a></span>RunMomentProcessor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::irsensor::RunMomentProcessor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_moment_processor_config.html">MomentProcessorConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begins processing for the IR Camera and moment processor. </p>
<p>If all preprocessors are running, stops the running processors and performs the moment processor processing again. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>IR Camera handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Moment processor settings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The IR Camera is initialized with the specified handle.</li>
<li><code><em>config</em></code>, the moment processor settings.<ul>
<li><code>MomentProcessorExposureTimeMin</code> &lt;= <code><em>config</em>.irCameraConfig.exposureTime</code>.</li>
<li><code><em>config</em>.irCameraConfig.exposureTime</code> &lt;= <code>MomentProcessorExposureTimeMax</code>.</li>
<li><code>IrCameraGainMin</code> &lt;= <code><em>config</em>.irCameraConfig.gain</code></li>
<li><code><em>config</em>.irCameraConfig.gain</code> &lt;= <code>IrCameraGainMax</code>.</li>
<li><code>0</code> &lt;= <code><em>config</em>.windowOfInterest.x</code>.</li>
<li><code>MomentProcessorBlockColumnCount</code> &lt;= <code><em>config</em>.windowOfInterest.width</code>.</li>
<li><code><em>config</em>.windowOfInterest.x</code> + <code><em>config</em>.windowOfInterest.width</code> &lt;= <code>IrCameraImageWidth</code>.</li>
<li><code>0</code> &lt;= <code><em>config</em>.windowOfInterest.y</code>.</li>
<li><code>MomentProcessorBlockRowCount</code> &lt;= <code><em>config</em>.windowOfInterest.height</code>.</li>
<li><code><em>config</em>.windowOfInterest.y</code> + <code><em>config</em>.windowOfInterest.height</code> &lt;= <code>IrCameraImageHeight</code>. </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The IR Camera corresponding to the specified handle is in a state where it is using and running the moment processor.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 If the IR Motion Camera corresponding to the specified handle is in a stopped state, this function applies the settings to the IR Motion Camera and moment processor, and puts the IR Motion Camera into a running state.</p>
<p>If the IR Motion Camera corresponding to the specified handle is in a running state, stops the existing processors, applies the settings to the IR Motion Camera and moment processor, and puts the IR Motion Camera into a running state again. The existing running state processors can be of any type. During this enabled state, IR Camera captures and processing via the moment processor occur periodically.</p>
<p>You can get results from the moment processor with <code><a class="el" href="namespacenn_1_1irsensor.html#a505a4e54e2b1931bd78c4a85f5b67276" title="Gets the latest results from the moment processor.">GetMomentProcessorState()</a></code> or <code><a class="el" href="namespacenn_1_1irsensor.html#a54d616f420145c9b7ac415d3c3d93523" title="Gets past moment processor results.">GetMomentProcessorStates()</a></code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ir_sensor_moment_basic_2_ir_sensor_moment_basic_8cpp-example.html#a54">IrSensorMomentBasic/IrSensorMomentBasic.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a505a4e54e2b1931bd78c4a85f5b67276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505a4e54e2b1931bd78c4a85f5b67276">&#9670;&nbsp;</a></span>GetMomentProcessorState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::irsensor::GetMomentProcessorState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1irsensor_1_1_moment_processor_state.html">MomentProcessorState</a> *&#160;</td>
          <td class="paramname"><em>pOutValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the latest results from the moment processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValue</td><td>Buffer to read processing results. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>IR Camera handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_not_ready.html">nn::irsensor::ResultIrsensorDeviceNotReady</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_unconnected.html">nn::irsensor::ResultIrsensorUnconnected</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_unsupported.html">nn::irsensor::ResultIrsensorUnsupported</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_error.html">nn::irsensor::ResultIrsensorDeviceError</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_resource_not_available.html">nn::irsensor::ResultIrsensorDeviceResourceNotAvailable</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The IR Camera is initialized with the specified handle.</li>
<li>The IR Camera corresponding to the specified handle is in a state where it is using and running the moment processor.</li>
<li><code><em>pOutValue</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pOutValue</em></code>, the read processing results.<ul>
<li><code>0</code> &lt;= <code><em>pOutValue</em>-&gt;blocks[<em>j</em>].averageIntensity</code> &amp;&amp; <code><em>pOutValue</em>-&gt;blocks[<em>j</em>].averageIntensity</code> &lt;= <code>IrCameraIntensityMax</code>.</li>
<li>When <code><em>pOutValue</em>-&gt;blocks[<em>j</em>].averageIntensity</code> == <code>0</code>, <code><em>pOutValue</em>-&gt;blocks[<em>j</em>].centroid.x</code> == <code>0</code> &amp;&amp; <code><em>outStates</em>[<em>i</em>].blocks[<em>j</em>].centroid.y</code> == <code>0</code>.</li>
<li>When <code><em>pOutValue</em>-&gt;blocks[<em>j</em>].averageIntensity</code> &gt; <code>0</code>, <code><em>pOutValue</em>-&gt;blocks[<em>j</em>].centroid</code> refers to the window of interest (WOI) coordinates set for the moment processor.</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 When this function returns <code><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">nn::ResultSuccess</a></code>, the same value as when one input state is read with <code><a class="el" href="namespacenn_1_1irsensor.html#a54d616f420145c9b7ac415d3c3d93523" title="Gets past moment processor results.">GetMomentProcessorStates()</a></code> is returned. When there are no results yet because processing just began, or when the IR Camera is not available, this function returns a value other than <code><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">nn::ResultSuccess</a></code>. Even in such an instance, you can get results (<code><em>pOutValue</em>-&gt;blocks[<em>j</em>].averageIntensity</code> = <code>0</code>) when the IR Motion Camera is in a state where nothing is displayed. However, <code><a class="el" href="structnn_1_1irsensor_1_1_moment_processor_state.html#a40e64427e14d0d79b9d770cf8246fc16" title="A value, greater than zero, that is incremented upon each receipt of results from a moment processor.">MomentProcessorState::samplingNumber</a></code> and <code><a class="el" href="structnn_1_1irsensor_1_1_moment_processor_state.html#af77696a3f52bcaff4d79dbcb6c0de445" title="Time data for the interval from the start of processing to when the process results are obtained.">MomentProcessorState::timeStamp</a></code> will always be <code>0</code>.</p>
<p>If the IR Motion Camera is in an abnormal state, the system will display the relevant error information on the screen. The calling function is blocked while the error is displayed. As the return value, after some user operation, the function returns <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_error.html" title="A class that represents error Result values (irsensor: The IR Motion Camera is not available because ...">nn::irsensor::ResultIrsensorDeviceError</a></code>, and then control returns to the caller.</p>
<p>When the controller firmware requires an update, the controller support applet starts and performs the update. The caller is blocked during the update. When the update is successful, <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_not_ready.html" title="A class that represents error Result values (irsensor: No processing results are available immediatel...">nn::irsensor::ResultIrsensorDeviceNotReady</a></code> is returned. When the update fails, <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_error.html" title="A class that represents error Result values (irsensor: The IR Motion Camera is not available because ...">nn::irsensor::ResultIrsensorDeviceError</a></code> is returned. Control is then returned to the caller.</p>
<p>We recommend calling this function from a thread other than the main loop because this function can block where it is called (as described previously).</p>
<p>At a minimum, you will be unable to use the IR Sensor when at least one controller is using NFP functionality. In addition, you will not be able to use multiple IR Sensors when at least five controllers are connected. If these usage conditions are not satisfied, this function will return <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_resource_not_available.html" title="A class that represents error Result values (irsensor: Cannot be used, either because of the restrict...">nn::irsensor::ResultIrsensorDeviceResourceNotAvailable</a></code> when it is called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ir_sensor_moment_basic_2_ir_sensor_moment_basic_8cpp-example.html#a20">IrSensorMomentBasic/IrSensorMomentBasic.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a54d616f420145c9b7ac415d3c3d93523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54d616f420145c9b7ac415d3c3d93523">&#9670;&nbsp;</a></span>GetMomentProcessorStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::irsensor::GetMomentProcessorStates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1irsensor_1_1_moment_processor_state.html">MomentProcessorState</a> *&#160;</td>
          <td class="paramname"><em>pOutStates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>countMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets past moment processor results. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutStates</td><td>The buffer (array) reading results. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutCount</td><td>The number of read results. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">countMax</td><td>The maximum number of results to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>IR Camera handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_not_ready.html">nn::irsensor::ResultIrsensorDeviceNotReady</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_unconnected.html">nn::irsensor::ResultIrsensorUnconnected</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_unsupported.html">nn::irsensor::ResultIrsensorUnsupported</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_error.html">nn::irsensor::ResultIrsensorDeviceError</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_resource_not_available.html">nn::irsensor::ResultIrsensorDeviceResourceNotAvailable</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The IR Camera is initialized with the specified handle.</li>
<li>The IR Camera corresponding to the specified handle is in a state where it is using and running the moment processor.</li>
<li><code><em>pOutStates</em></code> != <code>nullptr</code>.</li>
<li><code><em>countMax</em></code> &gt;= <code>0</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>For <code>*<em>pOutCount</em></code>, the number of read results, <code>0</code> &lt;= <code>*<em>pOutCount</em></code> &amp;&amp; <code>*<em>pOutCount</em></code> &lt;= <code><em>countMax</em></code> &amp;&amp; <code>*<em>pOutCount</em></code> &lt;= <code>MomentProcessorStateCountMax</code>.</li>
<li><code><em>pOutStates</em>[<em>i</em>]</code>, the read results:<ul>
<li><code>0</code> &lt;= <code><em>pOutStates</em>[<em>i</em>].blocks[<em>j</em>].averageIntensity</code> &amp;&amp; <code><em>pOutStates</em>[<em>i</em>].blocks[<em>j</em>].averageIntensity</code> &lt;= <code>IrCameraIntensityMax</code>.</li>
<li>When <code><em>pOutStates</em>[<em>i</em>].blocks[<em>j</em>].averageIntensity</code> == <code>0</code>, <code><em>pOutStates</em>[<em>i</em>].blocks[<em>j</em>].centroid.x</code> == <code>0</code> &amp;&amp; <code><em>pOutStates</em>[<em>i</em>].blocks[<em>j</em>].centroid.y</code> == <code>0</code>.</li>
<li>When <code><em>pOutStates</em>[<em>i</em>].blocks[<em>j</em>].averageIntensity</code> &gt; <code>0</code>, <code><em>pOutStates</em>[<em>i</em>].blocks[<em>j</em>].centroid</code> refers to the window of interest (WOI) coordinates set for the moment processor.</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets results from the IR Camera and moment processor corresponding to the specified handle, reading as many past states as are available, in order, from the most recent. When you specify a buffer (array) that is larger than the number of available results, nothing will be done with the leftover area. The maximum number of results that can be read is the number specified by <code>MomentProcessorStateCountMax</code>. The available input states include those that have already been read. If you want to use just the difference, see <code><a class="el" href="structnn_1_1irsensor_1_1_moment_processor_state.html#a40e64427e14d0d79b9d770cf8246fc16" title="A value, greater than zero, that is incremented upon each receipt of results from a moment processor.">MomentProcessorState::samplingNumber</a></code>. When there are no results yet because processing just began, or when the IR Camera is not available, this function returns a value other than <code><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">nn::ResultSuccess</a></code> and <code>0</code> as the number of results.</p>
<p>If the IR Motion Camera is in an abnormal state, the system will display the relevant error information on the screen. The calling function is blocked while the error is displayed. As the return value, after some user operation, the function returns <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_error.html" title="A class that represents error Result values (irsensor: The IR Motion Camera is not available because ...">nn::irsensor::ResultIrsensorDeviceError</a></code>, and then control returns to the caller.</p>
<p>When the controller firmware requires an update, the controller support applet starts and the update is performed. The caller is blocked during the update. When the update is successful, <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_not_ready.html" title="A class that represents error Result values (irsensor: No processing results are available immediatel...">nn::irsensor::ResultIrsensorDeviceNotReady</a></code> is returned. When the update fails, <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_error.html" title="A class that represents error Result values (irsensor: The IR Motion Camera is not available because ...">nn::irsensor::ResultIrsensorDeviceError</a></code> is returned. Control is then returned to the caller.</p>
<p>We recommend calling this function from a thread other than the main loop because this function can block where it is called (as described previously).</p>
<p>At a minimum, you will be unable to use the IR Sensor when at least one controller is using NFP functionality. In addition, you will not be able to use multiple IR Sensors when at least five controllers are connected. If these usage conditions are not satisfied, this function will return <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_resource_not_available.html" title="A class that represents error Result values (irsensor: Cannot be used, either because of the restrict...">nn::irsensor::ResultIrsensorDeviceResourceNotAvailable</a></code> when it is called. </p>

</div>
</div>
<a id="a59c192d7cb6147dc50ac8d4b1751d746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c192d7cb6147dc50ac8d4b1751d746">&#9670;&nbsp;</a></span>CalculateMomentRegionStatistic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1irsensor_1_1_moment_statistic.html">MomentStatistic</a> nn::irsensor::CalculateMomentRegionStatistic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_moment_processor_state.html">MomentProcessorState</a> *&#160;</td>
          <td class="paramname"><em>pState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>windowOfInterest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rowCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>columnCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the statistics for a rectangular region comprised of multiple blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pState</td><td>The process result obtained by the moment processor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">windowOfInterest</td><td>The rectangular region configured to the moment processor when the process result was obtained. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startRow</td><td>The starting row of the region. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startColumn</td><td>The starting column of the region. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowCount</td><td>The number of rows in the region. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">columnCount</td><td>The number of columns in the region. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the statistics for the region. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pState</em></code> != <code>nullptr</code>.</li>
<li><code>0</code> &lt;= <code><em>startRow</em></code>.</li>
<li><code>1</code> &lt;= <code><em>rowCount</em></code>.</li>
<li><code><em>startRow</em></code> + <code><em>rowCount</em></code> &lt;= <code>MomentProcessorBlockRowCount</code>.</li>
<li><code>0</code> &lt;= <code><em>startColumn</em></code>.</li>
<li><code>1</code> &lt;= <code><em>columnCount</em></code>.</li>
<li><code><em>startColumn</em></code> + <code><em>rowCount</em></code> &lt;= <code>MomentProcessorBlockColumnCount</code>.</li>
<li>Set to be the same as the <code><em>windowOfInterest</em></code> configured when data was obtained using the moment processor.</li>
<li><code>0</code> &lt;= <code><em>windowOfInterest</em>.x</code>.</li>
<li><code>MomentProcessorBlockColumnCount</code> &lt;= <code><em>windowOfInterest</em>.width</code>.</li>
<li><code><em>windowOfInterest</em>.x</code> + <code><em>windowOfIntereset</em>.width</code> &lt;= <code>IrCameraImageWidth</code></li>
<li><code>0</code> &lt;= <code><em>windowOfInterest</em>.y</code>.</li>
<li><code>MomentProcessorBlockRowCount</code> &lt;= <code><em>windowOfInterest</em>.height</code>.</li>
<li><code><em>windowOfIntereset</em>.y</code> + <code><em>windowOfIntereset</em>.height</code> &lt;= <code>IrCameraImageHeight</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Data available using the moment processor is data at the individual block level. Use this function for multiple rectangle block data, including when you need for an entire image, to recalculate statistics as a region. The <code>WindowOfInterest</code> data for the entire image when the original data was obtained is needed to recalculate statistics as a rectangle region. Set to the same value as that for the <code>WindowOfInterest</code> configured using the <code><a class="el" href="namespacenn_1_1irsensor.html#a0658b45f92e49e1612735574042920e9" title="Begins processing for the IR Camera and moment processor.">RunMomentProcessor()</a></code> function parameter. </p>

</div>
</div>
<a id="a35ef293f2a5162a81e7c07ea3693de82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ef293f2a5162a81e7c07ea3693de82">&#9670;&nbsp;</a></span>RunPointingProcessor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::irsensor::RunPointingProcessor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begins processing for the IR camera and pointing processor. </p>
<p>If all preprocessors are running, stops the running processors and restarts processing for the pointing processor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>IR Camera handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The IR Camera is initialized with the specified handle.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The processing status of the pointing processor used by the IR Motion Camera of the specified handle.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 If the IR Motion Camera and processor corresponding to the specified handled are stopped, applies the settings to the IR Camera and pointing processor Puts the IR Motion Camera into the executing processing state.</p>
<p>If the IR Motion Camera corresponding to the specified handle is in a running state, this function stops the existing processors, applies the settings to the IR Motion Camera and pointing processor, and puts the IR Motion Camera into a running state again. The existing running state processors can be of any type. This function periodically runs IR Motion Camera capture and pointing processor processing while in a running state.</p>
<p>The processing result of the pointing processor can be obtained with <code><a class="el" href="namespacenn_1_1irsensor.html#affe5dbef15c8120623fa7301622502e1" title="Gets past pointing processor results.">GetPointingProcessorStates()</a></code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ir_sensor_pointing_basic_2_ir_sensor_pointing_basic_8cpp-example.html#a44">IrSensorPointingBasic/IrSensorPointingBasic.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="affe5dbef15c8120623fa7301622502e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affe5dbef15c8120623fa7301622502e1">&#9670;&nbsp;</a></span>GetPointingProcessorStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::irsensor::GetPointingProcessorStates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1irsensor_1_1_pointing_processor_state.html">PointingProcessorState</a> *&#160;</td>
          <td class="paramname"><em>pOutStates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>countMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1irsensor_1_1_ir_camera_handle.html">IrCameraHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets past pointing processor results. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutStates</td><td>The buffer (array) reading results. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutCount</td><td>The number of read results. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">countMax</td><td>The maximum number of results to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>IR Camera handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_not_ready.html">nn::irsensor::ResultIrsensorDeviceNotReady</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_unconnected.html">nn::irsensor::ResultIrsensorUnconnected</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_unsupported.html">nn::irsensor::ResultIrsensorUnsupported</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_error.html">nn::irsensor::ResultIrsensorDeviceError</a> must be handled.</li>
<li><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_resource_not_available.html">nn::irsensor::ResultIrsensorDeviceResourceNotAvailable</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The IR Camera is initialized with the specified handle.</li>
<li>The processing status of the pointing processor used by the IR Motion Camera of the specified handle.</li>
<li><code><em>pOutStates</em></code> is not a null pointer.</li>
<li><code><em>countMax</em></code> &gt;= <code>0</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>For the count of processing results <code>0</code> &lt;= <code>*<em>pOutCount</em></code> &lt;= &amp;&amp; <code>*<em>pOutCount</em></code> &lt;= <code><em>countMax</em></code> &amp;&amp; <code>*<em>pOutCount</em></code> &lt;= <code>PointingProcessorStateCountMax</code>.</li>
<li><code><em>pOutStates</em>[i].position</code> is normalized coordinate data.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets results from the IR Motion Camera and pointing processor corresponding to the specified handle, reading as many past states as are available, in order, from the most recent. When you specify a buffer (array) that is larger than the number of available results, nothing will be done with the leftover area. The maximum number of processing results available for reading is <code>PointingProcessorStateCountMax</code>. The available input states include those that have already been read. If only the difference is needed, reference <code><a class="el" href="structnn_1_1irsensor_1_1_pointing_processor_state.html" title="A structure representing the results of the pointing processor.">PointingProcessorState</a>::<em>sampleNumber</em></code>. When there are no results yet because processing just began, or when the IR camera is not available, this function returns a value other than <code><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">nn::ResultSuccess</a></code> and <code>0</code> as the number of results.</p>
<p>If the IR Motion Camera is in an abnormal state, the system will display the relevant error information on the screen. The calling function is blocked while the error is displayed. As the return value, after some user operation, the function returns <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_error.html" title="A class that represents error Result values (irsensor: The IR Motion Camera is not available because ...">nn::irsensor::ResultIrsensorDeviceError</a></code>, and then control returns to the caller.</p>
<p>When the controller firmware requires an update, the controller support applet starts and performs the update. The caller is blocked during the update. When the update is successful, <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_not_ready.html" title="A class that represents error Result values (irsensor: No processing results are available immediatel...">nn::irsensor::ResultIrsensorDeviceNotReady</a></code> is returned. When the update fails, <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_error.html" title="A class that represents error Result values (irsensor: The IR Motion Camera is not available because ...">nn::irsensor::ResultIrsensorDeviceError</a></code> is returned. Control is then returned to the caller.</p>
<p>We recommend calling this function from a thread other than the main loop because this function can block where it is called (as described previously).</p>
<p>At a minimum, you will be unable to use the IR Sensor when at least one controller is using NFP functionality. In addition, you will not be able to use multiple IR Sensors when at least five controllers are connected. If these usage conditions are not satisfied, this function returns <code><a class="el" href="classnn_1_1irsensor_1_1_result_irsensor_device_resource_not_available.html" title="A class that represents error Result values (irsensor: Cannot be used, either because of the restrict...">nn::irsensor::ResultIrsensorDeviceResourceNotAvailable</a></code> when it is called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ir_sensor_pointing_basic_2_ir_sensor_pointing_basic_8cpp-example.html#a21">IrSensorPointingBasic/IrSensorPointingBasic.cpp</a>.</dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
