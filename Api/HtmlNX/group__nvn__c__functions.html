<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>API Functions | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">API Functions<div class="ingroups"><a class="el" href="group__nvn__c__interface.html">NVN C API Bindings</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>C Interface API entry points.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga347fb2b3121de63e9c3a6b9595ccd2c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga594e8a6aa9642c5542c0a0ee0156c146">NVNblendAdvancedMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga347fb2b3121de63e9c3a6b9595ccd2c0">nvnBlendStateGetAdvancedMode</a> (const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend)</td></tr>
<tr class="memdesc:ga347fb2b3121de63e9c3a6b9595ccd2c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the mode for advanced blending equations.  <a href="group__nvn__c__functions.html#ga347fb2b3121de63e9c3a6b9595ccd2c0">More...</a><br /></td></tr>
<tr class="separator:ga347fb2b3121de63e9c3a6b9595ccd2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c2a450326605d61c14c8a888db2fb2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4c2a450326605d61c14c8a888db2fb2b">nvnBlendStateGetAdvancedNormalizedDst</a> (const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend)</td></tr>
<tr class="memdesc:ga4c2a450326605d61c14c8a888db2fb2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the destination color target has unsigned normalized components (values in [0,1]).  <a href="group__nvn__c__functions.html#ga4c2a450326605d61c14c8a888db2fb2b">More...</a><br /></td></tr>
<tr class="separator:ga4c2a450326605d61c14c8a888db2fb2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1fa95ae6b7e29e8eeb8c491f846f467"><td class="memItemLeft" align="right" valign="top">NVNINLINE <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae1fa95ae6b7e29e8eeb8c491f846f467">nvnBlendStateGetAdvancedNormalizedDst_fastpath</a> (const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend)</td></tr>
<tr class="memdesc:gae1fa95ae6b7e29e8eeb8c491f846f467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the destination color target has unsigned normalized components (values in [0,1]).  <a href="group__nvn__c__functions.html#gae1fa95ae6b7e29e8eeb8c491f846f467">More...</a><br /></td></tr>
<tr class="separator:gae1fa95ae6b7e29e8eeb8c491f846f467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a0232ed175b83f4002d237e98eea02c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga49a9399d8c6cc26a7f4b256fe0951699">NVNblendAdvancedOverlap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9a0232ed175b83f4002d237e98eea02c">nvnBlendStateGetAdvancedOverlap</a> (const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend)</td></tr>
<tr class="memdesc:ga9a0232ed175b83f4002d237e98eea02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the blend overlap mode for advanced blending equations.  <a href="group__nvn__c__functions.html#ga9a0232ed175b83f4002d237e98eea02c">More...</a><br /></td></tr>
<tr class="separator:ga9a0232ed175b83f4002d237e98eea02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e8df2c0b7c30848c050cf62da45494d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8e8df2c0b7c30848c050cf62da45494d">nvnBlendStateGetAdvancedPremultipliedSrc</a> (const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend)</td></tr>
<tr class="memdesc:ga8e8df2c0b7c30848c050cf62da45494d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the source color is considered premultiplied for advanced blending equations.  <a href="group__nvn__c__functions.html#ga8e8df2c0b7c30848c050cf62da45494d">More...</a><br /></td></tr>
<tr class="separator:ga8e8df2c0b7c30848c050cf62da45494d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f80605e385de2c63e73c51162897bde"><td class="memItemLeft" align="right" valign="top">NVNINLINE <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3f80605e385de2c63e73c51162897bde">nvnBlendStateGetAdvancedPremultipliedSrc_fastpath</a> (const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend)</td></tr>
<tr class="memdesc:ga3f80605e385de2c63e73c51162897bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the source color is considered premultiplied for advanced blending equations.  <a href="group__nvn__c__functions.html#ga3f80605e385de2c63e73c51162897bde">More...</a><br /></td></tr>
<tr class="separator:ga3f80605e385de2c63e73c51162897bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7473bde2a4b5144923394d2b2b3ebaab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7473bde2a4b5144923394d2b2b3ebaab">nvnBlendStateGetBlendEquation</a> (const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend, <a class="el" href="group__nvn__c__enum.html#ga127348ecf50d7e4c7197ed7e989c5e60">NVNblendEquation</a> *modeRGB, <a class="el" href="group__nvn__c__enum.html#ga127348ecf50d7e4c7197ed7e989c5e60">NVNblendEquation</a> *modeAlpha)</td></tr>
<tr class="memdesc:ga7473bde2a4b5144923394d2b2b3ebaab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query blend equations for color and alpha channels.  <a href="group__nvn__c__functions.html#ga7473bde2a4b5144923394d2b2b3ebaab">More...</a><br /></td></tr>
<tr class="separator:ga7473bde2a4b5144923394d2b2b3ebaab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafac4c143756021848290b54879da1240"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gafac4c143756021848290b54879da1240">nvnBlendStateGetBlendFunc</a> (const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend, <a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a> *srcFunc, <a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a> *dstFunc, <a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a> *srcFuncAlpha, <a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a> *dstFuncAlpha)</td></tr>
<tr class="memdesc:gafac4c143756021848290b54879da1240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query blend functions for source and destination color and alpha channels.  <a href="group__nvn__c__functions.html#gafac4c143756021848290b54879da1240">More...</a><br /></td></tr>
<tr class="separator:gafac4c143756021848290b54879da1240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67117050f7018fa4eb4f51b7611b743c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga67117050f7018fa4eb4f51b7611b743c">nvnBlendStateGetBlendTarget</a> (const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend)</td></tr>
<tr class="memdesc:ga67117050f7018fa4eb4f51b7611b743c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of the color target to update via the <a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object.  <a href="group__nvn__c__functions.html#ga67117050f7018fa4eb4f51b7611b743c">More...</a><br /></td></tr>
<tr class="separator:ga67117050f7018fa4eb4f51b7611b743c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f8a1adcd6b4c29ee296072ba9f0942f"><td class="memItemLeft" align="right" valign="top">NVNINLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga5f8a1adcd6b4c29ee296072ba9f0942f">nvnBlendStateGetBlendTarget_fastpath</a> (const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend)</td></tr>
<tr class="memdesc:ga5f8a1adcd6b4c29ee296072ba9f0942f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of the color target to update via the <a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object.  <a href="group__nvn__c__functions.html#ga5f8a1adcd6b4c29ee296072ba9f0942f">More...</a><br /></td></tr>
<tr class="separator:ga5f8a1adcd6b4c29ee296072ba9f0942f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadda20b441c242fbad2fa87c9c441735a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gadda20b441c242fbad2fa87c9c441735a">nvnBlendStateSetAdvancedMode</a> (<a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend, <a class="el" href="group__nvn__c__enum.html#ga594e8a6aa9642c5542c0a0ee0156c146">NVNblendAdvancedMode</a> overlap)</td></tr>
<tr class="memdesc:gadda20b441c242fbad2fa87c9c441735a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a mode for advanced blending equations.  <a href="group__nvn__c__functions.html#gadda20b441c242fbad2fa87c9c441735a">More...</a><br /></td></tr>
<tr class="separator:gadda20b441c242fbad2fa87c9c441735a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47baf1ff1219b778f966f1866f6b0666"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga47baf1ff1219b778f966f1866f6b0666">nvnBlendStateSetAdvancedMode_fastpath</a> (<a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend, <a class="el" href="group__nvn__c__enum.html#ga594e8a6aa9642c5542c0a0ee0156c146">NVNblendAdvancedMode</a> overlap)</td></tr>
<tr class="memdesc:ga47baf1ff1219b778f966f1866f6b0666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a mode for advanced blending equations.  <a href="group__nvn__c__functions.html#ga47baf1ff1219b778f966f1866f6b0666">More...</a><br /></td></tr>
<tr class="separator:ga47baf1ff1219b778f966f1866f6b0666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ae21c2d569e680699ce50ff6d6b3a7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3ae21c2d569e680699ce50ff6d6b3a7b">nvnBlendStateSetAdvancedNormalizedDst</a> (<a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> normalized)</td></tr>
<tr class="memdesc:ga3ae21c2d569e680699ce50ff6d6b3a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify whether the destination color target has unsigned normalized components (values in [0,1]).  <a href="group__nvn__c__functions.html#ga3ae21c2d569e680699ce50ff6d6b3a7b">More...</a><br /></td></tr>
<tr class="separator:ga3ae21c2d569e680699ce50ff6d6b3a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14b8abb0c19884137457c9379982db3f"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga14b8abb0c19884137457c9379982db3f">nvnBlendStateSetAdvancedNormalizedDst_fastpath</a> (<a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> normalized)</td></tr>
<tr class="memdesc:ga14b8abb0c19884137457c9379982db3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify whether the destination color target has unsigned normalized components (values in [0,1]).  <a href="group__nvn__c__functions.html#ga14b8abb0c19884137457c9379982db3f">More...</a><br /></td></tr>
<tr class="separator:ga14b8abb0c19884137457c9379982db3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e2be1cd8aad18c9d1ba0f9fa4ca7af4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0e2be1cd8aad18c9d1ba0f9fa4ca7af4">nvnBlendStateSetAdvancedOverlap</a> (<a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend, <a class="el" href="group__nvn__c__enum.html#ga49a9399d8c6cc26a7f4b256fe0951699">NVNblendAdvancedOverlap</a> overlap)</td></tr>
<tr class="memdesc:ga0e2be1cd8aad18c9d1ba0f9fa4ca7af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify blend overlap mode for advanced blending equations.  <a href="group__nvn__c__functions.html#ga0e2be1cd8aad18c9d1ba0f9fa4ca7af4">More...</a><br /></td></tr>
<tr class="separator:ga0e2be1cd8aad18c9d1ba0f9fa4ca7af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec9e463299721f02e7c0f6afc1922590"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaec9e463299721f02e7c0f6afc1922590">nvnBlendStateSetAdvancedOverlap_fastpath</a> (<a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend, <a class="el" href="group__nvn__c__enum.html#ga49a9399d8c6cc26a7f4b256fe0951699">NVNblendAdvancedOverlap</a> overlap)</td></tr>
<tr class="memdesc:gaec9e463299721f02e7c0f6afc1922590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify blend overlap mode for advanced blending equations.  <a href="group__nvn__c__functions.html#gaec9e463299721f02e7c0f6afc1922590">More...</a><br /></td></tr>
<tr class="separator:gaec9e463299721f02e7c0f6afc1922590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8aae125e2a9006310e3812c99e5f7ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac8aae125e2a9006310e3812c99e5f7ff">nvnBlendStateSetAdvancedPremultipliedSrc</a> (<a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> premultiplied)</td></tr>
<tr class="memdesc:gac8aae125e2a9006310e3812c99e5f7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify whether the source color is considered premultiplied for advanced blending equations.  <a href="group__nvn__c__functions.html#gac8aae125e2a9006310e3812c99e5f7ff">More...</a><br /></td></tr>
<tr class="separator:gac8aae125e2a9006310e3812c99e5f7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff5b17f8bdd9ab57c6c495b1c0e64d85"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaff5b17f8bdd9ab57c6c495b1c0e64d85">nvnBlendStateSetAdvancedPremultipliedSrc_fastpath</a> (<a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> premultiplied)</td></tr>
<tr class="memdesc:gaff5b17f8bdd9ab57c6c495b1c0e64d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify whether the source color is considered premultiplied for advanced blending equations.  <a href="group__nvn__c__functions.html#gaff5b17f8bdd9ab57c6c495b1c0e64d85">More...</a><br /></td></tr>
<tr class="separator:gaff5b17f8bdd9ab57c6c495b1c0e64d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8c227afe934866f7758f9158ebe1f9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad8c227afe934866f7758f9158ebe1f9f">nvnBlendStateSetBlendEquation</a> (<a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend, <a class="el" href="group__nvn__c__enum.html#ga127348ecf50d7e4c7197ed7e989c5e60">NVNblendEquation</a> modeRGB, <a class="el" href="group__nvn__c__enum.html#ga127348ecf50d7e4c7197ed7e989c5e60">NVNblendEquation</a> modeAlpha)</td></tr>
<tr class="memdesc:gad8c227afe934866f7758f9158ebe1f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify blend equations for color and alpha channels.  <a href="group__nvn__c__functions.html#gad8c227afe934866f7758f9158ebe1f9f">More...</a><br /></td></tr>
<tr class="separator:gad8c227afe934866f7758f9158ebe1f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38d3f5fdce0a963834287722be665ef8"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga38d3f5fdce0a963834287722be665ef8">nvnBlendStateSetBlendEquation_fastpath</a> (<a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend, <a class="el" href="group__nvn__c__enum.html#ga127348ecf50d7e4c7197ed7e989c5e60">NVNblendEquation</a> modeRGB, <a class="el" href="group__nvn__c__enum.html#ga127348ecf50d7e4c7197ed7e989c5e60">NVNblendEquation</a> modeAlpha)</td></tr>
<tr class="memdesc:ga38d3f5fdce0a963834287722be665ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify blend equations for color and alpha channels.  <a href="group__nvn__c__functions.html#ga38d3f5fdce0a963834287722be665ef8">More...</a><br /></td></tr>
<tr class="separator:ga38d3f5fdce0a963834287722be665ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f1f669fc90892348eb5763a6d173c60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8f1f669fc90892348eb5763a6d173c60">nvnBlendStateSetBlendFunc</a> (<a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend, <a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a> srcFunc, <a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a> dstFunc, <a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a> srcFuncAlpha, <a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a> dstFuncAlpha)</td></tr>
<tr class="memdesc:ga8f1f669fc90892348eb5763a6d173c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify blend functions for source and destination color and alpha channels.  <a href="group__nvn__c__functions.html#ga8f1f669fc90892348eb5763a6d173c60">More...</a><br /></td></tr>
<tr class="separator:ga8f1f669fc90892348eb5763a6d173c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79b06d608873a5153807d809b96bd272"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga79b06d608873a5153807d809b96bd272">nvnBlendStateSetBlendFunc_fastpath</a> (<a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend, <a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a> srcFunc, <a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a> dstFunc, <a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a> srcFuncAlpha, <a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a> dstFuncAlpha)</td></tr>
<tr class="memdesc:ga79b06d608873a5153807d809b96bd272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify blend functions for source and destination color and alpha channels.  <a href="group__nvn__c__functions.html#ga79b06d608873a5153807d809b96bd272">More...</a><br /></td></tr>
<tr class="separator:ga79b06d608873a5153807d809b96bd272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe4427881d956cf1db9fc536bb9586ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gafe4427881d956cf1db9fc536bb9586ce">nvnBlendStateSetBlendTarget</a> (<a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend, int target)</td></tr>
<tr class="memdesc:gafe4427881d956cf1db9fc536bb9586ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the number of the color target to update via the <a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object.  <a href="group__nvn__c__functions.html#gafe4427881d956cf1db9fc536bb9586ce">More...</a><br /></td></tr>
<tr class="separator:gafe4427881d956cf1db9fc536bb9586ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0da5237e8887948680f1c401cab2011"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf0da5237e8887948680f1c401cab2011">nvnBlendStateSetBlendTarget_fastpath</a> (<a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend, int target)</td></tr>
<tr class="memdesc:gaf0da5237e8887948680f1c401cab2011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the number of the color target to update via the <a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object.  <a href="group__nvn__c__functions.html#gaf0da5237e8887948680f1c401cab2011">More...</a><br /></td></tr>
<tr class="separator:gaf0da5237e8887948680f1c401cab2011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0c043334f5f7eb94883fc0465f18e4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad0c043334f5f7eb94883fc0465f18e4f">nvnBlendStateSetDefaults</a> (<a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend)</td></tr>
<tr class="memdesc:gad0c043334f5f7eb94883fc0465f18e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object.  <a href="group__nvn__c__functions.html#gad0c043334f5f7eb94883fc0465f18e4f">More...</a><br /></td></tr>
<tr class="separator:gad0c043334f5f7eb94883fc0465f18e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf799ed12f9ff9d00ec9acdc4ba60ba57"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf799ed12f9ff9d00ec9acdc4ba60ba57">nvnBufferBuilderGetDevice</a> (const <a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *builder)</td></tr>
<tr class="memdesc:gaf799ed12f9ff9d00ec9acdc4ba60ba57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the device associated with this <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object.  <a href="group__nvn__c__functions.html#gaf799ed12f9ff9d00ec9acdc4ba60ba57">More...</a><br /></td></tr>
<tr class="separator:gaf799ed12f9ff9d00ec9acdc4ba60ba57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b753c8e6ece193fed5d50c2d2e2d23b"><td class="memItemLeft" align="right" valign="top">NVNINLINE const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga5b753c8e6ece193fed5d50c2d2e2d23b">nvnBufferBuilderGetDevice_fastpath</a> (const <a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga5b753c8e6ece193fed5d50c2d2e2d23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the device associated with this <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object.  <a href="group__nvn__c__functions.html#ga5b753c8e6ece193fed5d50c2d2e2d23b">More...</a><br /></td></tr>
<tr class="separator:ga5b753c8e6ece193fed5d50c2d2e2d23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga205e32b963584eaf5e8c78cdba135e68"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga205e32b963584eaf5e8c78cdba135e68">nvnBufferBuilderGetMemoryOffset</a> (const <a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga205e32b963584eaf5e8c78cdba135e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool offset used by a <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object.  <a href="group__nvn__c__functions.html#ga205e32b963584eaf5e8c78cdba135e68">More...</a><br /></td></tr>
<tr class="separator:ga205e32b963584eaf5e8c78cdba135e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fb3902aaac7accad53fb11f558ac99b"><td class="memItemLeft" align="right" valign="top">NVNINLINE ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0fb3902aaac7accad53fb11f558ac99b">nvnBufferBuilderGetMemoryOffset_fastpath</a> (const <a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga0fb3902aaac7accad53fb11f558ac99b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool offset used by a <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object.  <a href="group__nvn__c__functions.html#ga0fb3902aaac7accad53fb11f558ac99b">More...</a><br /></td></tr>
<tr class="separator:ga0fb3902aaac7accad53fb11f558ac99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80ec5e6a2f5d90f738de111cef60c5b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga80ec5e6a2f5d90f738de111cef60c5b4">nvnBufferBuilderGetMemoryPool</a> (const <a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga80ec5e6a2f5d90f738de111cef60c5b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool used by a <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object.  <a href="group__nvn__c__functions.html#ga80ec5e6a2f5d90f738de111cef60c5b4">More...</a><br /></td></tr>
<tr class="separator:ga80ec5e6a2f5d90f738de111cef60c5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a89114d870cb5b4da2d980a345956f8"><td class="memItemLeft" align="right" valign="top">NVNINLINE <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga5a89114d870cb5b4da2d980a345956f8">nvnBufferBuilderGetMemoryPool_fastpath</a> (const <a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga5a89114d870cb5b4da2d980a345956f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool used by a <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object.  <a href="group__nvn__c__functions.html#ga5a89114d870cb5b4da2d980a345956f8">More...</a><br /></td></tr>
<tr class="separator:ga5a89114d870cb5b4da2d980a345956f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga318db40761633c5e9129be18c1420f9c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga318db40761633c5e9129be18c1420f9c">nvnBufferBuilderGetSize</a> (const <a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga318db40761633c5e9129be18c1420f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the size (in bytes) of the storage in a <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object.  <a href="group__nvn__c__functions.html#ga318db40761633c5e9129be18c1420f9c">More...</a><br /></td></tr>
<tr class="separator:ga318db40761633c5e9129be18c1420f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga375f0fbe90f51fd378f5c17d734cd738"><td class="memItemLeft" align="right" valign="top">NVNINLINE size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga375f0fbe90f51fd378f5c17d734cd738">nvnBufferBuilderGetSize_fastpath</a> (const <a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga375f0fbe90f51fd378f5c17d734cd738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the size (in bytes) of the storage in a <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object.  <a href="group__nvn__c__functions.html#ga375f0fbe90f51fd378f5c17d734cd738">More...</a><br /></td></tr>
<tr class="separator:ga375f0fbe90f51fd378f5c17d734cd738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17550ab21d8136e4f5c48c91c21716f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga17550ab21d8136e4f5c48c91c21716f2">nvnBufferBuilderSetDefaults</a> (<a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga17550ab21d8136e4f5c48c91c21716f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object.  <a href="group__nvn__c__functions.html#ga17550ab21d8136e4f5c48c91c21716f2">More...</a><br /></td></tr>
<tr class="separator:ga17550ab21d8136e4f5c48c91c21716f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f1e5a40cc9b049892a527b95ac9b9fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7f1e5a40cc9b049892a527b95ac9b9fc">nvnBufferBuilderSetDevice</a> (<a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *builder, <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device)</td></tr>
<tr class="memdesc:ga7f1e5a40cc9b049892a527b95ac9b9fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> associated with a <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object.  <a href="group__nvn__c__functions.html#ga7f1e5a40cc9b049892a527b95ac9b9fc">More...</a><br /></td></tr>
<tr class="separator:ga7f1e5a40cc9b049892a527b95ac9b9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaa4fd698902c746debccb3fa967e324"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaaaa4fd698902c746debccb3fa967e324">nvnBufferBuilderSetStorage</a> (<a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *builder, <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *pool, ptrdiff_t offset, size_t size)</td></tr>
<tr class="memdesc:gaaaa4fd698902c746debccb3fa967e324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the range of a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> used for a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object created from the <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a>.  <a href="group__nvn__c__functions.html#gaaaa4fd698902c746debccb3fa967e324">More...</a><br /></td></tr>
<tr class="separator:gaaaa4fd698902c746debccb3fa967e324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41b52c690e8fb7f7455588c4e4403768"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga41b52c690e8fb7f7455588c4e4403768">nvnBufferBuilderSetStorage_fastpath</a> (<a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *builder, <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *pool, ptrdiff_t offset, size_t size)</td></tr>
<tr class="memdesc:ga41b52c690e8fb7f7455588c4e4403768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the range of a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> used for a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object created from the <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a>.  <a href="group__nvn__c__functions.html#ga41b52c690e8fb7f7455588c4e4403768">More...</a><br /></td></tr>
<tr class="separator:ga41b52c690e8fb7f7455588c4e4403768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e56941d8153c1e1b2ba861189ea993d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3e56941d8153c1e1b2ba861189ea993d">nvnBufferFinalize</a> (<a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *buffer)</td></tr>
<tr class="memdesc:ga3e56941d8153c1e1b2ba861189ea993d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object.  <a href="group__nvn__c__functions.html#ga3e56941d8153c1e1b2ba861189ea993d">More...</a><br /></td></tr>
<tr class="separator:ga3e56941d8153c1e1b2ba861189ea993d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77aee9d827392e1bb7d86a02dd5b8e5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga77aee9d827392e1bb7d86a02dd5b8e5c">nvnBufferFlushMappedRange</a> (const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *buffer, ptrdiff_t offset, size_t size)</td></tr>
<tr class="memdesc:ga77aee9d827392e1bb7d86a02dd5b8e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush previous CPU writes to a range of a buffer to be visible to the GPU.  <a href="group__nvn__c__functions.html#ga77aee9d827392e1bb7d86a02dd5b8e5c">More...</a><br /></td></tr>
<tr class="separator:ga77aee9d827392e1bb7d86a02dd5b8e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac38c964075df642306d6490b8b50ace3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac38c964075df642306d6490b8b50ace3">nvnBufferGetAddress</a> (const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *buffer)</td></tr>
<tr class="memdesc:gac38c964075df642306d6490b8b50ace3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the GPU address of the data store of a buffer object.  <a href="group__nvn__c__functions.html#gac38c964075df642306d6490b8b50ace3">More...</a><br /></td></tr>
<tr class="separator:gac38c964075df642306d6490b8b50ace3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d63ead7e4386863c9d3e250be49ad47"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3d63ead7e4386863c9d3e250be49ad47">nvnBufferGetDebugID</a> (const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *buffer)</td></tr>
<tr class="memdesc:ga3d63ead7e4386863c9d3e250be49ad47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the debug layer unique ID of this buffer.  <a href="group__nvn__c__functions.html#ga3d63ead7e4386863c9d3e250be49ad47">More...</a><br /></td></tr>
<tr class="separator:ga3d63ead7e4386863c9d3e250be49ad47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga748c3509a17ea343cbee8675d4185f6e"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga748c3509a17ea343cbee8675d4185f6e">nvnBufferGetMemoryOffset</a> (const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *buffer)</td></tr>
<tr class="memdesc:ga748c3509a17ea343cbee8675d4185f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool offset used by a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object.  <a href="group__nvn__c__functions.html#ga748c3509a17ea343cbee8675d4185f6e">More...</a><br /></td></tr>
<tr class="separator:ga748c3509a17ea343cbee8675d4185f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga286445ca576d2dd9a1733fcb6bf7501a"><td class="memItemLeft" align="right" valign="top">NVNINLINE ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga286445ca576d2dd9a1733fcb6bf7501a">nvnBufferGetMemoryOffset_fastpath</a> (const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *buffer)</td></tr>
<tr class="memdesc:ga286445ca576d2dd9a1733fcb6bf7501a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool offset used by a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object.  <a href="group__nvn__c__functions.html#ga286445ca576d2dd9a1733fcb6bf7501a">More...</a><br /></td></tr>
<tr class="separator:ga286445ca576d2dd9a1733fcb6bf7501a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f89923da0518bec56898b2dcddf213d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga5f89923da0518bec56898b2dcddf213d">nvnBufferGetMemoryPool</a> (const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *buffer)</td></tr>
<tr class="memdesc:ga5f89923da0518bec56898b2dcddf213d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool used by a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object.  <a href="group__nvn__c__functions.html#ga5f89923da0518bec56898b2dcddf213d">More...</a><br /></td></tr>
<tr class="separator:ga5f89923da0518bec56898b2dcddf213d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4977edbe6a03b57fcf28fde92c24649"><td class="memItemLeft" align="right" valign="top">NVNINLINE <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaa4977edbe6a03b57fcf28fde92c24649">nvnBufferGetMemoryPool_fastpath</a> (const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *buffer)</td></tr>
<tr class="memdesc:gaa4977edbe6a03b57fcf28fde92c24649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool used by a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object.  <a href="group__nvn__c__functions.html#gaa4977edbe6a03b57fcf28fde92c24649">More...</a><br /></td></tr>
<tr class="separator:gaa4977edbe6a03b57fcf28fde92c24649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9537e164c060a08b95e68caea5c9ba6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad9537e164c060a08b95e68caea5c9ba6">nvnBufferGetSize</a> (const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *buffer)</td></tr>
<tr class="memdesc:gad9537e164c060a08b95e68caea5c9ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the size (in bytes) of the storage of a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object.  <a href="group__nvn__c__functions.html#gad9537e164c060a08b95e68caea5c9ba6">More...</a><br /></td></tr>
<tr class="separator:gad9537e164c060a08b95e68caea5c9ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f5c6403f8121790616058c4138c2d1c"><td class="memItemLeft" align="right" valign="top">NVNINLINE size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga5f5c6403f8121790616058c4138c2d1c">nvnBufferGetSize_fastpath</a> (const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *buffer)</td></tr>
<tr class="memdesc:ga5f5c6403f8121790616058c4138c2d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the size (in bytes) of the storage of a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object.  <a href="group__nvn__c__functions.html#ga5f5c6403f8121790616058c4138c2d1c">More...</a><br /></td></tr>
<tr class="separator:ga5f5c6403f8121790616058c4138c2d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga862eafc1a9c42ce08a7c40ba004d7b57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga862eafc1a9c42ce08a7c40ba004d7b57">nvnBufferInitialize</a> (<a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *buffer, const <a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga862eafc1a9c42ce08a7c40ba004d7b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a new buffer object from a buffer builder.  <a href="group__nvn__c__functions.html#ga862eafc1a9c42ce08a7c40ba004d7b57">More...</a><br /></td></tr>
<tr class="separator:ga862eafc1a9c42ce08a7c40ba004d7b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7087d787b41f8b07b13ed3a7f1edddc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf7087d787b41f8b07b13ed3a7f1edddc">nvnBufferInvalidateMappedRange</a> (const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *buffer, ptrdiff_t offset, size_t size)</td></tr>
<tr class="memdesc:gaf7087d787b41f8b07b13ed3a7f1edddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate CPU caches for a range of a buffer that may have been written by the GPU.  <a href="group__nvn__c__functions.html#gaf7087d787b41f8b07b13ed3a7f1edddc">More...</a><br /></td></tr>
<tr class="separator:gaf7087d787b41f8b07b13ed3a7f1edddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3a80a57023737b594e83a9fa04282c6"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaa3a80a57023737b594e83a9fa04282c6">nvnBufferMap</a> (const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *buffer)</td></tr>
<tr class="memdesc:gaa3a80a57023737b594e83a9fa04282c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a CPU pointer to the memory of a previously created <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object.  <a href="group__nvn__c__functions.html#gaa3a80a57023737b594e83a9fa04282c6">More...</a><br /></td></tr>
<tr class="separator:gaa3a80a57023737b594e83a9fa04282c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c0027b477c987c8a8573c7d04d854b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9c0027b477c987c8a8573c7d04d854b1">nvnBufferSetDebugLabel</a> (<a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *buffer, const char *label)</td></tr>
<tr class="memdesc:ga9c0027b477c987c8a8573c7d04d854b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug label string for a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object.  <a href="group__nvn__c__functions.html#ga9c0027b477c987c8a8573c7d04d854b1">More...</a><br /></td></tr>
<tr class="separator:ga9c0027b477c987c8a8573c7d04d854b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc2b78b04c91b5deabcfaf93cdb0e36c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gacc2b78b04c91b5deabcfaf93cdb0e36c">nvnChannelMaskStateGetChannelMask</a> (const <a class="el" href="struct_n_v_nchannel_mask_state.html">NVNchannelMaskState</a> *channelMask, int index, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> *r, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> *g, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> *b, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> *a)</td></tr>
<tr class="memdesc:gacc2b78b04c91b5deabcfaf93cdb0e36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query RGBA channel masks for a single color target.  <a href="group__nvn__c__functions.html#gacc2b78b04c91b5deabcfaf93cdb0e36c">More...</a><br /></td></tr>
<tr class="separator:gacc2b78b04c91b5deabcfaf93cdb0e36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2493330ef54d576b537e2f0b1aadbf24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2493330ef54d576b537e2f0b1aadbf24">nvnChannelMaskStateSetChannelMask</a> (<a class="el" href="struct_n_v_nchannel_mask_state.html">NVNchannelMaskState</a> *channelMask, int index, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> r, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> g, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> b, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> a)</td></tr>
<tr class="memdesc:ga2493330ef54d576b537e2f0b1aadbf24"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives.">NVNprogram</a> RGBA channel masks for a single color target.  <a href="group__nvn__c__functions.html#ga2493330ef54d576b537e2f0b1aadbf24">More...</a><br /></td></tr>
<tr class="separator:ga2493330ef54d576b537e2f0b1aadbf24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc110d97cce3482f715d26e83413adfc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gafc110d97cce3482f715d26e83413adfc">nvnChannelMaskStateSetDefaults</a> (<a class="el" href="struct_n_v_nchannel_mask_state.html">NVNchannelMaskState</a> *channelMask)</td></tr>
<tr class="memdesc:gafc110d97cce3482f715d26e83413adfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_nchannel_mask_state.html" title="API state object holding per-channel write masks for all color buffers.">NVNchannelMaskState</a> object.  <a href="group__nvn__c__functions.html#gafc110d97cce3482f715d26e83413adfc">More...</a><br /></td></tr>
<tr class="separator:gafc110d97cce3482f715d26e83413adfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dd303cf6348a6e860f26da1f9219e46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#gaef30ce5d138fb99aee61e09d89d9952e">NVNalphaFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9dd303cf6348a6e860f26da1f9219e46">nvnColorStateGetAlphaTest</a> (const <a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *color)</td></tr>
<tr class="memdesc:ga9dd303cf6348a6e860f26da1f9219e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the comparison function to use for alpha testing.  <a href="group__nvn__c__functions.html#ga9dd303cf6348a6e860f26da1f9219e46">More...</a><br /></td></tr>
<tr class="separator:ga9dd303cf6348a6e860f26da1f9219e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3503d68a40da5ab574a594125f8cef2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3503d68a40da5ab574a594125f8cef2e">nvnColorStateGetBlendEnable</a> (const <a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *color, int index)</td></tr>
<tr class="memdesc:ga3503d68a40da5ab574a594125f8cef2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the blending enable for a single color target.  <a href="group__nvn__c__functions.html#ga3503d68a40da5ab574a594125f8cef2e">More...</a><br /></td></tr>
<tr class="separator:ga3503d68a40da5ab574a594125f8cef2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf55951ccbd93d23d1753d4de03d81119"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga13d92b26dc58a3c92b79e217e1d81786">NVNlogicOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf55951ccbd93d23d1753d4de03d81119">nvnColorStateGetLogicOp</a> (const <a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *color)</td></tr>
<tr class="memdesc:gaf55951ccbd93d23d1753d4de03d81119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the logical operation to perform for all color targets.  <a href="group__nvn__c__functions.html#gaf55951ccbd93d23d1753d4de03d81119">More...</a><br /></td></tr>
<tr class="separator:gaf55951ccbd93d23d1753d4de03d81119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cd9f1df52f41fef96e17bbd42facaa0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1cd9f1df52f41fef96e17bbd42facaa0">nvnColorStateSetAlphaTest</a> (<a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *color, <a class="el" href="group__nvn__c__enum.html#gaef30ce5d138fb99aee61e09d89d9952e">NVNalphaFunc</a> alphaTest)</td></tr>
<tr class="memdesc:ga1cd9f1df52f41fef96e17bbd42facaa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a comparison function to use for alpha testing.  <a href="group__nvn__c__functions.html#ga1cd9f1df52f41fef96e17bbd42facaa0">More...</a><br /></td></tr>
<tr class="separator:ga1cd9f1df52f41fef96e17bbd42facaa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47f9bc738389baa490dd5f4b0df8b527"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga47f9bc738389baa490dd5f4b0df8b527">nvnColorStateSetAlphaTest_fastpath</a> (<a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *color, <a class="el" href="group__nvn__c__enum.html#gaef30ce5d138fb99aee61e09d89d9952e">NVNalphaFunc</a> alphaTest)</td></tr>
<tr class="memdesc:ga47f9bc738389baa490dd5f4b0df8b527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a comparison function to use for alpha testing.  <a href="group__nvn__c__functions.html#ga47f9bc738389baa490dd5f4b0df8b527">More...</a><br /></td></tr>
<tr class="separator:ga47f9bc738389baa490dd5f4b0df8b527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c1c99c2ad31d66b2a6c170b8d8b324c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4c1c99c2ad31d66b2a6c170b8d8b324c">nvnColorStateSetBlendEnable</a> (<a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *color, int index, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable)</td></tr>
<tr class="memdesc:ga4c1c99c2ad31d66b2a6c170b8d8b324c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the blending enable for a single color target.  <a href="group__nvn__c__functions.html#ga4c1c99c2ad31d66b2a6c170b8d8b324c">More...</a><br /></td></tr>
<tr class="separator:ga4c1c99c2ad31d66b2a6c170b8d8b324c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b5549b5bc5384456dda61010d85b5c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1b5549b5bc5384456dda61010d85b5c2">nvnColorStateSetDefaults</a> (<a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *color)</td></tr>
<tr class="memdesc:ga1b5549b5bc5384456dda61010d85b5c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_ncolor_state.html" title="API state object controlling processing of color values.">NVNcolorState</a> object.  <a href="group__nvn__c__functions.html#ga1b5549b5bc5384456dda61010d85b5c2">More...</a><br /></td></tr>
<tr class="separator:ga1b5549b5bc5384456dda61010d85b5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34d488b77453064ee98fd042c5f8f9df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga34d488b77453064ee98fd042c5f8f9df">nvnColorStateSetLogicOp</a> (<a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *color, <a class="el" href="group__nvn__c__enum.html#ga13d92b26dc58a3c92b79e217e1d81786">NVNlogicOp</a> logicOp)</td></tr>
<tr class="memdesc:ga34d488b77453064ee98fd042c5f8f9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the logical operation to perform for all color targets.  <a href="group__nvn__c__functions.html#ga34d488b77453064ee98fd042c5f8f9df">More...</a><br /></td></tr>
<tr class="separator:ga34d488b77453064ee98fd042c5f8f9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f36048ed6077a8bb93623325cab6ee5"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3f36048ed6077a8bb93623325cab6ee5">nvnColorStateSetLogicOp_fastpath</a> (<a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *color, <a class="el" href="group__nvn__c__enum.html#ga13d92b26dc58a3c92b79e217e1d81786">NVNlogicOp</a> logicOp)</td></tr>
<tr class="memdesc:ga3f36048ed6077a8bb93623325cab6ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the logical operation to perform for all color targets.  <a href="group__nvn__c__functions.html#ga3f36048ed6077a8bb93623325cab6ee5">More...</a><br /></td></tr>
<tr class="separator:ga3f36048ed6077a8bb93623325cab6ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c0d758cfa73c25f2a34486353f46d92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2c0d758cfa73c25f2a34486353f46d92">nvnCommandBufferAddCommandMemory</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *pool, ptrdiff_t offset, size_t size)</td></tr>
<tr class="memdesc:ga2c0d758cfa73c25f2a34486353f46d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add command data memory for a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object.  <a href="group__nvn__c__functions.html#ga2c0d758cfa73c25f2a34486353f46d92">More...</a><br /></td></tr>
<tr class="separator:ga2c0d758cfa73c25f2a34486353f46d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8de6ce290ee0180d9bcd700c1d08d0bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8de6ce290ee0180d9bcd700c1d08d0bf">nvnCommandBufferAddControlMemory</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, void *memory, size_t size)</td></tr>
<tr class="memdesc:ga8de6ce290ee0180d9bcd700c1d08d0bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add control memory for a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object.  <a href="group__nvn__c__functions.html#ga8de6ce290ee0180d9bcd700c1d08d0bf">More...</a><br /></td></tr>
<tr class="separator:ga8de6ce290ee0180d9bcd700c1d08d0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8004a74da7c68a5424ac4466653dce34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8004a74da7c68a5424ac4466653dce34">nvnCommandBufferBarrier</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int barrier)</td></tr>
<tr class="memdesc:ga8004a74da7c68a5424ac4466653dce34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a barrier ordering execution of GPU commands and invalidating internal GPU caches.  <a href="group__nvn__c__functions.html#ga8004a74da7c68a5424ac4466653dce34">More...</a><br /></td></tr>
<tr class="separator:ga8004a74da7c68a5424ac4466653dce34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb763d2bdad2c058c75802190fef4748"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaeb763d2bdad2c058c75802190fef4748">nvnCommandBufferBeginRecording</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:gaeb763d2bdad2c058c75802190fef4748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin recording a new set of commands in this <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object.  <a href="group__nvn__c__functions.html#gaeb763d2bdad2c058c75802190fef4748">More...</a><br /></td></tr>
<tr class="separator:gaeb763d2bdad2c058c75802190fef4748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d414ebb37bc0583da4929b13b1259cf"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1d414ebb37bc0583da4929b13b1259cf">nvnCommandBufferBeginRecording_fastpath</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:ga1d414ebb37bc0583da4929b13b1259cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin recording a new set of commands in this <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object.  <a href="group__nvn__c__functions.html#ga1d414ebb37bc0583da4929b13b1259cf">More...</a><br /></td></tr>
<tr class="separator:ga1d414ebb37bc0583da4929b13b1259cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a5d40804e1ae718dfb71928afc6963e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8a5d40804e1ae718dfb71928afc6963e">nvnCommandBufferBeginTransformFeedback</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> buffer)</td></tr>
<tr class="memdesc:ga8a5d40804e1ae718dfb71928afc6963e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a transform feedback (stream output) operation.  <a href="group__nvn__c__functions.html#ga8a5d40804e1ae718dfb71928afc6963e">More...</a><br /></td></tr>
<tr class="separator:ga8a5d40804e1ae718dfb71928afc6963e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae567923c05099ece28c0a72f7e5a7b95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae567923c05099ece28c0a72f7e5a7b95">nvnCommandBufferBindBlendState</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, NVN_NOESCAPE const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend)</td></tr>
<tr class="memdesc:gae567923c05099ece28c0a72f7e5a7b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a new <a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object to bind for subsequent commands.  <a href="group__nvn__c__functions.html#gae567923c05099ece28c0a72f7e5a7b95">More...</a><br /></td></tr>
<tr class="separator:gae567923c05099ece28c0a72f7e5a7b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4e79d1982d0459fe3f052464d722135"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae4e79d1982d0459fe3f052464d722135">nvnCommandBufferBindChannelMaskState</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, NVN_NOESCAPE const <a class="el" href="struct_n_v_nchannel_mask_state.html">NVNchannelMaskState</a> *channelMask)</td></tr>
<tr class="memdesc:gae4e79d1982d0459fe3f052464d722135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a new <a class="el" href="struct_n_v_nchannel_mask_state.html" title="API state object holding per-channel write masks for all color buffers.">NVNchannelMaskState</a> object to bind for subsequent commands.  <a href="group__nvn__c__functions.html#gae4e79d1982d0459fe3f052464d722135">More...</a><br /></td></tr>
<tr class="separator:gae4e79d1982d0459fe3f052464d722135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43d6d532c48207186945d010043d5b44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga43d6d532c48207186945d010043d5b44">nvnCommandBufferBindColorState</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, NVN_NOESCAPE const <a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *color)</td></tr>
<tr class="memdesc:ga43d6d532c48207186945d010043d5b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a new <a class="el" href="struct_n_v_ncolor_state.html" title="API state object controlling processing of color values.">NVNcolorState</a> object to bind for subsequent commands.  <a href="group__nvn__c__functions.html#ga43d6d532c48207186945d010043d5b44">More...</a><br /></td></tr>
<tr class="separator:ga43d6d532c48207186945d010043d5b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30bc114cd2aad54bb5c54dbba0b74ce1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga30bc114cd2aad54bb5c54dbba0b74ce1">nvnCommandBufferBindCoverageModulationTable</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, NVN_NOESCAPE const float *entries)</td></tr>
<tr class="memdesc:ga30bc114cd2aad54bb5c54dbba0b74ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds or unbinds a coverage modulation table used for target-independent rasterization.  <a href="group__nvn__c__functions.html#ga30bc114cd2aad54bb5c54dbba0b74ce1">More...</a><br /></td></tr>
<tr class="separator:ga30bc114cd2aad54bb5c54dbba0b74ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38fb4b53978713545ee59f17dcbeb19f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga38fb4b53978713545ee59f17dcbeb19f">nvnCommandBufferBindDepthStencilState</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, NVN_NOESCAPE const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil)</td></tr>
<tr class="memdesc:ga38fb4b53978713545ee59f17dcbeb19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a new <a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">NVNdepthStencilState</a> object to bind for subsequent commands.  <a href="group__nvn__c__functions.html#ga38fb4b53978713545ee59f17dcbeb19f">More...</a><br /></td></tr>
<tr class="separator:ga38fb4b53978713545ee59f17dcbeb19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26915307b6b313db6e592c0b2c9a9aa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga26915307b6b313db6e592c0b2c9a9aa4">nvnCommandBufferBindImage</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int index, <a class="el" href="group__nvn__c__handle.html#gacba3c44a43c05f11bc1b88c49b118606">NVNimageHandle</a> image)</td></tr>
<tr class="memdesc:ga26915307b6b313db6e592c0b2c9a9aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> to use for image loads and stores in shaders.  <a href="group__nvn__c__functions.html#ga26915307b6b313db6e592c0b2c9a9aa4">More...</a><br /></td></tr>
<tr class="separator:ga26915307b6b313db6e592c0b2c9a9aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee09267e163c31d524cfc70ea047cafc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaee09267e163c31d524cfc70ea047cafc">nvnCommandBufferBindImages</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int first, int count, NVN_NOESCAPE const <a class="el" href="group__nvn__c__handle.html#gacba3c44a43c05f11bc1b88c49b118606">NVNimageHandle</a> *images)</td></tr>
<tr class="memdesc:gaee09267e163c31d524cfc70ea047cafc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more Textures to use for image loads and stores in shaders.  <a href="group__nvn__c__functions.html#gaee09267e163c31d524cfc70ea047cafc">More...</a><br /></td></tr>
<tr class="separator:gaee09267e163c31d524cfc70ea047cafc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7810c6547483c880bb3594e0c2e4162e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7810c6547483c880bb3594e0c2e4162e">nvnCommandBufferBindImagesDeferred</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int first, int count, const <a class="el" href="group__nvn__c__handle.html#gacba3c44a43c05f11bc1b88c49b118606">NVNimageHandle</a> *images)</td></tr>
<tr class="memdesc:ga7810c6547483c880bb3594e0c2e4162e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more Textures to use for image loads and stores in shaders.  <a href="group__nvn__c__functions.html#ga7810c6547483c880bb3594e0c2e4162e">More...</a><br /></td></tr>
<tr class="separator:ga7810c6547483c880bb3594e0c2e4162e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5ea7e3b5622fe8d512afe682890c328"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad5ea7e3b5622fe8d512afe682890c328">nvnCommandBufferBindImagesDeferred_fastpath</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int first, int count, const <a class="el" href="group__nvn__c__handle.html#gacba3c44a43c05f11bc1b88c49b118606">NVNimageHandle</a> *images)</td></tr>
<tr class="memdesc:gad5ea7e3b5622fe8d512afe682890c328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more Textures to use for image loads and stores in shaders.  <a href="group__nvn__c__functions.html#gad5ea7e3b5622fe8d512afe682890c328">More...</a><br /></td></tr>
<tr class="separator:gad5ea7e3b5622fe8d512afe682890c328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga557044ccfe0956a4a5e0accbff24680d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga557044ccfe0956a4a5e0accbff24680d">nvnCommandBufferBindMultisampleState</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, NVN_NOESCAPE const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:ga557044ccfe0956a4a5e0accbff24680d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a new <a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to bind for subsequent commands.  <a href="group__nvn__c__functions.html#ga557044ccfe0956a4a5e0accbff24680d">More...</a><br /></td></tr>
<tr class="separator:ga557044ccfe0956a4a5e0accbff24680d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4eaf64e9a465e7a751bba9a15d3b4959"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4eaf64e9a465e7a751bba9a15d3b4959">nvnCommandBufferBindPolygonState</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, NVN_NOESCAPE const <a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *polygon)</td></tr>
<tr class="memdesc:ga4eaf64e9a465e7a751bba9a15d3b4959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a new <a class="el" href="struct_n_v_npolygon_state.html" title="API state object controlling rasterization of polygons.">NVNpolygonState</a> object to bind for subsequent commands.  <a href="group__nvn__c__functions.html#ga4eaf64e9a465e7a751bba9a15d3b4959">More...</a><br /></td></tr>
<tr class="separator:ga4eaf64e9a465e7a751bba9a15d3b4959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f4b9d505338994b172c814ed32565c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1f4b9d505338994b172c814ed32565c8">nvnCommandBufferBindProgram</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *program, int stages)</td></tr>
<tr class="memdesc:ga1f4b9d505338994b172c814ed32565c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind or unbind shaders in a <a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives.">NVNprogram</a> object for subsequent rendering commands.  <a href="group__nvn__c__functions.html#ga1f4b9d505338994b172c814ed32565c8">More...</a><br /></td></tr>
<tr class="separator:ga1f4b9d505338994b172c814ed32565c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee3d37a925075c3b7309519710eba21c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaee3d37a925075c3b7309519710eba21c">nvnCommandBufferBindSeparateSampler</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int index, <a class="el" href="struct_n_v_nseparate_sampler_handle.html">NVNseparateSamplerHandle</a> samplerHandle)</td></tr>
<tr class="memdesc:gaee3d37a925075c3b7309519710eba21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a separate <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> to use for texture mapping in shaders.  <a href="group__nvn__c__functions.html#gaee3d37a925075c3b7309519710eba21c">More...</a><br /></td></tr>
<tr class="separator:gaee3d37a925075c3b7309519710eba21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ae38068201854f531108a986b081d4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1ae38068201854f531108a986b081d4b">nvnCommandBufferBindSeparateSamplers</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int first, int count, NVN_NOESCAPE const <a class="el" href="struct_n_v_nseparate_sampler_handle.html">NVNseparateSamplerHandle</a> *samplerHandles)</td></tr>
<tr class="memdesc:ga1ae38068201854f531108a986b081d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more Samplers to use for texture mapping in shaders.  <a href="group__nvn__c__functions.html#ga1ae38068201854f531108a986b081d4b">More...</a><br /></td></tr>
<tr class="separator:ga1ae38068201854f531108a986b081d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4df7161364cf51b04adbc44f41cb809"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae4df7161364cf51b04adbc44f41cb809">nvnCommandBufferBindSeparateSamplersDeferred</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int first, int count, const <a class="el" href="struct_n_v_nseparate_sampler_handle.html">NVNseparateSamplerHandle</a> *samplerHandles)</td></tr>
<tr class="memdesc:gae4df7161364cf51b04adbc44f41cb809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more Samplers to use for texture mapping in shaders.  <a href="group__nvn__c__functions.html#gae4df7161364cf51b04adbc44f41cb809">More...</a><br /></td></tr>
<tr class="separator:gae4df7161364cf51b04adbc44f41cb809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78c40fd8ad57f52512ac2f3e534edab6"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga78c40fd8ad57f52512ac2f3e534edab6">nvnCommandBufferBindSeparateSamplersDeferred_fastpath</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int first, int count, const <a class="el" href="struct_n_v_nseparate_sampler_handle.html">NVNseparateSamplerHandle</a> *samplerHandles)</td></tr>
<tr class="memdesc:ga78c40fd8ad57f52512ac2f3e534edab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more Samplers to use for texture mapping in shaders.  <a href="group__nvn__c__functions.html#ga78c40fd8ad57f52512ac2f3e534edab6">More...</a><br /></td></tr>
<tr class="separator:ga78c40fd8ad57f52512ac2f3e534edab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b5b85ce0b512e73c9d3b5ad067c3bbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9b5b85ce0b512e73c9d3b5ad067c3bbe">nvnCommandBufferBindSeparateTexture</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int index, <a class="el" href="struct_n_v_nseparate_texture_handle.html">NVNseparateTextureHandle</a> textureHandle)</td></tr>
<tr class="memdesc:ga9b5b85ce0b512e73c9d3b5ad067c3bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a separate <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> to use for texture mapping in shaders.  <a href="group__nvn__c__functions.html#ga9b5b85ce0b512e73c9d3b5ad067c3bbe">More...</a><br /></td></tr>
<tr class="separator:ga9b5b85ce0b512e73c9d3b5ad067c3bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2120b1cf857f2c687ee18530b6aef0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae2120b1cf857f2c687ee18530b6aef0e">nvnCommandBufferBindSeparateTextures</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int first, int count, NVN_NOESCAPE const <a class="el" href="struct_n_v_nseparate_texture_handle.html">NVNseparateTextureHandle</a> *textureHandles)</td></tr>
<tr class="memdesc:gae2120b1cf857f2c687ee18530b6aef0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more separate textures to use for texture mapping in shaders.  <a href="group__nvn__c__functions.html#gae2120b1cf857f2c687ee18530b6aef0e">More...</a><br /></td></tr>
<tr class="separator:gae2120b1cf857f2c687ee18530b6aef0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84c5b79a065744d3c4937123af4e17b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga84c5b79a065744d3c4937123af4e17b3">nvnCommandBufferBindSeparateTexturesDeferred</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int first, int count, const <a class="el" href="struct_n_v_nseparate_texture_handle.html">NVNseparateTextureHandle</a> *textureHandles)</td></tr>
<tr class="memdesc:ga84c5b79a065744d3c4937123af4e17b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more separate textures to use for texture mapping in shaders.  <a href="group__nvn__c__functions.html#ga84c5b79a065744d3c4937123af4e17b3">More...</a><br /></td></tr>
<tr class="separator:ga84c5b79a065744d3c4937123af4e17b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fa5a61a760f767ada6c768ba8c18a71"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9fa5a61a760f767ada6c768ba8c18a71">nvnCommandBufferBindSeparateTexturesDeferred_fastpath</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int first, int count, const <a class="el" href="struct_n_v_nseparate_texture_handle.html">NVNseparateTextureHandle</a> *textureHandles)</td></tr>
<tr class="memdesc:ga9fa5a61a760f767ada6c768ba8c18a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more separate textures to use for texture mapping in shaders.  <a href="group__nvn__c__functions.html#ga9fa5a61a760f767ada6c768ba8c18a71">More...</a><br /></td></tr>
<tr class="separator:ga9fa5a61a760f767ada6c768ba8c18a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18f58558537f39f4d427bd09c99de607"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga18f58558537f39f4d427bd09c99de607">nvnCommandBufferBindStorageBuffer</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int index, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> buffer, size_t size)</td></tr>
<tr class="memdesc:ga18f58558537f39f4d427bd09c99de607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a range of a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object to use for random-access reads and writes in shaders.  <a href="group__nvn__c__functions.html#ga18f58558537f39f4d427bd09c99de607">More...</a><br /></td></tr>
<tr class="separator:ga18f58558537f39f4d427bd09c99de607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83b106a76c4096e5a51032212c0af535"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga83b106a76c4096e5a51032212c0af535">nvnCommandBufferBindStorageBuffers</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int first, int count, NVN_NOESCAPE const <a class="el" href="struct_n_v_nbuffer_range.html">NVNbufferRange</a> *buffers)</td></tr>
<tr class="memdesc:ga83b106a76c4096e5a51032212c0af535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object ranges to use for random-access reads and writes in shaders.  <a href="group__nvn__c__functions.html#ga83b106a76c4096e5a51032212c0af535">More...</a><br /></td></tr>
<tr class="separator:ga83b106a76c4096e5a51032212c0af535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37d27bbff1e23c694944e0d876bd364b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga37d27bbff1e23c694944e0d876bd364b">nvnCommandBufferBindStorageBuffersDeferred</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int first, int count, const <a class="el" href="struct_n_v_nbuffer_range.html">NVNbufferRange</a> *buffers)</td></tr>
<tr class="memdesc:ga37d27bbff1e23c694944e0d876bd364b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object ranges to use for random-access reads and writes in shaders.  <a href="group__nvn__c__functions.html#ga37d27bbff1e23c694944e0d876bd364b">More...</a><br /></td></tr>
<tr class="separator:ga37d27bbff1e23c694944e0d876bd364b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf71383854dd30f81ddc65910f7098124"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf71383854dd30f81ddc65910f7098124">nvnCommandBufferBindStorageBuffersDeferred_fastpath</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int first, int count, const <a class="el" href="struct_n_v_nbuffer_range.html">NVNbufferRange</a> *buffers)</td></tr>
<tr class="memdesc:gaf71383854dd30f81ddc65910f7098124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object ranges to use for random-access reads and writes in shaders.  <a href="group__nvn__c__functions.html#gaf71383854dd30f81ddc65910f7098124">More...</a><br /></td></tr>
<tr class="separator:gaf71383854dd30f81ddc65910f7098124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad89eb87dde4d1dba6444ea4f8f79e66b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad89eb87dde4d1dba6444ea4f8f79e66b">nvnCommandBufferBindTexture</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int index, <a class="el" href="group__nvn__c__handle.html#gaa1a1fc7a9e690ce93870bcd71ea6b446">NVNtextureHandle</a> texture)</td></tr>
<tr class="memdesc:gad89eb87dde4d1dba6444ea4f8f79e66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a NVNtexture/NVNsampler pair to use for texture mapping in shaders.  <a href="group__nvn__c__functions.html#gad89eb87dde4d1dba6444ea4f8f79e66b">More...</a><br /></td></tr>
<tr class="separator:gad89eb87dde4d1dba6444ea4f8f79e66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga685c4d1fb926a9eff6eb658549d146e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga685c4d1fb926a9eff6eb658549d146e8">nvnCommandBufferBindTextures</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int first, int count, NVN_NOESCAPE const <a class="el" href="group__nvn__c__handle.html#gaa1a1fc7a9e690ce93870bcd71ea6b446">NVNtextureHandle</a> *textures)</td></tr>
<tr class="memdesc:ga685c4d1fb926a9eff6eb658549d146e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more NVNtexture/NVNsampler pairs to use for texture mapping in shaders.  <a href="group__nvn__c__functions.html#ga685c4d1fb926a9eff6eb658549d146e8">More...</a><br /></td></tr>
<tr class="separator:ga685c4d1fb926a9eff6eb658549d146e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac44a39a31493571990dc888d765687ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac44a39a31493571990dc888d765687ae">nvnCommandBufferBindTexturesDeferred</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int first, int count, const <a class="el" href="group__nvn__c__handle.html#gaa1a1fc7a9e690ce93870bcd71ea6b446">NVNtextureHandle</a> *textures)</td></tr>
<tr class="memdesc:gac44a39a31493571990dc888d765687ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more NVNtexture/NVNsampler pairs to use for texture mapping in shaders.  <a href="group__nvn__c__functions.html#gac44a39a31493571990dc888d765687ae">More...</a><br /></td></tr>
<tr class="separator:gac44a39a31493571990dc888d765687ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71beee9a1f2f8aae74522c05d0031e61"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga71beee9a1f2f8aae74522c05d0031e61">nvnCommandBufferBindTexturesDeferred_fastpath</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int first, int count, const <a class="el" href="group__nvn__c__handle.html#gaa1a1fc7a9e690ce93870bcd71ea6b446">NVNtextureHandle</a> *textures)</td></tr>
<tr class="memdesc:ga71beee9a1f2f8aae74522c05d0031e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more NVNtexture/NVNsampler pairs to use for texture mapping in shaders.  <a href="group__nvn__c__functions.html#ga71beee9a1f2f8aae74522c05d0031e61">More...</a><br /></td></tr>
<tr class="separator:ga71beee9a1f2f8aae74522c05d0031e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadacbd5a1b83b888949d3374015019a39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gadacbd5a1b83b888949d3374015019a39">nvnCommandBufferBindTransformFeedbackBuffer</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int index, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> buffer, size_t size)</td></tr>
<tr class="memdesc:gadacbd5a1b83b888949d3374015019a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a range of a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object to use for capturing transformed vertex data.  <a href="group__nvn__c__functions.html#gadacbd5a1b83b888949d3374015019a39">More...</a><br /></td></tr>
<tr class="separator:gadacbd5a1b83b888949d3374015019a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga882751c504e2ae17b4794d811c6b5c9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga882751c504e2ae17b4794d811c6b5c9c">nvnCommandBufferBindTransformFeedbackBuffers</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int first, int count, NVN_NOESCAPE const <a class="el" href="struct_n_v_nbuffer_range.html">NVNbufferRange</a> *buffers)</td></tr>
<tr class="memdesc:ga882751c504e2ae17b4794d811c6b5c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object ranges to use for capturing transformed vertex data.  <a href="group__nvn__c__functions.html#ga882751c504e2ae17b4794d811c6b5c9c">More...</a><br /></td></tr>
<tr class="separator:ga882751c504e2ae17b4794d811c6b5c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50631d9a85aca68db2ede52b0d13521e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga50631d9a85aca68db2ede52b0d13521e">nvnCommandBufferBindUniformBuffer</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int index, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> buffer, size_t size)</td></tr>
<tr class="memdesc:ga50631d9a85aca68db2ede52b0d13521e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a range of a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object to use for fetching shader uniform values.  <a href="group__nvn__c__functions.html#ga50631d9a85aca68db2ede52b0d13521e">More...</a><br /></td></tr>
<tr class="separator:ga50631d9a85aca68db2ede52b0d13521e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34d3c347e431f11e2b08179e95c85fb5"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga34d3c347e431f11e2b08179e95c85fb5">nvnCommandBufferBindUniformBuffer_fastpath</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int index, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> buffer, size_t size)</td></tr>
<tr class="memdesc:ga34d3c347e431f11e2b08179e95c85fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a range of a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object to use for fetching shader uniform values.  <a href="group__nvn__c__functions.html#ga34d3c347e431f11e2b08179e95c85fb5">More...</a><br /></td></tr>
<tr class="separator:ga34d3c347e431f11e2b08179e95c85fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6c5976d18967b450044eff98880ecd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac6c5976d18967b450044eff98880ecd6">nvnCommandBufferBindUniformBuffers</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int first, int count, NVN_NOESCAPE const <a class="el" href="struct_n_v_nbuffer_range.html">NVNbufferRange</a> *buffers)</td></tr>
<tr class="memdesc:gac6c5976d18967b450044eff98880ecd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object ranges to use for fetching shader uniform values.  <a href="group__nvn__c__functions.html#gac6c5976d18967b450044eff98880ecd6">More...</a><br /></td></tr>
<tr class="separator:gac6c5976d18967b450044eff98880ecd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe79df1465ac2ed717a129aaac29edfa"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gabe79df1465ac2ed717a129aaac29edfa">nvnCommandBufferBindUniformBuffers_fastpath</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int first, int count, NVN_NOESCAPE const <a class="el" href="struct_n_v_nbuffer_range.html">NVNbufferRange</a> *buffers)</td></tr>
<tr class="memdesc:gabe79df1465ac2ed717a129aaac29edfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object ranges to use for fetching shader uniform values.  <a href="group__nvn__c__functions.html#gabe79df1465ac2ed717a129aaac29edfa">More...</a><br /></td></tr>
<tr class="separator:gabe79df1465ac2ed717a129aaac29edfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14559252ced1659ed1cae3e0040eaebf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga14559252ced1659ed1cae3e0040eaebf">nvnCommandBufferBindUniformBuffersDeferred</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int first, int count, const <a class="el" href="struct_n_v_nbuffer_range.html">NVNbufferRange</a> *buffers)</td></tr>
<tr class="memdesc:ga14559252ced1659ed1cae3e0040eaebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object ranges to use for fetching shader uniform values.  <a href="group__nvn__c__functions.html#ga14559252ced1659ed1cae3e0040eaebf">More...</a><br /></td></tr>
<tr class="separator:ga14559252ced1659ed1cae3e0040eaebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37a1a7dc8cf9405bd88e6fd237812518"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga37a1a7dc8cf9405bd88e6fd237812518">nvnCommandBufferBindUniformBuffersDeferred_fastpath</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int first, int count, const <a class="el" href="struct_n_v_nbuffer_range.html">NVNbufferRange</a> *buffers)</td></tr>
<tr class="memdesc:ga37a1a7dc8cf9405bd88e6fd237812518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object ranges to use for fetching shader uniform values.  <a href="group__nvn__c__functions.html#ga37a1a7dc8cf9405bd88e6fd237812518">More...</a><br /></td></tr>
<tr class="separator:ga37a1a7dc8cf9405bd88e6fd237812518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfabe6cc1b10a74cf521ec26b8f7ee7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gacfabe6cc1b10a74cf521ec26b8f7ee7f">nvnCommandBufferBindVertexAttribState</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int numAttribs, NVN_NOESCAPE const <a class="el" href="struct_n_v_nvertex_attrib_state.html">NVNvertexAttribState</a> *attribs)</td></tr>
<tr class="memdesc:gacfabe6cc1b10a74cf521ec26b8f7ee7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a vertex attribute layout for subsequent commands.  <a href="group__nvn__c__functions.html#gacfabe6cc1b10a74cf521ec26b8f7ee7f">More...</a><br /></td></tr>
<tr class="separator:gacfabe6cc1b10a74cf521ec26b8f7ee7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga328bba22810a4467865b444d17bec8e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga328bba22810a4467865b444d17bec8e9">nvnCommandBufferBindVertexBuffer</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int index, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> buffer, size_t size)</td></tr>
<tr class="memdesc:ga328bba22810a4467865b444d17bec8e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a range of a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object to use for fetching vertex attributes.  <a href="group__nvn__c__functions.html#ga328bba22810a4467865b444d17bec8e9">More...</a><br /></td></tr>
<tr class="separator:ga328bba22810a4467865b444d17bec8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1ac45527dfdfaaf891af2d95487ac91"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad1ac45527dfdfaaf891af2d95487ac91">nvnCommandBufferBindVertexBuffer_fastpath</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int index, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> buffer, size_t size)</td></tr>
<tr class="memdesc:gad1ac45527dfdfaaf891af2d95487ac91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a range of a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object to use for fetching vertex attributes.  <a href="group__nvn__c__functions.html#gad1ac45527dfdfaaf891af2d95487ac91">More...</a><br /></td></tr>
<tr class="separator:gad1ac45527dfdfaaf891af2d95487ac91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbcfc19ae3f372f59ae4db3be11dc9e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gabbcfc19ae3f372f59ae4db3be11dc9e2">nvnCommandBufferBindVertexBuffers</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int first, int count, NVN_NOESCAPE const <a class="el" href="struct_n_v_nbuffer_range.html">NVNbufferRange</a> *buffers)</td></tr>
<tr class="memdesc:gabbcfc19ae3f372f59ae4db3be11dc9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object ranges to use for fetching vertex attributes.  <a href="group__nvn__c__functions.html#gabbcfc19ae3f372f59ae4db3be11dc9e2">More...</a><br /></td></tr>
<tr class="separator:gabbcfc19ae3f372f59ae4db3be11dc9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82c7e3c0c9fff4ebfeef4d6d118dfc1a"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga82c7e3c0c9fff4ebfeef4d6d118dfc1a">nvnCommandBufferBindVertexBuffers_fastpath</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int first, int count, NVN_NOESCAPE const <a class="el" href="struct_n_v_nbuffer_range.html">NVNbufferRange</a> *buffers)</td></tr>
<tr class="memdesc:ga82c7e3c0c9fff4ebfeef4d6d118dfc1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object ranges to use for fetching vertex attributes.  <a href="group__nvn__c__functions.html#ga82c7e3c0c9fff4ebfeef4d6d118dfc1a">More...</a><br /></td></tr>
<tr class="separator:ga82c7e3c0c9fff4ebfeef4d6d118dfc1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8667c7a6dad506aa2eb54370c67b2b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad8667c7a6dad506aa2eb54370c67b2b1">nvnCommandBufferBindVertexStreamState</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int numStreams, NVN_NOESCAPE const <a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *streams)</td></tr>
<tr class="memdesc:gad8667c7a6dad506aa2eb54370c67b2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a vertex stream layout for subsequent commands.  <a href="group__nvn__c__functions.html#gad8667c7a6dad506aa2eb54370c67b2b1">More...</a><br /></td></tr>
<tr class="separator:gad8667c7a6dad506aa2eb54370c67b2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2ce6552ebb6a5dd259aecc7a2cf53e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf2ce6552ebb6a5dd259aecc7a2cf53e4">nvnCommandBufferCallCommands</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int numCommands, NVN_NOESCAPE const <a class="el" href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a> *handles)</td></tr>
<tr class="memdesc:gaf2ce6552ebb6a5dd259aecc7a2cf53e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert calls to previously recorded command sets into the command set under construction.  <a href="group__nvn__c__functions.html#gaf2ce6552ebb6a5dd259aecc7a2cf53e4">More...</a><br /></td></tr>
<tr class="separator:gaf2ce6552ebb6a5dd259aecc7a2cf53e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c8a0ae87c2636ee5541d6c1a46c9e50"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8c8a0ae87c2636ee5541d6c1a46c9e50">nvnCommandBufferCallCommands_fastpath</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int numCommands, NVN_NOESCAPE const <a class="el" href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a> *handles)</td></tr>
<tr class="memdesc:ga8c8a0ae87c2636ee5541d6c1a46c9e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert calls to previously recorded command sets into the command set under construction.  <a href="group__nvn__c__functions.html#ga8c8a0ae87c2636ee5541d6c1a46c9e50">More...</a><br /></td></tr>
<tr class="separator:ga8c8a0ae87c2636ee5541d6c1a46c9e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0d38dd93f857f1242072e0fc1d3aa05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab0d38dd93f857f1242072e0fc1d3aa05">nvnCommandBufferClearBuffer</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> dst, size_t size, uint32_t value)</td></tr>
<tr class="memdesc:gab0d38dd93f857f1242072e0fc1d3aa05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a buffer to a 32-bit integer value.  <a href="group__nvn__c__functions.html#gab0d38dd93f857f1242072e0fc1d3aa05">More...</a><br /></td></tr>
<tr class="separator:gab0d38dd93f857f1242072e0fc1d3aa05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae891eb7519f90d437a89e3ca17cddf7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae891eb7519f90d437a89e3ca17cddf7a">nvnCommandBufferClearColor</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int index, NVN_NOESCAPE const float *color, int mask)</td></tr>
<tr class="memdesc:gae891eb7519f90d437a89e3ca17cddf7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a color buffer using floating-point clear color values.  <a href="group__nvn__c__functions.html#gae891eb7519f90d437a89e3ca17cddf7a">More...</a><br /></td></tr>
<tr class="separator:gae891eb7519f90d437a89e3ca17cddf7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga397b5f686c588f1e71e374d5b8d6276b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga397b5f686c588f1e71e374d5b8d6276b">nvnCommandBufferClearColori</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int index, NVN_NOESCAPE const int *color, int mask)</td></tr>
<tr class="memdesc:ga397b5f686c588f1e71e374d5b8d6276b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a color buffer using signed integer clear color values.  <a href="group__nvn__c__functions.html#ga397b5f686c588f1e71e374d5b8d6276b">More...</a><br /></td></tr>
<tr class="separator:ga397b5f686c588f1e71e374d5b8d6276b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9c2f476b24cd629f774c48c5f7f364d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad9c2f476b24cd629f774c48c5f7f364d">nvnCommandBufferClearColorui</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int index, NVN_NOESCAPE const uint32_t *color, int mask)</td></tr>
<tr class="memdesc:gad9c2f476b24cd629f774c48c5f7f364d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a color buffer using unsigned integer clear color values.  <a href="group__nvn__c__functions.html#gad9c2f476b24cd629f774c48c5f7f364d">More...</a><br /></td></tr>
<tr class="separator:gad9c2f476b24cd629f774c48c5f7f364d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5f7adad6751d801a89cd1101253fa85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae5f7adad6751d801a89cd1101253fa85">nvnCommandBufferClearDepthStencil</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, float depthValue, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> depthMask, int stencilValue, int stencilMask)</td></tr>
<tr class="memdesc:gae5f7adad6751d801a89cd1101253fa85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a depth/stencil buffer.  <a href="group__nvn__c__functions.html#gae5f7adad6751d801a89cd1101253fa85">More...</a><br /></td></tr>
<tr class="separator:gae5f7adad6751d801a89cd1101253fa85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa49f5f00f5245458671621105c1258b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaa49f5f00f5245458671621105c1258b9">nvnCommandBufferClearTexture</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *dstTexture, NVN_NOESCAPE const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *dstView, NVN_NOESCAPE const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *dstRegion, NVN_NOESCAPE const float *color, int mask)</td></tr>
<tr class="memdesc:gaa49f5f00f5245458671621105c1258b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a color buffer using floating point clear color values.  <a href="group__nvn__c__functions.html#gaa49f5f00f5245458671621105c1258b9">More...</a><br /></td></tr>
<tr class="separator:gaa49f5f00f5245458671621105c1258b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ba0b1e7a75abe28a3ce14d815de7509"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2ba0b1e7a75abe28a3ce14d815de7509">nvnCommandBufferClearTexturei</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *dstTexture, NVN_NOESCAPE const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *dstView, NVN_NOESCAPE const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *dstRegion, NVN_NOESCAPE const int *color, int mask)</td></tr>
<tr class="memdesc:ga2ba0b1e7a75abe28a3ce14d815de7509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a color buffer using signed integer clear color values.  <a href="group__nvn__c__functions.html#ga2ba0b1e7a75abe28a3ce14d815de7509">More...</a><br /></td></tr>
<tr class="separator:ga2ba0b1e7a75abe28a3ce14d815de7509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga468e09110c2f176ec9bda5f47284ae6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga468e09110c2f176ec9bda5f47284ae6b">nvnCommandBufferClearTextureui</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *dstTexture, NVN_NOESCAPE const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *dstView, NVN_NOESCAPE const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *dstRegion, NVN_NOESCAPE const uint32_t *color, int mask)</td></tr>
<tr class="memdesc:ga468e09110c2f176ec9bda5f47284ae6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a color buffer using unsigned integer clear color values.  <a href="group__nvn__c__functions.html#ga468e09110c2f176ec9bda5f47284ae6b">More...</a><br /></td></tr>
<tr class="separator:ga468e09110c2f176ec9bda5f47284ae6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd877eff408eaf5795b2e6affa58d2c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gafd877eff408eaf5795b2e6affa58d2c7">nvnCommandBufferCopyBufferToBuffer</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> src, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> dst, size_t size, int flags)</td></tr>
<tr class="memdesc:gafd877eff408eaf5795b2e6affa58d2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a copy of data from one <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object into another <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object.  <a href="group__nvn__c__functions.html#gafd877eff408eaf5795b2e6affa58d2c7">More...</a><br /></td></tr>
<tr class="separator:gafd877eff408eaf5795b2e6affa58d2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61bd6278e489d30dc49f054f1ea00cff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga61bd6278e489d30dc49f054f1ea00cff">nvnCommandBufferCopyBufferToTexture</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> src, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *dstTexture, NVN_NOESCAPE const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *dstView, NVN_NOESCAPE const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *dstRegion, int flags)</td></tr>
<tr class="memdesc:ga61bd6278e489d30dc49f054f1ea00cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy texture data from buffer memory into a region of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object.  <a href="group__nvn__c__functions.html#ga61bd6278e489d30dc49f054f1ea00cff">More...</a><br /></td></tr>
<tr class="separator:ga61bd6278e489d30dc49f054f1ea00cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad11b2ce112a68a88c10dedebae6cd73f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad11b2ce112a68a88c10dedebae6cd73f">nvnCommandBufferCopyCommands</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int numCommands, NVN_NOESCAPE const <a class="el" href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a> *handles)</td></tr>
<tr class="memdesc:gad11b2ce112a68a88c10dedebae6cd73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert copies of previously recorded command sets into the command set under construction.  <a href="group__nvn__c__functions.html#gad11b2ce112a68a88c10dedebae6cd73f">More...</a><br /></td></tr>
<tr class="separator:gad11b2ce112a68a88c10dedebae6cd73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad014cbb33dea53090529aafb29ecfe8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaad014cbb33dea53090529aafb29ecfe8">nvnCommandBufferCopyTextureToBuffer</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *srcTexture, NVN_NOESCAPE const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *srcView, NVN_NOESCAPE const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *srcRegion, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> dst, int flags)</td></tr>
<tr class="memdesc:gaad014cbb33dea53090529aafb29ecfe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy texture data from a region of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object into buffer memory.  <a href="group__nvn__c__functions.html#gaad014cbb33dea53090529aafb29ecfe8">More...</a><br /></td></tr>
<tr class="separator:gaad014cbb33dea53090529aafb29ecfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ff5b7b182fe231019b0927b419a799b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0ff5b7b182fe231019b0927b419a799b">nvnCommandBufferCopyTextureToTexture</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *srcTexture, NVN_NOESCAPE const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *srcView, NVN_NOESCAPE const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *srcRegion, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *dstTexture, NVN_NOESCAPE const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *dstView, NVN_NOESCAPE const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *dstRegion, int flags)</td></tr>
<tr class="memdesc:ga0ff5b7b182fe231019b0927b419a799b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy texture data from a region of one <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object into a region of another <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object.  <a href="group__nvn__c__functions.html#ga0ff5b7b182fe231019b0927b419a799b">More...</a><br /></td></tr>
<tr class="separator:ga0ff5b7b182fe231019b0927b419a799b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae319235f09374fb2e5968d09cfbba7f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae319235f09374fb2e5968d09cfbba7f7">nvnCommandBufferDiscardColor</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int index)</td></tr>
<tr class="memdesc:gae319235f09374fb2e5968d09cfbba7f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discard the contents of the specified bound color render target.  <a href="group__nvn__c__functions.html#gae319235f09374fb2e5968d09cfbba7f7">More...</a><br /></td></tr>
<tr class="separator:gae319235f09374fb2e5968d09cfbba7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga883170655ee34cb170ebe9475679c946"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga883170655ee34cb170ebe9475679c946">nvnCommandBufferDiscardDepthStencil</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:ga883170655ee34cb170ebe9475679c946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discard the contents of the currently bound depth/stencil render target.  <a href="group__nvn__c__functions.html#ga883170655ee34cb170ebe9475679c946">More...</a><br /></td></tr>
<tr class="separator:ga883170655ee34cb170ebe9475679c946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1e19b7700460afce5817b7c9d7bee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga32b1e19b7700460afce5817b7c9d7bee">nvnCommandBufferDispatchCompute</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int groupsX, int groupsY, int groupsZ)</td></tr>
<tr class="memdesc:ga32b1e19b7700460afce5817b7c9d7bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch a new grid of compute shader work groups for processing.  <a href="group__nvn__c__functions.html#ga32b1e19b7700460afce5817b7c9d7bee">More...</a><br /></td></tr>
<tr class="separator:ga32b1e19b7700460afce5817b7c9d7bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa16fbe913a0dc193ff71d835abcf404"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gafa16fbe913a0dc193ff71d835abcf404">nvnCommandBufferDispatchComputeIndirect</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> indirectBuffer)</td></tr>
<tr class="memdesc:gafa16fbe913a0dc193ff71d835abcf404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch a new grid of compute shader work groups for processing.  <a href="group__nvn__c__functions.html#gafa16fbe913a0dc193ff71d835abcf404">More...</a><br /></td></tr>
<tr class="separator:gafa16fbe913a0dc193ff71d835abcf404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd85afea943735121bd9ce1755d65623"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gadd85afea943735121bd9ce1755d65623">nvnCommandBufferDownsample</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *src, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *dst)</td></tr>
<tr class="memdesc:gadd85afea943735121bd9ce1755d65623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a filtered version of a multisample source texture to produce a single-sample destination texture.  <a href="group__nvn__c__functions.html#gadd85afea943735121bd9ce1755d65623">More...</a><br /></td></tr>
<tr class="separator:gadd85afea943735121bd9ce1755d65623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga800eedcf58d0e3deff9b0c2a47fc5e29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga800eedcf58d0e3deff9b0c2a47fc5e29">nvnCommandBufferDownsampleTextureView</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *src, NVN_NOESCAPE const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *srcView, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *dst, NVN_NOESCAPE const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *dstView)</td></tr>
<tr class="memdesc:ga800eedcf58d0e3deff9b0c2a47fc5e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a filtered version of a multisample source texture and texture view to produce a single-sample destination texture through a texture view.  <a href="group__nvn__c__functions.html#ga800eedcf58d0e3deff9b0c2a47fc5e29">More...</a><br /></td></tr>
<tr class="separator:ga800eedcf58d0e3deff9b0c2a47fc5e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a1a1002239aa2f5f61e79308c99a84a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7a1a1002239aa2f5f61e79308c99a84a">nvnCommandBufferDrawArrays</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a> mode, int first, int count)</td></tr>
<tr class="memdesc:ga7a1a1002239aa2f5f61e79308c99a84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render a primitive with consecutive vertex indices.  <a href="group__nvn__c__functions.html#ga7a1a1002239aa2f5f61e79308c99a84a">More...</a><br /></td></tr>
<tr class="separator:ga7a1a1002239aa2f5f61e79308c99a84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7266e9a35bb52a07df08a09333b1e2e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7266e9a35bb52a07df08a09333b1e2e8">nvnCommandBufferDrawArraysIndirect</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a> mode, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> indirectBuffer)</td></tr>
<tr class="memdesc:ga7266e9a35bb52a07df08a09333b1e2e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render primitives with consecutive vertex indices, using draw parameters fetched from an indirect data buffer.  <a href="group__nvn__c__functions.html#ga7266e9a35bb52a07df08a09333b1e2e8">More...</a><br /></td></tr>
<tr class="separator:ga7266e9a35bb52a07df08a09333b1e2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga990fb401259b83e26716733dd581d5d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga990fb401259b83e26716733dd581d5d8">nvnCommandBufferDrawArraysInstanced</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a> mode, int first, int count, int baseInstance, int instanceCount)</td></tr>
<tr class="memdesc:ga990fb401259b83e26716733dd581d5d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render multiple copies (instances) of a primitive with consecutive vertex indices.  <a href="group__nvn__c__functions.html#ga990fb401259b83e26716733dd581d5d8">More...</a><br /></td></tr>
<tr class="separator:ga990fb401259b83e26716733dd581d5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06f4d4765bf74d01809661766ac7df80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga06f4d4765bf74d01809661766ac7df80">nvnCommandBufferDrawElements</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a> mode, <a class="el" href="group__nvn__c__enum.html#gaaf90e0c2dbdc1e42db8192f0c0cb1522">NVNindexType</a> type, int count, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> indexBuffer)</td></tr>
<tr class="memdesc:ga06f4d4765bf74d01809661766ac7df80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render a primitive with vertex indices fetched from an index buffer.  <a href="group__nvn__c__functions.html#ga06f4d4765bf74d01809661766ac7df80">More...</a><br /></td></tr>
<tr class="separator:ga06f4d4765bf74d01809661766ac7df80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7310dac6860cdf877465adb7ad8e5b5"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae7310dac6860cdf877465adb7ad8e5b5">nvnCommandBufferDrawElements_fastpath</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a> mode, <a class="el" href="group__nvn__c__enum.html#gaaf90e0c2dbdc1e42db8192f0c0cb1522">NVNindexType</a> type, int count, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> indexBuffer)</td></tr>
<tr class="memdesc:gae7310dac6860cdf877465adb7ad8e5b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render a primitive with vertex indices fetched from an index buffer.  <a href="group__nvn__c__functions.html#gae7310dac6860cdf877465adb7ad8e5b5">More...</a><br /></td></tr>
<tr class="separator:gae7310dac6860cdf877465adb7ad8e5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24c189bbc5765d6e8e7c862156417baf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga24c189bbc5765d6e8e7c862156417baf">nvnCommandBufferDrawElementsBaseVertex</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a> mode, <a class="el" href="group__nvn__c__enum.html#gaaf90e0c2dbdc1e42db8192f0c0cb1522">NVNindexType</a> type, int count, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> indexBuffer, int baseVertex)</td></tr>
<tr class="memdesc:ga24c189bbc5765d6e8e7c862156417baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render a primitive with vertex indices fetched from an index buffer, with a base vertex value added to each fetched index.  <a href="group__nvn__c__functions.html#ga24c189bbc5765d6e8e7c862156417baf">More...</a><br /></td></tr>
<tr class="separator:ga24c189bbc5765d6e8e7c862156417baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ea4fb762b38faa6bce7d27c075011e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0ea4fb762b38faa6bce7d27c075011e4">nvnCommandBufferDrawElementsIndirect</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a> mode, <a class="el" href="group__nvn__c__enum.html#gaaf90e0c2dbdc1e42db8192f0c0cb1522">NVNindexType</a> type, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> indexBuffer, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> indirectBuffer)</td></tr>
<tr class="memdesc:ga0ea4fb762b38faa6bce7d27c075011e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render primitives with vertex indices fetched from an index buffer, using draw parameters fetched from an indirect data buffer.  <a href="group__nvn__c__functions.html#ga0ea4fb762b38faa6bce7d27c075011e4">More...</a><br /></td></tr>
<tr class="separator:ga0ea4fb762b38faa6bce7d27c075011e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe27aeb078f485947d4c4454182c8fde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gabe27aeb078f485947d4c4454182c8fde">nvnCommandBufferDrawElementsInstanced</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a> mode, <a class="el" href="group__nvn__c__enum.html#gaaf90e0c2dbdc1e42db8192f0c0cb1522">NVNindexType</a> type, int count, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> indexBuffer, int baseVertex, int baseInstance, int instanceCount)</td></tr>
<tr class="memdesc:gabe27aeb078f485947d4c4454182c8fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render multiple copies (instances) of a primitive with vertex indices fetched from an index buffer.  <a href="group__nvn__c__functions.html#gabe27aeb078f485947d4c4454182c8fde">More...</a><br /></td></tr>
<tr class="separator:gabe27aeb078f485947d4c4454182c8fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01170f44ca8ae6f10aa10ad7fdefbfe0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga01170f44ca8ae6f10aa10ad7fdefbfe0">nvnCommandBufferDrawTexture</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__handle.html#gaa1a1fc7a9e690ce93870bcd71ea6b446">NVNtextureHandle</a> texture, NVN_NOESCAPE const <a class="el" href="struct_n_v_ndraw_texture_region.html">NVNdrawTextureRegion</a> *dstRegion, NVN_NOESCAPE const <a class="el" href="struct_n_v_ndraw_texture_region.html">NVNdrawTextureRegion</a> *srcRegion)</td></tr>
<tr class="memdesc:ga01170f44ca8ae6f10aa10ad7fdefbfe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws an on-screen rectangle displaying the contents of a provided texture.  <a href="group__nvn__c__functions.html#ga01170f44ca8ae6f10aa10ad7fdefbfe0">More...</a><br /></td></tr>
<tr class="separator:ga01170f44ca8ae6f10aa10ad7fdefbfe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c7d4cceeb20e66d10503c868a05a99d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0c7d4cceeb20e66d10503c868a05a99d">nvnCommandBufferDrawTransformFeedback</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a> mode, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> buffer)</td></tr>
<tr class="memdesc:ga0c7d4cceeb20e66d10503c868a05a99d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw primitives captured in a previous transform feedback (stream output) operation.  <a href="group__nvn__c__functions.html#ga0c7d4cceeb20e66d10503c868a05a99d">More...</a><br /></td></tr>
<tr class="separator:ga0c7d4cceeb20e66d10503c868a05a99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d97d4cbf72259b6e867f3080f223b95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7d97d4cbf72259b6e867f3080f223b95">nvnCommandBufferEndRecording</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:ga7d97d4cbf72259b6e867f3080f223b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete recording a new set of commands in this <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object.  <a href="group__nvn__c__functions.html#ga7d97d4cbf72259b6e867f3080f223b95">More...</a><br /></td></tr>
<tr class="separator:ga7d97d4cbf72259b6e867f3080f223b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1f8deb2cc863867218ce25789684809"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaa1f8deb2cc863867218ce25789684809">nvnCommandBufferEndTransformFeedback</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> buffer)</td></tr>
<tr class="memdesc:gaa1f8deb2cc863867218ce25789684809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete a transform feedback (stream output) operation.  <a href="group__nvn__c__functions.html#gaa1f8deb2cc863867218ce25789684809">More...</a><br /></td></tr>
<tr class="separator:gaa1f8deb2cc863867218ce25789684809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7649fa38fde42a6fc9ec32b1133d5528"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7649fa38fde42a6fc9ec32b1133d5528">nvnCommandBufferFenceSync</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="struct_n_v_nsync.html">NVNsync</a> *sync, <a class="el" href="group__nvn__c__enum.html#ga6ab26a343b68da722799167ea97ec69d">NVNsyncCondition</a> condition, int flags)</td></tr>
<tr class="memdesc:ga7649fa38fde42a6fc9ec32b1133d5528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object as signaled when all previous commands have completed in the <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object.  <a href="group__nvn__c__functions.html#ga7649fa38fde42a6fc9ec32b1133d5528">More...</a><br /></td></tr>
<tr class="separator:ga7649fa38fde42a6fc9ec32b1133d5528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga014c41d2335d4d9ff6c776c99bc70bfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga014c41d2335d4d9ff6c776c99bc70bfb">nvnCommandBufferFinalize</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:ga014c41d2335d4d9ff6c776c99bc70bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object.  <a href="group__nvn__c__functions.html#ga014c41d2335d4d9ff6c776c99bc70bfb">More...</a><br /></td></tr>
<tr class="separator:ga014c41d2335d4d9ff6c776c99bc70bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga211e559b84b562b34d26b809a9316ff2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga211e559b84b562b34d26b809a9316ff2">nvnCommandBufferGetCommandMemoryFree</a> (const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:ga211e559b84b562b34d26b809a9316ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unused size in bytes of the command memory block that was lastly added to the <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a>.  <a href="group__nvn__c__functions.html#ga211e559b84b562b34d26b809a9316ff2">More...</a><br /></td></tr>
<tr class="separator:ga211e559b84b562b34d26b809a9316ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c33bb9cd401c44be336bdcb915d9e70"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7c33bb9cd401c44be336bdcb915d9e70">nvnCommandBufferGetCommandMemorySize</a> (const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:ga7c33bb9cd401c44be336bdcb915d9e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total size in bytes of the command memory block that was lastly added to the <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a>.  <a href="group__nvn__c__functions.html#ga7c33bb9cd401c44be336bdcb915d9e70">More...</a><br /></td></tr>
<tr class="separator:ga7c33bb9cd401c44be336bdcb915d9e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7976af012dd82485da7127beca93e2ff"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7976af012dd82485da7127beca93e2ff">nvnCommandBufferGetCommandMemoryUsed</a> (const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:ga7976af012dd82485da7127beca93e2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the used size in bytes of the command memory block that was lastly added to the <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a>.  <a href="group__nvn__c__functions.html#ga7976af012dd82485da7127beca93e2ff">More...</a><br /></td></tr>
<tr class="separator:ga7976af012dd82485da7127beca93e2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fe9b2e839389d1a7396b54edb86ca77"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3fe9b2e839389d1a7396b54edb86ca77">nvnCommandBufferGetControlMemoryFree</a> (const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:ga3fe9b2e839389d1a7396b54edb86ca77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unused size in bytes of the control memory block that was lastly added to the <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a>.  <a href="group__nvn__c__functions.html#ga3fe9b2e839389d1a7396b54edb86ca77">More...</a><br /></td></tr>
<tr class="separator:ga3fe9b2e839389d1a7396b54edb86ca77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93c82ac4fededbf48d55179b57248de7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga93c82ac4fededbf48d55179b57248de7">nvnCommandBufferGetControlMemorySize</a> (const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:ga93c82ac4fededbf48d55179b57248de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total size in bytes of the control memory block that was lastly added to the <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a>.  <a href="group__nvn__c__functions.html#ga93c82ac4fededbf48d55179b57248de7">More...</a><br /></td></tr>
<tr class="separator:ga93c82ac4fededbf48d55179b57248de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef36338c2d889d846bf1fbbe3efd25df"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaef36338c2d889d846bf1fbbe3efd25df">nvnCommandBufferGetControlMemoryUsed</a> (const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:gaef36338c2d889d846bf1fbbe3efd25df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the used size in bytes of the control memory block that was lastly added to the <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a>.  <a href="group__nvn__c__functions.html#gaef36338c2d889d846bf1fbbe3efd25df">More...</a><br /></td></tr>
<tr class="separator:gaef36338c2d889d846bf1fbbe3efd25df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72e2b27a9a418f0eb48b0675c47809b4"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga72e2b27a9a418f0eb48b0675c47809b4">nvnCommandBufferGetCopyImageStride</a> (const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:ga72e2b27a9a418f0eb48b0675c47809b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current copy image stride stored in a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object.  <a href="group__nvn__c__functions.html#ga72e2b27a9a418f0eb48b0675c47809b4">More...</a><br /></td></tr>
<tr class="separator:ga72e2b27a9a418f0eb48b0675c47809b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca29ca51ef0664b03280efdcc1e36323"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaca29ca51ef0664b03280efdcc1e36323">nvnCommandBufferGetCopyRowStride</a> (const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:gaca29ca51ef0664b03280efdcc1e36323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current copy row stride stored in a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object.  <a href="group__nvn__c__functions.html#gaca29ca51ef0664b03280efdcc1e36323">More...</a><br /></td></tr>
<tr class="separator:gaca29ca51ef0664b03280efdcc1e36323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b241dbc3db41646a27cf4fe10ef3538"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__funcptrs.html#gac2d9ed5522cd4167d6a59f16d379bb1c">PFNNVNCOMMANDBUFFERMEMORYCALLBACKPROC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1b241dbc3db41646a27cf4fe10ef3538">nvnCommandBufferGetMemoryCallback</a> (const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:ga1b241dbc3db41646a27cf4fe10ef3538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query a callback function for a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object that will be called if it runs out of memory.  <a href="group__nvn__c__functions.html#ga1b241dbc3db41646a27cf4fe10ef3538">More...</a><br /></td></tr>
<tr class="separator:ga1b241dbc3db41646a27cf4fe10ef3538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf726c18072c4b8ece85794276cfd991"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaaf726c18072c4b8ece85794276cfd991">nvnCommandBufferGetMemoryCallbackData</a> (const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:gaaf726c18072c4b8ece85794276cfd991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query a generic pointer that will be passed to a callback function if the command buffer runs out of memory.  <a href="group__nvn__c__functions.html#gaaf726c18072c4b8ece85794276cfd991">More...</a><br /></td></tr>
<tr class="separator:gaaf726c18072c4b8ece85794276cfd991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab146b70a699dfee69d0724e430d5694e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab146b70a699dfee69d0724e430d5694e">nvnCommandBufferInitialize</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device)</td></tr>
<tr class="memdesc:gab146b70a699dfee69d0724e430d5694e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object for the specified device.  <a href="group__nvn__c__functions.html#gab146b70a699dfee69d0724e430d5694e">More...</a><br /></td></tr>
<tr class="separator:gab146b70a699dfee69d0724e430d5694e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga471e3ef75091f5d2c42b680694efcbff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga471e3ef75091f5d2c42b680694efcbff">nvnCommandBufferInsertCheckpointDynamic</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, NVN_NOESCAPE const void *markerData, size_t markerDataSize)</td></tr>
<tr class="memdesc:ga471e3ef75091f5d2c42b680694efcbff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a checkpoint event marker to the command set.  <a href="group__nvn__c__functions.html#ga471e3ef75091f5d2c42b680694efcbff">More...</a><br /></td></tr>
<tr class="separator:ga471e3ef75091f5d2c42b680694efcbff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27b79a7f5a59ef54146d7bd76fdbb3b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga27b79a7f5a59ef54146d7bd76fdbb3b2">nvnCommandBufferInsertCheckpointStatic</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const void *markerData, size_t markerDataSize)</td></tr>
<tr class="memdesc:ga27b79a7f5a59ef54146d7bd76fdbb3b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a checkpoint event marker to the command set.  <a href="group__nvn__c__functions.html#ga27b79a7f5a59ef54146d7bd76fdbb3b2">More...</a><br /></td></tr>
<tr class="separator:ga27b79a7f5a59ef54146d7bd76fdbb3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d91848e0c99bad0ca343ba3710278e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4d91848e0c99bad0ca343ba3710278e0">nvnCommandBufferInsertDebugMarker</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const char *description)</td></tr>
<tr class="memdesc:ga4d91848e0c99bad0ca343ba3710278e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a debug event marker to the command stream.  <a href="group__nvn__c__functions.html#ga4d91848e0c99bad0ca343ba3710278e0">More...</a><br /></td></tr>
<tr class="separator:ga4d91848e0c99bad0ca343ba3710278e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3df18b5df1b162e23c2315f19f45a936"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3df18b5df1b162e23c2315f19f45a936">nvnCommandBufferInsertDebugMarkerDynamic</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, uint32_t domainId, NVN_NOESCAPE const char *description)</td></tr>
<tr class="memdesc:ga3df18b5df1b162e23c2315f19f45a936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a debug event marker to the command stream.  <a href="group__nvn__c__functions.html#ga3df18b5df1b162e23c2315f19f45a936">More...</a><br /></td></tr>
<tr class="separator:ga3df18b5df1b162e23c2315f19f45a936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68f148606bec51c995b3b86f851c5b09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga68f148606bec51c995b3b86f851c5b09">nvnCommandBufferInsertDebugMarkerStatic</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, uint32_t domainId, const char *description)</td></tr>
<tr class="memdesc:ga68f148606bec51c995b3b86f851c5b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a debug event marker to the command stream.  <a href="group__nvn__c__functions.html#ga68f148606bec51c995b3b86f851c5b09">More...</a><br /></td></tr>
<tr class="separator:ga68f148606bec51c995b3b86f851c5b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0790bc37a5893867aa5258dfbfe7923"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf0790bc37a5893867aa5258dfbfe7923">nvnCommandBufferIsRecording</a> (const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:gaf0790bc37a5893867aa5258dfbfe7923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the command buffer is currently recording.  <a href="group__nvn__c__functions.html#gaf0790bc37a5893867aa5258dfbfe7923">More...</a><br /></td></tr>
<tr class="separator:gaf0790bc37a5893867aa5258dfbfe7923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06413e93f9e3d29a45fa878540947a8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga06413e93f9e3d29a45fa878540947a8f">nvnCommandBufferMultiDrawArraysIndirectCount</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a> mode, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> indirectBuffer, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> parameterBuffer, int maxDrawCount, ptrdiff_t stride)</td></tr>
<tr class="memdesc:ga06413e93f9e3d29a45fa878540947a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render multiple primitives with vertices fetched from a vertex buffer, using draw parameters fetched from an indirect data buffer and the number of primitives fetched from a parameter buffer.  <a href="group__nvn__c__functions.html#ga06413e93f9e3d29a45fa878540947a8f">More...</a><br /></td></tr>
<tr class="separator:ga06413e93f9e3d29a45fa878540947a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga181160adcfe4ed4870196d02ff457a72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga181160adcfe4ed4870196d02ff457a72">nvnCommandBufferMultiDrawElementsIndirectCount</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a> mode, <a class="el" href="group__nvn__c__enum.html#gaaf90e0c2dbdc1e42db8192f0c0cb1522">NVNindexType</a> type, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> indexBuffer, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> indirectBuffer, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> parameterBuffer, int maxDrawCount, ptrdiff_t stride)</td></tr>
<tr class="memdesc:ga181160adcfe4ed4870196d02ff457a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render multiple primitives with vertex indices fetched from an index buffer, using draw parameters fetched from an indirect data buffer and the number of primitives fetched from a parameter buffer.  <a href="group__nvn__c__functions.html#ga181160adcfe4ed4870196d02ff457a72">More...</a><br /></td></tr>
<tr class="separator:ga181160adcfe4ed4870196d02ff457a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8510eb82e5aa827f42b527aac457d94e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8510eb82e5aa827f42b527aac457d94e">nvnCommandBufferOverrideSubtileSize</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> override, int subtileSize)</td></tr>
<tr class="memdesc:ga8510eb82e5aa827f42b527aac457d94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override the default number of fragment shader warps in a single subtile.  <a href="group__nvn__c__functions.html#ga8510eb82e5aa827f42b527aac457d94e">More...</a><br /></td></tr>
<tr class="separator:ga8510eb82e5aa827f42b527aac457d94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36606b1759b3b79a8844de9ff4072b49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga36606b1759b3b79a8844de9ff4072b49">nvnCommandBufferPauseTransformFeedback</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> buffer)</td></tr>
<tr class="memdesc:ga36606b1759b3b79a8844de9ff4072b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause a transform feedback (stream output) operation.  <a href="group__nvn__c__functions.html#ga36606b1759b3b79a8844de9ff4072b49">More...</a><br /></td></tr>
<tr class="separator:ga36606b1759b3b79a8844de9ff4072b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e093d931066afbd07f7dc62f728a1d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9e093d931066afbd07f7dc62f728a1d3">nvnCommandBufferPopDebugGroup</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:ga9e093d931066afbd07f7dc62f728a1d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops the active debug group off the command stream.  <a href="group__nvn__c__functions.html#ga9e093d931066afbd07f7dc62f728a1d3">More...</a><br /></td></tr>
<tr class="separator:ga9e093d931066afbd07f7dc62f728a1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9a3654de302a8d7725d78a793f47571"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab9a3654de302a8d7725d78a793f47571">nvnCommandBufferPopDebugGroupId</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, uint32_t domainId)</td></tr>
<tr class="memdesc:gab9a3654de302a8d7725d78a793f47571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops the active debug group off the command stream.  <a href="group__nvn__c__functions.html#gab9a3654de302a8d7725d78a793f47571">More...</a><br /></td></tr>
<tr class="separator:gab9a3654de302a8d7725d78a793f47571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac328ee49a5aecdaf097da8d156837955"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac328ee49a5aecdaf097da8d156837955">nvnCommandBufferPushDebugGroup</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const char *description)</td></tr>
<tr class="memdesc:gac328ee49a5aecdaf097da8d156837955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a debug group into the command stream.  <a href="group__nvn__c__functions.html#gac328ee49a5aecdaf097da8d156837955">More...</a><br /></td></tr>
<tr class="separator:gac328ee49a5aecdaf097da8d156837955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac103cf83c2d69ae2c1bfd49ba0fd41d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac103cf83c2d69ae2c1bfd49ba0fd41d5">nvnCommandBufferPushDebugGroupDynamic</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, uint32_t domainId, NVN_NOESCAPE const char *description)</td></tr>
<tr class="memdesc:gac103cf83c2d69ae2c1bfd49ba0fd41d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a debug group into the command stream.  <a href="group__nvn__c__functions.html#gac103cf83c2d69ae2c1bfd49ba0fd41d5">More...</a><br /></td></tr>
<tr class="separator:gac103cf83c2d69ae2c1bfd49ba0fd41d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54bb644ef7005a664579254b47587c93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga54bb644ef7005a664579254b47587c93">nvnCommandBufferPushDebugGroupStatic</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, uint32_t domainId, const char *description)</td></tr>
<tr class="memdesc:ga54bb644ef7005a664579254b47587c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a debug group into the command stream.  <a href="group__nvn__c__functions.html#ga54bb644ef7005a664579254b47587c93">More...</a><br /></td></tr>
<tr class="separator:ga54bb644ef7005a664579254b47587c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade6b81268dfab6d9e22de06bbd170951"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gade6b81268dfab6d9e22de06bbd170951">nvnCommandBufferReportCounter</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#ga280033bdac9f8e19de62817c8d200773">NVNcounterType</a> counter, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> buffer)</td></tr>
<tr class="memdesc:gade6b81268dfab6d9e22de06bbd170951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a GPU counter and timestamp into buffer object memory.  <a href="group__nvn__c__functions.html#gade6b81268dfab6d9e22de06bbd170951">More...</a><br /></td></tr>
<tr class="separator:gade6b81268dfab6d9e22de06bbd170951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9642c6dc30a8a0f71464a7de155c0f2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9642c6dc30a8a0f71464a7de155c0f2e">nvnCommandBufferReportValue</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, uint32_t value, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> buffer)</td></tr>
<tr class="memdesc:ga9642c6dc30a8a0f71464a7de155c0f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a GPU counter report and timestamp into buffer object memory using an application-provided value.  <a href="group__nvn__c__functions.html#ga9642c6dc30a8a0f71464a7de155c0f2e">More...</a><br /></td></tr>
<tr class="separator:ga9642c6dc30a8a0f71464a7de155c0f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49ee8eb6d0cecd901d9de38d983ceb1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga49ee8eb6d0cecd901d9de38d983ceb1a">nvnCommandBufferResetCounter</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#ga280033bdac9f8e19de62817c8d200773">NVNcounterType</a> counter)</td></tr>
<tr class="memdesc:ga49ee8eb6d0cecd901d9de38d983ceb1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset a GPU counter to zero.  <a href="group__nvn__c__functions.html#ga49ee8eb6d0cecd901d9de38d983ceb1a">More...</a><br /></td></tr>
<tr class="separator:ga49ee8eb6d0cecd901d9de38d983ceb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f474458657c1fea18b88dd48777b581"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2f474458657c1fea18b88dd48777b581">nvnCommandBufferResolveDepthBuffer</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:ga2f474458657c1fea18b88dd48777b581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve depth values in a compressible depth render target.  <a href="group__nvn__c__functions.html#ga2f474458657c1fea18b88dd48777b581">More...</a><br /></td></tr>
<tr class="separator:ga2f474458657c1fea18b88dd48777b581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6f7056d3e1f5a0c04ebfb301bf26a22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad6f7056d3e1f5a0c04ebfb301bf26a22">nvnCommandBufferRestoreZCullData</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> src, size_t size)</td></tr>
<tr class="memdesc:gad6f7056d3e1f5a0c04ebfb301bf26a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the current ZCull state to use saved state from a previous render target.  <a href="group__nvn__c__functions.html#gad6f7056d3e1f5a0c04ebfb301bf26a22">More...</a><br /></td></tr>
<tr class="separator:gad6f7056d3e1f5a0c04ebfb301bf26a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ad2246e89cf77b1a4cf41c38ff43527"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3ad2246e89cf77b1a4cf41c38ff43527">nvnCommandBufferResumeTransformFeedback</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> buffer)</td></tr>
<tr class="memdesc:ga3ad2246e89cf77b1a4cf41c38ff43527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume a transform feedback (stream output) operation.  <a href="group__nvn__c__functions.html#ga3ad2246e89cf77b1a4cf41c38ff43527">More...</a><br /></td></tr>
<tr class="separator:ga3ad2246e89cf77b1a4cf41c38ff43527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf22d0bc677beea73eac74721ddfb325"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaaf22d0bc677beea73eac74721ddfb325">nvnCommandBufferSaveZCullData</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> dst, size_t size)</td></tr>
<tr class="memdesc:gaaf22d0bc677beea73eac74721ddfb325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the current ZCull state for the current depth render target.  <a href="group__nvn__c__functions.html#gaaf22d0bc677beea73eac74721ddfb325">More...</a><br /></td></tr>
<tr class="separator:gaaf22d0bc677beea73eac74721ddfb325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab298722737de06614902b5e15ffadea6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab298722737de06614902b5e15ffadea6">nvnCommandBufferSetAlphaRef</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, float ref)</td></tr>
<tr class="memdesc:gab298722737de06614902b5e15ffadea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a reference value to use for alpha testing.  <a href="group__nvn__c__functions.html#gab298722737de06614902b5e15ffadea6">More...</a><br /></td></tr>
<tr class="separator:gab298722737de06614902b5e15ffadea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a8731d746a400b1cb433971c1091bd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga5a8731d746a400b1cb433971c1091bd6">nvnCommandBufferSetBlendColor</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, NVN_NOESCAPE const float *blendColor)</td></tr>
<tr class="memdesc:ga5a8731d746a400b1cb433971c1091bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a constant color that may be used by blending functions.  <a href="group__nvn__c__functions.html#ga5a8731d746a400b1cb433971c1091bd6">More...</a><br /></td></tr>
<tr class="separator:ga5a8731d746a400b1cb433971c1091bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41c02cd9b5c931fd6b233b48ca245daa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga41c02cd9b5c931fd6b233b48ca245daa">nvnCommandBufferSetColorReductionEnable</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable)</td></tr>
<tr class="memdesc:ga41c02cd9b5c931fd6b233b48ca245daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable lossy color reduction.  <a href="group__nvn__c__functions.html#ga41c02cd9b5c931fd6b233b48ca245daa">More...</a><br /></td></tr>
<tr class="separator:ga41c02cd9b5c931fd6b233b48ca245daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75a746908aa8a2688d6269f5441bf758"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga75a746908aa8a2688d6269f5441bf758">nvnCommandBufferSetColorReductionThresholds</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac983c7ec7de25e7b97dacc14b163b5a5">NVNformatClass</a> formatClass, int thresholdConservative, int thresholdAggressive)</td></tr>
<tr class="memdesc:ga75a746908aa8a2688d6269f5441bf758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify new lossy color reduction thresholds for a format class.  <a href="group__nvn__c__functions.html#ga75a746908aa8a2688d6269f5441bf758">More...</a><br /></td></tr>
<tr class="separator:ga75a746908aa8a2688d6269f5441bf758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad359cbb0a01f7d1cb280166880155ae0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad359cbb0a01f7d1cb280166880155ae0">nvnCommandBufferSetCommandMemoryCallbackEnabled</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enabled)</td></tr>
<tr class="memdesc:gad359cbb0a01f7d1cb280166880155ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the memory callback when out of command memory.  <a href="group__nvn__c__functions.html#gad359cbb0a01f7d1cb280166880155ae0">More...</a><br /></td></tr>
<tr class="separator:gad359cbb0a01f7d1cb280166880155ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95e185dafd114395bdc8d8111f3511ef"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga95e185dafd114395bdc8d8111f3511ef">nvnCommandBufferSetCommandMemoryCallbackEnabled_fastpath</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enabled)</td></tr>
<tr class="memdesc:ga95e185dafd114395bdc8d8111f3511ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the memory callback when out of command memory.  <a href="group__nvn__c__functions.html#ga95e185dafd114395bdc8d8111f3511ef">More...</a><br /></td></tr>
<tr class="separator:ga95e185dafd114395bdc8d8111f3511ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaced655069ef6e505fddd493fb0d33606"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaced655069ef6e505fddd493fb0d33606">nvnCommandBufferSetConservativeRasterDilate</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, float dilate)</td></tr>
<tr class="memdesc:gaced655069ef6e505fddd493fb0d33606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the degree of primitive dilation when conservative rasterization is enabled.  <a href="group__nvn__c__functions.html#gaced655069ef6e505fddd493fb0d33606">More...</a><br /></td></tr>
<tr class="separator:gaced655069ef6e505fddd493fb0d33606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e231e88d224fc168ca94e22252be6e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1e231e88d224fc168ca94e22252be6e3">nvnCommandBufferSetConservativeRasterEnable</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable)</td></tr>
<tr class="memdesc:ga1e231e88d224fc168ca94e22252be6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable conservative rasterization of rendered primitives.  <a href="group__nvn__c__functions.html#ga1e231e88d224fc168ca94e22252be6e3">More...</a><br /></td></tr>
<tr class="separator:ga1e231e88d224fc168ca94e22252be6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58fb857e055afc2512209f671e3d89ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga58fb857e055afc2512209f671e3d89ca">nvnCommandBufferSetCopyImageStride</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, ptrdiff_t stride)</td></tr>
<tr class="memdesc:ga58fb857e055afc2512209f671e3d89ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the image stride used for copies between buffer and texture memory.  <a href="group__nvn__c__functions.html#ga58fb857e055afc2512209f671e3d89ca">More...</a><br /></td></tr>
<tr class="separator:ga58fb857e055afc2512209f671e3d89ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6face2746fa0f109f61ba3d3b349fb9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga6face2746fa0f109f61ba3d3b349fb9f">nvnCommandBufferSetCopyRowStride</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, ptrdiff_t stride)</td></tr>
<tr class="memdesc:ga6face2746fa0f109f61ba3d3b349fb9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the row stride used for copies between buffer and texture memory.  <a href="group__nvn__c__functions.html#ga6face2746fa0f109f61ba3d3b349fb9f">More...</a><br /></td></tr>
<tr class="separator:ga6face2746fa0f109f61ba3d3b349fb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ecae66d8ac5f623d7a1abae492fc243"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3ecae66d8ac5f623d7a1abae492fc243">nvnCommandBufferSetDebugLabel</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const char *label)</td></tr>
<tr class="memdesc:ga3ecae66d8ac5f623d7a1abae492fc243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug label string for a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object.  <a href="group__nvn__c__functions.html#ga3ecae66d8ac5f623d7a1abae492fc243">More...</a><br /></td></tr>
<tr class="separator:ga3ecae66d8ac5f623d7a1abae492fc243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b174a2678de189471d5466ca2bfd4d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4b174a2678de189471d5466ca2bfd4d3">nvnCommandBufferSetDepthBounds</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable, float n, float f)</td></tr>
<tr class="memdesc:ga4b174a2678de189471d5466ca2bfd4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control the operation of the depth bounds test.  <a href="group__nvn__c__functions.html#ga4b174a2678de189471d5466ca2bfd4d3">More...</a><br /></td></tr>
<tr class="separator:ga4b174a2678de189471d5466ca2bfd4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ddab005c7a86e3b0b29a62932893cb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga5ddab005c7a86e3b0b29a62932893cb4">nvnCommandBufferSetDepthClamp</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> clamp)</td></tr>
<tr class="memdesc:ga5ddab005c7a86e3b0b29a62932893cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable depth clamping of rendered primitives.  <a href="group__nvn__c__functions.html#ga5ddab005c7a86e3b0b29a62932893cb4">More...</a><br /></td></tr>
<tr class="separator:ga5ddab005c7a86e3b0b29a62932893cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82e8dc14164ab8018898a76e07e6e86a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga82e8dc14164ab8018898a76e07e6e86a">nvnCommandBufferSetDepthRange</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, float n, float f)</td></tr>
<tr class="memdesc:ga82e8dc14164ab8018898a76e07e6e86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the range of depth values for rendered primitives.  <a href="group__nvn__c__functions.html#ga82e8dc14164ab8018898a76e07e6e86a">More...</a><br /></td></tr>
<tr class="separator:ga82e8dc14164ab8018898a76e07e6e86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6edc6a9aa34e0f383cfbdb0e78d20605"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga6edc6a9aa34e0f383cfbdb0e78d20605">nvnCommandBufferSetDepthRanges</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int first, int count, NVN_NOESCAPE const float *ranges)</td></tr>
<tr class="memdesc:ga6edc6a9aa34e0f383cfbdb0e78d20605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets multiple ranges of depth values for rendered primitives.  <a href="group__nvn__c__functions.html#ga6edc6a9aa34e0f383cfbdb0e78d20605">More...</a><br /></td></tr>
<tr class="separator:ga6edc6a9aa34e0f383cfbdb0e78d20605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf71f351afe5100328f8697ef4d7e69fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf71f351afe5100328f8697ef4d7e69fc">nvnCommandBufferSetInnerTessellationLevels</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, NVN_NOESCAPE const float *levels)</td></tr>
<tr class="memdesc:gaf71f351afe5100328f8697ef4d7e69fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify default inner tessellation levels when rendering patch primitives.  <a href="group__nvn__c__functions.html#gaf71f351afe5100328f8697ef4d7e69fc">More...</a><br /></td></tr>
<tr class="separator:gaf71f351afe5100328f8697ef4d7e69fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb4bb0bdb2ac78ee60e2e3e5138ce22e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gafb4bb0bdb2ac78ee60e2e3e5138ce22e">nvnCommandBufferSetLineWidth</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, float lineWidth)</td></tr>
<tr class="memdesc:gafb4bb0bdb2ac78ee60e2e3e5138ce22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the width (in pixels) of line primitives to render.  <a href="group__nvn__c__functions.html#gafb4bb0bdb2ac78ee60e2e3e5138ce22e">More...</a><br /></td></tr>
<tr class="separator:gafb4bb0bdb2ac78ee60e2e3e5138ce22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69eb92c349d648988d02b9b7a7a94a75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga69eb92c349d648988d02b9b7a7a94a75">nvnCommandBufferSetMemoryCallback</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__funcptrs.html#gac2d9ed5522cd4167d6a59f16d379bb1c">PFNNVNCOMMANDBUFFERMEMORYCALLBACKPROC</a> callback)</td></tr>
<tr class="memdesc:ga69eb92c349d648988d02b9b7a7a94a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a callback function for a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object that will be called if it runs out of memory.  <a href="group__nvn__c__functions.html#ga69eb92c349d648988d02b9b7a7a94a75">More...</a><br /></td></tr>
<tr class="separator:ga69eb92c349d648988d02b9b7a7a94a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8656f3468c263124963216458569ec07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8656f3468c263124963216458569ec07">nvnCommandBufferSetMemoryCallbackData</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, void *callbackData)</td></tr>
<tr class="memdesc:ga8656f3468c263124963216458569ec07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a generic pointer that will be passed to a callback function if the command buffer runs out of memory.  <a href="group__nvn__c__functions.html#ga8656f3468c263124963216458569ec07">More...</a><br /></td></tr>
<tr class="separator:ga8656f3468c263124963216458569ec07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8072de9e7ba78cc0eddff5c67deec10c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8072de9e7ba78cc0eddff5c67deec10c">nvnCommandBufferSetOuterTessellationLevels</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, NVN_NOESCAPE const float *levels)</td></tr>
<tr class="memdesc:ga8072de9e7ba78cc0eddff5c67deec10c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify default outer tessellation levels when rendering patch primitives.  <a href="group__nvn__c__functions.html#ga8072de9e7ba78cc0eddff5c67deec10c">More...</a><br /></td></tr>
<tr class="separator:ga8072de9e7ba78cc0eddff5c67deec10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0030496de8749dee42285b464f59f066"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0030496de8749dee42285b464f59f066">nvnCommandBufferSetPatchSize</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int size)</td></tr>
<tr class="memdesc:ga0030496de8749dee42285b464f59f066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the number of vertices in each patch when rendering patch primitives.  <a href="group__nvn__c__functions.html#ga0030496de8749dee42285b464f59f066">More...</a><br /></td></tr>
<tr class="separator:ga0030496de8749dee42285b464f59f066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3a20e6577e2780cf1de7487730a2086"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf3a20e6577e2780cf1de7487730a2086">nvnCommandBufferSetPointSize</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, float pointSize)</td></tr>
<tr class="memdesc:gaf3a20e6577e2780cf1de7487730a2086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the size (in pixels) of point primitives to render.  <a href="group__nvn__c__functions.html#gaf3a20e6577e2780cf1de7487730a2086">More...</a><br /></td></tr>
<tr class="separator:gaf3a20e6577e2780cf1de7487730a2086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81867da9e1301f27904dae46435c931b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga81867da9e1301f27904dae46435c931b">nvnCommandBufferSetPolygonOffsetClamp</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, float factor, float units, float clamp)</td></tr>
<tr class="memdesc:ga81867da9e1301f27904dae46435c931b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies values used to compute a depth offset value when polygon offset is enabled.  <a href="group__nvn__c__functions.html#ga81867da9e1301f27904dae46435c931b">More...</a><br /></td></tr>
<tr class="separator:ga81867da9e1301f27904dae46435c931b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fe0e7f03b40e90dc870c706d6432d8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9fe0e7f03b40e90dc870c706d6432d8f">nvnCommandBufferSetPrimitiveRestart</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable, int index)</td></tr>
<tr class="memdesc:ga9fe0e7f03b40e90dc870c706d6432d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable and disable primitive restart and specify a primitive restart index.  <a href="group__nvn__c__functions.html#ga9fe0e7f03b40e90dc870c706d6432d8f">More...</a><br /></td></tr>
<tr class="separator:ga9fe0e7f03b40e90dc870c706d6432d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab36aecb89c1a84c9cb2a2ca621056f89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab36aecb89c1a84c9cb2a2ca621056f89">nvnCommandBufferSetProgramSubroutines</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *program, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, const int first, const int count, NVN_NOESCAPE const int *values)</td></tr>
<tr class="memdesc:gab36aecb89c1a84c9cb2a2ca621056f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the subroutine uniform parameters.  <a href="group__nvn__c__functions.html#gab36aecb89c1a84c9cb2a2ca621056f89">More...</a><br /></td></tr>
<tr class="separator:gab36aecb89c1a84c9cb2a2ca621056f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacff1db19e51d3dec85a952263345dcff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gacff1db19e51d3dec85a952263345dcff">nvnCommandBufferSetRasterizerDiscard</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> discard)</td></tr>
<tr class="memdesc:gacff1db19e51d3dec85a952263345dcff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable rasterizer discard.  <a href="group__nvn__c__functions.html#gacff1db19e51d3dec85a952263345dcff">More...</a><br /></td></tr>
<tr class="separator:gacff1db19e51d3dec85a952263345dcff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada2e0273010f55fc9c3a44e57320a0d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gada2e0273010f55fc9c3a44e57320a0d2">nvnCommandBufferSetRenderEnable</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable)</td></tr>
<tr class="memdesc:gada2e0273010f55fc9c3a44e57320a0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the render enable for a queue.  <a href="group__nvn__c__functions.html#gada2e0273010f55fc9c3a44e57320a0d2">More...</a><br /></td></tr>
<tr class="separator:gada2e0273010f55fc9c3a44e57320a0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa29e43ea6dbe7c77ea050ae7ae95758c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaa29e43ea6dbe7c77ea050ae7ae95758c">nvnCommandBufferSetRenderEnableConditional</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gae555b5b8ce83bd8c76b77f40481adc8b">NVNconditionalRenderMode</a> mode, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> counters)</td></tr>
<tr class="memdesc:gaa29e43ea6dbe7c77ea050ae7ae95758c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables rendering for a queue, depending on the equality of counters.  <a href="group__nvn__c__functions.html#gaa29e43ea6dbe7c77ea050ae7ae95758c">More...</a><br /></td></tr>
<tr class="separator:gaa29e43ea6dbe7c77ea050ae7ae95758c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75b3bc276a95e8c5a8bbd08ea3e9593a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga75b3bc276a95e8c5a8bbd08ea3e9593a">nvnCommandBufferSetRenderTargets</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int numColors, NVN_NOESCAPE const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *const *colors, NVN_NOESCAPE const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *const *colorViews, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *depthStencil, NVN_NOESCAPE const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *depthStencilView)</td></tr>
<tr class="memdesc:ga75b3bc276a95e8c5a8bbd08ea3e9593a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets color and depth/stencil textures in the framebuffer.  <a href="group__nvn__c__functions.html#ga75b3bc276a95e8c5a8bbd08ea3e9593a">More...</a><br /></td></tr>
<tr class="separator:ga75b3bc276a95e8c5a8bbd08ea3e9593a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcba5a3b987a3f421ca0566a48dbf62e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gadcba5a3b987a3f421ca0566a48dbf62e">nvnCommandBufferSetSampleMask</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int mask)</td></tr>
<tr class="memdesc:gadcba5a3b987a3f421ca0566a48dbf62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a mask of samples that may be covered by rendered primitives.  <a href="group__nvn__c__functions.html#gadcba5a3b987a3f421ca0566a48dbf62e">More...</a><br /></td></tr>
<tr class="separator:gadcba5a3b987a3f421ca0566a48dbf62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71cd4e0a83ae73c92c76333d3adc6212"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga71cd4e0a83ae73c92c76333d3adc6212">nvnCommandBufferSetSamplerPool</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *samplerPool)</td></tr>
<tr class="memdesc:ga71cd4e0a83ae73c92c76333d3adc6212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a new sampler pool used for subsequent rendering operations.  <a href="group__nvn__c__functions.html#ga71cd4e0a83ae73c92c76333d3adc6212">More...</a><br /></td></tr>
<tr class="separator:ga71cd4e0a83ae73c92c76333d3adc6212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6c38cac9330ae402f2f911d1e1aa757"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac6c38cac9330ae402f2f911d1e1aa757">nvnCommandBufferSetScissor</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int x, int y, int w, int h)</td></tr>
<tr class="memdesc:gac6c38cac9330ae402f2f911d1e1aa757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the scissor rectangle used for clipping primitives and clears.  <a href="group__nvn__c__functions.html#gac6c38cac9330ae402f2f911d1e1aa757">More...</a><br /></td></tr>
<tr class="separator:gac6c38cac9330ae402f2f911d1e1aa757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c88523532adae470502025229b62f08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1c88523532adae470502025229b62f08">nvnCommandBufferSetScissors</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int first, int count, NVN_NOESCAPE const int *rects)</td></tr>
<tr class="memdesc:ga1c88523532adae470502025229b62f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify one or more scissor rectangles.  <a href="group__nvn__c__functions.html#ga1c88523532adae470502025229b62f08">More...</a><br /></td></tr>
<tr class="separator:ga1c88523532adae470502025229b62f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafccbb352a6e0b28138c1a1e727fc1f83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gafccbb352a6e0b28138c1a1e727fc1f83">nvnCommandBufferSetShaderScratchMemory</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *pool, ptrdiff_t offset, size_t size)</td></tr>
<tr class="memdesc:gafccbb352a6e0b28138c1a1e727fc1f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify scratch memory required for shader execution.  <a href="group__nvn__c__functions.html#gafccbb352a6e0b28138c1a1e727fc1f83">More...</a><br /></td></tr>
<tr class="separator:gafccbb352a6e0b28138c1a1e727fc1f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fdbe92539c8703c2e92cec46a3ce654"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3fdbe92539c8703c2e92cec46a3ce654">nvnCommandBufferSetStencilCullCriteria</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gab50861ff9b46503782bb66c4edb734ae">NVNstencilFunc</a> func, int ref, int mask)</td></tr>
<tr class="memdesc:ga3fdbe92539c8703c2e92cec46a3ce654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the criteria that is used by the ZCull HW for stencil culling.  <a href="group__nvn__c__functions.html#ga3fdbe92539c8703c2e92cec46a3ce654">More...</a><br /></td></tr>
<tr class="separator:ga3fdbe92539c8703c2e92cec46a3ce654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f084072b85bde09e40e4920fce1be65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga5f084072b85bde09e40e4920fce1be65">nvnCommandBufferSetStencilMask</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a> faces, int mask)</td></tr>
<tr class="memdesc:ga5f084072b85bde09e40e4920fce1be65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a mask to apply to stencil values written by the stencil test.  <a href="group__nvn__c__functions.html#ga5f084072b85bde09e40e4920fce1be65">More...</a><br /></td></tr>
<tr class="separator:ga5f084072b85bde09e40e4920fce1be65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3670a8f6d5e0a5267dfb69919d46d8d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3670a8f6d5e0a5267dfb69919d46d8d5">nvnCommandBufferSetStencilRef</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a> faces, int ref)</td></tr>
<tr class="memdesc:ga3670a8f6d5e0a5267dfb69919d46d8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a stencil reference value used by the stencil test.  <a href="group__nvn__c__functions.html#ga3670a8f6d5e0a5267dfb69919d46d8d5">More...</a><br /></td></tr>
<tr class="separator:ga3670a8f6d5e0a5267dfb69919d46d8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab057345ad441b37deda70d0434d0cb5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab057345ad441b37deda70d0434d0cb5f">nvnCommandBufferSetStencilValueMask</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a> faces, int mask)</td></tr>
<tr class="memdesc:gab057345ad441b37deda70d0434d0cb5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a mask that will be applied to the stencil index and reference values prior to performing the stencil test.  <a href="group__nvn__c__functions.html#gab057345ad441b37deda70d0434d0cb5f">More...</a><br /></td></tr>
<tr class="separator:gab057345ad441b37deda70d0434d0cb5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c5fe84c110d0a48de87c2f6f83eb6e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga6c5fe84c110d0a48de87c2f6f83eb6e3">nvnCommandBufferSetSubpixelPrecisionBias</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int xBits, int yBits)</td></tr>
<tr class="memdesc:ga6c5fe84c110d0a48de87c2f6f83eb6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the number of additional bits of subpixel precision to be used for primitive rasterization when conservative rasterization is enabled.  <a href="group__nvn__c__functions.html#ga6c5fe84c110d0a48de87c2f6f83eb6e3">More...</a><br /></td></tr>
<tr class="separator:ga6c5fe84c110d0a48de87c2f6f83eb6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43781240fe1741acfa122ad4fd63b802"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga43781240fe1741acfa122ad4fd63b802">nvnCommandBufferSetTexturePool</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *texturePool)</td></tr>
<tr class="memdesc:ga43781240fe1741acfa122ad4fd63b802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a new texture pool used for subsequent rendering operations.  <a href="group__nvn__c__functions.html#ga43781240fe1741acfa122ad4fd63b802">More...</a><br /></td></tr>
<tr class="separator:ga43781240fe1741acfa122ad4fd63b802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2e294bc785c1a41a874f71fe5b277d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae2e294bc785c1a41a874f71fe5b277d4">nvnCommandBufferSetTiledCacheAction</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gaa34a73b0ed878a1ee610efb60d5bbb9c">NVNtiledCacheAction</a> action)</td></tr>
<tr class="memdesc:gae2e294bc785c1a41a874f71fe5b277d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a specified operation related to tiled caching.  <a href="group__nvn__c__functions.html#gae2e294bc785c1a41a874f71fe5b277d4">More...</a><br /></td></tr>
<tr class="separator:gae2e294bc785c1a41a874f71fe5b277d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga682b6f01fe95daff5aa16c5b044fca32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga682b6f01fe95daff5aa16c5b044fca32">nvnCommandBufferSetTiledCacheTileSize</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int tileWidth, int tileHeight)</td></tr>
<tr class="memdesc:ga682b6f01fe95daff5aa16c5b044fca32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the tile size used for tiled caching.  <a href="group__nvn__c__functions.html#ga682b6f01fe95daff5aa16c5b044fca32">More...</a><br /></td></tr>
<tr class="separator:ga682b6f01fe95daff5aa16c5b044fca32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4cadef7ff012bc4d218bfd9e510a888"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac4cadef7ff012bc4d218bfd9e510a888">nvnCommandBufferSetViewport</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int x, int y, int w, int h)</td></tr>
<tr class="memdesc:gac4cadef7ff012bc4d218bfd9e510a888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the rectangle for viewport 0.  <a href="group__nvn__c__functions.html#gac4cadef7ff012bc4d218bfd9e510a888">More...</a><br /></td></tr>
<tr class="separator:gac4cadef7ff012bc4d218bfd9e510a888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2730fee1fd83ed7b15d81b46f6c73c41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2730fee1fd83ed7b15d81b46f6c73c41">nvnCommandBufferSetViewports</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int first, int count, NVN_NOESCAPE const float *ranges)</td></tr>
<tr class="memdesc:ga2730fee1fd83ed7b15d81b46f6c73c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify one or more viewport rectangles.  <a href="group__nvn__c__functions.html#ga2730fee1fd83ed7b15d81b46f6c73c41">More...</a><br /></td></tr>
<tr class="separator:ga2730fee1fd83ed7b15d81b46f6c73c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92a714477d6eaad9ca388efc5ecd31e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga92a714477d6eaad9ca388efc5ecd31e3">nvnCommandBufferSetViewportSwizzles</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int first, int count, NVN_NOESCAPE const <a class="el" href="group__nvn__c__enum.html#ga00e92e1d7e5fff49496f813b6288ec0f">NVNviewportSwizzle</a> *swizzles)</td></tr>
<tr class="memdesc:ga92a714477d6eaad9ca388efc5ecd31e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a set of viewport swizzle selectors for one or more viewport rectangles.  <a href="group__nvn__c__functions.html#ga92a714477d6eaad9ca388efc5ecd31e3">More...</a><br /></td></tr>
<tr class="separator:ga92a714477d6eaad9ca388efc5ecd31e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70069b0add7841395efa76905f4f3833"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga70069b0add7841395efa76905f4f3833">nvnCommandBufferSetZCullZF32CompressionEnable</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable)</td></tr>
<tr class="memdesc:ga70069b0add7841395efa76905f4f3833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables/Disables the compression for ZF32 values in the ZCull <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a>.  <a href="group__nvn__c__functions.html#ga70069b0add7841395efa76905f4f3833">More...</a><br /></td></tr>
<tr class="separator:ga70069b0add7841395efa76905f4f3833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae26f02577d10f5b39bb432d34d4b8649"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae26f02577d10f5b39bb432d34d4b8649">nvnCommandBufferSignalEvent</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_nevent.html">NVNevent</a> *event, <a class="el" href="group__nvn__c__enum.html#gae0c7c9637d4f93ea56fc315c97f17a7e">NVNeventSignalMode</a> mode, <a class="el" href="group__nvn__c__enum.html#ga46d20cb478c11853f23d27890c28f4ee">NVNeventSignalLocation</a> location, int flags, uint32_t value)</td></tr>
<tr class="memdesc:gae26f02577d10f5b39bb432d34d4b8649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the GPU to signal an <a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object.  <a href="group__nvn__c__functions.html#gae26f02577d10f5b39bb432d34d4b8649">More...</a><br /></td></tr>
<tr class="separator:gae26f02577d10f5b39bb432d34d4b8649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09ac3a51249e04fe24e778d62fa0717b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga09ac3a51249e04fe24e778d62fa0717b">nvnCommandBufferTiledDownsample</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *src, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *dst)</td></tr>
<tr class="memdesc:ga09ac3a51249e04fe24e778d62fa0717b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a filtered version of a multisample source texture to produce a single-sample destination texture.  <a href="group__nvn__c__functions.html#ga09ac3a51249e04fe24e778d62fa0717b">More...</a><br /></td></tr>
<tr class="separator:ga09ac3a51249e04fe24e778d62fa0717b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c1557296bd5eea6bbf2f2cbb8692aa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2c1557296bd5eea6bbf2f2cbb8692aa6">nvnCommandBufferTiledDownsampleTextureView</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *src, NVN_NOESCAPE const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *srcView, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *dst, NVN_NOESCAPE const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *dstView)</td></tr>
<tr class="memdesc:ga2c1557296bd5eea6bbf2f2cbb8692aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a filtered version of a multisample source texture texture view to produce a single-sample destination texture view.  <a href="group__nvn__c__functions.html#ga2c1557296bd5eea6bbf2f2cbb8692aa6">More...</a><br /></td></tr>
<tr class="separator:ga2c1557296bd5eea6bbf2f2cbb8692aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacea9343e5ef30fb540cc2f021bfa0f74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gacea9343e5ef30fb540cc2f021bfa0f74">nvnCommandBufferUpdateUniformBuffer</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> buffer, size_t bufferSize, ptrdiff_t updateOffset, size_t updateSize, NVN_NOESCAPE const void *data)</td></tr>
<tr class="memdesc:gacea9343e5ef30fb540cc2f021bfa0f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the contents of a uniform buffer.  <a href="group__nvn__c__functions.html#gacea9343e5ef30fb540cc2f021bfa0f74">More...</a><br /></td></tr>
<tr class="separator:gacea9343e5ef30fb540cc2f021bfa0f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bf01e6a51e19855a7906f9172ce3e39"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0bf01e6a51e19855a7906f9172ce3e39">nvnCommandBufferUpdateUniformBuffer_fastpath</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> buffer, size_t bufferSize, ptrdiff_t updateOffset, size_t updateSize, NVN_NOESCAPE const void *data)</td></tr>
<tr class="memdesc:ga0bf01e6a51e19855a7906f9172ce3e39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the contents of a uniform buffer.  <a href="group__nvn__c__functions.html#ga0bf01e6a51e19855a7906f9172ce3e39">More...</a><br /></td></tr>
<tr class="separator:ga0bf01e6a51e19855a7906f9172ce3e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81d0bfe6252b8f44e1b0a3607856d71c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga81d0bfe6252b8f44e1b0a3607856d71c">nvnCommandBufferWaitEvent</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_nevent.html">NVNevent</a> *event, <a class="el" href="group__nvn__c__enum.html#ga6062c139aaf05b84d9c59913ff914cad">NVNeventWaitMode</a> waitMode, uint32_t value)</td></tr>
<tr class="memdesc:ga81d0bfe6252b8f44e1b0a3607856d71c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause work on the GPU until an event is signaled.  <a href="group__nvn__c__functions.html#ga81d0bfe6252b8f44e1b0a3607856d71c">More...</a><br /></td></tr>
<tr class="separator:ga81d0bfe6252b8f44e1b0a3607856d71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e5ab25595c79c070fc8dd7442a69d6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7e5ab25595c79c070fc8dd7442a69d6d">nvnCommandBufferWaitSync</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_nsync.html">NVNsync</a> *sync)</td></tr>
<tr class="memdesc:ga7e5ab25595c79c070fc8dd7442a69d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object to be signaled on the GPU before processing any further commands in the specified <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object.  <a href="group__nvn__c__functions.html#ga7e5ab25595c79c070fc8dd7442a69d6d">More...</a><br /></td></tr>
<tr class="separator:ga7e5ab25595c79c070fc8dd7442a69d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga988a86f1527afdfb7cd08e79b5ac600a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga14f57c18bdbcc7517a24b723743e61e6">NVNdepthFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga988a86f1527afdfb7cd08e79b5ac600a">nvnDepthStencilStateGetDepthFunc</a> (const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil)</td></tr>
<tr class="memdesc:ga988a86f1527afdfb7cd08e79b5ac600a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the comparison function used when depth testing is enabled.  <a href="group__nvn__c__functions.html#ga988a86f1527afdfb7cd08e79b5ac600a">More...</a><br /></td></tr>
<tr class="separator:ga988a86f1527afdfb7cd08e79b5ac600a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e0c9f60146ff3dce4ae5377e5dea5df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0e0c9f60146ff3dce4ae5377e5dea5df">nvnDepthStencilStateGetDepthTestEnable</a> (const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil)</td></tr>
<tr class="memdesc:ga0e0c9f60146ff3dce4ae5377e5dea5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether depth testing is enabled or disabled.  <a href="group__nvn__c__functions.html#ga0e0c9f60146ff3dce4ae5377e5dea5df">More...</a><br /></td></tr>
<tr class="separator:ga0e0c9f60146ff3dce4ae5377e5dea5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdef5f8abe8f174129ae19e8480c48bf"><td class="memItemLeft" align="right" valign="top">NVNINLINE <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gabdef5f8abe8f174129ae19e8480c48bf">nvnDepthStencilStateGetDepthTestEnable_fastpath</a> (const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil)</td></tr>
<tr class="memdesc:gabdef5f8abe8f174129ae19e8480c48bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether depth testing is enabled or disabled.  <a href="group__nvn__c__functions.html#gabdef5f8abe8f174129ae19e8480c48bf">More...</a><br /></td></tr>
<tr class="separator:gabdef5f8abe8f174129ae19e8480c48bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dbfe16804066f2acf2127e1b36fadb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2dbfe16804066f2acf2127e1b36fadb3">nvnDepthStencilStateGetDepthWriteEnable</a> (const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil)</td></tr>
<tr class="memdesc:ga2dbfe16804066f2acf2127e1b36fadb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the depth buffer should be updated by the depth test.  <a href="group__nvn__c__functions.html#ga2dbfe16804066f2acf2127e1b36fadb3">More...</a><br /></td></tr>
<tr class="separator:ga2dbfe16804066f2acf2127e1b36fadb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86ef894acb9260d8a39e80fa67ab232d"><td class="memItemLeft" align="right" valign="top">NVNINLINE <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga86ef894acb9260d8a39e80fa67ab232d">nvnDepthStencilStateGetDepthWriteEnable_fastpath</a> (const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil)</td></tr>
<tr class="memdesc:ga86ef894acb9260d8a39e80fa67ab232d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the depth buffer should be updated by the depth test.  <a href="group__nvn__c__functions.html#ga86ef894acb9260d8a39e80fa67ab232d">More...</a><br /></td></tr>
<tr class="separator:ga86ef894acb9260d8a39e80fa67ab232d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11ef77b998e4d4ca6bff2e8721a18ae7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#gab50861ff9b46503782bb66c4edb734ae">NVNstencilFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga11ef77b998e4d4ca6bff2e8721a18ae7">nvnDepthStencilStateGetStencilFunc</a> (const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil, <a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a> face)</td></tr>
<tr class="memdesc:ga11ef77b998e4d4ca6bff2e8721a18ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the comparison function used when stencil testing is enabled.  <a href="group__nvn__c__functions.html#ga11ef77b998e4d4ca6bff2e8721a18ae7">More...</a><br /></td></tr>
<tr class="separator:ga11ef77b998e4d4ca6bff2e8721a18ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1f44de3d7815edec84bc5773e4bf6b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf1f44de3d7815edec84bc5773e4bf6b7">nvnDepthStencilStateGetStencilOp</a> (const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil, <a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a> face, <a class="el" href="group__nvn__c__enum.html#gad3757d551ee48be48890aa243050e6ca">NVNstencilOp</a> *fail, <a class="el" href="group__nvn__c__enum.html#gad3757d551ee48be48890aa243050e6ca">NVNstencilOp</a> *depthFail, <a class="el" href="group__nvn__c__enum.html#gad3757d551ee48be48890aa243050e6ca">NVNstencilOp</a> *depthPass)</td></tr>
<tr class="memdesc:gaf1f44de3d7815edec84bc5773e4bf6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query operations performed on stored stencil values by the stencil test.  <a href="group__nvn__c__functions.html#gaf1f44de3d7815edec84bc5773e4bf6b7">More...</a><br /></td></tr>
<tr class="separator:gaf1f44de3d7815edec84bc5773e4bf6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22358a58ee07fdefd11993f6929ac9d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga22358a58ee07fdefd11993f6929ac9d7">nvnDepthStencilStateGetStencilTestEnable</a> (const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil)</td></tr>
<tr class="memdesc:ga22358a58ee07fdefd11993f6929ac9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the stencil testing is enabled or disabled.  <a href="group__nvn__c__functions.html#ga22358a58ee07fdefd11993f6929ac9d7">More...</a><br /></td></tr>
<tr class="separator:ga22358a58ee07fdefd11993f6929ac9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf6468c3bdfd26790e0c535d22fa0b97"><td class="memItemLeft" align="right" valign="top">NVNINLINE <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gabf6468c3bdfd26790e0c535d22fa0b97">nvnDepthStencilStateGetStencilTestEnable_fastpath</a> (const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil)</td></tr>
<tr class="memdesc:gabf6468c3bdfd26790e0c535d22fa0b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the stencil testing is enabled or disabled.  <a href="group__nvn__c__functions.html#gabf6468c3bdfd26790e0c535d22fa0b97">More...</a><br /></td></tr>
<tr class="separator:gabf6468c3bdfd26790e0c535d22fa0b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f659011ea2a0c713e64022959b865e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2f659011ea2a0c713e64022959b865e2">nvnDepthStencilStateSetDefaults</a> (<a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil)</td></tr>
<tr class="memdesc:ga2f659011ea2a0c713e64022959b865e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">NVNdepthStencilState</a> object.  <a href="group__nvn__c__functions.html#ga2f659011ea2a0c713e64022959b865e2">More...</a><br /></td></tr>
<tr class="separator:ga2f659011ea2a0c713e64022959b865e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdbe8e6bc4bfb62a304d831a919d9890"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gafdbe8e6bc4bfb62a304d831a919d9890">nvnDepthStencilStateSetDepthFunc</a> (<a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil, <a class="el" href="group__nvn__c__enum.html#ga14f57c18bdbcc7517a24b723743e61e6">NVNdepthFunc</a> func)</td></tr>
<tr class="memdesc:gafdbe8e6bc4bfb62a304d831a919d9890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the comparison function used when depth testing is enabled.  <a href="group__nvn__c__functions.html#gafdbe8e6bc4bfb62a304d831a919d9890">More...</a><br /></td></tr>
<tr class="separator:gafdbe8e6bc4bfb62a304d831a919d9890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0c842855708604f65d309bb0e8fdfc5"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf0c842855708604f65d309bb0e8fdfc5">nvnDepthStencilStateSetDepthFunc_fastpath</a> (<a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil, <a class="el" href="group__nvn__c__enum.html#ga14f57c18bdbcc7517a24b723743e61e6">NVNdepthFunc</a> func)</td></tr>
<tr class="memdesc:gaf0c842855708604f65d309bb0e8fdfc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the comparison function used when depth testing is enabled.  <a href="group__nvn__c__functions.html#gaf0c842855708604f65d309bb0e8fdfc5">More...</a><br /></td></tr>
<tr class="separator:gaf0c842855708604f65d309bb0e8fdfc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a0a2454a1b00a8889d1d34fd8a7da69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8a0a2454a1b00a8889d1d34fd8a7da69">nvnDepthStencilStateSetDepthTestEnable</a> (<a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable)</td></tr>
<tr class="memdesc:ga8a0a2454a1b00a8889d1d34fd8a7da69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify whether depth testing is enabled or disabled.  <a href="group__nvn__c__functions.html#ga8a0a2454a1b00a8889d1d34fd8a7da69">More...</a><br /></td></tr>
<tr class="separator:ga8a0a2454a1b00a8889d1d34fd8a7da69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e04251e5e2f58570fede3774d347b75"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4e04251e5e2f58570fede3774d347b75">nvnDepthStencilStateSetDepthTestEnable_fastpath</a> (<a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable)</td></tr>
<tr class="memdesc:ga4e04251e5e2f58570fede3774d347b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify whether depth testing is enabled or disabled.  <a href="group__nvn__c__functions.html#ga4e04251e5e2f58570fede3774d347b75">More...</a><br /></td></tr>
<tr class="separator:ga4e04251e5e2f58570fede3774d347b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga363282d1d17b72e5553651d7b2c367cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga363282d1d17b72e5553651d7b2c367cf">nvnDepthStencilStateSetDepthWriteEnable</a> (<a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable)</td></tr>
<tr class="memdesc:ga363282d1d17b72e5553651d7b2c367cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify whether the depth buffer should be updated by the depth test.  <a href="group__nvn__c__functions.html#ga363282d1d17b72e5553651d7b2c367cf">More...</a><br /></td></tr>
<tr class="separator:ga363282d1d17b72e5553651d7b2c367cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72379cdc250746f376943f0188b606bf"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga72379cdc250746f376943f0188b606bf">nvnDepthStencilStateSetDepthWriteEnable_fastpath</a> (<a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable)</td></tr>
<tr class="memdesc:ga72379cdc250746f376943f0188b606bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify whether the depth buffer should be updated by the depth test.  <a href="group__nvn__c__functions.html#ga72379cdc250746f376943f0188b606bf">More...</a><br /></td></tr>
<tr class="separator:ga72379cdc250746f376943f0188b606bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6c290c610aa9daf1a2ece3e18065e32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaa6c290c610aa9daf1a2ece3e18065e32">nvnDepthStencilStateSetStencilFunc</a> (<a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil, <a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a> faces, <a class="el" href="group__nvn__c__enum.html#gab50861ff9b46503782bb66c4edb734ae">NVNstencilFunc</a> func)</td></tr>
<tr class="memdesc:gaa6c290c610aa9daf1a2ece3e18065e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the comparison function used when stencil testing is enabled.  <a href="group__nvn__c__functions.html#gaa6c290c610aa9daf1a2ece3e18065e32">More...</a><br /></td></tr>
<tr class="separator:gaa6c290c610aa9daf1a2ece3e18065e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36095f921d11664dbe4b3139b8bf7793"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga36095f921d11664dbe4b3139b8bf7793">nvnDepthStencilStateSetStencilOp</a> (<a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil, <a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a> faces, <a class="el" href="group__nvn__c__enum.html#gad3757d551ee48be48890aa243050e6ca">NVNstencilOp</a> fail, <a class="el" href="group__nvn__c__enum.html#gad3757d551ee48be48890aa243050e6ca">NVNstencilOp</a> depthFail, <a class="el" href="group__nvn__c__enum.html#gad3757d551ee48be48890aa243050e6ca">NVNstencilOp</a> depthPass)</td></tr>
<tr class="memdesc:ga36095f921d11664dbe4b3139b8bf7793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies operations performed on stored stencil values by the stencil test.  <a href="group__nvn__c__functions.html#ga36095f921d11664dbe4b3139b8bf7793">More...</a><br /></td></tr>
<tr class="separator:ga36095f921d11664dbe4b3139b8bf7793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0127f672494691efb62b594091eeddee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0127f672494691efb62b594091eeddee">nvnDepthStencilStateSetStencilTestEnable</a> (<a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable)</td></tr>
<tr class="memdesc:ga0127f672494691efb62b594091eeddee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify whether the stencil testing is enabled or disabled.  <a href="group__nvn__c__functions.html#ga0127f672494691efb62b594091eeddee">More...</a><br /></td></tr>
<tr class="separator:ga0127f672494691efb62b594091eeddee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a7785c775e7c533efa35b8562a6f826"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9a7785c775e7c533efa35b8562a6f826">nvnDepthStencilStateSetStencilTestEnable_fastpath</a> (<a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable)</td></tr>
<tr class="memdesc:ga9a7785c775e7c533efa35b8562a6f826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify whether the stencil testing is enabled or disabled.  <a href="group__nvn__c__functions.html#ga9a7785c775e7c533efa35b8562a6f826">More...</a><br /></td></tr>
<tr class="separator:ga9a7785c775e7c533efa35b8562a6f826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfe3e96f8b8ef13acb9008e4098196d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga9c68350bf64f2e7a90a23290c26872d3">NVNdeviceFlagBits</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gacfe3e96f8b8ef13acb9008e4098196d3">nvnDeviceBuilderGetFlags</a> (const <a class="el" href="struct_n_v_ndevice_builder.html">NVNdeviceBuilder</a> *builder)</td></tr>
<tr class="memdesc:gacfe3e96f8b8ef13acb9008e4098196d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get flags associated with this <a class="el" href="struct_n_v_ndevice_builder.html" title="Object specifying state used to construct new device objects.">NVNdeviceBuilder</a> object.  <a href="group__nvn__c__functions.html#gacfe3e96f8b8ef13acb9008e4098196d3">More...</a><br /></td></tr>
<tr class="separator:gacfe3e96f8b8ef13acb9008e4098196d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9965ca922dfa44cecfff9185a65d99c0"><td class="memItemLeft" align="right" valign="top">NVNINLINE <a class="el" href="group__nvn__c__enum.html#ga9c68350bf64f2e7a90a23290c26872d3">NVNdeviceFlagBits</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9965ca922dfa44cecfff9185a65d99c0">nvnDeviceBuilderGetFlags_fastpath</a> (const <a class="el" href="struct_n_v_ndevice_builder.html">NVNdeviceBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga9965ca922dfa44cecfff9185a65d99c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get flags associated with this <a class="el" href="struct_n_v_ndevice_builder.html" title="Object specifying state used to construct new device objects.">NVNdeviceBuilder</a> object.  <a href="group__nvn__c__functions.html#ga9965ca922dfa44cecfff9185a65d99c0">More...</a><br /></td></tr>
<tr class="separator:ga9965ca922dfa44cecfff9185a65d99c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa042629cf4bc5ef1fab4bc7bf37b6f4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaa042629cf4bc5ef1fab4bc7bf37b6f4f">nvnDeviceBuilderSetDefaults</a> (<a class="el" href="struct_n_v_ndevice_builder.html">NVNdeviceBuilder</a> *builder)</td></tr>
<tr class="memdesc:gaa042629cf4bc5ef1fab4bc7bf37b6f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_ndevice_builder.html" title="Object specifying state used to construct new device objects.">NVNdeviceBuilder</a> object.  <a href="group__nvn__c__functions.html#gaa042629cf4bc5ef1fab4bc7bf37b6f4f">More...</a><br /></td></tr>
<tr class="separator:gaa042629cf4bc5ef1fab4bc7bf37b6f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga918d154a1d1f156eb61e6a3e402cbf1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga918d154a1d1f156eb61e6a3e402cbf1c">nvnDeviceBuilderSetFlags</a> (<a class="el" href="struct_n_v_ndevice_builder.html">NVNdeviceBuilder</a> *builder, int flags)</td></tr>
<tr class="memdesc:ga918d154a1d1f156eb61e6a3e402cbf1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set flags used for during device initialzation.  <a href="group__nvn__c__functions.html#ga918d154a1d1f156eb61e6a3e402cbf1c">More...</a><br /></td></tr>
<tr class="separator:ga918d154a1d1f156eb61e6a3e402cbf1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fccd6ba67cd2d269900832d3b7e82ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga5fccd6ba67cd2d269900832d3b7e82ff">nvnDeviceFinalize</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device)</td></tr>
<tr class="memdesc:ga5fccd6ba67cd2d269900832d3b7e82ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> object.  <a href="group__nvn__c__functions.html#ga5fccd6ba67cd2d269900832d3b7e82ff">More...</a><br /></td></tr>
<tr class="separator:ga5fccd6ba67cd2d269900832d3b7e82ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5babbe756bd750bf3fd41c2b4049a730"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga5babbe756bd750bf3fd41c2b4049a730">nvnDeviceFinalizeCommandHandle</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, <a class="el" href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a> handles)</td></tr>
<tr class="memdesc:ga5babbe756bd750bf3fd41c2b4049a730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a command handle.  <a href="group__nvn__c__functions.html#ga5babbe756bd750bf3fd41c2b4049a730">More...</a><br /></td></tr>
<tr class="separator:ga5babbe756bd750bf3fd41c2b4049a730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fb39752d0d8dd9d254667f3042c42b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga721dd09710079ec7e1d153842dbc7665">NVNdebugDomainId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7fb39752d0d8dd9d254667f3042c42b6">nvnDeviceGenerateDebugDomainId</a> (const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, const char *name)</td></tr>
<tr class="memdesc:ga7fb39752d0d8dd9d254667f3042c42b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns a unique ID by atomically incrementing a global counter on each request.  <a href="group__nvn__c__functions.html#ga7fb39752d0d8dd9d254667f3042c42b6">More...</a><br /></td></tr>
<tr class="separator:ga7fb39752d0d8dd9d254667f3042c42b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae11fb2040aadb9ab716ffc31d5f21e43"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae11fb2040aadb9ab716ffc31d5f21e43">nvnDeviceGetCurrentTimestampInNanoseconds</a> (const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device)</td></tr>
<tr class="memdesc:gae11fb2040aadb9ab716ffc31d5f21e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get timestamp from the device, without queuing like the ReportCounter functions.  <a href="group__nvn__c__functions.html#gae11fb2040aadb9ab716ffc31d5f21e43">More...</a><br /></td></tr>
<tr class="separator:gae11fb2040aadb9ab716ffc31d5f21e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga764b1be2fcce7a44895399a46646bb14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga0e55de1522658c843016e8b24a8ecabd">NVNdepthMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga764b1be2fcce7a44895399a46646bb14">nvnDeviceGetDepthMode</a> (const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device)</td></tr>
<tr class="memdesc:ga764b1be2fcce7a44895399a46646bb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the depth mode for a device.  <a href="group__nvn__c__functions.html#ga764b1be2fcce7a44895399a46646bb14">More...</a><br /></td></tr>
<tr class="separator:ga764b1be2fcce7a44895399a46646bb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5a1e64f3f59dd202df0e24ce466407b"><td class="memItemLeft" align="right" valign="top">NVNINLINE <a class="el" href="group__nvn__c__enum.html#ga0e55de1522658c843016e8b24a8ecabd">NVNdepthMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac5a1e64f3f59dd202df0e24ce466407b">nvnDeviceGetDepthMode_fastpath</a> (const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device)</td></tr>
<tr class="memdesc:gac5a1e64f3f59dd202df0e24ce466407b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the depth mode for a device.  <a href="group__nvn__c__functions.html#gac5a1e64f3f59dd202df0e24ce466407b">More...</a><br /></td></tr>
<tr class="separator:gac5a1e64f3f59dd202df0e24ce466407b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c42db1b24a512270afa6abd615fae01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__handle.html#gacba3c44a43c05f11bc1b88c49b118606">NVNimageHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9c42db1b24a512270afa6abd615fae01">nvnDeviceGetImageHandle</a> (const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, int imageID)</td></tr>
<tr class="memdesc:ga9c42db1b24a512270afa6abd615fae01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle to use for image loads and stores to a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object.  <a href="group__nvn__c__functions.html#ga9c42db1b24a512270afa6abd615fae01">More...</a><br /></td></tr>
<tr class="separator:ga9c42db1b24a512270afa6abd615fae01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f739de39c3818a65b190be3a82cf891"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga6f739de39c3818a65b190be3a82cf891">nvnDeviceGetInteger</a> (const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, <a class="el" href="group__nvn__c__enum.html#gac887e20e2474bb76b87943b0f0be7a50">NVNdeviceInfo</a> pname, int *v)</td></tr>
<tr class="memdesc:ga6f739de39c3818a65b190be3a82cf891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query properties of a device.  <a href="group__nvn__c__functions.html#ga6f739de39c3818a65b190be3a82cf891">More...</a><br /></td></tr>
<tr class="separator:ga6f739de39c3818a65b190be3a82cf891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacddfe3caf2f24874b617cd696e3a4305"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__funcptrs.html#gacb3cbf1bdfffca0a1bf319b77919e7f5">PFNNVNGENERICFUNCPTRPROC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gacddfe3caf2f24874b617cd696e3a4305">nvnDeviceGetProcAddress</a> (const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, const char *name)</td></tr>
<tr class="memdesc:gacddfe3caf2f24874b617cd696e3a4305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query a function pointer for a specified C interface entry point for a device.  <a href="group__nvn__c__functions.html#gacddfe3caf2f24874b617cd696e3a4305">More...</a><br /></td></tr>
<tr class="separator:gacddfe3caf2f24874b617cd696e3a4305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c15b1de83a8fe22f4ef03b74d8f946a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_n_v_nseparate_sampler_handle.html">NVNseparateSamplerHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2c15b1de83a8fe22f4ef03b74d8f946a">nvnDeviceGetSeparateSamplerHandle</a> (const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, int samplerID)</td></tr>
<tr class="memdesc:ga2c15b1de83a8fe22f4ef03b74d8f946a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle for a separate <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object.  <a href="group__nvn__c__functions.html#ga2c15b1de83a8fe22f4ef03b74d8f946a">More...</a><br /></td></tr>
<tr class="separator:ga2c15b1de83a8fe22f4ef03b74d8f946a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f3dbb400d79d6d8dc64c052226ba809"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_n_v_nseparate_texture_handle.html">NVNseparateTextureHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0f3dbb400d79d6d8dc64c052226ba809">nvnDeviceGetSeparateTextureHandle</a> (const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, int textureID)</td></tr>
<tr class="memdesc:ga0f3dbb400d79d6d8dc64c052226ba809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle for a separate <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object.  <a href="group__nvn__c__functions.html#ga0f3dbb400d79d6d8dc64c052226ba809">More...</a><br /></td></tr>
<tr class="separator:ga0f3dbb400d79d6d8dc64c052226ba809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0b754403b7c24211f204fd7667466da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__handle.html#gaa1a1fc7a9e690ce93870bcd71ea6b446">NVNtextureHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab0b754403b7c24211f204fd7667466da">nvnDeviceGetTexelFetchHandle</a> (const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, int textureID)</td></tr>
<tr class="memdesc:gab0b754403b7c24211f204fd7667466da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object for use in texel fetches.  <a href="group__nvn__c__functions.html#gab0b754403b7c24211f204fd7667466da">More...</a><br /></td></tr>
<tr class="separator:gab0b754403b7c24211f204fd7667466da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ca6fe7fc102170723f5eccb14a25046"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__handle.html#gaa1a1fc7a9e690ce93870bcd71ea6b446">NVNtextureHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0ca6fe7fc102170723f5eccb14a25046">nvnDeviceGetTextureHandle</a> (const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, int textureID, int samplerID)</td></tr>
<tr class="memdesc:ga0ca6fe7fc102170723f5eccb14a25046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle for a combined pair of <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> and <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects.  <a href="group__nvn__c__functions.html#ga0ca6fe7fc102170723f5eccb14a25046">More...</a><br /></td></tr>
<tr class="separator:ga0ca6fe7fc102170723f5eccb14a25046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dad3a471fcb5313fd4aab24e8062f1c"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9dad3a471fcb5313fd4aab24e8062f1c">nvnDeviceGetTimestampInNanoseconds</a> (const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, const <a class="el" href="struct_n_v_ncounter_data.html">NVNcounterData</a> *counterData)</td></tr>
<tr class="memdesc:ga9dad3a471fcb5313fd4aab24e8062f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the timestamp contained in a counter report, with time values converted from the platform-specific timestamp resolution to nanoseconds.  <a href="group__nvn__c__functions.html#ga9dad3a471fcb5313fd4aab24e8062f1c">More...</a><br /></td></tr>
<tr class="separator:ga9dad3a471fcb5313fd4aab24e8062f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f3e9684e49790ad324c33e38a07276b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga52db1bf3e182ec089c43db5a02baecd6">NVNwindowOriginMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1f3e9684e49790ad324c33e38a07276b">nvnDeviceGetWindowOriginMode</a> (const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device)</td></tr>
<tr class="memdesc:ga1f3e9684e49790ad324c33e38a07276b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the window origin mode for a device.  <a href="group__nvn__c__functions.html#ga1f3e9684e49790ad324c33e38a07276b">More...</a><br /></td></tr>
<tr class="separator:ga1f3e9684e49790ad324c33e38a07276b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf0bb6f5770883cd18dac49be9f5c44b"><td class="memItemLeft" align="right" valign="top">NVNINLINE <a class="el" href="group__nvn__c__enum.html#ga52db1bf3e182ec089c43db5a02baecd6">NVNwindowOriginMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gabf0bb6f5770883cd18dac49be9f5c44b">nvnDeviceGetWindowOriginMode_fastpath</a> (const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device)</td></tr>
<tr class="memdesc:gabf0bb6f5770883cd18dac49be9f5c44b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the window origin mode for a device.  <a href="group__nvn__c__functions.html#gabf0bb6f5770883cd18dac49be9f5c44b">More...</a><br /></td></tr>
<tr class="separator:gabf0bb6f5770883cd18dac49be9f5c44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac05386acab686b7614d353c9a4ea4d96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac05386acab686b7614d353c9a4ea4d96">nvnDeviceInitialize</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, const <a class="el" href="struct_n_v_ndevice_builder.html">NVNdeviceBuilder</a> *builder)</td></tr>
<tr class="memdesc:gac05386acab686b7614d353c9a4ea4d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> object from a device builder.  <a href="group__nvn__c__functions.html#gac05386acab686b7614d353c9a4ea4d96">More...</a><br /></td></tr>
<tr class="separator:gac05386acab686b7614d353c9a4ea4d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab73dcc0df1012caf66620aa7c56b2592"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab73dcc0df1012caf66620aa7c56b2592">nvnDeviceInstallDebugCallback</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, const <a class="el" href="group__nvn__c__funcptrs.html#gab106acc34961bf1c3a43514686dbfc4b">PFNNVNDEBUGCALLBACKPROC</a> callback, void *callbackData, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable)</td></tr>
<tr class="memdesc:gab73dcc0df1012caf66620aa7c56b2592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install or remove a callback function to be called whenever the debug layer generates a message.  <a href="group__nvn__c__functions.html#gab73dcc0df1012caf66620aa7c56b2592">More...</a><br /></td></tr>
<tr class="separator:gab73dcc0df1012caf66620aa7c56b2592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9291748f30602dc5655cd1556fc2eb01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9291748f30602dc5655cd1556fc2eb01">nvnDeviceIsExternalDebuggerAttached</a> (const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device)</td></tr>
<tr class="memdesc:ga9291748f30602dc5655cd1556fc2eb01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if an external debugger is attached when running an NVN application.  <a href="group__nvn__c__functions.html#ga9291748f30602dc5655cd1556fc2eb01">More...</a><br /></td></tr>
<tr class="separator:ga9291748f30602dc5655cd1556fc2eb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace7813b0e44d122d452df918525ef8a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gace7813b0e44d122d452df918525ef8a1">nvnDeviceRegisterFastClearColor</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, const float *color, <a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a> format)</td></tr>
<tr class="memdesc:gace7813b0e44d122d452df918525ef8a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a fast clear color value.  <a href="group__nvn__c__functions.html#gace7813b0e44d122d452df918525ef8a1">More...</a><br /></td></tr>
<tr class="separator:gace7813b0e44d122d452df918525ef8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c2df0951b28828873afc21370d7c010"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1c2df0951b28828873afc21370d7c010">nvnDeviceRegisterFastClearColori</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, const int *color, <a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a> format)</td></tr>
<tr class="memdesc:ga1c2df0951b28828873afc21370d7c010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a signed integer fast clear color value.  <a href="group__nvn__c__functions.html#ga1c2df0951b28828873afc21370d7c010">More...</a><br /></td></tr>
<tr class="separator:ga1c2df0951b28828873afc21370d7c010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cfafa315b6bea064d93dd963eb7b891"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9cfafa315b6bea064d93dd963eb7b891">nvnDeviceRegisterFastClearColorui</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, const uint32_t *color, <a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a> format)</td></tr>
<tr class="memdesc:ga9cfafa315b6bea064d93dd963eb7b891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an unsigned integer fast clear color value.  <a href="group__nvn__c__functions.html#ga9cfafa315b6bea064d93dd963eb7b891">More...</a><br /></td></tr>
<tr class="separator:ga9cfafa315b6bea064d93dd963eb7b891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c9adc51dc192c3e48dc4c0e2e6f2e86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2c9adc51dc192c3e48dc4c0e2e6f2e86">nvnDeviceRegisterFastClearDepth</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, float depth)</td></tr>
<tr class="memdesc:ga2c9adc51dc192c3e48dc4c0e2e6f2e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a fast clear depth value.  <a href="group__nvn__c__functions.html#ga2c9adc51dc192c3e48dc4c0e2e6f2e86">More...</a><br /></td></tr>
<tr class="separator:ga2c9adc51dc192c3e48dc4c0e2e6f2e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd59fdbbc8eafae5e42bd86236e714f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gadd59fdbbc8eafae5e42bd86236e714f8">nvnDeviceSetAutomaticCheckpointsByDebugGroup</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, uint32_t domainId, const char *debugGroupName)</td></tr>
<tr class="memdesc:gadd59fdbbc8eafae5e42bd86236e714f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control automatic checkpoint event markers by debug group.  <a href="group__nvn__c__functions.html#gadd59fdbbc8eafae5e42bd86236e714f8">More...</a><br /></td></tr>
<tr class="separator:gadd59fdbbc8eafae5e42bd86236e714f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99557bee9c57748558aa42d74c1ecbea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga99557bee9c57748558aa42d74c1ecbea">nvnDeviceSetAutomaticCheckpointsEnable</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable)</td></tr>
<tr class="memdesc:ga99557bee9c57748558aa42d74c1ecbea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control automatic checkpoint event markers.  <a href="group__nvn__c__functions.html#ga99557bee9c57748558aa42d74c1ecbea">More...</a><br /></td></tr>
<tr class="separator:ga99557bee9c57748558aa42d74c1ecbea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1f6dccb79d0016bc5f9fadd91bc37f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad1f6dccb79d0016bc5f9fadd91bc37f5">nvnDeviceSetAutomaticCheckpointsMask</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, int mask)</td></tr>
<tr class="memdesc:gad1f6dccb79d0016bc5f9fadd91bc37f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control for which commands automatic checkpoint event markers are added.  <a href="group__nvn__c__functions.html#gad1f6dccb79d0016bc5f9fadd91bc37f5">More...</a><br /></td></tr>
<tr class="separator:gad1f6dccb79d0016bc5f9fadd91bc37f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05a0ec24e19814c9f38c3ae315cc82ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga05a0ec24e19814c9f38c3ae315cc82ed">nvnDeviceSetAutomaticCheckpointsSamplingInterval</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, int interval)</td></tr>
<tr class="memdesc:ga05a0ec24e19814c9f38c3ae315cc82ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control how frequently automatic checkpoint event markers are inserted.  <a href="group__nvn__c__functions.html#ga05a0ec24e19814c9f38c3ae315cc82ed">More...</a><br /></td></tr>
<tr class="separator:ga05a0ec24e19814c9f38c3ae315cc82ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8367dbc5aa88a0efc6b1419cb7fb1a5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8367dbc5aa88a0efc6b1419cb7fb1a5a">nvnDeviceSetCheckpointCallStacksEnable</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable)</td></tr>
<tr class="memdesc:ga8367dbc5aa88a0efc6b1419cb7fb1a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control call stack capture for checkpoint event markers.  <a href="group__nvn__c__functions.html#ga8367dbc5aa88a0efc6b1419cb7fb1a5a">More...</a><br /></td></tr>
<tr class="separator:ga8367dbc5aa88a0efc6b1419cb7fb1a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05b69b6c497c67926c7a0a27cb84181c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga05b69b6c497c67926c7a0a27cb84181c">nvnDeviceSetCheckpointMaxCallStacksDepth</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, int depth)</td></tr>
<tr class="memdesc:ga05b69b6c497c67926c7a0a27cb84181c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control call stack capture depth for checkpoint event markers.  <a href="group__nvn__c__functions.html#ga05b69b6c497c67926c7a0a27cb84181c">More...</a><br /></td></tr>
<tr class="separator:ga05b69b6c497c67926c7a0a27cb84181c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bfa6529d97f627325bd9ac84605a9b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga6bfa6529d97f627325bd9ac84605a9b1">nvnDeviceSetDebugLabel</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, const char *label)</td></tr>
<tr class="memdesc:ga6bfa6529d97f627325bd9ac84605a9b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug label string for a <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> object.  <a href="group__nvn__c__functions.html#ga6bfa6529d97f627325bd9ac84605a9b1">More...</a><br /></td></tr>
<tr class="separator:ga6bfa6529d97f627325bd9ac84605a9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b42972a78ea6d7180106f97a8ef1eec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8b42972a78ea6d7180106f97a8ef1eec">nvnDeviceSetDepthMode</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, <a class="el" href="group__nvn__c__enum.html#ga0e55de1522658c843016e8b24a8ecabd">NVNdepthMode</a> depthMode)</td></tr>
<tr class="memdesc:ga8b42972a78ea6d7180106f97a8ef1eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the global clipping range for normalized depth in clip space.  <a href="group__nvn__c__functions.html#ga8b42972a78ea6d7180106f97a8ef1eec">More...</a><br /></td></tr>
<tr class="separator:ga8b42972a78ea6d7180106f97a8ef1eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbd75784e9651faa3562714bb8b9179e"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gafbd75784e9651faa3562714bb8b9179e">nvnDeviceSetDepthMode_fastpath</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, <a class="el" href="group__nvn__c__enum.html#ga0e55de1522658c843016e8b24a8ecabd">NVNdepthMode</a> depthMode)</td></tr>
<tr class="memdesc:gafbd75784e9651faa3562714bb8b9179e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the global clipping range for normalized depth in clip space.  <a href="group__nvn__c__functions.html#gafbd75784e9651faa3562714bb8b9179e">More...</a><br /></td></tr>
<tr class="separator:gafbd75784e9651faa3562714bb8b9179e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc2c6dd07f2db4dddff39bcd0eff76a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gafc2c6dd07f2db4dddff39bcd0eff76a3">nvnDeviceSetIntermediateShaderCache</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, int numMaxEntries)</td></tr>
<tr class="memdesc:gafc2c6dd07f2db4dddff39bcd0eff76a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the shader cache for the Windows reference platform to store fat binary intermediate results.  <a href="group__nvn__c__functions.html#gafc2c6dd07f2db4dddff39bcd0eff76a3">More...</a><br /></td></tr>
<tr class="separator:gafc2c6dd07f2db4dddff39bcd0eff76a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24c4fdcf11f6dc0bf042566b4da7bba4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga24c4fdcf11f6dc0bf042566b4da7bba4">nvnDeviceSetWindowOriginMode</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, <a class="el" href="group__nvn__c__enum.html#ga52db1bf3e182ec089c43db5a02baecd6">NVNwindowOriginMode</a> windowOriginMode)</td></tr>
<tr class="memdesc:ga24c4fdcf11f6dc0bf042566b4da7bba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the global location for window coordinates (0,0).  <a href="group__nvn__c__functions.html#ga24c4fdcf11f6dc0bf042566b4da7bba4">More...</a><br /></td></tr>
<tr class="separator:ga24c4fdcf11f6dc0bf042566b4da7bba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92c66661dc98041b781cf4b2611ac0b6"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga92c66661dc98041b781cf4b2611ac0b6">nvnDeviceSetWindowOriginMode_fastpath</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, <a class="el" href="group__nvn__c__enum.html#ga52db1bf3e182ec089c43db5a02baecd6">NVNwindowOriginMode</a> windowOriginMode)</td></tr>
<tr class="memdesc:ga92c66661dc98041b781cf4b2611ac0b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the global location for window coordinates (0,0).  <a href="group__nvn__c__functions.html#ga92c66661dc98041b781cf4b2611ac0b6">More...</a><br /></td></tr>
<tr class="separator:ga92c66661dc98041b781cf4b2611ac0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf12100926a7307bf74d86ab68dd59e65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf12100926a7307bf74d86ab68dd59e65">nvnDeviceWalkDebugDatabase</a> (const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, <a class="el" href="group__nvn__c__enum.html#ga1ad0f9413adde3e3c46751c0312564ea">NVNdebugObjectType</a> type, <a class="el" href="group__nvn__c__funcptrs.html#gacf070cc0410c00ecf1430770bb9ed021">PFNNVNWALKDEBUGDATABASECALLBACKPROC</a> callback, void *userParam)</td></tr>
<tr class="memdesc:gaf12100926a7307bf74d86ab68dd59e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk through the debug layer object database.  <a href="group__nvn__c__functions.html#gaf12100926a7307bf74d86ab68dd59e65">More...</a><br /></td></tr>
<tr class="separator:gaf12100926a7307bf74d86ab68dd59e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e667fa73cc3c548f4a951831c471a5c"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1e667fa73cc3c548f4a951831c471a5c">nvnEventBuilderGetMemoryOffset</a> (const <a class="el" href="struct_n_v_nevent_builder.html">NVNeventBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga1e667fa73cc3c548f4a951831c471a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the memory pool offset associated with this <a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects.">NVNeventBuilder</a> object.  <a href="group__nvn__c__functions.html#ga1e667fa73cc3c548f4a951831c471a5c">More...</a><br /></td></tr>
<tr class="separator:ga1e667fa73cc3c548f4a951831c471a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2361f65d66b8967fc7f1a864b055ae84"><td class="memItemLeft" align="right" valign="top">NVNINLINE int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2361f65d66b8967fc7f1a864b055ae84">nvnEventBuilderGetMemoryOffset_fastpath</a> (const <a class="el" href="struct_n_v_nevent_builder.html">NVNeventBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga2361f65d66b8967fc7f1a864b055ae84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the memory pool offset associated with this <a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects.">NVNeventBuilder</a> object.  <a href="group__nvn__c__functions.html#ga2361f65d66b8967fc7f1a864b055ae84">More...</a><br /></td></tr>
<tr class="separator:ga2361f65d66b8967fc7f1a864b055ae84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a91710b2481a42679ee132f0d56fb78"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7a91710b2481a42679ee132f0d56fb78">nvnEventBuilderGetMemoryPool</a> (const <a class="el" href="struct_n_v_nevent_builder.html">NVNeventBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga7a91710b2481a42679ee132f0d56fb78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the memory pool associated with this <a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects.">NVNeventBuilder</a> object.  <a href="group__nvn__c__functions.html#ga7a91710b2481a42679ee132f0d56fb78">More...</a><br /></td></tr>
<tr class="separator:ga7a91710b2481a42679ee132f0d56fb78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8a022cb514b7a57a4918d01871b3b0a"><td class="memItemLeft" align="right" valign="top">NVNINLINE const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaa8a022cb514b7a57a4918d01871b3b0a">nvnEventBuilderGetMemoryPool_fastpath</a> (const <a class="el" href="struct_n_v_nevent_builder.html">NVNeventBuilder</a> *builder)</td></tr>
<tr class="memdesc:gaa8a022cb514b7a57a4918d01871b3b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the memory pool associated with this <a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects.">NVNeventBuilder</a> object.  <a href="group__nvn__c__functions.html#gaa8a022cb514b7a57a4918d01871b3b0a">More...</a><br /></td></tr>
<tr class="separator:gaa8a022cb514b7a57a4918d01871b3b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga798a91d0cfa6b69b33678a78631f6d38"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga798a91d0cfa6b69b33678a78631f6d38">nvnEventBuilderGetStorage</a> (const <a class="el" href="struct_n_v_nevent_builder.html">NVNeventBuilder</a> *builder, int64_t *offset)</td></tr>
<tr class="memdesc:ga798a91d0cfa6b69b33678a78631f6d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the memory pool and the offset associated with this <a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects.">NVNeventBuilder</a> object.  <a href="group__nvn__c__functions.html#ga798a91d0cfa6b69b33678a78631f6d38">More...</a><br /></td></tr>
<tr class="separator:ga798a91d0cfa6b69b33678a78631f6d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9cbb0430ea71279858b791e61bbddae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf9cbb0430ea71279858b791e61bbddae">nvnEventBuilderSetDefaults</a> (<a class="el" href="struct_n_v_nevent_builder.html">NVNeventBuilder</a> *builder)</td></tr>
<tr class="memdesc:gaf9cbb0430ea71279858b791e61bbddae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects.">NVNeventBuilder</a> object.  <a href="group__nvn__c__functions.html#gaf9cbb0430ea71279858b791e61bbddae">More...</a><br /></td></tr>
<tr class="separator:gaf9cbb0430ea71279858b791e61bbddae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga220c8fbd5686a7d0bb8629205ad0ce7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga220c8fbd5686a7d0bb8629205ad0ce7d">nvnEventBuilderSetStorage</a> (<a class="el" href="struct_n_v_nevent_builder.html">NVNeventBuilder</a> *builder, const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *pool, int64_t offset)</td></tr>
<tr class="memdesc:ga220c8fbd5686a7d0bb8629205ad0ce7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the location in a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> used to hold the state of an <a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> created from the <a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects.">NVNeventBuilder</a>.  <a href="group__nvn__c__functions.html#ga220c8fbd5686a7d0bb8629205ad0ce7d">More...</a><br /></td></tr>
<tr class="separator:ga220c8fbd5686a7d0bb8629205ad0ce7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3396c994019a4149ee5cf81d6fdf368c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3396c994019a4149ee5cf81d6fdf368c">nvnEventFinalize</a> (<a class="el" href="struct_n_v_nevent.html">NVNevent</a> *event)</td></tr>
<tr class="memdesc:ga3396c994019a4149ee5cf81d6fdf368c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object.  <a href="group__nvn__c__functions.html#ga3396c994019a4149ee5cf81d6fdf368c">More...</a><br /></td></tr>
<tr class="separator:ga3396c994019a4149ee5cf81d6fdf368c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9a056dded99e0b175123549802b1e54"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaa9a056dded99e0b175123549802b1e54">nvnEventGetMemoryOffset</a> (const <a class="el" href="struct_n_v_nevent.html">NVNevent</a> *event)</td></tr>
<tr class="memdesc:gaa9a056dded99e0b175123549802b1e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the memory pool offset associated with this <a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object.  <a href="group__nvn__c__functions.html#gaa9a056dded99e0b175123549802b1e54">More...</a><br /></td></tr>
<tr class="separator:gaa9a056dded99e0b175123549802b1e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8be19e0ecd2669f0d428f2cf52cccfa"><td class="memItemLeft" align="right" valign="top">NVNINLINE int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf8be19e0ecd2669f0d428f2cf52cccfa">nvnEventGetMemoryOffset_fastpath</a> (const <a class="el" href="struct_n_v_nevent.html">NVNevent</a> *event)</td></tr>
<tr class="memdesc:gaf8be19e0ecd2669f0d428f2cf52cccfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the memory pool offset associated with this <a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object.  <a href="group__nvn__c__functions.html#gaf8be19e0ecd2669f0d428f2cf52cccfa">More...</a><br /></td></tr>
<tr class="separator:gaf8be19e0ecd2669f0d428f2cf52cccfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28078a24c2d5dda89524575e17d8424e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga28078a24c2d5dda89524575e17d8424e">nvnEventGetMemoryPool</a> (const <a class="el" href="struct_n_v_nevent.html">NVNevent</a> *event)</td></tr>
<tr class="memdesc:ga28078a24c2d5dda89524575e17d8424e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the memory pool associated with this <a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object.  <a href="group__nvn__c__functions.html#ga28078a24c2d5dda89524575e17d8424e">More...</a><br /></td></tr>
<tr class="separator:ga28078a24c2d5dda89524575e17d8424e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac181724f3d88162a0534c9a96402864c"><td class="memItemLeft" align="right" valign="top">NVNINLINE const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac181724f3d88162a0534c9a96402864c">nvnEventGetMemoryPool_fastpath</a> (const <a class="el" href="struct_n_v_nevent.html">NVNevent</a> *event)</td></tr>
<tr class="memdesc:gac181724f3d88162a0534c9a96402864c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the memory pool associated with this <a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object.  <a href="group__nvn__c__functions.html#gac181724f3d88162a0534c9a96402864c">More...</a><br /></td></tr>
<tr class="separator:gac181724f3d88162a0534c9a96402864c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95d214178cd0d00385e74cba7b2c2b76"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga95d214178cd0d00385e74cba7b2c2b76">nvnEventGetValue</a> (const <a class="el" href="struct_n_v_nevent.html">NVNevent</a> *event)</td></tr>
<tr class="memdesc:ga95d214178cd0d00385e74cba7b2c2b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value associated with an <a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object.  <a href="group__nvn__c__functions.html#ga95d214178cd0d00385e74cba7b2c2b76">More...</a><br /></td></tr>
<tr class="separator:ga95d214178cd0d00385e74cba7b2c2b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga969cdf368faed960c33d23f25d72e16b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga969cdf368faed960c33d23f25d72e16b">nvnEventInitialize</a> (<a class="el" href="struct_n_v_nevent.html">NVNevent</a> *event, const <a class="el" href="struct_n_v_nevent_builder.html">NVNeventBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga969cdf368faed960c33d23f25d72e16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an <a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object.  <a href="group__nvn__c__functions.html#ga969cdf368faed960c33d23f25d72e16b">More...</a><br /></td></tr>
<tr class="separator:ga969cdf368faed960c33d23f25d72e16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ea5599a30f15446978d9b535e3aabf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8ea5599a30f15446978d9b535e3aabf9">nvnEventSignal</a> (<a class="el" href="struct_n_v_nevent.html">NVNevent</a> *event, <a class="el" href="group__nvn__c__enum.html#gae0c7c9637d4f93ea56fc315c97f17a7e">NVNeventSignalMode</a> mode, uint32_t value)</td></tr>
<tr class="memdesc:ga8ea5599a30f15446978d9b535e3aabf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the CPU to signal an <a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object.  <a href="group__nvn__c__functions.html#ga8ea5599a30f15446978d9b535e3aabf9">More...</a><br /></td></tr>
<tr class="separator:ga8ea5599a30f15446978d9b535e3aabf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40a50e5352cccfa1ba2c2569777b85fa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga40a50e5352cccfa1ba2c2569777b85fa">nvnMemoryPoolBuilderGetDevice</a> (const <a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga40a50e5352cccfa1ba2c2569777b85fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the device associated with a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a>.  <a href="group__nvn__c__functions.html#ga40a50e5352cccfa1ba2c2569777b85fa">More...</a><br /></td></tr>
<tr class="separator:ga40a50e5352cccfa1ba2c2569777b85fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga143237ae7046e5c75f2ba2a50814c261"><td class="memItemLeft" align="right" valign="top">NVNINLINE const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga143237ae7046e5c75f2ba2a50814c261">nvnMemoryPoolBuilderGetDevice_fastpath</a> (const <a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga143237ae7046e5c75f2ba2a50814c261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the device associated with a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a>.  <a href="group__nvn__c__functions.html#ga143237ae7046e5c75f2ba2a50814c261">More...</a><br /></td></tr>
<tr class="separator:ga143237ae7046e5c75f2ba2a50814c261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68a5197066d35e0f2bb74afc79fc0020"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#gaa7df4970255609d7a317631bcb37d654">NVNmemoryPoolFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga68a5197066d35e0f2bb74afc79fc0020">nvnMemoryPoolBuilderGetFlags</a> (const <a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga68a5197066d35e0f2bb74afc79fc0020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the flags associated with a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a>.  <a href="group__nvn__c__functions.html#ga68a5197066d35e0f2bb74afc79fc0020">More...</a><br /></td></tr>
<tr class="separator:ga68a5197066d35e0f2bb74afc79fc0020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fd3be6de491b86c814434acefe29f5f"><td class="memItemLeft" align="right" valign="top">NVNINLINE <a class="el" href="group__nvn__c__enum.html#gaa7df4970255609d7a317631bcb37d654">NVNmemoryPoolFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2fd3be6de491b86c814434acefe29f5f">nvnMemoryPoolBuilderGetFlags_fastpath</a> (const <a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga2fd3be6de491b86c814434acefe29f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the flags associated with a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a>.  <a href="group__nvn__c__functions.html#ga2fd3be6de491b86c814434acefe29f5f">More...</a><br /></td></tr>
<tr class="separator:ga2fd3be6de491b86c814434acefe29f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5dd6a5d6a9164d1bddf18cdef18502a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac5dd6a5d6a9164d1bddf18cdef18502a">nvnMemoryPoolBuilderGetMemory</a> (const <a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *builder)</td></tr>
<tr class="memdesc:gac5dd6a5d6a9164d1bddf18cdef18502a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory allocation associated with a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a>.  <a href="group__nvn__c__functions.html#gac5dd6a5d6a9164d1bddf18cdef18502a">More...</a><br /></td></tr>
<tr class="separator:gac5dd6a5d6a9164d1bddf18cdef18502a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafda9fa9a9327ab0a61835e1eddda205e"><td class="memItemLeft" align="right" valign="top">NVNINLINE void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gafda9fa9a9327ab0a61835e1eddda205e">nvnMemoryPoolBuilderGetMemory_fastpath</a> (const <a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *builder)</td></tr>
<tr class="memdesc:gafda9fa9a9327ab0a61835e1eddda205e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory allocation associated with a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a>.  <a href="group__nvn__c__functions.html#gafda9fa9a9327ab0a61835e1eddda205e">More...</a><br /></td></tr>
<tr class="separator:gafda9fa9a9327ab0a61835e1eddda205e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga692de7a3a6d9d318a39ea376a096097e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga692de7a3a6d9d318a39ea376a096097e">nvnMemoryPoolBuilderGetSize</a> (const <a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga692de7a3a6d9d318a39ea376a096097e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the size associated with a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a>.  <a href="group__nvn__c__functions.html#ga692de7a3a6d9d318a39ea376a096097e">More...</a><br /></td></tr>
<tr class="separator:ga692de7a3a6d9d318a39ea376a096097e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad772c1c13b0da3a947b59b4d20e763ef"><td class="memItemLeft" align="right" valign="top">NVNINLINE size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad772c1c13b0da3a947b59b4d20e763ef">nvnMemoryPoolBuilderGetSize_fastpath</a> (const <a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *builder)</td></tr>
<tr class="memdesc:gad772c1c13b0da3a947b59b4d20e763ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the size associated with a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a>.  <a href="group__nvn__c__functions.html#gad772c1c13b0da3a947b59b4d20e763ef">More...</a><br /></td></tr>
<tr class="separator:gad772c1c13b0da3a947b59b4d20e763ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa17de90ba16494d5076a9a0dba9185d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaaa17de90ba16494d5076a9a0dba9185d">nvnMemoryPoolBuilderSetDefaults</a> (<a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *builder)</td></tr>
<tr class="memdesc:gaaa17de90ba16494d5076a9a0dba9185d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a> object.  <a href="group__nvn__c__functions.html#gaaa17de90ba16494d5076a9a0dba9185d">More...</a><br /></td></tr>
<tr class="separator:gaaa17de90ba16494d5076a9a0dba9185d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacafb3b85111e530155835f1048360d59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gacafb3b85111e530155835f1048360d59">nvnMemoryPoolBuilderSetDevice</a> (<a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *builder, <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device)</td></tr>
<tr class="memdesc:gacafb3b85111e530155835f1048360d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> associated with a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a> object.  <a href="group__nvn__c__functions.html#gacafb3b85111e530155835f1048360d59">More...</a><br /></td></tr>
<tr class="separator:gacafb3b85111e530155835f1048360d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga332d877a6825cf3af6904c9615935daa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga332d877a6825cf3af6904c9615935daa">nvnMemoryPoolBuilderSetFlags</a> (<a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *builder, int flags)</td></tr>
<tr class="memdesc:ga332d877a6825cf3af6904c9615935daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set properties of <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> objects created from the builder.  <a href="group__nvn__c__functions.html#ga332d877a6825cf3af6904c9615935daa">More...</a><br /></td></tr>
<tr class="separator:ga332d877a6825cf3af6904c9615935daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86c5f0efe19800f8571930177679853f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga86c5f0efe19800f8571930177679853f">nvnMemoryPoolBuilderSetStorage</a> (<a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *builder, void *memory, size_t size)</td></tr>
<tr class="memdesc:ga86c5f0efe19800f8571930177679853f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides memory to be used by memory pools initialized using a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a>.  <a href="group__nvn__c__functions.html#ga86c5f0efe19800f8571930177679853f">More...</a><br /></td></tr>
<tr class="separator:ga86c5f0efe19800f8571930177679853f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cc130f7dcc64cd765e0b74a8c10e448"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4cc130f7dcc64cd765e0b74a8c10e448">nvnMemoryPoolFinalize</a> (<a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *pool)</td></tr>
<tr class="memdesc:ga4cc130f7dcc64cd765e0b74a8c10e448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> object.  <a href="group__nvn__c__functions.html#ga4cc130f7dcc64cd765e0b74a8c10e448">More...</a><br /></td></tr>
<tr class="separator:ga4cc130f7dcc64cd765e0b74a8c10e448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f76c329bcb4a9420bc4c6bc29f762e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9f76c329bcb4a9420bc4c6bc29f762e3">nvnMemoryPoolFlushMappedRange</a> (const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *pool, ptrdiff_t offset, size_t size)</td></tr>
<tr class="memdesc:ga9f76c329bcb4a9420bc4c6bc29f762e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush previous CPU writes to a range of the memory pool to be visible to the GPU.  <a href="group__nvn__c__functions.html#ga9f76c329bcb4a9420bc4c6bc29f762e3">More...</a><br /></td></tr>
<tr class="separator:ga9f76c329bcb4a9420bc4c6bc29f762e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1c21d6dc85c6325013b0e782998fbdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac1c21d6dc85c6325013b0e782998fbdb">nvnMemoryPoolGetBufferAddress</a> (const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *pool)</td></tr>
<tr class="memdesc:gac1c21d6dc85c6325013b0e782998fbdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the GPU address of the data store of a memory pool object.  <a href="group__nvn__c__functions.html#gac1c21d6dc85c6325013b0e782998fbdb">More...</a><br /></td></tr>
<tr class="separator:gac1c21d6dc85c6325013b0e782998fbdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaae82797756975754c0e3f141c66a524"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#gaa7df4970255609d7a317631bcb37d654">NVNmemoryPoolFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaaae82797756975754c0e3f141c66a524">nvnMemoryPoolGetFlags</a> (const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *pool)</td></tr>
<tr class="memdesc:gaaae82797756975754c0e3f141c66a524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the flags associated with a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> object.  <a href="group__nvn__c__functions.html#gaaae82797756975754c0e3f141c66a524">More...</a><br /></td></tr>
<tr class="separator:gaaae82797756975754c0e3f141c66a524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ab20a3416a36855861741c3305c2d80"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1ab20a3416a36855861741c3305c2d80">nvnMemoryPoolGetSize</a> (const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *pool)</td></tr>
<tr class="memdesc:ga1ab20a3416a36855861741c3305c2d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the size associated with a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> object.  <a href="group__nvn__c__functions.html#ga1ab20a3416a36855861741c3305c2d80">More...</a><br /></td></tr>
<tr class="separator:ga1ab20a3416a36855861741c3305c2d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae78de6694c8b1b054050dcc1b82bb20d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae78de6694c8b1b054050dcc1b82bb20d">nvnMemoryPoolInitialize</a> (<a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *pool, const <a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *builder)</td></tr>
<tr class="memdesc:gae78de6694c8b1b054050dcc1b82bb20d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> object using a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a> object.  <a href="group__nvn__c__functions.html#gae78de6694c8b1b054050dcc1b82bb20d">More...</a><br /></td></tr>
<tr class="separator:gae78de6694c8b1b054050dcc1b82bb20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc7ba26caa615b7f4abb81de4ed6205e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gabc7ba26caa615b7f4abb81de4ed6205e">nvnMemoryPoolInvalidateMappedRange</a> (const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *pool, ptrdiff_t offset, size_t size)</td></tr>
<tr class="memdesc:gabc7ba26caa615b7f4abb81de4ed6205e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate CPU caches for a range of the memory pool that may have been written by the GPU.  <a href="group__nvn__c__functions.html#gabc7ba26caa615b7f4abb81de4ed6205e">More...</a><br /></td></tr>
<tr class="separator:gabc7ba26caa615b7f4abb81de4ed6205e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga072ffc85fe3f8ae544f3c788b192be77"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga072ffc85fe3f8ae544f3c788b192be77">nvnMemoryPoolMap</a> (const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *pool)</td></tr>
<tr class="memdesc:ga072ffc85fe3f8ae544f3c788b192be77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a CPU pointer to the memory owned by the <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> object.  <a href="group__nvn__c__functions.html#ga072ffc85fe3f8ae544f3c788b192be77">More...</a><br /></td></tr>
<tr class="separator:ga072ffc85fe3f8ae544f3c788b192be77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6dac6504ee2c716377f6dce9cede4e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae6dac6504ee2c716377f6dce9cede4e1">nvnMemoryPoolMapVirtual</a> (<a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *virtualPool, int numRequests, const <a class="el" href="struct_n_v_nmapping_request.html">NVNmappingRequest</a> *requests)</td></tr>
<tr class="memdesc:gae6dac6504ee2c716377f6dce9cede4e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map memory pages from physical memory pools into a virtual memory pool.  <a href="group__nvn__c__functions.html#gae6dac6504ee2c716377f6dce9cede4e1">More...</a><br /></td></tr>
<tr class="separator:gae6dac6504ee2c716377f6dce9cede4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d256413a09dc0163d78749b7e8756b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga6d256413a09dc0163d78749b7e8756b6">nvnMemoryPoolSetDebugLabel</a> (<a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *pool, const char *label)</td></tr>
<tr class="memdesc:ga6d256413a09dc0163d78749b7e8756b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug label string for a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> object.  <a href="group__nvn__c__functions.html#ga6d256413a09dc0163d78749b7e8756b6">More...</a><br /></td></tr>
<tr class="separator:ga6d256413a09dc0163d78749b7e8756b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga172c7ccc42da8dbc211c9d8f8dc383dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga172c7ccc42da8dbc211c9d8f8dc383dd">nvnMultisampleStateGetAlphaToCoverageDither</a> (const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:ga172c7ccc42da8dbc211c9d8f8dc383dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the alpha-to-coverage dithering enable.  <a href="group__nvn__c__functions.html#ga172c7ccc42da8dbc211c9d8f8dc383dd">More...</a><br /></td></tr>
<tr class="separator:ga172c7ccc42da8dbc211c9d8f8dc383dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga165ffe961a05d447344d3a364f97deb8"><td class="memItemLeft" align="right" valign="top">NVNINLINE <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga165ffe961a05d447344d3a364f97deb8">nvnMultisampleStateGetAlphaToCoverageDither_fastpath</a> (const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:ga165ffe961a05d447344d3a364f97deb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the alpha-to-coverage dithering enable.  <a href="group__nvn__c__functions.html#ga165ffe961a05d447344d3a364f97deb8">More...</a><br /></td></tr>
<tr class="separator:ga165ffe961a05d447344d3a364f97deb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga709089315b48eb90eb3cf781957c9dc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga709089315b48eb90eb3cf781957c9dc9">nvnMultisampleStateGetAlphaToCoverageEnable</a> (const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:ga709089315b48eb90eb3cf781957c9dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the alpha-to-coverage enable.  <a href="group__nvn__c__functions.html#ga709089315b48eb90eb3cf781957c9dc9">More...</a><br /></td></tr>
<tr class="separator:ga709089315b48eb90eb3cf781957c9dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab73a7a751bd29625291bdbd689ef38f8"><td class="memItemLeft" align="right" valign="top">NVNINLINE <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab73a7a751bd29625291bdbd689ef38f8">nvnMultisampleStateGetAlphaToCoverageEnable_fastpath</a> (const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:gab73a7a751bd29625291bdbd689ef38f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the alpha-to-coverage enable.  <a href="group__nvn__c__functions.html#gab73a7a751bd29625291bdbd689ef38f8">More...</a><br /></td></tr>
<tr class="separator:gab73a7a751bd29625291bdbd689ef38f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfac452c21527aeb1043008e5924564d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga26f01c2daca8e41b2961de31a9079501">NVNcoverageModulationMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gabfac452c21527aeb1043008e5924564d">nvnMultisampleStateGetCoverageModulationMode</a> (const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:gabfac452c21527aeb1043008e5924564d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the coverage modulation mode for target-independent rasterization.  <a href="group__nvn__c__functions.html#gabfac452c21527aeb1043008e5924564d">More...</a><br /></td></tr>
<tr class="separator:gabfac452c21527aeb1043008e5924564d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0713e246ce816f781da8e21ab070194a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0713e246ce816f781da8e21ab070194a">nvnMultisampleStateGetCoverageToColorEnable</a> (const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:ga0713e246ce816f781da8e21ab070194a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the enable for the fragment coverage-to-color feature.  <a href="group__nvn__c__functions.html#ga0713e246ce816f781da8e21ab070194a">More...</a><br /></td></tr>
<tr class="separator:ga0713e246ce816f781da8e21ab070194a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4293a2fa489afa5f8e0dd558dd2c129"><td class="memItemLeft" align="right" valign="top">NVNINLINE <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad4293a2fa489afa5f8e0dd558dd2c129">nvnMultisampleStateGetCoverageToColorEnable_fastpath</a> (const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:gad4293a2fa489afa5f8e0dd558dd2c129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the enable for the fragment coverage-to-color feature.  <a href="group__nvn__c__functions.html#gad4293a2fa489afa5f8e0dd558dd2c129">More...</a><br /></td></tr>
<tr class="separator:gad4293a2fa489afa5f8e0dd558dd2c129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e1d59807858c15163a9b4be1959b8e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9e1d59807858c15163a9b4be1959b8e8">nvnMultisampleStateGetCoverageToColorOutput</a> (const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:ga9e1d59807858c15163a9b4be1959b8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the color output updated by the fragment coverage-to-color feature.  <a href="group__nvn__c__functions.html#ga9e1d59807858c15163a9b4be1959b8e8">More...</a><br /></td></tr>
<tr class="separator:ga9e1d59807858c15163a9b4be1959b8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2147839d3cd2c0a9359ef536f8980dc"><td class="memItemLeft" align="right" valign="top">NVNINLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf2147839d3cd2c0a9359ef536f8980dc">nvnMultisampleStateGetCoverageToColorOutput_fastpath</a> (const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:gaf2147839d3cd2c0a9359ef536f8980dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the color output updated by the fragment coverage-to-color feature.  <a href="group__nvn__c__functions.html#gaf2147839d3cd2c0a9359ef536f8980dc">More...</a><br /></td></tr>
<tr class="separator:gaf2147839d3cd2c0a9359ef536f8980dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7f67824bc1e151868f8d1cd2a1ce1c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab7f67824bc1e151868f8d1cd2a1ce1c6">nvnMultisampleStateGetMultisampleEnable</a> (const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:gab7f67824bc1e151868f8d1cd2a1ce1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the multisample rasterization enable.  <a href="group__nvn__c__functions.html#gab7f67824bc1e151868f8d1cd2a1ce1c6">More...</a><br /></td></tr>
<tr class="separator:gab7f67824bc1e151868f8d1cd2a1ce1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga030dc03728226ce80514f6c25bb94dbf"><td class="memItemLeft" align="right" valign="top">NVNINLINE <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga030dc03728226ce80514f6c25bb94dbf">nvnMultisampleStateGetMultisampleEnable_fastpath</a> (const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:ga030dc03728226ce80514f6c25bb94dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the multisample rasterization enable.  <a href="group__nvn__c__functions.html#ga030dc03728226ce80514f6c25bb94dbf">More...</a><br /></td></tr>
<tr class="separator:ga030dc03728226ce80514f6c25bb94dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8a5728de499b27f27bff6f41be25aa2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf8a5728de499b27f27bff6f41be25aa2">nvnMultisampleStateGetRasterSamples</a> (const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:gaf8a5728de499b27f27bff6f41be25aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the raster sample count for target-independent rasterization.  <a href="group__nvn__c__functions.html#gaf8a5728de499b27f27bff6f41be25aa2">More...</a><br /></td></tr>
<tr class="separator:gaf8a5728de499b27f27bff6f41be25aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d829875d3a027916c5bc0fcb7a932d5"><td class="memItemLeft" align="right" valign="top">NVNINLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0d829875d3a027916c5bc0fcb7a932d5">nvnMultisampleStateGetRasterSamples_fastpath</a> (const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:ga0d829875d3a027916c5bc0fcb7a932d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the raster sample count for target-independent rasterization.  <a href="group__nvn__c__functions.html#ga0d829875d3a027916c5bc0fcb7a932d5">More...</a><br /></td></tr>
<tr class="separator:ga0d829875d3a027916c5bc0fcb7a932d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf91e203d2f30a7a960993c14826b3a2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf91e203d2f30a7a960993c14826b3a2f">nvnMultisampleStateGetSampleLocationsEnable</a> (const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:gaf91e203d2f30a7a960993c14826b3a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the programmable sample locations enable.  <a href="group__nvn__c__functions.html#gaf91e203d2f30a7a960993c14826b3a2f">More...</a><br /></td></tr>
<tr class="separator:gaf91e203d2f30a7a960993c14826b3a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e266660a7c1aa3fb1aa800019924eaf"><td class="memItemLeft" align="right" valign="top">NVNINLINE <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga6e266660a7c1aa3fb1aa800019924eaf">nvnMultisampleStateGetSampleLocationsEnable_fastpath</a> (const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:ga6e266660a7c1aa3fb1aa800019924eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the programmable sample locations enable.  <a href="group__nvn__c__functions.html#ga6e266660a7c1aa3fb1aa800019924eaf">More...</a><br /></td></tr>
<tr class="separator:ga6e266660a7c1aa3fb1aa800019924eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41a34fd884435c3a3de1089633068740"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga41a34fd884435c3a3de1089633068740">nvnMultisampleStateGetSampleLocationsGrid</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, int *width, int *height)</td></tr>
<tr class="memdesc:ga41a34fd884435c3a3de1089633068740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the size of a pixel grid used for programmable sample locations.  <a href="group__nvn__c__functions.html#ga41a34fd884435c3a3de1089633068740">More...</a><br /></td></tr>
<tr class="separator:ga41a34fd884435c3a3de1089633068740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87e1af29088e21596f0e4d5744777498"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga87e1af29088e21596f0e4d5744777498">nvnMultisampleStateGetSampleLocationsGridEnable</a> (const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:ga87e1af29088e21596f0e4d5744777498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the programmable sample locations grid enable.  <a href="group__nvn__c__functions.html#ga87e1af29088e21596f0e4d5744777498">More...</a><br /></td></tr>
<tr class="separator:ga87e1af29088e21596f0e4d5744777498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53c1fb5d3917bc019271764ee7f8b9ce"><td class="memItemLeft" align="right" valign="top">NVNINLINE <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga53c1fb5d3917bc019271764ee7f8b9ce">nvnMultisampleStateGetSampleLocationsGridEnable_fastpath</a> (const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:ga53c1fb5d3917bc019271764ee7f8b9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the programmable sample locations grid enable.  <a href="group__nvn__c__functions.html#ga53c1fb5d3917bc019271764ee7f8b9ce">More...</a><br /></td></tr>
<tr class="separator:ga53c1fb5d3917bc019271764ee7f8b9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8aa20b9525683eeca5f07d1c40db4078"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8aa20b9525683eeca5f07d1c40db4078">nvnMultisampleStateGetSamples</a> (const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:ga8aa20b9525683eeca5f07d1c40db4078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of samples in a <a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object.  <a href="group__nvn__c__functions.html#ga8aa20b9525683eeca5f07d1c40db4078">More...</a><br /></td></tr>
<tr class="separator:ga8aa20b9525683eeca5f07d1c40db4078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d803306cbbc3edbb66ffeb1a06794ae"><td class="memItemLeft" align="right" valign="top">NVNINLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4d803306cbbc3edbb66ffeb1a06794ae">nvnMultisampleStateGetSamples_fastpath</a> (const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:ga4d803306cbbc3edbb66ffeb1a06794ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of samples in a <a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object.  <a href="group__nvn__c__functions.html#ga4d803306cbbc3edbb66ffeb1a06794ae">More...</a><br /></td></tr>
<tr class="separator:ga4d803306cbbc3edbb66ffeb1a06794ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc12eb75e49cd73800ac71eac99e4008"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gabc12eb75e49cd73800ac71eac99e4008">nvnMultisampleStateSetAlphaToCoverageDither</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> dither)</td></tr>
<tr class="memdesc:gabc12eb75e49cd73800ac71eac99e4008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable dithering in the alpha-to-coverage operation.  <a href="group__nvn__c__functions.html#gabc12eb75e49cd73800ac71eac99e4008">More...</a><br /></td></tr>
<tr class="separator:gabc12eb75e49cd73800ac71eac99e4008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga442665a5bf95bbdc90e57e1eabdc8451"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga442665a5bf95bbdc90e57e1eabdc8451">nvnMultisampleStateSetAlphaToCoverageDither_fastpath</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> dither)</td></tr>
<tr class="memdesc:ga442665a5bf95bbdc90e57e1eabdc8451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable dithering in the alpha-to-coverage operation.  <a href="group__nvn__c__functions.html#ga442665a5bf95bbdc90e57e1eabdc8451">More...</a><br /></td></tr>
<tr class="separator:ga442665a5bf95bbdc90e57e1eabdc8451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3837dd1e28700073cfd34479a6a2e677"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3837dd1e28700073cfd34479a6a2e677">nvnMultisampleStateSetAlphaToCoverageEnable</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable)</td></tr>
<tr class="memdesc:ga3837dd1e28700073cfd34479a6a2e677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable alpha-to-coverage operation.  <a href="group__nvn__c__functions.html#ga3837dd1e28700073cfd34479a6a2e677">More...</a><br /></td></tr>
<tr class="separator:ga3837dd1e28700073cfd34479a6a2e677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50a2f81139dd5987bbd1edd0e224553c"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga50a2f81139dd5987bbd1edd0e224553c">nvnMultisampleStateSetAlphaToCoverageEnable_fastpath</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable)</td></tr>
<tr class="memdesc:ga50a2f81139dd5987bbd1edd0e224553c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable alpha-to-coverage operation.  <a href="group__nvn__c__functions.html#ga50a2f81139dd5987bbd1edd0e224553c">More...</a><br /></td></tr>
<tr class="separator:ga50a2f81139dd5987bbd1edd0e224553c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab15dd40cc4d6671ec613598a489f99ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab15dd40cc4d6671ec613598a489f99ef">nvnMultisampleStateSetCoverageModulationMode</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, <a class="el" href="group__nvn__c__enum.html#ga26f01c2daca8e41b2961de31a9079501">NVNcoverageModulationMode</a> mode)</td></tr>
<tr class="memdesc:gab15dd40cc4d6671ec613598a489f99ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the coverage modulation mode for target-independent rasterization.  <a href="group__nvn__c__functions.html#gab15dd40cc4d6671ec613598a489f99ef">More...</a><br /></td></tr>
<tr class="separator:gab15dd40cc4d6671ec613598a489f99ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b504018fe751259ef755cc2113613c7"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4b504018fe751259ef755cc2113613c7">nvnMultisampleStateSetCoverageModulationMode_fastpath</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, <a class="el" href="group__nvn__c__enum.html#ga26f01c2daca8e41b2961de31a9079501">NVNcoverageModulationMode</a> mode)</td></tr>
<tr class="memdesc:ga4b504018fe751259ef755cc2113613c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the coverage modulation mode for target-independent rasterization.  <a href="group__nvn__c__functions.html#ga4b504018fe751259ef755cc2113613c7">More...</a><br /></td></tr>
<tr class="separator:ga4b504018fe751259ef755cc2113613c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbf2410e5a0f923e692f3223cf49935c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gabbf2410e5a0f923e692f3223cf49935c">nvnMultisampleStateSetCoverageToColorEnable</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable)</td></tr>
<tr class="memdesc:gabbf2410e5a0f923e692f3223cf49935c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the fragment coverage-to-color feature.  <a href="group__nvn__c__functions.html#gabbf2410e5a0f923e692f3223cf49935c">More...</a><br /></td></tr>
<tr class="separator:gabbf2410e5a0f923e692f3223cf49935c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbea1fe9392579207a1c50816cdc62f0"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gadbea1fe9392579207a1c50816cdc62f0">nvnMultisampleStateSetCoverageToColorEnable_fastpath</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable)</td></tr>
<tr class="memdesc:gadbea1fe9392579207a1c50816cdc62f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the fragment coverage-to-color feature.  <a href="group__nvn__c__functions.html#gadbea1fe9392579207a1c50816cdc62f0">More...</a><br /></td></tr>
<tr class="separator:gadbea1fe9392579207a1c50816cdc62f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09d3ac530fffb5efaac50748ff4873f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga09d3ac530fffb5efaac50748ff4873f9">nvnMultisampleStateSetCoverageToColorOutput</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, int color)</td></tr>
<tr class="memdesc:ga09d3ac530fffb5efaac50748ff4873f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the color output updated by the fragment coverage-to-color feature.  <a href="group__nvn__c__functions.html#ga09d3ac530fffb5efaac50748ff4873f9">More...</a><br /></td></tr>
<tr class="separator:ga09d3ac530fffb5efaac50748ff4873f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51c0ef641afbcef76c82ae5a342057d0"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga51c0ef641afbcef76c82ae5a342057d0">nvnMultisampleStateSetCoverageToColorOutput_fastpath</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, int color)</td></tr>
<tr class="memdesc:ga51c0ef641afbcef76c82ae5a342057d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the color output updated by the fragment coverage-to-color feature.  <a href="group__nvn__c__functions.html#ga51c0ef641afbcef76c82ae5a342057d0">More...</a><br /></td></tr>
<tr class="separator:ga51c0ef641afbcef76c82ae5a342057d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d649ca21de18dd8b544c8006d6612d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0d649ca21de18dd8b544c8006d6612d8">nvnMultisampleStateSetDefaults</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:ga0d649ca21de18dd8b544c8006d6612d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object.  <a href="group__nvn__c__functions.html#ga0d649ca21de18dd8b544c8006d6612d8">More...</a><br /></td></tr>
<tr class="separator:ga0d649ca21de18dd8b544c8006d6612d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f1d552844cb1b2388d012cb80d094ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7f1d552844cb1b2388d012cb80d094ea">nvnMultisampleStateSetMultisampleEnable</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable)</td></tr>
<tr class="memdesc:ga7f1d552844cb1b2388d012cb80d094ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable multisample rasterization.  <a href="group__nvn__c__functions.html#ga7f1d552844cb1b2388d012cb80d094ea">More...</a><br /></td></tr>
<tr class="separator:ga7f1d552844cb1b2388d012cb80d094ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60abfbd8dd83007831c1e50de6c0a1e6"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga60abfbd8dd83007831c1e50de6c0a1e6">nvnMultisampleStateSetMultisampleEnable_fastpath</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable)</td></tr>
<tr class="memdesc:ga60abfbd8dd83007831c1e50de6c0a1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable multisample rasterization.  <a href="group__nvn__c__functions.html#ga60abfbd8dd83007831c1e50de6c0a1e6">More...</a><br /></td></tr>
<tr class="separator:ga60abfbd8dd83007831c1e50de6c0a1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae00fe1081ea4ab7c88803a66283990d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae00fe1081ea4ab7c88803a66283990d2">nvnMultisampleStateSetRasterSamples</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, int rasterSamples)</td></tr>
<tr class="memdesc:gae00fe1081ea4ab7c88803a66283990d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the raster sample count for target-independent rasterization.  <a href="group__nvn__c__functions.html#gae00fe1081ea4ab7c88803a66283990d2">More...</a><br /></td></tr>
<tr class="separator:gae00fe1081ea4ab7c88803a66283990d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga436ec90542fecfa208d6e972fcbb2e9f"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga436ec90542fecfa208d6e972fcbb2e9f">nvnMultisampleStateSetRasterSamples_fastpath</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, int rasterSamples)</td></tr>
<tr class="memdesc:ga436ec90542fecfa208d6e972fcbb2e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the raster sample count for target-independent rasterization.  <a href="group__nvn__c__functions.html#ga436ec90542fecfa208d6e972fcbb2e9f">More...</a><br /></td></tr>
<tr class="separator:ga436ec90542fecfa208d6e972fcbb2e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab91f126da720035da293ef8bd7f527b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab91f126da720035da293ef8bd7f527b1">nvnMultisampleStateSetSampleLocations</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, int start, int count, const float *values)</td></tr>
<tr class="memdesc:gab91f126da720035da293ef8bd7f527b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies programmable sample locations for rasterization.  <a href="group__nvn__c__functions.html#gab91f126da720035da293ef8bd7f527b1">More...</a><br /></td></tr>
<tr class="separator:gab91f126da720035da293ef8bd7f527b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga882228d131ff8d2ca6f0ba72d4a9182c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga882228d131ff8d2ca6f0ba72d4a9182c">nvnMultisampleStateSetSampleLocationsEnable</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable)</td></tr>
<tr class="memdesc:ga882228d131ff8d2ca6f0ba72d4a9182c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable programmable sample locations.  <a href="group__nvn__c__functions.html#ga882228d131ff8d2ca6f0ba72d4a9182c">More...</a><br /></td></tr>
<tr class="separator:ga882228d131ff8d2ca6f0ba72d4a9182c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga058d52c5580ec2a084eebdae519f6757"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga058d52c5580ec2a084eebdae519f6757">nvnMultisampleStateSetSampleLocationsEnable_fastpath</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable)</td></tr>
<tr class="memdesc:ga058d52c5580ec2a084eebdae519f6757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable programmable sample locations.  <a href="group__nvn__c__functions.html#ga058d52c5580ec2a084eebdae519f6757">More...</a><br /></td></tr>
<tr class="separator:ga058d52c5580ec2a084eebdae519f6757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga705b9946424e5f6e727adae9eae7ace5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga705b9946424e5f6e727adae9eae7ace5">nvnMultisampleStateSetSampleLocationsGridEnable</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable)</td></tr>
<tr class="memdesc:ga705b9946424e5f6e727adae9eae7ace5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the programmable sample locations grid enable.  <a href="group__nvn__c__functions.html#ga705b9946424e5f6e727adae9eae7ace5">More...</a><br /></td></tr>
<tr class="separator:ga705b9946424e5f6e727adae9eae7ace5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade1af4f73dc51c1d409a5bd7366c9cc0"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gade1af4f73dc51c1d409a5bd7366c9cc0">nvnMultisampleStateSetSampleLocationsGridEnable_fastpath</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable)</td></tr>
<tr class="memdesc:gade1af4f73dc51c1d409a5bd7366c9cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the programmable sample locations grid enable.  <a href="group__nvn__c__functions.html#gade1af4f73dc51c1d409a5bd7366c9cc0">More...</a><br /></td></tr>
<tr class="separator:gade1af4f73dc51c1d409a5bd7366c9cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc59ccbfdafe205cd8ba04f1795ada6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gafc59ccbfdafe205cd8ba04f1795ada6d">nvnMultisampleStateSetSamples</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, int samples)</td></tr>
<tr class="memdesc:gafc59ccbfdafe205cd8ba04f1795ada6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the number of samples in the framebuffer.  <a href="group__nvn__c__functions.html#gafc59ccbfdafe205cd8ba04f1795ada6d">More...</a><br /></td></tr>
<tr class="separator:gafc59ccbfdafe205cd8ba04f1795ada6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaf62b0c321b135199f65fc7b0890afe"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gabaf62b0c321b135199f65fc7b0890afe">nvnMultisampleStateSetSamples_fastpath</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, int samples)</td></tr>
<tr class="memdesc:gabaf62b0c321b135199f65fc7b0890afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the number of samples in the framebuffer.  <a href="group__nvn__c__functions.html#gabaf62b0c321b135199f65fc7b0890afe">More...</a><br /></td></tr>
<tr class="separator:gabaf62b0c321b135199f65fc7b0890afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bbd7972e1b1ed778eddbf09ff967b32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8bbd7972e1b1ed778eddbf09ff967b32">nvnPolygonStateGetCullFace</a> (const <a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *polygon)</td></tr>
<tr class="memdesc:ga8bbd7972e1b1ed778eddbf09ff967b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the control for culling of front- and back-facing polygons.  <a href="group__nvn__c__functions.html#ga8bbd7972e1b1ed778eddbf09ff967b32">More...</a><br /></td></tr>
<tr class="separator:ga8bbd7972e1b1ed778eddbf09ff967b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga462e3ea6a04c604d1fd83a7ef7c4508c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga77dcac47ffba6330842afbc0c57db3c3">NVNfrontFace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga462e3ea6a04c604d1fd83a7ef7c4508c">nvnPolygonStateGetFrontFace</a> (const <a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *polygon)</td></tr>
<tr class="memdesc:ga462e3ea6a04c604d1fd83a7ef7c4508c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether clockwise or counter-clockwise polygons are considered front-facing.  <a href="group__nvn__c__functions.html#ga462e3ea6a04c604d1fd83a7ef7c4508c">More...</a><br /></td></tr>
<tr class="separator:ga462e3ea6a04c604d1fd83a7ef7c4508c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6b72dd688c4c3e432aacb9af6305520"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#gae34b6e4f02d0dae7198337f940340ec6">NVNpolygonMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac6b72dd688c4c3e432aacb9af6305520">nvnPolygonStateGetPolygonMode</a> (const <a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *polygon)</td></tr>
<tr class="memdesc:gac6b72dd688c4c3e432aacb9af6305520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether polygons are rendered as points, lines, or triangles.  <a href="group__nvn__c__functions.html#gac6b72dd688c4c3e432aacb9af6305520">More...</a><br /></td></tr>
<tr class="separator:gac6b72dd688c4c3e432aacb9af6305520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27a048c2d766c7f3f46f828eb9d963de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga04590c619164a552f5c23b8f096b3d73">NVNpolygonOffsetEnable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga27a048c2d766c7f3f46f828eb9d963de">nvnPolygonStateGetPolygonOffsetEnables</a> (const <a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *polygon)</td></tr>
<tr class="memdesc:ga27a048c2d766c7f3f46f828eb9d963de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether polygon offset is applied for point-mode, line-mode, and filled polygons.  <a href="group__nvn__c__functions.html#ga27a048c2d766c7f3f46f828eb9d963de">More...</a><br /></td></tr>
<tr class="separator:ga27a048c2d766c7f3f46f828eb9d963de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3520bbbee9b5089521912dacdbdbb4b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3520bbbee9b5089521912dacdbdbb4b6">nvnPolygonStateSetCullFace</a> (<a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *polygon, <a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a> face)</td></tr>
<tr class="memdesc:ga3520bbbee9b5089521912dacdbdbb4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify controls for culling of front- and back-facing polygons.  <a href="group__nvn__c__functions.html#ga3520bbbee9b5089521912dacdbdbb4b6">More...</a><br /></td></tr>
<tr class="separator:ga3520bbbee9b5089521912dacdbdbb4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64be3472744af8c53ce8c54c292b4239"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga64be3472744af8c53ce8c54c292b4239">nvnPolygonStateSetCullFace_fastpath</a> (<a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *polygon, <a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a> face)</td></tr>
<tr class="memdesc:ga64be3472744af8c53ce8c54c292b4239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify controls for culling of front- and back-facing polygons.  <a href="group__nvn__c__functions.html#ga64be3472744af8c53ce8c54c292b4239">More...</a><br /></td></tr>
<tr class="separator:ga64be3472744af8c53ce8c54c292b4239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47c2200da77cbb2c0d7279ecb9311525"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga47c2200da77cbb2c0d7279ecb9311525">nvnPolygonStateSetDefaults</a> (<a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *polygon)</td></tr>
<tr class="memdesc:ga47c2200da77cbb2c0d7279ecb9311525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_npolygon_state.html" title="API state object controlling rasterization of polygons.">NVNpolygonState</a> object.  <a href="group__nvn__c__functions.html#ga47c2200da77cbb2c0d7279ecb9311525">More...</a><br /></td></tr>
<tr class="separator:ga47c2200da77cbb2c0d7279ecb9311525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0de647048323e5c7b6fe8d93a0875cca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0de647048323e5c7b6fe8d93a0875cca">nvnPolygonStateSetFrontFace</a> (<a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *polygon, <a class="el" href="group__nvn__c__enum.html#ga77dcac47ffba6330842afbc0c57db3c3">NVNfrontFace</a> face)</td></tr>
<tr class="memdesc:ga0de647048323e5c7b6fe8d93a0875cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify whether clockwise or counter-clockwise polygons are considered front-facing.  <a href="group__nvn__c__functions.html#ga0de647048323e5c7b6fe8d93a0875cca">More...</a><br /></td></tr>
<tr class="separator:ga0de647048323e5c7b6fe8d93a0875cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8f191f866a32315939c80ff1e895ce3"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaa8f191f866a32315939c80ff1e895ce3">nvnPolygonStateSetFrontFace_fastpath</a> (<a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *polygon, <a class="el" href="group__nvn__c__enum.html#ga77dcac47ffba6330842afbc0c57db3c3">NVNfrontFace</a> face)</td></tr>
<tr class="memdesc:gaa8f191f866a32315939c80ff1e895ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify whether clockwise or counter-clockwise polygons are considered front-facing.  <a href="group__nvn__c__functions.html#gaa8f191f866a32315939c80ff1e895ce3">More...</a><br /></td></tr>
<tr class="separator:gaa8f191f866a32315939c80ff1e895ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5d89993b3e9b7adcee98d5846052cb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae5d89993b3e9b7adcee98d5846052cb5">nvnPolygonStateSetPolygonMode</a> (<a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *polygon, <a class="el" href="group__nvn__c__enum.html#gae34b6e4f02d0dae7198337f940340ec6">NVNpolygonMode</a> polygonMode)</td></tr>
<tr class="memdesc:gae5d89993b3e9b7adcee98d5846052cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether polygons are rendered as points, lines, or triangles.  <a href="group__nvn__c__functions.html#gae5d89993b3e9b7adcee98d5846052cb5">More...</a><br /></td></tr>
<tr class="separator:gae5d89993b3e9b7adcee98d5846052cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b14412334d7d0473ab10b4a7ae2f638"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2b14412334d7d0473ab10b4a7ae2f638">nvnPolygonStateSetPolygonMode_fastpath</a> (<a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *polygon, <a class="el" href="group__nvn__c__enum.html#gae34b6e4f02d0dae7198337f940340ec6">NVNpolygonMode</a> polygonMode)</td></tr>
<tr class="memdesc:ga2b14412334d7d0473ab10b4a7ae2f638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether polygons are rendered as points, lines, or triangles.  <a href="group__nvn__c__functions.html#ga2b14412334d7d0473ab10b4a7ae2f638">More...</a><br /></td></tr>
<tr class="separator:ga2b14412334d7d0473ab10b4a7ae2f638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5351a8bc94ba8da9a23a17d5e01ff2d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga5351a8bc94ba8da9a23a17d5e01ff2d8">nvnPolygonStateSetPolygonOffsetEnables</a> (<a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *polygon, int enables)</td></tr>
<tr class="memdesc:ga5351a8bc94ba8da9a23a17d5e01ff2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify whether polygon offset is applied for point-mode, line-mode, and filled polygons.  <a href="group__nvn__c__functions.html#ga5351a8bc94ba8da9a23a17d5e01ff2d8">More...</a><br /></td></tr>
<tr class="separator:ga5351a8bc94ba8da9a23a17d5e01ff2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24bd32154585c557cea6e061aecb6000"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga24bd32154585c557cea6e061aecb6000">nvnProgramFinalize</a> (<a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *program)</td></tr>
<tr class="memdesc:ga24bd32154585c557cea6e061aecb6000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives.">NVNprogram</a> object.  <a href="group__nvn__c__functions.html#ga24bd32154585c557cea6e061aecb6000">More...</a><br /></td></tr>
<tr class="separator:ga24bd32154585c557cea6e061aecb6000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2194ddf73d0aae8dd2361f03f933a44d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2194ddf73d0aae8dd2361f03f933a44d">nvnProgramGetSubtileSize</a> (const <a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *program)</td></tr>
<tr class="memdesc:ga2194ddf73d0aae8dd2361f03f933a44d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the computed subtile size for a program's fragment shader.  <a href="group__nvn__c__functions.html#ga2194ddf73d0aae8dd2361f03f933a44d">More...</a><br /></td></tr>
<tr class="separator:ga2194ddf73d0aae8dd2361f03f933a44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga872e7fb952779aa76d2643af8c50feab"><td class="memItemLeft" align="right" valign="top">NVNINLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga872e7fb952779aa76d2643af8c50feab">nvnProgramGetSubtileSize_fastpath</a> (const <a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *program)</td></tr>
<tr class="memdesc:ga872e7fb952779aa76d2643af8c50feab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the computed subtile size for a program's fragment shader.  <a href="group__nvn__c__functions.html#ga872e7fb952779aa76d2643af8c50feab">More...</a><br /></td></tr>
<tr class="separator:ga872e7fb952779aa76d2643af8c50feab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94b5dc5a5043495db9e6c3bc41ed6098"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga94b5dc5a5043495db9e6c3bc41ed6098">nvnProgramInitialize</a> (<a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *program, <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device)</td></tr>
<tr class="memdesc:ga94b5dc5a5043495db9e6c3bc41ed6098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives.">NVNprogram</a> object for the specified device.  <a href="group__nvn__c__functions.html#ga94b5dc5a5043495db9e6c3bc41ed6098">More...</a><br /></td></tr>
<tr class="separator:ga94b5dc5a5043495db9e6c3bc41ed6098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cae86887480bb2aac1d98a5a4f94f68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga5cae86887480bb2aac1d98a5a4f94f68">nvnProgramSetDebugLabel</a> (<a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *program, const char *label)</td></tr>
<tr class="memdesc:ga5cae86887480bb2aac1d98a5a4f94f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug label string for a <a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives.">NVNprogram</a> object.  <a href="group__nvn__c__functions.html#ga5cae86887480bb2aac1d98a5a4f94f68">More...</a><br /></td></tr>
<tr class="separator:ga5cae86887480bb2aac1d98a5a4f94f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga242e9c1623683791c311192c1547cc4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga242e9c1623683791c311192c1547cc4e">nvnProgramSetSampleShading</a> (<a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *program, <a class="el" href="group__nvn__c__enum.html#ga9cb9f0d20bd6e1b9c9140139d913ce21">NVNsampleShadingMode</a> shadingMode)</td></tr>
<tr class="memdesc:ga242e9c1623683791c311192c1547cc4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overrides how the program's fragment shader is evaluated.  <a href="group__nvn__c__functions.html#ga242e9c1623683791c311192c1547cc4e">More...</a><br /></td></tr>
<tr class="separator:ga242e9c1623683791c311192c1547cc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6a517c8312bcaea2bafddfdf59f426a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad6a517c8312bcaea2bafddfdf59f426a">nvnProgramSetShaders</a> (<a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *program, int count, const <a class="el" href="struct_n_v_nshader_data.html">NVNshaderData</a> *stageData)</td></tr>
<tr class="memdesc:gad6a517c8312bcaea2bafddfdf59f426a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a program object to use pre-compiled GPU code from one or multiple shaders.  <a href="group__nvn__c__functions.html#gad6a517c8312bcaea2bafddfdf59f426a">More...</a><br /></td></tr>
<tr class="separator:gad6a517c8312bcaea2bafddfdf59f426a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67a984a9d07ea6f3f976b846224b5515"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga67a984a9d07ea6f3f976b846224b5515">nvnProgramSetShadersExt</a> (<a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *program, int count, const <a class="el" href="struct_n_v_nshader_data_ext.html">NVNshaderDataExt</a> *stageDataExt)</td></tr>
<tr class="memdesc:ga67a984a9d07ea6f3f976b846224b5515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a program object to use pre-compiled GPU code from one or multiple shaders and optionally replaces the debug data hashes.  <a href="group__nvn__c__functions.html#ga67a984a9d07ea6f3f976b846224b5515">More...</a><br /></td></tr>
<tr class="separator:ga67a984a9d07ea6f3f976b846224b5515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe101d51f91200d5c59c756b8f754961"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gafe101d51f91200d5c59c756b8f754961">nvnProgramSetSubroutineLinkage</a> (<a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *program, int count, const <a class="el" href="group__nvn__c__api__typedefs.html#gab66e1162e92eb9ed7611be8e01118116">NVNsubroutineLinkageMapPtr</a> *linkageMapPtrs)</td></tr>
<tr class="memdesc:gafe101d51f91200d5c59c756b8f754961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the program's subroutine linkage maps for future use with nvnCommandBufferSetProgramSubroutines.  <a href="group__nvn__c__functions.html#gafe101d51f91200d5c59c756b8f754961">More...</a><br /></td></tr>
<tr class="separator:gafe101d51f91200d5c59c756b8f754961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga620c9128e6758213a4fecaf7ce6fccea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga620c9128e6758213a4fecaf7ce6fccea">nvnQueueBuilderGetCommandFlushThreshold</a> (const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder, int *flushThreshold)</td></tr>
<tr class="memdesc:ga620c9128e6758213a4fecaf7ce6fccea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the command flush threshold associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object.  <a href="group__nvn__c__functions.html#ga620c9128e6758213a4fecaf7ce6fccea">More...</a><br /></td></tr>
<tr class="separator:ga620c9128e6758213a4fecaf7ce6fccea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12df64513ce3e52474dc6a091cd3616d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga12df64513ce3e52474dc6a091cd3616d">nvnQueueBuilderGetCommandMemorySize</a> (const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder, int *size)</td></tr>
<tr class="memdesc:ga12df64513ce3e52474dc6a091cd3616d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the command memory size associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object.  <a href="group__nvn__c__functions.html#ga12df64513ce3e52474dc6a091cd3616d">More...</a><br /></td></tr>
<tr class="separator:ga12df64513ce3e52474dc6a091cd3616d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf728cfa48fe1665b195f0bbcb7ece385"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf728cfa48fe1665b195f0bbcb7ece385">nvnQueueBuilderGetComputeMemorySize</a> (const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder, int *size)</td></tr>
<tr class="memdesc:gaf728cfa48fe1665b195f0bbcb7ece385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the compute memory size associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object.  <a href="group__nvn__c__functions.html#gaf728cfa48fe1665b195f0bbcb7ece385">More...</a><br /></td></tr>
<tr class="separator:gaf728cfa48fe1665b195f0bbcb7ece385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0be1544f07aa9d9c50f0d7a6261df8f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0be1544f07aa9d9c50f0d7a6261df8f3">nvnQueueBuilderGetControlMemorySize</a> (const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder, int *size)</td></tr>
<tr class="memdesc:ga0be1544f07aa9d9c50f0d7a6261df8f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the control memory size associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object.  <a href="group__nvn__c__functions.html#ga0be1544f07aa9d9c50f0d7a6261df8f3">More...</a><br /></td></tr>
<tr class="separator:ga0be1544f07aa9d9c50f0d7a6261df8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea2b90419b41e5ece6af3edd45129d32"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaea2b90419b41e5ece6af3edd45129d32">nvnQueueBuilderGetDevice</a> (const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder)</td></tr>
<tr class="memdesc:gaea2b90419b41e5ece6af3edd45129d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object.  <a href="group__nvn__c__functions.html#gaea2b90419b41e5ece6af3edd45129d32">More...</a><br /></td></tr>
<tr class="separator:gaea2b90419b41e5ece6af3edd45129d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8052ee2bf90dc95291341ae400dd1ea7"><td class="memItemLeft" align="right" valign="top">NVNINLINE const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8052ee2bf90dc95291341ae400dd1ea7">nvnQueueBuilderGetDevice_fastpath</a> (const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga8052ee2bf90dc95291341ae400dd1ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object.  <a href="group__nvn__c__functions.html#ga8052ee2bf90dc95291341ae400dd1ea7">More...</a><br /></td></tr>
<tr class="separator:ga8052ee2bf90dc95291341ae400dd1ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bbd3d283a12e7b08f06f006dbebee66"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7bbd3d283a12e7b08f06f006dbebee66">nvnQueueBuilderGetFlags</a> (const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga7bbd3d283a12e7b08f06f006dbebee66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get queue flags associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object.  <a href="group__nvn__c__functions.html#ga7bbd3d283a12e7b08f06f006dbebee66">More...</a><br /></td></tr>
<tr class="separator:ga7bbd3d283a12e7b08f06f006dbebee66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed3ae6a74ec026d51d9cf84b8ae0f232"><td class="memItemLeft" align="right" valign="top">NVNINLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaed3ae6a74ec026d51d9cf84b8ae0f232">nvnQueueBuilderGetFlags_fastpath</a> (const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder)</td></tr>
<tr class="memdesc:gaed3ae6a74ec026d51d9cf84b8ae0f232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get queue flags associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object.  <a href="group__nvn__c__functions.html#gaed3ae6a74ec026d51d9cf84b8ae0f232">More...</a><br /></td></tr>
<tr class="separator:gaed3ae6a74ec026d51d9cf84b8ae0f232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga272f5fc06e59a8c193abb2ad86ad6900"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga272f5fc06e59a8c193abb2ad86ad6900">nvnQueueBuilderGetMemory</a> (const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga272f5fc06e59a8c193abb2ad86ad6900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the memory associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object.  <a href="group__nvn__c__functions.html#ga272f5fc06e59a8c193abb2ad86ad6900">More...</a><br /></td></tr>
<tr class="separator:ga272f5fc06e59a8c193abb2ad86ad6900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac99fb806fca2d81338429173878844c2"><td class="memItemLeft" align="right" valign="top">NVNINLINE void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac99fb806fca2d81338429173878844c2">nvnQueueBuilderGetMemory_fastpath</a> (const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder)</td></tr>
<tr class="memdesc:gac99fb806fca2d81338429173878844c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the memory associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object.  <a href="group__nvn__c__functions.html#gac99fb806fca2d81338429173878844c2">More...</a><br /></td></tr>
<tr class="separator:gac99fb806fca2d81338429173878844c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8ddabb30dcd2193f80184a22a395b13"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf8ddabb30dcd2193f80184a22a395b13">nvnQueueBuilderGetMemorySize</a> (const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder)</td></tr>
<tr class="memdesc:gaf8ddabb30dcd2193f80184a22a395b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the memory associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object.  <a href="group__nvn__c__functions.html#gaf8ddabb30dcd2193f80184a22a395b13">More...</a><br /></td></tr>
<tr class="separator:gaf8ddabb30dcd2193f80184a22a395b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2903b2910d9471307595962237d3c578"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2903b2910d9471307595962237d3c578">nvnQueueBuilderGetQueueMemorySize</a> (const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga2903b2910d9471307595962237d3c578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the amount of extra memory needed for a queue initialized using a <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a>.  <a href="group__nvn__c__functions.html#ga2903b2910d9471307595962237d3c578">More...</a><br /></td></tr>
<tr class="separator:ga2903b2910d9471307595962237d3c578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab654b1b408e6ffe58faa6fa981796905"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#gad6f183867c5a1658ad18db1d8dfb4102">NVNqueuePriority</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab654b1b408e6ffe58faa6fa981796905">nvnQueueBuilderGetQueuePriority</a> (const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder)</td></tr>
<tr class="memdesc:gab654b1b408e6ffe58faa6fa981796905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the priority associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object.  <a href="group__nvn__c__functions.html#gab654b1b408e6ffe58faa6fa981796905">More...</a><br /></td></tr>
<tr class="separator:gab654b1b408e6ffe58faa6fa981796905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4de1469ce962b138ca454c034f6e649b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4de1469ce962b138ca454c034f6e649b">nvnQueueBuilderSetCommandFlushThreshold</a> (<a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder, size_t threshold)</td></tr>
<tr class="memdesc:ga4de1469ce962b138ca454c034f6e649b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a flush threshold for a new <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> object.  <a href="group__nvn__c__functions.html#ga4de1469ce962b138ca454c034f6e649b">More...</a><br /></td></tr>
<tr class="separator:ga4de1469ce962b138ca454c034f6e649b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4291be788552aa888e9551d0e1084bfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4291be788552aa888e9551d0e1084bfb">nvnQueueBuilderSetCommandMemorySize</a> (<a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder, size_t size)</td></tr>
<tr class="memdesc:ga4291be788552aa888e9551d0e1084bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the size of the internal command buffer used by a <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> object.  <a href="group__nvn__c__functions.html#ga4291be788552aa888e9551d0e1084bfb">More...</a><br /></td></tr>
<tr class="separator:ga4291be788552aa888e9551d0e1084bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga161b2d39535ffac2829d972058391bb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga161b2d39535ffac2829d972058391bb6">nvnQueueBuilderSetComputeMemorySize</a> (<a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder, size_t size)</td></tr>
<tr class="memdesc:ga161b2d39535ffac2829d972058391bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the size of the internal buffers used for compute dispatches in a <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> object.  <a href="group__nvn__c__functions.html#ga161b2d39535ffac2829d972058391bb6">More...</a><br /></td></tr>
<tr class="separator:ga161b2d39535ffac2829d972058391bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef123992e515f2eac2af9fecad8634a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaef123992e515f2eac2af9fecad8634a9">nvnQueueBuilderSetControlMemorySize</a> (<a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder, size_t size)</td></tr>
<tr class="memdesc:gaef123992e515f2eac2af9fecad8634a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the size of the control memory buffer used by a <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> object.  <a href="group__nvn__c__functions.html#gaef123992e515f2eac2af9fecad8634a9">More...</a><br /></td></tr>
<tr class="separator:gaef123992e515f2eac2af9fecad8634a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20bc093a367e06cd1f1f273289354b75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga20bc093a367e06cd1f1f273289354b75">nvnQueueBuilderSetDefaults</a> (<a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga20bc093a367e06cd1f1f273289354b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object.  <a href="group__nvn__c__functions.html#ga20bc093a367e06cd1f1f273289354b75">More...</a><br /></td></tr>
<tr class="separator:ga20bc093a367e06cd1f1f273289354b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fdbe1fc82e21cf370aa7f1fa0a6141a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7fdbe1fc82e21cf370aa7f1fa0a6141a">nvnQueueBuilderSetDevice</a> (<a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder, <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device)</td></tr>
<tr class="memdesc:ga7fdbe1fc82e21cf370aa7f1fa0a6141a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> associated with a <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object.  <a href="group__nvn__c__functions.html#ga7fdbe1fc82e21cf370aa7f1fa0a6141a">More...</a><br /></td></tr>
<tr class="separator:ga7fdbe1fc82e21cf370aa7f1fa0a6141a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1665885cd6a9f8b9c3fbac546243b440"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1665885cd6a9f8b9c3fbac546243b440">nvnQueueBuilderSetFlags</a> (<a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder, int flags)</td></tr>
<tr class="memdesc:ga1665885cd6a9f8b9c3fbac546243b440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set properties of <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> objects created from the builder.  <a href="group__nvn__c__functions.html#ga1665885cd6a9f8b9c3fbac546243b440">More...</a><br /></td></tr>
<tr class="separator:ga1665885cd6a9f8b9c3fbac546243b440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0403d233aff80ce9cc6548b5dbe24ca2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0403d233aff80ce9cc6548b5dbe24ca2">nvnQueueBuilderSetQueueMemory</a> (<a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder, void *memory, size_t size)</td></tr>
<tr class="memdesc:ga0403d233aff80ce9cc6548b5dbe24ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides memory to be used by queues pools initialized using a <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a>.  <a href="group__nvn__c__functions.html#ga0403d233aff80ce9cc6548b5dbe24ca2">More...</a><br /></td></tr>
<tr class="separator:ga0403d233aff80ce9cc6548b5dbe24ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ee5e4ee215b89d57000f8774135dd04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4ee5e4ee215b89d57000f8774135dd04">nvnQueueBuilderSetQueuePriority</a> (<a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder, const <a class="el" href="group__nvn__c__enum.html#gad6f183867c5a1658ad18db1d8dfb4102">NVNqueuePriority</a> priority)</td></tr>
<tr class="memdesc:ga4ee5e4ee215b89d57000f8774135dd04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a priority on a <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object.  <a href="group__nvn__c__functions.html#ga4ee5e4ee215b89d57000f8774135dd04">More...</a><br /></td></tr>
<tr class="separator:ga4ee5e4ee215b89d57000f8774135dd04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9ac49135f570d693b7c6469c62f069b"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac9ac49135f570d693b7c6469c62f069b">nvnQueueBuilderSetQueuePriority_fastpath</a> (<a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder, const <a class="el" href="group__nvn__c__enum.html#gad6f183867c5a1658ad18db1d8dfb4102">NVNqueuePriority</a> priority)</td></tr>
<tr class="memdesc:gac9ac49135f570d693b7c6469c62f069b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a priority on a <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object.  <a href="group__nvn__c__functions.html#gac9ac49135f570d693b7c6469c62f069b">More...</a><br /></td></tr>
<tr class="separator:gac9ac49135f570d693b7c6469c62f069b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae646129720b27503c239a22db9653fa0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae646129720b27503c239a22db9653fa0">nvnQueueFenceSync</a> (<a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *queue, <a class="el" href="struct_n_v_nsync.html">NVNsync</a> *sync, <a class="el" href="group__nvn__c__enum.html#ga6ab26a343b68da722799167ea97ec69d">NVNsyncCondition</a> condition, int flags)</td></tr>
<tr class="memdesc:gae646129720b27503c239a22db9653fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object as signaled when all previous commands have completed in the <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> object.  <a href="group__nvn__c__functions.html#gae646129720b27503c239a22db9653fa0">More...</a><br /></td></tr>
<tr class="separator:gae646129720b27503c239a22db9653fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54ac57de39c708eb9758bae7770d5ccc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga54ac57de39c708eb9758bae7770d5ccc">nvnQueueFinalize</a> (<a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *queue)</td></tr>
<tr class="memdesc:ga54ac57de39c708eb9758bae7770d5ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> object.  <a href="group__nvn__c__functions.html#ga54ac57de39c708eb9758bae7770d5ccc">More...</a><br /></td></tr>
<tr class="separator:ga54ac57de39c708eb9758bae7770d5ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab3c15f657cefdff33dab453795ff38f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaab3c15f657cefdff33dab453795ff38f">nvnQueueFinish</a> (<a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *queue)</td></tr>
<tr class="memdesc:gaab3c15f657cefdff33dab453795ff38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until all commands previously submitted to a queue have completed execution.  <a href="group__nvn__c__functions.html#gaab3c15f657cefdff33dab453795ff38f">More...</a><br /></td></tr>
<tr class="separator:gaab3c15f657cefdff33dab453795ff38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98feac9fc906eb1a9a5eb19ef4381b46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga98feac9fc906eb1a9a5eb19ef4381b46">nvnQueueFlush</a> (<a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *queue)</td></tr>
<tr class="memdesc:ga98feac9fc906eb1a9a5eb19ef4381b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush commands previously submitted to a queue for processing.  <a href="group__nvn__c__functions.html#ga98feac9fc906eb1a9a5eb19ef4381b46">More...</a><br /></td></tr>
<tr class="separator:ga98feac9fc906eb1a9a5eb19ef4381b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81cb87eb9eba8acd7de1fa80ab673ab7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga2a36e1011d80409e1d1cd7c87e81035c">NVNqueueGetErrorResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga81cb87eb9eba8acd7de1fa80ab673ab7">nvnQueueGetError</a> (<a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *queue, <a class="el" href="union_n_v_nqueue_error_info.html">NVNqueueErrorInfo</a> *errorInfo)</td></tr>
<tr class="memdesc:ga81cb87eb9eba8acd7de1fa80ab673ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get GPU error status of the queue.  <a href="group__nvn__c__functions.html#ga81cb87eb9eba8acd7de1fa80ab673ab7">More...</a><br /></td></tr>
<tr class="separator:ga81cb87eb9eba8acd7de1fa80ab673ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc96e4b44f4c1fa2540ecbcb37c4fe62"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gacc96e4b44f4c1fa2540ecbcb37c4fe62">nvnQueueGetTotalCommandMemoryUsed</a> (<a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *queue)</td></tr>
<tr class="memdesc:gacc96e4b44f4c1fa2540ecbcb37c4fe62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query total queue command memory usage.  <a href="group__nvn__c__functions.html#gacc96e4b44f4c1fa2540ecbcb37c4fe62">More...</a><br /></td></tr>
<tr class="separator:gacc96e4b44f4c1fa2540ecbcb37c4fe62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70fb17ac6a5d34a7e8eb17a8d1e9a28e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga70fb17ac6a5d34a7e8eb17a8d1e9a28e">nvnQueueGetTotalComputeMemoryUsed</a> (<a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *queue)</td></tr>
<tr class="memdesc:ga70fb17ac6a5d34a7e8eb17a8d1e9a28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query total queue compute memory usage.  <a href="group__nvn__c__functions.html#ga70fb17ac6a5d34a7e8eb17a8d1e9a28e">More...</a><br /></td></tr>
<tr class="separator:ga70fb17ac6a5d34a7e8eb17a8d1e9a28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f0889104e9531bc404a133456bad956"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1f0889104e9531bc404a133456bad956">nvnQueueGetTotalControlMemoryUsed</a> (<a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *queue)</td></tr>
<tr class="memdesc:ga1f0889104e9531bc404a133456bad956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query total queue control memory usage.  <a href="group__nvn__c__functions.html#ga1f0889104e9531bc404a133456bad956">More...</a><br /></td></tr>
<tr class="separator:ga1f0889104e9531bc404a133456bad956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga512027cc783d925feb7261915130e2ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga512027cc783d925feb7261915130e2ca">nvnQueueInitialize</a> (<a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *queue, const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga512027cc783d925feb7261915130e2ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> object from a queue builder.  <a href="group__nvn__c__functions.html#ga512027cc783d925feb7261915130e2ca">More...</a><br /></td></tr>
<tr class="separator:ga512027cc783d925feb7261915130e2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad317e78382b7f51a7a6f0504193d90c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad317e78382b7f51a7a6f0504193d90c7">nvnQueuePresentTexture</a> (<a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *queue, <a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *window, int textureIndex)</td></tr>
<tr class="memdesc:gad317e78382b7f51a7a6f0504193d90c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display the contents of a texture into the window.  <a href="group__nvn__c__functions.html#gad317e78382b7f51a7a6f0504193d90c7">More...</a><br /></td></tr>
<tr class="separator:gad317e78382b7f51a7a6f0504193d90c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae59349fe88c0a1e539a891b79e1bff72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae59349fe88c0a1e539a891b79e1bff72">nvnQueueResetMemoryUsageCounts</a> (<a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *queue)</td></tr>
<tr class="memdesc:gae59349fe88c0a1e539a891b79e1bff72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset usage counters for command, control and compute memory.  <a href="group__nvn__c__functions.html#gae59349fe88c0a1e539a891b79e1bff72">More...</a><br /></td></tr>
<tr class="separator:gae59349fe88c0a1e539a891b79e1bff72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c90495a1a43ec403d590ee7603057ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0c90495a1a43ec403d590ee7603057ec">nvnQueueSetDebugLabel</a> (<a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *queue, const char *label)</td></tr>
<tr class="memdesc:ga0c90495a1a43ec403d590ee7603057ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug label string for a <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> object.  <a href="group__nvn__c__functions.html#ga0c90495a1a43ec403d590ee7603057ec">More...</a><br /></td></tr>
<tr class="separator:ga0c90495a1a43ec403d590ee7603057ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga095fabdb4c81459bbe496ba45528211b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga095fabdb4c81459bbe496ba45528211b">nvnQueueSubmitCommands</a> (<a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *queue, int numCommands, const <a class="el" href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a> *handles)</td></tr>
<tr class="memdesc:ga095fabdb4c81459bbe496ba45528211b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit commands encapsulated in command buffers to a queue for processing.  <a href="group__nvn__c__functions.html#ga095fabdb4c81459bbe496ba45528211b">More...</a><br /></td></tr>
<tr class="separator:ga095fabdb4c81459bbe496ba45528211b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad28b8279c1f539d143c1902212df11f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaad28b8279c1f539d143c1902212df11f">nvnQueueWaitSync</a> (<a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *queue, const <a class="el" href="struct_n_v_nsync.html">NVNsync</a> *sync)</td></tr>
<tr class="memdesc:gaad28b8279c1f539d143c1902212df11f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object to be signaled on the GPU before processing any further commands in the specified <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> object.  <a href="group__nvn__c__functions.html#gaad28b8279c1f539d143c1902212df11f">More...</a><br /></td></tr>
<tr class="separator:gaad28b8279c1f539d143c1902212df11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83e8344bbc081cb9ba7464b5e3436c47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga83e8344bbc081cb9ba7464b5e3436c47">nvnSamplerBuilderGetBorderColor</a> (const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, float *borderColor)</td></tr>
<tr class="memdesc:ga83e8344bbc081cb9ba7464b5e3436c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query floating-point border color values for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object.  <a href="group__nvn__c__functions.html#ga83e8344bbc081cb9ba7464b5e3436c47">More...</a><br /></td></tr>
<tr class="separator:ga83e8344bbc081cb9ba7464b5e3436c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fd5ad1183b027c260ec36d73c6ee3bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7fd5ad1183b027c260ec36d73c6ee3bf">nvnSamplerBuilderGetBorderColori</a> (const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, int *borderColor)</td></tr>
<tr class="memdesc:ga7fd5ad1183b027c260ec36d73c6ee3bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query signed integer border color values for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object.  <a href="group__nvn__c__functions.html#ga7fd5ad1183b027c260ec36d73c6ee3bf">More...</a><br /></td></tr>
<tr class="separator:ga7fd5ad1183b027c260ec36d73c6ee3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8354e069c30e1e18a0581471daf66409"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8354e069c30e1e18a0581471daf66409">nvnSamplerBuilderGetBorderColorui</a> (const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, uint32_t *borderColor)</td></tr>
<tr class="memdesc:ga8354e069c30e1e18a0581471daf66409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query unsigned integer border color values for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object.  <a href="group__nvn__c__functions.html#ga8354e069c30e1e18a0581471daf66409">More...</a><br /></td></tr>
<tr class="separator:ga8354e069c30e1e18a0581471daf66409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga759f6c95513d59fe4239f85eeac0a534"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga759f6c95513d59fe4239f85eeac0a534">nvnSamplerBuilderGetCompare</a> (const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, <a class="el" href="group__nvn__c__enum.html#gaa5f726f373cd522aa586a0b26a34fb3d">NVNcompareMode</a> *mode, <a class="el" href="group__nvn__c__enum.html#ga83d020997abcffbd763d2ca9e7b1aff6">NVNcompareFunc</a> *func)</td></tr>
<tr class="memdesc:ga759f6c95513d59fe4239f85eeac0a534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the depth comparison modes for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object.  <a href="group__nvn__c__functions.html#ga759f6c95513d59fe4239f85eeac0a534">More...</a><br /></td></tr>
<tr class="separator:ga759f6c95513d59fe4239f85eeac0a534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8362d8f866fe4e0f19bf075d801f7220"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8362d8f866fe4e0f19bf075d801f7220">nvnSamplerBuilderGetDevice</a> (const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga8362d8f866fe4e0f19bf075d801f7220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the device associated with this <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object.  <a href="group__nvn__c__functions.html#ga8362d8f866fe4e0f19bf075d801f7220">More...</a><br /></td></tr>
<tr class="separator:ga8362d8f866fe4e0f19bf075d801f7220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3d7dbc5d106bd2e6a4f62f868795a9b"><td class="memItemLeft" align="right" valign="top">NVNINLINE const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae3d7dbc5d106bd2e6a4f62f868795a9b">nvnSamplerBuilderGetDevice_fastpath</a> (const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder)</td></tr>
<tr class="memdesc:gae3d7dbc5d106bd2e6a4f62f868795a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the device associated with this <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object.  <a href="group__nvn__c__functions.html#gae3d7dbc5d106bd2e6a4f62f868795a9b">More...</a><br /></td></tr>
<tr class="separator:gae3d7dbc5d106bd2e6a4f62f868795a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae616d8490657704e4afae4dce930f03f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae616d8490657704e4afae4dce930f03f">nvnSamplerBuilderGetLodBias</a> (const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder)</td></tr>
<tr class="memdesc:gae616d8490657704e4afae4dce930f03f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the level-of-detail bias for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object.  <a href="group__nvn__c__functions.html#gae616d8490657704e4afae4dce930f03f">More...</a><br /></td></tr>
<tr class="separator:gae616d8490657704e4afae4dce930f03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64f1a26f240d1f2f13b413d7983c3b3b"><td class="memItemLeft" align="right" valign="top">NVNINLINE float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga64f1a26f240d1f2f13b413d7983c3b3b">nvnSamplerBuilderGetLodBias_fastpath</a> (const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga64f1a26f240d1f2f13b413d7983c3b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the level-of-detail bias for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object.  <a href="group__nvn__c__functions.html#ga64f1a26f240d1f2f13b413d7983c3b3b">More...</a><br /></td></tr>
<tr class="separator:ga64f1a26f240d1f2f13b413d7983c3b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe25c536260b86ccfde63a91d187c6c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gabe25c536260b86ccfde63a91d187c6c9">nvnSamplerBuilderGetLodClamp</a> (const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, float *min, float *max)</td></tr>
<tr class="memdesc:gabe25c536260b86ccfde63a91d187c6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the minimum and maximum level of detail in a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object.  <a href="group__nvn__c__functions.html#gabe25c536260b86ccfde63a91d187c6c9">More...</a><br /></td></tr>
<tr class="separator:gabe25c536260b86ccfde63a91d187c6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4da85e68ee693bfffd871cace32923c0"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4da85e68ee693bfffd871cace32923c0">nvnSamplerBuilderGetLodSnap</a> (const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga4da85e68ee693bfffd871cace32923c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the LOD snap for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object.  <a href="group__nvn__c__functions.html#ga4da85e68ee693bfffd871cace32923c0">More...</a><br /></td></tr>
<tr class="separator:ga4da85e68ee693bfffd871cace32923c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga857ebc705d76d61d16ba09428772944c"><td class="memItemLeft" align="right" valign="top">NVNINLINE float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga857ebc705d76d61d16ba09428772944c">nvnSamplerBuilderGetLodSnap_fastpath</a> (const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga857ebc705d76d61d16ba09428772944c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the LOD snap for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object.  <a href="group__nvn__c__functions.html#ga857ebc705d76d61d16ba09428772944c">More...</a><br /></td></tr>
<tr class="separator:ga857ebc705d76d61d16ba09428772944c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ee3fc56d9b39c67402c04802437976f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1ee3fc56d9b39c67402c04802437976f">nvnSamplerBuilderGetMaxAnisotropy</a> (const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga1ee3fc56d9b39c67402c04802437976f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the maximum level of anisotropy for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object.  <a href="group__nvn__c__functions.html#ga1ee3fc56d9b39c67402c04802437976f">More...</a><br /></td></tr>
<tr class="separator:ga1ee3fc56d9b39c67402c04802437976f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga238bf64d12308d70de98aa8d9568a514"><td class="memItemLeft" align="right" valign="top">NVNINLINE float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga238bf64d12308d70de98aa8d9568a514">nvnSamplerBuilderGetMaxAnisotropy_fastpath</a> (const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga238bf64d12308d70de98aa8d9568a514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the maximum level of anisotropy for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object.  <a href="group__nvn__c__functions.html#ga238bf64d12308d70de98aa8d9568a514">More...</a><br /></td></tr>
<tr class="separator:ga238bf64d12308d70de98aa8d9568a514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3a7a2b46cc8ada75360ac6b0bd73257"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab3a7a2b46cc8ada75360ac6b0bd73257">nvnSamplerBuilderGetMinMagFilter</a> (const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, <a class="el" href="group__nvn__c__enum.html#ga41610125d2ee1e59db15c26f9a1288c5">NVNminFilter</a> *min, <a class="el" href="group__nvn__c__enum.html#ga7f4e9b2ce71bbd9c4c2de6b3cfc293dc">NVNmagFilter</a> *mag)</td></tr>
<tr class="memdesc:gab3a7a2b46cc8ada75360ac6b0bd73257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the minification and magnification filters for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object.  <a href="group__nvn__c__functions.html#gab3a7a2b46cc8ada75360ac6b0bd73257">More...</a><br /></td></tr>
<tr class="separator:gab3a7a2b46cc8ada75360ac6b0bd73257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabefac5ca39cb0fb81d4fc8b53a031515"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga867b21c764db6c0573e9fc68e1b83437">NVNsamplerReduction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gabefac5ca39cb0fb81d4fc8b53a031515">nvnSamplerBuilderGetReductionFilter</a> (const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder)</td></tr>
<tr class="memdesc:gabefac5ca39cb0fb81d4fc8b53a031515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the reduction filter for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object.  <a href="group__nvn__c__functions.html#gabefac5ca39cb0fb81d4fc8b53a031515">More...</a><br /></td></tr>
<tr class="separator:gabefac5ca39cb0fb81d4fc8b53a031515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86f90d77048555a8d81b586536752299"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga86f90d77048555a8d81b586536752299">nvnSamplerBuilderGetWrapMode</a> (const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, <a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a> *s, <a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a> *t, <a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a> *r)</td></tr>
<tr class="memdesc:ga86f90d77048555a8d81b586536752299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the coordinate wrap modes for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object.  <a href="group__nvn__c__functions.html#ga86f90d77048555a8d81b586536752299">More...</a><br /></td></tr>
<tr class="separator:ga86f90d77048555a8d81b586536752299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58d007814dbbe79756a873c62077f8f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga58d007814dbbe79756a873c62077f8f0">nvnSamplerBuilderSetBorderColor</a> (<a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, const float *borderColor)</td></tr>
<tr class="memdesc:ga58d007814dbbe79756a873c62077f8f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set floating-point border color values used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>.  <a href="group__nvn__c__functions.html#ga58d007814dbbe79756a873c62077f8f0">More...</a><br /></td></tr>
<tr class="separator:ga58d007814dbbe79756a873c62077f8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae65d26314f7fcc219ac81cd331037cee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae65d26314f7fcc219ac81cd331037cee">nvnSamplerBuilderSetBorderColori</a> (<a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, const int *borderColor)</td></tr>
<tr class="memdesc:gae65d26314f7fcc219ac81cd331037cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set signed integer border color values used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>.  <a href="group__nvn__c__functions.html#gae65d26314f7fcc219ac81cd331037cee">More...</a><br /></td></tr>
<tr class="separator:gae65d26314f7fcc219ac81cd331037cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga620e4e3a9f487eaaab3b1ff4e7854bde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga620e4e3a9f487eaaab3b1ff4e7854bde">nvnSamplerBuilderSetBorderColorui</a> (<a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, const uint32_t *borderColor)</td></tr>
<tr class="memdesc:ga620e4e3a9f487eaaab3b1ff4e7854bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set unsigned integer border color values used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>.  <a href="group__nvn__c__functions.html#ga620e4e3a9f487eaaab3b1ff4e7854bde">More...</a><br /></td></tr>
<tr class="separator:ga620e4e3a9f487eaaab3b1ff4e7854bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61212f6d7e261272b3f3d8a2bedb7fd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga61212f6d7e261272b3f3d8a2bedb7fd4">nvnSamplerBuilderSetCompare</a> (<a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, <a class="el" href="group__nvn__c__enum.html#gaa5f726f373cd522aa586a0b26a34fb3d">NVNcompareMode</a> mode, <a class="el" href="group__nvn__c__enum.html#ga83d020997abcffbd763d2ca9e7b1aff6">NVNcompareFunc</a> func)</td></tr>
<tr class="memdesc:ga61212f6d7e261272b3f3d8a2bedb7fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the depth comparison mode used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>.  <a href="group__nvn__c__functions.html#ga61212f6d7e261272b3f3d8a2bedb7fd4">More...</a><br /></td></tr>
<tr class="separator:ga61212f6d7e261272b3f3d8a2bedb7fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga889b306858059648c66e88a226391acc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga889b306858059648c66e88a226391acc">nvnSamplerBuilderSetDefaults</a> (<a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga889b306858059648c66e88a226391acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object.  <a href="group__nvn__c__functions.html#ga889b306858059648c66e88a226391acc">More...</a><br /></td></tr>
<tr class="separator:ga889b306858059648c66e88a226391acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7504233cce44b1f5a7223f322b76a84d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7504233cce44b1f5a7223f322b76a84d">nvnSamplerBuilderSetDevice</a> (<a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device)</td></tr>
<tr class="memdesc:ga7504233cce44b1f5a7223f322b76a84d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> associated with a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object.  <a href="group__nvn__c__functions.html#ga7504233cce44b1f5a7223f322b76a84d">More...</a><br /></td></tr>
<tr class="separator:ga7504233cce44b1f5a7223f322b76a84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21c8ec90c03a9ba5c53824bfb9c1eee6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga21c8ec90c03a9ba5c53824bfb9c1eee6">nvnSamplerBuilderSetLodBias</a> (<a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, float bias)</td></tr>
<tr class="memdesc:ga21c8ec90c03a9ba5c53824bfb9c1eee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the level-of-detail bias used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>.  <a href="group__nvn__c__functions.html#ga21c8ec90c03a9ba5c53824bfb9c1eee6">More...</a><br /></td></tr>
<tr class="separator:ga21c8ec90c03a9ba5c53824bfb9c1eee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e64b4783943bf22e8adbb6e984c00d6"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0e64b4783943bf22e8adbb6e984c00d6">nvnSamplerBuilderSetLodBias_fastpath</a> (<a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, float bias)</td></tr>
<tr class="memdesc:ga0e64b4783943bf22e8adbb6e984c00d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the level-of-detail bias used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>.  <a href="group__nvn__c__functions.html#ga0e64b4783943bf22e8adbb6e984c00d6">More...</a><br /></td></tr>
<tr class="separator:ga0e64b4783943bf22e8adbb6e984c00d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd10e1f2dc492fdf600365ef94945170"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gacd10e1f2dc492fdf600365ef94945170">nvnSamplerBuilderSetLodClamp</a> (<a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, float min, float max)</td></tr>
<tr class="memdesc:gacd10e1f2dc492fdf600365ef94945170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minimum and maximum level of detail used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>.  <a href="group__nvn__c__functions.html#gacd10e1f2dc492fdf600365ef94945170">More...</a><br /></td></tr>
<tr class="separator:gacd10e1f2dc492fdf600365ef94945170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf28b83743a551b29d219963cb4e9ab5c"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf28b83743a551b29d219963cb4e9ab5c">nvnSamplerBuilderSetLodClamp_fastpath</a> (<a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, float min, float max)</td></tr>
<tr class="memdesc:gaf28b83743a551b29d219963cb4e9ab5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minimum and maximum level of detail used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>.  <a href="group__nvn__c__functions.html#gaf28b83743a551b29d219963cb4e9ab5c">More...</a><br /></td></tr>
<tr class="separator:gaf28b83743a551b29d219963cb4e9ab5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7165b9753b8ce20db7f8658c918fb686"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7165b9753b8ce20db7f8658c918fb686">nvnSamplerBuilderSetLodSnap</a> (<a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, float lodSnap)</td></tr>
<tr class="memdesc:ga7165b9753b8ce20db7f8658c918fb686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set LOD snap used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>.  <a href="group__nvn__c__functions.html#ga7165b9753b8ce20db7f8658c918fb686">More...</a><br /></td></tr>
<tr class="separator:ga7165b9753b8ce20db7f8658c918fb686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c6860a4029a428c4a4161c9bed7d1b"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga09c6860a4029a428c4a4161c9bed7d1b">nvnSamplerBuilderSetLodSnap_fastpath</a> (<a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, float lodSnap)</td></tr>
<tr class="memdesc:ga09c6860a4029a428c4a4161c9bed7d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set LOD snap used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>.  <a href="group__nvn__c__functions.html#ga09c6860a4029a428c4a4161c9bed7d1b">More...</a><br /></td></tr>
<tr class="separator:ga09c6860a4029a428c4a4161c9bed7d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga211345dfd517cb8458313d2bd00df0a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga211345dfd517cb8458313d2bd00df0a9">nvnSamplerBuilderSetMaxAnisotropy</a> (<a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, float maxAniso)</td></tr>
<tr class="memdesc:ga211345dfd517cb8458313d2bd00df0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum level of anisotropy used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>.  <a href="group__nvn__c__functions.html#ga211345dfd517cb8458313d2bd00df0a9">More...</a><br /></td></tr>
<tr class="separator:ga211345dfd517cb8458313d2bd00df0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac952c1e10cb272d836bab7a4ba83c6d4"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac952c1e10cb272d836bab7a4ba83c6d4">nvnSamplerBuilderSetMaxAnisotropy_fastpath</a> (<a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, float maxAniso)</td></tr>
<tr class="memdesc:gac952c1e10cb272d836bab7a4ba83c6d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum level of anisotropy used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>.  <a href="group__nvn__c__functions.html#gac952c1e10cb272d836bab7a4ba83c6d4">More...</a><br /></td></tr>
<tr class="separator:gac952c1e10cb272d836bab7a4ba83c6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f634bd122e2b47cbebfeb16cda8352f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0f634bd122e2b47cbebfeb16cda8352f">nvnSamplerBuilderSetMinMagFilter</a> (<a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, <a class="el" href="group__nvn__c__enum.html#ga41610125d2ee1e59db15c26f9a1288c5">NVNminFilter</a> min, <a class="el" href="group__nvn__c__enum.html#ga7f4e9b2ce71bbd9c4c2de6b3cfc293dc">NVNmagFilter</a> mag)</td></tr>
<tr class="memdesc:ga0f634bd122e2b47cbebfeb16cda8352f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minification and magnification filters for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>.  <a href="group__nvn__c__functions.html#ga0f634bd122e2b47cbebfeb16cda8352f">More...</a><br /></td></tr>
<tr class="separator:ga0f634bd122e2b47cbebfeb16cda8352f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c077843893df456f4abff6862b4d467"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3c077843893df456f4abff6862b4d467">nvnSamplerBuilderSetReductionFilter</a> (<a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, <a class="el" href="group__nvn__c__enum.html#ga867b21c764db6c0573e9fc68e1b83437">NVNsamplerReduction</a> filter)</td></tr>
<tr class="memdesc:ga3c077843893df456f4abff6862b4d467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the reduction filter used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>.  <a href="group__nvn__c__functions.html#ga3c077843893df456f4abff6862b4d467">More...</a><br /></td></tr>
<tr class="separator:ga3c077843893df456f4abff6862b4d467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63aec39a3ab8401a6e287d2024c74e2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga63aec39a3ab8401a6e287d2024c74e2f">nvnSamplerBuilderSetWrapMode</a> (<a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, <a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a> s, <a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a> t, <a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a> r)</td></tr>
<tr class="memdesc:ga63aec39a3ab8401a6e287d2024c74e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the coordinate wrap modes for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>.  <a href="group__nvn__c__functions.html#ga63aec39a3ab8401a6e287d2024c74e2f">More...</a><br /></td></tr>
<tr class="separator:ga63aec39a3ab8401a6e287d2024c74e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga530d7f40e1ddc78fcb447d1950f2b471"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga530d7f40e1ddc78fcb447d1950f2b471">nvnSamplerCompare</a> (const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler, const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *otherSampler)</td></tr>
<tr class="memdesc:ga530d7f40e1ddc78fcb447d1950f2b471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if sampler objects are equivalent.  <a href="group__nvn__c__functions.html#ga530d7f40e1ddc78fcb447d1950f2b471">More...</a><br /></td></tr>
<tr class="separator:ga530d7f40e1ddc78fcb447d1950f2b471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82945a36dea04505dcd29e03442ed5a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga82945a36dea04505dcd29e03442ed5a6">nvnSamplerFinalize</a> (<a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler)</td></tr>
<tr class="memdesc:ga82945a36dea04505dcd29e03442ed5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object.  <a href="group__nvn__c__functions.html#ga82945a36dea04505dcd29e03442ed5a6">More...</a><br /></td></tr>
<tr class="separator:ga82945a36dea04505dcd29e03442ed5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05bf524362b220a01368041d936a5473"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga05bf524362b220a01368041d936a5473">nvnSamplerGetBorderColor</a> (const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler, float *borderColor)</td></tr>
<tr class="memdesc:ga05bf524362b220a01368041d936a5473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query floating-point border color values for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object.  <a href="group__nvn__c__functions.html#ga05bf524362b220a01368041d936a5473">More...</a><br /></td></tr>
<tr class="separator:ga05bf524362b220a01368041d936a5473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42f49191e28dd92309cd80f79c71d325"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga42f49191e28dd92309cd80f79c71d325">nvnSamplerGetBorderColori</a> (const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler, int *borderColor)</td></tr>
<tr class="memdesc:ga42f49191e28dd92309cd80f79c71d325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query signed integer border color values for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object.  <a href="group__nvn__c__functions.html#ga42f49191e28dd92309cd80f79c71d325">More...</a><br /></td></tr>
<tr class="separator:ga42f49191e28dd92309cd80f79c71d325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09cffaeae4405d2a9b3b8b2054002c29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga09cffaeae4405d2a9b3b8b2054002c29">nvnSamplerGetBorderColorui</a> (const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler, uint32_t *borderColor)</td></tr>
<tr class="memdesc:ga09cffaeae4405d2a9b3b8b2054002c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query unsigned integer border color values for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object.  <a href="group__nvn__c__functions.html#ga09cffaeae4405d2a9b3b8b2054002c29">More...</a><br /></td></tr>
<tr class="separator:ga09cffaeae4405d2a9b3b8b2054002c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf974179c68b5aeebac1e821b757235da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf974179c68b5aeebac1e821b757235da">nvnSamplerGetCompare</a> (const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler, <a class="el" href="group__nvn__c__enum.html#gaa5f726f373cd522aa586a0b26a34fb3d">NVNcompareMode</a> *mode, <a class="el" href="group__nvn__c__enum.html#ga83d020997abcffbd763d2ca9e7b1aff6">NVNcompareFunc</a> *func)</td></tr>
<tr class="memdesc:gaf974179c68b5aeebac1e821b757235da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the depth comparison modes for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object.  <a href="group__nvn__c__functions.html#gaf974179c68b5aeebac1e821b757235da">More...</a><br /></td></tr>
<tr class="separator:gaf974179c68b5aeebac1e821b757235da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bedba0ca7bda287c734f16e1124d303"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7bedba0ca7bda287c734f16e1124d303">nvnSamplerGetDebugID</a> (const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler)</td></tr>
<tr class="memdesc:ga7bedba0ca7bda287c734f16e1124d303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the debug layer unique ID of this sampler.  <a href="group__nvn__c__functions.html#ga7bedba0ca7bda287c734f16e1124d303">More...</a><br /></td></tr>
<tr class="separator:ga7bedba0ca7bda287c734f16e1124d303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94a996072e4bfcf92d86b6866a28d511"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga94a996072e4bfcf92d86b6866a28d511">nvnSamplerGetLodBias</a> (const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler)</td></tr>
<tr class="memdesc:ga94a996072e4bfcf92d86b6866a28d511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the level-of-detail bias for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object.  <a href="group__nvn__c__functions.html#ga94a996072e4bfcf92d86b6866a28d511">More...</a><br /></td></tr>
<tr class="separator:ga94a996072e4bfcf92d86b6866a28d511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3ffb490c3ac760043e8fd7539344341"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae3ffb490c3ac760043e8fd7539344341">nvnSamplerGetLodClamp</a> (const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler, float *min, float *max)</td></tr>
<tr class="memdesc:gae3ffb490c3ac760043e8fd7539344341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the minimum and maximum level of detail in a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object.  <a href="group__nvn__c__functions.html#gae3ffb490c3ac760043e8fd7539344341">More...</a><br /></td></tr>
<tr class="separator:gae3ffb490c3ac760043e8fd7539344341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25e6287ab1146df61fe42a501d93abaf"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga25e6287ab1146df61fe42a501d93abaf">nvnSamplerGetMaxAnisotropy</a> (const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler)</td></tr>
<tr class="memdesc:ga25e6287ab1146df61fe42a501d93abaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the maximum level of anisotropy for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object.  <a href="group__nvn__c__functions.html#ga25e6287ab1146df61fe42a501d93abaf">More...</a><br /></td></tr>
<tr class="separator:ga25e6287ab1146df61fe42a501d93abaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bacdf25415f1169fff22060eae02d85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2bacdf25415f1169fff22060eae02d85">nvnSamplerGetMinMagFilter</a> (const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler, <a class="el" href="group__nvn__c__enum.html#ga41610125d2ee1e59db15c26f9a1288c5">NVNminFilter</a> *min, <a class="el" href="group__nvn__c__enum.html#ga7f4e9b2ce71bbd9c4c2de6b3cfc293dc">NVNmagFilter</a> *mag)</td></tr>
<tr class="memdesc:ga2bacdf25415f1169fff22060eae02d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the minification and magnification filters for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object.  <a href="group__nvn__c__functions.html#ga2bacdf25415f1169fff22060eae02d85">More...</a><br /></td></tr>
<tr class="separator:ga2bacdf25415f1169fff22060eae02d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga476d91292dcfa379c72a31f17bb1e1bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga867b21c764db6c0573e9fc68e1b83437">NVNsamplerReduction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga476d91292dcfa379c72a31f17bb1e1bd">nvnSamplerGetReductionFilter</a> (const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler)</td></tr>
<tr class="memdesc:ga476d91292dcfa379c72a31f17bb1e1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the reduction filter for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object.  <a href="group__nvn__c__functions.html#ga476d91292dcfa379c72a31f17bb1e1bd">More...</a><br /></td></tr>
<tr class="separator:ga476d91292dcfa379c72a31f17bb1e1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2f6cd6c8e394fb4357615ae4d6e6590"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae2f6cd6c8e394fb4357615ae4d6e6590">nvnSamplerGetWrapMode</a> (const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler, <a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a> *s, <a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a> *t, <a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a> *r)</td></tr>
<tr class="memdesc:gae2f6cd6c8e394fb4357615ae4d6e6590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the coordinate wrap modes for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object.  <a href="group__nvn__c__functions.html#gae2f6cd6c8e394fb4357615ae4d6e6590">More...</a><br /></td></tr>
<tr class="separator:gae2f6cd6c8e394fb4357615ae4d6e6590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f3728966dc1ce72231c88bd3bca94ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga5f3728966dc1ce72231c88bd3bca94ad">nvnSamplerInitialize</a> (<a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler, const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga5f3728966dc1ce72231c88bd3bca94ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object using the specified <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object.  <a href="group__nvn__c__functions.html#ga5f3728966dc1ce72231c88bd3bca94ad">More...</a><br /></td></tr>
<tr class="separator:ga5f3728966dc1ce72231c88bd3bca94ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f34faa24cf7902685de6c5c58e3b370"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0f34faa24cf7902685de6c5c58e3b370">nvnSamplerPoolFinalize</a> (<a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *pool)</td></tr>
<tr class="memdesc:ga0f34faa24cf7902685de6c5c58e3b370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">NVNsamplerPool</a> object.  <a href="group__nvn__c__functions.html#ga0f34faa24cf7902685de6c5c58e3b370">More...</a><br /></td></tr>
<tr class="separator:ga0f34faa24cf7902685de6c5c58e3b370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ab7ea81536b1e2cf80ad042e8f862a7"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7ab7ea81536b1e2cf80ad042e8f862a7">nvnSamplerPoolGetMemoryOffset</a> (const <a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *pool)</td></tr>
<tr class="memdesc:ga7ab7ea81536b1e2cf80ad042e8f862a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool offset used by a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">NVNsamplerPool</a> object.  <a href="group__nvn__c__functions.html#ga7ab7ea81536b1e2cf80ad042e8f862a7">More...</a><br /></td></tr>
<tr class="separator:ga7ab7ea81536b1e2cf80ad042e8f862a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11e4a70af5e36373a37c3baea913f21e"><td class="memItemLeft" align="right" valign="top">NVNINLINE ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga11e4a70af5e36373a37c3baea913f21e">nvnSamplerPoolGetMemoryOffset_fastpath</a> (const <a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *pool)</td></tr>
<tr class="memdesc:ga11e4a70af5e36373a37c3baea913f21e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool offset used by a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">NVNsamplerPool</a> object.  <a href="group__nvn__c__functions.html#ga11e4a70af5e36373a37c3baea913f21e">More...</a><br /></td></tr>
<tr class="separator:ga11e4a70af5e36373a37c3baea913f21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee878a9e546d6c2b6325cf0be61ae41c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaee878a9e546d6c2b6325cf0be61ae41c">nvnSamplerPoolGetMemoryPool</a> (const <a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *pool)</td></tr>
<tr class="memdesc:gaee878a9e546d6c2b6325cf0be61ae41c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool used by a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">NVNsamplerPool</a> object.  <a href="group__nvn__c__functions.html#gaee878a9e546d6c2b6325cf0be61ae41c">More...</a><br /></td></tr>
<tr class="separator:gaee878a9e546d6c2b6325cf0be61ae41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3eb0f055816559741a871fa6c1817b06"><td class="memItemLeft" align="right" valign="top">NVNINLINE const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3eb0f055816559741a871fa6c1817b06">nvnSamplerPoolGetMemoryPool_fastpath</a> (const <a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *pool)</td></tr>
<tr class="memdesc:ga3eb0f055816559741a871fa6c1817b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool used by a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">NVNsamplerPool</a> object.  <a href="group__nvn__c__functions.html#ga3eb0f055816559741a871fa6c1817b06">More...</a><br /></td></tr>
<tr class="separator:ga3eb0f055816559741a871fa6c1817b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc23370e8330ae3727bb03f26f5d097c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gadc23370e8330ae3727bb03f26f5d097c">nvnSamplerPoolGetSize</a> (const <a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *pool)</td></tr>
<tr class="memdesc:gadc23370e8330ae3727bb03f26f5d097c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of descriptors in the memory of a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">NVNsamplerPool</a> object.  <a href="group__nvn__c__functions.html#gadc23370e8330ae3727bb03f26f5d097c">More...</a><br /></td></tr>
<tr class="separator:gadc23370e8330ae3727bb03f26f5d097c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8045e82bc788372353472ec61bb08d0d"><td class="memItemLeft" align="right" valign="top">NVNINLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8045e82bc788372353472ec61bb08d0d">nvnSamplerPoolGetSize_fastpath</a> (const <a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *pool)</td></tr>
<tr class="memdesc:ga8045e82bc788372353472ec61bb08d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of descriptors in the memory of a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">NVNsamplerPool</a> object.  <a href="group__nvn__c__functions.html#ga8045e82bc788372353472ec61bb08d0d">More...</a><br /></td></tr>
<tr class="separator:ga8045e82bc788372353472ec61bb08d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac78aeeebf55a677fa61bdceebc46ef5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac78aeeebf55a677fa61bdceebc46ef5b">nvnSamplerPoolInitialize</a> (<a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *samplerPool, const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *memoryPool, ptrdiff_t offset, int numDescriptors)</td></tr>
<tr class="memdesc:gac78aeeebf55a677fa61bdceebc46ef5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">NVNsamplerPool</a> object.  <a href="group__nvn__c__functions.html#gac78aeeebf55a677fa61bdceebc46ef5b">More...</a><br /></td></tr>
<tr class="separator:gac78aeeebf55a677fa61bdceebc46ef5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga534898b94679ef42198d21f4a3bd966e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga534898b94679ef42198d21f4a3bd966e">nvnSamplerPoolRegisterSampler</a> (const <a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *samplerPool, int id, const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler)</td></tr>
<tr class="memdesc:ga534898b94679ef42198d21f4a3bd966e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a sampler descriptor in a sampler pool for use via texture handles, using a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object.  <a href="group__nvn__c__functions.html#ga534898b94679ef42198d21f4a3bd966e">More...</a><br /></td></tr>
<tr class="separator:ga534898b94679ef42198d21f4a3bd966e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33025ca24e76ce3cc2df1844cad3bca8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga33025ca24e76ce3cc2df1844cad3bca8">nvnSamplerPoolRegisterSamplerBuilder</a> (const <a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *samplerPool, int id, const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga33025ca24e76ce3cc2df1844cad3bca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a sampler descriptor in a sampler pool for use via texture handles, using <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> state.  <a href="group__nvn__c__functions.html#ga33025ca24e76ce3cc2df1844cad3bca8">More...</a><br /></td></tr>
<tr class="separator:ga33025ca24e76ce3cc2df1844cad3bca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5a4a7a3602ace4ed28a8249bdaf249f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad5a4a7a3602ace4ed28a8249bdaf249f">nvnSamplerPoolSetDebugLabel</a> (<a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *pool, const char *label)</td></tr>
<tr class="memdesc:gad5a4a7a3602ace4ed28a8249bdaf249f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug label string for a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">NVNsamplerPool</a> object.  <a href="group__nvn__c__functions.html#gad5a4a7a3602ace4ed28a8249bdaf249f">More...</a><br /></td></tr>
<tr class="separator:gad5a4a7a3602ace4ed28a8249bdaf249f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf992a842dafe3db3a3d68c36a7f89b1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf992a842dafe3db3a3d68c36a7f89b1a">nvnSamplerSetDebugLabel</a> (<a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler, const char *label)</td></tr>
<tr class="memdesc:gaf992a842dafe3db3a3d68c36a7f89b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug label string for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object.  <a href="group__nvn__c__functions.html#gaf992a842dafe3db3a3d68c36a7f89b1a">More...</a><br /></td></tr>
<tr class="separator:gaf992a842dafe3db3a3d68c36a7f89b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae11ae660cf9aa3a973a6f38f1174d8a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#gaa4f7646e09407139b1ec66c53f6a1cbf">NVNsyncInteropStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae11ae660cf9aa3a973a6f38f1174d8a9">nvnSyncCreateGLSync</a> (const <a class="el" href="struct_n_v_nsync.html">NVNsync</a> *sync, uint64_t *glSync)</td></tr>
<tr class="memdesc:gae11ae660cf9aa3a973a6f38f1174d8a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a fenced and flushed NVN <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object to create a GLsync.  <a href="group__nvn__c__functions.html#gae11ae660cf9aa3a973a6f38f1174d8a9">More...</a><br /></td></tr>
<tr class="separator:gae11ae660cf9aa3a973a6f38f1174d8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga918f1f02b17ba89d048372ead736a929"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga918f1f02b17ba89d048372ead736a929">nvnSyncFinalize</a> (<a class="el" href="struct_n_v_nsync.html">NVNsync</a> *sync)</td></tr>
<tr class="memdesc:ga918f1f02b17ba89d048372ead736a929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object.  <a href="group__nvn__c__functions.html#ga918f1f02b17ba89d048372ead736a929">More...</a><br /></td></tr>
<tr class="separator:ga918f1f02b17ba89d048372ead736a929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8eeff0f19eaa7bb9b57ea8134411baa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad8eeff0f19eaa7bb9b57ea8134411baa">nvnSyncInitialize</a> (<a class="el" href="struct_n_v_nsync.html">NVNsync</a> *sync, <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device)</td></tr>
<tr class="memdesc:gad8eeff0f19eaa7bb9b57ea8134411baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object for the specified device.  <a href="group__nvn__c__functions.html#gad8eeff0f19eaa7bb9b57ea8134411baa">More...</a><br /></td></tr>
<tr class="separator:gad8eeff0f19eaa7bb9b57ea8134411baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e8bc9ad7077caaf6c73d93a7d49f0e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9e8bc9ad7077caaf6c73d93a7d49f0e8">nvnSyncInitializeFromFencedGLSync</a> (<a class="el" href="struct_n_v_nsync.html">NVNsync</a> *sync, <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, const void *glSync, <a class="el" href="group__nvn__c__enum.html#gaa4f7646e09407139b1ec66c53f6a1cbf">NVNsyncInteropStatus</a> *status)</td></tr>
<tr class="memdesc:ga9e8bc9ad7077caaf6c73d93a7d49f0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a fenced and flushed GLsync object to initialize a NVN <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object.  <a href="group__nvn__c__functions.html#ga9e8bc9ad7077caaf6c73d93a7d49f0e8">More...</a><br /></td></tr>
<tr class="separator:ga9e8bc9ad7077caaf6c73d93a7d49f0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga052a5bc70782ffe27301d0e317e6382b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga052a5bc70782ffe27301d0e317e6382b">nvnSyncSetDebugLabel</a> (<a class="el" href="struct_n_v_nsync.html">NVNsync</a> *sync, const char *label)</td></tr>
<tr class="memdesc:ga052a5bc70782ffe27301d0e317e6382b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug label string for a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object.  <a href="group__nvn__c__functions.html#ga052a5bc70782ffe27301d0e317e6382b">More...</a><br /></td></tr>
<tr class="separator:ga052a5bc70782ffe27301d0e317e6382b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e9deb5d068866fe0c32929a3f82baf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga52ff133a79fc03ef1f60a3e7946332a1">NVNsyncWaitResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2e9deb5d068866fe0c32929a3f82baf3">nvnSyncWait</a> (const <a class="el" href="struct_n_v_nsync.html">NVNsync</a> *sync, uint64_t timeoutNs)</td></tr>
<tr class="memdesc:ga2e9deb5d068866fe0c32929a3f82baf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object to be signaled on the CPU before returning.  <a href="group__nvn__c__functions.html#ga2e9deb5d068866fe0c32929a3f82baf3">More...</a><br /></td></tr>
<tr class="separator:ga2e9deb5d068866fe0c32929a3f82baf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab08075b4fd422c5586f418ec95432ca8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab08075b4fd422c5586f418ec95432ca8">nvnTextureBuilderGetDepth</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:gab08075b4fd422c5586f418ec95432ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the depth for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#gab08075b4fd422c5586f418ec95432ca8">More...</a><br /></td></tr>
<tr class="separator:gab08075b4fd422c5586f418ec95432ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93b3a10d1240766fbc6db48266972377"><td class="memItemLeft" align="right" valign="top">NVNINLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga93b3a10d1240766fbc6db48266972377">nvnTextureBuilderGetDepth_fastpath</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga93b3a10d1240766fbc6db48266972377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the depth for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#ga93b3a10d1240766fbc6db48266972377">More...</a><br /></td></tr>
<tr class="separator:ga93b3a10d1240766fbc6db48266972377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae190535d6c7660700220beee28fabb20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga3fc9be97b8a8e51aacbaf2d93edb9b1c">NVNtextureDepthStencilMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae190535d6c7660700220beee28fabb20">nvnTextureBuilderGetDepthStencilMode</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:gae190535d6c7660700220beee28fabb20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the depth/stencil mode for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#gae190535d6c7660700220beee28fabb20">More...</a><br /></td></tr>
<tr class="separator:gae190535d6c7660700220beee28fabb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44b7411c51def8c3ecc859873003b3bb"><td class="memItemLeft" align="right" valign="top">NVNINLINE <a class="el" href="group__nvn__c__enum.html#ga3fc9be97b8a8e51aacbaf2d93edb9b1c">NVNtextureDepthStencilMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga44b7411c51def8c3ecc859873003b3bb">nvnTextureBuilderGetDepthStencilMode_fastpath</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga44b7411c51def8c3ecc859873003b3bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the depth/stencil mode for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#ga44b7411c51def8c3ecc859873003b3bb">More...</a><br /></td></tr>
<tr class="separator:ga44b7411c51def8c3ecc859873003b3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf602e9d491bac3c2389d3f62e5fc3a82"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf602e9d491bac3c2389d3f62e5fc3a82">nvnTextureBuilderGetDevice</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:gaf602e9d491bac3c2389d3f62e5fc3a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the device associated with this <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#gaf602e9d491bac3c2389d3f62e5fc3a82">More...</a><br /></td></tr>
<tr class="separator:gaf602e9d491bac3c2389d3f62e5fc3a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga392d7354936040055696d5e306ec0b23"><td class="memItemLeft" align="right" valign="top">NVNINLINE const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga392d7354936040055696d5e306ec0b23">nvnTextureBuilderGetDevice_fastpath</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga392d7354936040055696d5e306ec0b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the device associated with this <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#ga392d7354936040055696d5e306ec0b23">More...</a><br /></td></tr>
<tr class="separator:ga392d7354936040055696d5e306ec0b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e8501ec354c364fc84ac787a1b29042"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga57ab2536473c8e62f621554a2618121b">NVNtextureFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga5e8501ec354c364fc84ac787a1b29042">nvnTextureBuilderGetFlags</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga5e8501ec354c364fc84ac787a1b29042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the flags for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#ga5e8501ec354c364fc84ac787a1b29042">More...</a><br /></td></tr>
<tr class="separator:ga5e8501ec354c364fc84ac787a1b29042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac234d1568f85b9c250d001aa987215d9"><td class="memItemLeft" align="right" valign="top">NVNINLINE <a class="el" href="group__nvn__c__enum.html#ga57ab2536473c8e62f621554a2618121b">NVNtextureFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac234d1568f85b9c250d001aa987215d9">nvnTextureBuilderGetFlags_fastpath</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:gac234d1568f85b9c250d001aa987215d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the flags for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#gac234d1568f85b9c250d001aa987215d9">More...</a><br /></td></tr>
<tr class="separator:gac234d1568f85b9c250d001aa987215d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8882c4fa3c8f9f232bcc966516005a2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8882c4fa3c8f9f232bcc966516005a2f">nvnTextureBuilderGetFormat</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga8882c4fa3c8f9f232bcc966516005a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the format for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#ga8882c4fa3c8f9f232bcc966516005a2f">More...</a><br /></td></tr>
<tr class="separator:ga8882c4fa3c8f9f232bcc966516005a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66b114c3b0b350cdbd5f363e352f0176"><td class="memItemLeft" align="right" valign="top">NVNINLINE <a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga66b114c3b0b350cdbd5f363e352f0176">nvnTextureBuilderGetFormat_fastpath</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga66b114c3b0b350cdbd5f363e352f0176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the format for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#ga66b114c3b0b350cdbd5f363e352f0176">More...</a><br /></td></tr>
<tr class="separator:ga66b114c3b0b350cdbd5f363e352f0176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad49dafe49d8e52a12518c8dc492fe71"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaad49dafe49d8e52a12518c8dc492fe71">nvnTextureBuilderGetGLTextureName</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:gaad49dafe49d8e52a12518c8dc492fe71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the OpenGL or OpenGL ES texture to use as an external texture source.  <a href="group__nvn__c__functions.html#gaad49dafe49d8e52a12518c8dc492fe71">More...</a><br /></td></tr>
<tr class="separator:gaad49dafe49d8e52a12518c8dc492fe71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga971d5f87eb203ca015164e8818d6eba2"><td class="memItemLeft" align="right" valign="top">NVNINLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga971d5f87eb203ca015164e8818d6eba2">nvnTextureBuilderGetGLTextureName_fastpath</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga971d5f87eb203ca015164e8818d6eba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the OpenGL or OpenGL ES texture to use as an external texture source.  <a href="group__nvn__c__functions.html#ga971d5f87eb203ca015164e8818d6eba2">More...</a><br /></td></tr>
<tr class="separator:ga971d5f87eb203ca015164e8818d6eba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33852e99c26e6d9ca7cce5faf24b55ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga33852e99c26e6d9ca7cce5faf24b55ec">nvnTextureBuilderGetHeight</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga33852e99c26e6d9ca7cce5faf24b55ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the height for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#ga33852e99c26e6d9ca7cce5faf24b55ec">More...</a><br /></td></tr>
<tr class="separator:ga33852e99c26e6d9ca7cce5faf24b55ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6036dbed63c82859bd20a416f4d6c3ed"><td class="memItemLeft" align="right" valign="top">NVNINLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga6036dbed63c82859bd20a416f4d6c3ed">nvnTextureBuilderGetHeight_fastpath</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga6036dbed63c82859bd20a416f4d6c3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the height for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#ga6036dbed63c82859bd20a416f4d6c3ed">More...</a><br /></td></tr>
<tr class="separator:ga6036dbed63c82859bd20a416f4d6c3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga203060aa64e2655e160e502337c80345"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga203060aa64e2655e160e502337c80345">nvnTextureBuilderGetLevels</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga203060aa64e2655e160e502337c80345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the level count for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#ga203060aa64e2655e160e502337c80345">More...</a><br /></td></tr>
<tr class="separator:ga203060aa64e2655e160e502337c80345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86b5b317daf788fb09f9cf163647ad9a"><td class="memItemLeft" align="right" valign="top">NVNINLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga86b5b317daf788fb09f9cf163647ad9a">nvnTextureBuilderGetLevels_fastpath</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga86b5b317daf788fb09f9cf163647ad9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the level count for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#ga86b5b317daf788fb09f9cf163647ad9a">More...</a><br /></td></tr>
<tr class="separator:ga86b5b317daf788fb09f9cf163647ad9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac22e6e0c78a09ad5348b8e6b3e7c5c1a"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac22e6e0c78a09ad5348b8e6b3e7c5c1a">nvnTextureBuilderGetMemoryOffset</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:gac22e6e0c78a09ad5348b8e6b3e7c5c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool offset used by a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#gac22e6e0c78a09ad5348b8e6b3e7c5c1a">More...</a><br /></td></tr>
<tr class="separator:gac22e6e0c78a09ad5348b8e6b3e7c5c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b13a9099081922c63ec6a809be3f0a8"><td class="memItemLeft" align="right" valign="top">NVNINLINE ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1b13a9099081922c63ec6a809be3f0a8">nvnTextureBuilderGetMemoryOffset_fastpath</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga1b13a9099081922c63ec6a809be3f0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool offset used by a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#ga1b13a9099081922c63ec6a809be3f0a8">More...</a><br /></td></tr>
<tr class="separator:ga1b13a9099081922c63ec6a809be3f0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeade4627ca9fc552f5c5b8584a7cd514"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaeade4627ca9fc552f5c5b8584a7cd514">nvnTextureBuilderGetMemoryPool</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:gaeade4627ca9fc552f5c5b8584a7cd514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool used by a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#gaeade4627ca9fc552f5c5b8584a7cd514">More...</a><br /></td></tr>
<tr class="separator:gaeade4627ca9fc552f5c5b8584a7cd514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga697877b97c34b084c69f95c6e61b4e23"><td class="memItemLeft" align="right" valign="top">NVNINLINE <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga697877b97c34b084c69f95c6e61b4e23">nvnTextureBuilderGetMemoryPool_fastpath</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga697877b97c34b084c69f95c6e61b4e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool used by a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#ga697877b97c34b084c69f95c6e61b4e23">More...</a><br /></td></tr>
<tr class="separator:ga697877b97c34b084c69f95c6e61b4e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c64f715837363c1e2920cae77be92da"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4c64f715837363c1e2920cae77be92da">nvnTextureBuilderGetPackagedTextureData</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga4c64f715837363c1e2920cae77be92da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the packaged texture data pointer for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#ga4c64f715837363c1e2920cae77be92da">More...</a><br /></td></tr>
<tr class="separator:ga4c64f715837363c1e2920cae77be92da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d4eab4f6bf7d1b48e53dfa1ee035058"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8d4eab4f6bf7d1b48e53dfa1ee035058">nvnTextureBuilderGetPackagedTextureLayout</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, <a class="el" href="struct_n_v_npackaged_texture_layout.html">NVNpackagedTextureLayout</a> *data)</td></tr>
<tr class="memdesc:ga8d4eab4f6bf7d1b48e53dfa1ee035058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the packaged texture layout associated with this <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#ga8d4eab4f6bf7d1b48e53dfa1ee035058">More...</a><br /></td></tr>
<tr class="separator:ga8d4eab4f6bf7d1b48e53dfa1ee035058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8254860768a38d3ca91de92b62227769"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#gada316a0018ae2f7d069329591e5312c3">NVNrawStorageClass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8254860768a38d3ca91de92b62227769">nvnTextureBuilderGetRawStorageClass</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga8254860768a38d3ca91de92b62227769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the raw storage class associated with this <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#ga8254860768a38d3ca91de92b62227769">More...</a><br /></td></tr>
<tr class="separator:ga8254860768a38d3ca91de92b62227769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga838dc1cd980379c39027331f1390169f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga838dc1cd980379c39027331f1390169f">nvnTextureBuilderGetSamples</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga838dc1cd980379c39027331f1390169f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the sample count for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#ga838dc1cd980379c39027331f1390169f">More...</a><br /></td></tr>
<tr class="separator:ga838dc1cd980379c39027331f1390169f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec8ebb1cb056a93518883f7382a9a934"><td class="memItemLeft" align="right" valign="top">NVNINLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaec8ebb1cb056a93518883f7382a9a934">nvnTextureBuilderGetSamples_fastpath</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:gaec8ebb1cb056a93518883f7382a9a934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the sample count for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#gaec8ebb1cb056a93518883f7382a9a934">More...</a><br /></td></tr>
<tr class="separator:gaec8ebb1cb056a93518883f7382a9a934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade45e847441bcf19b57835e7b30e3dbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gade45e847441bcf19b57835e7b30e3dbe">nvnTextureBuilderGetSparseTileLayout</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, <a class="el" href="struct_n_v_ntexture_sparse_tile_layout.html">NVNtextureSparseTileLayout</a> *layout)</td></tr>
<tr class="memdesc:gade45e847441bcf19b57835e7b30e3dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns properties of the sparse memory layout for a texture to be created using the provided <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#gade45e847441bcf19b57835e7b30e3dbe">More...</a><br /></td></tr>
<tr class="separator:gade45e847441bcf19b57835e7b30e3dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05c4e80a256b37ed63e1478ffd680eab"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga05c4e80a256b37ed63e1478ffd680eab">nvnTextureBuilderGetStorageAlignment</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga05c4e80a256b37ed63e1478ffd680eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum alignment in bytes (in bytes) required to hold a texture to be created using the provided <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#ga05c4e80a256b37ed63e1478ffd680eab">More...</a><br /></td></tr>
<tr class="separator:ga05c4e80a256b37ed63e1478ffd680eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4136c92f14cf364c1776814c31d098a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga4e21960c2b9244bbd2753954b23580d3">NVNstorageClass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad4136c92f14cf364c1776814c31d098a">nvnTextureBuilderGetStorageClass</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:gad4136c92f14cf364c1776814c31d098a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the storage class needed for virtual memory mappings for a texture to be created using the provided <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#gad4136c92f14cf364c1776814c31d098a">More...</a><br /></td></tr>
<tr class="separator:gad4136c92f14cf364c1776814c31d098a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ba9cfd0600643dbb909eaa9c36abe26"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1ba9cfd0600643dbb909eaa9c36abe26">nvnTextureBuilderGetStorageSize</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga1ba9cfd0600643dbb909eaa9c36abe26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of memory (in bytes) required to hold a texture to be created using the provided <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#ga1ba9cfd0600643dbb909eaa9c36abe26">More...</a><br /></td></tr>
<tr class="separator:ga1ba9cfd0600643dbb909eaa9c36abe26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9939e7f8604b5c1c58eade93a8c6f2df"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9939e7f8604b5c1c58eade93a8c6f2df">nvnTextureBuilderGetStride</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga9939e7f8604b5c1c58eade93a8c6f2df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the stride for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#ga9939e7f8604b5c1c58eade93a8c6f2df">More...</a><br /></td></tr>
<tr class="separator:ga9939e7f8604b5c1c58eade93a8c6f2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gababa0aba972e4b42112909e0fad93180"><td class="memItemLeft" align="right" valign="top">NVNINLINE ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gababa0aba972e4b42112909e0fad93180">nvnTextureBuilderGetStride_fastpath</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:gababa0aba972e4b42112909e0fad93180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the stride for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#gababa0aba972e4b42112909e0fad93180">More...</a><br /></td></tr>
<tr class="separator:gababa0aba972e4b42112909e0fad93180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad00012a5e2ba6e63b8c022fff5d233c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad00012a5e2ba6e63b8c022fff5d233c8">nvnTextureBuilderGetSwizzle</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *r, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *g, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *b, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *a)</td></tr>
<tr class="memdesc:gad00012a5e2ba6e63b8c022fff5d233c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the swizzles for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#gad00012a5e2ba6e63b8c022fff5d233c8">More...</a><br /></td></tr>
<tr class="separator:gad00012a5e2ba6e63b8c022fff5d233c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0202b12c55ce5a46f3c023266d8c454"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga7f247010f53480c7dd1f3b2ad638c431">NVNtextureTarget</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf0202b12c55ce5a46f3c023266d8c454">nvnTextureBuilderGetTarget</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:gaf0202b12c55ce5a46f3c023266d8c454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the target for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#gaf0202b12c55ce5a46f3c023266d8c454">More...</a><br /></td></tr>
<tr class="separator:gaf0202b12c55ce5a46f3c023266d8c454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a0cab3b48389afdc34492c8762e1403"><td class="memItemLeft" align="right" valign="top">NVNINLINE <a class="el" href="group__nvn__c__enum.html#ga7f247010f53480c7dd1f3b2ad638c431">NVNtextureTarget</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8a0cab3b48389afdc34492c8762e1403">nvnTextureBuilderGetTarget_fastpath</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga8a0cab3b48389afdc34492c8762e1403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the target for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#ga8a0cab3b48389afdc34492c8762e1403">More...</a><br /></td></tr>
<tr class="separator:ga8a0cab3b48389afdc34492c8762e1403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad412a4af5aa2ce9732256345b9b7c0a7"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad412a4af5aa2ce9732256345b9b7c0a7">nvnTextureBuilderGetViewOffset</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *textureView)</td></tr>
<tr class="memdesc:gad412a4af5aa2ce9732256345b9b7c0a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the offset (in bytes) of the first byte of storage used by a view of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object created by the provided <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>.  <a href="group__nvn__c__functions.html#gad412a4af5aa2ce9732256345b9b7c0a7">More...</a><br /></td></tr>
<tr class="separator:gad412a4af5aa2ce9732256345b9b7c0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga386847eb4289c7cd7ad45ee0d2b62918"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga386847eb4289c7cd7ad45ee0d2b62918">nvnTextureBuilderGetWidth</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga386847eb4289c7cd7ad45ee0d2b62918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the width for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#ga386847eb4289c7cd7ad45ee0d2b62918">More...</a><br /></td></tr>
<tr class="separator:ga386847eb4289c7cd7ad45ee0d2b62918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49dc0ac55c9c351e8e1810cd6e81ed6b"><td class="memItemLeft" align="right" valign="top">NVNINLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga49dc0ac55c9c351e8e1810cd6e81ed6b">nvnTextureBuilderGetWidth_fastpath</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga49dc0ac55c9c351e8e1810cd6e81ed6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the width for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#ga49dc0ac55c9c351e8e1810cd6e81ed6b">More...</a><br /></td></tr>
<tr class="separator:ga49dc0ac55c9c351e8e1810cd6e81ed6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa00aaba8acd99e423733589231ac411a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaa00aaba8acd99e423733589231ac411a">nvnTextureBuilderGetZCullStorageSize</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:gaa00aaba8acd99e423733589231ac411a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of memory (in bytes) required to hold a ZCull save/restore buffer for a depth texture.  <a href="group__nvn__c__functions.html#gaa00aaba8acd99e423733589231ac411a">More...</a><br /></td></tr>
<tr class="separator:gaa00aaba8acd99e423733589231ac411a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6287f82327692478ee9040e4fe73dd36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga6287f82327692478ee9040e4fe73dd36">nvnTextureBuilderSetDefaults</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga6287f82327692478ee9040e4fe73dd36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#ga6287f82327692478ee9040e4fe73dd36">More...</a><br /></td></tr>
<tr class="separator:ga6287f82327692478ee9040e4fe73dd36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad86f04179d66882fe758554678311e42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad86f04179d66882fe758554678311e42">nvnTextureBuilderSetDepth</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, int depth)</td></tr>
<tr class="memdesc:gad86f04179d66882fe758554678311e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the depth (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>.  <a href="group__nvn__c__functions.html#gad86f04179d66882fe758554678311e42">More...</a><br /></td></tr>
<tr class="separator:gad86f04179d66882fe758554678311e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa90855fc25d3451bc9aa82c92d4b3923"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaa90855fc25d3451bc9aa82c92d4b3923">nvnTextureBuilderSetDepth_fastpath</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, int depth)</td></tr>
<tr class="memdesc:gaa90855fc25d3451bc9aa82c92d4b3923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the depth (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>.  <a href="group__nvn__c__functions.html#gaa90855fc25d3451bc9aa82c92d4b3923">More...</a><br /></td></tr>
<tr class="separator:gaa90855fc25d3451bc9aa82c92d4b3923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1f0c27399978e0f15954533cc4763bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad1f0c27399978e0f15954533cc4763bd">nvnTextureBuilderSetDepthStencilMode</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, <a class="el" href="group__nvn__c__enum.html#ga3fc9be97b8a8e51aacbaf2d93edb9b1c">NVNtextureDepthStencilMode</a> mode)</td></tr>
<tr class="memdesc:gad1f0c27399978e0f15954533cc4763bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the values returned for depth/stencil <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>.  <a href="group__nvn__c__functions.html#gad1f0c27399978e0f15954533cc4763bd">More...</a><br /></td></tr>
<tr class="separator:gad1f0c27399978e0f15954533cc4763bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4d5094e5922edff81723ff08abbf77f"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae4d5094e5922edff81723ff08abbf77f">nvnTextureBuilderSetDepthStencilMode_fastpath</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, <a class="el" href="group__nvn__c__enum.html#ga3fc9be97b8a8e51aacbaf2d93edb9b1c">NVNtextureDepthStencilMode</a> mode)</td></tr>
<tr class="memdesc:gae4d5094e5922edff81723ff08abbf77f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the values returned for depth/stencil <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>.  <a href="group__nvn__c__functions.html#gae4d5094e5922edff81723ff08abbf77f">More...</a><br /></td></tr>
<tr class="separator:gae4d5094e5922edff81723ff08abbf77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3125b10128cdf01e0c489ebf9644cc36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3125b10128cdf01e0c489ebf9644cc36">nvnTextureBuilderSetDevice</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device)</td></tr>
<tr class="memdesc:ga3125b10128cdf01e0c489ebf9644cc36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> associated with a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object.  <a href="group__nvn__c__functions.html#ga3125b10128cdf01e0c489ebf9644cc36">More...</a><br /></td></tr>
<tr class="separator:ga3125b10128cdf01e0c489ebf9644cc36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga249280b0e8c57ead0fa7a82a8ebc56f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga249280b0e8c57ead0fa7a82a8ebc56f9">nvnTextureBuilderSetFlags</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, int flags)</td></tr>
<tr class="memdesc:ga249280b0e8c57ead0fa7a82a8ebc56f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set flags indentifying special properties of <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>.  <a href="group__nvn__c__functions.html#ga249280b0e8c57ead0fa7a82a8ebc56f9">More...</a><br /></td></tr>
<tr class="separator:ga249280b0e8c57ead0fa7a82a8ebc56f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad83f59e208a24b5843543e1d0c7aec8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad83f59e208a24b5843543e1d0c7aec8a">nvnTextureBuilderSetFormat</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, <a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a> format)</td></tr>
<tr class="memdesc:gad83f59e208a24b5843543e1d0c7aec8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab" title="Identifies how data elements stored in texture or buffer objects are encoded.">NVNformat</a> for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>.  <a href="group__nvn__c__functions.html#gad83f59e208a24b5843543e1d0c7aec8a">More...</a><br /></td></tr>
<tr class="separator:gad83f59e208a24b5843543e1d0c7aec8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b2053fd0ba53f7db4419f284c76285e"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4b2053fd0ba53f7db4419f284c76285e">nvnTextureBuilderSetFormat_fastpath</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, <a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a> format)</td></tr>
<tr class="memdesc:ga4b2053fd0ba53f7db4419f284c76285e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab" title="Identifies how data elements stored in texture or buffer objects are encoded.">NVNformat</a> for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>.  <a href="group__nvn__c__functions.html#ga4b2053fd0ba53f7db4419f284c76285e">More...</a><br /></td></tr>
<tr class="separator:ga4b2053fd0ba53f7db4419f284c76285e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8382ee09ab0b9f65b84368aa3aa8fef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae8382ee09ab0b9f65b84368aa3aa8fef">nvnTextureBuilderSetGLTextureName</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, uint32_t name)</td></tr>
<tr class="memdesc:gae8382ee09ab0b9f65b84368aa3aa8fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the name of the OpenGL texture to use as an external texture source.  <a href="group__nvn__c__functions.html#gae8382ee09ab0b9f65b84368aa3aa8fef">More...</a><br /></td></tr>
<tr class="separator:gae8382ee09ab0b9f65b84368aa3aa8fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6c93fbfa974a07606f5c398adb4a080"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad6c93fbfa974a07606f5c398adb4a080">nvnTextureBuilderSetHeight</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, int height)</td></tr>
<tr class="memdesc:gad6c93fbfa974a07606f5c398adb4a080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the height (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>.  <a href="group__nvn__c__functions.html#gad6c93fbfa974a07606f5c398adb4a080">More...</a><br /></td></tr>
<tr class="separator:gad6c93fbfa974a07606f5c398adb4a080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cda9dba5319ded82a20b806bb384d17"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7cda9dba5319ded82a20b806bb384d17">nvnTextureBuilderSetHeight_fastpath</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, int height)</td></tr>
<tr class="memdesc:ga7cda9dba5319ded82a20b806bb384d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the height (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>.  <a href="group__nvn__c__functions.html#ga7cda9dba5319ded82a20b806bb384d17">More...</a><br /></td></tr>
<tr class="separator:ga7cda9dba5319ded82a20b806bb384d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b84b7b97960b702cd6e8438e0bc303b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7b84b7b97960b702cd6e8438e0bc303b">nvnTextureBuilderSetLevels</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, int numLevels)</td></tr>
<tr class="memdesc:ga7b84b7b97960b702cd6e8438e0bc303b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of mipmap levels for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>.  <a href="group__nvn__c__functions.html#ga7b84b7b97960b702cd6e8438e0bc303b">More...</a><br /></td></tr>
<tr class="separator:ga7b84b7b97960b702cd6e8438e0bc303b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee1ad9054811161e66566175088ff000"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaee1ad9054811161e66566175088ff000">nvnTextureBuilderSetLevels_fastpath</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, int numLevels)</td></tr>
<tr class="memdesc:gaee1ad9054811161e66566175088ff000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of mipmap levels for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>.  <a href="group__nvn__c__functions.html#gaee1ad9054811161e66566175088ff000">More...</a><br /></td></tr>
<tr class="separator:gaee1ad9054811161e66566175088ff000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ccd08d4bafb09088fb0c39aea731354"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga6ccd08d4bafb09088fb0c39aea731354">nvnTextureBuilderSetPackagedTextureData</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, const void *data)</td></tr>
<tr class="memdesc:ga6ccd08d4bafb09088fb0c39aea731354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify optional packaged texture data used to initialize texture storage.  <a href="group__nvn__c__functions.html#ga6ccd08d4bafb09088fb0c39aea731354">More...</a><br /></td></tr>
<tr class="separator:ga6ccd08d4bafb09088fb0c39aea731354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9c504fb68daac897da16e9161e61eb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab9c504fb68daac897da16e9161e61eb7">nvnTextureBuilderSetPackagedTextureLayout</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, const <a class="el" href="struct_n_v_npackaged_texture_layout.html">NVNpackagedTextureLayout</a> *layout)</td></tr>
<tr class="memdesc:gab9c504fb68daac897da16e9161e61eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the layout of packaged texture data used for texture storage.  <a href="group__nvn__c__functions.html#gab9c504fb68daac897da16e9161e61eb7">More...</a><br /></td></tr>
<tr class="separator:gab9c504fb68daac897da16e9161e61eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d9a12fdb214af17acac6536d23cd911"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0d9a12fdb214af17acac6536d23cd911">nvnTextureBuilderSetSamples</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, int samples)</td></tr>
<tr class="memdesc:ga0d9a12fdb214af17acac6536d23cd911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sample count for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>.  <a href="group__nvn__c__functions.html#ga0d9a12fdb214af17acac6536d23cd911">More...</a><br /></td></tr>
<tr class="separator:ga0d9a12fdb214af17acac6536d23cd911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f3a3be05f2c5477f75036efcafb9fbf"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9f3a3be05f2c5477f75036efcafb9fbf">nvnTextureBuilderSetSamples_fastpath</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, int samples)</td></tr>
<tr class="memdesc:ga9f3a3be05f2c5477f75036efcafb9fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sample count for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>.  <a href="group__nvn__c__functions.html#ga9f3a3be05f2c5477f75036efcafb9fbf">More...</a><br /></td></tr>
<tr class="separator:ga9f3a3be05f2c5477f75036efcafb9fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff26847111e7f31129495f9211db22d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaff26847111e7f31129495f9211db22d6">nvnTextureBuilderSetSize1D</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, int width)</td></tr>
<tr class="memdesc:gaff26847111e7f31129495f9211db22d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the width (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>.  <a href="group__nvn__c__functions.html#gaff26847111e7f31129495f9211db22d6">More...</a><br /></td></tr>
<tr class="separator:gaff26847111e7f31129495f9211db22d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eb945f455f851adf9b738be38cfb0bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1eb945f455f851adf9b738be38cfb0bc">nvnTextureBuilderSetSize2D</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, int width, int height)</td></tr>
<tr class="memdesc:ga1eb945f455f851adf9b738be38cfb0bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the width and height (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>.  <a href="group__nvn__c__functions.html#ga1eb945f455f851adf9b738be38cfb0bc">More...</a><br /></td></tr>
<tr class="separator:ga1eb945f455f851adf9b738be38cfb0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1295ca18055627e3128e6ec7f0be5439"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1295ca18055627e3128e6ec7f0be5439">nvnTextureBuilderSetSize3D</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, int width, int height, int depth)</td></tr>
<tr class="memdesc:ga1295ca18055627e3128e6ec7f0be5439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the width, height, and depth (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>.  <a href="group__nvn__c__functions.html#ga1295ca18055627e3128e6ec7f0be5439">More...</a><br /></td></tr>
<tr class="separator:ga1295ca18055627e3128e6ec7f0be5439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a056b36730ab3bb163648b5a93ca7c8"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga6a056b36730ab3bb163648b5a93ca7c8">nvnTextureBuilderSetSize3D_fastpath</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, int width, int height, int depth)</td></tr>
<tr class="memdesc:ga6a056b36730ab3bb163648b5a93ca7c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the width, height, and depth (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>.  <a href="group__nvn__c__functions.html#ga6a056b36730ab3bb163648b5a93ca7c8">More...</a><br /></td></tr>
<tr class="separator:ga6a056b36730ab3bb163648b5a93ca7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6530c01a016b836ad82434f6a793cd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf6530c01a016b836ad82434f6a793cd8">nvnTextureBuilderSetStorage</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *pool, ptrdiff_t offset)</td></tr>
<tr class="memdesc:gaf6530c01a016b836ad82434f6a793cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the location in a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> used for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>.  <a href="group__nvn__c__functions.html#gaf6530c01a016b836ad82434f6a793cd8">More...</a><br /></td></tr>
<tr class="separator:gaf6530c01a016b836ad82434f6a793cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad23f93b4dba4217792daee5196eb8d28"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad23f93b4dba4217792daee5196eb8d28">nvnTextureBuilderSetStorage_fastpath</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *pool, ptrdiff_t offset)</td></tr>
<tr class="memdesc:gad23f93b4dba4217792daee5196eb8d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the location in a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> used for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>.  <a href="group__nvn__c__functions.html#gad23f93b4dba4217792daee5196eb8d28">More...</a><br /></td></tr>
<tr class="separator:gad23f93b4dba4217792daee5196eb8d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaadb0c9f8190a0f8dbc4e637f593636"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gabaadb0c9f8190a0f8dbc4e637f593636">nvnTextureBuilderSetStride</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, ptrdiff_t stride)</td></tr>
<tr class="memdesc:gabaadb0c9f8190a0f8dbc4e637f593636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify stride for linear textures.  <a href="group__nvn__c__functions.html#gabaadb0c9f8190a0f8dbc4e637f593636">More...</a><br /></td></tr>
<tr class="separator:gabaadb0c9f8190a0f8dbc4e637f593636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc101b1093b409c29b8db4a6f144d968"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gabc101b1093b409c29b8db4a6f144d968">nvnTextureBuilderSetSwizzle</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> r, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> g, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> b, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> a)</td></tr>
<tr class="memdesc:gabc101b1093b409c29b8db4a6f144d968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the texture swizzle for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>.  <a href="group__nvn__c__functions.html#gabc101b1093b409c29b8db4a6f144d968">More...</a><br /></td></tr>
<tr class="separator:gabc101b1093b409c29b8db4a6f144d968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7e80e3d31c6cffc51d255cbe86694b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaa7e80e3d31c6cffc51d255cbe86694b3">nvnTextureBuilderSetTarget</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, <a class="el" href="group__nvn__c__enum.html#ga7f247010f53480c7dd1f3b2ad638c431">NVNtextureTarget</a> target)</td></tr>
<tr class="memdesc:gaa7e80e3d31c6cffc51d255cbe86694b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the target (texture type) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>.  <a href="group__nvn__c__functions.html#gaa7e80e3d31c6cffc51d255cbe86694b3">More...</a><br /></td></tr>
<tr class="separator:gaa7e80e3d31c6cffc51d255cbe86694b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5712a1cc40bad51852c8d3e81e8108c5"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga5712a1cc40bad51852c8d3e81e8108c5">nvnTextureBuilderSetTarget_fastpath</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, <a class="el" href="group__nvn__c__enum.html#ga7f247010f53480c7dd1f3b2ad638c431">NVNtextureTarget</a> target)</td></tr>
<tr class="memdesc:ga5712a1cc40bad51852c8d3e81e8108c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the target (texture type) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>.  <a href="group__nvn__c__functions.html#ga5712a1cc40bad51852c8d3e81e8108c5">More...</a><br /></td></tr>
<tr class="separator:ga5712a1cc40bad51852c8d3e81e8108c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb74efcd860292768c1ee95c09c647c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaeb74efcd860292768c1ee95c09c647c7">nvnTextureBuilderSetWidth</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, int width)</td></tr>
<tr class="memdesc:gaeb74efcd860292768c1ee95c09c647c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the width (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>.  <a href="group__nvn__c__functions.html#gaeb74efcd860292768c1ee95c09c647c7">More...</a><br /></td></tr>
<tr class="separator:gaeb74efcd860292768c1ee95c09c647c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98d1393cc6947bb371edbab1f254cba7"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga98d1393cc6947bb371edbab1f254cba7">nvnTextureBuilderSetWidth_fastpath</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, int width)</td></tr>
<tr class="memdesc:ga98d1393cc6947bb371edbab1f254cba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the width (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>.  <a href="group__nvn__c__functions.html#ga98d1393cc6947bb371edbab1f254cba7">More...</a><br /></td></tr>
<tr class="separator:ga98d1393cc6947bb371edbab1f254cba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga236976f3597cb6595dc0703c6a8e7dae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga236976f3597cb6595dc0703c6a8e7dae">nvnTextureCompare</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *otherTexture)</td></tr>
<tr class="memdesc:ga236976f3597cb6595dc0703c6a8e7dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if texture objects are equivalent.  <a href="group__nvn__c__functions.html#ga236976f3597cb6595dc0703c6a8e7dae">More...</a><br /></td></tr>
<tr class="separator:ga236976f3597cb6595dc0703c6a8e7dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5741253f7ab5c9075a6821a68cfa351"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaa5741253f7ab5c9075a6821a68cfa351">nvnTextureFinalize</a> (<a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:gaa5741253f7ab5c9075a6821a68cfa351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object.  <a href="group__nvn__c__functions.html#gaa5741253f7ab5c9075a6821a68cfa351">More...</a><br /></td></tr>
<tr class="separator:gaa5741253f7ab5c9075a6821a68cfa351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga955c791dfe86ae65b7e87903575c0cfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga955c791dfe86ae65b7e87903575c0cfa">nvnTextureFlushTexels</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *textureView, const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *region)</td></tr>
<tr class="memdesc:ga955c791dfe86ae65b7e87903575c0cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush CPU cache lines holding portions of a texture.  <a href="group__nvn__c__functions.html#ga955c791dfe86ae65b7e87903575c0cfa">More...</a><br /></td></tr>
<tr class="separator:ga955c791dfe86ae65b7e87903575c0cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89c5c4383243a7679a4d4d9977ffc365"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga89c5c4383243a7679a4d4d9977ffc365">nvnTextureGetDebugID</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:ga89c5c4383243a7679a4d4d9977ffc365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the debug layer unique ID of this texture.  <a href="group__nvn__c__functions.html#ga89c5c4383243a7679a4d4d9977ffc365">More...</a><br /></td></tr>
<tr class="separator:ga89c5c4383243a7679a4d4d9977ffc365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1949a4d4cb3eaf94f805beae5748209d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1949a4d4cb3eaf94f805beae5748209d">nvnTextureGetDepth</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:ga1949a4d4cb3eaf94f805beae5748209d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the depth for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object.  <a href="group__nvn__c__functions.html#ga1949a4d4cb3eaf94f805beae5748209d">More...</a><br /></td></tr>
<tr class="separator:ga1949a4d4cb3eaf94f805beae5748209d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga745f91a439a4c7ab71f1e58cd2e2246b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga3fc9be97b8a8e51aacbaf2d93edb9b1c">NVNtextureDepthStencilMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga745f91a439a4c7ab71f1e58cd2e2246b">nvnTextureGetDepthStencilMode</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:ga745f91a439a4c7ab71f1e58cd2e2246b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the depth/stencil mode for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object.  <a href="group__nvn__c__functions.html#ga745f91a439a4c7ab71f1e58cd2e2246b">More...</a><br /></td></tr>
<tr class="separator:ga745f91a439a4c7ab71f1e58cd2e2246b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b2185123abcb5454ce65f662c34e166"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga57ab2536473c8e62f621554a2618121b">NVNtextureFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2b2185123abcb5454ce65f662c34e166">nvnTextureGetFlags</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:ga2b2185123abcb5454ce65f662c34e166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the flags for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object.  <a href="group__nvn__c__functions.html#ga2b2185123abcb5454ce65f662c34e166">More...</a><br /></td></tr>
<tr class="separator:ga2b2185123abcb5454ce65f662c34e166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1d6ee5609a77cbcc3d7af85edf1ea76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaa1d6ee5609a77cbcc3d7af85edf1ea76">nvnTextureGetFormat</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:gaa1d6ee5609a77cbcc3d7af85edf1ea76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the format for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object.  <a href="group__nvn__c__functions.html#gaa1d6ee5609a77cbcc3d7af85edf1ea76">More...</a><br /></td></tr>
<tr class="separator:gaa1d6ee5609a77cbcc3d7af85edf1ea76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53c4d11d01059c6d3d875ecf85ede8a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga53c4d11d01059c6d3d875ecf85ede8a5">nvnTextureGetHeight</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:ga53c4d11d01059c6d3d875ecf85ede8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the height for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object.  <a href="group__nvn__c__functions.html#ga53c4d11d01059c6d3d875ecf85ede8a5">More...</a><br /></td></tr>
<tr class="separator:ga53c4d11d01059c6d3d875ecf85ede8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab847c77fff2d7ff0597ba6138da6dae5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab847c77fff2d7ff0597ba6138da6dae5">nvnTextureGetLevels</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:gab847c77fff2d7ff0597ba6138da6dae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the level count for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object.  <a href="group__nvn__c__functions.html#gab847c77fff2d7ff0597ba6138da6dae5">More...</a><br /></td></tr>
<tr class="separator:gab847c77fff2d7ff0597ba6138da6dae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec925c37d4094927b8e9fc1d9808545a"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaec925c37d4094927b8e9fc1d9808545a">nvnTextureGetMemoryOffset</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:gaec925c37d4094927b8e9fc1d9808545a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool offset used by a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object.  <a href="group__nvn__c__functions.html#gaec925c37d4094927b8e9fc1d9808545a">More...</a><br /></td></tr>
<tr class="separator:gaec925c37d4094927b8e9fc1d9808545a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15b7941491a88ad4abf82bdc145216f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga15b7941491a88ad4abf82bdc145216f7">nvnTextureGetMemoryPool</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:ga15b7941491a88ad4abf82bdc145216f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool used by a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object.  <a href="group__nvn__c__functions.html#ga15b7941491a88ad4abf82bdc145216f7">More...</a><br /></td></tr>
<tr class="separator:ga15b7941491a88ad4abf82bdc145216f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab234267003a4032b21f68fbbb23c1c9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#gada316a0018ae2f7d069329591e5312c3">NVNrawStorageClass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab234267003a4032b21f68fbbb23c1c9a">nvnTextureGetRawStorageClass</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:gab234267003a4032b21f68fbbb23c1c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the raw storage class associated with this <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object.  <a href="group__nvn__c__functions.html#gab234267003a4032b21f68fbbb23c1c9a">More...</a><br /></td></tr>
<tr class="separator:gab234267003a4032b21f68fbbb23c1c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05bc2d539e76dd0f5daaf6faccc8d718"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga05bc2d539e76dd0f5daaf6faccc8d718">nvnTextureGetSamples</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:ga05bc2d539e76dd0f5daaf6faccc8d718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the sample count for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object.  <a href="group__nvn__c__functions.html#ga05bc2d539e76dd0f5daaf6faccc8d718">More...</a><br /></td></tr>
<tr class="separator:ga05bc2d539e76dd0f5daaf6faccc8d718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92054c4c5f509f4be2e4b5536f755344"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga92054c4c5f509f4be2e4b5536f755344">nvnTextureGetSparseTileLayout</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture, <a class="el" href="struct_n_v_ntexture_sparse_tile_layout.html">NVNtextureSparseTileLayout</a> *layout)</td></tr>
<tr class="memdesc:ga92054c4c5f509f4be2e4b5536f755344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns properties of the sparse memory layout for a texture.  <a href="group__nvn__c__functions.html#ga92054c4c5f509f4be2e4b5536f755344">More...</a><br /></td></tr>
<tr class="separator:ga92054c4c5f509f4be2e4b5536f755344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga290d7f9e06d3eb2618b601f83d3bbbb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga4e21960c2b9244bbd2753954b23580d3">NVNstorageClass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga290d7f9e06d3eb2618b601f83d3bbbb9">nvnTextureGetStorageClass</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:ga290d7f9e06d3eb2618b601f83d3bbbb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the storage class needed for virtual memory mappings for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object.  <a href="group__nvn__c__functions.html#ga290d7f9e06d3eb2618b601f83d3bbbb9">More...</a><br /></td></tr>
<tr class="separator:ga290d7f9e06d3eb2618b601f83d3bbbb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74382bb40eec4fcbd761e8c76e0bbd3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga74382bb40eec4fcbd761e8c76e0bbd3f">nvnTextureGetStorageSize</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:ga74382bb40eec4fcbd761e8c76e0bbd3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the storage size for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object.  <a href="group__nvn__c__functions.html#ga74382bb40eec4fcbd761e8c76e0bbd3f">More...</a><br /></td></tr>
<tr class="separator:ga74382bb40eec4fcbd761e8c76e0bbd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4813ee9097b828190f3b6098fb3c3ab0"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4813ee9097b828190f3b6098fb3c3ab0">nvnTextureGetStride</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:ga4813ee9097b828190f3b6098fb3c3ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the stride for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object.  <a href="group__nvn__c__functions.html#ga4813ee9097b828190f3b6098fb3c3ab0">More...</a><br /></td></tr>
<tr class="separator:ga4813ee9097b828190f3b6098fb3c3ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8a208369ab9e5f3c15794f023893a5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad8a208369ab9e5f3c15794f023893a5c">nvnTextureGetSwizzle</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *r, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *g, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *b, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *a)</td></tr>
<tr class="memdesc:gad8a208369ab9e5f3c15794f023893a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the swizzles for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object.  <a href="group__nvn__c__functions.html#gad8a208369ab9e5f3c15794f023893a5c">More...</a><br /></td></tr>
<tr class="separator:gad8a208369ab9e5f3c15794f023893a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga785889a42583d3e442610a7385ec2f3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga7f247010f53480c7dd1f3b2ad638c431">NVNtextureTarget</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga785889a42583d3e442610a7385ec2f3f">nvnTextureGetTarget</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:ga785889a42583d3e442610a7385ec2f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the target for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object.  <a href="group__nvn__c__functions.html#ga785889a42583d3e442610a7385ec2f3f">More...</a><br /></td></tr>
<tr class="separator:ga785889a42583d3e442610a7385ec2f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1830936e33236e3808dbf70c8bd076f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__handle.html#ga25907f5565e57af5a1f3f2fef4493887">NVNtextureAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1830936e33236e3808dbf70c8bd076f7">nvnTextureGetTextureAddress</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:ga1830936e33236e3808dbf70c8bd076f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the GPU address of the first byte of memory used by a texture.  <a href="group__nvn__c__functions.html#ga1830936e33236e3808dbf70c8bd076f7">More...</a><br /></td></tr>
<tr class="separator:ga1830936e33236e3808dbf70c8bd076f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f538a9539abbb991fd0c42089293105"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4f538a9539abbb991fd0c42089293105">nvnTextureGetViewOffset</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *textureView)</td></tr>
<tr class="memdesc:ga4f538a9539abbb991fd0c42089293105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the offset (in bytes) of the first byte of storage used by a view of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object.  <a href="group__nvn__c__functions.html#ga4f538a9539abbb991fd0c42089293105">More...</a><br /></td></tr>
<tr class="separator:ga4f538a9539abbb991fd0c42089293105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga529f99644886d9a725ef2bf7b9108a27"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga529f99644886d9a725ef2bf7b9108a27">nvnTextureGetWidth</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:ga529f99644886d9a725ef2bf7b9108a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the width for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object.  <a href="group__nvn__c__functions.html#ga529f99644886d9a725ef2bf7b9108a27">More...</a><br /></td></tr>
<tr class="separator:ga529f99644886d9a725ef2bf7b9108a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73cb447f019bda7152e2ab27a5a9156d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga73cb447f019bda7152e2ab27a5a9156d">nvnTextureGetZCullStorageSize</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:ga73cb447f019bda7152e2ab27a5a9156d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of memory (in bytes) required to hold a ZCull save/restore buffer for a depth texture.  <a href="group__nvn__c__functions.html#ga73cb447f019bda7152e2ab27a5a9156d">More...</a><br /></td></tr>
<tr class="separator:ga73cb447f019bda7152e2ab27a5a9156d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8c5cbaa3292721f1de9d521a66aac3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad8c5cbaa3292721f1de9d521a66aac3e">nvnTextureInitialize</a> (<a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture, const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:gad8c5cbaa3292721f1de9d521a66aac3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a texture object from a texture builder using storage provided by a memory pool.  <a href="group__nvn__c__functions.html#gad8c5cbaa3292721f1de9d521a66aac3e">More...</a><br /></td></tr>
<tr class="separator:gad8c5cbaa3292721f1de9d521a66aac3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec4e878f1036375ad23ff57ceafe53f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaec4e878f1036375ad23ff57ceafe53f2">nvnTextureInvalidateTexels</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *textureView, const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *region)</td></tr>
<tr class="memdesc:gaec4e878f1036375ad23ff57ceafe53f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate CPU cache lines holding portions of a texture.  <a href="group__nvn__c__functions.html#gaec4e878f1036375ad23ff57ceafe53f2">More...</a><br /></td></tr>
<tr class="separator:gaec4e878f1036375ad23ff57ceafe53f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef9948023397e7c1c3294fba08135f68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaef9948023397e7c1c3294fba08135f68">nvnTexturePoolFinalize</a> (<a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *pool)</td></tr>
<tr class="memdesc:gaef9948023397e7c1c3294fba08135f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">NVNtexturePool</a> object.  <a href="group__nvn__c__functions.html#gaef9948023397e7c1c3294fba08135f68">More...</a><br /></td></tr>
<tr class="separator:gaef9948023397e7c1c3294fba08135f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga235dc3565dd2c666c1162229b58c9d36"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga235dc3565dd2c666c1162229b58c9d36">nvnTexturePoolGetMemoryOffset</a> (const <a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *pool)</td></tr>
<tr class="memdesc:ga235dc3565dd2c666c1162229b58c9d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool offset used by a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">NVNtexturePool</a> object.  <a href="group__nvn__c__functions.html#ga235dc3565dd2c666c1162229b58c9d36">More...</a><br /></td></tr>
<tr class="separator:ga235dc3565dd2c666c1162229b58c9d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41c3a27256c9c5eed8648ead0edce062"><td class="memItemLeft" align="right" valign="top">NVNINLINE ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga41c3a27256c9c5eed8648ead0edce062">nvnTexturePoolGetMemoryOffset_fastpath</a> (const <a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *pool)</td></tr>
<tr class="memdesc:ga41c3a27256c9c5eed8648ead0edce062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool offset used by a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">NVNtexturePool</a> object.  <a href="group__nvn__c__functions.html#ga41c3a27256c9c5eed8648ead0edce062">More...</a><br /></td></tr>
<tr class="separator:ga41c3a27256c9c5eed8648ead0edce062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc56cdaa4e3572684ac54699776459f0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gabc56cdaa4e3572684ac54699776459f0">nvnTexturePoolGetMemoryPool</a> (const <a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *pool)</td></tr>
<tr class="memdesc:gabc56cdaa4e3572684ac54699776459f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool used by a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">NVNtexturePool</a> object.  <a href="group__nvn__c__functions.html#gabc56cdaa4e3572684ac54699776459f0">More...</a><br /></td></tr>
<tr class="separator:gabc56cdaa4e3572684ac54699776459f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga051629046cc084fb24541b057a6fad91"><td class="memItemLeft" align="right" valign="top">NVNINLINE const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga051629046cc084fb24541b057a6fad91">nvnTexturePoolGetMemoryPool_fastpath</a> (const <a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *pool)</td></tr>
<tr class="memdesc:ga051629046cc084fb24541b057a6fad91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool used by a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">NVNtexturePool</a> object.  <a href="group__nvn__c__functions.html#ga051629046cc084fb24541b057a6fad91">More...</a><br /></td></tr>
<tr class="separator:ga051629046cc084fb24541b057a6fad91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94185c1c4011d6a6cf9343fa5b923701"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga94185c1c4011d6a6cf9343fa5b923701">nvnTexturePoolGetSize</a> (const <a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *pool)</td></tr>
<tr class="memdesc:ga94185c1c4011d6a6cf9343fa5b923701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of descriptors in the memory of a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">NVNtexturePool</a> object.  <a href="group__nvn__c__functions.html#ga94185c1c4011d6a6cf9343fa5b923701">More...</a><br /></td></tr>
<tr class="separator:ga94185c1c4011d6a6cf9343fa5b923701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0beb1e1bd91db6e12ea0ff619b8e5ed9"><td class="memItemLeft" align="right" valign="top">NVNINLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0beb1e1bd91db6e12ea0ff619b8e5ed9">nvnTexturePoolGetSize_fastpath</a> (const <a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *pool)</td></tr>
<tr class="memdesc:ga0beb1e1bd91db6e12ea0ff619b8e5ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of descriptors in the memory of a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">NVNtexturePool</a> object.  <a href="group__nvn__c__functions.html#ga0beb1e1bd91db6e12ea0ff619b8e5ed9">More...</a><br /></td></tr>
<tr class="separator:ga0beb1e1bd91db6e12ea0ff619b8e5ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3b22a7104a3c1cb6c0ab5c46e753587"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf3b22a7104a3c1cb6c0ab5c46e753587">nvnTexturePoolInitialize</a> (<a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *texturePool, const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *memoryPool, ptrdiff_t offset, int numDescriptors)</td></tr>
<tr class="memdesc:gaf3b22a7104a3c1cb6c0ab5c46e753587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">NVNtexturePool</a> object.  <a href="group__nvn__c__functions.html#gaf3b22a7104a3c1cb6c0ab5c46e753587">More...</a><br /></td></tr>
<tr class="separator:gaf3b22a7104a3c1cb6c0ab5c46e753587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9357d2ef95b193039fab87192187845"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab9357d2ef95b193039fab87192187845">nvnTexturePoolRegisterImage</a> (const <a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *texturePool, int id, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view)</td></tr>
<tr class="memdesc:gab9357d2ef95b193039fab87192187845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an image descriptor in a texture pool for use via image loads and stores.  <a href="group__nvn__c__functions.html#gab9357d2ef95b193039fab87192187845">More...</a><br /></td></tr>
<tr class="separator:gab9357d2ef95b193039fab87192187845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae68c38ccc4963fcdefa710b993104364"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae68c38ccc4963fcdefa710b993104364">nvnTexturePoolRegisterTexture</a> (const <a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *texturePool, int id, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view)</td></tr>
<tr class="memdesc:gae68c38ccc4963fcdefa710b993104364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a texture descriptor in a texture pool for use via texture handles.  <a href="group__nvn__c__functions.html#gae68c38ccc4963fcdefa710b993104364">More...</a><br /></td></tr>
<tr class="separator:gae68c38ccc4963fcdefa710b993104364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58691b87b17bce83845582aa218982f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga58691b87b17bce83845582aa218982f2">nvnTexturePoolSetDebugLabel</a> (<a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *pool, const char *label)</td></tr>
<tr class="memdesc:ga58691b87b17bce83845582aa218982f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug label string for a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">NVNtexturePool</a> object.  <a href="group__nvn__c__functions.html#ga58691b87b17bce83845582aa218982f2">More...</a><br /></td></tr>
<tr class="separator:ga58691b87b17bce83845582aa218982f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a3763d942005f48eaa467571ff8ad8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0a3763d942005f48eaa467571ff8ad8b">nvnTextureReadTexels</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *textureView, const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *region, void *data)</td></tr>
<tr class="memdesc:ga0a3763d942005f48eaa467571ff8ad8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read texture data from a region of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object into memory.  <a href="group__nvn__c__functions.html#ga0a3763d942005f48eaa467571ff8ad8b">More...</a><br /></td></tr>
<tr class="separator:ga0a3763d942005f48eaa467571ff8ad8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3284bbe008a0f733024a6a041579632e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3284bbe008a0f733024a6a041579632e">nvnTextureReadTexelsStrided</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *textureView, const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *region, void *data, ptrdiff_t rowStride, ptrdiff_t imageStride)</td></tr>
<tr class="memdesc:ga3284bbe008a0f733024a6a041579632e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read texture data from a region of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object into memory.  <a href="group__nvn__c__functions.html#ga3284bbe008a0f733024a6a041579632e">More...</a><br /></td></tr>
<tr class="separator:ga3284bbe008a0f733024a6a041579632e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38af53eeec445c9775f1b4715c707570"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga38af53eeec445c9775f1b4715c707570">nvnTextureSetDebugLabel</a> (<a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture, const char *label)</td></tr>
<tr class="memdesc:ga38af53eeec445c9775f1b4715c707570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug label string for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object.  <a href="group__nvn__c__functions.html#ga38af53eeec445c9775f1b4715c707570">More...</a><br /></td></tr>
<tr class="separator:ga38af53eeec445c9775f1b4715c707570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab95e7a5cd51184f9578614b4ec442b78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab95e7a5cd51184f9578614b4ec442b78">nvnTextureViewCompare</a> (const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *otherView)</td></tr>
<tr class="memdesc:gab95e7a5cd51184f9578614b4ec442b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> objects are equivalent.  <a href="group__nvn__c__functions.html#gab95e7a5cd51184f9578614b4ec442b78">More...</a><br /></td></tr>
<tr class="separator:gab95e7a5cd51184f9578614b4ec442b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2176ce574e0478a456a9a87022a25532"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2176ce574e0478a456a9a87022a25532">nvnTextureViewGetDepthStencilMode</a> (const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view, <a class="el" href="group__nvn__c__enum.html#ga3fc9be97b8a8e51aacbaf2d93edb9b1c">NVNtextureDepthStencilMode</a> *mode)</td></tr>
<tr class="memdesc:ga2176ce574e0478a456a9a87022a25532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the depth/stencil mode associated with a <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> object.  <a href="group__nvn__c__functions.html#ga2176ce574e0478a456a9a87022a25532">More...</a><br /></td></tr>
<tr class="separator:ga2176ce574e0478a456a9a87022a25532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf06b460df83524343f9092f1c50d50ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf06b460df83524343f9092f1c50d50ab">nvnTextureViewGetFormat</a> (const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view, <a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a> *format)</td></tr>
<tr class="memdesc:gaf06b460df83524343f9092f1c50d50ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the format associated with a <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> object.  <a href="group__nvn__c__functions.html#gaf06b460df83524343f9092f1c50d50ab">More...</a><br /></td></tr>
<tr class="separator:gaf06b460df83524343f9092f1c50d50ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf9f4f92177b7a7801a6a6d7c829ec00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gacf9f4f92177b7a7801a6a6d7c829ec00">nvnTextureViewGetLayers</a> (const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view, int *minLayer, int *numLayers)</td></tr>
<tr class="memdesc:gacf9f4f92177b7a7801a6a6d7c829ec00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the set of layers associated with a <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> object.  <a href="group__nvn__c__functions.html#gacf9f4f92177b7a7801a6a6d7c829ec00">More...</a><br /></td></tr>
<tr class="separator:gacf9f4f92177b7a7801a6a6d7c829ec00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga367cd40a7a0c3ebfa548291f93bfd4fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga367cd40a7a0c3ebfa548291f93bfd4fd">nvnTextureViewGetLevels</a> (const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view, int *baseLevel, int *numLevels)</td></tr>
<tr class="memdesc:ga367cd40a7a0c3ebfa548291f93bfd4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the set of levels associated with a <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> object.  <a href="group__nvn__c__functions.html#ga367cd40a7a0c3ebfa548291f93bfd4fd">More...</a><br /></td></tr>
<tr class="separator:ga367cd40a7a0c3ebfa548291f93bfd4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e112fd45346310739045b94eeef908f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3e112fd45346310739045b94eeef908f">nvnTextureViewGetSwizzle</a> (const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *r, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *g, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *b, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *a)</td></tr>
<tr class="memdesc:ga3e112fd45346310739045b94eeef908f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the swizzles associated with a <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> object.  <a href="group__nvn__c__functions.html#ga3e112fd45346310739045b94eeef908f">More...</a><br /></td></tr>
<tr class="separator:ga3e112fd45346310739045b94eeef908f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aa74261dd204238deca7932be67bdb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga5aa74261dd204238deca7932be67bdb1">nvnTextureViewGetTarget</a> (const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view, <a class="el" href="group__nvn__c__enum.html#ga7f247010f53480c7dd1f3b2ad638c431">NVNtextureTarget</a> *target)</td></tr>
<tr class="memdesc:ga5aa74261dd204238deca7932be67bdb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the target associated with a <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> object.  <a href="group__nvn__c__functions.html#ga5aa74261dd204238deca7932be67bdb1">More...</a><br /></td></tr>
<tr class="separator:ga5aa74261dd204238deca7932be67bdb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c88faa3760e867dc363f64b46ad3487"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3c88faa3760e867dc363f64b46ad3487">nvnTextureViewSetDefaults</a> (<a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view)</td></tr>
<tr class="memdesc:ga3c88faa3760e867dc363f64b46ad3487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> object.  <a href="group__nvn__c__functions.html#ga3c88faa3760e867dc363f64b46ad3487">More...</a><br /></td></tr>
<tr class="separator:ga3c88faa3760e867dc363f64b46ad3487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f34ef29814d767bb2347759358832db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2f34ef29814d767bb2347759358832db">nvnTextureViewSetDepthStencilMode</a> (<a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view, <a class="el" href="group__nvn__c__enum.html#ga3fc9be97b8a8e51aacbaf2d93edb9b1c">NVNtextureDepthStencilMode</a> mode)</td></tr>
<tr class="memdesc:ga2f34ef29814d767bb2347759358832db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a texture view to select an alternate depth/stencil mode.  <a href="group__nvn__c__functions.html#ga2f34ef29814d767bb2347759358832db">More...</a><br /></td></tr>
<tr class="separator:ga2f34ef29814d767bb2347759358832db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33693bbcbc48e8dd365fa40627d8fc93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga33693bbcbc48e8dd365fa40627d8fc93">nvnTextureViewSetFormat</a> (<a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view, <a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a> format)</td></tr>
<tr class="memdesc:ga33693bbcbc48e8dd365fa40627d8fc93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a texture view to select an alternate texture format.  <a href="group__nvn__c__functions.html#ga33693bbcbc48e8dd365fa40627d8fc93">More...</a><br /></td></tr>
<tr class="separator:ga33693bbcbc48e8dd365fa40627d8fc93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad854d7dac2c34ed9bf7258d5083d12b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad854d7dac2c34ed9bf7258d5083d12b8">nvnTextureViewSetLayers</a> (<a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view, int minLayer, int numLayers)</td></tr>
<tr class="memdesc:gad854d7dac2c34ed9bf7258d5083d12b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a texture view to select a subset of the layers in a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object.  <a href="group__nvn__c__functions.html#gad854d7dac2c34ed9bf7258d5083d12b8">More...</a><br /></td></tr>
<tr class="separator:gad854d7dac2c34ed9bf7258d5083d12b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0bf0a7949e2e49f628bbba2358ef86e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae0bf0a7949e2e49f628bbba2358ef86e">nvnTextureViewSetLevels</a> (<a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view, int baseLevel, int numLevels)</td></tr>
<tr class="memdesc:gae0bf0a7949e2e49f628bbba2358ef86e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a texture view to select a subset of the mipmap levels in a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object.  <a href="group__nvn__c__functions.html#gae0bf0a7949e2e49f628bbba2358ef86e">More...</a><br /></td></tr>
<tr class="separator:gae0bf0a7949e2e49f628bbba2358ef86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga034326c7ada555fedcd5ddb4ed1eeef9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga034326c7ada555fedcd5ddb4ed1eeef9">nvnTextureViewSetSwizzle</a> (<a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> r, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> g, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> b, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> a)</td></tr>
<tr class="memdesc:ga034326c7ada555fedcd5ddb4ed1eeef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a texture view to select an alternate component swizzle.  <a href="group__nvn__c__functions.html#ga034326c7ada555fedcd5ddb4ed1eeef9">More...</a><br /></td></tr>
<tr class="separator:ga034326c7ada555fedcd5ddb4ed1eeef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb89f522ce35d06d0067032ab0e42b0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gabb89f522ce35d06d0067032ab0e42b0f">nvnTextureViewSetTarget</a> (<a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view, <a class="el" href="group__nvn__c__enum.html#ga7f247010f53480c7dd1f3b2ad638c431">NVNtextureTarget</a> target)</td></tr>
<tr class="memdesc:gabb89f522ce35d06d0067032ab0e42b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a texture view to select an alternate texture target.  <a href="group__nvn__c__functions.html#gabb89f522ce35d06d0067032ab0e42b0f">More...</a><br /></td></tr>
<tr class="separator:gabb89f522ce35d06d0067032ab0e42b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e4a235dac08f14ecbaf8e566df8444e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0e4a235dac08f14ecbaf8e566df8444e">nvnTextureWriteTexels</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *textureView, const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *region, const void *data)</td></tr>
<tr class="memdesc:ga0e4a235dac08f14ecbaf8e566df8444e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy texture data from memory into a region of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object.  <a href="group__nvn__c__functions.html#ga0e4a235dac08f14ecbaf8e566df8444e">More...</a><br /></td></tr>
<tr class="separator:ga0e4a235dac08f14ecbaf8e566df8444e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaa6b82b65f0aa146a786e5f08e762ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gacaa6b82b65f0aa146a786e5f08e762ba">nvnTextureWriteTexelsStrided</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *textureView, const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *region, const void *data, ptrdiff_t rowStride, ptrdiff_t imageStride)</td></tr>
<tr class="memdesc:gacaa6b82b65f0aa146a786e5f08e762ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy texture data from memory into a region of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object with user-specified stride.  <a href="group__nvn__c__functions.html#gacaa6b82b65f0aa146a786e5f08e762ba">More...</a><br /></td></tr>
<tr class="separator:gacaa6b82b65f0aa146a786e5f08e762ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ff90c3673688217dba1c0cb18084031"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9ff90c3673688217dba1c0cb18084031">nvnVertexAttribStateGetFormat</a> (const <a class="el" href="struct_n_v_nvertex_attrib_state.html">NVNvertexAttribState</a> *attrib, <a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a> *format, ptrdiff_t *relativeOffset)</td></tr>
<tr class="memdesc:ga9ff90c3673688217dba1c0cb18084031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the format (in memory) for values for a single vertex attribute.  <a href="group__nvn__c__functions.html#ga9ff90c3673688217dba1c0cb18084031">More...</a><br /></td></tr>
<tr class="separator:ga9ff90c3673688217dba1c0cb18084031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6633a58ae913e3de782d0d2af524e2f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga6633a58ae913e3de782d0d2af524e2f7">nvnVertexAttribStateGetStreamIndex</a> (const <a class="el" href="struct_n_v_nvertex_attrib_state.html">NVNvertexAttribState</a> *attrib)</td></tr>
<tr class="memdesc:ga6633a58ae913e3de782d0d2af524e2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the vertex attribute stream binding index.  <a href="group__nvn__c__functions.html#ga6633a58ae913e3de782d0d2af524e2f7">More...</a><br /></td></tr>
<tr class="separator:ga6633a58ae913e3de782d0d2af524e2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad884328996e09c2ff153a14a86fc08cb"><td class="memItemLeft" align="right" valign="top">NVNINLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad884328996e09c2ff153a14a86fc08cb">nvnVertexAttribStateGetStreamIndex_fastpath</a> (const <a class="el" href="struct_n_v_nvertex_attrib_state.html">NVNvertexAttribState</a> *attrib)</td></tr>
<tr class="memdesc:gad884328996e09c2ff153a14a86fc08cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the vertex attribute stream binding index.  <a href="group__nvn__c__functions.html#gad884328996e09c2ff153a14a86fc08cb">More...</a><br /></td></tr>
<tr class="separator:gad884328996e09c2ff153a14a86fc08cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e71254f0f8cd7eb8fa2aa8e8909779f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8e71254f0f8cd7eb8fa2aa8e8909779f">nvnVertexAttribStateSetDefaults</a> (<a class="el" href="struct_n_v_nvertex_attrib_state.html">NVNvertexAttribState</a> *attrib)</td></tr>
<tr class="memdesc:ga8e71254f0f8cd7eb8fa2aa8e8909779f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_nvertex_attrib_state.html" title="API state object controlling vertex attrib state.">NVNvertexAttribState</a> object.  <a href="group__nvn__c__functions.html#ga8e71254f0f8cd7eb8fa2aa8e8909779f">More...</a><br /></td></tr>
<tr class="separator:ga8e71254f0f8cd7eb8fa2aa8e8909779f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga447b6bbe81e21c3bff3dbf10bc15d80e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga447b6bbe81e21c3bff3dbf10bc15d80e">nvnVertexAttribStateSetFormat</a> (<a class="el" href="struct_n_v_nvertex_attrib_state.html">NVNvertexAttribState</a> *attrib, <a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a> format, ptrdiff_t relativeOffset)</td></tr>
<tr class="memdesc:ga447b6bbe81e21c3bff3dbf10bc15d80e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the format (in memory) for values for a single vertex attribute.  <a href="group__nvn__c__functions.html#ga447b6bbe81e21c3bff3dbf10bc15d80e">More...</a><br /></td></tr>
<tr class="separator:ga447b6bbe81e21c3bff3dbf10bc15d80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab96f74226c1d22d01c186d908eff14ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab96f74226c1d22d01c186d908eff14ab">nvnVertexAttribStateSetStreamIndex</a> (<a class="el" href="struct_n_v_nvertex_attrib_state.html">NVNvertexAttribState</a> *attrib, int streamIndex)</td></tr>
<tr class="memdesc:gab96f74226c1d22d01c186d908eff14ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the vertex attribute stream binding index.  <a href="group__nvn__c__functions.html#gab96f74226c1d22d01c186d908eff14ab">More...</a><br /></td></tr>
<tr class="separator:gab96f74226c1d22d01c186d908eff14ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08293b7f6f1efa4341d3f369e44f6384"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga08293b7f6f1efa4341d3f369e44f6384">nvnVertexAttribStateSetStreamIndex_fastpath</a> (<a class="el" href="struct_n_v_nvertex_attrib_state.html">NVNvertexAttribState</a> *attrib, int streamIndex)</td></tr>
<tr class="memdesc:ga08293b7f6f1efa4341d3f369e44f6384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the vertex attribute stream binding index.  <a href="group__nvn__c__functions.html#ga08293b7f6f1efa4341d3f369e44f6384">More...</a><br /></td></tr>
<tr class="separator:ga08293b7f6f1efa4341d3f369e44f6384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a99fed1a389e1a231314215842674e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3a99fed1a389e1a231314215842674e9">nvnVertexStreamStateGetDivisor</a> (const <a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *stream)</td></tr>
<tr class="memdesc:ga3a99fed1a389e1a231314215842674e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the frequency divisor in a <a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state.">NVNvertexStreamState</a> object.  <a href="group__nvn__c__functions.html#ga3a99fed1a389e1a231314215842674e9">More...</a><br /></td></tr>
<tr class="separator:ga3a99fed1a389e1a231314215842674e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbb6bbc19b8a311d81e4000afc30e2d1"><td class="memItemLeft" align="right" valign="top">NVNINLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gadbb6bbc19b8a311d81e4000afc30e2d1">nvnVertexStreamStateGetDivisor_fastpath</a> (const <a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *stream)</td></tr>
<tr class="memdesc:gadbb6bbc19b8a311d81e4000afc30e2d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the frequency divisor in a <a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state.">NVNvertexStreamState</a> object.  <a href="group__nvn__c__functions.html#gadbb6bbc19b8a311d81e4000afc30e2d1">More...</a><br /></td></tr>
<tr class="separator:gadbb6bbc19b8a311d81e4000afc30e2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebbf25d7f5c74f49b0b3635d3f8d78bc"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaebbf25d7f5c74f49b0b3635d3f8d78bc">nvnVertexStreamStateGetStride</a> (const <a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *stream)</td></tr>
<tr class="memdesc:gaebbf25d7f5c74f49b0b3635d3f8d78bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the stride (in bytes) for a <a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state.">NVNvertexStreamState</a> object.  <a href="group__nvn__c__functions.html#gaebbf25d7f5c74f49b0b3635d3f8d78bc">More...</a><br /></td></tr>
<tr class="separator:gaebbf25d7f5c74f49b0b3635d3f8d78bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac11f8cb40f347008360d15388925c016"><td class="memItemLeft" align="right" valign="top">NVNINLINE ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac11f8cb40f347008360d15388925c016">nvnVertexStreamStateGetStride_fastpath</a> (const <a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *stream)</td></tr>
<tr class="memdesc:gac11f8cb40f347008360d15388925c016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the stride (in bytes) for a <a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state.">NVNvertexStreamState</a> object.  <a href="group__nvn__c__functions.html#gac11f8cb40f347008360d15388925c016">More...</a><br /></td></tr>
<tr class="separator:gac11f8cb40f347008360d15388925c016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dca0133939bd660957dd5de2a56d240"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9dca0133939bd660957dd5de2a56d240">nvnVertexStreamStateSetDefaults</a> (<a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *stream)</td></tr>
<tr class="memdesc:ga9dca0133939bd660957dd5de2a56d240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state.">NVNvertexStreamState</a> object.  <a href="group__nvn__c__functions.html#ga9dca0133939bd660957dd5de2a56d240">More...</a><br /></td></tr>
<tr class="separator:ga9dca0133939bd660957dd5de2a56d240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6f8d41933935967cde1cadcc328c8da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac6f8d41933935967cde1cadcc328c8da">nvnVertexStreamStateSetDivisor</a> (<a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *stream, int divisor)</td></tr>
<tr class="memdesc:gac6f8d41933935967cde1cadcc328c8da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the frequency divisor for vertices in vertex binding N.  <a href="group__nvn__c__functions.html#gac6f8d41933935967cde1cadcc328c8da">More...</a><br /></td></tr>
<tr class="separator:gac6f8d41933935967cde1cadcc328c8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57ffd7e1095dd1d535c98b794eeca8c1"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga57ffd7e1095dd1d535c98b794eeca8c1">nvnVertexStreamStateSetDivisor_fastpath</a> (<a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *stream, int divisor)</td></tr>
<tr class="memdesc:ga57ffd7e1095dd1d535c98b794eeca8c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the frequency divisor for vertices in vertex binding N.  <a href="group__nvn__c__functions.html#ga57ffd7e1095dd1d535c98b794eeca8c1">More...</a><br /></td></tr>
<tr class="separator:ga57ffd7e1095dd1d535c98b794eeca8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a72c7499ec4a36d8cc38d0b5d575c90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9a72c7499ec4a36d8cc38d0b5d575c90">nvnVertexStreamStateSetStride</a> (<a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *stream, ptrdiff_t stride)</td></tr>
<tr class="memdesc:ga9a72c7499ec4a36d8cc38d0b5d575c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the stride (in bytes) for vertex attribute records fetched from a single vertex binding point.  <a href="group__nvn__c__functions.html#ga9a72c7499ec4a36d8cc38d0b5d575c90">More...</a><br /></td></tr>
<tr class="separator:ga9a72c7499ec4a36d8cc38d0b5d575c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab657c9c5139919b7141e22888676f8c8"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab657c9c5139919b7141e22888676f8c8">nvnVertexStreamStateSetStride_fastpath</a> (<a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *stream, ptrdiff_t stride)</td></tr>
<tr class="memdesc:gab657c9c5139919b7141e22888676f8c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the stride (in bytes) for vertex attribute records fetched from a single vertex binding point.  <a href="group__nvn__c__functions.html#gab657c9c5139919b7141e22888676f8c8">More...</a><br /></td></tr>
<tr class="separator:gab657c9c5139919b7141e22888676f8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fa0b45affa2e04d77e3c1ad11a03c32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga58e9b155d7f2272b95044eed1f40415e">NVNwindowAcquireTextureResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7fa0b45affa2e04d77e3c1ad11a03c32">nvnWindowAcquireTexture</a> (<a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *window, <a class="el" href="struct_n_v_nsync.html">NVNsync</a> *textureAvailableSync, int *textureIndex)</td></tr>
<tr class="memdesc:ga7fa0b45affa2e04d77e3c1ad11a03c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire a texture from the window.  <a href="group__nvn__c__functions.html#ga7fa0b45affa2e04d77e3c1ad11a03c32">More...</a><br /></td></tr>
<tr class="separator:ga7fa0b45affa2e04d77e3c1ad11a03c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a123578bac4b0a41cd7601cc53b84f5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8a123578bac4b0a41cd7601cc53b84f5">nvnWindowBuilderGetDevice</a> (const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga8a123578bac4b0a41cd7601cc53b84f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the device associated with this <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object.  <a href="group__nvn__c__functions.html#ga8a123578bac4b0a41cd7601cc53b84f5">More...</a><br /></td></tr>
<tr class="separator:ga8a123578bac4b0a41cd7601cc53b84f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77a240ba752c43089ca3d32ee4d17e60"><td class="memItemLeft" align="right" valign="top">NVNINLINE const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga77a240ba752c43089ca3d32ee4d17e60">nvnWindowBuilderGetDevice_fastpath</a> (const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga77a240ba752c43089ca3d32ee4d17e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the device associated with this <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object.  <a href="group__nvn__c__functions.html#ga77a240ba752c43089ca3d32ee4d17e60">More...</a><br /></td></tr>
<tr class="separator:ga77a240ba752c43089ca3d32ee4d17e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20d7c6255438597f1e6ff33a17bc1028"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga05b6b3dd5b965bd81efe2d03cee0bbbd">NVNnativeWindow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga20d7c6255438597f1e6ff33a17bc1028">nvnWindowBuilderGetNativeWindow</a> (const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga20d7c6255438597f1e6ff33a17bc1028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the native window for a <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object.  <a href="group__nvn__c__functions.html#ga20d7c6255438597f1e6ff33a17bc1028">More...</a><br /></td></tr>
<tr class="separator:ga20d7c6255438597f1e6ff33a17bc1028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63cf86f4034ccf1f3958d7d4c521eefa"><td class="memItemLeft" align="right" valign="top">NVNINLINE <a class="el" href="group__nvn__c__api__typedefs.html#ga05b6b3dd5b965bd81efe2d03cee0bbbd">NVNnativeWindow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga63cf86f4034ccf1f3958d7d4c521eefa">nvnWindowBuilderGetNativeWindow_fastpath</a> (const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga63cf86f4034ccf1f3958d7d4c521eefa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the native window for a <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object.  <a href="group__nvn__c__functions.html#ga63cf86f4034ccf1f3958d7d4c521eefa">More...</a><br /></td></tr>
<tr class="separator:ga63cf86f4034ccf1f3958d7d4c521eefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa848f2304d43c83aed3fa6fba34782ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaa848f2304d43c83aed3fa6fba34782ce">nvnWindowBuilderGetNumActiveTextures</a> (const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *builder)</td></tr>
<tr class="memdesc:gaa848f2304d43c83aed3fa6fba34782ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of active textures for presenting to this window.  <a href="group__nvn__c__functions.html#gaa848f2304d43c83aed3fa6fba34782ce">More...</a><br /></td></tr>
<tr class="separator:gaa848f2304d43c83aed3fa6fba34782ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c83252e5cdf05e5e0c30c7d9dea99ac"><td class="memItemLeft" align="right" valign="top">NVNINLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9c83252e5cdf05e5e0c30c7d9dea99ac">nvnWindowBuilderGetNumActiveTextures_fastpath</a> (const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga9c83252e5cdf05e5e0c30c7d9dea99ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of active textures for presenting to this window Fastpath variant.  <a href="group__nvn__c__functions.html#ga9c83252e5cdf05e5e0c30c7d9dea99ac">More...</a><br /></td></tr>
<tr class="separator:ga9c83252e5cdf05e5e0c30c7d9dea99ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacad10a6368b14ab7ba7d98f2855c800f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gacad10a6368b14ab7ba7d98f2855c800f">nvnWindowBuilderGetNumTextures</a> (const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *builder)</td></tr>
<tr class="memdesc:gacad10a6368b14ab7ba7d98f2855c800f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of textures associated with this <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object.  <a href="group__nvn__c__functions.html#gacad10a6368b14ab7ba7d98f2855c800f">More...</a><br /></td></tr>
<tr class="separator:gacad10a6368b14ab7ba7d98f2855c800f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84df620e4826600e95d514c9167e1c4f"><td class="memItemLeft" align="right" valign="top">NVNINLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga84df620e4826600e95d514c9167e1c4f">nvnWindowBuilderGetNumTextures_fastpath</a> (const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga84df620e4826600e95d514c9167e1c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of textures associated with this <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object.  <a href="group__nvn__c__functions.html#ga84df620e4826600e95d514c9167e1c4f">More...</a><br /></td></tr>
<tr class="separator:ga84df620e4826600e95d514c9167e1c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23b4fc7396418e24deb8286cdb74da8f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga23b4fc7396418e24deb8286cdb74da8f">nvnWindowBuilderGetPresentInterval</a> (const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga23b4fc7396418e24deb8286cdb74da8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the present interval for a <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object.  <a href="group__nvn__c__functions.html#ga23b4fc7396418e24deb8286cdb74da8f">More...</a><br /></td></tr>
<tr class="separator:ga23b4fc7396418e24deb8286cdb74da8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02e84bd3df0a6dd2bc27e9775f959da2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga02e84bd3df0a6dd2bc27e9775f959da2">nvnWindowBuilderGetTexture</a> (const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *builder, int textureId)</td></tr>
<tr class="memdesc:ga02e84bd3df0a6dd2bc27e9775f959da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the texture with index textureId associated with this <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object.  <a href="group__nvn__c__functions.html#ga02e84bd3df0a6dd2bc27e9775f959da2">More...</a><br /></td></tr>
<tr class="separator:ga02e84bd3df0a6dd2bc27e9775f959da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3924f2d40fa227e1b405df3755ad46e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3924f2d40fa227e1b405df3755ad46e7">nvnWindowBuilderSetDefaults</a> (<a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga3924f2d40fa227e1b405df3755ad46e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object.  <a href="group__nvn__c__functions.html#ga3924f2d40fa227e1b405df3755ad46e7">More...</a><br /></td></tr>
<tr class="separator:ga3924f2d40fa227e1b405df3755ad46e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf93ec4cee4147e9cc004b7b16c802621"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf93ec4cee4147e9cc004b7b16c802621">nvnWindowBuilderSetDevice</a> (<a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *builder, <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device)</td></tr>
<tr class="memdesc:gaf93ec4cee4147e9cc004b7b16c802621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> associated with a <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object.  <a href="group__nvn__c__functions.html#gaf93ec4cee4147e9cc004b7b16c802621">More...</a><br /></td></tr>
<tr class="separator:gaf93ec4cee4147e9cc004b7b16c802621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac518ddbead9eac057d3578c6195166b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac518ddbead9eac057d3578c6195166b2">nvnWindowBuilderSetNativeWindow</a> (<a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *builder, <a class="el" href="group__nvn__c__api__typedefs.html#ga05b6b3dd5b965bd81efe2d03cee0bbbd">NVNnativeWindow</a> nativeWindow)</td></tr>
<tr class="memdesc:gac518ddbead9eac057d3578c6195166b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the native window where the textures of this window will be presented to.  <a href="group__nvn__c__functions.html#gac518ddbead9eac057d3578c6195166b2">More...</a><br /></td></tr>
<tr class="separator:gac518ddbead9eac057d3578c6195166b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4de9e801cdca28c77518c9e5942b5ccd"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4de9e801cdca28c77518c9e5942b5ccd">nvnWindowBuilderSetNativeWindow_fastpath</a> (<a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *builder, <a class="el" href="group__nvn__c__api__typedefs.html#ga05b6b3dd5b965bd81efe2d03cee0bbbd">NVNnativeWindow</a> nativeWindow)</td></tr>
<tr class="memdesc:ga4de9e801cdca28c77518c9e5942b5ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the native window where the textures of this window will be presented to.  <a href="group__nvn__c__functions.html#ga4de9e801cdca28c77518c9e5942b5ccd">More...</a><br /></td></tr>
<tr class="separator:ga4de9e801cdca28c77518c9e5942b5ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3f7dbd4f7cfe3d734866db4f0f96497"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad3f7dbd4f7cfe3d734866db4f0f96497">nvnWindowBuilderSetNumActiveTextures</a> (<a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *builder, int numActiveTextures)</td></tr>
<tr class="memdesc:gad3f7dbd4f7cfe3d734866db4f0f96497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of textures for presenting to this window.  <a href="group__nvn__c__functions.html#gad3f7dbd4f7cfe3d734866db4f0f96497">More...</a><br /></td></tr>
<tr class="separator:gad3f7dbd4f7cfe3d734866db4f0f96497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa61a7c476bdc25d6c4c93751bf543df8"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaa61a7c476bdc25d6c4c93751bf543df8">nvnWindowBuilderSetNumActiveTextures_fastpath</a> (<a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *builder, int numActiveTextures)</td></tr>
<tr class="memdesc:gaa61a7c476bdc25d6c4c93751bf543df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of textures for presenting to this window.  <a href="group__nvn__c__functions.html#gaa61a7c476bdc25d6c4c93751bf543df8">More...</a><br /></td></tr>
<tr class="separator:gaa61a7c476bdc25d6c4c93751bf543df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c80a6fc0718d28e05c183a8110b9f07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9c80a6fc0718d28e05c183a8110b9f07">nvnWindowBuilderSetPresentInterval</a> (<a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *builder, int presentInterval)</td></tr>
<tr class="memdesc:ga9c80a6fc0718d28e05c183a8110b9f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the present interval used when presenting to this window.  <a href="group__nvn__c__functions.html#ga9c80a6fc0718d28e05c183a8110b9f07">More...</a><br /></td></tr>
<tr class="separator:ga9c80a6fc0718d28e05c183a8110b9f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga610c7f233b7bb1e02f4926fe554df5db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga610c7f233b7bb1e02f4926fe554df5db">nvnWindowBuilderSetTextures</a> (<a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *builder, int numTextures, <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *const *textures)</td></tr>
<tr class="memdesc:ga610c7f233b7bb1e02f4926fe554df5db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the textures used for presenting to this window.  <a href="group__nvn__c__functions.html#ga610c7f233b7bb1e02f4926fe554df5db">More...</a><br /></td></tr>
<tr class="separator:ga610c7f233b7bb1e02f4926fe554df5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b92b39df0509c4044ffec0d506c0074"><td class="memItemLeft" align="right" valign="top">NVNINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga6b92b39df0509c4044ffec0d506c0074">nvnWindowBuilderSetTextures_fastpath</a> (<a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *builder, int numTextures, <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *const *textures)</td></tr>
<tr class="memdesc:ga6b92b39df0509c4044ffec0d506c0074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the textures used for presenting to this window.  <a href="group__nvn__c__functions.html#ga6b92b39df0509c4044ffec0d506c0074">More...</a><br /></td></tr>
<tr class="separator:ga6b92b39df0509c4044ffec0d506c0074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53660a4abfffea411f62415c79a65cdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga53660a4abfffea411f62415c79a65cdf">nvnWindowFinalize</a> (<a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *window)</td></tr>
<tr class="memdesc:ga53660a4abfffea411f62415c79a65cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object.  <a href="group__nvn__c__functions.html#ga53660a4abfffea411f62415c79a65cdf">More...</a><br /></td></tr>
<tr class="separator:ga53660a4abfffea411f62415c79a65cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0857c62a4ddce422c4aed104c607ac4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae0857c62a4ddce422c4aed104c607ac4">nvnWindowGetCrop</a> (const <a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *window, <a class="el" href="struct_n_v_nrectangle.html">NVNrectangle</a> *crop)</td></tr>
<tr class="memdesc:gae0857c62a4ddce422c4aed104c607ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimensions of the crop rectangle that defines the region inside the window texture which gets displayed.  <a href="group__nvn__c__functions.html#gae0857c62a4ddce422c4aed104c607ac4">More...</a><br /></td></tr>
<tr class="separator:gae0857c62a4ddce422c4aed104c607ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35e25752c0757803fdb19b8b9584af9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga05b6b3dd5b965bd81efe2d03cee0bbbd">NVNnativeWindow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga35e25752c0757803fdb19b8b9584af9a">nvnWindowGetNativeWindow</a> (const <a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *window)</td></tr>
<tr class="memdesc:ga35e25752c0757803fdb19b8b9584af9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the native window for a <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object.  <a href="group__nvn__c__functions.html#ga35e25752c0757803fdb19b8b9584af9a">More...</a><br /></td></tr>
<tr class="separator:ga35e25752c0757803fdb19b8b9584af9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b6fec6511611178d8cb553ce5358755"><td class="memItemLeft" align="right" valign="top">NVNINLINE <a class="el" href="group__nvn__c__api__typedefs.html#ga05b6b3dd5b965bd81efe2d03cee0bbbd">NVNnativeWindow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8b6fec6511611178d8cb553ce5358755">nvnWindowGetNativeWindow_fastpath</a> (const <a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *window)</td></tr>
<tr class="memdesc:ga8b6fec6511611178d8cb553ce5358755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the native window for a <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object.  <a href="group__nvn__c__functions.html#ga8b6fec6511611178d8cb553ce5358755">More...</a><br /></td></tr>
<tr class="separator:ga8b6fec6511611178d8cb553ce5358755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1d1cfbfb51522743c2bb1afb2cea414"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab1d1cfbfb51522743c2bb1afb2cea414">nvnWindowGetNumActiveTextures</a> (const <a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *window)</td></tr>
<tr class="memdesc:gab1d1cfbfb51522743c2bb1afb2cea414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of active textures for presenting to this window.  <a href="group__nvn__c__functions.html#gab1d1cfbfb51522743c2bb1afb2cea414">More...</a><br /></td></tr>
<tr class="separator:gab1d1cfbfb51522743c2bb1afb2cea414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe52efe05026fe19a9df4d6a8bdab8a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gabe52efe05026fe19a9df4d6a8bdab8a3">nvnWindowGetNumTextures</a> (const <a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *window)</td></tr>
<tr class="memdesc:gabe52efe05026fe19a9df4d6a8bdab8a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the maximum available number of textures for presenting to this window.  <a href="group__nvn__c__functions.html#gabe52efe05026fe19a9df4d6a8bdab8a3">More...</a><br /></td></tr>
<tr class="separator:gabe52efe05026fe19a9df4d6a8bdab8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dc4e247245c6f29706be307de1ca096"><td class="memItemLeft" align="right" valign="top">NVNINLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3dc4e247245c6f29706be307de1ca096">nvnWindowGetNumTextures_fastpath</a> (const <a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *window)</td></tr>
<tr class="memdesc:ga3dc4e247245c6f29706be307de1ca096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the maximum available number of textures for presenting to this window.  <a href="group__nvn__c__functions.html#ga3dc4e247245c6f29706be307de1ca096">More...</a><br /></td></tr>
<tr class="separator:ga3dc4e247245c6f29706be307de1ca096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga759e5d9a7bd29dda539893cfd23d3ca2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga759e5d9a7bd29dda539893cfd23d3ca2">nvnWindowGetPresentInterval</a> (const <a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *window)</td></tr>
<tr class="memdesc:ga759e5d9a7bd29dda539893cfd23d3ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the present interval for a <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object.  <a href="group__nvn__c__functions.html#ga759e5d9a7bd29dda539893cfd23d3ca2">More...</a><br /></td></tr>
<tr class="separator:ga759e5d9a7bd29dda539893cfd23d3ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7edaefdb91e348186c3310c181fc1d5e"><td class="memItemLeft" align="right" valign="top">NVNINLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7edaefdb91e348186c3310c181fc1d5e">nvnWindowGetPresentInterval_fastpath</a> (const <a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *window)</td></tr>
<tr class="memdesc:ga7edaefdb91e348186c3310c181fc1d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the present interval for a <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object.  <a href="group__nvn__c__functions.html#ga7edaefdb91e348186c3310c181fc1d5e">More...</a><br /></td></tr>
<tr class="separator:ga7edaefdb91e348186c3310c181fc1d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5c388ac1ed70cb34ea4d71d23af9a73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac5c388ac1ed70cb34ea4d71d23af9a73">nvnWindowInitialize</a> (<a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *window, const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *builder)</td></tr>
<tr class="memdesc:gac5c388ac1ed70cb34ea4d71d23af9a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a new window object from a window builder.  <a href="group__nvn__c__functions.html#gac5c388ac1ed70cb34ea4d71d23af9a73">More...</a><br /></td></tr>
<tr class="separator:gac5c388ac1ed70cb34ea4d71d23af9a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf961e88cbeee4c0612548c40e7db432d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf961e88cbeee4c0612548c40e7db432d">nvnWindowSetCrop</a> (<a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *window, int x, int y, int w, int h)</td></tr>
<tr class="memdesc:gaf961e88cbeee4c0612548c40e7db432d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the rectangle inside the window texture that gets displayed.  <a href="group__nvn__c__functions.html#gaf961e88cbeee4c0612548c40e7db432d">More...</a><br /></td></tr>
<tr class="separator:gaf961e88cbeee4c0612548c40e7db432d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e7fcf2ce10cbe51af72130cacac4840"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4e7fcf2ce10cbe51af72130cacac4840">nvnWindowSetDebugLabel</a> (<a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *window, const char *label)</td></tr>
<tr class="memdesc:ga4e7fcf2ce10cbe51af72130cacac4840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug label string for a <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object.  <a href="group__nvn__c__functions.html#ga4e7fcf2ce10cbe51af72130cacac4840">More...</a><br /></td></tr>
<tr class="separator:ga4e7fcf2ce10cbe51af72130cacac4840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga023ae1798862318f9cbe4bac4de26db1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga023ae1798862318f9cbe4bac4de26db1">nvnWindowSetNumActiveTextures</a> (<a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *window, int numActiveTextures)</td></tr>
<tr class="memdesc:ga023ae1798862318f9cbe4bac4de26db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of textures for presenting to this window.  <a href="group__nvn__c__functions.html#ga023ae1798862318f9cbe4bac4de26db1">More...</a><br /></td></tr>
<tr class="separator:ga023ae1798862318f9cbe4bac4de26db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b735c095396aabd05d437bd2bda1ded"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3b735c095396aabd05d437bd2bda1ded">nvnWindowSetPresentInterval</a> (<a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *window, int presentInterval)</td></tr>
<tr class="memdesc:ga3b735c095396aabd05d437bd2bda1ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the present interval for a <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object.  <a href="group__nvn__c__functions.html#ga3b735c095396aabd05d437bd2bda1ded">More...</a><br /></td></tr>
<tr class="separator:ga3b735c095396aabd05d437bd2bda1ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>C Interface API entry points. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa042629cf4bc5ef1fab4bc7bf37b6f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa042629cf4bc5ef1fab4bc7bf37b6f4f">&#9670;&nbsp;</a></span>nvnDeviceBuilderSetDefaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDeviceBuilderSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice_builder.html">NVNdeviceBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_ndevice_builder.html" title="Object specifying state used to construct new device objects.">NVNdeviceBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ndevice_builder.html" title="Object specifying state used to construct new device objects.">NVNdeviceBuilder</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga918d154a1d1f156eb61e6a3e402cbf1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga918d154a1d1f156eb61e6a3e402cbf1c">&#9670;&nbsp;</a></span>nvnDeviceBuilderSetFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDeviceBuilderSetFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice_builder.html">NVNdeviceBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set flags used for during device initialzation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ndevice_builder.html" title="Object specifying state used to construct new device objects.">NVNdeviceBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">flags</td><td>Flags to use during device initialization. See <a class="el" href="group__nvn__c__enum.html#ga9c68350bf64f2e7a90a23290c26872d3" title="Specifies additional flags when creating a device.">NVNdeviceFlagBits</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacfe3e96f8b8ef13acb9008e4098196d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfe3e96f8b8ef13acb9008e4098196d3">&#9670;&nbsp;</a></span>nvnDeviceBuilderGetFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga9c68350bf64f2e7a90a23290c26872d3">NVNdeviceFlagBits</a> nvnDeviceBuilderGetFlags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice_builder.html">NVNdeviceBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get flags associated with this <a class="el" href="struct_n_v_ndevice_builder.html" title="Object specifying state used to construct new device objects.">NVNdeviceBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ndevice_builder.html" title="Object specifying state used to construct new device objects.">NVNdeviceBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9965ca922dfa44cecfff9185a65d99c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9965ca922dfa44cecfff9185a65d99c0">&#9670;&nbsp;</a></span>nvnDeviceBuilderGetFlags_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE <a class="el" href="group__nvn__c__enum.html#ga9c68350bf64f2e7a90a23290c26872d3">NVNdeviceFlagBits</a> nvnDeviceBuilderGetFlags_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice_builder.html">NVNdeviceBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get flags associated with this <a class="el" href="struct_n_v_ndevice_builder.html" title="Object specifying state used to construct new device objects.">NVNdeviceBuilder</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnDeviceBuilderGetFlags, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ndevice_builder.html" title="Object specifying state used to construct new device objects.">NVNdeviceBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac05386acab686b7614d353c9a4ea4d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac05386acab686b7614d353c9a4ea4d96">&#9670;&nbsp;</a></span>nvnDeviceInitialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnDeviceInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice_builder.html">NVNdeviceBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> object from a device builder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> object to initialize.</td></tr>
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ndevice_builder.html" title="Object specifying state used to construct new device objects.">NVNdeviceBuilder</a> object holding properties of the new <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5fccd6ba67cd2d269900832d3b7e82ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fccd6ba67cd2d269900832d3b7e82ff">&#9670;&nbsp;</a></span>nvnDeviceFinalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDeviceFinalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> object to finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6bfa6529d97f627325bd9ac84605a9b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bfa6529d97f627325bd9ac84605a9b1">&#9670;&nbsp;</a></span>nvnDeviceSetDebugLabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDeviceSetDebugLabel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debug label string for a <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> object. </p>
<p>Annotates a <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> object with a descriptive text label. This label may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> object to set debug label.</td></tr>
    <tr><td class="paramname">label</td><td>Text string used to annotate the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacddfe3caf2f24874b617cd696e3a4305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacddfe3caf2f24874b617cd696e3a4305">&#9670;&nbsp;</a></span>nvnDeviceGetProcAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__funcptrs.html#gacb3cbf1bdfffca0a1bf319b77919e7f5">PFNNVNGENERICFUNCPTRPROC</a> nvnDeviceGetProcAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query a function pointer for a specified C interface entry point for a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> object to query.</td></tr>
    <tr><td class="paramname">name</td><td>Name of the C entry point to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6f739de39c3818a65b190be3a82cf891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f739de39c3818a65b190be3a82cf891">&#9670;&nbsp;</a></span>nvnDeviceGetInteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDeviceGetInteger </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac887e20e2474bb76b87943b0f0be7a50">NVNdeviceInfo</a>&#160;</td>
          <td class="paramname"><em>pname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query properties of a device. </p>
<dl class="section note"><dt>Note</dt><dd><em>device</em> may be NULL when querying supported API or GPU shader code versions prior to creating a device object. For all other queries, <em>device</em> must point at a valid NVN device object.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> to query.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pname</td><td>Property to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>Value associated with the property, returned to the application. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae11fb2040aadb9ab716ffc31d5f21e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae11fb2040aadb9ab716ffc31d5f21e43">&#9670;&nbsp;</a></span>nvnDeviceGetCurrentTimestampInNanoseconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t nvnDeviceGetCurrentTimestampInNanoseconds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get timestamp from the device, without queuing like the ReportCounter functions. </p>
<p>See the <a class="el" href="nvn_index.html#nvn_guide_counters">Counters</a> section of the NVN Programming Guide for more detail.</p>
<dl class="section note"><dt>Note</dt><dd><em>device</em> must point at a valid NVN device object.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafc2c6dd07f2db4dddff39bcd0eff76a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc2c6dd07f2db4dddff39bcd0eff76a3">&#9670;&nbsp;</a></span>nvnDeviceSetIntermediateShaderCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDeviceSetIntermediateShaderCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numMaxEntries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the shader cache for the Windows reference platform to store fat binary intermediate results. </p>
<p>If the NVN platform is NX, this function does nothing.</p>
<p>On the Windows reference implemenetation, nvnProgramSetShaders will compile machine code that can run on the attached GPU, using intermediate shader code and specialization information stored in the provided control data. If the same shader is compiled with different specialization information (via glslcCompileSpecialized) using this cache can avoid re-processing the same shader code on each call to nvnProgramSetShaders.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device owning the programs to cache.</td></tr>
    <tr><td class="paramname">numMaxEntries</td><td>Maximum number of entries that the intermediate shader cache can hold. If this is 0, the cache will be disabled and any previous cache resources will be cleaned up. If a non-zero value is used, the cache will hold intermediate code for up to <em>numMaxEntries</em> unique shaders. Programs containing multiple shader stages will consume multiple entries in this cache. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0ca6fe7fc102170723f5eccb14a25046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ca6fe7fc102170723f5eccb14a25046">&#9670;&nbsp;</a></span>nvnDeviceGetTextureHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__handle.html#gaa1a1fc7a9e690ce93870bcd71ea6b446">NVNtextureHandle</a> nvnDeviceGetTextureHandle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>textureID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>samplerID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle for a combined pair of <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> and <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device owning the texture and sampler objects.</td></tr>
    <tr><td class="paramname">textureID</td><td>Registered ID of the <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. Must be greater than or equal to 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a513596e8b2dc04714d6478aed173a891" title="Number of entries reserved at the beginning of the texture pool for internal driver usage.">NVN_DEVICE_INFO_RESERVED_TEXTURE_DESCRIPTORS</a>).</td></tr>
    <tr><td class="paramname">samplerID</td><td>Registered ID of the <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object. Must be greater than or equal to 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a5b9a26a5aadab05c4a9f8a286718fbc7" title="Number of samplers that must be reserved for use by the driver.">NVN_DEVICE_INFO_RESERVED_SAMPLER_DESCRIPTORS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab0b754403b7c24211f204fd7667466da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0b754403b7c24211f204fd7667466da">&#9670;&nbsp;</a></span>nvnDeviceGetTexelFetchHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__handle.html#gaa1a1fc7a9e690ce93870bcd71ea6b446">NVNtextureHandle</a> nvnDeviceGetTexelFetchHandle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>textureID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object for use in texel fetches. </p>
<p>A handle produced by this entry point can be used for texel fetches via the texelFetch() GLSL built-in function. Using such handles in texture lookups will use undefined sampler state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device owning the texture object.</td></tr>
    <tr><td class="paramname">textureID</td><td>Registered ID of the <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. Must be greater than or equal to 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a513596e8b2dc04714d6478aed173a891" title="Number of entries reserved at the beginning of the texture pool for internal driver usage.">NVN_DEVICE_INFO_RESERVED_TEXTURE_DESCRIPTORS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9c42db1b24a512270afa6abd615fae01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c42db1b24a512270afa6abd615fae01">&#9670;&nbsp;</a></span>nvnDeviceGetImageHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__handle.html#gacba3c44a43c05f11bc1b88c49b118606">NVNimageHandle</a> nvnDeviceGetImageHandle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>imageID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle to use for image loads and stores to a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device owning the texture and sampler objects.</td></tr>
    <tr><td class="paramname">imageID</td><td>Registered image ID of the <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. Must be greater than or equal to 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a513596e8b2dc04714d6478aed173a891" title="Number of entries reserved at the beginning of the texture pool for internal driver usage.">NVN_DEVICE_INFO_RESERVED_TEXTURE_DESCRIPTORS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab73dcc0df1012caf66620aa7c56b2592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab73dcc0df1012caf66620aa7c56b2592">&#9670;&nbsp;</a></span>nvnDeviceInstallDebugCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDeviceInstallDebugCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__nvn__c__funcptrs.html#gab106acc34961bf1c3a43514686dbfc4b">PFNNVNDEBUGCALLBACKPROC</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install or remove a callback function to be called whenever the debug layer generates a message. </p>
<p>Multiple callback functions (each with separate callback data) are supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> used for the callback.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">callback</td><td>Pointer to a callback function to call.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">callbackData</td><td>Pointer to arbitrary data to pass in each call to the callback function.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">enable</td><td>Enable (TRUE) or disable (FALSE) the specified callback function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7fb39752d0d8dd9d254667f3042c42b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fb39752d0d8dd9d254667f3042c42b6">&#9670;&nbsp;</a></span>nvnDeviceGenerateDebugDomainId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga721dd09710079ec7e1d153842dbc7665">NVNdebugDomainId</a> nvnDeviceGenerateDebugDomainId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This returns a unique ID by atomically incrementing a global counter on each request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> used.</td></tr>
    <tr><td class="paramname">name</td><td>Name to associate to new domain id. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga24c4fdcf11f6dc0bf042566b4da7bba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24c4fdcf11f6dc0bf042566b4da7bba4">&#9670;&nbsp;</a></span>nvnDeviceSetWindowOriginMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDeviceSetWindowOriginMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga52db1bf3e182ec089c43db5a02baecd6">NVNwindowOriginMode</a>&#160;</td>
          <td class="paramname"><em>windowOriginMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the global location for window coordinates (0,0). </p>
<p>Applications should set the window origin mode in the device before creating any queues, command buffers, or windows, and should use that mode for the lifetime of the application. Rendering results are undefined if there are any inconsistencies between the window origin mode (a) currently set for the device, (b) set when creating the command buffer used to create rendering commands, (c) set when creating the queue used to submit rendering commands, (d) set when creating the window used to display rendered frames.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to be modified.</td></tr>
    <tr><td class="paramname">windowOriginMode</td><td>New location for the window origin. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga92c66661dc98041b781cf4b2611ac0b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92c66661dc98041b781cf4b2611ac0b6">&#9670;&nbsp;</a></span>nvnDeviceSetWindowOriginMode_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnDeviceSetWindowOriginMode_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga52db1bf3e182ec089c43db5a02baecd6">NVNwindowOriginMode</a>&#160;</td>
          <td class="paramname"><em>windowOriginMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the global location for window coordinates (0,0). </p>
<p>Fastpath variant.</p>
<p>Applications should set the window origin mode in the device before creating any queues, command buffers, or windows, and should use that mode for the lifetime of the application. Rendering results are undefined if there are any inconsistencies between the window origin mode (a) currently set for the device, (b) set when creating the command buffer used to create rendering commands, (c) set when creating the queue used to submit rendering commands, (d) set when creating the window used to display rendered frames.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnDeviceSetWindowOriginMode, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to be modified.</td></tr>
    <tr><td class="paramname">windowOriginMode</td><td>New location for the window origin. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8b42972a78ea6d7180106f97a8ef1eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b42972a78ea6d7180106f97a8ef1eec">&#9670;&nbsp;</a></span>nvnDeviceSetDepthMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDeviceSetDepthMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga0e55de1522658c843016e8b24a8ecabd">NVNdepthMode</a>&#160;</td>
          <td class="paramname"><em>depthMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the global clipping range for normalized depth in clip space. </p>
<p>Applications should set the depth mode in the device before creating any queues or command buffers, and should use that mode for the lifetime of the application. Rendering results are undefined if there are any inconsistencies between the depth mode (a) currently set for the device, (b) set when creating the command buffer used to create rendering commands, or (c) set when creating the queue used to submit rendering commands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to be modified.</td></tr>
    <tr><td class="paramname">depthMode</td><td>New policy for depth clipping. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafbd75784e9651faa3562714bb8b9179e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbd75784e9651faa3562714bb8b9179e">&#9670;&nbsp;</a></span>nvnDeviceSetDepthMode_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnDeviceSetDepthMode_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga0e55de1522658c843016e8b24a8ecabd">NVNdepthMode</a>&#160;</td>
          <td class="paramname"><em>depthMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the global clipping range for normalized depth in clip space. </p>
<p>Fastpath variant.</p>
<p>Applications should set the depth mode in the device before creating any queues or command buffers, and should use that mode for the lifetime of the application. Rendering results are undefined if there are any inconsistencies between the depth mode (a) currently set for the device, (b) set when creating the command buffer used to create rendering commands, or (c) set when creating the queue used to submit rendering commands.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnDeviceSetDepthMode, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to be modified.</td></tr>
    <tr><td class="paramname">depthMode</td><td>New policy for depth clipping. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gace7813b0e44d122d452df918525ef8a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace7813b0e44d122d452df918525ef8a1">&#9670;&nbsp;</a></span>nvnDeviceRegisterFastClearColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnDeviceRegisterFastClearColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a fast clear color value. </p>
<p>Applications can register specific combinations of clear values and formats that it expects to use for future framebuffer clears. Clearing the framebuffer using one of these registered clear colors will result in reduced memory bandwidth usage and increased performance when used with compressible textures.</p>
<p>The number of clear values that can be registered is limited. Additionally, this command is supported only for formats with more than 16 bits per pixel and floating-point or normalized components. If a clear value or format can not be registered, NVN_FALSE is returned. If registration is successful, NVN_TRUE is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to be modified.</td></tr>
    <tr><td class="paramname">color</td><td>Array of four floating-point (RGBA) clear color values.</td></tr>
    <tr><td class="paramname">format</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> format to encode the value into. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1c2df0951b28828873afc21370d7c010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c2df0951b28828873afc21370d7c010">&#9670;&nbsp;</a></span>nvnDeviceRegisterFastClearColori()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnDeviceRegisterFastClearColori </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a signed integer fast clear color value. </p>
<p>Applications can register specific combinations of clear values and formats that it expects to use for future framebuffer clears. Clearing the framebuffer using one of these registered clear colors will result in reduced memory bandwidth usage and increased performance when used with compressible textures.</p>
<p>The number of clear values that can be registered is limited. Additionally, this command is supported only for formats with more than 16 bits per pixel and signed integer components. If a clear value or format can not be registered, NVN_FALSE is returned. If registration is successful, NVN_TRUE is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to be modified.</td></tr>
    <tr><td class="paramname">color</td><td>Array of four signed integer (RGBA) clear color values.</td></tr>
    <tr><td class="paramname">format</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> format to encode the value into. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9cfafa315b6bea064d93dd963eb7b891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cfafa315b6bea064d93dd963eb7b891">&#9670;&nbsp;</a></span>nvnDeviceRegisterFastClearColorui()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnDeviceRegisterFastClearColorui </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an unsigned integer fast clear color value. </p>
<p>Applications can register specific combinations of clear values and formats that it expects to use for future framebuffer clears. Clearing the framebuffer using one of these registered clear colors will result in reduced memory bandwidth usage and increased performance when used with compressible textures.</p>
<p>The number of clear values that can be registered is limited. Additionally, this command is supported only for formats with more than 16 bits per pixel and unsigned integer components. If a clear value or format can not be registered, NVN_FALSE is returned. If registration is successful, NVN_TRUE is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to be modified.</td></tr>
    <tr><td class="paramname">color</td><td>Array of four unsigned integer (RGBA) clear color values.</td></tr>
    <tr><td class="paramname">format</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> format to encode the value into. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2c9adc51dc192c3e48dc4c0e2e6f2e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c9adc51dc192c3e48dc4c0e2e6f2e86">&#9670;&nbsp;</a></span>nvnDeviceRegisterFastClearDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnDeviceRegisterFastClearDepth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a fast clear depth value. </p>
<p>Applications can register specific clear values that it expects to use for future depth buffer clears. Clearing the depth buffer using one of these registered clear depth values will result in reduced memory bandwidth usage and increased performance when used with compressible textures.</p>
<p>The number of clear values that can be registered is finite. If a clear value can not be registered, NVN_FALSE is returned. If registration is successful, NVN_TRUE is returned. </p><dl class="section note"><dt>Note</dt><dd>16-bit depth textures (<a class="el" href="group__nvn__c__enum.html#gga99463f5b9af6151e604b01dfdd5fecaba66e178062c6e76540621006c44c82ba9" title="A 16-bit unsigned normalized depth component.">NVN_FORMAT_DEPTH16</a>) have limited support for fast clears. See documentation on <a class="el" href="group__nvn__c__enum.html#gga57ab2536473c8e62f621554a2618121bad04da7f2ffe131d7103cd9de47be2227" title="Favor fast clear over depth compression for DEPTH16 depth textures.">NVN_TEXTURE_FLAGS_DEPTH16_PREFER_FAST_CLEAR_BIT</a> for more information.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to be modified.</td></tr>
    <tr><td class="paramname">depth</td><td>Depth value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1f3e9684e49790ad324c33e38a07276b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f3e9684e49790ad324c33e38a07276b">&#9670;&nbsp;</a></span>nvnDeviceGetWindowOriginMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga52db1bf3e182ec089c43db5a02baecd6">NVNwindowOriginMode</a> nvnDeviceGetWindowOriginMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the window origin mode for a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabf0bb6f5770883cd18dac49be9f5c44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf0bb6f5770883cd18dac49be9f5c44b">&#9670;&nbsp;</a></span>nvnDeviceGetWindowOriginMode_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE <a class="el" href="group__nvn__c__enum.html#ga52db1bf3e182ec089c43db5a02baecd6">NVNwindowOriginMode</a> nvnDeviceGetWindowOriginMode_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the window origin mode for a device. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnDeviceGetWindowOriginMode, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga764b1be2fcce7a44895399a46646bb14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga764b1be2fcce7a44895399a46646bb14">&#9670;&nbsp;</a></span>nvnDeviceGetDepthMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga0e55de1522658c843016e8b24a8ecabd">NVNdepthMode</a> nvnDeviceGetDepthMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the depth mode for a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac5a1e64f3f59dd202df0e24ce466407b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5a1e64f3f59dd202df0e24ce466407b">&#9670;&nbsp;</a></span>nvnDeviceGetDepthMode_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE <a class="el" href="group__nvn__c__enum.html#ga0e55de1522658c843016e8b24a8ecabd">NVNdepthMode</a> nvnDeviceGetDepthMode_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the depth mode for a device. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnDeviceGetDepthMode, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9dad3a471fcb5313fd4aab24e8062f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9dad3a471fcb5313fd4aab24e8062f1c">&#9670;&nbsp;</a></span>nvnDeviceGetTimestampInNanoseconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t nvnDeviceGetTimestampInNanoseconds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncounter_data.html">NVNcounterData</a> *&#160;</td>
          <td class="paramname"><em>counterData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the timestamp contained in a counter report, with time values converted from the platform-specific timestamp resolution to nanoseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> used to perform the counter report operation.</td></tr>
    <tr><td class="paramname">counterData</td><td>Pointer to a full <a class="el" href="struct_n_v_ncounter_data.html" title="Data structure describing how counter values are written to buffer memory.">NVNcounterData</a> structure containing the timestamp value to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5babbe756bd750bf3fd41c2b4049a730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5babbe756bd750bf3fd41c2b4049a730">&#9670;&nbsp;</a></span>nvnDeviceFinalizeCommandHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDeviceFinalizeCommandHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a>&#160;</td>
          <td class="paramname"><em>handles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a command handle. </p>
<p>This command can be used to free any memory associated with a command handle that may have been allocated by the debug layer or other developer tools that track the contents of a command set. If command handles are not explicitly finalized, associated memory will be freed only when the command or control memory associated with the command set is freed or reused. The control memory has a tracking token used to implicit cleanup the memory later even if the application does not call finalize. Overwriting the command set memory before calling FinalizeCommandHandle or implicit clean can corrupt the tracking token and may result in memory leaks. This command has no effect if the debug layer and other developer tools are disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> associated with the command handle.</td></tr>
    <tr><td class="paramname">handles</td><td>Command handle to finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf12100926a7307bf74d86ab68dd59e65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf12100926a7307bf74d86ab68dd59e65">&#9670;&nbsp;</a></span>nvnDeviceWalkDebugDatabase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDeviceWalkDebugDatabase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga1ad0f9413adde3e3c46751c0312564ea">NVNdebugObjectType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__funcptrs.html#gacf070cc0410c00ecf1430770bb9ed021">PFNNVNWALKDEBUGDATABASECALLBACKPROC</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk through the debug layer object database. </p>
<p>Debug layer must be enabled.</p>
<p>Reports the debug layer's list of objects of the given type through the callback function. At least Level 1 debug layer must be enabled, as object tracking is not done at debug layer level 0. See <a class="el" href="nvn_index.html#nvn_guide_api_object_tracking">API Object Tracking</a> for detail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> associated with list of objects to be reported.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">type</td><td>Type of objects to walk through.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">callback</td><td>Callback function to be called for every object matching the given device and object type.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">userParam</td><td>Value to be passed to the callback holding a 'user pointer' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0f3dbb400d79d6d8dc64c052226ba809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f3dbb400d79d6d8dc64c052226ba809">&#9670;&nbsp;</a></span>nvnDeviceGetSeparateTextureHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_n_v_nseparate_texture_handle.html">NVNseparateTextureHandle</a> nvnDeviceGetSeparateTextureHandle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>textureID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle for a separate <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device owning the texture object.</td></tr>
    <tr><td class="paramname">textureID</td><td>Registered ID of the <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. Must be greater than or equal to 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a513596e8b2dc04714d6478aed173a891" title="Number of entries reserved at the beginning of the texture pool for internal driver usage.">NVN_DEVICE_INFO_RESERVED_TEXTURE_DESCRIPTORS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2c15b1de83a8fe22f4ef03b74d8f946a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c15b1de83a8fe22f4ef03b74d8f946a">&#9670;&nbsp;</a></span>nvnDeviceGetSeparateSamplerHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_n_v_nseparate_sampler_handle.html">NVNseparateSamplerHandle</a> nvnDeviceGetSeparateSamplerHandle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>samplerID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle for a separate <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device owning the sampler object.</td></tr>
    <tr><td class="paramname">samplerID</td><td>Registered ID of the <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object. Must be greater than or equal to 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a5b9a26a5aadab05c4a9f8a286718fbc7" title="Number of samplers that must be reserved for use by the driver.">NVN_DEVICE_INFO_RESERVED_SAMPLER_DESCRIPTORS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9291748f30602dc5655cd1556fc2eb01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9291748f30602dc5655cd1556fc2eb01">&#9670;&nbsp;</a></span>nvnDeviceIsExternalDebuggerAttached()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnDeviceIsExternalDebuggerAttached </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if an external debugger is attached when running an NVN application. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga81cb87eb9eba8acd7de1fa80ab673ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81cb87eb9eba8acd7de1fa80ab673ab7">&#9670;&nbsp;</a></span>nvnQueueGetError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga2a36e1011d80409e1d1cd7c87e81035c">NVNqueueGetErrorResult</a> nvnQueueGetError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="union_n_v_nqueue_error_info.html">NVNqueueErrorInfo</a> *&#160;</td>
          <td class="paramname"><em>errorInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get GPU error status of the queue. </p>
<p>Applications can use this function to check if queue encountered unrecoverable GPU error such as invalid GPU memory accesses, invalid command, timeout or other errors. After GPU error queue is in faulted state and following behavior is expected:</p><ol type="1">
<li><a class="el" href="group__nvn__c__functions.html#gaab3c15f657cefdff33dab453795ff38f" title="Wait until all commands previously submitted to a queue have completed execution.">nvnQueueFinish()</a> returns immediately.</li>
<li><a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> objects placed into faulted queue signal completion.</li>
<li>Faulted queue can be finalized to free resources.</li>
<li>Remaining nvnQueue API calls for faulted queue are ignored or return error.</li>
<li>Other device queues are not affected or blocked by faulted queue.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">queue</td><td><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> whose status should be checked for GPU error.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errorInfo</td><td>Pointer to structure to save information about error. If set to NULL, information will not be retrieved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacc96e4b44f4c1fa2540ecbcb37c4fe62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc96e4b44f4c1fa2540ecbcb37c4fe62">&#9670;&nbsp;</a></span>nvnQueueGetTotalCommandMemoryUsed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnQueueGetTotalCommandMemoryUsed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query total queue command memory usage. </p>
<p>This command returns the total amount of queue command memory (in bytes) used by queue commands since the queue was initialized or since usage counts were last reset by nvnQueueResetMemoryUsageCounts. The total memory usage count can be used by application developers to determine the amount of memory to provide when initializing a queue. Note that memory usage counts may exceed the total amount of memory provided to the queue since the NVN driver will automatically reuse queue memory when required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1f0889104e9531bc404a133456bad956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f0889104e9531bc404a133456bad956">&#9670;&nbsp;</a></span>nvnQueueGetTotalControlMemoryUsed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnQueueGetTotalControlMemoryUsed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query total queue control memory usage. </p>
<p>This command returns the total amount of queue control memory (in bytes) used by queue commands since the queue was initialized or since usage counts were last reset by nvnQueueResetMemoryUsageCounts. The total memory usage count can be used by application developers to determine the amount of memory to provide when initializing a queue. Note that memory usage counts may exceed the total amount of memory provided to the queue since the NVN driver will automatically reuse queue memory when required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga70fb17ac6a5d34a7e8eb17a8d1e9a28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70fb17ac6a5d34a7e8eb17a8d1e9a28e">&#9670;&nbsp;</a></span>nvnQueueGetTotalComputeMemoryUsed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnQueueGetTotalComputeMemoryUsed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query total queue compute memory usage. </p>
<p>This command returns the total amount of queue compute memory (in bytes) used by queue commands since the queue was initialized or since usage counts were last reset by nvnQueueResetMemoryUsageCounts. The total memory usage count can be used by application developers to determine the amount of memory to provide when initializing a queue. Note that memory usage counts may exceed the total amount of memory provided to the queue since the NVN driver will automatically reuse queue memory when required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae59349fe88c0a1e539a891b79e1bff72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae59349fe88c0a1e539a891b79e1bff72">&#9670;&nbsp;</a></span>nvnQueueResetMemoryUsageCounts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueueResetMemoryUsageCounts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset usage counters for command, control and compute memory. </p>
<p>This command resets the accumulated usage counters for queue command, control, and compute memory.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> memory consumed by GPU commands may not be added to the usage counters reset by this command until the queue is next flushed. When total queue memory usage is queried, any memory used by unflushed commands will be added to the total usage counters. As a result, querying memory usage immediately after resetting counters may return non-zero values if the queue has unflushed commands.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> object with counters to reset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7fdbe1fc82e21cf370aa7f1fa0a6141a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fdbe1fc82e21cf370aa7f1fa0a6141a">&#9670;&nbsp;</a></span>nvnQueueBuilderSetDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueueBuilderSetDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> associated with a <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> owning <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> objects created by the <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga20bc093a367e06cd1f1f273289354b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20bc093a367e06cd1f1f273289354b75">&#9670;&nbsp;</a></span>nvnQueueBuilderSetDefaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueueBuilderSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object. </p>
<p>This method does not modify the device associated with the builder, which is programmed by SetDevice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1665885cd6a9f8b9c3fbac546243b440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1665885cd6a9f8b9c3fbac546243b440">&#9670;&nbsp;</a></span>nvnQueueBuilderSetFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueueBuilderSetFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set properties of <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> objects created from the builder. </p>
<p>The default value for queue flags is <a class="el" href="group__nvn__c__enum.html#gga23e18ba1a4734288fff6c67afd04df14a3b2769b009642157d73235802a1a7ad4" title="No special operation behavior is required by the queue.">NVN_QUEUE_FLAGS_NONE</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">flags</td><td>Flags controlling the behavior of queues initialized using the builder. See <a class="el" href="group__nvn__c__enum.html#ga23e18ba1a4734288fff6c67afd04df14" title="Flags controlling the behavior of NVNqueue objects.">NVNqueueFlags</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4291be788552aa888e9551d0e1084bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4291be788552aa888e9551d0e1084bfb">&#9670;&nbsp;</a></span>nvnQueueBuilderSetCommandMemorySize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueueBuilderSetCommandMemorySize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the size of the internal command buffer used by a <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> object. </p>
<p>Each NVN queue has an internal command buffer used to send commands to the GPU. This command buffer is used by some <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> class methods and is also used for any required submit-time processing of command sets sent by nvnQueueSubmitCommands. Most queue commands do not require a large amount of command memory. However, compute dispatches and shader subroutine uniform updates can require a substantial amount of per-queue command memory. The internal queue command buffer memory is managed automatically by the NVN driver, and internal queue flushes may be required if a significant amount of command memory is used since the last explicit queue flush. For workloads requiring a significant amount of command memory, applications can specify a command memory size larger than the 64KB default size.</p>
<p>The default command memory size can be queried using the property <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a1275409c693a426d639a6460b42a9cb9" title="Default size for per-queue command memory.">NVN_DEVICE_INFO_QUEUE_COMMAND_MEMORY_DEFAULT_SIZE</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the queue's internal command memory. Must be greater than or equal to 65536 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50af620633087a96a544b6c2ff6741a7697" title="Minimum allowed size for per-queue command memory.">NVN_DEVICE_INFO_QUEUE_COMMAND_MEMORY_MIN_SIZE</a>). Must be a multiple of 4096 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ade5c93496a7e3c7830b2b9c961901816" title="Required granularity for per-queue command memory.">NVN_DEVICE_INFO_QUEUE_COMMAND_MEMORY_GRANULARITY</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga161b2d39535ffac2829d972058391bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga161b2d39535ffac2829d972058391bb6">&#9670;&nbsp;</a></span>nvnQueueBuilderSetComputeMemorySize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueueBuilderSetComputeMemorySize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the size of the internal buffers used for compute dispatches in a <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> object. </p>
<p>Each NVN queue may have an internal ring buffer used to hold information on compute dispatches that have been submitted to the queue but have not completed execution. The queue compute memory is managed automatically by the NVN driver, but the total size of this ring buffer can limit the number of compute dispatches in flight. Applications using a large number of compute dispatches per frame may benefit from increasing the size of this buffer. Applications not using compute shaders at all may set the size to zero to save memory.</p>
<p>The default compute memory size can be queried using the property <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ab35cc3044033489f4f72bc81576a614b" title="Default size for per-queue compute memory.">NVN_DEVICE_INFO_QUEUE_COMPUTE_MEMORY_DEFAULT_SIZE</a>.</p>
<dl class="section note"><dt>Note</dt><dd>If the queue compute memory size is zero, it is illegal to submit command sets containing compute work, such as nvnCommandBufferDispatchCompute.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the embedded queue command buffer. Must be a multiple of 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a85d83ee88a1d86d44da8f3ccce567553" title="Required granularity for per-queue compute memory.">NVN_DEVICE_INFO_QUEUE_COMPUTE_MEMORY_GRANULARITY</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaef123992e515f2eac2af9fecad8634a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef123992e515f2eac2af9fecad8634a9">&#9670;&nbsp;</a></span>nvnQueueBuilderSetControlMemorySize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueueBuilderSetControlMemorySize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the size of the control memory buffer used by a <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> object. </p>
<p>Each NVN queue has an internal control memory buffer used for gathering command buffer references consumed by the GPU. For example nvnQueueSubmitCommands and nvnCommandBufferCallCommands will add these references. The control buffer needs to be large enough so that NVN doesn't need to stall due to waiting for the buffer to drain. On the other hand, unnecessarily large buffer wastes memory. The default size of 16KB should be enough for most applications, but an application may want to tune this value for its needs. NVN will issue a debug layer performance warning in case the buffer is too small.</p>
<p>The default queue control memory size can be queried using the property <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a6c14564a64b9425808158e3bfc05db1a" title="Default size for queue control memory.">NVN_DEVICE_INFO_QUEUE_CONTROL_MEMORY_DEFAULT_SIZE</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the queue control memory. Must be greater than or equal to 4096 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a0e27f85a4c45ef97de142618f384b6d3" title="Minimum allowed size for queue control memory.">NVN_DEVICE_INFO_QUEUE_CONTROL_MEMORY_MIN_SIZE</a>). Must be a multiple of 4096 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a4a7d50535e574f4b8b9fc8a4e2431ed9" title="Required granularity for queue control memory.">NVN_DEVICE_INFO_QUEUE_CONTROL_MEMORY_GRANULARITY</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2903b2910d9471307595962237d3c578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2903b2910d9471307595962237d3c578">&#9670;&nbsp;</a></span>nvnQueueBuilderGetQueueMemorySize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnQueueBuilderGetQueueMemorySize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the amount of extra memory needed for a queue initialized using a <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a>. </p>
<p>Each NVN queue requires a separate block of per-queue memory for the GPU to use, which can be provided by nvnQueueBuilderSetQueueMemory. This command allows applications to determine the size of the provided memory, given the current <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> state. For correct operation, the <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> must have a device set via nvnQueueBuilderSetDevice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0403d233aff80ce9cc6548b5dbe24ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0403d233aff80ce9cc6548b5dbe24ca2">&#9670;&nbsp;</a></span>nvnQueueBuilderSetQueueMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueueBuilderSetQueueMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides memory to be used by queues pools initialized using a <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a>. </p>
<p>Each NVN queue created from a queue builder requires per-queue memory for several uses:</p>
<ul>
<li>Embedded command buffer memory, with a size provided by nvnQueueBuilderSetCommandMemorySize. </li>
<li>Embedded control memory, with a size provided by nvnQueueBuilderSetControlMemorySize. </li>
<li>Compute shader ring buffers, with a size provided by nvnQueueBuilderSetComputeMemorySize. </li>
<li>Scratch memory for fragment shader interlocks, which can be disabled by setting <a class="el" href="group__nvn__c__enum.html#gga23e18ba1a4734288fff6c67afd04df14aa3e0ad816f08301b322ba4d01d1853cd" title="Disable support for fragment shader interlocks.">NVN_QUEUE_FLAGS_NO_FRAGMENT_INTERLOCK_BIT</a>. </li>
<li>Scratch memory for other internal GPU operations.</li>
</ul>
<p>When a queue is initialized using a queue builder on NX, <em>size</em> bytes of memory pointed to by <em>memory</em> will be owned by the queue until the queue is finalized. Applications must not access <em>memory</em> directly after calling nvnQueueInitialize. <em>size</em> must be sufficiently large to satisfy the requirements described above; the minimum size can be queried using nvnQueueBuilderGetQueueMemorySize. On the Windows reference implementation, per-queue memory is allocated by the driver, and the memory provided by <em>memory</em> (if any) is ignored.</p>
<p>The default queue memory size is zero, indicating that no memory is provided by the application. In that case, the NVN driver will allocate a buffer of sufficient size when the queue is initialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object to update.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">memory</td><td>Storage used for the queue memory. Must be aligned to a multiple of 4KB (NVN_MEMORY_POOL_STORAGE_ALIGNMENT).</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">size</td><td>Size (in bytes) of the queue memory. Must be aligned to a multiple of 4KB (NVN_MEMORY_POOL_STORAGE_GRANULARITY). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4de1469ce962b138ca454c034f6e649b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4de1469ce962b138ca454c034f6e649b">&#9670;&nbsp;</a></span>nvnQueueBuilderSetCommandFlushThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueueBuilderSetCommandFlushThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a flush threshold for a new <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> object. </p>
<p><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> objects include an embedded command buffer that is automatically managed by the NVN driver. This command buffer is used to send commands to the GPU for various <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> methods or for command sets that require additional processing when nvnQueueSubmitCommands is called. Most commands require very little command memory, but certain commands like compute dispatches or shader subroutine uniform updates may require significant amounts of command memory. The NVN driver will automatically flush the queue when the amount of command memory used since the last queue flush approaches a specified flush threshold.</p>
<p>By default, the flush threshold is 1/8 of the total available command memory. Setting a higher threshold may reduce the number of automatic flushes performed, but less frequent flushes may cause the driver to have to wait for the completion of previous flushes before reusing command memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">threshold</td><td>Threshold (in bytes) of queue command memory usage triggering automatic flushes. Must be greater than or equal to 4096 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a41746792748f7b142878c4d1654e5c4d" title="Minimum flush threshold size for per-queue command memory provided to NVN.">NVN_DEVICE_INFO_QUEUE_COMMAND_MEMORY_MIN_FLUSH_THRESHOLD</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4ee5e4ee215b89d57000f8774135dd04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ee5e4ee215b89d57000f8774135dd04">&#9670;&nbsp;</a></span>nvnQueueBuilderSetQueuePriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueueBuilderSetQueuePriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__nvn__c__enum.html#gad6f183867c5a1658ad18db1d8dfb4102">NVNqueuePriority</a>&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a priority on a <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object. </p>
<p>Setting a priority on a <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object allows for additional control of the relative execution timing between Queues. <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> Priority affects both the execution order of the Queues in their timeslice as well as the (best-effort, round-robin) timesharing of the GPU resources. GPU-side scheduling of Queues is a function of method pipelining and shader run-time, and behavior is difficult to describe in a correct and precise fashion. This function has no effect on the Windows reference implementation. A few rules help guide the use of Priorities: </p><ul>
<li>Mixing Normal and Low should be avoided, as this increases the number of context switches on the GPU: prefer High and Low. </li>
<li>Content that should render in the frame should be submitted on High priority Queues, while Low priority is well suited for Compute content that can run for multiple frames. </li>
<li>Queues that have equal priorities will almost surely run in order of creation.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object to query.</td></tr>
    <tr><td class="paramname">priority</td><td>The priority to set on the queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac9ac49135f570d693b7c6469c62f069b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9ac49135f570d693b7c6469c62f069b">&#9670;&nbsp;</a></span>nvnQueueBuilderSetQueuePriority_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnQueueBuilderSetQueuePriority_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__nvn__c__enum.html#gad6f183867c5a1658ad18db1d8dfb4102">NVNqueuePriority</a>&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a priority on a <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object. </p>
<p>Fastpath variant.</p>
<p>Setting a priority on a <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object allows for additional control of the relative execution timing between Queues. <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> Priority affects both the execution order of the Queues in their timeslice as well as the (best-effort, round-robin) timesharing of the GPU resources. GPU-side scheduling of Queues is a function of method pipelining and shader run-time, and behavior is difficult to describe in a correct and precise fashion. This function has no effect on the Windows reference implementation. A few rules help guide the use of Priorities: </p><ul>
<li>Mixing Normal and Low should be avoided, as this increases the number of context switches on the GPU: prefer High and Low. </li>
<li>Content that should render in the frame should be submitted on High priority Queues, while Low priority is well suited for Compute content that can run for multiple frames. </li>
<li>Queues that have equal priorities will almost surely run in order of creation.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnQueueBuilderSetQueuePriority, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object to query.</td></tr>
    <tr><td class="paramname">priority</td><td>The priority to set on the queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab654b1b408e6ffe58faa6fa981796905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab654b1b408e6ffe58faa6fa981796905">&#9670;&nbsp;</a></span>nvnQueueBuilderGetQueuePriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#gad6f183867c5a1658ad18db1d8dfb4102">NVNqueuePriority</a> nvnQueueBuilderGetQueuePriority </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the priority associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaea2b90419b41e5ece6af3edd45129d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea2b90419b41e5ece6af3edd45129d32">&#9670;&nbsp;</a></span>nvnQueueBuilderGetDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a>* nvnQueueBuilderGetDevice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8052ee2bf90dc95291341ae400dd1ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8052ee2bf90dc95291341ae400dd1ea7">&#9670;&nbsp;</a></span>nvnQueueBuilderGetDevice_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a>* nvnQueueBuilderGetDevice_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnQueueBuilderGetDevice, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7bbd3d283a12e7b08f06f006dbebee66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bbd3d283a12e7b08f06f006dbebee66">&#9670;&nbsp;</a></span>nvnQueueBuilderGetFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnQueueBuilderGetFlags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get queue flags associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaed3ae6a74ec026d51d9cf84b8ae0f232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed3ae6a74ec026d51d9cf84b8ae0f232">&#9670;&nbsp;</a></span>nvnQueueBuilderGetFlags_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE int nvnQueueBuilderGetFlags_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get queue flags associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnQueueBuilderGetFlags, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga12df64513ce3e52474dc6a091cd3616d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12df64513ce3e52474dc6a091cd3616d">&#9670;&nbsp;</a></span>nvnQueueBuilderGetCommandMemorySize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnQueueBuilderGetCommandMemorySize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the command memory size associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object. </p>
<p>The function will return true if the command memory size was explicitly set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>Command memory size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf728cfa48fe1665b195f0bbcb7ece385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf728cfa48fe1665b195f0bbcb7ece385">&#9670;&nbsp;</a></span>nvnQueueBuilderGetComputeMemorySize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnQueueBuilderGetComputeMemorySize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the compute memory size associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object. </p>
<p>The function will return true if the compute memory size was explicitly set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>Compute memory size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0be1544f07aa9d9c50f0d7a6261df8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0be1544f07aa9d9c50f0d7a6261df8f3">&#9670;&nbsp;</a></span>nvnQueueBuilderGetControlMemorySize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnQueueBuilderGetControlMemorySize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the control memory size associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object. </p>
<p>The function will return true if the control memory size was explicitly set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>Control memory size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga620c9128e6758213a4fecaf7ce6fccea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga620c9128e6758213a4fecaf7ce6fccea">&#9670;&nbsp;</a></span>nvnQueueBuilderGetCommandFlushThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnQueueBuilderGetCommandFlushThreshold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>flushThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the command flush threshold associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object. </p>
<p>The function will return true if the flush threshold was explicitly set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flushThreshold</td><td>Flush threshold. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf8ddabb30dcd2193f80184a22a395b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8ddabb30dcd2193f80184a22a395b13">&#9670;&nbsp;</a></span>nvnQueueBuilderGetMemorySize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnQueueBuilderGetMemorySize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of the memory associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga272f5fc06e59a8c193abb2ad86ad6900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga272f5fc06e59a8c193abb2ad86ad6900">&#9670;&nbsp;</a></span>nvnQueueBuilderGetMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nvnQueueBuilderGetMemory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the memory associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac99fb806fca2d81338429173878844c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac99fb806fca2d81338429173878844c2">&#9670;&nbsp;</a></span>nvnQueueBuilderGetMemory_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void* nvnQueueBuilderGetMemory_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the memory associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnQueueBuilderGetMemory, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga512027cc783d925feb7261915130e2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga512027cc783d925feb7261915130e2ca">&#9670;&nbsp;</a></span>nvnQueueInitialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnQueueInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> object from a queue builder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> object to initialize.</td></tr>
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects.">NVNqueueBuilder</a> object holding properties of the new <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga54ac57de39c708eb9758bae7770d5ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54ac57de39c708eb9758bae7770d5ccc">&#9670;&nbsp;</a></span>nvnQueueFinalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueueFinalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> object. </p>
<dl class="section note"><dt>Note</dt><dd>Finalizing a queue will wait for the completion of all commands previously submitted to the queue, including those sent by the driver during queue initialization.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> object to finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0c90495a1a43ec403d590ee7603057ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c90495a1a43ec403d590ee7603057ec">&#9670;&nbsp;</a></span>nvnQueueSetDebugLabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueueSetDebugLabel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debug label string for a <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> object. </p>
<p>Annotates a <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> object with a descriptive text label. This label may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> object to set debug label.</td></tr>
    <tr><td class="paramname">label</td><td>Text string used to annotate the <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga095fabdb4c81459bbe496ba45528211b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga095fabdb4c81459bbe496ba45528211b">&#9670;&nbsp;</a></span>nvnQueueSubmitCommands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueueSubmitCommands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numCommands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a> *&#160;</td>
          <td class="paramname"><em>handles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit commands encapsulated in command buffers to a queue for processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> receiving the commands stored in the command buffers.</td></tr>
    <tr><td class="paramname">numCommands</td><td>Number of command buffers to send.</td></tr>
    <tr><td class="paramname">handles</td><td>Array of numCommands handles for the command buffers to send. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga98feac9fc906eb1a9a5eb19ef4381b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98feac9fc906eb1a9a5eb19ef4381b46">&#9670;&nbsp;</a></span>nvnQueueFlush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueueFlush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush commands previously submitted to a queue for processing. </p>
<p>Commands submitted to <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> objects may be batched up by the implementation to avoid the overhead that would be involved in flushing each command immediately after it is submitted. Flush can be used to manually flush commands that were previously batched up.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> whose commands should be flushed for further processing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaab3c15f657cefdff33dab453795ff38f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab3c15f657cefdff33dab453795ff38f">&#9670;&nbsp;</a></span>nvnQueueFinish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueueFinish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until all commands previously submitted to a queue have completed execution. </p>
<p>This command will not return to the caller until the previously submitted commands have completed. To determine if submitted commands have completed without blocking, applications can use <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> objects and Sync::WaitSync(). Finish will automatically flush the previously submitted commands as part of its operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> whose commands should be waited on for completion. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad317e78382b7f51a7a6f0504193d90c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad317e78382b7f51a7a6f0504193d90c7">&#9670;&nbsp;</a></span>nvnQueuePresentTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueuePresentTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>textureIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Display the contents of a texture into the window. </p>
<p>This command presents the texture specified by <em>textureIndex</em> in the native window associated with <em>window</em>. It also triggers an implicit call to nvnQueueFlush so that the texture is guaranteed to be shown on the screen in finite time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> used for previous commands rendering to texture.</td></tr>
    <tr><td class="paramname">window</td><td>The window where the texture should be presented.</td></tr>
    <tr><td class="paramname">textureIndex</td><td>The index of the texture to be displayed on-screen. The texture must be previously acquired from <em>window</em> using nvnWindowAcquireTexture. nvnQueuePresentTexture transfers the ownership of the texture back to the platform windowing system, and the application must re-acquire it with nvnWindowAcquireTexture before using it again. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf93ec4cee4147e9cc004b7b16c802621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf93ec4cee4147e9cc004b7b16c802621">&#9670;&nbsp;</a></span>nvnWindowBuilderSetDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnWindowBuilderSetDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> associated with a <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> owning <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> objects created by the <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3924f2d40fa227e1b405df3755ad46e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3924f2d40fa227e1b405df3755ad46e7">&#9670;&nbsp;</a></span>nvnWindowBuilderSetDefaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnWindowBuilderSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object. </p>
<p>This method does not modify the device associated with the builder, which is programmed by SetDevice.</p>
<dl class="section note"><dt>Note</dt><dd>This is semantically equivalent to calling</dd></dl>
<div class="fragment"><div class="line">WindowBuilder::SetNativeWindow(NULL);</div>
<div class="line">WindowBuilder::SetTextures(0, NULL);</div>
<div class="line">WindowBuilder::SetPresentInterval(1);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac518ddbead9eac057d3578c6195166b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac518ddbead9eac057d3578c6195166b2">&#9670;&nbsp;</a></span>nvnWindowBuilderSetNativeWindow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnWindowBuilderSetNativeWindow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga05b6b3dd5b965bd81efe2d03cee0bbbd">NVNnativeWindow</a>&#160;</td>
          <td class="paramname"><em>nativeWindow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the native window where the textures of this window will be presented to. </p>
<p>On NX, the native window should be of type <a class="el" href="namespacenn_1_1vi.html#a4d5f9e1b22348c0080755ad26cb980c1" title="Platform-dependent handle to a window.">nn::vi::NativeWindowHandle</a>.</p>
<p>On Windows, the native window (if provided) should be of type HWND and applications must have set a pixel format using the Windows <code>SetPixelFormat</code> API. The pixel format must be an RGBA format that supports NVIDIA hardware acceleration and has the <code>PFD_DRAW_TO_WINDOW</code>, <code>PFD_SUPPORT_OPENGL</code>, and <code>PFD_DOUBLEBUFFER</code> properties set. The window class that was registered using the Windows <code>RegisterClass</code> function, needs to have the CS_OWNDC flag set. If no native window is provided on Windows, applications must bind a "donor" OpenGL context and drawable using <code>wglMakeCurrent</code> before calling nvnQueuePresentTexture.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">nativeWindow</td><td>NativeWindow where the textures of this window will be presented to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4de9e801cdca28c77518c9e5942b5ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4de9e801cdca28c77518c9e5942b5ccd">&#9670;&nbsp;</a></span>nvnWindowBuilderSetNativeWindow_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnWindowBuilderSetNativeWindow_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga05b6b3dd5b965bd81efe2d03cee0bbbd">NVNnativeWindow</a>&#160;</td>
          <td class="paramname"><em>nativeWindow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the native window where the textures of this window will be presented to. </p>
<p>Fastpath variant.</p>
<p>On NX, the native window should be of type <a class="el" href="namespacenn_1_1vi.html#a4d5f9e1b22348c0080755ad26cb980c1" title="Platform-dependent handle to a window.">nn::vi::NativeWindowHandle</a>.</p>
<p>On Windows, the native window (if provided) should be of type HWND and applications must have set a pixel format using the Windows <code>SetPixelFormat</code> API. The pixel format must be an RGBA format that supports NVIDIA hardware acceleration and has the <code>PFD_DRAW_TO_WINDOW</code>, <code>PFD_SUPPORT_OPENGL</code>, and <code>PFD_DOUBLEBUFFER</code> properties set. The window class that was registered using the Windows <code>RegisterClass</code> function, needs to have the CS_OWNDC flag set. If no native window is provided on Windows, applications must bind a "donor" OpenGL context and drawable using <code>wglMakeCurrent</code> before calling nvnQueuePresentTexture.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnWindowBuilderSetNativeWindow, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">nativeWindow</td><td>NativeWindow where the textures of this window will be presented to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga610c7f233b7bb1e02f4926fe554df5db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga610c7f233b7bb1e02f4926fe554df5db">&#9670;&nbsp;</a></span>nvnWindowBuilderSetTextures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnWindowBuilderSetTextures </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numTextures</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *const *&#160;</td>
          <td class="paramname"><em>textures</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the textures used for presenting to this window. </p>
<p>The textures must specify <a class="el" href="group__nvn__c__enum.html#gga57ab2536473c8e62f621554a2618121bad47e8f3aafe9ec5eb90d9309d591604f" title="This texture can be displayed on-screen.">NVN_TEXTURE_FLAGS_DISPLAY_BIT</a>, and must not be finalized before the <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> is finalized.</p>
<p>For additional restrictions such as a list of supported formats, refer to the NVN programming guide.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">numTextures</td><td>Number of color textures to use. Must be greater than or equal to 2 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a7117530c35faff1e4158bc9610ca7892" title="Minimum value supported by nvnWindowBuilderSetTextures.">NVN_DEVICE_INFO_MIN_TEXTURES_PER_WINDOW</a>). Must be less than or equal to 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a732f31ae4f01b3912cb4742f1c98cbed" title="Maximum value supported by nvnWindowBuilderSetTextures.">NVN_DEVICE_INFO_MAX_TEXTURES_PER_WINDOW</a>).</td></tr>
    <tr><td class="paramname">textures</td><td>Array of numTextures pointers for color textures. The pointer must remain valid until the window is initialized with nvnWindowInitialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6b92b39df0509c4044ffec0d506c0074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b92b39df0509c4044ffec0d506c0074">&#9670;&nbsp;</a></span>nvnWindowBuilderSetTextures_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnWindowBuilderSetTextures_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numTextures</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *const *&#160;</td>
          <td class="paramname"><em>textures</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the textures used for presenting to this window. </p>
<p>Fastpath variant.</p>
<p>The textures must specify <a class="el" href="group__nvn__c__enum.html#gga57ab2536473c8e62f621554a2618121bad47e8f3aafe9ec5eb90d9309d591604f" title="This texture can be displayed on-screen.">NVN_TEXTURE_FLAGS_DISPLAY_BIT</a>, and must not be finalized before the <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> is finalized.</p>
<p>For additional restrictions such as a list of supported formats, refer to the NVN programming guide.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnWindowBuilderSetTextures, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">numTextures</td><td>Number of color textures to use. Must be greater than or equal to 2 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a7117530c35faff1e4158bc9610ca7892" title="Minimum value supported by nvnWindowBuilderSetTextures.">NVN_DEVICE_INFO_MIN_TEXTURES_PER_WINDOW</a>). Must be less than or equal to 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a732f31ae4f01b3912cb4742f1c98cbed" title="Maximum value supported by nvnWindowBuilderSetTextures.">NVN_DEVICE_INFO_MAX_TEXTURES_PER_WINDOW</a>).</td></tr>
    <tr><td class="paramname">textures</td><td>Array of numTextures pointers for color textures. The pointer must remain valid until the window is initialized with nvnWindowInitialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9c80a6fc0718d28e05c183a8110b9f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c80a6fc0718d28e05c183a8110b9f07">&#9670;&nbsp;</a></span>nvnWindowBuilderSetPresentInterval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnWindowBuilderSetPresentInterval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>presentInterval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the present interval used when presenting to this window. </p>
<p>Sets the present interval for the window object. The present interval specifies the minimum number of display refresh between frames when presenting to a <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object. Legal values are in the range [0,MAX_PRESENT_INTERVAL]:</p>
<ul>
<li>0: Update the display without waiting for the next refresh. This will display frames as fast as possible but will likely result in visual tearing.</li>
<li>1: Update the display on the next refresh. This limits the frame rate to the display's refresh rate.</li>
<li><em>n</em> (&gt; 1): Update the display on the next refresh, but no sooner than <em>n</em> refreshes since the previous update. This limits the frame rate to 1 / <em>n</em> of the display's refresh rate.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The production environment will not support a present interval of 0. In that environment, setting a present interval of 0 will behave as though 1 were specified.</dd>
<dd>
On the Windows reference implementation, calling SetPresentInterval with an interval different than 1 is only supported if the application provides a native window to the <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a>.</dd>
<dd>
On NX, the display refresh rate will always be 60Hz. On the Windows reference implementation, the refresh rate depend on the capabilities of the connected monitor and might be in some cases different than 60Hz.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">presentInterval</td><td>Present interval to use. Must be greater than or equal to zero. Must be less than or equal to 5 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a139273b9da8efa2fd1bba31f9bc93a8f" title="Maximum value supported by nvnWindowBuilderSetPresentInterval.">NVN_DEVICE_INFO_MAX_PRESENT_INTERVAL</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad3f7dbd4f7cfe3d734866db4f0f96497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3f7dbd4f7cfe3d734866db4f0f96497">&#9670;&nbsp;</a></span>nvnWindowBuilderSetNumActiveTextures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnWindowBuilderSetNumActiveTextures </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numActiveTextures</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the number of textures for presenting to this window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">numActiveTextures</td><td>Number of color textures to use. Must be less than or equal the number of textures set by nvnWindowBuilderSetTextures. Must be greater than or equal to 2 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a7117530c35faff1e4158bc9610ca7892" title="Minimum value supported by nvnWindowBuilderSetTextures.">NVN_DEVICE_INFO_MIN_TEXTURES_PER_WINDOW</a>). Must be less than or equal to 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a732f31ae4f01b3912cb4742f1c98cbed" title="Maximum value supported by nvnWindowBuilderSetTextures.">NVN_DEVICE_INFO_MAX_TEXTURES_PER_WINDOW</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa61a7c476bdc25d6c4c93751bf543df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa61a7c476bdc25d6c4c93751bf543df8">&#9670;&nbsp;</a></span>nvnWindowBuilderSetNumActiveTextures_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnWindowBuilderSetNumActiveTextures_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numActiveTextures</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the number of textures for presenting to this window. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnWindowBuilderSetNumActiveTextures, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">numActiveTextures</td><td>Number of color textures to use. Must be less than or equal the number of textures set by nvnWindowBuilderSetTextures. Must be greater than or equal to 2 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a7117530c35faff1e4158bc9610ca7892" title="Minimum value supported by nvnWindowBuilderSetTextures.">NVN_DEVICE_INFO_MIN_TEXTURES_PER_WINDOW</a>). Must be less than or equal to 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a732f31ae4f01b3912cb4742f1c98cbed" title="Maximum value supported by nvnWindowBuilderSetTextures.">NVN_DEVICE_INFO_MAX_TEXTURES_PER_WINDOW</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8a123578bac4b0a41cd7601cc53b84f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a123578bac4b0a41cd7601cc53b84f5">&#9670;&nbsp;</a></span>nvnWindowBuilderGetDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a>* nvnWindowBuilderGetDevice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the device associated with this <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga77a240ba752c43089ca3d32ee4d17e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77a240ba752c43089ca3d32ee4d17e60">&#9670;&nbsp;</a></span>nvnWindowBuilderGetDevice_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a>* nvnWindowBuilderGetDevice_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the device associated with this <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnWindowBuilderGetDevice, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacad10a6368b14ab7ba7d98f2855c800f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacad10a6368b14ab7ba7d98f2855c800f">&#9670;&nbsp;</a></span>nvnWindowBuilderGetNumTextures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnWindowBuilderGetNumTextures </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the number of textures associated with this <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga84df620e4826600e95d514c9167e1c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84df620e4826600e95d514c9167e1c4f">&#9670;&nbsp;</a></span>nvnWindowBuilderGetNumTextures_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE int nvnWindowBuilderGetNumTextures_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the number of textures associated with this <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnWindowBuilderGetNumTextures, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga02e84bd3df0a6dd2bc27e9775f959da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02e84bd3df0a6dd2bc27e9775f959da2">&#9670;&nbsp;</a></span>nvnWindowBuilderGetTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a>* nvnWindowBuilderGetTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>textureId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the texture with index textureId associated with this <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object. </p>
<p>The texture array stored in the <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object is supposed to remain valid until the window is initialized with nvnWindowInitialize. Therefore GetTexture should be called before the window is initialized to make sure it returns a valid pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object to query.</td></tr>
    <tr><td class="paramname">textureId</td><td>Index of the texture to be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga20d7c6255438597f1e6ff33a17bc1028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20d7c6255438597f1e6ff33a17bc1028">&#9670;&nbsp;</a></span>nvnWindowBuilderGetNativeWindow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga05b6b3dd5b965bd81efe2d03cee0bbbd">NVNnativeWindow</a> nvnWindowBuilderGetNativeWindow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the native window for a <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga63cf86f4034ccf1f3958d7d4c521eefa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63cf86f4034ccf1f3958d7d4c521eefa">&#9670;&nbsp;</a></span>nvnWindowBuilderGetNativeWindow_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE <a class="el" href="group__nvn__c__api__typedefs.html#ga05b6b3dd5b965bd81efe2d03cee0bbbd">NVNnativeWindow</a> nvnWindowBuilderGetNativeWindow_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the native window for a <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnWindowBuilderGetNativeWindow, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga23b4fc7396418e24deb8286cdb74da8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23b4fc7396418e24deb8286cdb74da8f">&#9670;&nbsp;</a></span>nvnWindowBuilderGetPresentInterval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnWindowBuilderGetPresentInterval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the present interval for a <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa848f2304d43c83aed3fa6fba34782ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa848f2304d43c83aed3fa6fba34782ce">&#9670;&nbsp;</a></span>nvnWindowBuilderGetNumActiveTextures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnWindowBuilderGetNumActiveTextures </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the number of active textures for presenting to this window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9c83252e5cdf05e5e0c30c7d9dea99ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c83252e5cdf05e5e0c30c7d9dea99ac">&#9670;&nbsp;</a></span>nvnWindowBuilderGetNumActiveTextures_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE int nvnWindowBuilderGetNumActiveTextures_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the number of active textures for presenting to this window Fastpath variant. </p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnWindowBuilderGetNumActiveTextures, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac5c388ac1ed70cb34ea4d71d23af9a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5c388ac1ed70cb34ea4d71d23af9a73">&#9670;&nbsp;</a></span>nvnWindowInitialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnWindowInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a new window object from a window builder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td><a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object to initialize.</td></tr>
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a> object holding properties of the new <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga53660a4abfffea411f62415c79a65cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53660a4abfffea411f62415c79a65cdf">&#9670;&nbsp;</a></span>nvnWindowFinalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnWindowFinalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td><a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object to finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4e7fcf2ce10cbe51af72130cacac4840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e7fcf2ce10cbe51af72130cacac4840">&#9670;&nbsp;</a></span>nvnWindowSetDebugLabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnWindowSetDebugLabel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debug label string for a <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object. </p>
<p>Annotates a <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object with a descriptive text label. This label may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td><a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object to set debug label.</td></tr>
    <tr><td class="paramname">label</td><td>Text string used to annotate the <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7fa0b45affa2e04d77e3c1ad11a03c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fa0b45affa2e04d77e3c1ad11a03c32">&#9670;&nbsp;</a></span>nvnWindowAcquireTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga58e9b155d7f2272b95044eed1f40415e">NVNwindowAcquireTextureResult</a> nvnWindowAcquireTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsync.html">NVNsync</a> *&#160;</td>
          <td class="paramname"><em>textureAvailableSync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>textureIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire a texture from the window. </p>
<p>This function will block until the GPU has completed rendering the previous frame to the acquired texture, but may return before the acquired texture is ready for rendering the next frame. The sync object <em>textureAvailableSync</em> can be used to determine when the acquired texture can be rendered to.</p>
<p>The caller is responsible for ensuring that it doesn't render to the acquired texture prematurely. Passing <em>textureAvailableSync</em> to nvnQueueWaitSync ensures that any subsequent commands sent to a queue are not processed by the GPU until the acquired texture is ready for use.</p>
<p>Applications should also use <em>textureAvailableSync</em> to match their rendering rate to the presentation rate. This can be done by calling nvnSyncWait on <em>textureAvailableSync</em> before calling nvnQueuePresentTexture.</p>
<dl class="section note"><dt>Note</dt><dd>Waiting for <em>textureAvailableSync</em> does not provide any guarantees regarding GPU work completion. For example, when double buffering between textures A and B, GPU may still be rendering texture B when A has become available for rendering (i.e. <em>textureAvailableSync</em> associated with acquiring texture A has been signaled).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">window</td><td><a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object to acquire a texture from.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">textureAvailableSync</td><td><a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object that will be signaled when the texture is available for rendering a new frame. If the texture has not been presented before with nvnQueuePresentTexture, <em>textureAvailableSync</em> will be signaled immediately. If nvnWindowAcquireTexture returns an error, <em>textureAvailableSync</em> will not be modified.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">textureIndex</td><td>An index into the texture array that was passed in when <em>window</em> was initialized, which identifies the texture that is now released from the platform windowing system to the application. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga35e25752c0757803fdb19b8b9584af9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35e25752c0757803fdb19b8b9584af9a">&#9670;&nbsp;</a></span>nvnWindowGetNativeWindow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga05b6b3dd5b965bd81efe2d03cee0bbbd">NVNnativeWindow</a> nvnWindowGetNativeWindow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the native window for a <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td><a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8b6fec6511611178d8cb553ce5358755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b6fec6511611178d8cb553ce5358755">&#9670;&nbsp;</a></span>nvnWindowGetNativeWindow_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE <a class="el" href="group__nvn__c__api__typedefs.html#ga05b6b3dd5b965bd81efe2d03cee0bbbd">NVNnativeWindow</a> nvnWindowGetNativeWindow_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the native window for a <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnWindowGetNativeWindow, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td><a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga759e5d9a7bd29dda539893cfd23d3ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga759e5d9a7bd29dda539893cfd23d3ca2">&#9670;&nbsp;</a></span>nvnWindowGetPresentInterval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnWindowGetPresentInterval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the present interval for a <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td><a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7edaefdb91e348186c3310c181fc1d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7edaefdb91e348186c3310c181fc1d5e">&#9670;&nbsp;</a></span>nvnWindowGetPresentInterval_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE int nvnWindowGetPresentInterval_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the present interval for a <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnWindowGetPresentInterval, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td><a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3b735c095396aabd05d437bd2bda1ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b735c095396aabd05d437bd2bda1ded">&#9670;&nbsp;</a></span>nvnWindowSetPresentInterval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnWindowSetPresentInterval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>presentInterval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the present interval for a <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object. </p>
<p>Sets the present interval for the window object. The present interval specifies the minimum number of display refresh between frames when presenting to a <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object. Legal values are in the range [0,MAX_PRESENT_INTERVAL]:</p>
<ul>
<li>0: Update the display without waiting for the next refresh. This will display frames as fast as possible but will likely result in visual tearing.</li>
<li>1: Update the display on the next refresh. This limits the frame rate to the display's refresh rate.</li>
<li><em>n</em> (&gt; 1): Update the display on the next refresh, but no sooner than <em>n</em> refreshes since the previous update. This limits the frame rate to 1 / <em>n</em> of the display's refresh rate.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The production environment will not support a present interval of 0. In that environment, setting a present interval of 0 will behave as though 1 were specified.</dd>
<dd>
On the Windows reference implementation, calling SetPresentInterval with an interval different than 1 is only supported if the application provides a native window to the <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects.">NVNwindowBuilder</a>.</dd>
<dd>
On NX, the display refresh rate will always be 60Hz. On the Windows reference implementation, the refresh rate depend on the capabilities of the connected monitor and might be in some cases different than 60Hz.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td><a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object.</td></tr>
    <tr><td class="paramname">presentInterval</td><td>Present interval to use. Must be greater than or equal to zero. Must be less than or equal to 5 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a139273b9da8efa2fd1bba31f9bc93a8f" title="Maximum value supported by nvnWindowBuilderSetPresentInterval.">NVN_DEVICE_INFO_MAX_PRESENT_INTERVAL</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf961e88cbeee4c0612548c40e7db432d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf961e88cbeee4c0612548c40e7db432d">&#9670;&nbsp;</a></span>nvnWindowSetCrop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnWindowSetCrop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the rectangle inside the window texture that gets displayed. </p>
<p>This method sets the rectangle inside a texture that gets displayed. If the rectangle size does not match the window size, the texture rectangle gets scaled to fit the window size. Passing a width or height of zero will reset the crop rectangle to match the dimension of the window texture.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td><a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object.</td></tr>
    <tr><td class="paramname">x</td><td>Smallest X coordinate of the display rectangle in window coordinates.</td></tr>
    <tr><td class="paramname">y</td><td>Smallest Y coordinate of the display rectangle in window coordinates.</td></tr>
    <tr><td class="paramname">w</td><td>Width of the display rectangle.</td></tr>
    <tr><td class="paramname">h</td><td>Height of the display rectangle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae0857c62a4ddce422c4aed104c607ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0857c62a4ddce422c4aed104c607ac4">&#9670;&nbsp;</a></span>nvnWindowGetCrop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnWindowGetCrop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_nrectangle.html">NVNrectangle</a> *&#160;</td>
          <td class="paramname"><em>crop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the dimensions of the crop rectangle that defines the region inside the window texture which gets displayed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">window</td><td><a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">crop</td><td>The crop rectangle that is used for presenting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga023ae1798862318f9cbe4bac4de26db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga023ae1798862318f9cbe4bac4de26db1">&#9670;&nbsp;</a></span>nvnWindowSetNumActiveTextures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnWindowSetNumActiveTextures </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numActiveTextures</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the number of textures for presenting to this window. </p>
<p>SetNumActiveTextures takes affect after numTextures - 1 frames in latest case. </p><dl class="section warning"><dt>Warning</dt><dd>This function must not be called while the app is holding any texture which is before presented to the window after acquiring it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td><a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object.</td></tr>
    <tr><td class="paramname">numActiveTextures</td><td>Number of color textures to use. Must be less than or equal to the number of textures set by nvnWindowBuilderSetTextures. Must be greater than or equal to 2 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a7117530c35faff1e4158bc9610ca7892" title="Minimum value supported by nvnWindowBuilderSetTextures.">NVN_DEVICE_INFO_MIN_TEXTURES_PER_WINDOW</a>). Must be less than or equal to 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a732f31ae4f01b3912cb4742f1c98cbed" title="Maximum value supported by nvnWindowBuilderSetTextures.">NVN_DEVICE_INFO_MAX_TEXTURES_PER_WINDOW</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab1d1cfbfb51522743c2bb1afb2cea414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1d1cfbfb51522743c2bb1afb2cea414">&#9670;&nbsp;</a></span>nvnWindowGetNumActiveTextures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnWindowGetNumActiveTextures </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the number of active textures for presenting to this window. </p>
<p>This value reflects the value set by nvnWindowSetNumActiveTextures immediately after calling the function but the actual change of the frame buffer behavior may take more time up to numTextures - 1 frames.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td><a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabe52efe05026fe19a9df4d6a8bdab8a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe52efe05026fe19a9df4d6a8bdab8a3">&#9670;&nbsp;</a></span>nvnWindowGetNumTextures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnWindowGetNumTextures </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the maximum available number of textures for presenting to this window. </p>
<p>This value is the same number of preallocated textures by nvnWindowBuilderSetTextures</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td><a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3dc4e247245c6f29706be307de1ca096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dc4e247245c6f29706be307de1ca096">&#9670;&nbsp;</a></span>nvnWindowGetNumTextures_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE int nvnWindowGetNumTextures_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the maximum available number of textures for presenting to this window. </p>
<p>Fastpath variant.</p>
<p>This value is the same number of preallocated textures by nvnWindowBuilderSetTextures</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnWindowGetNumTextures, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td><a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system.">NVNwindow</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga94b5dc5a5043495db9e6c3bc41ed6098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94b5dc5a5043495db9e6c3bc41ed6098">&#9670;&nbsp;</a></span>nvnProgramInitialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnProgramInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives.">NVNprogram</a> object for the specified device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td><a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives.">NVNprogram</a> object to initialize.</td></tr>
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> owning the program. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga24bd32154585c557cea6e061aecb6000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24bd32154585c557cea6e061aecb6000">&#9670;&nbsp;</a></span>nvnProgramFinalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnProgramFinalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *&#160;</td>
          <td class="paramname"><em>program</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a <a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives.">NVNprogram</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td><a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives.">NVNprogram</a> object to finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5cae86887480bb2aac1d98a5a4f94f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cae86887480bb2aac1d98a5a4f94f68">&#9670;&nbsp;</a></span>nvnProgramSetDebugLabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnProgramSetDebugLabel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debug label string for a <a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives.">NVNprogram</a> object. </p>
<p>Annotates a <a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives.">NVNprogram</a> object with a descriptive text label. This label may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td><a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives.">NVNprogram</a> object to set debug label.</td></tr>
    <tr><td class="paramname">label</td><td>Text string used to annotate the <a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives.">NVNprogram</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad6a517c8312bcaea2bafddfdf59f426a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6a517c8312bcaea2bafddfdf59f426a">&#9670;&nbsp;</a></span>nvnProgramSetShaders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnProgramSetShaders </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nshader_data.html">NVNshaderData</a> *&#160;</td>
          <td class="paramname"><em>stageData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a program object to use pre-compiled GPU code from one or multiple shaders. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td><a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives.">NVNprogram</a> object to set up.</td></tr>
    <tr><td class="paramname">count</td><td>Number of GPU programs to load in.</td></tr>
    <tr><td class="paramname">stageData</td><td>GPU control information to help set up </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga67a984a9d07ea6f3f976b846224b5515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67a984a9d07ea6f3f976b846224b5515">&#9670;&nbsp;</a></span>nvnProgramSetShadersExt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnProgramSetShadersExt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nshader_data_ext.html">NVNshaderDataExt</a> *&#160;</td>
          <td class="paramname"><em>stageDataExt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a program object to use pre-compiled GPU code from one or multiple shaders and optionally replaces the debug data hashes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td><a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives.">NVNprogram</a> object to set up.</td></tr>
    <tr><td class="paramname">count</td><td>Number of GPU programs to load in.</td></tr>
    <tr><td class="paramname">stageDataExt</td><td>GPU control information to help set up the program as well as replacement debug information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga242e9c1623683791c311192c1547cc4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga242e9c1623683791c311192c1547cc4e">&#9670;&nbsp;</a></span>nvnProgramSetSampleShading()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnProgramSetSampleShading </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga9cb9f0d20bd6e1b9c9140139d913ce21">NVNsampleShadingMode</a>&#160;</td>
          <td class="paramname"><em>shadingMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overrides how the program's fragment shader is evaluated. </p>
<p>By default a fragment shader is evaluated per sample only if a keyword such as gl_SamplePosition is used. This function can be used to force a specific sample shading mode.</p>
<dl class="section note"><dt>Note</dt><dd>: This function must be called before calling SetShaders otherwise it will have no effect.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td><a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives.">NVNprogram</a> object to modify.</td></tr>
    <tr><td class="paramname">shadingMode</td><td>Sample shading mode to override. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2194ddf73d0aae8dd2361f03f933a44d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2194ddf73d0aae8dd2361f03f933a44d">&#9670;&nbsp;</a></span>nvnProgramGetSubtileSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnProgramGetSubtileSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *&#160;</td>
          <td class="paramname"><em>program</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the computed subtile size for a program's fragment shader. </p>
<p>Fragments generated by rasterization are arranged into groups called <em>subtiles</em>, which are processed as a unit by the fragment shading hardware. The subtile size is configured by the NVN driver, which computes a default subtile size based on properties of the fragment shader and GPU hardware. This command returns the default subtile size for <em>program</em>, which can be overridden by nvnCommandBufferOverrideSubtileSize. Returns zero if <em>program</em> does not include a fragment shader.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td><a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives.">NVNprogram</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga872e7fb952779aa76d2643af8c50feab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga872e7fb952779aa76d2643af8c50feab">&#9670;&nbsp;</a></span>nvnProgramGetSubtileSize_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE int nvnProgramGetSubtileSize_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *&#160;</td>
          <td class="paramname"><em>program</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the computed subtile size for a program's fragment shader. </p>
<p>Fastpath variant.</p>
<p>Fragments generated by rasterization are arranged into groups called <em>subtiles</em>, which are processed as a unit by the fragment shading hardware. The subtile size is configured by the NVN driver, which computes a default subtile size based on properties of the fragment shader and GPU hardware. This command returns the default subtile size for <em>program</em>, which can be overridden by nvnCommandBufferOverrideSubtileSize. Returns zero if <em>program</em> does not include a fragment shader.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnProgramGetSubtileSize, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td><a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives.">NVNprogram</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacafb3b85111e530155835f1048360d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacafb3b85111e530155835f1048360d59">&#9670;&nbsp;</a></span>nvnMemoryPoolBuilderSetDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMemoryPoolBuilderSetDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> associated with a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> owning <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> objects created by the <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaa17de90ba16494d5076a9a0dba9185d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa17de90ba16494d5076a9a0dba9185d">&#9670;&nbsp;</a></span>nvnMemoryPoolBuilderSetDefaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMemoryPoolBuilderSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a> object. </p>
<p>This method does not modify the device associated with the builder, which is programmed by SetDevice.</p>
<dl class="section note"><dt>Note</dt><dd>This is semantically equivalent to calling</dd></dl>
<div class="fragment"><div class="line">MemoryPoolBuilder::SetStorage(NULL, 0);</div>
<div class="line">MemoryPoolBuilder::SetFlags(NVN_MEMORY_POOL_FLAGS_CPU_NO_ACCESS_BIT |</div>
<div class="line">                            NVN_MEMORY_POOL_FLAGS_GPU_CACHED_BIT);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga86c5f0efe19800f8571930177679853f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86c5f0efe19800f8571930177679853f">&#9670;&nbsp;</a></span>nvnMemoryPoolBuilderSetStorage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMemoryPoolBuilderSetStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides memory to be used by memory pools initialized using a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a>. </p>
<p>When a memory pool is initialized using a memory pool builder, <em>size</em> bytes of memory pointed to by <em>memory</em> will be owned by the memory pool until the memory pool is finalized. Applications must not access <em>memory</em> directly after calling nvnMemoryPoolInitialize. For memory pools created with <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a2fa7e2b859d94d1dc2c7077822b46f83" title="Indicates that the memory pool will be accessed by the CPU with caching.">NVN_MEMORY_POOL_FLAGS_CPU_CACHED_BIT</a> or <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a93f5342f52f301cfdca9901586b9b8e1" title="Indicates that the memory pool will be accessed by the CPU without caching.">NVN_MEMORY_POOL_FLAGS_CPU_UNCACHED_BIT</a>, applications can retrieve a CPU pointer to the pool using nvnMemoryPoolMap that can be used until the pool is finalized. The memory provided by <em>memory</em> can be re-used or freed by the application after the pool is finalized using nvnMemoryPoolFinalize.</p>
<p>Virtual memory pools (<a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a651cb5e0623ae5abd441c6c1b48087f5" title="Indicates that the memory pool may be used for sparse operations.">NVN_MEMORY_POOL_FLAGS_VIRTUAL_BIT</a>) do not own any storage and must be initialized using a NULL <em>memory</em> parameter.</p>
<p>On NX, non-virtual memory pools must be initialized with application-provided memory. Initialization for non-virtual memory pools will fail if a builder with a NULL <em>memory</em> parameter is provided.</p>
<p>On Windows, NVN allocates separate memory for non-virtual memory pools and does not take ownership of the application-provided memory. If <em>memory</em> is NULL, the contents of the allocated pool memory will be uninitialized. If <em>memory</em> is non-NULL, the allocated pool memory will be initialized by copying the <em>size</em> bytes pointed to by <em>memory</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a> object to update.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">memory</td><td>Storage used for the memory pool. Must be aligned to a multiple of 4KB (NVN_MEMORY_POOL_STORAGE_ALIGNMENT).</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">size</td><td>Size (in bytes) of the memory pool. Must be aligned to a multiple of 4KB (NVN_MEMORY_POOL_STORAGE_GRANULARITY). Must be greater than zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga332d877a6825cf3af6904c9615935daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga332d877a6825cf3af6904c9615935daa">&#9670;&nbsp;</a></span>nvnMemoryPoolBuilderSetFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMemoryPoolBuilderSetFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set properties of <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> objects created from the builder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">flags</td><td>Bitfield specifying properties of the memory pool to initialize. See <a class="el" href="group__nvn__c__enum.html#gaa7df4970255609d7a317631bcb37d654" title="Specifies properties of memory pools created from a memory pool builder.">NVNmemoryPoolFlags</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga40a50e5352cccfa1ba2c2569777b85fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40a50e5352cccfa1ba2c2569777b85fa">&#9670;&nbsp;</a></span>nvnMemoryPoolBuilderGetDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a>* nvnMemoryPoolBuilderGetDevice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the device associated with a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga143237ae7046e5c75f2ba2a50814c261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga143237ae7046e5c75f2ba2a50814c261">&#9670;&nbsp;</a></span>nvnMemoryPoolBuilderGetDevice_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a>* nvnMemoryPoolBuilderGetDevice_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the device associated with a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a>. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnMemoryPoolBuilderGetDevice, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac5dd6a5d6a9164d1bddf18cdef18502a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5dd6a5d6a9164d1bddf18cdef18502a">&#9670;&nbsp;</a></span>nvnMemoryPoolBuilderGetMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nvnMemoryPoolBuilderGetMemory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory allocation associated with a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafda9fa9a9327ab0a61835e1eddda205e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafda9fa9a9327ab0a61835e1eddda205e">&#9670;&nbsp;</a></span>nvnMemoryPoolBuilderGetMemory_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void* nvnMemoryPoolBuilderGetMemory_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory allocation associated with a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a>. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnMemoryPoolBuilderGetMemory, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga692de7a3a6d9d318a39ea376a096097e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga692de7a3a6d9d318a39ea376a096097e">&#9670;&nbsp;</a></span>nvnMemoryPoolBuilderGetSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnMemoryPoolBuilderGetSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the size associated with a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad772c1c13b0da3a947b59b4d20e763ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad772c1c13b0da3a947b59b4d20e763ef">&#9670;&nbsp;</a></span>nvnMemoryPoolBuilderGetSize_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE size_t nvnMemoryPoolBuilderGetSize_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the size associated with a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a>. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnMemoryPoolBuilderGetSize, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga68a5197066d35e0f2bb74afc79fc0020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68a5197066d35e0f2bb74afc79fc0020">&#9670;&nbsp;</a></span>nvnMemoryPoolBuilderGetFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#gaa7df4970255609d7a317631bcb37d654">NVNmemoryPoolFlags</a> nvnMemoryPoolBuilderGetFlags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the flags associated with a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2fd3be6de491b86c814434acefe29f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fd3be6de491b86c814434acefe29f5f">&#9670;&nbsp;</a></span>nvnMemoryPoolBuilderGetFlags_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE <a class="el" href="group__nvn__c__enum.html#gaa7df4970255609d7a317631bcb37d654">NVNmemoryPoolFlags</a> nvnMemoryPoolBuilderGetFlags_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the flags associated with a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a>. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnMemoryPoolBuilderGetFlags, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae78de6694c8b1b054050dcc1b82bb20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae78de6694c8b1b054050dcc1b82bb20d">&#9670;&nbsp;</a></span>nvnMemoryPoolInitialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnMemoryPoolInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> object using a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a> object. </p>
<dl class="section note"><dt>Note</dt><dd>On Windows, nvnMemoryPoolInitialize may return NVN_FALSE if video memory on the discrete GPU is exhausted. Reducing the size of the memory pool and/or shutting down other applications that consume video memory may resolve this error.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> object to initialize.</td></tr>
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">NVNmemoryPoolBuilder</a> object holding properties of the new <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6d256413a09dc0163d78749b7e8756b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d256413a09dc0163d78749b7e8756b6">&#9670;&nbsp;</a></span>nvnMemoryPoolSetDebugLabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMemoryPoolSetDebugLabel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debug label string for a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> object. </p>
<p>Annotates a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> object with a descriptive text label. This label may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> object to set debug label.</td></tr>
    <tr><td class="paramname">label</td><td>Text string used to annotate the <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4cc130f7dcc64cd765e0b74a8c10e448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cc130f7dcc64cd765e0b74a8c10e448">&#9670;&nbsp;</a></span>nvnMemoryPoolFinalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMemoryPoolFinalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>Memory pool to finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga072ffc85fe3f8ae544f3c788b192be77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga072ffc85fe3f8ae544f3c788b192be77">&#9670;&nbsp;</a></span>nvnMemoryPoolMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nvnMemoryPoolMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a CPU pointer to the memory owned by the <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> object. </p>
<p>If the memory pool does not support CPU access (<a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654ae90d91fe770d2eb3e1476c404c003369" title="Indicates that the memory pool will not be accessed by the CPU.">NVN_MEMORY_POOL_FLAGS_CPU_NO_ACCESS_BIT</a>), NULL is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>Memory pool object being accessed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9f76c329bcb4a9420bc4c6bc29f762e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f76c329bcb4a9420bc4c6bc29f762e3">&#9670;&nbsp;</a></span>nvnMemoryPoolFlushMappedRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMemoryPoolFlushMappedRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush previous CPU writes to a range of the memory pool to be visible to the GPU. </p>
<dl class="section note"><dt>Note</dt><dd>On NX, calling <a class="el" href="namespacenn_1_1os.html#a0fc3b750c03200539a98c98f7acca022" title="Writes the data stored in data cache to memory and then invalidates the pertinent cache line.">nn::os::FlushDataCache</a> on an equivalent memory range will have the same effect as calling this function. The flush is performed with 64-byte granularity, matching the size of a CPU cache line. The GPU cache line size is 128 bytes, so there may be interactions with nearby memory ranges that share a cache line with the flushed range. If two non-coherent memory ranges are separately managed by the CPU and the GPU, it is recommended that they be allocated from distinct 128-byte aligned ranges. See <a class="el" href="nvn_index.html#nvn_guide_memory_pool_coherency">3.2. CPU Access and Coherency</a> in the NVN Programming Guide for details and recommendations.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> object containing the range to flush.</td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) of the first byte of the memory pool range to flush.</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the memory pool range to flush. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabc7ba26caa615b7f4abb81de4ed6205e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc7ba26caa615b7f4abb81de4ed6205e">&#9670;&nbsp;</a></span>nvnMemoryPoolInvalidateMappedRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMemoryPoolInvalidateMappedRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidate CPU caches for a range of the memory pool that may have been written by the GPU. </p>
<dl class="section note"><dt>Note</dt><dd>On NX, calling <a class="el" href="namespacenn_1_1os.html#a0fc3b750c03200539a98c98f7acca022" title="Writes the data stored in data cache to memory and then invalidates the pertinent cache line.">nn::os::FlushDataCache</a> on an equivalent memory range will have the same effect as calling this function. The invalidate is performed with 64-byte granularity, matching the size of a CPU cache line. The GPU cache line size is 128 bytes, so there may be interactions with nearby memory ranges that share a cache line with the flushed range. If two non-coherent memory ranges are separately managed by the CPU and the GPU, it is recommended that they be allocated from distinct 128-byte aligned ranges. See <a class="el" href="nvn_index.html#nvn_guide_memory_pool_coherency">3.2. CPU Access and Coherency</a> in the NVN Programming Guide for details and recommendations.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> object containing the range to invalidate.</td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) of the first byte of the memory pool range to invalidate.</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the memory pool range to invalidate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac1c21d6dc85c6325013b0e782998fbdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1c21d6dc85c6325013b0e782998fbdb">&#9670;&nbsp;</a></span>nvnMemoryPoolGetBufferAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> nvnMemoryPoolGetBufferAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the GPU address of the data store of a memory pool object. </p>
<p>All buffer resources stored in a memory pool are accessed using a single GPU address mapping created for the entire pool. This function returns the GPU address of the first byte of this mapping.</p>
<dl class="section note"><dt>Note</dt><dd>The address for a buffer object can be obtained by adding the buffer address of the memory pool owning the buffer object and the offset of the buffer object within its pool.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> object used for the address query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae6dac6504ee2c716377f6dce9cede4e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6dac6504ee2c716377f6dce9cede4e1">&#9670;&nbsp;</a></span>nvnMemoryPoolMapVirtual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnMemoryPoolMapVirtual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>virtualPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numRequests</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmapping_request.html">NVNmappingRequest</a> *&#160;</td>
          <td class="paramname"><em>requests</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map memory pages from physical memory pools into a virtual memory pool. </p>
<p>This command can be used to map memory from a physical memory pool (one using <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654af8bf52f665606652b45e14bae4cb7f4f" title="Indicates that the memory pool may only be used as physical storage for memory mappings into virtual ...">NVN_MEMORY_POOL_FLAGS_PHYSICAL_BIT</a>) into a virtual memory pool (one using <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a651cb5e0623ae5abd441c6c1b48087f5" title="Indicates that the memory pool may be used for sparse operations.">NVN_MEMORY_POOL_FLAGS_VIRTUAL_BIT</a>). Each individual mapping request will map a contiguous set of pages in the physical pool into a contiguous range of the virtual pool, using a specified storage class for the virtual memory mapping. Applications can specify one or multiple mapping requests in a single call; performing multiple mappings in a single call can reduce CPU overhead required to perform the mappings.</p>
<p>Returns NVN_TRUE if all virtual mapping requests were successfully processed. If any mapping request fails, NVN_FALSE will be returned. If NVN_FALSE is returned, some of the virtual mapping requests may have been fully or partially satisfied prior to the failure. There is no guarantee that the mappings in <em>virtualPool</em> are unchanged if this command fails. Virtual mappings may fail if the graphics firmware has insufficient memory to set up the new mapping.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">virtualPool</td><td>Virtual memory pool to update.</td></tr>
    <tr><td class="paramname">numRequests</td><td>Number of mapping requests to perform.</td></tr>
    <tr><td class="paramname">requests</td><td>Array of mapping requests to perform. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1ab20a3416a36855861741c3305c2d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ab20a3416a36855861741c3305c2d80">&#9670;&nbsp;</a></span>nvnMemoryPoolGetSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnMemoryPoolGetSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the size associated with a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaae82797756975754c0e3f141c66a524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaae82797756975754c0e3f141c66a524">&#9670;&nbsp;</a></span>nvnMemoryPoolGetFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#gaa7df4970255609d7a317631bcb37d654">NVNmemoryPoolFlags</a> nvnMemoryPoolGetFlags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the flags associated with a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf3b22a7104a3c1cb6c0ab5c46e753587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3b22a7104a3c1cb6c0ab5c46e753587">&#9670;&nbsp;</a></span>nvnTexturePoolInitialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnTexturePoolInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *&#160;</td>
          <td class="paramname"><em>texturePool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>memoryPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numDescriptors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">NVNtexturePool</a> object. </p>
<p>The texture pool is a contiguous block of memory where texture descriptors are written. <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> descriptors hold information about textures and are used by the GPU when using textures in rendering operations. <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> descriptors are written into the pool using RegisterTexture. The pool itself must be set to the queue before rendering with any individual textures. A number of entries at the beginning of the pool are reserved for use by the driver. The number of reserved entries can be found by querying the device property RESERVED_TEXTURE_DESCRIPTORS. The size of each entry can be found by querying TEXTURE_DESCRIPTOR_SIZE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texturePool</td><td><a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">NVNtexturePool</a> object to initialize.</td></tr>
    <tr><td class="paramname">memoryPool</td><td><a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> object providing storage for the texture pool. The memory pool must be CPU-accessible (except on the Windows reference implementation).</td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) of the first byte of memory pool storage used by the texture pool. Must be a multiple of 32 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a72e50333aa53ce4a4d9dbd00c2af3db9" title="Size (in bytes) of a single texture descriptor stored in the pool.">NVN_DEVICE_INFO_TEXTURE_DESCRIPTOR_SIZE</a>).</td></tr>
    <tr><td class="paramname">numDescriptors</td><td>The number of texture descriptors that can be stored within the texture pool, including texture descriptors reserved to the driver. Must be greater than or equal to 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a513596e8b2dc04714d6478aed173a891" title="Number of entries reserved at the beginning of the texture pool for internal driver usage.">NVN_DEVICE_INFO_RESERVED_TEXTURE_DESCRIPTORS</a>). Must be less than or equal to 1048576 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a3e1b65743283fca466db252241b5dd87" title="Maximum number of entries (including reserved ones) supported in a texture descriptor pool.">NVN_DEVICE_INFO_MAX_TEXTURE_POOL_SIZE</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga58691b87b17bce83845582aa218982f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58691b87b17bce83845582aa218982f2">&#9670;&nbsp;</a></span>nvnTexturePoolSetDebugLabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTexturePoolSetDebugLabel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debug label string for a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">NVNtexturePool</a> object. </p>
<p>Annotates a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">NVNtexturePool</a> object with a descriptive text label. This label may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">NVNtexturePool</a> object to set debug label.</td></tr>
    <tr><td class="paramname">label</td><td>Text string used to annotate the <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">NVNtexturePool</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaef9948023397e7c1c3294fba08135f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef9948023397e7c1c3294fba08135f68">&#9670;&nbsp;</a></span>nvnTexturePoolFinalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTexturePoolFinalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">NVNtexturePool</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> pool to finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae68c38ccc4963fcdefa710b993104364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae68c38ccc4963fcdefa710b993104364">&#9670;&nbsp;</a></span>nvnTexturePoolRegisterTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTexturePoolRegisterTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *&#160;</td>
          <td class="paramname"><em>texturePool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a texture descriptor in a texture pool for use via texture handles. </p>
<p>The identifier <em>id</em> specifies an index into <em>texturePool</em> where the descriptor is written. The texture pool index is used together with a sampler pool index to generate a texture handle used for subsequent texture binding operations or bindless texture accesses. </p><dl class="section note"><dt>Note</dt><dd>If a texture needs to be used for both texture and image accesses, it must be registered separately for both use cases unless the device property <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a0932b19f385c068c4a59815c0b719b89" title="1 if the NVN implementation supports using texture handles for image accesses, 0 otherwise.">NVN_DEVICE_INFO_SUPPORTS_IMAGES_USING_TEXTURE_HANDLES</a> is true. </dd>
<dd>
In case of the NVN Windows reference implementation, if the texture is initialized with an ASTC format, any format specified in the <em>view</em> parameter will be ignored. For the detail, please refer <a class="el" href="nvn_index.html#nvn_guide_formats_restrictions_on_Windows">Formats Restrictions on the NVN Windows Reference Implementation</a> section of the Programming Guide.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texturePool</td><td>The texture pool owning the texture descriptor.</td></tr>
    <tr><td class="paramname">id</td><td>Offset (in descriptors) in the texture pool used to store the texture descriptor. Must be greater than or equal to 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a513596e8b2dc04714d6478aed173a891" title="Number of entries reserved at the beginning of the texture pool for internal driver usage.">NVN_DEVICE_INFO_RESERVED_TEXTURE_DESCRIPTORS</a>). Must be less than or equal to 1048576 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a3e1b65743283fca466db252241b5dd87" title="Maximum number of entries (including reserved ones) supported in a texture descriptor pool.">NVN_DEVICE_INFO_MAX_TEXTURE_POOL_SIZE</a>).</td></tr>
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to register.</td></tr>
    <tr><td class="paramname">view</td><td>View of the texture object to register. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab9357d2ef95b193039fab87192187845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9357d2ef95b193039fab87192187845">&#9670;&nbsp;</a></span>nvnTexturePoolRegisterImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTexturePoolRegisterImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *&#160;</td>
          <td class="paramname"><em>texturePool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an image descriptor in a texture pool for use via image loads and stores. </p>
<p>The identifier <em>id</em> specifies an index into <em>texturePool</em> where the descriptor is written. The texture pool index is used to generate an image handle used for subsequent image binding operations or bindless image accesses.</p>
<dl class="section note"><dt>Note</dt><dd>If a texture needs to be used for both texture and image accesses, it must be registered separately for both use cases unless the device property <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a0932b19f385c068c4a59815c0b719b89" title="1 if the NVN implementation supports using texture handles for image accesses, 0 otherwise.">NVN_DEVICE_INFO_SUPPORTS_IMAGES_USING_TEXTURE_HANDLES</a> is true.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texturePool</td><td>The texture pool owning the image descriptor.</td></tr>
    <tr><td class="paramname">id</td><td>Offset (in descriptors) in the texture pool used to store the image descriptor. Must be greater than or equal to 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a513596e8b2dc04714d6478aed173a891" title="Number of entries reserved at the beginning of the texture pool for internal driver usage.">NVN_DEVICE_INFO_RESERVED_TEXTURE_DESCRIPTORS</a>). Must be less than or equal to 1048576 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a3e1b65743283fca466db252241b5dd87" title="Maximum number of entries (including reserved ones) supported in a texture descriptor pool.">NVN_DEVICE_INFO_MAX_TEXTURE_POOL_SIZE</a>).</td></tr>
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to register.</td></tr>
    <tr><td class="paramname">view</td><td>View of the texture object to register. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabc56cdaa4e3572684ac54699776459f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc56cdaa4e3572684ac54699776459f0">&#9670;&nbsp;</a></span>nvnTexturePoolGetMemoryPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a>* nvnTexturePoolGetMemoryPool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool used by a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">NVNtexturePool</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">NVNtexturePool</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga051629046cc084fb24541b057a6fad91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga051629046cc084fb24541b057a6fad91">&#9670;&nbsp;</a></span>nvnTexturePoolGetMemoryPool_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a>* nvnTexturePoolGetMemoryPool_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool used by a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">NVNtexturePool</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnTexturePoolGetMemoryPool, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">NVNtexturePool</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga235dc3565dd2c666c1162229b58c9d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga235dc3565dd2c666c1162229b58c9d36">&#9670;&nbsp;</a></span>nvnTexturePoolGetMemoryOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t nvnTexturePoolGetMemoryOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool offset used by a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">NVNtexturePool</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">NVNtexturePool</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga41c3a27256c9c5eed8648ead0edce062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41c3a27256c9c5eed8648ead0edce062">&#9670;&nbsp;</a></span>nvnTexturePoolGetMemoryOffset_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE ptrdiff_t nvnTexturePoolGetMemoryOffset_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool offset used by a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">NVNtexturePool</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnTexturePoolGetMemoryOffset, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">NVNtexturePool</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga94185c1c4011d6a6cf9343fa5b923701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94185c1c4011d6a6cf9343fa5b923701">&#9670;&nbsp;</a></span>nvnTexturePoolGetSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnTexturePoolGetSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the number of descriptors in the memory of a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">NVNtexturePool</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">NVNtexturePool</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0beb1e1bd91db6e12ea0ff619b8e5ed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0beb1e1bd91db6e12ea0ff619b8e5ed9">&#9670;&nbsp;</a></span>nvnTexturePoolGetSize_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE int nvnTexturePoolGetSize_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the number of descriptors in the memory of a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">NVNtexturePool</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnTexturePoolGetSize, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">NVNtexturePool</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac78aeeebf55a677fa61bdceebc46ef5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac78aeeebf55a677fa61bdceebc46ef5b">&#9670;&nbsp;</a></span>nvnSamplerPoolInitialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnSamplerPoolInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *&#160;</td>
          <td class="paramname"><em>samplerPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>memoryPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numDescriptors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">NVNsamplerPool</a> object. </p>
<p>The sampler pool is a contiguous block of memory where sampler descriptors are written. <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> descriptors hold information about textures and are used by the GPU when using samplers in rendering operations. <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> descriptors are written into the pool using the RegisterSampler or RegisterSamplerBuilder methods. The pool itself must be set to the queue before rendering with any individual textures. A number of entries at the beginning of the pool are reserved for use by the driver. The number of reserved entries can be found by querying the device property RESERVED_SAMPLER_DESCRIPTORS. The size of each entry can be found by querying SAMPLER_DESCRIPTOR_SIZE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">samplerPool</td><td><a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">NVNsamplerPool</a> object to initialize.</td></tr>
    <tr><td class="paramname">memoryPool</td><td><a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> object providing storage for the sampler pool. The memory pool must be CPU-accessible (except on the Windows reference implementation).</td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) of the first byte of memory pool storage used by the sampler pool. Must be a multiple of 32 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ad6c9e8c2fd664c8ce50eddcf7563dbff" title="Size in bytes of a single sampler descriptor.">NVN_DEVICE_INFO_SAMPLER_DESCRIPTOR_SIZE</a>).</td></tr>
    <tr><td class="paramname">numDescriptors</td><td>The number of sampler descriptors that can be stored within the sampler pool, including samplers reserved to the driver. Must be greater than or equal to 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a5b9a26a5aadab05c4a9f8a286718fbc7" title="Number of samplers that must be reserved for use by the driver.">NVN_DEVICE_INFO_RESERVED_SAMPLER_DESCRIPTORS</a>). Must be less than or equal to 4096 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ae2d3753921fc35e9af1b1ae2b0cae57f" title="Maximum number of entries (including reserved ones) supported in a sampler descriptor pool.">NVN_DEVICE_INFO_MAX_SAMPLER_POOL_SIZE</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad5a4a7a3602ace4ed28a8249bdaf249f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5a4a7a3602ace4ed28a8249bdaf249f">&#9670;&nbsp;</a></span>nvnSamplerPoolSetDebugLabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerPoolSetDebugLabel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debug label string for a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">NVNsamplerPool</a> object. </p>
<p>Annotates a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">NVNsamplerPool</a> object with a descriptive text label. This label may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">NVNsamplerPool</a> object to set debug label.</td></tr>
    <tr><td class="paramname">label</td><td>Text string used to annotate the <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">NVNsamplerPool</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0f34faa24cf7902685de6c5c58e3b370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f34faa24cf7902685de6c5c58e3b370">&#9670;&nbsp;</a></span>nvnSamplerPoolFinalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerPoolFinalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">NVNsamplerPool</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> pool to finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga534898b94679ef42198d21f4a3bd966e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga534898b94679ef42198d21f4a3bd966e">&#9670;&nbsp;</a></span>nvnSamplerPoolRegisterSampler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerPoolRegisterSampler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *&#160;</td>
          <td class="paramname"><em>samplerPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a sampler descriptor in a sampler pool for use via texture handles, using a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object. </p>
<p>The identifier <em>id</em> specifies an index into <em>samplerPool</em> where the descriptor is written. The sampler pool index is used together with a texture pool index to generate a texture handle used for subsequent texture binding operations or bindless texture accesses.</p>
<dl class="section note"><dt>Note</dt><dd>The nvnSamplerPoolRegisterSamplerBuilder method performs identical sampler descriptor registration directly from sampler builder state, without a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">samplerPool</td><td>The sampler pool owning the sampler descriptor.</td></tr>
    <tr><td class="paramname">id</td><td>Offset (in descriptors) in the sampler pool used to store the sampler descriptor. Must be greater than or equal to 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a5b9a26a5aadab05c4a9f8a286718fbc7" title="Number of samplers that must be reserved for use by the driver.">NVN_DEVICE_INFO_RESERVED_SAMPLER_DESCRIPTORS</a>). Must be less than or equal to 4096 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ae2d3753921fc35e9af1b1ae2b0cae57f" title="Maximum number of entries (including reserved ones) supported in a sampler descriptor pool.">NVN_DEVICE_INFO_MAX_SAMPLER_POOL_SIZE</a>).</td></tr>
    <tr><td class="paramname">sampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object to register. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga33025ca24e76ce3cc2df1844cad3bca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33025ca24e76ce3cc2df1844cad3bca8">&#9670;&nbsp;</a></span>nvnSamplerPoolRegisterSamplerBuilder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerPoolRegisterSamplerBuilder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *&#160;</td>
          <td class="paramname"><em>samplerPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a sampler descriptor in a sampler pool for use via texture handles, using <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> state. </p>
<p>The identifier <em>id</em> specifies an index into <em>samplerPool</em> where the descriptor is written. The sampler pool index is used together with a texture pool index to generate a texture handle used for subsequent texture binding operations or bindless texture accesses.</p>
<dl class="section note"><dt>Note</dt><dd>The nvnSamplerPoolRegisterSampler method performs identical sampler descriptor registration using a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">samplerPool</td><td>The sampler pool owning the sampler descriptor.</td></tr>
    <tr><td class="paramname">id</td><td>Offset (in descriptors) in the sampler pool used to store the sampler descriptor. Must be greater than or equal to 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a5b9a26a5aadab05c4a9f8a286718fbc7" title="Number of samplers that must be reserved for use by the driver.">NVN_DEVICE_INFO_RESERVED_SAMPLER_DESCRIPTORS</a>). Must be less than or equal to 4096 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ae2d3753921fc35e9af1b1ae2b0cae57f" title="Maximum number of entries (including reserved ones) supported in a sampler descriptor pool.">NVN_DEVICE_INFO_MAX_SAMPLER_POOL_SIZE</a>).</td></tr>
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> builder state to register. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaee878a9e546d6c2b6325cf0be61ae41c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee878a9e546d6c2b6325cf0be61ae41c">&#9670;&nbsp;</a></span>nvnSamplerPoolGetMemoryPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a>* nvnSamplerPoolGetMemoryPool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool used by a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">NVNsamplerPool</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">NVNsamplerPool</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3eb0f055816559741a871fa6c1817b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3eb0f055816559741a871fa6c1817b06">&#9670;&nbsp;</a></span>nvnSamplerPoolGetMemoryPool_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a>* nvnSamplerPoolGetMemoryPool_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool used by a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">NVNsamplerPool</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnSamplerPoolGetMemoryPool, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">NVNsamplerPool</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7ab7ea81536b1e2cf80ad042e8f862a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ab7ea81536b1e2cf80ad042e8f862a7">&#9670;&nbsp;</a></span>nvnSamplerPoolGetMemoryOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t nvnSamplerPoolGetMemoryOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool offset used by a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">NVNsamplerPool</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">NVNsamplerPool</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga11e4a70af5e36373a37c3baea913f21e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11e4a70af5e36373a37c3baea913f21e">&#9670;&nbsp;</a></span>nvnSamplerPoolGetMemoryOffset_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE ptrdiff_t nvnSamplerPoolGetMemoryOffset_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool offset used by a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">NVNsamplerPool</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnSamplerPoolGetMemoryOffset, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">NVNsamplerPool</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadc23370e8330ae3727bb03f26f5d097c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc23370e8330ae3727bb03f26f5d097c">&#9670;&nbsp;</a></span>nvnSamplerPoolGetSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnSamplerPoolGetSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the number of descriptors in the memory of a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">NVNsamplerPool</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">NVNsamplerPool</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8045e82bc788372353472ec61bb08d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8045e82bc788372353472ec61bb08d0d">&#9670;&nbsp;</a></span>nvnSamplerPoolGetSize_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE int nvnSamplerPoolGetSize_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the number of descriptors in the memory of a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">NVNsamplerPool</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnSamplerPoolGetSize, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">NVNsamplerPool</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7f1e5a40cc9b049892a527b95ac9b9fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f1e5a40cc9b049892a527b95ac9b9fc">&#9670;&nbsp;</a></span>nvnBufferBuilderSetDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBufferBuilderSetDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> associated with a <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> owning <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> objects created by the <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga17550ab21d8136e4f5c48c91c21716f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17550ab21d8136e4f5c48c91c21716f2">&#9670;&nbsp;</a></span>nvnBufferBuilderSetDefaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBufferBuilderSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object. </p>
<p>This method does not modify the device associated with the builder, which is programmed by SetDevice.</p>
<dl class="section note"><dt>Note</dt><dd>This is semantically equivalent to calling</dd></dl>
<div class="fragment"><div class="line">BufferBuilder::SetStorage(NULL, 0, 0);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaaa4fd698902c746debccb3fa967e324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaaa4fd698902c746debccb3fa967e324">&#9670;&nbsp;</a></span>nvnBufferBuilderSetStorage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBufferBuilderSetStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the range of a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> used for a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object created from the <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> object providing storage for the new <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object.</td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) of the first byte of pool storage used by the new <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object.</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the new buffer object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga41b52c690e8fb7f7455588c4e4403768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41b52c690e8fb7f7455588c4e4403768">&#9670;&nbsp;</a></span>nvnBufferBuilderSetStorage_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnBufferBuilderSetStorage_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the range of a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> used for a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object created from the <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a>. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnBufferBuilderSetStorage, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> object providing storage for the new <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object.</td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) of the first byte of pool storage used by the new <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object.</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the new buffer object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf799ed12f9ff9d00ec9acdc4ba60ba57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf799ed12f9ff9d00ec9acdc4ba60ba57">&#9670;&nbsp;</a></span>nvnBufferBuilderGetDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a>* nvnBufferBuilderGetDevice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the device associated with this <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5b753c8e6ece193fed5d50c2d2e2d23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b753c8e6ece193fed5d50c2d2e2d23b">&#9670;&nbsp;</a></span>nvnBufferBuilderGetDevice_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a>* nvnBufferBuilderGetDevice_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the device associated with this <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnBufferBuilderGetDevice, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga80ec5e6a2f5d90f738de111cef60c5b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80ec5e6a2f5d90f738de111cef60c5b4">&#9670;&nbsp;</a></span>nvnBufferBuilderGetMemoryPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a>* nvnBufferBuilderGetMemoryPool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool used by a <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5a89114d870cb5b4da2d980a345956f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a89114d870cb5b4da2d980a345956f8">&#9670;&nbsp;</a></span>nvnBufferBuilderGetMemoryPool_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a>* nvnBufferBuilderGetMemoryPool_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool used by a <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnBufferBuilderGetMemoryPool, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga205e32b963584eaf5e8c78cdba135e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga205e32b963584eaf5e8c78cdba135e68">&#9670;&nbsp;</a></span>nvnBufferBuilderGetMemoryOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t nvnBufferBuilderGetMemoryOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool offset used by a <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0fb3902aaac7accad53fb11f558ac99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fb3902aaac7accad53fb11f558ac99b">&#9670;&nbsp;</a></span>nvnBufferBuilderGetMemoryOffset_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE ptrdiff_t nvnBufferBuilderGetMemoryOffset_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool offset used by a <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnBufferBuilderGetMemoryOffset, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga318db40761633c5e9129be18c1420f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga318db40761633c5e9129be18c1420f9c">&#9670;&nbsp;</a></span>nvnBufferBuilderGetSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnBufferBuilderGetSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the size (in bytes) of the storage in a <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga375f0fbe90f51fd378f5c17d734cd738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga375f0fbe90f51fd378f5c17d734cd738">&#9670;&nbsp;</a></span>nvnBufferBuilderGetSize_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE size_t nvnBufferBuilderGetSize_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the size (in bytes) of the storage in a <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnBufferBuilderGetSize, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga862eafc1a9c42ce08a7c40ba004d7b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga862eafc1a9c42ce08a7c40ba004d7b57">&#9670;&nbsp;</a></span>nvnBufferInitialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnBufferInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a new buffer object from a buffer builder. </p>
<p><a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> objects are created using the <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object, with storage provided by a memory pool or a previously existing <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td><a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object to initialize.</td></tr>
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects.">NVNbufferBuilder</a> object holding properties of the new <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9c0027b477c987c8a8573c7d04d854b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c0027b477c987c8a8573c7d04d854b1">&#9670;&nbsp;</a></span>nvnBufferSetDebugLabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBufferSetDebugLabel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debug label string for a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object. </p>
<p>Annotates a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object with a descriptive text label. This label may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td><a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object to set debug label.</td></tr>
    <tr><td class="paramname">label</td><td>Text string used to annotate the <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3e56941d8153c1e1b2ba861189ea993d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e56941d8153c1e1b2ba861189ea993d">&#9670;&nbsp;</a></span>nvnBufferFinalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBufferFinalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td><a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object to finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa3a80a57023737b594e83a9fa04282c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3a80a57023737b594e83a9fa04282c6">&#9670;&nbsp;</a></span>nvnBufferMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nvnBufferMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a CPU pointer to the memory of a previously created <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object. </p>
<p>If the memory pool used by the buffer object does not support CPU access (<a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654ae90d91fe770d2eb3e1476c404c003369" title="Indicates that the memory pool will not be accessed by the CPU.">NVN_MEMORY_POOL_FLAGS_CPU_NO_ACCESS_BIT</a>), NULL is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td><a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object to map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac38c964075df642306d6490b8b50ace3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac38c964075df642306d6490b8b50ace3">&#9670;&nbsp;</a></span>nvnBufferGetAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> nvnBufferGetAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the GPU address of the data store of a buffer object. </p>
<dl class="section note"><dt>Note</dt><dd>The address for a buffer object can also be obtained by adding the buffer address of the memory pool owning the buffer object and the offset of the buffer object within its pool.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td><a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object used for the address query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga77aee9d827392e1bb7d86a02dd5b8e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77aee9d827392e1bb7d86a02dd5b8e5c">&#9670;&nbsp;</a></span>nvnBufferFlushMappedRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBufferFlushMappedRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush previous CPU writes to a range of a buffer to be visible to the GPU. </p>
<dl class="section note"><dt>Note</dt><dd>On NX, calling <a class="el" href="namespacenn_1_1os.html#a0fc3b750c03200539a98c98f7acca022" title="Writes the data stored in data cache to memory and then invalidates the pertinent cache line.">nn::os::FlushDataCache</a> on an equivalent memory range will have the same effect as calling this function. The flush is performed with 64-byte granularity, matching the size of a CPU cache line. The GPU cache line size is 128 bytes, so there may be interactions with nearby memory ranges that share a cache line with the flushed range. If two non-coherent memory ranges are separately managed by the CPU and the GPU, it is recommended that they be allocated from distinct 128-byte aligned ranges. See <a class="el" href="nvn_index.html#nvn_guide_memory_pool_coherency">3.2. CPU Access and Coherency</a> in the NVN Programming Guide for details and recommendations.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td><a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object containing the range to flush.</td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) of the first byte of the buffer range to flush.</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the buffer range to flush. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf7087d787b41f8b07b13ed3a7f1edddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7087d787b41f8b07b13ed3a7f1edddc">&#9670;&nbsp;</a></span>nvnBufferInvalidateMappedRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBufferInvalidateMappedRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidate CPU caches for a range of a buffer that may have been written by the GPU. </p>
<dl class="section note"><dt>Note</dt><dd>On NX, calling <a class="el" href="namespacenn_1_1os.html#a0fc3b750c03200539a98c98f7acca022" title="Writes the data stored in data cache to memory and then invalidates the pertinent cache line.">nn::os::FlushDataCache</a> on an equivalent memory range will have the same effect as calling this function. The invalidate is performed with 64-byte granularity, matching the size of a CPU cache line. The GPU cache line size is 128 bytes, so there may be interactions with nearby memory ranges that share a cache line with the flushed range. If two non-coherent memory ranges are separately managed by the CPU and the GPU, it is recommended that they be allocated from distinct 128-byte aligned ranges. See <a class="el" href="nvn_index.html#nvn_guide_memory_pool_coherency">3.2. CPU Access and Coherency</a> in the NVN Programming Guide for details and recommendations.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td><a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object containing the range to invalidate.</td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) of the first byte of the buffer to invalidate.</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the buffer to invalidate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5f89923da0518bec56898b2dcddf213d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f89923da0518bec56898b2dcddf213d">&#9670;&nbsp;</a></span>nvnBufferGetMemoryPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a>* nvnBufferGetMemoryPool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool used by a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td><a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa4977edbe6a03b57fcf28fde92c24649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4977edbe6a03b57fcf28fde92c24649">&#9670;&nbsp;</a></span>nvnBufferGetMemoryPool_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a>* nvnBufferGetMemoryPool_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool used by a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnBufferGetMemoryPool, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td><a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga748c3509a17ea343cbee8675d4185f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga748c3509a17ea343cbee8675d4185f6e">&#9670;&nbsp;</a></span>nvnBufferGetMemoryOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t nvnBufferGetMemoryOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool offset used by a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td><a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga286445ca576d2dd9a1733fcb6bf7501a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga286445ca576d2dd9a1733fcb6bf7501a">&#9670;&nbsp;</a></span>nvnBufferGetMemoryOffset_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE ptrdiff_t nvnBufferGetMemoryOffset_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool offset used by a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnBufferGetMemoryOffset, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td><a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad9537e164c060a08b95e68caea5c9ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9537e164c060a08b95e68caea5c9ba6">&#9670;&nbsp;</a></span>nvnBufferGetSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnBufferGetSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the size (in bytes) of the storage of a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td><a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5f5c6403f8121790616058c4138c2d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f5c6403f8121790616058c4138c2d1c">&#9670;&nbsp;</a></span>nvnBufferGetSize_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE size_t nvnBufferGetSize_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the size (in bytes) of the storage of a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnBufferGetSize, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td><a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3d63ead7e4386863c9d3e250be49ad47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d63ead7e4386863c9d3e250be49ad47">&#9670;&nbsp;</a></span>nvnBufferGetDebugID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t nvnBufferGetDebugID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the debug layer unique ID of this buffer. </p>
<p>Returns 0 if debug layer disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td><a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3125b10128cdf01e0c489ebf9644cc36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3125b10128cdf01e0c489ebf9644cc36">&#9670;&nbsp;</a></span>nvnTextureBuilderSetDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> associated with a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> owning <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created by the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6287f82327692478ee9040e4fe73dd36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6287f82327692478ee9040e4fe73dd36">&#9670;&nbsp;</a></span>nvnTextureBuilderSetDefaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<p>This method does not modify the device associated with the builder, which is programmed by SetDevice.</p>
<dl class="section note"><dt>Note</dt><dd>This is semantically equivalent to calling</dd></dl>
<div class="fragment"><div class="line">TextureBuilder::SetFlags(0);</div>
<div class="line">TextureBuilder::SetTarget(TextureTarget::TARGET_2D);</div>
<div class="line">TextureBuilder::SetWidth(0);</div>
<div class="line">TextureBuilder::SetHeight(0);</div>
<div class="line">TextureBuilder::SetDepth(0);</div>
<div class="line">TextureBuilder::SetLevels(1);</div>
<div class="line">TextureBuilder::SetFormat(Format::NONE);</div>
<div class="line">TextureBuilder::SetSamples(0);</div>
<div class="line">TextureBuilder::SetSwizzle(TextureSwizzle::R, TextureSwizzle::G,</div>
<div class="line">                           TextureSwizzle::B, TextureSwizzle::A);</div>
<div class="line">TextureBuilder::SetDepthStencilMode(TextureDepthStencilMode::DEPTH);</div>
<div class="line">TextureBuilder::SetStorage(NULL, 0, 0);</div>
<div class="line">TextureBuilder::SetPackagedTextureData(NULL);</div>
<div class="line">TextureBuilder::SetPackagedTextureLayout(NULL);</div>
<div class="line">TextureBuilder::SetStride(0);</div>
<div class="line">TextureBuilder::SetGLTextureName(0);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga249280b0e8c57ead0fa7a82a8ebc56f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga249280b0e8c57ead0fa7a82a8ebc56f9">&#9670;&nbsp;</a></span>nvnTextureBuilderSetFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set flags indentifying special properties of <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="group__nvn__c__enum.html#ga57ab2536473c8e62f621554a2618121b" title="Identifies special properties of texture allocations.">NVNtextureFlags</a> value specifying special properties for created <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa7e80e3d31c6cffc51d255cbe86694b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7e80e3d31c6cffc51d255cbe86694b3">&#9670;&nbsp;</a></span>nvnTextureBuilderSetTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga7f247010f53480c7dd1f3b2ad638c431">NVNtextureTarget</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the target (texture type) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">target</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> target to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5712a1cc40bad51852c8d3e81e8108c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5712a1cc40bad51852c8d3e81e8108c5">&#9670;&nbsp;</a></span>nvnTextureBuilderSetTarget_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnTextureBuilderSetTarget_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga7f247010f53480c7dd1f3b2ad638c431">NVNtextureTarget</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the target (texture type) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnTextureBuilderSetTarget, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">target</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> target to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeb74efcd860292768c1ee95c09c647c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb74efcd860292768c1ee95c09c647c7">&#9670;&nbsp;</a></span>nvnTextureBuilderSetWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the width (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">width</td><td>Width (in texels) used for new textures. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga98d1393cc6947bb371edbab1f254cba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98d1393cc6947bb371edbab1f254cba7">&#9670;&nbsp;</a></span>nvnTextureBuilderSetWidth_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnTextureBuilderSetWidth_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the width (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnTextureBuilderSetWidth, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">width</td><td>Width (in texels) used for new textures. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad6c93fbfa974a07606f5c398adb4a080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6c93fbfa974a07606f5c398adb4a080">&#9670;&nbsp;</a></span>nvnTextureBuilderSetHeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetHeight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the height (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">height</td><td>Height (in texels) used for new textures. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7cda9dba5319ded82a20b806bb384d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cda9dba5319ded82a20b806bb384d17">&#9670;&nbsp;</a></span>nvnTextureBuilderSetHeight_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnTextureBuilderSetHeight_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the height (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnTextureBuilderSetHeight, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">height</td><td>Height (in texels) used for new textures. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad86f04179d66882fe758554678311e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad86f04179d66882fe758554678311e42">&#9670;&nbsp;</a></span>nvnTextureBuilderSetDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetDepth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the depth (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">depth</td><td>Depth (in texels) used for new textures. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa90855fc25d3451bc9aa82c92d4b3923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa90855fc25d3451bc9aa82c92d4b3923">&#9670;&nbsp;</a></span>nvnTextureBuilderSetDepth_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnTextureBuilderSetDepth_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the depth (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnTextureBuilderSetDepth, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">depth</td><td>Depth (in texels) used for new textures. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaff26847111e7f31129495f9211db22d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff26847111e7f31129495f9211db22d6">&#9670;&nbsp;</a></span>nvnTextureBuilderSetSize1D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetSize1D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the width (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>. </p>
<p>This command also sets the height and depth (in texels) to one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">width</td><td>Width (in texels) used for new textures. Must be greater than zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1eb945f455f851adf9b738be38cfb0bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1eb945f455f851adf9b738be38cfb0bc">&#9670;&nbsp;</a></span>nvnTextureBuilderSetSize2D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetSize2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the width and height (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>. </p>
<p>This command also sets the depth (in texels) to one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">width</td><td>Width (in texels) used for new textures. Must be greater than zero.</td></tr>
    <tr><td class="paramname">height</td><td>Height (in texels) used for new textures. Must be greater than zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1295ca18055627e3128e6ec7f0be5439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1295ca18055627e3128e6ec7f0be5439">&#9670;&nbsp;</a></span>nvnTextureBuilderSetSize3D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetSize3D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the width, height, and depth (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">width</td><td>Width (in texels) used for new textures. Must be greater than zero.</td></tr>
    <tr><td class="paramname">height</td><td>Height (in texels) used for new textures. Must be greater than zero.</td></tr>
    <tr><td class="paramname">depth</td><td>Depth (in texels) used for new textures. Must be greater than zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6a056b36730ab3bb163648b5a93ca7c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a056b36730ab3bb163648b5a93ca7c8">&#9670;&nbsp;</a></span>nvnTextureBuilderSetSize3D_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnTextureBuilderSetSize3D_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the width, height, and depth (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnTextureBuilderSetSize3D, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">width</td><td>Width (in texels) used for new textures. Must be greater than zero.</td></tr>
    <tr><td class="paramname">height</td><td>Height (in texels) used for new textures. Must be greater than zero.</td></tr>
    <tr><td class="paramname">depth</td><td>Depth (in texels) used for new textures. Must be greater than zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7b84b7b97960b702cd6e8438e0bc303b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b84b7b97960b702cd6e8438e0bc303b">&#9670;&nbsp;</a></span>nvnTextureBuilderSetLevels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetLevels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numLevels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the number of mipmap levels for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">numLevels</td><td>Number of mipmap levels to create for the texture. <ul>
<li>Must be greater than zero. </li>
<li>Must be one for targets <a class="el" href="group__nvn__c__enum.html#gga7f247010f53480c7dd1f3b2ad638c431a02667fb4d0f849264b91266727b7b221" title="Two-dimensional texture, accessed with non-normalized coordinates.">NVN_TEXTURE_TARGET_RECTANGLE</a> and <a class="el" href="group__nvn__c__enum.html#gga7f247010f53480c7dd1f3b2ad638c431ad76c4748580ea6bff4859bc20c034cb9" title="NVNbuffer texture.">NVN_TEXTURE_TARGET_BUFFER</a>. Must be greater than zero. Must be less than or equal to 15 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50afb8ed8803991c4da6b6b989c8cf955be" title="Maximum number of levels supported for any texture target.">NVN_DEVICE_INFO_MAX_TEXTURE_LEVELS</a>). </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaee1ad9054811161e66566175088ff000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee1ad9054811161e66566175088ff000">&#9670;&nbsp;</a></span>nvnTextureBuilderSetLevels_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnTextureBuilderSetLevels_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numLevels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the number of mipmap levels for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnTextureBuilderSetLevels, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">numLevels</td><td>Number of mipmap levels to create for the texture. <ul>
<li>Must be greater than zero. </li>
<li>Must be one for targets <a class="el" href="group__nvn__c__enum.html#gga7f247010f53480c7dd1f3b2ad638c431a02667fb4d0f849264b91266727b7b221" title="Two-dimensional texture, accessed with non-normalized coordinates.">NVN_TEXTURE_TARGET_RECTANGLE</a> and <a class="el" href="group__nvn__c__enum.html#gga7f247010f53480c7dd1f3b2ad638c431ad76c4748580ea6bff4859bc20c034cb9" title="NVNbuffer texture.">NVN_TEXTURE_TARGET_BUFFER</a>. Must be greater than zero. Must be less than or equal to 15 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50afb8ed8803991c4da6b6b989c8cf955be" title="Maximum number of levels supported for any texture target.">NVN_DEVICE_INFO_MAX_TEXTURE_LEVELS</a>). </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad83f59e208a24b5843543e1d0c7aec8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad83f59e208a24b5843543e1d0c7aec8a">&#9670;&nbsp;</a></span>nvnTextureBuilderSetFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab" title="Identifies how data elements stored in texture or buffer objects are encoded.">NVNformat</a> for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>. </p>
<p>Note that compressed formats are not supported for 1D or 1D array textures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">format</td><td><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab" title="Identifies how data elements stored in texture or buffer objects are encoded.">NVNformat</a> to use for new textures. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4b2053fd0ba53f7db4419f284c76285e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b2053fd0ba53f7db4419f284c76285e">&#9670;&nbsp;</a></span>nvnTextureBuilderSetFormat_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnTextureBuilderSetFormat_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab" title="Identifies how data elements stored in texture or buffer objects are encoded.">NVNformat</a> for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>. </p>
<p>Fastpath variant.</p>
<p>Note that compressed formats are not supported for 1D or 1D array textures.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnTextureBuilderSetFormat, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">format</td><td><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab" title="Identifies how data elements stored in texture or buffer objects are encoded.">NVNformat</a> to use for new textures. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0d9a12fdb214af17acac6536d23cd911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d9a12fdb214af17acac6536d23cd911">&#9670;&nbsp;</a></span>nvnTextureBuilderSetSamples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetSamples </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the sample count for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">samples</td><td>Sample count to use for new textures. <ul>
<li>Must be zero for non-multisample textures (those with targets other than TextureTarget::TEXTURE_MULTISAMPLE and TextureTarget::TARGET_MULTISAMPLE_ARRAY). </li>
<li>Must be 2, 4, 8 or 16 for multisample textures. </li>
<li>May be 16 only for textures with a format of <a class="el" href="group__nvn__c__enum.html#gga99463f5b9af6151e604b01dfdd5fecaba744d4b5716446de725dc08dfcc8ea3ca" title="An 8-bit unsigned integer stencil component.">NVN_FORMAT_STENCIL8</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9f3a3be05f2c5477f75036efcafb9fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f3a3be05f2c5477f75036efcafb9fbf">&#9670;&nbsp;</a></span>nvnTextureBuilderSetSamples_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnTextureBuilderSetSamples_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the sample count for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnTextureBuilderSetSamples, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">samples</td><td>Sample count to use for new textures. <ul>
<li>Must be zero for non-multisample textures (those with targets other than TextureTarget::TEXTURE_MULTISAMPLE and TextureTarget::TARGET_MULTISAMPLE_ARRAY). </li>
<li>Must be 2, 4, 8 or 16 for multisample textures. </li>
<li>May be 16 only for textures with a format of <a class="el" href="group__nvn__c__enum.html#gga99463f5b9af6151e604b01dfdd5fecaba744d4b5716446de725dc08dfcc8ea3ca" title="An 8-bit unsigned integer stencil component.">NVN_FORMAT_STENCIL8</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabc101b1093b409c29b8db4a6f144d968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc101b1093b409c29b8db4a6f144d968">&#9670;&nbsp;</a></span>nvnTextureBuilderSetSwizzle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetSwizzle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a>&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the texture swizzle for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>. </p>
<p>Lookups from <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects will return a four-component vector with (R,G,B,A) components. The texture <a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab" title="Identifies how data elements stored in texture or buffer objects are encoded.">NVNformat</a> specifies the (R,G,B,A) components used for storing texel data. The texture swizzle allows applications to produce a new (R,G,B,A) vector by specifying a source component value (R, G, B, A, or the constants 0 or 1) to use for each component of the new output vector. For example, an application can use the swizzle to remap a texture with a format of <a class="el" href="group__nvn__c__enum.html#gga99463f5b9af6151e604b01dfdd5fecaba1b8221c2a207f0d16fb49c568040da0b" title="One 8-bit unsigned normalized component.">NVN_FORMAT_R8</a> into a 'LUMINANCE8' texture by using a swizzle pattern of (R,R,R,1).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">r</td><td>Input component value used for the first (R) output component.</td></tr>
    <tr><td class="paramname">g</td><td>Input component value used for the second (G) output component.</td></tr>
    <tr><td class="paramname">b</td><td>Input component value used for the third (B) output component.</td></tr>
    <tr><td class="paramname">a</td><td>Input component value used for the fourth (A) output component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad1f0c27399978e0f15954533cc4763bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1f0c27399978e0f15954533cc4763bd">&#9670;&nbsp;</a></span>nvnTextureBuilderSetDepthStencilMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetDepthStencilMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga3fc9be97b8a8e51aacbaf2d93edb9b1c">NVNtextureDepthStencilMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the values returned for depth/stencil <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>. </p>
<p>If the texture has a format with no depth or stencil components, the depth/stencil mode is ignored. If depth/stencil mode selects the stencil component in a texture with only a depth component or vice versa, the results of texture lookups are undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">mode</td><td>Specifies whether to return depth or stencil values from a texture with depth and/or stencil components. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae4d5094e5922edff81723ff08abbf77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4d5094e5922edff81723ff08abbf77f">&#9670;&nbsp;</a></span>nvnTextureBuilderSetDepthStencilMode_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnTextureBuilderSetDepthStencilMode_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga3fc9be97b8a8e51aacbaf2d93edb9b1c">NVNtextureDepthStencilMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the values returned for depth/stencil <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>. </p>
<p>Fastpath variant.</p>
<p>If the texture has a format with no depth or stencil components, the depth/stencil mode is ignored. If depth/stencil mode selects the stencil component in a texture with only a depth component or vice versa, the results of texture lookups are undefined.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnTextureBuilderSetDepthStencilMode, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">mode</td><td>Specifies whether to return depth or stencil values from a texture with depth and/or stencil components. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1ba9cfd0600643dbb909eaa9c36abe26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ba9cfd0600643dbb909eaa9c36abe26">&#9670;&nbsp;</a></span>nvnTextureBuilderGetStorageSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnTextureBuilderGetStorageSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the amount of memory (in bytes) required to hold a texture to be created using the provided <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<p>For correct operation, the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> must have a device set via nvnTextureBuilderSetDevice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to be used to create a new texture. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga05c4e80a256b37ed63e1478ffd680eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05c4e80a256b37ed63e1478ffd680eab">&#9670;&nbsp;</a></span>nvnTextureBuilderGetStorageAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnTextureBuilderGetStorageAlignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the minimum alignment in bytes (in bytes) required to hold a texture to be created using the provided <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<p>For correct operation, the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> must have a device set via nvnTextureBuilderSetDevice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to be used to create a new texture. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad412a4af5aa2ce9732256345b9b7c0a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad412a4af5aa2ce9732256345b9b7c0a7">&#9670;&nbsp;</a></span>nvnTextureBuilderGetViewOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t nvnTextureBuilderGetViewOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>textureView</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the offset (in bytes) of the first byte of storage used by a view of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object created by the provided <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>. </p>
<p>The offset returned is a value relative to the offset of the first byte of storage used by the full texture. Textures are stored in (virtually) contiguous memory. For array and cube map textures, each layer or face is stored in memory as a unit with offsets increasing by layer number. For mipmapped textures, each mipmap level in the texture (or in each layer for array and cube map textures) is stored as a unit with offsets increasing by mipmap level number.</p>
<dl class="section note"><dt>Note</dt><dd>The return value of this function is the same as that of nvnTextureGetViewOffset called on a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> initialized from the provided <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query.</td></tr>
    <tr><td class="paramname">textureView</td><td>View of the texture used to determine an offset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf6530c01a016b836ad82434f6a793cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6530c01a016b836ad82434f6a793cd8">&#9670;&nbsp;</a></span>nvnTextureBuilderSetStorage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the location in a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> used for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> object providing storage for the new <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object.</td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) of the first byte of pool storage used by the new <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. <ul>
<li>The provided offset must be a multiple of the required alignment for the provided <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad23f93b4dba4217792daee5196eb8d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad23f93b4dba4217792daee5196eb8d28">&#9670;&nbsp;</a></span>nvnTextureBuilderSetStorage_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnTextureBuilderSetStorage_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the location in a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> used for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnTextureBuilderSetStorage, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> object providing storage for the new <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object.</td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) of the first byte of pool storage used by the new <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. <ul>
<li>The provided offset must be a multiple of the required alignment for the provided <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6ccd08d4bafb09088fb0c39aea731354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ccd08d4bafb09088fb0c39aea731354">&#9670;&nbsp;</a></span>nvnTextureBuilderSetPackagedTextureData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetPackagedTextureData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify optional packaged texture data used to initialize texture storage. </p>
<p>On the Windows reference implementation, texture data produced by the texture packager is not in a form that can be consumed directly by the GPU. When creating a texture with a non-NULL packaged texture data pointer, the Windows reference implementation will convert the texture data from the packaged form to the native format of the GPU, storing the results in the pool memory specified in the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> used to create the texture. If the packaged texture data pointer is NULL, no conversion or copy will be performed. On the target device, the packaged texture data pointer is not used; packaged texture data may be loaded directly in the underlying pool storage used by the texture. For more information please refer to the <a class="el" href="nvn_index.html#nvn_guide_formats_restrictions_on_Windows">Formats Restrictions on the NVN Windows Reference Implementation</a> section of the Programming Guide.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">data</td><td>CPU pointer to NX-optimized texture data built by the texture packager; ignored on NX. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab9c504fb68daac897da16e9161e61eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9c504fb68daac897da16e9161e61eb7">&#9670;&nbsp;</a></span>nvnTextureBuilderSetPackagedTextureLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetPackagedTextureLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_npackaged_texture_layout.html">NVNpackagedTextureLayout</a> *&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the layout of packaged texture data used for texture storage. </p>
<p>This command specifies the memory layout of packaged texture data produced by the NVN texture packager. By default, the driver and texture packager select an optimal layout for a texture based on its size and format. This command allows applications to provide the driver with a layout descriptor produced by the NVN texture packager so that old packaged texture assets can continue to be used even if the default layout changes in a new driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">layout</td><td>Description of the texture layout produced by the NVN texture packager. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabaadb0c9f8190a0f8dbc4e637f593636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabaadb0c9f8190a0f8dbc4e637f593636">&#9670;&nbsp;</a></span>nvnTextureBuilderSetStride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetStride </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify stride for linear textures. </p>
<p>Specifies the stride for linear textures. Only used when the TextureFlags::LINEAR_BIT flag is set. The stride is defined as the number of bytes between consecutive rows in the linear image. If the texture is to be used as a render target, then this value must be aligned to at least deviceInfo::LINEAR_RENDER_TARGET_STRIDE_ALIGNMENT. If it is only used as a texture, then it needs to be aligned to deviceInfo::LINEAR_TEXTURE_STRIDE_ALIGNMENT Should be at least (width * bpp).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">stride</td><td>Stride for this linear texture. <ul>
<li>Must be greater than zero for linear textures. </li>
<li>Must be aligned to either deviceInfo::LINEAR_RENDER_TARGET_STRIDE_ALIGNMENT or deviceInfo::LINEAR_TEXTURE_STRIDE_ALIGNMENT. Must be greater than or equal to zero. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae8382ee09ab0b9f65b84368aa3aa8fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8382ee09ab0b9f65b84368aa3aa8fef">&#9670;&nbsp;</a></span>nvnTextureBuilderSetGLTextureName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetGLTextureName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the name of the OpenGL texture to use as an external texture source. </p>
<p>If a texture builder with a non-zero texture name is used to initialize a new NVN texture, the texture will be initialized to use all the properties, including texel storage, of the OpenGL or OpenGL ES texture with the provided name. The texture name will be used to look up OpenGL or OpenGL ES texture object using the OpenGL/OpenGL ES context current on the thread initializing the NVN texture. If no OpenGL/OpenGL ES context is current, or if the name does not identify a valid texture object, the results of NVN texture initialization are undefined. There are a number of restrictions on the GL texture object: </p><ul>
<li><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> storage must be immutable. </li>
<li>The format and target of the texture must have NVN equivalents. </li>
<li>Sparse textures are unsupported. </li>
<li><a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> textures are unsupported. Synchronization and lifetime management must be handled by the application. In particular, the application must ensure that all NVN commands accessing the texture have completed (e.g., by calling <a class="el" href="group__nvn__c__functions.html#gaab3c15f657cefdff33dab453795ff38f" title="Wait until all commands previously submitted to a queue have completed execution.">nvnQueueFinish()</a>) before calling either glDeleteTextures() or <a class="el" href="group__nvn__c__functions.html#gaa5741253f7ab5c9075a6821a68cfa351" title="Finalize a NVNtexture object.">nvnTextureFinalize()</a>. By default, the texture name associated with a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> is zero, which indicates that no GL texture should be used for NVN texture initialization.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">name</td><td>The name of the OpenGL/OpenGL ES texture to use as a source. <ul>
<li>Must be zero, or the name of a valid OpenGL or OpenGL ES texture. </li>
<li>If non-zero, the texture properties must be compatible with NVN. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad4136c92f14cf364c1776814c31d098a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4136c92f14cf364c1776814c31d098a">&#9670;&nbsp;</a></span>nvnTextureBuilderGetStorageClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga4e21960c2b9244bbd2753954b23580d3">NVNstorageClass</a> nvnTextureBuilderGetStorageClass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the storage class needed for virtual memory mappings for a texture to be created using the provided <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<p>When memory from a physical memory pool is mapped into a virtual memory pool, the mapping must be established with a storage class appropriate for texture or buffer resources using the virtual memory. The value returned by this command should be used for memory mappings of textures created with this <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to be used to create a new texture. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf602e9d491bac3c2389d3f62e5fc3a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf602e9d491bac3c2389d3f62e5fc3a82">&#9670;&nbsp;</a></span>nvnTextureBuilderGetDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a>* nvnTextureBuilderGetDevice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the device associated with this <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga392d7354936040055696d5e306ec0b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga392d7354936040055696d5e306ec0b23">&#9670;&nbsp;</a></span>nvnTextureBuilderGetDevice_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a>* nvnTextureBuilderGetDevice_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the device associated with this <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnTextureBuilderGetDevice, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5e8501ec354c364fc84ac787a1b29042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e8501ec354c364fc84ac787a1b29042">&#9670;&nbsp;</a></span>nvnTextureBuilderGetFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga57ab2536473c8e62f621554a2618121b">NVNtextureFlags</a> nvnTextureBuilderGetFlags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the flags for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac234d1568f85b9c250d001aa987215d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac234d1568f85b9c250d001aa987215d9">&#9670;&nbsp;</a></span>nvnTextureBuilderGetFlags_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE <a class="el" href="group__nvn__c__enum.html#ga57ab2536473c8e62f621554a2618121b">NVNtextureFlags</a> nvnTextureBuilderGetFlags_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the flags for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnTextureBuilderGetFlags, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf0202b12c55ce5a46f3c023266d8c454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0202b12c55ce5a46f3c023266d8c454">&#9670;&nbsp;</a></span>nvnTextureBuilderGetTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga7f247010f53480c7dd1f3b2ad638c431">NVNtextureTarget</a> nvnTextureBuilderGetTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the target for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8a0cab3b48389afdc34492c8762e1403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a0cab3b48389afdc34492c8762e1403">&#9670;&nbsp;</a></span>nvnTextureBuilderGetTarget_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE <a class="el" href="group__nvn__c__enum.html#ga7f247010f53480c7dd1f3b2ad638c431">NVNtextureTarget</a> nvnTextureBuilderGetTarget_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the target for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnTextureBuilderGetTarget, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga386847eb4289c7cd7ad45ee0d2b62918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga386847eb4289c7cd7ad45ee0d2b62918">&#9670;&nbsp;</a></span>nvnTextureBuilderGetWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnTextureBuilderGetWidth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the width for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga49dc0ac55c9c351e8e1810cd6e81ed6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49dc0ac55c9c351e8e1810cd6e81ed6b">&#9670;&nbsp;</a></span>nvnTextureBuilderGetWidth_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE int nvnTextureBuilderGetWidth_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the width for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnTextureBuilderGetWidth, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga33852e99c26e6d9ca7cce5faf24b55ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33852e99c26e6d9ca7cce5faf24b55ec">&#9670;&nbsp;</a></span>nvnTextureBuilderGetHeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnTextureBuilderGetHeight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the height for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6036dbed63c82859bd20a416f4d6c3ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6036dbed63c82859bd20a416f4d6c3ed">&#9670;&nbsp;</a></span>nvnTextureBuilderGetHeight_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE int nvnTextureBuilderGetHeight_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the height for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnTextureBuilderGetHeight, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab08075b4fd422c5586f418ec95432ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab08075b4fd422c5586f418ec95432ca8">&#9670;&nbsp;</a></span>nvnTextureBuilderGetDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnTextureBuilderGetDepth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the depth for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga93b3a10d1240766fbc6db48266972377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93b3a10d1240766fbc6db48266972377">&#9670;&nbsp;</a></span>nvnTextureBuilderGetDepth_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE int nvnTextureBuilderGetDepth_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the depth for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnTextureBuilderGetDepth, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga203060aa64e2655e160e502337c80345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga203060aa64e2655e160e502337c80345">&#9670;&nbsp;</a></span>nvnTextureBuilderGetLevels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnTextureBuilderGetLevels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the level count for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga86b5b317daf788fb09f9cf163647ad9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86b5b317daf788fb09f9cf163647ad9a">&#9670;&nbsp;</a></span>nvnTextureBuilderGetLevels_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE int nvnTextureBuilderGetLevels_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the level count for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnTextureBuilderGetLevels, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8882c4fa3c8f9f232bcc966516005a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8882c4fa3c8f9f232bcc966516005a2f">&#9670;&nbsp;</a></span>nvnTextureBuilderGetFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a> nvnTextureBuilderGetFormat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the format for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga66b114c3b0b350cdbd5f363e352f0176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66b114c3b0b350cdbd5f363e352f0176">&#9670;&nbsp;</a></span>nvnTextureBuilderGetFormat_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE <a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a> nvnTextureBuilderGetFormat_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the format for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnTextureBuilderGetFormat, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga838dc1cd980379c39027331f1390169f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga838dc1cd980379c39027331f1390169f">&#9670;&nbsp;</a></span>nvnTextureBuilderGetSamples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnTextureBuilderGetSamples </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the sample count for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaec8ebb1cb056a93518883f7382a9a934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec8ebb1cb056a93518883f7382a9a934">&#9670;&nbsp;</a></span>nvnTextureBuilderGetSamples_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE int nvnTextureBuilderGetSamples_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the sample count for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnTextureBuilderGetSamples, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad00012a5e2ba6e63b8c022fff5d233c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad00012a5e2ba6e63b8c022fff5d233c8">&#9670;&nbsp;</a></span>nvnTextureBuilderGetSwizzle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderGetSwizzle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the swizzles for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">r</td><td>Input component value used for the first (R) output component.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>Input component value used for the second (G) output component.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>Input component value used for the third (B) output component.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a</td><td>Input component value used for the fourth (A) output component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae190535d6c7660700220beee28fabb20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae190535d6c7660700220beee28fabb20">&#9670;&nbsp;</a></span>nvnTextureBuilderGetDepthStencilMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga3fc9be97b8a8e51aacbaf2d93edb9b1c">NVNtextureDepthStencilMode</a> nvnTextureBuilderGetDepthStencilMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the depth/stencil mode for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga44b7411c51def8c3ecc859873003b3bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44b7411c51def8c3ecc859873003b3bb">&#9670;&nbsp;</a></span>nvnTextureBuilderGetDepthStencilMode_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE <a class="el" href="group__nvn__c__enum.html#ga3fc9be97b8a8e51aacbaf2d93edb9b1c">NVNtextureDepthStencilMode</a> nvnTextureBuilderGetDepthStencilMode_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the depth/stencil mode for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnTextureBuilderGetDepthStencilMode, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4c64f715837363c1e2920cae77be92da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c64f715837363c1e2920cae77be92da">&#9670;&nbsp;</a></span>nvnTextureBuilderGetPackagedTextureData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* nvnTextureBuilderGetPackagedTextureData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the packaged texture data pointer for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8d4eab4f6bf7d1b48e53dfa1ee035058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d4eab4f6bf7d1b48e53dfa1ee035058">&#9670;&nbsp;</a></span>nvnTextureBuilderGetPackagedTextureLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnTextureBuilderGetPackagedTextureLayout </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_npackaged_texture_layout.html">NVNpackagedTextureLayout</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the packaged texture layout associated with this <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<p>Returns true if a layout of packaged texture data is associated with this <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a>. In this case the layout is returned in data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Packaged texture layout associated with this <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9939e7f8604b5c1c58eade93a8c6f2df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9939e7f8604b5c1c58eade93a8c6f2df">&#9670;&nbsp;</a></span>nvnTextureBuilderGetStride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t nvnTextureBuilderGetStride </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the stride for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gababa0aba972e4b42112909e0fad93180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gababa0aba972e4b42112909e0fad93180">&#9670;&nbsp;</a></span>nvnTextureBuilderGetStride_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE ptrdiff_t nvnTextureBuilderGetStride_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the stride for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnTextureBuilderGetStride, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gade45e847441bcf19b57835e7b30e3dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade45e847441bcf19b57835e7b30e3dbe">&#9670;&nbsp;</a></span>nvnTextureBuilderGetSparseTileLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderGetSparseTileLayout </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_sparse_tile_layout.html">NVNtextureSparseTileLayout</a> *&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns properties of the sparse memory layout for a texture to be created using the provided <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<p>For correct operation, the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> must have a device set via nvnTextureBuilderSetDevice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to be used to create a new texture.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">layout</td><td>Pointer to a <a class="el" href="struct_n_v_ntexture_sparse_tile_layout.html" title="Data structure used by queries of the memory layout used by sparse textures.">NVNtextureSparseTileLayout</a> structure to receive layout information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaad49dafe49d8e52a12518c8dc492fe71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad49dafe49d8e52a12518c8dc492fe71">&#9670;&nbsp;</a></span>nvnTextureBuilderGetGLTextureName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nvnTextureBuilderGetGLTextureName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of the OpenGL or OpenGL ES texture to use as an external texture source. </p>
<p>If the returned name is zero, no source texture will be used. See SetGLTextureName for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga971d5f87eb203ca015164e8818d6eba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga971d5f87eb203ca015164e8818d6eba2">&#9670;&nbsp;</a></span>nvnTextureBuilderGetGLTextureName_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE uint32_t nvnTextureBuilderGetGLTextureName_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of the OpenGL or OpenGL ES texture to use as an external texture source. </p>
<p>Fastpath variant.</p>
<p>If the returned name is zero, no source texture will be used. See SetGLTextureName for details.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnTextureBuilderGetGLTextureName, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa00aaba8acd99e423733589231ac411a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa00aaba8acd99e423733589231ac411a">&#9670;&nbsp;</a></span>nvnTextureBuilderGetZCullStorageSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnTextureBuilderGetZCullStorageSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the amount of memory (in bytes) required to hold a ZCull save/restore buffer for a depth texture. </p>
<p>The buffer should be aligned to <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a0ed594e80e327869a5f693ae2cdc2835" title="Minimum alignment for ZCull save/restore buffers.">NVN_DEVICE_INFO_ZCULL_SAVE_RESTORE_ALIGNMENT</a> bytes.</p>
<p>If the texture has a format with no depth or stencil components, this function returns zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to be used to create a new texture. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeade4627ca9fc552f5c5b8584a7cd514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeade4627ca9fc552f5c5b8584a7cd514">&#9670;&nbsp;</a></span>nvnTextureBuilderGetMemoryPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a>* nvnTextureBuilderGetMemoryPool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool used by a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga697877b97c34b084c69f95c6e61b4e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga697877b97c34b084c69f95c6e61b4e23">&#9670;&nbsp;</a></span>nvnTextureBuilderGetMemoryPool_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a>* nvnTextureBuilderGetMemoryPool_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool used by a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnTextureBuilderGetMemoryPool, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac22e6e0c78a09ad5348b8e6b3e7c5c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac22e6e0c78a09ad5348b8e6b3e7c5c1a">&#9670;&nbsp;</a></span>nvnTextureBuilderGetMemoryOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t nvnTextureBuilderGetMemoryOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool offset used by a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1b13a9099081922c63ec6a809be3f0a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b13a9099081922c63ec6a809be3f0a8">&#9670;&nbsp;</a></span>nvnTextureBuilderGetMemoryOffset_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE ptrdiff_t nvnTextureBuilderGetMemoryOffset_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool offset used by a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnTextureBuilderGetMemoryOffset, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8254860768a38d3ca91de92b62227769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8254860768a38d3ca91de92b62227769">&#9670;&nbsp;</a></span>nvnTextureBuilderGetRawStorageClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#gada316a0018ae2f7d069329591e5312c3">NVNrawStorageClass</a> nvnTextureBuilderGetRawStorageClass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the raw storage class associated with this <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3c88faa3760e867dc363f64b46ad3487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c88faa3760e867dc363f64b46ad3487">&#9670;&nbsp;</a></span>nvnTextureViewSetDefaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureViewSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> object. </p>
<p>A <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> object programmed with the default state will use all of the properties of the original texture using the texture view object. Only those properties explicitly programmed in the <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> object will affect the view of the original texture.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td><a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae0bf0a7949e2e49f628bbba2358ef86e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0bf0a7949e2e49f628bbba2358ef86e">&#9670;&nbsp;</a></span>nvnTextureViewSetLevels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureViewSetLevels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numLevels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a texture view to select a subset of the mipmap levels in a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. </p>
<p>By default, texture objects registered in the texture pool will use all mipmap levels in the original texture. Selecting levels in the texture view when registering a texture will limit the registered texture to a subset of the levels of the original texture object. Other rendering operations using a texture will default to using the base level (numbered zero) of the original texture. Selecting levels in the texture view in these cases will instead use the baseLevel parameter of the texture view.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td><a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> object to update.</td></tr>
    <tr><td class="paramname">baseLevel</td><td>Specifies the minimum (base) level in a view of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. A base level of zero selects the highest-resolution mipmap level of the texture; larger values select lower-resolution mipmap levels. Must be less than the number of layers in the original texture object. Must be less than 15 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50afb8ed8803991c4da6b6b989c8cf955be" title="Maximum number of levels supported for any texture target.">NVN_DEVICE_INFO_MAX_TEXTURE_LEVELS</a>).</td></tr>
    <tr><td class="paramname">numLevels</td><td>Specifies the number of mipmap levels in a view of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. If non-zero, selects the specified number of mipmap levels. If zero, selects all mipmap levels below baseLevel. The sum of <em>baseLevel</em> and <em>numLevels</em> in the view must be less than or equal to the number of levels in the original texture object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad854d7dac2c34ed9bf7258d5083d12b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad854d7dac2c34ed9bf7258d5083d12b8">&#9670;&nbsp;</a></span>nvnTextureViewSetLayers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureViewSetLayers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numLayers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a texture view to select a subset of the layers in a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. </p>
<p>By default, texture objects registered in the texture pool or used for rendering will use all layers in the original texture. Selecting layers in the texture view will limit the view to a subset of the layers of the original texture object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td><a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> object to update.</td></tr>
    <tr><td class="paramname">minLayer</td><td>Specifies the minimum layer number in a view of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. Must be less than the total number of layers in the texture. Must be less than 2048 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a0937333540ee2d53634d831a2533c485" title="Maximum number of layers supported for any array texture target.">NVN_DEVICE_INFO_MAX_TEXTURE_LAYERS</a>).</td></tr>
    <tr><td class="paramname">numLayers</td><td>Specifies the number of layers to use when accessing this texture. If non-zero, selects the specified number of layers. If zero, selects all layers greater than or equal to minLayer. The sum of <em>minLayer</em> and <em>numLayers</em> in the view must be less than or equal to the number of layers in the original texture object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga33693bbcbc48e8dd365fa40627d8fc93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33693bbcbc48e8dd365fa40627d8fc93">&#9670;&nbsp;</a></span>nvnTextureViewSetFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureViewSetFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a texture view to select an alternate texture format. </p>
<p>Using a format in a texture view allows applications to reinterpret the storage belonging to a texture object with an alternate format. For example, a texture with a format of <a class="el" href="group__nvn__c__enum.html#gga99463f5b9af6151e604b01dfdd5fecaba81514f73c168617e9819e91131e87426" title="Four 8-bit unsigned normalized components.">NVN_FORMAT_RGBA8</a> can be reinterpreted with a format of <a class="el" href="group__nvn__c__enum.html#gga99463f5b9af6151e604b01dfdd5fecabaadce15bed959fd4fbdd5e62ad368f17c" title="Four 8-bit unsigned integer components.">NVN_FORMAT_RGBA8UI</a> to obtain the components of the texture as raw integer values instead of as normalized values in [0,1]. The format selected for the texture view must be compatible with the format of the original texture object. The format specified in a texture view overrides the format specified by nvnTextureBuilderSetFormat.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td><a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> object to update.</td></tr>
    <tr><td class="paramname">format</td><td><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab" title="Identifies how data elements stored in texture or buffer objects are encoded.">NVNformat</a> to use in the texture view. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga034326c7ada555fedcd5ddb4ed1eeef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga034326c7ada555fedcd5ddb4ed1eeef9">&#9670;&nbsp;</a></span>nvnTextureViewSetSwizzle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureViewSetSwizzle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a>&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a texture view to select an alternate component swizzle. </p>
<p>The swizzles specified in a texture view override those specified by nvnTextureBuilderSetSwizzle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td><a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> object to update.</td></tr>
    <tr><td class="paramname">r</td><td>Input component value used for the first (R) output component.</td></tr>
    <tr><td class="paramname">g</td><td>Input component value used for the second (G) output component.</td></tr>
    <tr><td class="paramname">b</td><td>Input component value used for the third (B) output component.</td></tr>
    <tr><td class="paramname">a</td><td>Input component value used for the fourth (A) output component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2f34ef29814d767bb2347759358832db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f34ef29814d767bb2347759358832db">&#9670;&nbsp;</a></span>nvnTextureViewSetDepthStencilMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureViewSetDepthStencilMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga3fc9be97b8a8e51aacbaf2d93edb9b1c">NVNtextureDepthStencilMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a texture view to select an alternate depth/stencil mode. </p>
<p>The swizzles specified in a texture view override those specified by nvnTextureBuilderSetDepthStencilMode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td><a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> object to update.</td></tr>
    <tr><td class="paramname">mode</td><td>Specifies whether to return depth or stencil values from a texture with depth and/or stencil components. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabb89f522ce35d06d0067032ab0e42b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb89f522ce35d06d0067032ab0e42b0f">&#9670;&nbsp;</a></span>nvnTextureViewSetTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureViewSetTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga7f247010f53480c7dd1f3b2ad638c431">NVNtextureTarget</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a texture view to select an alternate texture target. </p>
<p>The swizzles specified in a texture view override those specified by nvnTextureBuilderSetTarget.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td><a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> object to update.</td></tr>
    <tr><td class="paramname">target</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> target to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga367cd40a7a0c3ebfa548291f93bfd4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga367cd40a7a0c3ebfa548291f93bfd4fd">&#9670;&nbsp;</a></span>nvnTextureViewGetLevels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnTextureViewGetLevels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>baseLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>numLevels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the set of levels associated with a <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> object. </p>
<p>Returns NVN_TRUE if a set of levels has been specified in the view. Returns NVN_FALSE if no set of levels has been specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">view</td><td><a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">baseLevel</td><td>Minimum (base) level in a view of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. Zero is returned if no set of levels has been specified.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numLevels</td><td>Number of mipmap levels in a view of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. Zero is returned if no set of levels has been specified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacf9f4f92177b7a7801a6a6d7c829ec00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf9f4f92177b7a7801a6a6d7c829ec00">&#9670;&nbsp;</a></span>nvnTextureViewGetLayers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnTextureViewGetLayers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>minLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>numLayers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the set of layers associated with a <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> object. </p>
<p>Returns NVN_TRUE if a set of layers has been specified in the view. Returns NVN_FALSE if no set of layers has been specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">view</td><td><a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">minLayer</td><td>The minimum layer number in a view of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. Zero is returned if no set of layers has been specified.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numLayers</td><td>The number of layers in a view of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. Zero is returned if no set of layers has been specified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf06b460df83524343f9092f1c50d50ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf06b460df83524343f9092f1c50d50ab">&#9670;&nbsp;</a></span>nvnTextureViewGetFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnTextureViewGetFormat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a> *&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the format associated with a <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> object. </p>
<p>Returns NVN_TRUE if a format has been specified in the view. Returns NVN_FALSE if no format has been specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">view</td><td><a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">format</td><td><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab" title="Identifies how data elements stored in texture or buffer objects are encoded.">NVNformat</a> in the texture view. <a class="el" href="group__nvn__c__enum.html#gga99463f5b9af6151e604b01dfdd5fecaba7c782a722996d27efbfc6f9128f32d73" title="Placeholder enum indicating no defined format; never valid.">NVN_FORMAT_NONE</a> is returned if no format has been specified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3e112fd45346310739045b94eeef908f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e112fd45346310739045b94eeef908f">&#9670;&nbsp;</a></span>nvnTextureViewGetSwizzle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnTextureViewGetSwizzle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the swizzles associated with a <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> object. </p>
<p>Returns NVN_TRUE if swizzles have been specified in the view. Returns NVN_FALSE if no swizzles have been specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">view</td><td><a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">r</td><td>Input component value used for the first (R) output component. <a class="el" href="group__nvn__c__enum.html#gga2655fafafc505f95439b33402186b6beaf9b420bd02d4a13c4c66e97023476d00" title="Output component returned as 0 or 0.0, depending on the texture format.">NVN_TEXTURE_SWIZZLE_ZERO</a> is returned if no swizzles have been specified.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>Input component value used for the second (G) output component. <a class="el" href="group__nvn__c__enum.html#gga2655fafafc505f95439b33402186b6beaf9b420bd02d4a13c4c66e97023476d00" title="Output component returned as 0 or 0.0, depending on the texture format.">NVN_TEXTURE_SWIZZLE_ZERO</a> is returned if no swizzles have been specified.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>Input component value used for the third (B) output component. <a class="el" href="group__nvn__c__enum.html#gga2655fafafc505f95439b33402186b6beaf9b420bd02d4a13c4c66e97023476d00" title="Output component returned as 0 or 0.0, depending on the texture format.">NVN_TEXTURE_SWIZZLE_ZERO</a> is returned if no swizzles have been specified.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a</td><td>Input component value used for the fourth (A) output component. <a class="el" href="group__nvn__c__enum.html#gga2655fafafc505f95439b33402186b6beaf9b420bd02d4a13c4c66e97023476d00" title="Output component returned as 0 or 0.0, depending on the texture format.">NVN_TEXTURE_SWIZZLE_ZERO</a> is returned if no swizzles have been specified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2176ce574e0478a456a9a87022a25532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2176ce574e0478a456a9a87022a25532">&#9670;&nbsp;</a></span>nvnTextureViewGetDepthStencilMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnTextureViewGetDepthStencilMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga3fc9be97b8a8e51aacbaf2d93edb9b1c">NVNtextureDepthStencilMode</a> *&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the depth/stencil mode associated with a <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> object. </p>
<p>Returns NVN_TRUE if a depth/stencil mode has been specified in the view. Returns NVN_FALSE if no depth/stencil mode has been specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">view</td><td><a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mode</td><td>Selector to return depth or stencil values from a texture with depth and/or stencil components. <a class="el" href="group__nvn__c__enum.html#gga3fc9be97b8a8e51aacbaf2d93edb9b1ca8ad2671f2dca9db97b1d62d29df0f7f0" title="Return depth data as floating-point values.">NVN_TEXTURE_DEPTH_STENCIL_MODE_DEPTH</a> is returned if no depth/stencil mode has been specified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5aa74261dd204238deca7932be67bdb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5aa74261dd204238deca7932be67bdb1">&#9670;&nbsp;</a></span>nvnTextureViewGetTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnTextureViewGetTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga7f247010f53480c7dd1f3b2ad638c431">NVNtextureTarget</a> *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the target associated with a <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> object. </p>
<p>Returns NVN_TRUE if a target has been specified in the view. Returns NVN_FALSE if no target has been specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">view</td><td><a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">target</td><td>Target associated with the texture view. <a class="el" href="group__nvn__c__enum.html#gga7f247010f53480c7dd1f3b2ad638c431abd7d830ea240f95cd050f980ec7c59a4" title="One-dimensional texture.">NVN_TEXTURE_TARGET_1D</a> is returned if no target has been specified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab95e7a5cd51184f9578614b4ec442b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab95e7a5cd51184f9578614b4ec442b78">&#9670;&nbsp;</a></span>nvnTextureViewCompare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnTextureViewCompare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>otherView</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> objects are equivalent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>First <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> object.</td></tr>
    <tr><td class="paramname">otherView</td><td><a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">NVNtextureView</a> object to compare against. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad8c5cbaa3292721f1de9d521a66aac3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8c5cbaa3292721f1de9d521a66aac3e">&#9670;&nbsp;</a></span>nvnTextureInitialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnTextureInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a texture object from a texture builder using storage provided by a memory pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to initialize.</td></tr>
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects.">NVNtextureBuilder</a> object holding properties of the new <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga73cb447f019bda7152e2ab27a5a9156d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73cb447f019bda7152e2ab27a5a9156d">&#9670;&nbsp;</a></span>nvnTextureGetZCullStorageSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnTextureGetZCullStorageSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the amount of memory (in bytes) required to hold a ZCull save/restore buffer for a depth texture. </p>
<p>The buffer should be aligned to <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a0ed594e80e327869a5f693ae2cdc2835" title="Minimum alignment for ZCull save/restore buffers.">NVN_DEVICE_INFO_ZCULL_SAVE_RESTORE_ALIGNMENT</a> bytes.</p>
<p>If the texture has a format with no depth or stencil components, this function returns zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa5741253f7ab5c9075a6821a68cfa351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5741253f7ab5c9075a6821a68cfa351">&#9670;&nbsp;</a></span>nvnTextureFinalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureFinalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga38af53eeec445c9775f1b4715c707570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38af53eeec445c9775f1b4715c707570">&#9670;&nbsp;</a></span>nvnTextureSetDebugLabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureSetDebugLabel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debug label string for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. </p>
<p>Annotates a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object with a descriptive text label. This label may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to set debug label.</td></tr>
    <tr><td class="paramname">label</td><td>Text string used to annotate the <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga290d7f9e06d3eb2618b601f83d3bbbb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga290d7f9e06d3eb2618b601f83d3bbbb9">&#9670;&nbsp;</a></span>nvnTextureGetStorageClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga4e21960c2b9244bbd2753954b23580d3">NVNstorageClass</a> nvnTextureGetStorageClass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the storage class needed for virtual memory mappings for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. </p>
<p>When memory from a physical memory pool is mapped into a virtual memory pool, the mapping must be established with a storage class appropriate for texture or buffer resources using the virtual memory. The value returned by this command should be used for memory mappings used by this texture.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4f538a9539abbb991fd0c42089293105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f538a9539abbb991fd0c42089293105">&#9670;&nbsp;</a></span>nvnTextureGetViewOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t nvnTextureGetViewOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>textureView</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the offset (in bytes) of the first byte of storage used by a view of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. </p>
<p>The offset returned is a value relative to the offset of the first byte of storage used by the full texture. Textures are stored in (virtually) contiguous memory. For array and cube map textures, each layer or face is stored in memory as a unit with offsets increasing by layer number. For mipmapped textures, each mipmap level in the texture (or in each layer for array and cube map textures) is stored as a unit with offsets increasing by mipmap level number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to query.</td></tr>
    <tr><td class="paramname">textureView</td><td>View of the texture used to determine an offset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2b2185123abcb5454ce65f662c34e166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b2185123abcb5454ce65f662c34e166">&#9670;&nbsp;</a></span>nvnTextureGetFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga57ab2536473c8e62f621554a2618121b">NVNtextureFlags</a> nvnTextureGetFlags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the flags for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga785889a42583d3e442610a7385ec2f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga785889a42583d3e442610a7385ec2f3f">&#9670;&nbsp;</a></span>nvnTextureGetTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga7f247010f53480c7dd1f3b2ad638c431">NVNtextureTarget</a> nvnTextureGetTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the target for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga529f99644886d9a725ef2bf7b9108a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga529f99644886d9a725ef2bf7b9108a27">&#9670;&nbsp;</a></span>nvnTextureGetWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnTextureGetWidth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the width for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga53c4d11d01059c6d3d875ecf85ede8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53c4d11d01059c6d3d875ecf85ede8a5">&#9670;&nbsp;</a></span>nvnTextureGetHeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnTextureGetHeight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the height for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1949a4d4cb3eaf94f805beae5748209d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1949a4d4cb3eaf94f805beae5748209d">&#9670;&nbsp;</a></span>nvnTextureGetDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnTextureGetDepth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the depth for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab847c77fff2d7ff0597ba6138da6dae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab847c77fff2d7ff0597ba6138da6dae5">&#9670;&nbsp;</a></span>nvnTextureGetLevels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnTextureGetLevels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the level count for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa1d6ee5609a77cbcc3d7af85edf1ea76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1d6ee5609a77cbcc3d7af85edf1ea76">&#9670;&nbsp;</a></span>nvnTextureGetFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a> nvnTextureGetFormat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the format for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga05bc2d539e76dd0f5daaf6faccc8d718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05bc2d539e76dd0f5daaf6faccc8d718">&#9670;&nbsp;</a></span>nvnTextureGetSamples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnTextureGetSamples </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the sample count for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad8a208369ab9e5f3c15794f023893a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8a208369ab9e5f3c15794f023893a5c">&#9670;&nbsp;</a></span>nvnTextureGetSwizzle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureGetSwizzle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the swizzles for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">r</td><td>Input component value used for the first (R) output component.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>Input component value used for the second (G) output component.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>Input component value used for the third (B) output component.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a</td><td>Input component value used for the fourth (A) output component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga745f91a439a4c7ab71f1e58cd2e2246b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga745f91a439a4c7ab71f1e58cd2e2246b">&#9670;&nbsp;</a></span>nvnTextureGetDepthStencilMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga3fc9be97b8a8e51aacbaf2d93edb9b1c">NVNtextureDepthStencilMode</a> nvnTextureGetDepthStencilMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the depth/stencil mode for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4813ee9097b828190f3b6098fb3c3ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4813ee9097b828190f3b6098fb3c3ab0">&#9670;&nbsp;</a></span>nvnTextureGetStride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t nvnTextureGetStride </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the stride for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1830936e33236e3808dbf70c8bd076f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1830936e33236e3808dbf70c8bd076f7">&#9670;&nbsp;</a></span>nvnTextureGetTextureAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__handle.html#ga25907f5565e57af5a1f3f2fef4493887">NVNtextureAddress</a> nvnTextureGetTextureAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the GPU address of the first byte of memory used by a texture. </p>
<dl class="section warning"><dt>Warning</dt><dd>Except for buffer and linear textures, a NVNtextureAddress returned by nvnTextureGetTextureAddress corresponds to a special memory mapping that can not be used to view or manipulate memory in commands accepting a buffer address.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga92054c4c5f509f4be2e4b5536f755344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92054c4c5f509f4be2e4b5536f755344">&#9670;&nbsp;</a></span>nvnTextureGetSparseTileLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureGetSparseTileLayout </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_sparse_tile_layout.html">NVNtextureSparseTileLayout</a> *&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns properties of the sparse memory layout for a texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">layout</td><td>Pointer to a <a class="el" href="struct_n_v_ntexture_sparse_tile_layout.html" title="Data structure used by queries of the memory layout used by sparse textures.">NVNtextureSparseTileLayout</a> structure to receive layout information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0e4a235dac08f14ecbaf8e566df8444e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e4a235dac08f14ecbaf8e566df8444e">&#9670;&nbsp;</a></span>nvnTextureWriteTexels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureWriteTexels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>textureView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy texture data from memory into a region of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. </p>
<p>Copies texture data from the memory pointed to by <em>data</em> to the specified region of a texture, using the CPU. This command behaves like nvnCommandBufferCopyBufferToTexture, except that the copy is performed immediately and does not involve the GPU on NX. On the Windows reference implementation, this copy will use the GPU to update GPU-attached video memory. If the texture is stored in a memory pool created with <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a2fa7e2b859d94d1dc2c7077822b46f83" title="Indicates that the memory pool will be accessed by the CPU with caching.">NVN_MEMORY_POOL_FLAGS_CPU_CACHED_BIT</a>, the caller must use nvnTextureFlushTexels to flush relevant portions of the CPU cache prior to using the updated texture in the GPU.</p>
<dl class="section warning"><dt>Warning</dt><dd>Because the CPU does not have access to GPU compression information needed to properly interpret GPU-compressed textures, it is an error to use this command to operate on a texture with the <a class="el" href="group__nvn__c__enum.html#gga57ab2536473c8e62f621554a2618121ba0d4ba29569c01183e9a92cb3359da7d1" title="The contents of this texture can be compressed by the GPU.">NVN_TEXTURE_FLAGS_COMPRESSIBLE_BIT</a> flag set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to update. This command may not be used to update textures stored in memory pools created with <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654ae90d91fe770d2eb3e1476c404c003369" title="Indicates that the memory pool will not be accessed by the CPU.">NVN_MEMORY_POOL_FLAGS_CPU_NO_ACCESS_BIT</a>.</td></tr>
    <tr><td class="paramname">textureView</td><td>View of the texture object used as the destination for the copy. A texture view, if specified, can be used to override properties of the corresponding texture <em>texture</em>. This parameter identifies a specific mipmap level, set of layers or alternate format in the specified texture. Other fields, such as swizzle, are ignored. If NULL is specified, the base level of the texture <em>texture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">region</td><td>Region of the destination texture to update.</td></tr>
    <tr><td class="paramname">data</td><td>Pointer to source texel data in system memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacaa6b82b65f0aa146a786e5f08e762ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacaa6b82b65f0aa146a786e5f08e762ba">&#9670;&nbsp;</a></span>nvnTextureWriteTexelsStrided()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureWriteTexelsStrided </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>textureView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>rowStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>imageStride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy texture data from memory into a region of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object with user-specified stride. </p>
<p>Copies texture data from the memory pointed to by <em>data</em> to the specified region of a texture, using the CPU. This command behaves like the combination of nvnCommandBufferSetCopyRowStride, nvnCommandBufferSetCopyImageStride, and nvnCommandBufferCopyBufferToTexture, except that no stride state is retained, and the copy is performed immediately and does not involve the GPU on NX. Note this means that <em>rowStride</em> must be at least the number of bytes in a row of the image, and <em>imageStride</em> must be at least the number of bytes in one full image. On the Windows reference implementation, this copy will use the GPU to update GPU-attached video memory. If the texture is stored in a memory pool created with <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a2fa7e2b859d94d1dc2c7077822b46f83" title="Indicates that the memory pool will be accessed by the CPU with caching.">NVN_MEMORY_POOL_FLAGS_CPU_CACHED_BIT</a>, the caller must use nvnTextureFlushTexels to flush relevant portions of the CPU cache prior to using the updated texture in the GPU.</p>
<dl class="section warning"><dt>Warning</dt><dd>Because the CPU does not have access to GPU compression information needed to properly interpret GPU-compressed textures, it is an error to use this command to operate on a texture with the <a class="el" href="group__nvn__c__enum.html#gga57ab2536473c8e62f621554a2618121ba0d4ba29569c01183e9a92cb3359da7d1" title="The contents of this texture can be compressed by the GPU.">NVN_TEXTURE_FLAGS_COMPRESSIBLE_BIT</a> flag set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to update. This command may not be used to update textures stored in memory pools created with <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654ae90d91fe770d2eb3e1476c404c003369" title="Indicates that the memory pool will not be accessed by the CPU.">NVN_MEMORY_POOL_FLAGS_CPU_NO_ACCESS_BIT</a>.</td></tr>
    <tr><td class="paramname">textureView</td><td>View of the texture object used as the destination for the copy. A texture view, if specified, can be used to override properties of the corresponding texture <em>texture</em>. This parameter identifies a specific mipmap level, set of layers or alternate format in the specified texture. Other fields, such as swizzle, are ignored. If NULL is specified, the base level of the texture <em>texture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">region</td><td>Region of the destination texture to update.</td></tr>
    <tr><td class="paramname">data</td><td>Pointer to source texel data in system memory.</td></tr>
    <tr><td class="paramname">rowStride</td><td>Stride (in bytes) between rows of texels in <em>data</em>. If specified as 0, rows of texels in <em>data</em> will be treated as densely packed, where each new row in memory starts immediately after the end of the previous row. For compressed texture formats, <em>rowStride</em> indicates the stride between rows of blocks.</td></tr>
    <tr><td class="paramname">imageStride</td><td>Stride (in bytes) between 2D arrays of texels in <em>data</em>. If specified as 0, 2D arrays of texels (corresponding to 2d texture layers, cube faces, or slices of a 3D texture) will be treated as densely packed, where each 2D array in memory starts immediately after the end of the previous 2D array. If <em>imageStride</em> is 0 and <em>rowStride</em> is non-zero, each 2D array is treated as an array of rows, each consuming <em>rowStride</em> bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0a3763d942005f48eaa467571ff8ad8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a3763d942005f48eaa467571ff8ad8b">&#9670;&nbsp;</a></span>nvnTextureReadTexels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureReadTexels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>textureView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read texture data from a region of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object into memory. </p>
<p>Copies texture data from the specified region of a texture to the memory pointed to by <em>data</em>, using the CPU. This command behaves like nvnCommandBufferCopyTextureToBuffer, except that the copy is performed immediately and does not involve the GPU on NX. On the Windows reference implementation, this copy will use the GPU to read GPU-attached video memory. If the texture is stored in a memory pool created with <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a2fa7e2b859d94d1dc2c7077822b46f83" title="Indicates that the memory pool will be accessed by the CPU with caching.">NVN_MEMORY_POOL_FLAGS_CPU_CACHED_BIT</a> and has been updated using the GPU, the caller must use nvnTextureInvalidateTexels to invalidate relevant portions of the CPU cache prior to using this command to read from the texture.</p>
<dl class="section warning"><dt>Warning</dt><dd>Because the CPU does not have access to GPU compression information needed to properly interpret GPU-compressed textures, it is an error to use this command to operate on a texture with the <a class="el" href="group__nvn__c__enum.html#gga57ab2536473c8e62f621554a2618121ba0d4ba29569c01183e9a92cb3359da7d1" title="The contents of this texture can be compressed by the GPU.">NVN_TEXTURE_FLAGS_COMPRESSIBLE_BIT</a> flag set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to read. This command may not be used to read from textures stored in memory pools created with <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654ae90d91fe770d2eb3e1476c404c003369" title="Indicates that the memory pool will not be accessed by the CPU.">NVN_MEMORY_POOL_FLAGS_CPU_NO_ACCESS_BIT</a>.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">textureView</td><td>View of the texture object used as the source for the copy. A texture view, if specified, can be used to override properties of the corresponding texture <em>texture</em>. This parameter identifies a specific mipmap level, set of layers or alternate format in the specified texture. Other fields, such as swizzle, are ignored. If NULL is specified, the base level of the texture <em>texture</em> will be used as-is.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">region</td><td>Region of the source texture to read.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Pointer to destination texel data in system memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3284bbe008a0f733024a6a041579632e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3284bbe008a0f733024a6a041579632e">&#9670;&nbsp;</a></span>nvnTextureReadTexelsStrided()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureReadTexelsStrided </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>textureView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>rowStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>imageStride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read texture data from a region of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object into memory. </p>
<p>Copies texture data from the specified region of a texture to the memory pointed to by <em>data</em>, using the CPU. This command behaves like the combination of nvnCommandBufferSetCopyRowStride, nvnCommandBufferSetCopyImageStride, and nvnCommandBufferCopyTextureToBuffer, except that no stride state is retained, and the copy is performed immediately and does not involve the GPU on NX. Note this means that <em>rowStride</em> must be at least the number of bytes in a row of the image, and <em>imageStride</em> must be at least the number of bytes in one full image. On the Windows reference implementation, this copy will use the GPU to read GPU-attached video memory. If the texture is stored in a memory pool created with <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a2fa7e2b859d94d1dc2c7077822b46f83" title="Indicates that the memory pool will be accessed by the CPU with caching.">NVN_MEMORY_POOL_FLAGS_CPU_CACHED_BIT</a> and has been updated using the GPU, the caller must use nvnTextureInvalidateTexels to invalidate relevant portions of the CPU cache prior to using this command to read from the texture.</p>
<dl class="section warning"><dt>Warning</dt><dd>Because the CPU does not have access to GPU compression information needed to properly interpret GPU-compressed textures, it is an error to use this command to operate on a texture with the <a class="el" href="group__nvn__c__enum.html#gga57ab2536473c8e62f621554a2618121ba0d4ba29569c01183e9a92cb3359da7d1" title="The contents of this texture can be compressed by the GPU.">NVN_TEXTURE_FLAGS_COMPRESSIBLE_BIT</a> flag set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to read. This command may not be used to read from textures stored in memory pools created with <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654ae90d91fe770d2eb3e1476c404c003369" title="Indicates that the memory pool will not be accessed by the CPU.">NVN_MEMORY_POOL_FLAGS_CPU_NO_ACCESS_BIT</a>.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">textureView</td><td>View of the texture object used as the source for the copy. A texture view, if specified, can be used to override properties of the corresponding texture <em>texture</em>. This parameter identifies a specific mipmap level, set of layers or alternate format in the specified texture. Other fields, such as swizzle, are ignored. If NULL is specified, the base level of the texture <em>texture</em> will be used as-is.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">region</td><td>Region of the source texture to read.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Pointer to destination texel data in system memory.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rowStride</td><td>Stride (in bytes) between rows of texels in <em>data</em>. If specified as 0, rows of texels in <em>data</em> will be treated as densely packed, where each new row in memory starts immediately after the end of the previous row. For compressed texture formats, <em>rowStride</em> indicates the stride between rows of blocks.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">imageStride</td><td>Stride (in bytes) between 2D arrays of texels in <em>data</em>. If specified as 0, 2D arrays of texels (corresponding to 2d texture layers, cube faces, or slices of a 3D texture) will be treated as densely packed, where each 2D array in memory starts immediately after the end of the previous 2D array. If <em>imageStride</em> is 0 and <em>rowStride</em> is non-zero, each 2D array is treated as an array of rows, each consuming <em>rowStride</em> bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga955c791dfe86ae65b7e87903575c0cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga955c791dfe86ae65b7e87903575c0cfa">&#9670;&nbsp;</a></span>nvnTextureFlushTexels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureFlushTexels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>textureView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush CPU cache lines holding portions of a texture. </p>
<p>When a texture object is stored in a memory pool created using <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a2fa7e2b859d94d1dc2c7077822b46f83" title="Indicates that the memory pool will be accessed by the CPU with caching.">NVN_MEMORY_POOL_FLAGS_CPU_CACHED_BIT</a>, texel updates using nvnTextureWriteTexels will use the CPU cache and may not be immediately visible to the GPU. Before using the contents of such textures on the GPU, this command should be used to flush relevant portions of the CPU cache to ensure that updated texels are written to main memory and will be visible to the GPU. This operation is not needed for textures stored in memory pools created using <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a93f5342f52f301cfdca9901586b9b8e1" title="Indicates that the memory pool will be accessed by the CPU without caching.">NVN_MEMORY_POOL_FLAGS_CPU_UNCACHED_BIT</a>. The flush is performed with 64-byte granularity, matching the size of a CPU cache line. The GPU cache line size is 128 bytes, so there may be interactions with nearby memory ranges that share a cache line with the flushed range. If two non-coherent memory ranges are separately managed by the CPU and the GPU, it is recommended that they be allocated from distinct 128-byte aligned ranges. See <a class="el" href="nvn_index.html#nvn_guide_memory_pool_coherency">3.2. CPU Access and Coherency</a> in the NVN Programming Guide for details and recommendations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object used for the flush operation.</td></tr>
    <tr><td class="paramname">textureView</td><td>View of the texture object used for the flush operation. A texture view, if specified, can be used to specify the layer set of the corresponding texture <em>texture</em>. If NULL is specified, the base level of the texture <em>texture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">region</td><td>Region of the texture used by the flush operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaec4e878f1036375ad23ff57ceafe53f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec4e878f1036375ad23ff57ceafe53f2">&#9670;&nbsp;</a></span>nvnTextureInvalidateTexels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureInvalidateTexels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>textureView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidate CPU cache lines holding portions of a texture. </p>
<p>When a texture object is stored in a memory pool created using <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a2fa7e2b859d94d1dc2c7077822b46f83" title="Indicates that the memory pool will be accessed by the CPU with caching.">NVN_MEMORY_POOL_FLAGS_CPU_CACHED_BIT</a>, texels accessed by the CPU may be stored in CPU caches. If texel values are updated using the GPU, subsequent accesses using nvnTextureReadTexels may read old texel values if any of the old data remains in the CPU cache. Before reading GPU-modified textures using nvnTextureReadTexels, this command should be used to invalidate relevant portions of the CPU cache to ensure that stale texel values do not remain in the CPU caches. This operation is not needed for textures stored in memory pools created using <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a93f5342f52f301cfdca9901586b9b8e1" title="Indicates that the memory pool will be accessed by the CPU without caching.">NVN_MEMORY_POOL_FLAGS_CPU_UNCACHED_BIT</a>. The invalidate is performed with 64-byte granularity, matching the size of a CPU cache line. The GPU cache line size is 128 bytes, so there may be interactions with nearby memory ranges that share a cache line with the flushed range. If two non-coherent memory ranges are separately managed by the CPU and the GPU, it is recommended that they be allocated from distinct 128-byte aligned ranges. See <a class="el" href="nvn_index.html#nvn_guide_memory_pool_coherency">3.2. CPU Access and Coherency</a> in the NVN Programming Guide for details and recommendations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object used for the invalidate operation.</td></tr>
    <tr><td class="paramname">textureView</td><td>View of the texture object used for the invalidate operation. A texture view, if specified, can be used to specify the layer set of the corresponding texture <em>texture</em>. If NULL is specified, the base level of the texture <em>texture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">region</td><td>Region of the texture used for the invalidate operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga15b7941491a88ad4abf82bdc145216f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15b7941491a88ad4abf82bdc145216f7">&#9670;&nbsp;</a></span>nvnTextureGetMemoryPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a>* nvnTextureGetMemoryPool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool used by a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaec925c37d4094927b8e9fc1d9808545a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec925c37d4094927b8e9fc1d9808545a">&#9670;&nbsp;</a></span>nvnTextureGetMemoryOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t nvnTextureGetMemoryOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool offset used by a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga74382bb40eec4fcbd761e8c76e0bbd3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74382bb40eec4fcbd761e8c76e0bbd3f">&#9670;&nbsp;</a></span>nvnTextureGetStorageSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnTextureGetStorageSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the storage size for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga236976f3597cb6595dc0703c6a8e7dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga236976f3597cb6595dc0703c6a8e7dae">&#9670;&nbsp;</a></span>nvnTextureCompare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnTextureCompare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>otherTexture</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if texture objects are equivalent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>First texture object.</td></tr>
    <tr><td class="paramname">otherTexture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to compare against. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga89c5c4383243a7679a4d4d9977ffc365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89c5c4383243a7679a4d4d9977ffc365">&#9670;&nbsp;</a></span>nvnTextureGetDebugID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t nvnTextureGetDebugID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the debug layer unique ID of this texture. </p>
<p>Returns 0 if debug layer disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab234267003a4032b21f68fbbb23c1c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab234267003a4032b21f68fbbb23c1c9a">&#9670;&nbsp;</a></span>nvnTextureGetRawStorageClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#gada316a0018ae2f7d069329591e5312c3">NVNrawStorageClass</a> nvnTextureGetRawStorageClass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the raw storage class associated with this <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7504233cce44b1f5a7223f322b76a84d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7504233cce44b1f5a7223f322b76a84d">&#9670;&nbsp;</a></span>nvnSamplerBuilderSetDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderSetDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> associated with a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> owning <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects created by the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga889b306858059648c66e88a226391acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga889b306858059648c66e88a226391acc">&#9670;&nbsp;</a></span>nvnSamplerBuilderSetDefaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object. </p>
<p>This method does not modify the device associated with the builder, which is programmed by SetDevice.</p>
<dl class="section note"><dt>Note</dt><dd>This is semantically equivalent to calling</dd></dl>
<div class="fragment"><div class="line">SamplerBuilder::SetMinMagFilter(NVN_MIN_FILTER_LINEAR, NVN_MAG_FILTER_LINEAR);</div>
<div class="line">SamplerBuilder::SetWrapMode(NVN_WRAP_MODE_REPEAT, NVN_WRAP_MODE_REPEAT,</div>
<div class="line">                            NVN_WRAP_MODE_REPEAT);</div>
<div class="line">SamplerBuilder::SetLodClamp(0.0, 1000.0);</div>
<div class="line">SamplerBuilder::SetLodBias(0.0);</div>
<div class="line">SamplerBuilder::SetCompare(NVN_COMPARE_MODE_NONE, NVN_COMPARE_FUNC_LESS);</div>
<div class="line">SamplerBuilder::SetBorderColor({ 0.0, 0.0, 0.0, 0.0 });</div>
<div class="line">SamplerBuilder::SetMaxAnisotropy(1.0);</div>
<div class="line">SamplerBuilder::SetReductionFilter(NVN_SAMPLER_REDUCTION_AVERAGE);</div>
<div class="line">SamplerBuilder::SetLodSnap(0.0);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0f634bd122e2b47cbebfeb16cda8352f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f634bd122e2b47cbebfeb16cda8352f">&#9670;&nbsp;</a></span>nvnSamplerBuilderSetMinMagFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderSetMinMagFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga41610125d2ee1e59db15c26f9a1288c5">NVNminFilter</a>&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga7f4e9b2ce71bbd9c4c2de6b3cfc293dc">NVNmagFilter</a>&#160;</td>
          <td class="paramname"><em>mag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the minification and magnification filters for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">min</td><td>Specifies the minification filter.</td></tr>
    <tr><td class="paramname">mag</td><td>Specifies the magnification filter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga63aec39a3ab8401a6e287d2024c74e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63aec39a3ab8401a6e287d2024c74e2f">&#9670;&nbsp;</a></span>nvnSamplerBuilderSetWrapMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderSetWrapMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a>&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the coordinate wrap modes for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">s</td><td>Specifies the wrap mode for the first (S) texture coordinate.</td></tr>
    <tr><td class="paramname">t</td><td>Specifies the wrap mode for the second (T) texture coordinate.</td></tr>
    <tr><td class="paramname">r</td><td>Specifies the wrap mode for the third (R) texture coordinate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacd10e1f2dc492fdf600365ef94945170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd10e1f2dc492fdf600365ef94945170">&#9670;&nbsp;</a></span>nvnSamplerBuilderSetLodClamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderSetLodClamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the minimum and maximum level of detail used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>. </p>
<p>When a sampler builder is used to initialize a sampler object, <em>min</em> will be clamped to [0.0, 15.0], and <em>max</em> will be clamped to [max(0.0, <em>min</em>), 15.0].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">min</td><td>Specifies the minimum level of detail used with the sampler. <ul>
<li>Must be less than or equal to max.</li>
</ul>
</td></tr>
    <tr><td class="paramname">max</td><td>Specifies the maximum level of detail used with the sampler. <ul>
<li>Must be greater than or equal to min. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf28b83743a551b29d219963cb4e9ab5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf28b83743a551b29d219963cb4e9ab5c">&#9670;&nbsp;</a></span>nvnSamplerBuilderSetLodClamp_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnSamplerBuilderSetLodClamp_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the minimum and maximum level of detail used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>. </p>
<p>Fastpath variant.</p>
<p>When a sampler builder is used to initialize a sampler object, <em>min</em> will be clamped to [0.0, 15.0], and <em>max</em> will be clamped to [max(0.0, <em>min</em>), 15.0].</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnSamplerBuilderSetLodClamp, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">min</td><td>Specifies the minimum level of detail used with the sampler. <ul>
<li>Must be less than or equal to max.</li>
</ul>
</td></tr>
    <tr><td class="paramname">max</td><td>Specifies the maximum level of detail used with the sampler. <ul>
<li>Must be greater than or equal to min. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga21c8ec90c03a9ba5c53824bfb9c1eee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21c8ec90c03a9ba5c53824bfb9c1eee6">&#9670;&nbsp;</a></span>nvnSamplerBuilderSetLodBias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderSetLodBias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bias</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the level-of-detail bias used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>. </p>
<p>When a sampler builder is used to initialize a sampler object, <em>bias</em> will be clamped to [-16.0, 15.996].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">bias</td><td>Specifies the bias to add to the computed level of detail when the sampler is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0e64b4783943bf22e8adbb6e984c00d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e64b4783943bf22e8adbb6e984c00d6">&#9670;&nbsp;</a></span>nvnSamplerBuilderSetLodBias_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnSamplerBuilderSetLodBias_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bias</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the level-of-detail bias used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>. </p>
<p>Fastpath variant.</p>
<p>When a sampler builder is used to initialize a sampler object, <em>bias</em> will be clamped to [-16.0, 15.996].</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnSamplerBuilderSetLodBias, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">bias</td><td>Specifies the bias to add to the computed level of detail when the sampler is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga61212f6d7e261272b3f3d8a2bedb7fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61212f6d7e261272b3f3d8a2bedb7fd4">&#9670;&nbsp;</a></span>nvnSamplerBuilderSetCompare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderSetCompare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaa5f726f373cd522aa586a0b26a34fb3d">NVNcompareMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga83d020997abcffbd763d2ca9e7b1aff6">NVNcompareFunc</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the depth comparison mode used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>. </p>
<p>When used with textures without depth components, the depth comparison mode is ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">mode</td><td>Specifies whether depth comparisons are performed when using the sampler.</td></tr>
    <tr><td class="paramname">func</td><td>If depth comparisons are enabled, specifies the comparison function used with the sampler. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga58d007814dbbe79756a873c62077f8f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58d007814dbbe79756a873c62077f8f0">&#9670;&nbsp;</a></span>nvnSamplerBuilderSetBorderColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderSetBorderColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>borderColor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set floating-point border color values used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">borderColor</td><td>Specifies four floating-point components (R,G,B,A) for the border color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae65d26314f7fcc219ac81cd331037cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae65d26314f7fcc219ac81cd331037cee">&#9670;&nbsp;</a></span>nvnSamplerBuilderSetBorderColori()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderSetBorderColori </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>borderColor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set signed integer border color values used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">borderColor</td><td>Specifies four signed integer components (R,G,B,A) for the border color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga620e4e3a9f487eaaab3b1ff4e7854bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga620e4e3a9f487eaaab3b1ff4e7854bde">&#9670;&nbsp;</a></span>nvnSamplerBuilderSetBorderColorui()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderSetBorderColorui </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>borderColor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set unsigned integer border color values used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">borderColor</td><td>Specifies four unsigned integer components (R,G,B,A) for the border color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga211345dfd517cb8458313d2bd00df0a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga211345dfd517cb8458313d2bd00df0a9">&#9670;&nbsp;</a></span>nvnSamplerBuilderSetMaxAnisotropy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderSetMaxAnisotropy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxAniso</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum level of anisotropy used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">maxAniso</td><td>Specifies the maximum level of anisotropy used with the sampler. Must be greater than zero. Must be less than or equal to 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50aeac483b004f722e9e092a4c20e695181" title="Maximum sampler anisotropy.">NVN_DEVICE_INFO_MAX_TEXTURE_ANISOTROPY</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac952c1e10cb272d836bab7a4ba83c6d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac952c1e10cb272d836bab7a4ba83c6d4">&#9670;&nbsp;</a></span>nvnSamplerBuilderSetMaxAnisotropy_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnSamplerBuilderSetMaxAnisotropy_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxAniso</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum level of anisotropy used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnSamplerBuilderSetMaxAnisotropy, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">maxAniso</td><td>Specifies the maximum level of anisotropy used with the sampler. Must be greater than zero. Must be less than or equal to 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50aeac483b004f722e9e092a4c20e695181" title="Maximum sampler anisotropy.">NVN_DEVICE_INFO_MAX_TEXTURE_ANISOTROPY</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3c077843893df456f4abff6862b4d467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c077843893df456f4abff6862b4d467">&#9670;&nbsp;</a></span>nvnSamplerBuilderSetReductionFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderSetReductionFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga867b21c764db6c0573e9fc68e1b83437">NVNsamplerReduction</a>&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the reduction filter used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">filter</td><td>Specifies the reduction filter used for the sampler. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7165b9753b8ce20db7f8658c918fb686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7165b9753b8ce20db7f8658c918fb686">&#9670;&nbsp;</a></span>nvnSamplerBuilderSetLodSnap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderSetLodSnap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lodSnap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set LOD snap used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>. </p>
<p>The texture LOD snap feature is an optimization that reduces texture bandwidth consumption with minification filters that average samples in multiple texture LODs. When performing texture lookups, hardware will round (snap) the computed texture LOD to the nearest integer if the difference between the computed LOD and the integer value is less than the snap value in the sampler. LOD values that are not snapped are adjusted so that the function adjusting the LOD value is continuous. When snapping occurs, hardware will save bandwidth by sampling from only one mipmap level instead of two.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">lodSnap</td><td>Specifies the LOD snap used for the sampler. Specifies the LOD snap used for the sampler. Valid values are in the range [0.0, 0.5], where 0.0 will result in no snapping and 0.5 would round most computed LODs to integer values. Not all values are supported by the hardware; the driver will select a supported snap value close to the value provided in the sampler. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga09c6860a4029a428c4a4161c9bed7d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09c6860a4029a428c4a4161c9bed7d1b">&#9670;&nbsp;</a></span>nvnSamplerBuilderSetLodSnap_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnSamplerBuilderSetLodSnap_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lodSnap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set LOD snap used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>. </p>
<p>Fastpath variant.</p>
<p>The texture LOD snap feature is an optimization that reduces texture bandwidth consumption with minification filters that average samples in multiple texture LODs. When performing texture lookups, hardware will round (snap) the computed texture LOD to the nearest integer if the difference between the computed LOD and the integer value is less than the snap value in the sampler. LOD values that are not snapped are adjusted so that the function adjusting the LOD value is continuous. When snapping occurs, hardware will save bandwidth by sampling from only one mipmap level instead of two.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnSamplerBuilderSetLodSnap, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">lodSnap</td><td>Specifies the LOD snap used for the sampler. Specifies the LOD snap used for the sampler. Valid values are in the range [0.0, 0.5], where 0.0 will result in no snapping and 0.5 would round most computed LODs to integer values. Not all values are supported by the hardware; the driver will select a supported snap value close to the value provided in the sampler. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8362d8f866fe4e0f19bf075d801f7220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8362d8f866fe4e0f19bf075d801f7220">&#9670;&nbsp;</a></span>nvnSamplerBuilderGetDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a>* nvnSamplerBuilderGetDevice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the device associated with this <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae3d7dbc5d106bd2e6a4f62f868795a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3d7dbc5d106bd2e6a4f62f868795a9b">&#9670;&nbsp;</a></span>nvnSamplerBuilderGetDevice_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a>* nvnSamplerBuilderGetDevice_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the device associated with this <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnSamplerBuilderGetDevice, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab3a7a2b46cc8ada75360ac6b0bd73257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3a7a2b46cc8ada75360ac6b0bd73257">&#9670;&nbsp;</a></span>nvnSamplerBuilderGetMinMagFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderGetMinMagFilter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga41610125d2ee1e59db15c26f9a1288c5">NVNminFilter</a> *&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga7f4e9b2ce71bbd9c4c2de6b3cfc293dc">NVNmagFilter</a> *&#160;</td>
          <td class="paramname"><em>mag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the minification and magnification filters for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">min</td><td>Minification filter for the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mag</td><td>Magnification filter for the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga86f90d77048555a8d81b586536752299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86f90d77048555a8d81b586536752299">&#9670;&nbsp;</a></span>nvnSamplerBuilderGetWrapMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderGetWrapMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a> *&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the coordinate wrap modes for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Wrap mode for the first (S) texture coordinate.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">t</td><td>Wrap mode for the second (T) texture coordinate.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">r</td><td>Wrap mode for the third (R) texture coordinate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabe25c536260b86ccfde63a91d187c6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe25c536260b86ccfde63a91d187c6c9">&#9670;&nbsp;</a></span>nvnSamplerBuilderGetLodClamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderGetLodClamp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the minimum and maximum level of detail in a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">min</td><td>Minimum level of detail used with the sampler.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max</td><td>Maximum level of detail used with the sampler. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae616d8490657704e4afae4dce930f03f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae616d8490657704e4afae4dce930f03f">&#9670;&nbsp;</a></span>nvnSamplerBuilderGetLodBias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nvnSamplerBuilderGetLodBias </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the level-of-detail bias for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga64f1a26f240d1f2f13b413d7983c3b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64f1a26f240d1f2f13b413d7983c3b3b">&#9670;&nbsp;</a></span>nvnSamplerBuilderGetLodBias_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE float nvnSamplerBuilderGetLodBias_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the level-of-detail bias for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnSamplerBuilderGetLodBias, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga759f6c95513d59fe4239f85eeac0a534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga759f6c95513d59fe4239f85eeac0a534">&#9670;&nbsp;</a></span>nvnSamplerBuilderGetCompare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderGetCompare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaa5f726f373cd522aa586a0b26a34fb3d">NVNcompareMode</a> *&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga83d020997abcffbd763d2ca9e7b1aff6">NVNcompareFunc</a> *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the depth comparison modes for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mode</td><td>Enable for depth comparisons in the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">func</td><td>Comparison function in the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga83e8344bbc081cb9ba7464b5e3436c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83e8344bbc081cb9ba7464b5e3436c47">&#9670;&nbsp;</a></span>nvnSamplerBuilderGetBorderColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderGetBorderColor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>borderColor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query floating-point border color values for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">borderColor</td><td>Four floating-point components (R,G,B,A) for the border color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7fd5ad1183b027c260ec36d73c6ee3bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fd5ad1183b027c260ec36d73c6ee3bf">&#9670;&nbsp;</a></span>nvnSamplerBuilderGetBorderColori()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderGetBorderColori </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>borderColor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query signed integer border color values for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">borderColor</td><td>Four signed integer components (R,G,B,A) for the border color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8354e069c30e1e18a0581471daf66409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8354e069c30e1e18a0581471daf66409">&#9670;&nbsp;</a></span>nvnSamplerBuilderGetBorderColorui()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderGetBorderColorui </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>borderColor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query unsigned integer border color values for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">borderColor</td><td>Four unsigned integer components (R,G,B,A) for the border color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1ee3fc56d9b39c67402c04802437976f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ee3fc56d9b39c67402c04802437976f">&#9670;&nbsp;</a></span>nvnSamplerBuilderGetMaxAnisotropy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nvnSamplerBuilderGetMaxAnisotropy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the maximum level of anisotropy for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga238bf64d12308d70de98aa8d9568a514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga238bf64d12308d70de98aa8d9568a514">&#9670;&nbsp;</a></span>nvnSamplerBuilderGetMaxAnisotropy_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE float nvnSamplerBuilderGetMaxAnisotropy_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the maximum level of anisotropy for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnSamplerBuilderGetMaxAnisotropy, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabefac5ca39cb0fb81d4fc8b53a031515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabefac5ca39cb0fb81d4fc8b53a031515">&#9670;&nbsp;</a></span>nvnSamplerBuilderGetReductionFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga867b21c764db6c0573e9fc68e1b83437">NVNsamplerReduction</a> nvnSamplerBuilderGetReductionFilter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the reduction filter for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4da85e68ee693bfffd871cace32923c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4da85e68ee693bfffd871cace32923c0">&#9670;&nbsp;</a></span>nvnSamplerBuilderGetLodSnap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nvnSamplerBuilderGetLodSnap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the LOD snap for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga857ebc705d76d61d16ba09428772944c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga857ebc705d76d61d16ba09428772944c">&#9670;&nbsp;</a></span>nvnSamplerBuilderGetLodSnap_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE float nvnSamplerBuilderGetLodSnap_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the LOD snap for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnSamplerBuilderGetLodSnap, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5f3728966dc1ce72231c88bd3bca94ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f3728966dc1ce72231c88bd3bca94ad">&#9670;&nbsp;</a></span>nvnSamplerInitialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnSamplerInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object using the specified <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object to initialize.</td></tr>
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects.">NVNsamplerBuilder</a> object specifying the state of the new sampler object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga82945a36dea04505dcd29e03442ed5a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82945a36dea04505dcd29e03442ed5a6">&#9670;&nbsp;</a></span>nvnSamplerFinalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerFinalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object to finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf992a842dafe3db3a3d68c36a7f89b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf992a842dafe3db3a3d68c36a7f89b1a">&#9670;&nbsp;</a></span>nvnSamplerSetDebugLabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerSetDebugLabel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debug label string for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object. </p>
<p>Annotates a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object with a descriptive text label. This label may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object to set debug label.</td></tr>
    <tr><td class="paramname">label</td><td>Text string used to annotate the <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2bacdf25415f1169fff22060eae02d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bacdf25415f1169fff22060eae02d85">&#9670;&nbsp;</a></span>nvnSamplerGetMinMagFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerGetMinMagFilter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga41610125d2ee1e59db15c26f9a1288c5">NVNminFilter</a> *&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga7f4e9b2ce71bbd9c4c2de6b3cfc293dc">NVNmagFilter</a> *&#160;</td>
          <td class="paramname"><em>mag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the minification and magnification filters for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">min</td><td>Minification filter for the <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a>.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mag</td><td>Magnification filter for the <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae2f6cd6c8e394fb4357615ae4d6e6590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2f6cd6c8e394fb4357615ae4d6e6590">&#9670;&nbsp;</a></span>nvnSamplerGetWrapMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerGetWrapMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a> *&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the coordinate wrap modes for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Wrap mode for the first (S) texture coordinate.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">t</td><td>Wrap mode for the second (T) texture coordinate.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">r</td><td>Wrap mode for the third (R) texture coordinate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae3ffb490c3ac760043e8fd7539344341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3ffb490c3ac760043e8fd7539344341">&#9670;&nbsp;</a></span>nvnSamplerGetLodClamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerGetLodClamp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the minimum and maximum level of detail in a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">min</td><td>Minimum level of detail used with the sampler.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max</td><td>Maximum level of detail used with the sampler. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga94a996072e4bfcf92d86b6866a28d511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94a996072e4bfcf92d86b6866a28d511">&#9670;&nbsp;</a></span>nvnSamplerGetLodBias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nvnSamplerGetLodBias </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the level-of-detail bias for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf974179c68b5aeebac1e821b757235da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf974179c68b5aeebac1e821b757235da">&#9670;&nbsp;</a></span>nvnSamplerGetCompare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerGetCompare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaa5f726f373cd522aa586a0b26a34fb3d">NVNcompareMode</a> *&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga83d020997abcffbd763d2ca9e7b1aff6">NVNcompareFunc</a> *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the depth comparison modes for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mode</td><td>Enable for depth comparisons in the <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a>.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">func</td><td>Comparison function in the <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga05bf524362b220a01368041d936a5473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05bf524362b220a01368041d936a5473">&#9670;&nbsp;</a></span>nvnSamplerGetBorderColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerGetBorderColor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>borderColor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query floating-point border color values for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">borderColor</td><td>Four floating-point components (R,G,B,A) for the border color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga42f49191e28dd92309cd80f79c71d325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42f49191e28dd92309cd80f79c71d325">&#9670;&nbsp;</a></span>nvnSamplerGetBorderColori()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerGetBorderColori </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>borderColor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query signed integer border color values for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">borderColor</td><td>Four signed integer components (R,G,B,A) for the border color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga09cffaeae4405d2a9b3b8b2054002c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09cffaeae4405d2a9b3b8b2054002c29">&#9670;&nbsp;</a></span>nvnSamplerGetBorderColorui()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerGetBorderColorui </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>borderColor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query unsigned integer border color values for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">borderColor</td><td>Four unsigned integer components (R,G,B,A) for the border color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga25e6287ab1146df61fe42a501d93abaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25e6287ab1146df61fe42a501d93abaf">&#9670;&nbsp;</a></span>nvnSamplerGetMaxAnisotropy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nvnSamplerGetMaxAnisotropy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the maximum level of anisotropy for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga476d91292dcfa379c72a31f17bb1e1bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga476d91292dcfa379c72a31f17bb1e1bd">&#9670;&nbsp;</a></span>nvnSamplerGetReductionFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga867b21c764db6c0573e9fc68e1b83437">NVNsamplerReduction</a> nvnSamplerGetReductionFilter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the reduction filter for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga530d7f40e1ddc78fcb447d1950f2b471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga530d7f40e1ddc78fcb447d1950f2b471">&#9670;&nbsp;</a></span>nvnSamplerCompare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnSamplerCompare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>otherSampler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if sampler objects are equivalent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampler</td><td>First sampler object.</td></tr>
    <tr><td class="paramname">otherSampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object to compare against. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7bedba0ca7bda287c734f16e1124d303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bedba0ca7bda287c734f16e1124d303">&#9670;&nbsp;</a></span>nvnSamplerGetDebugID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t nvnSamplerGetDebugID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the debug layer unique ID of this sampler. </p>
<p>Returns 0 if debug layer disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad0c043334f5f7eb94883fc0465f18e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0c043334f5f7eb94883fc0465f18e4f">&#9670;&nbsp;</a></span>nvnBlendStateSetDefaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBlendStateSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object. </p>
<dl class="section note"><dt>Note</dt><dd>This is semantically equivalent to calling</dd></dl>
<div class="fragment"><div class="line">BlendState::SetBlendTarget(0);</div>
<div class="line">BlendState::SetBlendFunc(NVN_BLEND_FUNC_ONE, NVN_BLEND_FUNC_ZERO,</div>
<div class="line">                         NVN_BLEND_FUNC_ONE, NVN_BLEND_FUNC_ZERO);</div>
<div class="line">BlendState::SetBlendEquation(NVN_BLEND_EQUATION_ADD,</div>
<div class="line">                             NVN_BLEND_EQUATION_ADD);</div>
<div class="line">BlendState::SetAdvancedMode(NVN_BLEND_ADVANCED_MODE_NONE);</div>
<div class="line">BlendState::SetAdvancedOverlap(NVN_BLEND_ADVANCED_OVERLAP_UNCORRELATED);</div>
<div class="line">BlendState::SetAdvancedPremultipliedSrc(<a class="code" href="group__nvn__c__defines.html#ga48151b7e768a13685d77d1a4c464a33b">NVN_TRUE</a>);</div>
<div class="line">BlendState::SetAdvancedNormalizedDst(<a class="code" href="group__nvn__c__defines.html#ga48151b7e768a13685d77d1a4c464a33b">NVN_TRUE</a>);</div>
<div class="ttc" id="agroup__nvn__c__defines_html_ga48151b7e768a13685d77d1a4c464a33b"><div class="ttname"><a href="group__nvn__c__defines.html#ga48151b7e768a13685d77d1a4c464a33b">NVN_TRUE</a></div><div class="ttdeci">#define NVN_TRUE</div><div class="ttdoc">Boolean condition with a value of true.</div><div class="ttdef"><b>Definition:</b> nvn.h:4566</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafe4427881d956cf1db9fc536bb9586ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe4427881d956cf1db9fc536bb9586ce">&#9670;&nbsp;</a></span>nvnBlendStateSetBlendTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBlendStateSetBlendTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the number of the color target to update via the <a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object to update.</td></tr>
    <tr><td class="paramname">target</td><td>Color target number to update when binding the blend state object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf0da5237e8887948680f1c401cab2011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0da5237e8887948680f1c401cab2011">&#9670;&nbsp;</a></span>nvnBlendStateSetBlendTarget_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnBlendStateSetBlendTarget_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the number of the color target to update via the <a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnBlendStateSetBlendTarget, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object to update.</td></tr>
    <tr><td class="paramname">target</td><td>Color target number to update when binding the blend state object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8f1f669fc90892348eb5763a6d173c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f1f669fc90892348eb5763a6d173c60">&#9670;&nbsp;</a></span>nvnBlendStateSetBlendFunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBlendStateSetBlendFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a>&#160;</td>
          <td class="paramname"><em>srcFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a>&#160;</td>
          <td class="paramname"><em>dstFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a>&#160;</td>
          <td class="paramname"><em>srcFuncAlpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a>&#160;</td>
          <td class="paramname"><em>dstFuncAlpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify blend functions for source and destination color and alpha channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object to update.</td></tr>
    <tr><td class="paramname">srcFunc</td><td>Blend factor used for source RGB color components.</td></tr>
    <tr><td class="paramname">dstFunc</td><td>Blend factor used for destination RGB color components.</td></tr>
    <tr><td class="paramname">srcFuncAlpha</td><td>Blend factor used for source alpha color components.</td></tr>
    <tr><td class="paramname">dstFuncAlpha</td><td>Blend factor used for destination alpha color components. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga79b06d608873a5153807d809b96bd272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79b06d608873a5153807d809b96bd272">&#9670;&nbsp;</a></span>nvnBlendStateSetBlendFunc_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnBlendStateSetBlendFunc_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a>&#160;</td>
          <td class="paramname"><em>srcFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a>&#160;</td>
          <td class="paramname"><em>dstFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a>&#160;</td>
          <td class="paramname"><em>srcFuncAlpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a>&#160;</td>
          <td class="paramname"><em>dstFuncAlpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify blend functions for source and destination color and alpha channels. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnBlendStateSetBlendFunc, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object to update.</td></tr>
    <tr><td class="paramname">srcFunc</td><td>Blend factor used for source RGB color components.</td></tr>
    <tr><td class="paramname">dstFunc</td><td>Blend factor used for destination RGB color components.</td></tr>
    <tr><td class="paramname">srcFuncAlpha</td><td>Blend factor used for source alpha color components.</td></tr>
    <tr><td class="paramname">dstFuncAlpha</td><td>Blend factor used for destination alpha color components. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad8c227afe934866f7758f9158ebe1f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8c227afe934866f7758f9158ebe1f9f">&#9670;&nbsp;</a></span>nvnBlendStateSetBlendEquation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBlendStateSetBlendEquation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga127348ecf50d7e4c7197ed7e989c5e60">NVNblendEquation</a>&#160;</td>
          <td class="paramname"><em>modeRGB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga127348ecf50d7e4c7197ed7e989c5e60">NVNblendEquation</a>&#160;</td>
          <td class="paramname"><em>modeAlpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify blend equations for color and alpha channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object to update.</td></tr>
    <tr><td class="paramname">modeRGB</td><td>Blend equation used for RGB color components.</td></tr>
    <tr><td class="paramname">modeAlpha</td><td>Blend equation used for alpha color components. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga38d3f5fdce0a963834287722be665ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38d3f5fdce0a963834287722be665ef8">&#9670;&nbsp;</a></span>nvnBlendStateSetBlendEquation_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnBlendStateSetBlendEquation_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga127348ecf50d7e4c7197ed7e989c5e60">NVNblendEquation</a>&#160;</td>
          <td class="paramname"><em>modeRGB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga127348ecf50d7e4c7197ed7e989c5e60">NVNblendEquation</a>&#160;</td>
          <td class="paramname"><em>modeAlpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify blend equations for color and alpha channels. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnBlendStateSetBlendEquation, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object to update.</td></tr>
    <tr><td class="paramname">modeRGB</td><td>Blend equation used for RGB color components.</td></tr>
    <tr><td class="paramname">modeAlpha</td><td>Blend equation used for alpha color components. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadda20b441c242fbad2fa87c9c441735a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadda20b441c242fbad2fa87c9c441735a">&#9670;&nbsp;</a></span>nvnBlendStateSetAdvancedMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBlendStateSetAdvancedMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga594e8a6aa9642c5542c0a0ee0156c146">NVNblendAdvancedMode</a>&#160;</td>
          <td class="paramname"><em>overlap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a mode for advanced blending equations. </p>
<p>Advanced blending in NVN provides capabilities similar to those provided by the NV_blend_equation_advanced OpenGL extension. These blend modes specify a technique for combining source and destination color components, and use the source and destination alpha components to evaluate how colors are combined with overlapping color components. The advanced blending modes provided here are similar to those supported in various standards, including several OpenGL and OpenGL ES extensions, OpenVG, the SVG compositing standard, the PDF document format, and various other APIs. For more information on the operation of these blend modes, please consult the NV_blend_equation_advanced specification.</p>
<p>When advanced blending is enabled (not set to <a class="el" href="group__nvn__c__enum.html#gga594e8a6aa9642c5542c0a0ee0156c146abebf3d2a655c414e8e8e67003be3f3ba" title="Use normal blending equations specified with nvnBlendStateSetBlendEquation and nvnBlendStateSetBlendF...">NVN_BLEND_ADVANCED_MODE_NONE</a>), only a single render target is supported. Advanced blending wtih multiple color targets has undefined behavior and may result in to GPU errors. Advanced modes other than NONE are supported only for color target zero.</p>
<p>Advanced blending modes are supported on NX but are not supported on the Windows reference implementation for GPUs older than first-generation Maxwell GPUs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object to update.</td></tr>
    <tr><td class="paramname">overlap</td><td>Mode to use for advanced blending equations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga47baf1ff1219b778f966f1866f6b0666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47baf1ff1219b778f966f1866f6b0666">&#9670;&nbsp;</a></span>nvnBlendStateSetAdvancedMode_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnBlendStateSetAdvancedMode_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga594e8a6aa9642c5542c0a0ee0156c146">NVNblendAdvancedMode</a>&#160;</td>
          <td class="paramname"><em>overlap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a mode for advanced blending equations. </p>
<p>Fastpath variant.</p>
<p>Advanced blending in NVN provides capabilities similar to those provided by the NV_blend_equation_advanced OpenGL extension. These blend modes specify a technique for combining source and destination color components, and use the source and destination alpha components to evaluate how colors are combined with overlapping color components. The advanced blending modes provided here are similar to those supported in various standards, including several OpenGL and OpenGL ES extensions, OpenVG, the SVG compositing standard, the PDF document format, and various other APIs. For more information on the operation of these blend modes, please consult the NV_blend_equation_advanced specification.</p>
<p>When advanced blending is enabled (not set to <a class="el" href="group__nvn__c__enum.html#gga594e8a6aa9642c5542c0a0ee0156c146abebf3d2a655c414e8e8e67003be3f3ba" title="Use normal blending equations specified with nvnBlendStateSetBlendEquation and nvnBlendStateSetBlendF...">NVN_BLEND_ADVANCED_MODE_NONE</a>), only a single render target is supported. Advanced blending wtih multiple color targets has undefined behavior and may result in to GPU errors. Advanced modes other than NONE are supported only for color target zero.</p>
<p>Advanced blending modes are supported on NX but are not supported on the Windows reference implementation for GPUs older than first-generation Maxwell GPUs.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnBlendStateSetAdvancedMode, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object to update.</td></tr>
    <tr><td class="paramname">overlap</td><td>Mode to use for advanced blending equations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0e2be1cd8aad18c9d1ba0f9fa4ca7af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e2be1cd8aad18c9d1ba0f9fa4ca7af4">&#9670;&nbsp;</a></span>nvnBlendStateSetAdvancedOverlap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBlendStateSetAdvancedOverlap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga49a9399d8c6cc26a7f4b256fe0951699">NVNblendAdvancedOverlap</a>&#160;</td>
          <td class="paramname"><em>overlap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify blend overlap mode for advanced blending equations. </p>
<p>Advanced blending in NVN provides capabilities similar to those provided by the NV_blend_equation_advanced OpenGL extension. The overlap modes specify how coverage for partially covered sources and/or destinations is treated in the blending equations. This state has no effect if the advanced blending mode is <a class="el" href="group__nvn__c__enum.html#gga594e8a6aa9642c5542c0a0ee0156c146abebf3d2a655c414e8e8e67003be3f3ba" title="Use normal blending equations specified with nvnBlendStateSetBlendEquation and nvnBlendStateSetBlendF...">NVN_BLEND_ADVANCED_MODE_NONE</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object to update.</td></tr>
    <tr><td class="paramname">overlap</td><td>Overlap mode used for advanced blending equations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaec9e463299721f02e7c0f6afc1922590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec9e463299721f02e7c0f6afc1922590">&#9670;&nbsp;</a></span>nvnBlendStateSetAdvancedOverlap_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnBlendStateSetAdvancedOverlap_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga49a9399d8c6cc26a7f4b256fe0951699">NVNblendAdvancedOverlap</a>&#160;</td>
          <td class="paramname"><em>overlap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify blend overlap mode for advanced blending equations. </p>
<p>Fastpath variant.</p>
<p>Advanced blending in NVN provides capabilities similar to those provided by the NV_blend_equation_advanced OpenGL extension. The overlap modes specify how coverage for partially covered sources and/or destinations is treated in the blending equations. This state has no effect if the advanced blending mode is <a class="el" href="group__nvn__c__enum.html#gga594e8a6aa9642c5542c0a0ee0156c146abebf3d2a655c414e8e8e67003be3f3ba" title="Use normal blending equations specified with nvnBlendStateSetBlendEquation and nvnBlendStateSetBlendF...">NVN_BLEND_ADVANCED_MODE_NONE</a>.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnBlendStateSetAdvancedOverlap, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object to update.</td></tr>
    <tr><td class="paramname">overlap</td><td>Overlap mode used for advanced blending equations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac8aae125e2a9006310e3812c99e5f7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8aae125e2a9006310e3812c99e5f7ff">&#9670;&nbsp;</a></span>nvnBlendStateSetAdvancedPremultipliedSrc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBlendStateSetAdvancedPremultipliedSrc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>premultiplied</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify whether the source color is considered premultiplied for advanced blending equations. </p>
<p>Advanced blending in NVN provides capabilities similar to those provided by the NV_blend_equation_advanced OpenGL extension. By default, blending is performed with pre-multiplied colors, where a white pixel with 50% coverage has an (R,G,B,A) value of (0.5, 0.5, 0.5, 0.5). If NVN_FALSE is specified, the source color is assumed not to be premultiplied and the same white pixel would be passed as (1.0, 1.0, 1.0, 0.5). Destination colors in advanced blending are always considered pre-multiplied. This state has no effect if the advanced blending mode is <a class="el" href="group__nvn__c__enum.html#gga594e8a6aa9642c5542c0a0ee0156c146abebf3d2a655c414e8e8e67003be3f3ba" title="Use normal blending equations specified with nvnBlendStateSetBlendEquation and nvnBlendStateSetBlendF...">NVN_BLEND_ADVANCED_MODE_NONE</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object to update.</td></tr>
    <tr><td class="paramname">premultiplied</td><td>TRUE if source color components are considered to be pre-multiplied by the source alpha. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaff5b17f8bdd9ab57c6c495b1c0e64d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff5b17f8bdd9ab57c6c495b1c0e64d85">&#9670;&nbsp;</a></span>nvnBlendStateSetAdvancedPremultipliedSrc_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnBlendStateSetAdvancedPremultipliedSrc_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>premultiplied</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify whether the source color is considered premultiplied for advanced blending equations. </p>
<p>Fastpath variant.</p>
<p>Advanced blending in NVN provides capabilities similar to those provided by the NV_blend_equation_advanced OpenGL extension. By default, blending is performed with pre-multiplied colors, where a white pixel with 50% coverage has an (R,G,B,A) value of (0.5, 0.5, 0.5, 0.5). If NVN_FALSE is specified, the source color is assumed not to be premultiplied and the same white pixel would be passed as (1.0, 1.0, 1.0, 0.5). Destination colors in advanced blending are always considered pre-multiplied. This state has no effect if the advanced blending mode is <a class="el" href="group__nvn__c__enum.html#gga594e8a6aa9642c5542c0a0ee0156c146abebf3d2a655c414e8e8e67003be3f3ba" title="Use normal blending equations specified with nvnBlendStateSetBlendEquation and nvnBlendStateSetBlendF...">NVN_BLEND_ADVANCED_MODE_NONE</a>.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnBlendStateSetAdvancedPremultipliedSrc, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object to update.</td></tr>
    <tr><td class="paramname">premultiplied</td><td>TRUE if source color components are considered to be pre-multiplied by the source alpha. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3ae21c2d569e680699ce50ff6d6b3a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ae21c2d569e680699ce50ff6d6b3a7b">&#9670;&nbsp;</a></span>nvnBlendStateSetAdvancedNormalizedDst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBlendStateSetAdvancedNormalizedDst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>normalized</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify whether the destination color target has unsigned normalized components (values in [0,1]). </p>
<p>Advanced blending in NVN provides capabilities similar to those provided by the NV_blend_equation_advanced OpenGL extension. By default, blending assumes that the destination values are stored with unsigned normalized components (e.g., using formats like <a class="el" href="group__nvn__c__enum.html#gga99463f5b9af6151e604b01dfdd5fecaba81514f73c168617e9819e91131e87426" title="Four 8-bit unsigned normalized components.">NVN_FORMAT_RGBA8</a>). If this value is set to NVN_FALSE, advanced blending will not assume that the destination input and the output will be clamped to [0,1] and will clamp values manually when required. This state has no effect if the advanced blending mode is <a class="el" href="group__nvn__c__enum.html#gga594e8a6aa9642c5542c0a0ee0156c146abebf3d2a655c414e8e8e67003be3f3ba" title="Use normal blending equations specified with nvnBlendStateSetBlendEquation and nvnBlendStateSetBlendF...">NVN_BLEND_ADVANCED_MODE_NONE</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object to update.</td></tr>
    <tr><td class="paramname">normalized</td><td>TRUE if destination color components are unsigned normalized ([0,1]) values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga14b8abb0c19884137457c9379982db3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14b8abb0c19884137457c9379982db3f">&#9670;&nbsp;</a></span>nvnBlendStateSetAdvancedNormalizedDst_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnBlendStateSetAdvancedNormalizedDst_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>normalized</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify whether the destination color target has unsigned normalized components (values in [0,1]). </p>
<p>Fastpath variant.</p>
<p>Advanced blending in NVN provides capabilities similar to those provided by the NV_blend_equation_advanced OpenGL extension. By default, blending assumes that the destination values are stored with unsigned normalized components (e.g., using formats like <a class="el" href="group__nvn__c__enum.html#gga99463f5b9af6151e604b01dfdd5fecaba81514f73c168617e9819e91131e87426" title="Four 8-bit unsigned normalized components.">NVN_FORMAT_RGBA8</a>). If this value is set to NVN_FALSE, advanced blending will not assume that the destination input and the output will be clamped to [0,1] and will clamp values manually when required. This state has no effect if the advanced blending mode is <a class="el" href="group__nvn__c__enum.html#gga594e8a6aa9642c5542c0a0ee0156c146abebf3d2a655c414e8e8e67003be3f3ba" title="Use normal blending equations specified with nvnBlendStateSetBlendEquation and nvnBlendStateSetBlendF...">NVN_BLEND_ADVANCED_MODE_NONE</a>.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnBlendStateSetAdvancedNormalizedDst, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object to update.</td></tr>
    <tr><td class="paramname">normalized</td><td>TRUE if destination color components are unsigned normalized ([0,1]) values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga67117050f7018fa4eb4f51b7611b743c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67117050f7018fa4eb4f51b7611b743c">&#9670;&nbsp;</a></span>nvnBlendStateGetBlendTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnBlendStateGetBlendTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the number of the color target to update via the <a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5f8a1adcd6b4c29ee296072ba9f0942f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f8a1adcd6b4c29ee296072ba9f0942f">&#9670;&nbsp;</a></span>nvnBlendStateGetBlendTarget_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE int nvnBlendStateGetBlendTarget_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the number of the color target to update via the <a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnBlendStateGetBlendTarget, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafac4c143756021848290b54879da1240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafac4c143756021848290b54879da1240">&#9670;&nbsp;</a></span>nvnBlendStateGetBlendFunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBlendStateGetBlendFunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a> *&#160;</td>
          <td class="paramname"><em>srcFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a> *&#160;</td>
          <td class="paramname"><em>dstFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a> *&#160;</td>
          <td class="paramname"><em>srcFuncAlpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a> *&#160;</td>
          <td class="paramname"><em>dstFuncAlpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query blend functions for source and destination color and alpha channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">srcFunc</td><td>Blend factor used for source RGB color components.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dstFunc</td><td>Blend factor used for destination RGB color components.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">srcFuncAlpha</td><td>Blend factor used for source alpha color components.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dstFuncAlpha</td><td>Blend factor used for destination alpha color components. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7473bde2a4b5144923394d2b2b3ebaab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7473bde2a4b5144923394d2b2b3ebaab">&#9670;&nbsp;</a></span>nvnBlendStateGetBlendEquation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBlendStateGetBlendEquation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga127348ecf50d7e4c7197ed7e989c5e60">NVNblendEquation</a> *&#160;</td>
          <td class="paramname"><em>modeRGB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga127348ecf50d7e4c7197ed7e989c5e60">NVNblendEquation</a> *&#160;</td>
          <td class="paramname"><em>modeAlpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query blend equations for color and alpha channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">modeRGB</td><td>Blend equation used for RGB color components.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">modeAlpha</td><td>Blend equation used for alpha color components. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga347fb2b3121de63e9c3a6b9595ccd2c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga347fb2b3121de63e9c3a6b9595ccd2c0">&#9670;&nbsp;</a></span>nvnBlendStateGetAdvancedMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga594e8a6aa9642c5542c0a0ee0156c146">NVNblendAdvancedMode</a> nvnBlendStateGetAdvancedMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the mode for advanced blending equations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9a0232ed175b83f4002d237e98eea02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a0232ed175b83f4002d237e98eea02c">&#9670;&nbsp;</a></span>nvnBlendStateGetAdvancedOverlap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga49a9399d8c6cc26a7f4b256fe0951699">NVNblendAdvancedOverlap</a> nvnBlendStateGetAdvancedOverlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the blend overlap mode for advanced blending equations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8e8df2c0b7c30848c050cf62da45494d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e8df2c0b7c30848c050cf62da45494d">&#9670;&nbsp;</a></span>nvnBlendStateGetAdvancedPremultipliedSrc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnBlendStateGetAdvancedPremultipliedSrc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether the source color is considered premultiplied for advanced blending equations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3f80605e385de2c63e73c51162897bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f80605e385de2c63e73c51162897bde">&#9670;&nbsp;</a></span>nvnBlendStateGetAdvancedPremultipliedSrc_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnBlendStateGetAdvancedPremultipliedSrc_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether the source color is considered premultiplied for advanced blending equations. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnBlendStateGetAdvancedPremultipliedSrc, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4c2a450326605d61c14c8a888db2fb2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c2a450326605d61c14c8a888db2fb2b">&#9670;&nbsp;</a></span>nvnBlendStateGetAdvancedNormalizedDst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnBlendStateGetAdvancedNormalizedDst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether the destination color target has unsigned normalized components (values in [0,1]). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae1fa95ae6b7e29e8eeb8c491f846f467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1fa95ae6b7e29e8eeb8c491f846f467">&#9670;&nbsp;</a></span>nvnBlendStateGetAdvancedNormalizedDst_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnBlendStateGetAdvancedNormalizedDst_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether the destination color target has unsigned normalized components (values in [0,1]). </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnBlendStateGetAdvancedNormalizedDst, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1b5549b5bc5384456dda61010d85b5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b5549b5bc5384456dda61010d85b5c2">&#9670;&nbsp;</a></span>nvnColorStateSetDefaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnColorStateSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_ncolor_state.html" title="API state object controlling processing of color values.">NVNcolorState</a> object. </p>
<dl class="section note"><dt>Note</dt><dd>This is semantically equivalent to calling</dd></dl>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (NVNuint i = 0; i &lt; DeviceInfo::COLOR_BUFFER_BINDINGS; ++i) {</div>
<div class="line">  ColorState::SetBlendEnable(i, <a class="code" href="group__nvn__c__defines.html#gad12fb86930f09043843be6b39c78bb1b">NVN_FALSE</a>);</div>
<div class="line">};</div>
<div class="line">ColorState::SetLogicOp(NVN_LOGIC_OP_COPY);</div>
<div class="line">ColorState::SetAlphaTest(NVN_ALPHA_FUNC_ALWAYS);</div>
<div class="ttc" id="agroup__nvn__c__defines_html_gad12fb86930f09043843be6b39c78bb1b"><div class="ttname"><a href="group__nvn__c__defines.html#gad12fb86930f09043843be6b39c78bb1b">NVN_FALSE</a></div><div class="ttdeci">#define NVN_FALSE</div><div class="ttdoc">Boolean condition with a value of false.</div><div class="ttdef"><b>Definition:</b> nvn.h:4563</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td><a class="el" href="struct_n_v_ncolor_state.html" title="API state object controlling processing of color values.">NVNcolorState</a> object to update. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4c1c99c2ad31d66b2a6c170b8d8b324c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c1c99c2ad31d66b2a6c170b8d8b324c">&#9670;&nbsp;</a></span>nvnColorStateSetBlendEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnColorStateSetBlendEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the blending enable for a single color target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td><a class="el" href="struct_n_v_ncolor_state.html" title="API state object controlling processing of color values.">NVNcolorState</a> object to update.</td></tr>
    <tr><td class="paramname">index</td><td>Number of the color target to update. Must be less than 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a9f4ab24a0b8c08e3f2b66ce04e379b16" title="Number of color buffer binding points.">NVN_DEVICE_INFO_COLOR_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">enable</td><td>TRUE if blending should be enabled for the specified target; FALSE, otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga34d488b77453064ee98fd042c5f8f9df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34d488b77453064ee98fd042c5f8f9df">&#9670;&nbsp;</a></span>nvnColorStateSetLogicOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnColorStateSetLogicOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga13d92b26dc58a3c92b79e217e1d81786">NVNlogicOp</a>&#160;</td>
          <td class="paramname"><em>logicOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the logical operation to perform for all color targets. </p>
<p>If programmed to anything but COPY, arithmetic blending has no effect. Unlike blending, there is no support for separate logical operations for each color target.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td><a class="el" href="struct_n_v_ncolor_state.html" title="API state object controlling processing of color values.">NVNcolorState</a> object to update.</td></tr>
    <tr><td class="paramname">logicOp</td><td>Logical operation to perform on all color targets. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3f36048ed6077a8bb93623325cab6ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f36048ed6077a8bb93623325cab6ee5">&#9670;&nbsp;</a></span>nvnColorStateSetLogicOp_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnColorStateSetLogicOp_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga13d92b26dc58a3c92b79e217e1d81786">NVNlogicOp</a>&#160;</td>
          <td class="paramname"><em>logicOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the logical operation to perform for all color targets. </p>
<p>Fastpath variant.</p>
<p>If programmed to anything but COPY, arithmetic blending has no effect. Unlike blending, there is no support for separate logical operations for each color target.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnColorStateSetLogicOp, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td><a class="el" href="struct_n_v_ncolor_state.html" title="API state object controlling processing of color values.">NVNcolorState</a> object to update.</td></tr>
    <tr><td class="paramname">logicOp</td><td>Logical operation to perform on all color targets. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1cd9f1df52f41fef96e17bbd42facaa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cd9f1df52f41fef96e17bbd42facaa0">&#9670;&nbsp;</a></span>nvnColorStateSetAlphaTest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnColorStateSetAlphaTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaef30ce5d138fb99aee61e09d89d9952e">NVNalphaFunc</a>&#160;</td>
          <td class="paramname"><em>alphaTest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies a comparison function to use for alpha testing. </p>
<p>Using <a class="el" href="group__nvn__c__enum.html#ggaef30ce5d138fb99aee61e09d89d9952ea5831bb73448f400fbb8034277fbf2452" title="Comparison always passes.">NVN_ALPHA_FUNC_ALWAYS</a> disables the alpha test entirely.</p>
<dl class="section note"><dt>Note</dt><dd>Applications may get better performance from performing an alpha test in the fragment shader and discarding fragments that fail. Doing so allows the fragment shader to skip other color calculations for failing fragments.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td><a class="el" href="struct_n_v_ncolor_state.html" title="API state object controlling processing of color values.">NVNcolorState</a> object to update.</td></tr>
    <tr><td class="paramname">alphaTest</td><td>Comparison function used by the alpha test. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga47f9bc738389baa490dd5f4b0df8b527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47f9bc738389baa490dd5f4b0df8b527">&#9670;&nbsp;</a></span>nvnColorStateSetAlphaTest_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnColorStateSetAlphaTest_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaef30ce5d138fb99aee61e09d89d9952e">NVNalphaFunc</a>&#160;</td>
          <td class="paramname"><em>alphaTest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies a comparison function to use for alpha testing. </p>
<p>Fastpath variant.</p>
<p>Using <a class="el" href="group__nvn__c__enum.html#ggaef30ce5d138fb99aee61e09d89d9952ea5831bb73448f400fbb8034277fbf2452" title="Comparison always passes.">NVN_ALPHA_FUNC_ALWAYS</a> disables the alpha test entirely.</p>
<dl class="section note"><dt>Note</dt><dd>Applications may get better performance from performing an alpha test in the fragment shader and discarding fragments that fail. Doing so allows the fragment shader to skip other color calculations for failing fragments.</dd>
<dd>
: This is functionally equivalent to nvnColorStateSetAlphaTest, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td><a class="el" href="struct_n_v_ncolor_state.html" title="API state object controlling processing of color values.">NVNcolorState</a> object to update.</td></tr>
    <tr><td class="paramname">alphaTest</td><td>Comparison function used by the alpha test. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3503d68a40da5ab574a594125f8cef2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3503d68a40da5ab574a594125f8cef2e">&#9670;&nbsp;</a></span>nvnColorStateGetBlendEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnColorStateGetBlendEnable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the blending enable for a single color target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td><a class="el" href="struct_n_v_ncolor_state.html" title="API state object controlling processing of color values.">NVNcolorState</a> object to query.</td></tr>
    <tr><td class="paramname">index</td><td>Number of the color target to query. Must be less than 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a9f4ab24a0b8c08e3f2b66ce04e379b16" title="Number of color buffer binding points.">NVN_DEVICE_INFO_COLOR_BUFFER_BINDINGS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf55951ccbd93d23d1753d4de03d81119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf55951ccbd93d23d1753d4de03d81119">&#9670;&nbsp;</a></span>nvnColorStateGetLogicOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga13d92b26dc58a3c92b79e217e1d81786">NVNlogicOp</a> nvnColorStateGetLogicOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the logical operation to perform for all color targets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td><a class="el" href="struct_n_v_ncolor_state.html" title="API state object controlling processing of color values.">NVNcolorState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9dd303cf6348a6e860f26da1f9219e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9dd303cf6348a6e860f26da1f9219e46">&#9670;&nbsp;</a></span>nvnColorStateGetAlphaTest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#gaef30ce5d138fb99aee61e09d89d9952e">NVNalphaFunc</a> nvnColorStateGetAlphaTest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the comparison function to use for alpha testing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td><a class="el" href="struct_n_v_ncolor_state.html" title="API state object controlling processing of color values.">NVNcolorState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafc110d97cce3482f715d26e83413adfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc110d97cce3482f715d26e83413adfc">&#9670;&nbsp;</a></span>nvnChannelMaskStateSetDefaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnChannelMaskStateSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nchannel_mask_state.html">NVNchannelMaskState</a> *&#160;</td>
          <td class="paramname"><em>channelMask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_nchannel_mask_state.html" title="API state object holding per-channel write masks for all color buffers.">NVNchannelMaskState</a> object. </p>
<dl class="section note"><dt>Note</dt><dd>This is semantically equivalent to calling</dd></dl>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (NVNuint i = 0; i &lt; DeviceInfo::COLOR_BUFFER_BINDINGS; ++i) {</div>
<div class="line">  ChannelMaskState::SetChannelMask(i, <a class="code" href="group__nvn__c__defines.html#ga48151b7e768a13685d77d1a4c464a33b">NVN_TRUE</a>, <a class="code" href="group__nvn__c__defines.html#ga48151b7e768a13685d77d1a4c464a33b">NVN_TRUE</a>,</div>
<div class="line">                                      <a class="code" href="group__nvn__c__defines.html#ga48151b7e768a13685d77d1a4c464a33b">NVN_TRUE</a>, <a class="code" href="group__nvn__c__defines.html#ga48151b7e768a13685d77d1a4c464a33b">NVN_TRUE</a>);</div>
<div class="line">};</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channelMask</td><td><a class="el" href="struct_n_v_nchannel_mask_state.html" title="API state object holding per-channel write masks for all color buffers.">NVNchannelMaskState</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2493330ef54d576b537e2f0b1aadbf24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2493330ef54d576b537e2f0b1aadbf24">&#9670;&nbsp;</a></span>nvnChannelMaskStateSetChannelMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnChannelMaskStateSetChannelMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nchannel_mask_state.html">NVNchannelMaskState</a> *&#160;</td>
          <td class="paramname"><em>channelMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives.">NVNprogram</a> RGBA channel masks for a single color target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channelMask</td><td><a class="el" href="struct_n_v_nchannel_mask_state.html" title="API state object holding per-channel write masks for all color buffers.">NVNchannelMaskState</a> object to update.</td></tr>
    <tr><td class="paramname">index</td><td>Number of the color target to update. Must be less than 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a9f4ab24a0b8c08e3f2b66ce04e379b16" title="Number of color buffer binding points.">NVN_DEVICE_INFO_COLOR_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">r</td><td>Enable (TRUE) or disable (FALSE) writes to the first (R) component.</td></tr>
    <tr><td class="paramname">g</td><td>Enable (TRUE) or disable (FALSE) writes to the second (G) component.</td></tr>
    <tr><td class="paramname">b</td><td>Enable (TRUE) or disable (FALSE) writes to the third (B) component.</td></tr>
    <tr><td class="paramname">a</td><td>Enable (TRUE) or disable (FALSE) writes to the fourth (A) component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacc2b78b04c91b5deabcfaf93cdb0e36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc2b78b04c91b5deabcfaf93cdb0e36c">&#9670;&nbsp;</a></span>nvnChannelMaskStateGetChannelMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnChannelMaskStateGetChannelMask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nchannel_mask_state.html">NVNchannelMaskState</a> *&#160;</td>
          <td class="paramname"><em>channelMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> *&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query RGBA channel masks for a single color target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">channelMask</td><td><a class="el" href="struct_n_v_nchannel_mask_state.html" title="API state object holding per-channel write masks for all color buffers.">NVNchannelMaskState</a> object to query.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">index</td><td>Number of the color target to query. Must be less than 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a9f4ab24a0b8c08e3f2b66ce04e379b16" title="Number of color buffer binding points.">NVN_DEVICE_INFO_COLOR_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">r</td><td>Enable (TRUE) or disable (FALSE) writes to the first (R) component.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>Enable (TRUE) or disable (FALSE) writes to the second (G) component.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>Enable (TRUE) or disable (FALSE) writes to the third (B) component.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a</td><td>Enable (TRUE) or disable (FALSE) writes to the fourth (A) component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0d649ca21de18dd8b544c8006d6612d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d649ca21de18dd8b544c8006d6612d8">&#9670;&nbsp;</a></span>nvnMultisampleStateSetDefaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMultisampleStateSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object. </p>
<dl class="section note"><dt>Note</dt><dd>This is semantically equivalent to calling</dd></dl>
<div class="fragment"><div class="line">MultisampleState::SetMultisampleEnable(<a class="code" href="group__nvn__c__defines.html#ga48151b7e768a13685d77d1a4c464a33b">NVN_TRUE</a>);</div>
<div class="line">MultisampleState::SetAlphaToCoverageEnable(<a class="code" href="group__nvn__c__defines.html#gad12fb86930f09043843be6b39c78bb1b">NVN_FALSE</a>);</div>
<div class="line">MultisampleState::SetAlphaToCoverageDither(<a class="code" href="group__nvn__c__defines.html#ga48151b7e768a13685d77d1a4c464a33b">NVN_TRUE</a>);</div>
<div class="line">MultisampleState::SetSamples(0);</div>
<div class="line">MultisampleState::SetRasterSamples(0);</div>
<div class="line">MultisampleState::SetCoverageModulationMode(CoverageModulationMode::NONE);</div>
<div class="line">MultisampleState::SetCoverageToColorEnable(<a class="code" href="group__nvn__c__defines.html#gad12fb86930f09043843be6b39c78bb1b">NVN_FALSE</a>);</div>
<div class="line">MultisampleState::SetCoverageToColorOutput(0);</div>
<div class="line">MultisampleState::SetSampleLocationsEnable(<a class="code" href="group__nvn__c__defines.html#gad12fb86930f09043843be6b39c78bb1b">NVN_FALSE</a>);</div>
<div class="line">MultisampleState::SetSampleLocationsGridEnable(<a class="code" href="group__nvn__c__defines.html#gad12fb86930f09043843be6b39c78bb1b">NVN_FALSE</a>);</div>
</div><!-- fragment --><p> All sample locations in the <a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object are initialized to pixel centers (0.5).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7f1d552844cb1b2388d012cb80d094ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f1d552844cb1b2388d012cb80d094ea">&#9670;&nbsp;</a></span>nvnMultisampleStateSetMultisampleEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMultisampleStateSetMultisampleEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable multisample rasterization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to update.</td></tr>
    <tr><td class="paramname">enable</td><td>Enable (TRUE) or disable (FALSE) multisample rasterization. When multisample rasterization is enabled, separate coverage information is computed for every sample in a pixel. When multisample rasterization is disabled, a single coverage value is used for all samples in a pixel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga60abfbd8dd83007831c1e50de6c0a1e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60abfbd8dd83007831c1e50de6c0a1e6">&#9670;&nbsp;</a></span>nvnMultisampleStateSetMultisampleEnable_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnMultisampleStateSetMultisampleEnable_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable multisample rasterization. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnMultisampleStateSetMultisampleEnable, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to update.</td></tr>
    <tr><td class="paramname">enable</td><td>Enable (TRUE) or disable (FALSE) multisample rasterization. When multisample rasterization is enabled, separate coverage information is computed for every sample in a pixel. When multisample rasterization is disabled, a single coverage value is used for all samples in a pixel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafc59ccbfdafe205cd8ba04f1795ada6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc59ccbfdafe205cd8ba04f1795ada6d">&#9670;&nbsp;</a></span>nvnMultisampleStateSetSamples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMultisampleStateSetSamples </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the number of samples in the framebuffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>If the sample count in the <a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object and the textures in the framebuffer don't match, the results of rendering are undefined.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to update.</td></tr>
    <tr><td class="paramname">samples</td><td>Specifies the number of samples in the framebuffer. If non-multisample framebuffers are used, the value should be specified as 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabaf62b0c321b135199f65fc7b0890afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabaf62b0c321b135199f65fc7b0890afe">&#9670;&nbsp;</a></span>nvnMultisampleStateSetSamples_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnMultisampleStateSetSamples_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the number of samples in the framebuffer. </p>
<p>Fastpath variant.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the sample count in the <a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object and the textures in the framebuffer don't match, the results of rendering are undefined.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnMultisampleStateSetSamples, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to update.</td></tr>
    <tr><td class="paramname">samples</td><td>Specifies the number of samples in the framebuffer. If non-multisample framebuffers are used, the value should be specified as 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3837dd1e28700073cfd34479a6a2e677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3837dd1e28700073cfd34479a6a2e677">&#9670;&nbsp;</a></span>nvnMultisampleStateSetAlphaToCoverageEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMultisampleStateSetAlphaToCoverageEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable alpha-to-coverage operation. </p>
<p>When alpha-to-coverage operations are enabled, the fourth (A) component of fragment color zero is used to produce a sample mask that is combined with raster coverage to produce an updated sample mask. An alpha value of 0.0 disables all samples; an alpha value of 1.0 enables all samples.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to update.</td></tr>
    <tr><td class="paramname">enable</td><td>Enable (TRUE) or disable (FALSE) the alpha-to-coverage operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga50a2f81139dd5987bbd1edd0e224553c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50a2f81139dd5987bbd1edd0e224553c">&#9670;&nbsp;</a></span>nvnMultisampleStateSetAlphaToCoverageEnable_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnMultisampleStateSetAlphaToCoverageEnable_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable alpha-to-coverage operation. </p>
<p>Fastpath variant.</p>
<p>When alpha-to-coverage operations are enabled, the fourth (A) component of fragment color zero is used to produce a sample mask that is combined with raster coverage to produce an updated sample mask. An alpha value of 0.0 disables all samples; an alpha value of 1.0 enables all samples.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnMultisampleStateSetAlphaToCoverageEnable, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to update.</td></tr>
    <tr><td class="paramname">enable</td><td>Enable (TRUE) or disable (FALSE) the alpha-to-coverage operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabc12eb75e49cd73800ac71eac99e4008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc12eb75e49cd73800ac71eac99e4008">&#9670;&nbsp;</a></span>nvnMultisampleStateSetAlphaToCoverageDither()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMultisampleStateSetAlphaToCoverageDither </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>dither</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable dithering in the alpha-to-coverage operation. </p>
<p>When alpha-to-coverage operations are enabled via MultisampleState::SetAlphaToCoverage, the fourth (A) component of fragment color zero is used to produce a sample mask that is combined with raster coverage to produce an updated sample mask. An alpha value of 0.0 disables all samples; an alpha value of 1.0 enables all samples. If alpha-to-coverage dithering is enabled by this command, the same alpha value will produce different sample masks for different pixels. If dithering is disabled, the same alpha value will produce the same sample mask in all pixels. Dithering will allow for more effective levels of transparency, but may result in more visible noise. Dithering has no effect if alpha-to-coverage is disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to update.</td></tr>
    <tr><td class="paramname">dither</td><td>Enable (TRUE) or disable (FALSE) the alpha-to-coverage dithering operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga442665a5bf95bbdc90e57e1eabdc8451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga442665a5bf95bbdc90e57e1eabdc8451">&#9670;&nbsp;</a></span>nvnMultisampleStateSetAlphaToCoverageDither_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnMultisampleStateSetAlphaToCoverageDither_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>dither</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable dithering in the alpha-to-coverage operation. </p>
<p>Fastpath variant.</p>
<p>When alpha-to-coverage operations are enabled via MultisampleState::SetAlphaToCoverage, the fourth (A) component of fragment color zero is used to produce a sample mask that is combined with raster coverage to produce an updated sample mask. An alpha value of 0.0 disables all samples; an alpha value of 1.0 enables all samples. If alpha-to-coverage dithering is enabled by this command, the same alpha value will produce different sample masks for different pixels. If dithering is disabled, the same alpha value will produce the same sample mask in all pixels. Dithering will allow for more effective levels of transparency, but may result in more visible noise. Dithering has no effect if alpha-to-coverage is disabled.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnMultisampleStateSetAlphaToCoverageDither, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to update.</td></tr>
    <tr><td class="paramname">dither</td><td>Enable (TRUE) or disable (FALSE) the alpha-to-coverage dithering operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab7f67824bc1e151868f8d1cd2a1ce1c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7f67824bc1e151868f8d1cd2a1ce1c6">&#9670;&nbsp;</a></span>nvnMultisampleStateGetMultisampleEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnMultisampleStateGetMultisampleEnable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the multisample rasterization enable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga030dc03728226ce80514f6c25bb94dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga030dc03728226ce80514f6c25bb94dbf">&#9670;&nbsp;</a></span>nvnMultisampleStateGetMultisampleEnable_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnMultisampleStateGetMultisampleEnable_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the multisample rasterization enable. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnMultisampleStateGetMultisampleEnable, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8aa20b9525683eeca5f07d1c40db4078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8aa20b9525683eeca5f07d1c40db4078">&#9670;&nbsp;</a></span>nvnMultisampleStateGetSamples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnMultisampleStateGetSamples </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the number of samples in a <a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4d803306cbbc3edbb66ffeb1a06794ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d803306cbbc3edbb66ffeb1a06794ae">&#9670;&nbsp;</a></span>nvnMultisampleStateGetSamples_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE int nvnMultisampleStateGetSamples_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the number of samples in a <a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnMultisampleStateGetSamples, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga709089315b48eb90eb3cf781957c9dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga709089315b48eb90eb3cf781957c9dc9">&#9670;&nbsp;</a></span>nvnMultisampleStateGetAlphaToCoverageEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnMultisampleStateGetAlphaToCoverageEnable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the alpha-to-coverage enable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab73a7a751bd29625291bdbd689ef38f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab73a7a751bd29625291bdbd689ef38f8">&#9670;&nbsp;</a></span>nvnMultisampleStateGetAlphaToCoverageEnable_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnMultisampleStateGetAlphaToCoverageEnable_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the alpha-to-coverage enable. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnMultisampleStateGetAlphaToCoverageEnable, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga172c7ccc42da8dbc211c9d8f8dc383dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga172c7ccc42da8dbc211c9d8f8dc383dd">&#9670;&nbsp;</a></span>nvnMultisampleStateGetAlphaToCoverageDither()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnMultisampleStateGetAlphaToCoverageDither </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the alpha-to-coverage dithering enable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga165ffe961a05d447344d3a364f97deb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga165ffe961a05d447344d3a364f97deb8">&#9670;&nbsp;</a></span>nvnMultisampleStateGetAlphaToCoverageDither_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnMultisampleStateGetAlphaToCoverageDither_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the alpha-to-coverage dithering enable. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnMultisampleStateGetAlphaToCoverageDither, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae00fe1081ea4ab7c88803a66283990d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae00fe1081ea4ab7c88803a66283990d2">&#9670;&nbsp;</a></span>nvnMultisampleStateSetRasterSamples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMultisampleStateSetRasterSamples </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rasterSamples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the raster sample count for target-independent rasterization. </p>
<p>When using a non-zero value (supported: 2, 4, 8, and 16), this command enables target-independent rasterization, where the rasterizer evaluates sample coverage using the specified number of sample locations. This raster sample count may differ from the number of stored samples in the framebuffer. When using a zero value (default), the command disables target-independent rasterization and has the rasterizer evaluate sample coverage based on the stored samples in the framebuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to update.</td></tr>
    <tr><td class="paramname">rasterSamples</td><td>Raster sample count. If depth or stencil tests are performed with target-independent rasterization, the raster sample count must be equal to the number of samples in the depth/stencil render target. If non-zero, the raster sample count must be greater than or equal to the color sample count set by nvnMultisampleStateSetSamples. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga436ec90542fecfa208d6e972fcbb2e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga436ec90542fecfa208d6e972fcbb2e9f">&#9670;&nbsp;</a></span>nvnMultisampleStateSetRasterSamples_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnMultisampleStateSetRasterSamples_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rasterSamples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the raster sample count for target-independent rasterization. </p>
<p>Fastpath variant.</p>
<p>When using a non-zero value (supported: 2, 4, 8, and 16), this command enables target-independent rasterization, where the rasterizer evaluates sample coverage using the specified number of sample locations. This raster sample count may differ from the number of stored samples in the framebuffer. When using a zero value (default), the command disables target-independent rasterization and has the rasterizer evaluate sample coverage based on the stored samples in the framebuffer.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnMultisampleStateSetRasterSamples, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to update.</td></tr>
    <tr><td class="paramname">rasterSamples</td><td>Raster sample count. If depth or stencil tests are performed with target-independent rasterization, the raster sample count must be equal to the number of samples in the depth/stencil render target. If non-zero, the raster sample count must be greater than or equal to the color sample count set by nvnMultisampleStateSetSamples. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf8a5728de499b27f27bff6f41be25aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8a5728de499b27f27bff6f41be25aa2">&#9670;&nbsp;</a></span>nvnMultisampleStateGetRasterSamples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnMultisampleStateGetRasterSamples </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the raster sample count for target-independent rasterization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0d829875d3a027916c5bc0fcb7a932d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d829875d3a027916c5bc0fcb7a932d5">&#9670;&nbsp;</a></span>nvnMultisampleStateGetRasterSamples_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE int nvnMultisampleStateGetRasterSamples_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the raster sample count for target-independent rasterization. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnMultisampleStateGetRasterSamples, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab15dd40cc4d6671ec613598a489f99ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab15dd40cc4d6671ec613598a489f99ef">&#9670;&nbsp;</a></span>nvnMultisampleStateSetCoverageModulationMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMultisampleStateSetCoverageModulationMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga26f01c2daca8e41b2961de31a9079501">NVNcoverageModulationMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the coverage modulation mode for target-independent rasterization. </p>
<p>When target-independent rasterization is enabled, pixel or sample color values in the framebuffer are updated whenever any of the associated raster samples are covered by a primitive. Applications can enable coverage modulation to account for partial coverage, where color (RGB) or alpha components are multiplied by a factor that reflects the fraction of raster samples that are covered. This modulation mode allows applications to specify that some, all, or none of the color components are multiplied by this factor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to update.</td></tr>
    <tr><td class="paramname">mode</td><td>Specifies the set of color channels to multiply by the coverage modulation factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4b504018fe751259ef755cc2113613c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b504018fe751259ef755cc2113613c7">&#9670;&nbsp;</a></span>nvnMultisampleStateSetCoverageModulationMode_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnMultisampleStateSetCoverageModulationMode_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga26f01c2daca8e41b2961de31a9079501">NVNcoverageModulationMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the coverage modulation mode for target-independent rasterization. </p>
<p>Fastpath variant.</p>
<p>When target-independent rasterization is enabled, pixel or sample color values in the framebuffer are updated whenever any of the associated raster samples are covered by a primitive. Applications can enable coverage modulation to account for partial coverage, where color (RGB) or alpha components are multiplied by a factor that reflects the fraction of raster samples that are covered. This modulation mode allows applications to specify that some, all, or none of the color components are multiplied by this factor.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnMultisampleStateSetCoverageModulationMode, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to update.</td></tr>
    <tr><td class="paramname">mode</td><td>Specifies the set of color channels to multiply by the coverage modulation factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabfac452c21527aeb1043008e5924564d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfac452c21527aeb1043008e5924564d">&#9670;&nbsp;</a></span>nvnMultisampleStateGetCoverageModulationMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga26f01c2daca8e41b2961de31a9079501">NVNcoverageModulationMode</a> nvnMultisampleStateGetCoverageModulationMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the coverage modulation mode for target-independent rasterization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabbf2410e5a0f923e692f3223cf49935c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbf2410e5a0f923e692f3223cf49935c">&#9670;&nbsp;</a></span>nvnMultisampleStateSetCoverageToColorEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMultisampleStateSetCoverageToColorEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the fragment coverage-to-color feature. </p>
<p>When enabled using nvnMultisampleStateSetCoverageToColorEnable, the fragment coverage-to-color feature writes a coverage mask for each fragment into the red component of the fragment color for one color output. The color output number recieving the coverage mask is specified by nvnMultisampleStateSetCoverageToColorOutput.</p>
<p>The coverage mask used for coverage-to-color reflects not only raster sample coverage, but also the results of per-fragment operations including other sample masks, alpha to coverage, alpha test, and the depth bounds, depth, and stencil tests.</p>
<dl class="section warning"><dt>Warning</dt><dd>When coverage-to-color is enabled, the color target receiving the coverage mask must have a one-component format with signed or unsigned integer components (e.g., R8I, R32UI). Coverage-to-color has no effect if other color target formats are used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to set.</td></tr>
    <tr><td class="paramname">enable</td><td>Fragment coverage-to-color enable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadbea1fe9392579207a1c50816cdc62f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbea1fe9392579207a1c50816cdc62f0">&#9670;&nbsp;</a></span>nvnMultisampleStateSetCoverageToColorEnable_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnMultisampleStateSetCoverageToColorEnable_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the fragment coverage-to-color feature. </p>
<p>Fastpath variant.</p>
<p>When enabled using nvnMultisampleStateSetCoverageToColorEnable, the fragment coverage-to-color feature writes a coverage mask for each fragment into the red component of the fragment color for one color output. The color output number recieving the coverage mask is specified by nvnMultisampleStateSetCoverageToColorOutput.</p>
<p>The coverage mask used for coverage-to-color reflects not only raster sample coverage, but also the results of per-fragment operations including other sample masks, alpha to coverage, alpha test, and the depth bounds, depth, and stencil tests.</p>
<dl class="section warning"><dt>Warning</dt><dd>When coverage-to-color is enabled, the color target receiving the coverage mask must have a one-component format with signed or unsigned integer components (e.g., R8I, R32UI). Coverage-to-color has no effect if other color target formats are used.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnMultisampleStateSetCoverageToColorEnable, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to set.</td></tr>
    <tr><td class="paramname">enable</td><td>Fragment coverage-to-color enable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0713e246ce816f781da8e21ab070194a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0713e246ce816f781da8e21ab070194a">&#9670;&nbsp;</a></span>nvnMultisampleStateGetCoverageToColorEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnMultisampleStateGetCoverageToColorEnable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the enable for the fragment coverage-to-color feature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad4293a2fa489afa5f8e0dd558dd2c129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4293a2fa489afa5f8e0dd558dd2c129">&#9670;&nbsp;</a></span>nvnMultisampleStateGetCoverageToColorEnable_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnMultisampleStateGetCoverageToColorEnable_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the enable for the fragment coverage-to-color feature. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnMultisampleStateGetCoverageToColorEnable, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga09d3ac530fffb5efaac50748ff4873f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09d3ac530fffb5efaac50748ff4873f9">&#9670;&nbsp;</a></span>nvnMultisampleStateSetCoverageToColorOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMultisampleStateSetCoverageToColorOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the color output updated by the fragment coverage-to-color feature. </p>
<p>When enabled using nvnMultisampleStateSetCoverageToColorEnable, the fragment coverage-to-color feature writes a coverage mask for each fragment into the red component of the fragment color for one color output. The color output number recieving the coverage mask is specified by nvnMultisampleStateSetCoverageToColorOutput.</p>
<p>The coverage mask used for coverage-to-color reflects not only raster sample coverage, but also the results of per-fragment operations including other sample masks, alpha to coverage, alpha test, and the depth bounds, depth, and stencil tests.</p>
<dl class="section warning"><dt>Warning</dt><dd>When coverage-to-color is enabled, the color target receiving the coverage mask must have a one-component format with signed or unsigned integer components (e.g., R8I, R32UI). Coverage-to-color has no effect if other color target formats are used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to update.</td></tr>
    <tr><td class="paramname">color</td><td>Color output number updated by the fragment coverage-to-color feature. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga51c0ef641afbcef76c82ae5a342057d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51c0ef641afbcef76c82ae5a342057d0">&#9670;&nbsp;</a></span>nvnMultisampleStateSetCoverageToColorOutput_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnMultisampleStateSetCoverageToColorOutput_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the color output updated by the fragment coverage-to-color feature. </p>
<p>Fastpath variant.</p>
<p>When enabled using nvnMultisampleStateSetCoverageToColorEnable, the fragment coverage-to-color feature writes a coverage mask for each fragment into the red component of the fragment color for one color output. The color output number recieving the coverage mask is specified by nvnMultisampleStateSetCoverageToColorOutput.</p>
<p>The coverage mask used for coverage-to-color reflects not only raster sample coverage, but also the results of per-fragment operations including other sample masks, alpha to coverage, alpha test, and the depth bounds, depth, and stencil tests.</p>
<dl class="section warning"><dt>Warning</dt><dd>When coverage-to-color is enabled, the color target receiving the coverage mask must have a one-component format with signed or unsigned integer components (e.g., R8I, R32UI). Coverage-to-color has no effect if other color target formats are used.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnMultisampleStateSetCoverageToColorOutput, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to update.</td></tr>
    <tr><td class="paramname">color</td><td>Color output number updated by the fragment coverage-to-color feature. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9e1d59807858c15163a9b4be1959b8e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e1d59807858c15163a9b4be1959b8e8">&#9670;&nbsp;</a></span>nvnMultisampleStateGetCoverageToColorOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnMultisampleStateGetCoverageToColorOutput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the color output updated by the fragment coverage-to-color feature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf2147839d3cd2c0a9359ef536f8980dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2147839d3cd2c0a9359ef536f8980dc">&#9670;&nbsp;</a></span>nvnMultisampleStateGetCoverageToColorOutput_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE int nvnMultisampleStateGetCoverageToColorOutput_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the color output updated by the fragment coverage-to-color feature. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnMultisampleStateGetCoverageToColorOutput, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga882228d131ff8d2ca6f0ba72d4a9182c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga882228d131ff8d2ca6f0ba72d4a9182c">&#9670;&nbsp;</a></span>nvnMultisampleStateSetSampleLocationsEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMultisampleStateSetSampleLocationsEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable programmable sample locations. </p>
<p>By default, rasterization in NVN uses a set of fixed sample locations based on the total number of raster samples. When programmable sample locations are enabled, rasterization instead uses a set of locations from the <a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object programmed using nvnMultisampleStateSetSampleLocations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to update.</td></tr>
    <tr><td class="paramname">enable</td><td>Enable/disable programmble sample locations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga058d52c5580ec2a084eebdae519f6757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga058d52c5580ec2a084eebdae519f6757">&#9670;&nbsp;</a></span>nvnMultisampleStateSetSampleLocationsEnable_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnMultisampleStateSetSampleLocationsEnable_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable programmable sample locations. </p>
<p>Fastpath variant.</p>
<p>By default, rasterization in NVN uses a set of fixed sample locations based on the total number of raster samples. When programmable sample locations are enabled, rasterization instead uses a set of locations from the <a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object programmed using nvnMultisampleStateSetSampleLocations.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnMultisampleStateSetSampleLocationsEnable, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to update.</td></tr>
    <tr><td class="paramname">enable</td><td>Enable/disable programmble sample locations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf91e203d2f30a7a960993c14826b3a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf91e203d2f30a7a960993c14826b3a2f">&#9670;&nbsp;</a></span>nvnMultisampleStateGetSampleLocationsEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnMultisampleStateGetSampleLocationsEnable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the programmable sample locations enable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6e266660a7c1aa3fb1aa800019924eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e266660a7c1aa3fb1aa800019924eaf">&#9670;&nbsp;</a></span>nvnMultisampleStateGetSampleLocationsEnable_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnMultisampleStateGetSampleLocationsEnable_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the programmable sample locations enable. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnMultisampleStateGetSampleLocationsEnable, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga41a34fd884435c3a3de1089633068740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41a34fd884435c3a3de1089633068740">&#9670;&nbsp;</a></span>nvnMultisampleStateGetSampleLocationsGrid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMultisampleStateGetSampleLocationsGrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the size of a pixel grid used for programmable sample locations. </p>
<p>When programmable sample locations are enabled, the rasterizer can use the same set of locations for each pixel, or use a different set of locations for each pixel in a small fixed-size grid, based on the enable set by nvnMultisampleStateSetSampleLocationsGridEnable. This function returns the width and height of the fixed-size grid used when enabled. The grid will have a total of 16/N pixels, where N is the total number of raster samples in the multisample state object. Please refer to the documentation of nvnMultisampleStateSetSampleLocations for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">width</td><td>Returns the width (in pixels) of the sample location pixel grid.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">height</td><td>Returns the height (in pixels) of the sample location pixel grid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga705b9946424e5f6e727adae9eae7ace5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga705b9946424e5f6e727adae9eae7ace5">&#9670;&nbsp;</a></span>nvnMultisampleStateSetSampleLocationsGridEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMultisampleStateSetSampleLocationsGridEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the programmable sample locations grid enable. </p>
<p>When programmable sample locations are enabled, the rasterizer can use the same set of locations for each pixel (disabled), or use a different set of locations for each pixel in a small fixed-size grid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to update.</td></tr>
    <tr><td class="paramname">enable</td><td>Enable or disable the programmble sample locations grid. If set to NVN_TRUE, different sample locations are used for each pixel in a fixed-size grid. If set to NVN_FALSE, the same locations are used for all pixels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gade1af4f73dc51c1d409a5bd7366c9cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade1af4f73dc51c1d409a5bd7366c9cc0">&#9670;&nbsp;</a></span>nvnMultisampleStateSetSampleLocationsGridEnable_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnMultisampleStateSetSampleLocationsGridEnable_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the programmable sample locations grid enable. </p>
<p>Fastpath variant.</p>
<p>When programmable sample locations are enabled, the rasterizer can use the same set of locations for each pixel (disabled), or use a different set of locations for each pixel in a small fixed-size grid.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnMultisampleStateSetSampleLocationsGridEnable, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to update.</td></tr>
    <tr><td class="paramname">enable</td><td>Enable or disable the programmble sample locations grid. If set to NVN_TRUE, different sample locations are used for each pixel in a fixed-size grid. If set to NVN_FALSE, the same locations are used for all pixels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga87e1af29088e21596f0e4d5744777498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87e1af29088e21596f0e4d5744777498">&#9670;&nbsp;</a></span>nvnMultisampleStateGetSampleLocationsGridEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnMultisampleStateGetSampleLocationsGridEnable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the programmable sample locations grid enable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga53c1fb5d3917bc019271764ee7f8b9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53c1fb5d3917bc019271764ee7f8b9ce">&#9670;&nbsp;</a></span>nvnMultisampleStateGetSampleLocationsGridEnable_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnMultisampleStateGetSampleLocationsGridEnable_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the programmable sample locations grid enable. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnMultisampleStateGetSampleLocationsGridEnable, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab91f126da720035da293ef8bd7f527b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab91f126da720035da293ef8bd7f527b1">&#9670;&nbsp;</a></span>nvnMultisampleStateSetSampleLocations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMultisampleStateSetSampleLocations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies programmable sample locations for rasterization. </p>
<p>When programmable sample locations are enabled using nvnMultisampleStateSetSampleLocationsEnable, rasterization uses a set of sample locations programmed in the multisample state object using this command. Each sample location is a pair of (x,y) values identifying the location of a sample within its pixel. The location of the origin (0.0, 0.0) follows the window origin mode, which is set by nvnDeviceSetWindowOriginMode.</p>
<p>The rasterizer may use the same sample locations for each pixel or varying sample locations within a repeating pixel grid, depending on state set using nvnMultisampleStateSetSampleLocationsGridEnable. If the pixel grid is disabled, a sample with index <em>s</em> in the pixel with coordinates (x,y) always uses entry <em>s</em> in the array of sample locations. If the pixel grid is enabled and the grid has a width and height of <em>gw</em> and <em>gh</em>, respectively, sample <em>s</em> in pixel (x,y) uses entry <em>s</em> + (<em>y</em> % <em>gh</em>) * <em>gw</em> + (<em>x</em> % <em>gw</em>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to update.</td></tr>
    <tr><td class="paramname">start</td><td>Index of the first sample location to update.</td></tr>
    <tr><td class="paramname">count</td><td>Number of sample locations to update.</td></tr>
    <tr><td class="paramname">values</td><td>Array of sample location value pairs. <em>values</em> is an array of 2 * <em>count</em> floating-point values, where each sample (x,y) location is specified using two values in the range [0.0, 1.0). The pair (0.5, 0.5) identifies the center of a pixel. Sample locations are converted to fixed-point values when the multisample state object is updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga47c2200da77cbb2c0d7279ecb9311525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47c2200da77cbb2c0d7279ecb9311525">&#9670;&nbsp;</a></span>nvnPolygonStateSetDefaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnPolygonStateSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_npolygon_state.html" title="API state object controlling rasterization of polygons.">NVNpolygonState</a> object. </p>
<dl class="section note"><dt>Note</dt><dd>This is semantically equivalent to calling</dd></dl>
<div class="fragment"><div class="line">PolygonState::SetCullFace(NVN_FACE_NONE);</div>
<div class="line">PolygonState::SetFrontFace(NVN_FRONT_FACE_CCW);</div>
<div class="line">PolygonState::SetPolygonMode(NVN_POLYGON_MODE_FILL);</div>
<div class="line">PolygonState::SetPolygonOffsetEnables(0);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td><a class="el" href="struct_n_v_npolygon_state.html" title="API state object controlling rasterization of polygons.">NVNpolygonState</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3520bbbee9b5089521912dacdbdbb4b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3520bbbee9b5089521912dacdbdbb4b6">&#9670;&nbsp;</a></span>nvnPolygonStateSetCullFace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnPolygonStateSetCullFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a>&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify controls for culling of front- and back-facing polygons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td><a class="el" href="struct_n_v_npolygon_state.html" title="API state object controlling rasterization of polygons.">NVNpolygonState</a> object to update.</td></tr>
    <tr><td class="paramname">face</td><td>Specifies the set of faces (if any) that should be cullled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga64be3472744af8c53ce8c54c292b4239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64be3472744af8c53ce8c54c292b4239">&#9670;&nbsp;</a></span>nvnPolygonStateSetCullFace_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnPolygonStateSetCullFace_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a>&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify controls for culling of front- and back-facing polygons. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnPolygonStateSetCullFace, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td><a class="el" href="struct_n_v_npolygon_state.html" title="API state object controlling rasterization of polygons.">NVNpolygonState</a> object to update.</td></tr>
    <tr><td class="paramname">face</td><td>Specifies the set of faces (if any) that should be cullled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0de647048323e5c7b6fe8d93a0875cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0de647048323e5c7b6fe8d93a0875cca">&#9670;&nbsp;</a></span>nvnPolygonStateSetFrontFace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnPolygonStateSetFrontFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga77dcac47ffba6330842afbc0c57db3c3">NVNfrontFace</a>&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify whether clockwise or counter-clockwise polygons are considered front-facing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td><a class="el" href="struct_n_v_npolygon_state.html" title="API state object controlling rasterization of polygons.">NVNpolygonState</a> object to update.</td></tr>
    <tr><td class="paramname">face</td><td>Treat clockwise (CW) or counter-clockwise (CCW) polygons as front-facing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa8f191f866a32315939c80ff1e895ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8f191f866a32315939c80ff1e895ce3">&#9670;&nbsp;</a></span>nvnPolygonStateSetFrontFace_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnPolygonStateSetFrontFace_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga77dcac47ffba6330842afbc0c57db3c3">NVNfrontFace</a>&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify whether clockwise or counter-clockwise polygons are considered front-facing. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnPolygonStateSetFrontFace, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td><a class="el" href="struct_n_v_npolygon_state.html" title="API state object controlling rasterization of polygons.">NVNpolygonState</a> object to update.</td></tr>
    <tr><td class="paramname">face</td><td>Treat clockwise (CW) or counter-clockwise (CCW) polygons as front-facing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae5d89993b3e9b7adcee98d5846052cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5d89993b3e9b7adcee98d5846052cb5">&#9670;&nbsp;</a></span>nvnPolygonStateSetPolygonMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnPolygonStateSetPolygonMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gae34b6e4f02d0dae7198337f940340ec6">NVNpolygonMode</a>&#160;</td>
          <td class="paramname"><em>polygonMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether polygons are rendered as points, lines, or triangles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td><a class="el" href="struct_n_v_npolygon_state.html" title="API state object controlling rasterization of polygons.">NVNpolygonState</a> object to update.</td></tr>
    <tr><td class="paramname">polygonMode</td><td>Render polygons as points (POINT), lines (LINE), or triangles (FILL). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2b14412334d7d0473ab10b4a7ae2f638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b14412334d7d0473ab10b4a7ae2f638">&#9670;&nbsp;</a></span>nvnPolygonStateSetPolygonMode_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnPolygonStateSetPolygonMode_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gae34b6e4f02d0dae7198337f940340ec6">NVNpolygonMode</a>&#160;</td>
          <td class="paramname"><em>polygonMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether polygons are rendered as points, lines, or triangles. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnPolygonStateSetPolygonMode, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td><a class="el" href="struct_n_v_npolygon_state.html" title="API state object controlling rasterization of polygons.">NVNpolygonState</a> object to update.</td></tr>
    <tr><td class="paramname">polygonMode</td><td>Render polygons as points (POINT), lines (LINE), or triangles (FILL). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5351a8bc94ba8da9a23a17d5e01ff2d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5351a8bc94ba8da9a23a17d5e01ff2d8">&#9670;&nbsp;</a></span>nvnPolygonStateSetPolygonOffsetEnables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnPolygonStateSetPolygonOffsetEnables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify whether polygon offset is applied for point-mode, line-mode, and filled polygons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td><a class="el" href="struct_n_v_npolygon_state.html" title="API state object controlling rasterization of polygons.">NVNpolygonState</a> object to update.</td></tr>
    <tr><td class="paramname">enables</td><td>Bitfield indicating whether polygon offset is applied for point-mode, line-mode, and filled polygons. See <a class="el" href="group__nvn__c__enum.html#ga04590c619164a552f5c23b8f096b3d73" title="Specifies whether the depth values of rasterized polygon primitives should be offset.">NVNpolygonOffsetEnable</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8bbd7972e1b1ed778eddbf09ff967b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bbd7972e1b1ed778eddbf09ff967b32">&#9670;&nbsp;</a></span>nvnPolygonStateGetCullFace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a> nvnPolygonStateGetCullFace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the control for culling of front- and back-facing polygons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td><a class="el" href="struct_n_v_npolygon_state.html" title="API state object controlling rasterization of polygons.">NVNpolygonState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga462e3ea6a04c604d1fd83a7ef7c4508c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga462e3ea6a04c604d1fd83a7ef7c4508c">&#9670;&nbsp;</a></span>nvnPolygonStateGetFrontFace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga77dcac47ffba6330842afbc0c57db3c3">NVNfrontFace</a> nvnPolygonStateGetFrontFace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether clockwise or counter-clockwise polygons are considered front-facing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td><a class="el" href="struct_n_v_npolygon_state.html" title="API state object controlling rasterization of polygons.">NVNpolygonState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac6b72dd688c4c3e432aacb9af6305520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6b72dd688c4c3e432aacb9af6305520">&#9670;&nbsp;</a></span>nvnPolygonStateGetPolygonMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#gae34b6e4f02d0dae7198337f940340ec6">NVNpolygonMode</a> nvnPolygonStateGetPolygonMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether polygons are rendered as points, lines, or triangles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td><a class="el" href="struct_n_v_npolygon_state.html" title="API state object controlling rasterization of polygons.">NVNpolygonState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga27a048c2d766c7f3f46f828eb9d963de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27a048c2d766c7f3f46f828eb9d963de">&#9670;&nbsp;</a></span>nvnPolygonStateGetPolygonOffsetEnables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga04590c619164a552f5c23b8f096b3d73">NVNpolygonOffsetEnable</a> nvnPolygonStateGetPolygonOffsetEnables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether polygon offset is applied for point-mode, line-mode, and filled polygons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td><a class="el" href="struct_n_v_npolygon_state.html" title="API state object controlling rasterization of polygons.">NVNpolygonState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2f659011ea2a0c713e64022959b865e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f659011ea2a0c713e64022959b865e2">&#9670;&nbsp;</a></span>nvnDepthStencilStateSetDefaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDepthStencilStateSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">NVNdepthStencilState</a> object. </p>
<dl class="section note"><dt>Note</dt><dd>This is semantically equivalent to calling</dd></dl>
<div class="fragment"><div class="line">DepthStencilState::SetDepthFunc(NVN_DEPTH_FUNC_LESS);</div>
<div class="line">DepthStencilState::SetDepthTestEnable(<a class="code" href="group__nvn__c__defines.html#gad12fb86930f09043843be6b39c78bb1b">NVN_FALSE</a>);</div>
<div class="line">DepthStencilState::SetDepthWriteEnable(<a class="code" href="group__nvn__c__defines.html#ga48151b7e768a13685d77d1a4c464a33b">NVN_TRUE</a>);</div>
<div class="line">DepthStencilState::SetStencilFunc(NVN_FACE_FRONT_AND_BACK,</div>
<div class="line">                                  NVN_STENCIL_FUNC_ALWAYS);</div>
<div class="line">DepthStencilState::SetStencilOp(NVN_FACE_FRONT_AND_BACK,</div>
<div class="line">  NVN_STENCIL_OP_KEEP, NVN_STENCIL_OP_KEEP, NVN_STENCIL_OP_KEEP);</div>
<div class="line">DepthStencilState::SetStencilTestEnable(<a class="code" href="group__nvn__c__defines.html#gad12fb86930f09043843be6b39c78bb1b">NVN_FALSE</a>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">NVNdepthStencilState</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8a0a2454a1b00a8889d1d34fd8a7da69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a0a2454a1b00a8889d1d34fd8a7da69">&#9670;&nbsp;</a></span>nvnDepthStencilStateSetDepthTestEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDepthStencilStateSetDepthTestEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify whether depth testing is enabled or disabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">NVNdepthStencilState</a> object to update.</td></tr>
    <tr><td class="paramname">enable</td><td>Enable (TRUE) or disable (FALSE) depth testing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4e04251e5e2f58570fede3774d347b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e04251e5e2f58570fede3774d347b75">&#9670;&nbsp;</a></span>nvnDepthStencilStateSetDepthTestEnable_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnDepthStencilStateSetDepthTestEnable_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify whether depth testing is enabled or disabled. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnDepthStencilStateSetDepthTestEnable, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">NVNdepthStencilState</a> object to update.</td></tr>
    <tr><td class="paramname">enable</td><td>Enable (TRUE) or disable (FALSE) depth testing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga363282d1d17b72e5553651d7b2c367cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga363282d1d17b72e5553651d7b2c367cf">&#9670;&nbsp;</a></span>nvnDepthStencilStateSetDepthWriteEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDepthStencilStateSetDepthWriteEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify whether the depth buffer should be updated by the depth test. </p>
<p>If depth testing is disabled, the depth buffer is not updated, regardless of the depth write enable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">NVNdepthStencilState</a> object to update.</td></tr>
    <tr><td class="paramname">enable</td><td>Enable (TRUE) or disable (FALSE) writes to the depth buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga72379cdc250746f376943f0188b606bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72379cdc250746f376943f0188b606bf">&#9670;&nbsp;</a></span>nvnDepthStencilStateSetDepthWriteEnable_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnDepthStencilStateSetDepthWriteEnable_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify whether the depth buffer should be updated by the depth test. </p>
<p>Fastpath variant.</p>
<p>If depth testing is disabled, the depth buffer is not updated, regardless of the depth write enable.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnDepthStencilStateSetDepthWriteEnable, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">NVNdepthStencilState</a> object to update.</td></tr>
    <tr><td class="paramname">enable</td><td>Enable (TRUE) or disable (FALSE) writes to the depth buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafdbe8e6bc4bfb62a304d831a919d9890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdbe8e6bc4bfb62a304d831a919d9890">&#9670;&nbsp;</a></span>nvnDepthStencilStateSetDepthFunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDepthStencilStateSetDepthFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga14f57c18bdbcc7517a24b723743e61e6">NVNdepthFunc</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the comparison function used when depth testing is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">NVNdepthStencilState</a> object to update.</td></tr>
    <tr><td class="paramname">func</td><td>Comparison function used when depth testing is enabled. If depth testing is disabled, the depth function has no effect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf0c842855708604f65d309bb0e8fdfc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0c842855708604f65d309bb0e8fdfc5">&#9670;&nbsp;</a></span>nvnDepthStencilStateSetDepthFunc_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnDepthStencilStateSetDepthFunc_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga14f57c18bdbcc7517a24b723743e61e6">NVNdepthFunc</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the comparison function used when depth testing is enabled. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnDepthStencilStateSetDepthFunc, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">NVNdepthStencilState</a> object to update.</td></tr>
    <tr><td class="paramname">func</td><td>Comparison function used when depth testing is enabled. If depth testing is disabled, the depth function has no effect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0127f672494691efb62b594091eeddee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0127f672494691efb62b594091eeddee">&#9670;&nbsp;</a></span>nvnDepthStencilStateSetStencilTestEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDepthStencilStateSetStencilTestEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify whether the stencil testing is enabled or disabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">NVNdepthStencilState</a> object to update.</td></tr>
    <tr><td class="paramname">enable</td><td>Enable (TRUE) or disable (FALSE) stencil testing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9a7785c775e7c533efa35b8562a6f826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a7785c775e7c533efa35b8562a6f826">&#9670;&nbsp;</a></span>nvnDepthStencilStateSetStencilTestEnable_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnDepthStencilStateSetStencilTestEnable_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify whether the stencil testing is enabled or disabled. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnDepthStencilStateSetStencilTestEnable, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">NVNdepthStencilState</a> object to update.</td></tr>
    <tr><td class="paramname">enable</td><td>Enable (TRUE) or disable (FALSE) stencil testing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa6c290c610aa9daf1a2ece3e18065e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6c290c610aa9daf1a2ece3e18065e32">&#9670;&nbsp;</a></span>nvnDepthStencilStateSetStencilFunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDepthStencilStateSetStencilFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a>&#160;</td>
          <td class="paramname"><em>faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gab50861ff9b46503782bb66c4edb734ae">NVNstencilFunc</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the comparison function used when stencil testing is enabled. </p>
<p>There are separate stencil functions for front- and back-facing primitives. This function can update the value of either or both functions in the <a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">NVNdepthStencilState</a> object. If stencil testing is disabled, the stencil function has no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">NVNdepthStencilState</a> object to update.</td></tr>
    <tr><td class="paramname">faces</td><td>Specifies the face(s) (front and/or back) using the new stencil function.</td></tr>
    <tr><td class="paramname">func</td><td>Comparison function used when stencil testing is enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga36095f921d11664dbe4b3139b8bf7793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36095f921d11664dbe4b3139b8bf7793">&#9670;&nbsp;</a></span>nvnDepthStencilStateSetStencilOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDepthStencilStateSetStencilOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a>&#160;</td>
          <td class="paramname"><em>faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gad3757d551ee48be48890aa243050e6ca">NVNstencilOp</a>&#160;</td>
          <td class="paramname"><em>fail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gad3757d551ee48be48890aa243050e6ca">NVNstencilOp</a>&#160;</td>
          <td class="paramname"><em>depthFail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gad3757d551ee48be48890aa243050e6ca">NVNstencilOp</a>&#160;</td>
          <td class="paramname"><em>depthPass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies operations performed on stored stencil values by the stencil test. </p>
<p>There are separate sets of stencil operations for front- and back-facing primitives. This function can update the value of either or both sets of operations in the <a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">NVNdepthStencilState</a> object. If stencil testing is disabled, the stencil operations have no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">NVNdepthStencilState</a> object to update.</td></tr>
    <tr><td class="paramname">faces</td><td>Specifies the face(s) (front and/or back) using the new stencil operations.</td></tr>
    <tr><td class="paramname">fail</td><td>Operation performed on the stencil value when the stencil test fails.</td></tr>
    <tr><td class="paramname">depthFail</td><td>Operation performed on the stencil value when the stencil test passes and the depth test fails.</td></tr>
    <tr><td class="paramname">depthPass</td><td>Operation performed on the stencil value when the stencil and depth tests pass. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0e0c9f60146ff3dce4ae5377e5dea5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e0c9f60146ff3dce4ae5377e5dea5df">&#9670;&nbsp;</a></span>nvnDepthStencilStateGetDepthTestEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnDepthStencilStateGetDepthTestEnable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether depth testing is enabled or disabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">NVNdepthStencilState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabdef5f8abe8f174129ae19e8480c48bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdef5f8abe8f174129ae19e8480c48bf">&#9670;&nbsp;</a></span>nvnDepthStencilStateGetDepthTestEnable_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnDepthStencilStateGetDepthTestEnable_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether depth testing is enabled or disabled. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnDepthStencilStateGetDepthTestEnable, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">NVNdepthStencilState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2dbfe16804066f2acf2127e1b36fadb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2dbfe16804066f2acf2127e1b36fadb3">&#9670;&nbsp;</a></span>nvnDepthStencilStateGetDepthWriteEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnDepthStencilStateGetDepthWriteEnable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether the depth buffer should be updated by the depth test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">NVNdepthStencilState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga86ef894acb9260d8a39e80fa67ab232d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86ef894acb9260d8a39e80fa67ab232d">&#9670;&nbsp;</a></span>nvnDepthStencilStateGetDepthWriteEnable_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnDepthStencilStateGetDepthWriteEnable_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether the depth buffer should be updated by the depth test. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnDepthStencilStateGetDepthWriteEnable, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">NVNdepthStencilState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga988a86f1527afdfb7cd08e79b5ac600a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga988a86f1527afdfb7cd08e79b5ac600a">&#9670;&nbsp;</a></span>nvnDepthStencilStateGetDepthFunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga14f57c18bdbcc7517a24b723743e61e6">NVNdepthFunc</a> nvnDepthStencilStateGetDepthFunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the comparison function used when depth testing is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">NVNdepthStencilState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga22358a58ee07fdefd11993f6929ac9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22358a58ee07fdefd11993f6929ac9d7">&#9670;&nbsp;</a></span>nvnDepthStencilStateGetStencilTestEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnDepthStencilStateGetStencilTestEnable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether the stencil testing is enabled or disabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">NVNdepthStencilState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabf6468c3bdfd26790e0c535d22fa0b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf6468c3bdfd26790e0c535d22fa0b97">&#9670;&nbsp;</a></span>nvnDepthStencilStateGetStencilTestEnable_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnDepthStencilStateGetStencilTestEnable_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether the stencil testing is enabled or disabled. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnDepthStencilStateGetStencilTestEnable, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">NVNdepthStencilState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga11ef77b998e4d4ca6bff2e8721a18ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11ef77b998e4d4ca6bff2e8721a18ae7">&#9670;&nbsp;</a></span>nvnDepthStencilStateGetStencilFunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#gab50861ff9b46503782bb66c4edb734ae">NVNstencilFunc</a> nvnDepthStencilStateGetStencilFunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a>&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the comparison function used when stencil testing is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">NVNdepthStencilState</a> object to query.</td></tr>
    <tr><td class="paramname">face</td><td>Specifies the face (front or back) to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf1f44de3d7815edec84bc5773e4bf6b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1f44de3d7815edec84bc5773e4bf6b7">&#9670;&nbsp;</a></span>nvnDepthStencilStateGetStencilOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDepthStencilStateGetStencilOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gad3757d551ee48be48890aa243050e6ca">NVNstencilOp</a> *&#160;</td>
          <td class="paramname"><em>fail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gad3757d551ee48be48890aa243050e6ca">NVNstencilOp</a> *&#160;</td>
          <td class="paramname"><em>depthFail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gad3757d551ee48be48890aa243050e6ca">NVNstencilOp</a> *&#160;</td>
          <td class="paramname"><em>depthPass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query operations performed on stored stencil values by the stencil test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">NVNdepthStencilState</a> object to query.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">face</td><td>Specifies the face (front or back) to query the stencil operations.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fail</td><td>Operation performed on the stencil value when the stencil test fails.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">depthFail</td><td>Operation performed on the stencil value when the stencil test passes and the depth test fails.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">depthPass</td><td>Operation performed on the stencil value when the stencil and depth tests pass. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8e71254f0f8cd7eb8fa2aa8e8909779f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e71254f0f8cd7eb8fa2aa8e8909779f">&#9670;&nbsp;</a></span>nvnVertexAttribStateSetDefaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnVertexAttribStateSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nvertex_attrib_state.html">NVNvertexAttribState</a> *&#160;</td>
          <td class="paramname"><em>attrib</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_nvertex_attrib_state.html" title="API state object controlling vertex attrib state.">NVNvertexAttribState</a> object. </p>
<dl class="section note"><dt>Note</dt><dd>This is semantically equivalent to calling</dd></dl>
<div class="fragment"><div class="line">VertexAttribState::SetFormat(NVN_FORMAT_NONE, 0);</div>
<div class="line">VertexAttribState::SetStreamIndex(0);</div>
</div><!-- fragment --><p>except that the object will be disabled until the first valid call to <a class="el" href="group__nvn__c__functions.html#ga447b6bbe81e21c3bff3dbf10bc15d80e" title="Specifies the format (in memory) for values for a single vertex attribute.">nvnVertexAttribStateSetFormat()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrib</td><td><a class="el" href="struct_n_v_nvertex_attrib_state.html" title="API state object controlling vertex attrib state.">NVNvertexAttribState</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga447b6bbe81e21c3bff3dbf10bc15d80e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga447b6bbe81e21c3bff3dbf10bc15d80e">&#9670;&nbsp;</a></span>nvnVertexAttribStateSetFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnVertexAttribStateSetFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nvertex_attrib_state.html">NVNvertexAttribState</a> *&#160;</td>
          <td class="paramname"><em>attrib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>relativeOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the format (in memory) for values for a single vertex attribute. </p>
<p>Specifying format is mandatory, and doing so also enables the vertex attribute for fetching.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrib</td><td><a class="el" href="struct_n_v_nvertex_attrib_state.html" title="API state object controlling vertex attrib state.">NVNvertexAttribState</a> object to update.</td></tr>
    <tr><td class="paramname">format</td><td><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab" title="Identifies how data elements stored in texture or buffer objects are encoded.">NVNformat</a> of the specified vertex attribute.</td></tr>
    <tr><td class="paramname">relativeOffset</td><td>Offset (in bytes) of the values for the vertex attribute relative to the base address from the vertex buffer binding. Must be greater than or equal to zero. Must be less than or equal to 16383 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50af0f318cc7301350740c3b6281e59abba" title="Maximum allowed relative offset in bytes for the vertex attribute from the base address for the verte...">NVN_DEVICE_INFO_VERTEX_ATTRIBUTE_STATE_MAXIMUM_RELATIVE_OFFSET</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab96f74226c1d22d01c186d908eff14ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab96f74226c1d22d01c186d908eff14ab">&#9670;&nbsp;</a></span>nvnVertexAttribStateSetStreamIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnVertexAttribStateSetStreamIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nvertex_attrib_state.html">NVNvertexAttribState</a> *&#160;</td>
          <td class="paramname"><em>attrib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>streamIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the vertex attribute stream binding index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrib</td><td><a class="el" href="struct_n_v_nvertex_attrib_state.html" title="API state object controlling vertex attrib state.">NVNvertexAttribState</a> object to update.</td></tr>
    <tr><td class="paramname">streamIndex</td><td>Index of the stream to use for the attribute. Must be less than 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a571496d1d44d5215d5023b1c8603c84f" title="Number of vertex buffer binding points.">NVN_DEVICE_INFO_VERTEX_BUFFER_BINDINGS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga08293b7f6f1efa4341d3f369e44f6384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08293b7f6f1efa4341d3f369e44f6384">&#9670;&nbsp;</a></span>nvnVertexAttribStateSetStreamIndex_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnVertexAttribStateSetStreamIndex_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nvertex_attrib_state.html">NVNvertexAttribState</a> *&#160;</td>
          <td class="paramname"><em>attrib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>streamIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the vertex attribute stream binding index. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnVertexAttribStateSetStreamIndex, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrib</td><td><a class="el" href="struct_n_v_nvertex_attrib_state.html" title="API state object controlling vertex attrib state.">NVNvertexAttribState</a> object to update.</td></tr>
    <tr><td class="paramname">streamIndex</td><td>Index of the stream to use for the attribute. Must be less than 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a571496d1d44d5215d5023b1c8603c84f" title="Number of vertex buffer binding points.">NVN_DEVICE_INFO_VERTEX_BUFFER_BINDINGS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9ff90c3673688217dba1c0cb18084031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ff90c3673688217dba1c0cb18084031">&#9670;&nbsp;</a></span>nvnVertexAttribStateGetFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnVertexAttribStateGetFormat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nvertex_attrib_state.html">NVNvertexAttribState</a> *&#160;</td>
          <td class="paramname"><em>attrib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a> *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t *&#160;</td>
          <td class="paramname"><em>relativeOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the format (in memory) for values for a single vertex attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">attrib</td><td><a class="el" href="struct_n_v_nvertex_attrib_state.html" title="API state object controlling vertex attrib state.">NVNvertexAttribState</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">format</td><td><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab" title="Identifies how data elements stored in texture or buffer objects are encoded.">NVNformat</a> of the specified vertex attribute.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">relativeOffset</td><td>Offset (in bytes) of the values for the vertex attribute relative to the base address from the vertex buffer binding. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6633a58ae913e3de782d0d2af524e2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6633a58ae913e3de782d0d2af524e2f7">&#9670;&nbsp;</a></span>nvnVertexAttribStateGetStreamIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnVertexAttribStateGetStreamIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nvertex_attrib_state.html">NVNvertexAttribState</a> *&#160;</td>
          <td class="paramname"><em>attrib</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the vertex attribute stream binding index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrib</td><td><a class="el" href="struct_n_v_nvertex_attrib_state.html" title="API state object controlling vertex attrib state.">NVNvertexAttribState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad884328996e09c2ff153a14a86fc08cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad884328996e09c2ff153a14a86fc08cb">&#9670;&nbsp;</a></span>nvnVertexAttribStateGetStreamIndex_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE int nvnVertexAttribStateGetStreamIndex_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nvertex_attrib_state.html">NVNvertexAttribState</a> *&#160;</td>
          <td class="paramname"><em>attrib</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the vertex attribute stream binding index. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnVertexAttribStateGetStreamIndex, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrib</td><td><a class="el" href="struct_n_v_nvertex_attrib_state.html" title="API state object controlling vertex attrib state.">NVNvertexAttribState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9dca0133939bd660957dd5de2a56d240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9dca0133939bd660957dd5de2a56d240">&#9670;&nbsp;</a></span>nvnVertexStreamStateSetDefaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnVertexStreamStateSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state.">NVNvertexStreamState</a> object. </p>
<dl class="section note"><dt>Note</dt><dd>This is semantically equivalent to calling</dd></dl>
<div class="fragment"><div class="line">VertexStreamState::SetDivisor(0);</div>
<div class="line">VertexStreamState::SetStride(0);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td><a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state.">NVNvertexStreamState</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9a72c7499ec4a36d8cc38d0b5d575c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a72c7499ec4a36d8cc38d0b5d575c90">&#9670;&nbsp;</a></span>nvnVertexStreamStateSetStride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnVertexStreamStateSetStride </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the stride (in bytes) for vertex attribute records fetched from a single vertex binding point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td><a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state.">NVNvertexStreamState</a> object to update.</td></tr>
    <tr><td class="paramname">stride</td><td>Stride (in bytes) between vertex attribute records for the specified binding point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab657c9c5139919b7141e22888676f8c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab657c9c5139919b7141e22888676f8c8">&#9670;&nbsp;</a></span>nvnVertexStreamStateSetStride_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnVertexStreamStateSetStride_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the stride (in bytes) for vertex attribute records fetched from a single vertex binding point. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnVertexStreamStateSetStride, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td><a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state.">NVNvertexStreamState</a> object to update.</td></tr>
    <tr><td class="paramname">stride</td><td>Stride (in bytes) between vertex attribute records for the specified binding point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac6f8d41933935967cde1cadcc328c8da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6f8d41933935967cde1cadcc328c8da">&#9670;&nbsp;</a></span>nvnVertexStreamStateSetDivisor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnVertexStreamStateSetDivisor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the frequency divisor for vertices in vertex binding N. </p>
<p>If zero, specifies that the vertex binding holds a separate set of values for each vertex in a rendered primitive. If set to a non-zero value X, a separate set of values will be used for each group of X instances, with the same set of values used for each vertex in a single instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td><a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state.">NVNvertexStreamState</a> object to update.</td></tr>
    <tr><td class="paramname">divisor</td><td>Frequency divisor for vertex attributes using the specified binding point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga57ffd7e1095dd1d535c98b794eeca8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57ffd7e1095dd1d535c98b794eeca8c1">&#9670;&nbsp;</a></span>nvnVertexStreamStateSetDivisor_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnVertexStreamStateSetDivisor_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the frequency divisor for vertices in vertex binding N. </p>
<p>Fastpath variant.</p>
<p>If zero, specifies that the vertex binding holds a separate set of values for each vertex in a rendered primitive. If set to a non-zero value X, a separate set of values will be used for each group of X instances, with the same set of values used for each vertex in a single instance.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnVertexStreamStateSetDivisor, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td><a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state.">NVNvertexStreamState</a> object to update.</td></tr>
    <tr><td class="paramname">divisor</td><td>Frequency divisor for vertex attributes using the specified binding point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaebbf25d7f5c74f49b0b3635d3f8d78bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebbf25d7f5c74f49b0b3635d3f8d78bc">&#9670;&nbsp;</a></span>nvnVertexStreamStateGetStride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t nvnVertexStreamStateGetStride </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the stride (in bytes) for a <a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state.">NVNvertexStreamState</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td><a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state.">NVNvertexStreamState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac11f8cb40f347008360d15388925c016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac11f8cb40f347008360d15388925c016">&#9670;&nbsp;</a></span>nvnVertexStreamStateGetStride_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE ptrdiff_t nvnVertexStreamStateGetStride_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the stride (in bytes) for a <a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state.">NVNvertexStreamState</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnVertexStreamStateGetStride, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td><a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state.">NVNvertexStreamState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3a99fed1a389e1a231314215842674e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a99fed1a389e1a231314215842674e9">&#9670;&nbsp;</a></span>nvnVertexStreamStateGetDivisor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnVertexStreamStateGetDivisor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the frequency divisor in a <a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state.">NVNvertexStreamState</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td><a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state.">NVNvertexStreamState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadbb6bbc19b8a311d81e4000afc30e2d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbb6bbc19b8a311d81e4000afc30e2d1">&#9670;&nbsp;</a></span>nvnVertexStreamStateGetDivisor_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE int nvnVertexStreamStateGetDivisor_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the frequency divisor in a <a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state.">NVNvertexStreamState</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnVertexStreamStateGetDivisor, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td><a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state.">NVNvertexStreamState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab146b70a699dfee69d0724e430d5694e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab146b70a699dfee69d0724e430d5694e">&#9670;&nbsp;</a></span>nvnCommandBufferInitialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnCommandBufferInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object for the specified device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Commandbuffer object to initialize.</td></tr>
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> owning the <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga014c41d2335d4d9ff6c776c99bc70bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga014c41d2335d4d9ff6c776c99bc70bfb">&#9670;&nbsp;</a></span>nvnCommandBufferFinalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferFinalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object to finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3ecae66d8ac5f623d7a1abae492fc243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ecae66d8ac5f623d7a1abae492fc243">&#9670;&nbsp;</a></span>nvnCommandBufferSetDebugLabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetDebugLabel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debug label string for a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object. </p>
<p>Annotates a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object with a descriptive text label. This label may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object to set debug label.</td></tr>
    <tr><td class="paramname">label</td><td>Text string used to annotate the <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga69eb92c349d648988d02b9b7a7a94a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69eb92c349d648988d02b9b7a7a94a75">&#9670;&nbsp;</a></span>nvnCommandBufferSetMemoryCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetMemoryCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__funcptrs.html#gac2d9ed5522cd4167d6a59f16d379bb1c">PFNNVNCOMMANDBUFFERMEMORYCALLBACKPROC</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a callback function for a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object that will be called if it runs out of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object to update.</td></tr>
    <tr><td class="paramname">callback</td><td>Callback function to use on out-of-memory events. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8656f3468c263124963216458569ec07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8656f3468c263124963216458569ec07">&#9670;&nbsp;</a></span>nvnCommandBufferSetMemoryCallbackData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetMemoryCallbackData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a generic pointer that will be passed to a callback function if the command buffer runs out of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object to update.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">callbackData</td><td>Callback data to be passed in an out-of-memory event callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad359cbb0a01f7d1cb280166880155ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad359cbb0a01f7d1cb280166880155ae0">&#9670;&nbsp;</a></span>nvnCommandBufferSetCommandMemoryCallbackEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetCommandMemoryCallbackEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the memory callback when out of command memory. </p>
<p>If a sequence of commands is known to fit within allocated command memory, applications can prevent the driver from conservatively invoking the out-of-memory callback when previously allocated command memory is nearly exhausted. This function does not affect behavior related to control memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object to update.</td></tr>
    <tr><td class="paramname">enabled</td><td>True (default) if the out-of-memory callback should be enabled; false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga95e185dafd114395bdc8d8111f3511ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95e185dafd114395bdc8d8111f3511ef">&#9670;&nbsp;</a></span>nvnCommandBufferSetCommandMemoryCallbackEnabled_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnCommandBufferSetCommandMemoryCallbackEnabled_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the memory callback when out of command memory. </p>
<p>Fastpath variant.</p>
<p>If a sequence of commands is known to fit within allocated command memory, applications can prevent the driver from conservatively invoking the out-of-memory callback when previously allocated command memory is nearly exhausted. This function does not affect behavior related to control memory.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnCommandBufferSetCommandMemoryCallbackEnabled, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object to update.</td></tr>
    <tr><td class="paramname">enabled</td><td>True (default) if the out-of-memory callback should be enabled; false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2c0d758cfa73c25f2a34486353f46d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c0d758cfa73c25f2a34486353f46d92">&#9670;&nbsp;</a></span>nvnCommandBufferAddCommandMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferAddCommandMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add command data memory for a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object. </p>
<p>This can be called at any time, even outside an out-of-memory callback or while recording or not recording. Any leftover space in the previous command memory will remain unused. Only the last provided block is consumed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object to update.</td></tr>
    <tr><td class="paramname">pool</td><td>Memory pool used to store commands.</td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) relative to pool of the memory used to store commands. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ada72f2b5ef4df11606b61aaa86f6f22c" title="Minimum alignment for command data in a command builder.">NVN_DEVICE_INFO_COMMAND_BUFFER_COMMAND_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of memory used to store commands. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ada72f2b5ef4df11606b61aaa86f6f22c" title="Minimum alignment for command data in a command builder.">NVN_DEVICE_INFO_COMMAND_BUFFER_COMMAND_ALIGNMENT</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8de6ce290ee0180d9bcd700c1d08d0bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8de6ce290ee0180d9bcd700c1d08d0bf">&#9670;&nbsp;</a></span>nvnCommandBufferAddControlMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferAddControlMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add control memory for a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object. </p>
<p>This can be called at any time, even outside an out-of-memory callback or while recording or not recording. Any leftover space in the previous control memory will remain unused. Only the last provided block is consumed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object to update.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">memory</td><td>Storage used for the command buffer control information. Must be a multiple of 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a743ea42e337a76b9d8ed34181a0d802e" title="Minimum alignment for control data in a command builder.">NVN_DEVICE_INFO_COMMAND_BUFFER_CONTROL_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">size</td><td>Size (in bytes) of memory used to store control information. Must be a multiple of 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a743ea42e337a76b9d8ed34181a0d802e" title="Minimum alignment for control data in a command builder.">NVN_DEVICE_INFO_COMMAND_BUFFER_CONTROL_ALIGNMENT</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7c33bb9cd401c44be336bdcb915d9e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c33bb9cd401c44be336bdcb915d9e70">&#9670;&nbsp;</a></span>nvnCommandBufferGetCommandMemorySize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnCommandBufferGetCommandMemorySize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total size in bytes of the command memory block that was lastly added to the <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a>. </p>
<p>Please see the <a class="el" href="nvn_index.html#nvn_guide_command_buffer_memory_management">Command NVNbuffer Memory Management</a> section of the NVN Programming Guide for further detail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7976af012dd82485da7127beca93e2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7976af012dd82485da7127beca93e2ff">&#9670;&nbsp;</a></span>nvnCommandBufferGetCommandMemoryUsed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnCommandBufferGetCommandMemoryUsed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the used size in bytes of the command memory block that was lastly added to the <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a>. </p>
<p>Please see the <a class="el" href="nvn_index.html#nvn_guide_command_buffer_memory_management">Command NVNbuffer Memory Management</a> section of the NVN Programming Guide for further detail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga211e559b84b562b34d26b809a9316ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga211e559b84b562b34d26b809a9316ff2">&#9670;&nbsp;</a></span>nvnCommandBufferGetCommandMemoryFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnCommandBufferGetCommandMemoryFree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the unused size in bytes of the command memory block that was lastly added to the <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a>. </p>
<p>Please see the <a class="el" href="nvn_index.html#nvn_guide_command_buffer_memory_management">Command NVNbuffer Memory Management</a> section of the NVN Programming Guide for further detail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga93c82ac4fededbf48d55179b57248de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93c82ac4fededbf48d55179b57248de7">&#9670;&nbsp;</a></span>nvnCommandBufferGetControlMemorySize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnCommandBufferGetControlMemorySize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total size in bytes of the control memory block that was lastly added to the <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a>. </p>
<p>Please see the <a class="el" href="nvn_index.html#nvn_guide_command_buffer_memory_management">Command NVNbuffer Memory Management</a> section of the NVN Programming Guide for further detail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaef36338c2d889d846bf1fbbe3efd25df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef36338c2d889d846bf1fbbe3efd25df">&#9670;&nbsp;</a></span>nvnCommandBufferGetControlMemoryUsed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnCommandBufferGetControlMemoryUsed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the used size in bytes of the control memory block that was lastly added to the <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a>. </p>
<p>Please see the <a class="el" href="nvn_index.html#nvn_guide_command_buffer_memory_management">Command NVNbuffer Memory Management</a> section of the NVN Programming Guide for further detail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3fe9b2e839389d1a7396b54edb86ca77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fe9b2e839389d1a7396b54edb86ca77">&#9670;&nbsp;</a></span>nvnCommandBufferGetControlMemoryFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnCommandBufferGetControlMemoryFree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the unused size in bytes of the control memory block that was lastly added to the <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a>. </p>
<p>Please see the <a class="el" href="nvn_index.html#nvn_guide_command_buffer_memory_management">Command NVNbuffer Memory Management</a> section of the NVN Programming Guide for further detail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeb763d2bdad2c058c75802190fef4748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb763d2bdad2c058c75802190fef4748">&#9670;&nbsp;</a></span>nvnCommandBufferBeginRecording()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBeginRecording </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin recording a new set of commands in this <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object used for command buffer construction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1d414ebb37bc0583da4929b13b1259cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d414ebb37bc0583da4929b13b1259cf">&#9670;&nbsp;</a></span>nvnCommandBufferBeginRecording_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnCommandBufferBeginRecording_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin recording a new set of commands in this <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnCommandBufferBeginRecording, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object used for command buffer construction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7d97d4cbf72259b6e867f3080f223b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d97d4cbf72259b6e867f3080f223b95">&#9670;&nbsp;</a></span>nvnCommandBufferEndRecording()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a> nvnCommandBufferEndRecording </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complete recording a new set of commands in this <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object used for command buffer construction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf2ce6552ebb6a5dd259aecc7a2cf53e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2ce6552ebb6a5dd259aecc7a2cf53e4">&#9670;&nbsp;</a></span>nvnCommandBufferCallCommands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferCallCommands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numCommands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a> *&#160;</td>
          <td class="paramname"><em>handles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert calls to previously recorded command sets into the command set under construction. </p>
<p>CallCommands will copy control data from the previously recorded command sets into the new command set. Command data from these command sets are called directly. The command buffer under construction must hold sufficient memory to hold the control data. The command data from called command sets must not be freed until all command sets referencing the data are no longer in use. The command data in the called command sets should be recorded in a memory pool using <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a93f5342f52f301cfdca9901586b9b8e1" title="Indicates that the memory pool will be accessed by the CPU without caching.">NVN_MEMORY_POOL_FLAGS_CPU_UNCACHED_BIT</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer recording the command set that should call the previously recorded command sets.</td></tr>
    <tr><td class="paramname">numCommands</td><td>Number of command sets to call.</td></tr>
    <tr><td class="paramname">handles</td><td>Array of numCommands command set handles to call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8c8a0ae87c2636ee5541d6c1a46c9e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c8a0ae87c2636ee5541d6c1a46c9e50">&#9670;&nbsp;</a></span>nvnCommandBufferCallCommands_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnCommandBufferCallCommands_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numCommands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a> *&#160;</td>
          <td class="paramname"><em>handles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert calls to previously recorded command sets into the command set under construction. </p>
<p>Fastpath variant.</p>
<p>CallCommands will copy control data from the previously recorded command sets into the new command set. Command data from these command sets are called directly. The command buffer under construction must hold sufficient memory to hold the control data. The command data from called command sets must not be freed until all command sets referencing the data are no longer in use. The command data in the called command sets should be recorded in a memory pool using <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a93f5342f52f301cfdca9901586b9b8e1" title="Indicates that the memory pool will be accessed by the CPU without caching.">NVN_MEMORY_POOL_FLAGS_CPU_UNCACHED_BIT</a>.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnCommandBufferCallCommands, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer recording the command set that should call the previously recorded command sets.</td></tr>
    <tr><td class="paramname">numCommands</td><td>Number of command sets to call.</td></tr>
    <tr><td class="paramname">handles</td><td>Array of numCommands command set handles to call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad11b2ce112a68a88c10dedebae6cd73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad11b2ce112a68a88c10dedebae6cd73f">&#9670;&nbsp;</a></span>nvnCommandBufferCopyCommands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferCopyCommands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numCommands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a> *&#160;</td>
          <td class="paramname"><em>handles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert copies of previously recorded command sets into the command set under construction. </p>
<p>CopyCommands will copy command and control data from the previously recorded command sets into the new command set. The command buffer must hold sufficient memory to hold the copied data. The command data in the called command sets should be recorded in a memory pool using <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a2fa7e2b859d94d1dc2c7077822b46f83" title="Indicates that the memory pool will be accessed by the CPU with caching.">NVN_MEMORY_POOL_FLAGS_CPU_CACHED_BIT</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer recording the command set that should copy the previously recorded command sets.</td></tr>
    <tr><td class="paramname">numCommands</td><td>Number of command sets to copy.</td></tr>
    <tr><td class="paramname">handles</td><td>Array of numCommands command set handles to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae567923c05099ece28c0a72f7e5a7b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae567923c05099ece28c0a72f7e5a7b95">&#9670;&nbsp;</a></span>nvnCommandBufferBindBlendState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindBlendState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a new <a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object to bind for subsequent commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the bind operation.</td></tr>
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target.">NVNblendState</a> object to be bound. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae4e79d1982d0459fe3f052464d722135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4e79d1982d0459fe3f052464d722135">&#9670;&nbsp;</a></span>nvnCommandBufferBindChannelMaskState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindChannelMaskState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_nchannel_mask_state.html">NVNchannelMaskState</a> *&#160;</td>
          <td class="paramname"><em>channelMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a new <a class="el" href="struct_n_v_nchannel_mask_state.html" title="API state object holding per-channel write masks for all color buffers.">NVNchannelMaskState</a> object to bind for subsequent commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the bind operation.</td></tr>
    <tr><td class="paramname">channelMask</td><td><a class="el" href="struct_n_v_nchannel_mask_state.html" title="API state object holding per-channel write masks for all color buffers.">NVNchannelMaskState</a> object to be bound. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga43d6d532c48207186945d010043d5b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43d6d532c48207186945d010043d5b44">&#9670;&nbsp;</a></span>nvnCommandBufferBindColorState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindColorState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a new <a class="el" href="struct_n_v_ncolor_state.html" title="API state object controlling processing of color values.">NVNcolorState</a> object to bind for subsequent commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">color</td><td><a class="el" href="struct_n_v_ncolor_state.html" title="API state object controlling processing of color values.">NVNcolorState</a> object to be bound. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga557044ccfe0956a4a5e0accbff24680d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga557044ccfe0956a4a5e0accbff24680d">&#9670;&nbsp;</a></span>nvnCommandBufferBindMultisampleState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindMultisampleState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a new <a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to bind for subsequent commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing.">NVNmultisampleState</a> object to be bound. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4eaf64e9a465e7a751bba9a15d3b4959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4eaf64e9a465e7a751bba9a15d3b4959">&#9670;&nbsp;</a></span>nvnCommandBufferBindPolygonState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindPolygonState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *&#160;</td>
          <td class="paramname"><em>polygon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a new <a class="el" href="struct_n_v_npolygon_state.html" title="API state object controlling rasterization of polygons.">NVNpolygonState</a> object to bind for subsequent commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">polygon</td><td><a class="el" href="struct_n_v_npolygon_state.html" title="API state object controlling rasterization of polygons.">NVNpolygonState</a> object to be bound. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga38fb4b53978713545ee59f17dcbeb19f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38fb4b53978713545ee59f17dcbeb19f">&#9670;&nbsp;</a></span>nvnCommandBufferBindDepthStencilState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindDepthStencilState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a new <a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">NVNdepthStencilState</a> object to bind for subsequent commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">NVNdepthStencilState</a> object to be bound. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacfabe6cc1b10a74cf521ec26b8f7ee7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfabe6cc1b10a74cf521ec26b8f7ee7f">&#9670;&nbsp;</a></span>nvnCommandBufferBindVertexAttribState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindVertexAttribState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numAttribs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_nvertex_attrib_state.html">NVNvertexAttribState</a> *&#160;</td>
          <td class="paramname"><em>attribs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a vertex attribute layout for subsequent commands. </p>
<p>All attributes beyond <em>numAttribs</em> are disabled, and fetching from them in the shader will return zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">numAttribs</td><td>Number of vertex attributes to bind. Must be less than or equal to 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a09de36a611cb7c5512ec623eb29684a7" title="Number of vertex attributes.">NVN_DEVICE_INFO_VERTEX_ATTRIBUTES</a>).</td></tr>
    <tr><td class="paramname">attribs</td><td><a class="el" href="struct_n_v_nvertex_attrib_state.html" title="API state object controlling vertex attrib state.">NVNvertexAttribState</a> objects to be bound. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad8667c7a6dad506aa2eb54370c67b2b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8667c7a6dad506aa2eb54370c67b2b1">&#9670;&nbsp;</a></span>nvnCommandBufferBindVertexStreamState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindVertexStreamState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numStreams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *&#160;</td>
          <td class="paramname"><em>streams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a vertex stream layout for subsequent commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">numStreams</td><td>Number of vertex streams to bind. Must be less than or equal to 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a571496d1d44d5215d5023b1c8603c84f" title="Number of vertex buffer binding points.">NVN_DEVICE_INFO_VERTEX_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">streams</td><td><a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state.">NVNvertexStreamState</a> objects to be bound. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1f4b9d505338994b172c814ed32565c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f4b9d505338994b172c814ed32565c8">&#9670;&nbsp;</a></span>nvnCommandBufferBindProgram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindProgram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stages</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind or unbind shaders in a <a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives.">NVNprogram</a> object for subsequent rendering commands. </p>
<p>This command binds all shaders present in <em>program</em>, and optionally disables additional shader stages based on the bitfield <em>stages</em>. If <em>program</em> is NULL, all shader stages specified in the bitfield <em>stages</em> are disabled. If <em>program</em> is non-NULL, all shaders present in <em>program</em> will be bound and any stages in <em>stages</em> that don't have shaders in <em>program</em> are disabled. For example, using <a class="el" href="group__nvn__c__enum.html#ggab5a02ce3ef6a80ad09e574e4e6791afaa9134531cb00eb495c3c2866a4bc216a5" title="Specifies all shader stages used to process graphics primitives.">NVN_SHADER_STAGE_ALL_GRAPHICS_BITS</a> with a program with only a vertex and fragment shader will bind the vertex and fragment shaders in the program and disable the optional tessellation control, tessellation evaluation, and geometry shader stages.</p>
<dl class="section warning"><dt>Warning</dt><dd>When <em>program</em> is non-NULL, all stages present in <em>program</em> must be enabled in the bitfield <em>stages</em>.</dd>
<dd>
In the C interface, it is possible to pass enums of the type NVNshaderStage (NVN_VERTEX_SHADER) in <em>stages</em>. This is not legal; <em>stages</em> requires a bitfield built from values of type NVNshaderStageBits (NVN_VERTEX_SHADER_BIT).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">program</td><td><a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives.">NVNprogram</a> object to be bound.</td></tr>
    <tr><td class="paramname">stages</td><td>Bitfield identifying the set of shader stages to be updated. See <a class="el" href="group__nvn__c__enum.html#gab5a02ce3ef6a80ad09e574e4e6791afa" title="Specifies a set of programmable shader stages.">NVNshaderStageBits</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga328bba22810a4467865b444d17bec8e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga328bba22810a4467865b444d17bec8e9">&#9670;&nbsp;</a></span>nvnCommandBufferBindVertexBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindVertexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a range of a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object to use for fetching vertex attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">index</td><td>Vertex buffer binding point number to update. Must be less than 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a571496d1d44d5215d5023b1c8603c84f" title="Number of vertex buffer binding points.">NVN_DEVICE_INFO_VERTEX_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of vertex buffer memory to bind.</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the range of the <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad1ac45527dfdfaaf891af2d95487ac91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1ac45527dfdfaaf891af2d95487ac91">&#9670;&nbsp;</a></span>nvnCommandBufferBindVertexBuffer_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnCommandBufferBindVertexBuffer_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a range of a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object to use for fetching vertex attributes. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnCommandBufferBindVertexBuffer, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">index</td><td>Vertex buffer binding point number to update. Must be less than 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a571496d1d44d5215d5023b1c8603c84f" title="Number of vertex buffer binding points.">NVN_DEVICE_INFO_VERTEX_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of vertex buffer memory to bind.</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the range of the <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabbcfc19ae3f372f59ae4db3be11dc9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbcfc19ae3f372f59ae4db3be11dc9e2">&#9670;&nbsp;</a></span>nvnCommandBufferBindVertexBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindVertexBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_nbuffer_range.html">NVNbufferRange</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object ranges to use for fetching vertex attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">first</td><td>First vertex buffer binding point number to update. Must be less than 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a571496d1d44d5215d5023b1c8603c84f" title="Number of vertex buffer binding points.">NVN_DEVICE_INFO_VERTEX_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous vertex buffer binding points to update. Must be greater than or equal to zero. Must be less than or equal to 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a571496d1d44d5215d5023b1c8603c84f" title="Number of vertex buffer binding points.">NVN_DEVICE_INFO_VERTEX_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">buffers</td><td>Array of vertex buffer ranges to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga82c7e3c0c9fff4ebfeef4d6d118dfc1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82c7e3c0c9fff4ebfeef4d6d118dfc1a">&#9670;&nbsp;</a></span>nvnCommandBufferBindVertexBuffers_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnCommandBufferBindVertexBuffers_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_nbuffer_range.html">NVNbufferRange</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object ranges to use for fetching vertex attributes. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnCommandBufferBindVertexBuffers, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">first</td><td>First vertex buffer binding point number to update. Must be less than 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a571496d1d44d5215d5023b1c8603c84f" title="Number of vertex buffer binding points.">NVN_DEVICE_INFO_VERTEX_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous vertex buffer binding points to update. Must be greater than or equal to zero. Must be less than or equal to 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a571496d1d44d5215d5023b1c8603c84f" title="Number of vertex buffer binding points.">NVN_DEVICE_INFO_VERTEX_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">buffers</td><td>Array of vertex buffer ranges to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga50631d9a85aca68db2ede52b0d13521e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50631d9a85aca68db2ede52b0d13521e">&#9670;&nbsp;</a></span>nvnCommandBufferBindUniformBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindUniformBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a range of a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object to use for fetching shader uniform values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding point to update.</td></tr>
    <tr><td class="paramname">index</td><td>Uniform buffer binding point number to update. Must be greater than or equal to zero. Must be less than 14 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a56301a29a39a7a7e6cce351b1483bcc6" title="Number of uniform buffer bindings supported for each shader stage.">NVN_DEVICE_INFO_UNIFORM_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of buffer object memory to bind. Must be a multiple of 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ac5b90148e47e9a26cd38b367123ff374" title="Minimum alignment of uniform buffer bindings.">NVN_DEVICE_INFO_UNIFORM_BUFFER_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the range of the <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object to bind. Must be less than or equal to 65536 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a3f3db4bfcb9457a4ca25046221f97409" title="Maximum size (in bytes) of a bound uniform buffer.">NVN_DEVICE_INFO_MAX_UNIFORM_BUFFER_SIZE</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga34d3c347e431f11e2b08179e95c85fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34d3c347e431f11e2b08179e95c85fb5">&#9670;&nbsp;</a></span>nvnCommandBufferBindUniformBuffer_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnCommandBufferBindUniformBuffer_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a range of a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object to use for fetching shader uniform values. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnCommandBufferBindUniformBuffer, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding point to update.</td></tr>
    <tr><td class="paramname">index</td><td>Uniform buffer binding point number to update. Must be greater than or equal to zero. Must be less than 14 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a56301a29a39a7a7e6cce351b1483bcc6" title="Number of uniform buffer bindings supported for each shader stage.">NVN_DEVICE_INFO_UNIFORM_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of buffer object memory to bind. Must be a multiple of 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ac5b90148e47e9a26cd38b367123ff374" title="Minimum alignment of uniform buffer bindings.">NVN_DEVICE_INFO_UNIFORM_BUFFER_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the range of the <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object to bind. Must be less than or equal to 65536 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a3f3db4bfcb9457a4ca25046221f97409" title="Maximum size (in bytes) of a bound uniform buffer.">NVN_DEVICE_INFO_MAX_UNIFORM_BUFFER_SIZE</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac6c5976d18967b450044eff98880ecd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6c5976d18967b450044eff98880ecd6">&#9670;&nbsp;</a></span>nvnCommandBufferBindUniformBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindUniformBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_nbuffer_range.html">NVNbufferRange</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object ranges to use for fetching shader uniform values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding point to update.</td></tr>
    <tr><td class="paramname">first</td><td>First uniform buffer binding point number to update. Must be less than 14 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a56301a29a39a7a7e6cce351b1483bcc6" title="Number of uniform buffer bindings supported for each shader stage.">NVN_DEVICE_INFO_UNIFORM_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous uniform buffer binding points to update. Must be greater than or equal to zero. Must be less than or equal to 14 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a56301a29a39a7a7e6cce351b1483bcc6" title="Number of uniform buffer bindings supported for each shader stage.">NVN_DEVICE_INFO_UNIFORM_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">buffers</td><td>Array of buffer object ranges to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabe79df1465ac2ed717a129aaac29edfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe79df1465ac2ed717a129aaac29edfa">&#9670;&nbsp;</a></span>nvnCommandBufferBindUniformBuffers_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnCommandBufferBindUniformBuffers_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_nbuffer_range.html">NVNbufferRange</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object ranges to use for fetching shader uniform values. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnCommandBufferBindUniformBuffers, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding point to update.</td></tr>
    <tr><td class="paramname">first</td><td>First uniform buffer binding point number to update. Must be less than 14 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a56301a29a39a7a7e6cce351b1483bcc6" title="Number of uniform buffer bindings supported for each shader stage.">NVN_DEVICE_INFO_UNIFORM_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous uniform buffer binding points to update. Must be greater than or equal to zero. Must be less than or equal to 14 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a56301a29a39a7a7e6cce351b1483bcc6" title="Number of uniform buffer bindings supported for each shader stage.">NVN_DEVICE_INFO_UNIFORM_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">buffers</td><td>Array of buffer object ranges to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga14559252ced1659ed1cae3e0040eaebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14559252ced1659ed1cae3e0040eaebf">&#9670;&nbsp;</a></span>nvnCommandBufferBindUniformBuffersDeferred()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindUniformBuffersDeferred </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer_range.html">NVNbufferRange</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object ranges to use for fetching shader uniform values. </p>
<p>When recording this command, the pointer to the set of buffer object ranges is not dereferenced when the command set is recorded. Instead, it is dereferenced only when the command set containing this command is submitted to a queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding point to update.</td></tr>
    <tr><td class="paramname">first</td><td>First uniform buffer binding point number to update. Must be less than 14 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a56301a29a39a7a7e6cce351b1483bcc6" title="Number of uniform buffer bindings supported for each shader stage.">NVN_DEVICE_INFO_UNIFORM_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous uniform buffer binding points to update. Must be greater than or equal to zero. Must be less than or equal to 14 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a56301a29a39a7a7e6cce351b1483bcc6" title="Number of uniform buffer bindings supported for each shader stage.">NVN_DEVICE_INFO_UNIFORM_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">buffers</td><td>Array of buffer object ranges to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga37a1a7dc8cf9405bd88e6fd237812518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37a1a7dc8cf9405bd88e6fd237812518">&#9670;&nbsp;</a></span>nvnCommandBufferBindUniformBuffersDeferred_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnCommandBufferBindUniformBuffersDeferred_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer_range.html">NVNbufferRange</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object ranges to use for fetching shader uniform values. </p>
<p>Fastpath variant.</p>
<p>When recording this command, the pointer to the set of buffer object ranges is not dereferenced when the command set is recorded. Instead, it is dereferenced only when the command set containing this command is submitted to a queue.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnCommandBufferBindUniformBuffersDeferred, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding point to update.</td></tr>
    <tr><td class="paramname">first</td><td>First uniform buffer binding point number to update. Must be less than 14 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a56301a29a39a7a7e6cce351b1483bcc6" title="Number of uniform buffer bindings supported for each shader stage.">NVN_DEVICE_INFO_UNIFORM_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous uniform buffer binding points to update. Must be greater than or equal to zero. Must be less than or equal to 14 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a56301a29a39a7a7e6cce351b1483bcc6" title="Number of uniform buffer bindings supported for each shader stage.">NVN_DEVICE_INFO_UNIFORM_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">buffers</td><td>Array of buffer object ranges to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadacbd5a1b83b888949d3374015019a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadacbd5a1b83b888949d3374015019a39">&#9670;&nbsp;</a></span>nvnCommandBufferBindTransformFeedbackBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindTransformFeedbackBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a range of a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object to use for capturing transformed vertex data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">index</td><td>Transform feedback buffer binding point number to update. Must be less than 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50aed491c3dd4f146cdd6a3da9b18650836" title="Number of transform feedback buffer binding points.">NVN_DEVICE_INFO_TRANSFORM_FEEDBACK_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of transform feedback buffer memory to bind. If specified as zero, no data should be captured for the updated binding point. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a5b01bf12e41d77eb9bf6321e62b2ec6b" title="Minimum alignment of transform feedback buffer bindings.">NVN_DEVICE_INFO_TRANSFORM_FEEDBACK_BUFFER_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the range of the <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object to bind. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a5b01bf12e41d77eb9bf6321e62b2ec6b" title="Minimum alignment of transform feedback buffer bindings.">NVN_DEVICE_INFO_TRANSFORM_FEEDBACK_BUFFER_ALIGNMENT</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga882751c504e2ae17b4794d811c6b5c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga882751c504e2ae17b4794d811c6b5c9c">&#9670;&nbsp;</a></span>nvnCommandBufferBindTransformFeedbackBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindTransformFeedbackBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_nbuffer_range.html">NVNbufferRange</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object ranges to use for capturing transformed vertex data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">first</td><td>First transform feedback buffer binding point number to update. Must be less than 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50aed491c3dd4f146cdd6a3da9b18650836" title="Number of transform feedback buffer binding points.">NVN_DEVICE_INFO_TRANSFORM_FEEDBACK_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous transform feedback buffer binding points to update. Must be greater than or equal to zero. Must be less than or equal to 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50aed491c3dd4f146cdd6a3da9b18650836" title="Number of transform feedback buffer binding points.">NVN_DEVICE_INFO_TRANSFORM_FEEDBACK_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">buffers</td><td>Array of buffer object ranges to bind. If specified as zero, no data should be captured for the updated binding point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga18f58558537f39f4d427bd09c99de607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18f58558537f39f4d427bd09c99de607">&#9670;&nbsp;</a></span>nvnCommandBufferBindStorageBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindStorageBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a range of a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object to use for random-access reads and writes in shaders. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding point to update.</td></tr>
    <tr><td class="paramname">index</td><td>Shader storage buffer binding point number to update. Must be less than 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ad3ff4123a22f799bd1e1712471e1e254" title="Number of shader storage buffer bindings supported for each shader stage.">NVN_DEVICE_INFO_SHADER_STORAGE_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of buffer object memory to bind.</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the range of the <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga83b106a76c4096e5a51032212c0af535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83b106a76c4096e5a51032212c0af535">&#9670;&nbsp;</a></span>nvnCommandBufferBindStorageBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindStorageBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_nbuffer_range.html">NVNbufferRange</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object ranges to use for random-access reads and writes in shaders. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding point to update.</td></tr>
    <tr><td class="paramname">first</td><td>First shader storage buffer binding point number to update. Must be less than 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ad3ff4123a22f799bd1e1712471e1e254" title="Number of shader storage buffer bindings supported for each shader stage.">NVN_DEVICE_INFO_SHADER_STORAGE_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous shader storage buffer binding points to update. Must be greater than or equal to zero. Must be less than or equal to 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ad3ff4123a22f799bd1e1712471e1e254" title="Number of shader storage buffer bindings supported for each shader stage.">NVN_DEVICE_INFO_SHADER_STORAGE_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">buffers</td><td>Array of buffer object ranges to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga37d27bbff1e23c694944e0d876bd364b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37d27bbff1e23c694944e0d876bd364b">&#9670;&nbsp;</a></span>nvnCommandBufferBindStorageBuffersDeferred()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindStorageBuffersDeferred </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer_range.html">NVNbufferRange</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object ranges to use for random-access reads and writes in shaders. </p>
<p>When recording this command, the pointer to the set of buffer object ranges is not dereferenced when the command set is recorded. Instead, it is dereferenced only when the command set containing this command is submitted to a queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding point to update.</td></tr>
    <tr><td class="paramname">first</td><td>First shader storage buffer binding point number to update. Must be less than 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ad3ff4123a22f799bd1e1712471e1e254" title="Number of shader storage buffer bindings supported for each shader stage.">NVN_DEVICE_INFO_SHADER_STORAGE_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous shader storage buffer binding points to update. Must be greater than or equal to zero. Must be less than or equal to 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ad3ff4123a22f799bd1e1712471e1e254" title="Number of shader storage buffer bindings supported for each shader stage.">NVN_DEVICE_INFO_SHADER_STORAGE_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">buffers</td><td>Array of buffer object ranges to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf71383854dd30f81ddc65910f7098124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf71383854dd30f81ddc65910f7098124">&#9670;&nbsp;</a></span>nvnCommandBufferBindStorageBuffersDeferred_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnCommandBufferBindStorageBuffersDeferred_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer_range.html">NVNbufferRange</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object ranges to use for random-access reads and writes in shaders. </p>
<p>Fastpath variant.</p>
<p>When recording this command, the pointer to the set of buffer object ranges is not dereferenced when the command set is recorded. Instead, it is dereferenced only when the command set containing this command is submitted to a queue.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnCommandBufferBindStorageBuffersDeferred, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding point to update.</td></tr>
    <tr><td class="paramname">first</td><td>First shader storage buffer binding point number to update. Must be less than 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ad3ff4123a22f799bd1e1712471e1e254" title="Number of shader storage buffer bindings supported for each shader stage.">NVN_DEVICE_INFO_SHADER_STORAGE_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous shader storage buffer binding points to update. Must be greater than or equal to zero. Must be less than or equal to 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ad3ff4123a22f799bd1e1712471e1e254" title="Number of shader storage buffer bindings supported for each shader stage.">NVN_DEVICE_INFO_SHADER_STORAGE_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">buffers</td><td>Array of buffer object ranges to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad89eb87dde4d1dba6444ea4f8f79e66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad89eb87dde4d1dba6444ea4f8f79e66b">&#9670;&nbsp;</a></span>nvnCommandBufferBindTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#gaa1a1fc7a9e690ce93870bcd71ea6b446">NVNtextureHandle</a>&#160;</td>
          <td class="paramname"><em>texture</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a NVNtexture/NVNsampler pair to use for texture mapping in shaders. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding point to update.</td></tr>
    <tr><td class="paramname">index</td><td>NVNtexture/sampler binding point number to update. Must be less than 32 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a5584c5a71f1b9cb98626dcc190156a91" title="Number of texture and sampler bindings supported for each shader stage.">NVN_DEVICE_INFO_TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">texture</td><td>Handle for the pair of <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> and <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga685c4d1fb926a9eff6eb658549d146e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga685c4d1fb926a9eff6eb658549d146e8">&#9670;&nbsp;</a></span>nvnCommandBufferBindTextures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindTextures </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="group__nvn__c__handle.html#gaa1a1fc7a9e690ce93870bcd71ea6b446">NVNtextureHandle</a> *&#160;</td>
          <td class="paramname"><em>textures</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more NVNtexture/NVNsampler pairs to use for texture mapping in shaders. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding points to update.</td></tr>
    <tr><td class="paramname">first</td><td>First texture/sampler binding point number to update. Must be less than 32 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a5584c5a71f1b9cb98626dcc190156a91" title="Number of texture and sampler bindings supported for each shader stage.">NVN_DEVICE_INFO_TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous texture/sampler binding points to update. Must be less than or equal to 32 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a5584c5a71f1b9cb98626dcc190156a91" title="Number of texture and sampler bindings supported for each shader stage.">NVN_DEVICE_INFO_TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">textures</td><td>Array of handles for pairs of <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> and <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac44a39a31493571990dc888d765687ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac44a39a31493571990dc888d765687ae">&#9670;&nbsp;</a></span>nvnCommandBufferBindTexturesDeferred()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindTexturesDeferred </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__nvn__c__handle.html#gaa1a1fc7a9e690ce93870bcd71ea6b446">NVNtextureHandle</a> *&#160;</td>
          <td class="paramname"><em>textures</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more NVNtexture/NVNsampler pairs to use for texture mapping in shaders. </p>
<p>When recording this command, the pointer to the set of texture handles is not dereferenced when the command set is recorded. Instead, it is dereferenced only when the command set containing this command is submitted to a queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding points to update.</td></tr>
    <tr><td class="paramname">first</td><td>First texture/sampler binding point number to update. Must be less than 32 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a5584c5a71f1b9cb98626dcc190156a91" title="Number of texture and sampler bindings supported for each shader stage.">NVN_DEVICE_INFO_TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous texture/sampler binding points to update. Must be less than or equal to 32 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a5584c5a71f1b9cb98626dcc190156a91" title="Number of texture and sampler bindings supported for each shader stage.">NVN_DEVICE_INFO_TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">textures</td><td>Array of handles for pairs of <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> and <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga71beee9a1f2f8aae74522c05d0031e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71beee9a1f2f8aae74522c05d0031e61">&#9670;&nbsp;</a></span>nvnCommandBufferBindTexturesDeferred_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnCommandBufferBindTexturesDeferred_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__nvn__c__handle.html#gaa1a1fc7a9e690ce93870bcd71ea6b446">NVNtextureHandle</a> *&#160;</td>
          <td class="paramname"><em>textures</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more NVNtexture/NVNsampler pairs to use for texture mapping in shaders. </p>
<p>Fastpath variant.</p>
<p>When recording this command, the pointer to the set of texture handles is not dereferenced when the command set is recorded. Instead, it is dereferenced only when the command set containing this command is submitted to a queue.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnCommandBufferBindTexturesDeferred, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding points to update.</td></tr>
    <tr><td class="paramname">first</td><td>First texture/sampler binding point number to update. Must be less than 32 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a5584c5a71f1b9cb98626dcc190156a91" title="Number of texture and sampler bindings supported for each shader stage.">NVN_DEVICE_INFO_TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous texture/sampler binding points to update. Must be less than or equal to 32 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a5584c5a71f1b9cb98626dcc190156a91" title="Number of texture and sampler bindings supported for each shader stage.">NVN_DEVICE_INFO_TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">textures</td><td>Array of handles for pairs of <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> and <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga26915307b6b313db6e592c0b2c9a9aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26915307b6b313db6e592c0b2c9a9aa4">&#9670;&nbsp;</a></span>nvnCommandBufferBindImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#gacba3c44a43c05f11bc1b88c49b118606">NVNimageHandle</a>&#160;</td>
          <td class="paramname"><em>image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> to use for image loads and stores in shaders. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding point to update.</td></tr>
    <tr><td class="paramname">index</td><td>Image binding point number to update. Must be less than 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a361bd4e100b213cf339f09e9e233cc89" title="Number of image bindings supported for each shader stage.">NVN_DEVICE_INFO_IMAGE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">image</td><td>Image handle for the <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaee09267e163c31d524cfc70ea047cafc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee09267e163c31d524cfc70ea047cafc">&#9670;&nbsp;</a></span>nvnCommandBufferBindImages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindImages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="group__nvn__c__handle.html#gacba3c44a43c05f11bc1b88c49b118606">NVNimageHandle</a> *&#160;</td>
          <td class="paramname"><em>images</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more Textures to use for image loads and stores in shaders. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding points to update.</td></tr>
    <tr><td class="paramname">first</td><td>First image binding point number to update. Must be less than 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a361bd4e100b213cf339f09e9e233cc89" title="Number of image bindings supported for each shader stage.">NVN_DEVICE_INFO_IMAGE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous image binding points to update. Must be less than or equal to 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a361bd4e100b213cf339f09e9e233cc89" title="Number of image bindings supported for each shader stage.">NVN_DEVICE_INFO_IMAGE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">images</td><td>Array of handles for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7810c6547483c880bb3594e0c2e4162e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7810c6547483c880bb3594e0c2e4162e">&#9670;&nbsp;</a></span>nvnCommandBufferBindImagesDeferred()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindImagesDeferred </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__nvn__c__handle.html#gacba3c44a43c05f11bc1b88c49b118606">NVNimageHandle</a> *&#160;</td>
          <td class="paramname"><em>images</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more Textures to use for image loads and stores in shaders. </p>
<p>When recording this command, the pointer to the set of image handles is not dereferenced when the command set is recorded. Instead, it is dereferenced only when the command set containing this command is submitted to a queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding points to update.</td></tr>
    <tr><td class="paramname">first</td><td>First image binding point number to update. Must be less than 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a361bd4e100b213cf339f09e9e233cc89" title="Number of image bindings supported for each shader stage.">NVN_DEVICE_INFO_IMAGE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous image binding points to update. Must be less than or equal to 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a361bd4e100b213cf339f09e9e233cc89" title="Number of image bindings supported for each shader stage.">NVN_DEVICE_INFO_IMAGE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">images</td><td>Array of handles for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad5ea7e3b5622fe8d512afe682890c328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5ea7e3b5622fe8d512afe682890c328">&#9670;&nbsp;</a></span>nvnCommandBufferBindImagesDeferred_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnCommandBufferBindImagesDeferred_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__nvn__c__handle.html#gacba3c44a43c05f11bc1b88c49b118606">NVNimageHandle</a> *&#160;</td>
          <td class="paramname"><em>images</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more Textures to use for image loads and stores in shaders. </p>
<p>Fastpath variant.</p>
<p>When recording this command, the pointer to the set of image handles is not dereferenced when the command set is recorded. Instead, it is dereferenced only when the command set containing this command is submitted to a queue.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnCommandBufferBindImagesDeferred, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding points to update.</td></tr>
    <tr><td class="paramname">first</td><td>First image binding point number to update. Must be less than 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a361bd4e100b213cf339f09e9e233cc89" title="Number of image bindings supported for each shader stage.">NVN_DEVICE_INFO_IMAGE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous image binding points to update. Must be less than or equal to 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a361bd4e100b213cf339f09e9e233cc89" title="Number of image bindings supported for each shader stage.">NVN_DEVICE_INFO_IMAGE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">images</td><td>Array of handles for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0030496de8749dee42285b464f59f066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0030496de8749dee42285b464f59f066">&#9670;&nbsp;</a></span>nvnCommandBufferSetPatchSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetPatchSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the number of vertices in each patch when rendering patch primitives. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update operation.</td></tr>
    <tr><td class="paramname">size</td><td>Number of vertices present in each patch. Must be greater than zero. Must be less than or equal to 32 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a28bfcb18df0b156944353878b0c29321" title="Maximum number of vertices in each patch primitive.">NVN_DEVICE_INFO_MAX_PATCH_SIZE</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf71f351afe5100328f8697ef4d7e69fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf71f351afe5100328f8697ef4d7e69fc">&#9670;&nbsp;</a></span>nvnCommandBufferSetInnerTessellationLevels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetInnerTessellationLevels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const float *&#160;</td>
          <td class="paramname"><em>levels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify default inner tessellation levels when rendering patch primitives. </p>
<p>The default inner and outer tessellation levels are used when a tessellation evaluation shader is bound without a tessellation control shader. When a tessellation control shader is bound, default levels are ignored.</p>
<dl class="section note"><dt>Note</dt><dd>Tessellation levels are clamped to the range [1.0, 64.0], and may be further clamped according to the tessellation spacing.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update operation.</td></tr>
    <tr><td class="paramname">levels</td><td>Two floating-point inner tessellation levels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8072de9e7ba78cc0eddff5c67deec10c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8072de9e7ba78cc0eddff5c67deec10c">&#9670;&nbsp;</a></span>nvnCommandBufferSetOuterTessellationLevels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetOuterTessellationLevels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const float *&#160;</td>
          <td class="paramname"><em>levels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify default outer tessellation levels when rendering patch primitives. </p>
<p>The default inner and outer tessellation levels are used when a tessellation evaluation shader is bound without a tessellation control shader. When a tessellation control shader is bound, default levels are ignored.</p>
<dl class="section note"><dt>Note</dt><dd>If any outer tessellation level is less than or equal to zero, a patch will be discarded, except for the fourth level when processing triangular patches.</dd>
<dd>
Tessellation levels greater than zero are clamped to the range [1.0, 64.0] and may be further clamped according to the tessellation spacing.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update operation.</td></tr>
    <tr><td class="paramname">levels</td><td>Four floating-point outer tessellation levels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9fe0e7f03b40e90dc870c706d6432d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fe0e7f03b40e90dc870c706d6432d8f">&#9670;&nbsp;</a></span>nvnCommandBufferSetPrimitiveRestart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetPrimitiveRestart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable and disable primitive restart and specify a primitive restart index. </p>
<p>When enabled, a primitive is restarted (with the same primitive type) whenever an index value matching the restart index value is found.</p>
<dl class="section note"><dt>Note</dt><dd>The vertex index value must match the restart index exactly. For example, primitives rendered using the index type <a class="el" href="group__nvn__c__enum.html#ggaaf90e0c2dbdc1e42db8192f0c0cb1522a9d49b4695541469d3ecbadeac29c98b8" title="Index values are specified as (8-bit) unsigned bytes.">NVN_INDEX_TYPE_UNSIGNED_BYTE</a> wil not be restarted if the restart index is outside the range [0,255].</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update operation.</td></tr>
    <tr><td class="paramname">enable</td><td>Enable (TRUE) or disable (FALSE) primitive restart operations.</td></tr>
    <tr><td class="paramname">index</td><td>Index value used to indicate that a primitive should be restarted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8a5d40804e1ae718dfb71928afc6963e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a5d40804e1ae718dfb71928afc6963e">&#9670;&nbsp;</a></span>nvnCommandBufferBeginTransformFeedback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBeginTransformFeedback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a transform feedback (stream output) operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used for the transform feedback commands.</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of buffer memory holding 32 bytes of control information used by the transform feedback operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Must point to valid buffer storage. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a263810a39849679dad70888a328d84a3" title="Minimum alignment of transform feedback control data.">NVN_DEVICE_INFO_TRANSFORM_FEEDBACK_CONTROL_ALIGNMENT</a>). </dd></dl>

</div>
</div>
<a id="gaa1f8deb2cc863867218ce25789684809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1f8deb2cc863867218ce25789684809">&#9670;&nbsp;</a></span>nvnCommandBufferEndTransformFeedback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferEndTransformFeedback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complete a transform feedback (stream output) operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used for the transform feedback commands.</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of buffer memory holding 32 bytes of control information used by the transform feedback operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Must point to valid buffer storage. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a263810a39849679dad70888a328d84a3" title="Minimum alignment of transform feedback control data.">NVN_DEVICE_INFO_TRANSFORM_FEEDBACK_CONTROL_ALIGNMENT</a>). </dd></dl>

</div>
</div>
<a id="ga36606b1759b3b79a8844de9ff4072b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36606b1759b3b79a8844de9ff4072b49">&#9670;&nbsp;</a></span>nvnCommandBufferPauseTransformFeedback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferPauseTransformFeedback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pause a transform feedback (stream output) operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used for the transform feedback commands.</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of buffer memory holding 32 bytes of control information used by the transform feedback operation. The provided address may be zero, in which case, no control information will be written to memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If an address of zero is used, the current state of the transform feedback operation is not saved to memory. If any other transform feedback operation is performed before resuming, or if transform feedback is resumed using a non-zero address, this state is lost. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a263810a39849679dad70888a328d84a3" title="Minimum alignment of transform feedback control data.">NVN_DEVICE_INFO_TRANSFORM_FEEDBACK_CONTROL_ALIGNMENT</a>). </dd></dl>

</div>
</div>
<a id="ga3ad2246e89cf77b1a4cf41c38ff43527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ad2246e89cf77b1a4cf41c38ff43527">&#9670;&nbsp;</a></span>nvnCommandBufferResumeTransformFeedback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferResumeTransformFeedback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume a transform feedback (stream output) operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used for the transform feedback commands.</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of buffer memory holding 32 bytes of control information used by the transform feedback operation. The provided address may be zero, in which case, no control information will be read from memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If an address of zero is used, the state of the previously paused transform feedback operation is not restored from memory. If any other transform feedback operation is performed before resuming with a zero address, this state is lost. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a263810a39849679dad70888a328d84a3" title="Minimum alignment of transform feedback control data.">NVN_DEVICE_INFO_TRANSFORM_FEEDBACK_CONTROL_ALIGNMENT</a>). </dd></dl>

</div>
</div>
<a id="ga0c7d4cceeb20e66d10503c868a05a99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c7d4cceeb20e66d10503c868a05a99d">&#9670;&nbsp;</a></span>nvnCommandBufferDrawTransformFeedback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferDrawTransformFeedback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw primitives captured in a previous transform feedback (stream output) operation. </p>
<dl class="section warning"><dt>Warning</dt><dd>Applications must call nvnCommandBufferBarrier with the <a class="el" href="group__nvn__c__enum.html#ggaab4eabfc248236cc6b42d9de9d735621ad90225b2b4d5e8e3b710573a967ac67e" title="Ensure that all work before the barrier completes before fetching per-draw data for indirect draws an...">NVN_BARRIER_ORDER_INDIRECT_DATA_BIT</a> bit set to ensure that the GPU doesn't fetch the indirect data before previous commands are finished writing the data. Waiting via nvnQueueFinish, nvnQueueWaitSync, or nvnCommandBufferWaitSync is not sufficient to ensure that GPU-produced indirect data are not fetched prematurely.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used for the transform feedback commands.</td></tr>
    <tr><td class="paramname">mode</td><td>Type of primitive to render. When rendering primitives captured by transform feedback, this parameter should typically be POINTS, LINES, or TRIANGLES, since transform feedback captures only independent primitives (even if the original geometry were provided as strips).</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of buffer memory holding 32 bytes of control information used by the transform feedback operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Must point to valid buffer storage. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a263810a39849679dad70888a328d84a3" title="Minimum alignment of transform feedback control data.">NVN_DEVICE_INFO_TRANSFORM_FEEDBACK_CONTROL_ALIGNMENT</a>). </dd></dl>

</div>
</div>
<a id="ga7a1a1002239aa2f5f61e79308c99a84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a1a1002239aa2f5f61e79308c99a84a">&#9670;&nbsp;</a></span>nvnCommandBufferDrawArrays()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferDrawArrays </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render a primitive with consecutive vertex indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the draw operation.</td></tr>
    <tr><td class="paramname">mode</td><td>Type of the primitive to render.</td></tr>
    <tr><td class="paramname">first</td><td>Index of the first vertex in the primitive.</td></tr>
    <tr><td class="paramname">count</td><td>Number of vertices in the primitive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga06f4d4765bf74d01809661766ac7df80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06f4d4765bf74d01809661766ac7df80">&#9670;&nbsp;</a></span>nvnCommandBufferDrawElements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferDrawElements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaaf90e0c2dbdc1e42db8192f0c0cb1522">NVNindexType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>indexBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render a primitive with vertex indices fetched from an index buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the draw operation.</td></tr>
    <tr><td class="paramname">mode</td><td>Type of the primitive to render.</td></tr>
    <tr><td class="paramname">type</td><td>Type of index values stored in the index buffer.</td></tr>
    <tr><td class="paramname">count</td><td>Number of vertices in the primitive.</td></tr>
    <tr><td class="paramname">indexBuffer</td><td>GPU address of buffer object memory used as the index buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae7310dac6860cdf877465adb7ad8e5b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7310dac6860cdf877465adb7ad8e5b5">&#9670;&nbsp;</a></span>nvnCommandBufferDrawElements_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnCommandBufferDrawElements_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaaf90e0c2dbdc1e42db8192f0c0cb1522">NVNindexType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>indexBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render a primitive with vertex indices fetched from an index buffer. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnCommandBufferDrawElements, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the draw operation.</td></tr>
    <tr><td class="paramname">mode</td><td>Type of the primitive to render.</td></tr>
    <tr><td class="paramname">type</td><td>Type of index values stored in the index buffer.</td></tr>
    <tr><td class="paramname">count</td><td>Number of vertices in the primitive.</td></tr>
    <tr><td class="paramname">indexBuffer</td><td>GPU address of buffer object memory used as the index buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga24c189bbc5765d6e8e7c862156417baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24c189bbc5765d6e8e7c862156417baf">&#9670;&nbsp;</a></span>nvnCommandBufferDrawElementsBaseVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferDrawElementsBaseVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaaf90e0c2dbdc1e42db8192f0c0cb1522">NVNindexType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>indexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseVertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render a primitive with vertex indices fetched from an index buffer, with a base vertex value added to each fetched index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the draw operation.</td></tr>
    <tr><td class="paramname">mode</td><td>Type of the primitive to render.</td></tr>
    <tr><td class="paramname">type</td><td>Type of index values stored in the index buffer.</td></tr>
    <tr><td class="paramname">count</td><td>Number of vertices in the primitive.</td></tr>
    <tr><td class="paramname">indexBuffer</td><td>GPU address of buffer object memory used as the index buffer.</td></tr>
    <tr><td class="paramname">baseVertex</td><td>Base vertex value, added to each index fetched from the index buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga990fb401259b83e26716733dd581d5d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga990fb401259b83e26716733dd581d5d8">&#9670;&nbsp;</a></span>nvnCommandBufferDrawArraysInstanced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferDrawArraysInstanced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instanceCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render multiple copies (instances) of a primitive with consecutive vertex indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the draw operation.</td></tr>
    <tr><td class="paramname">mode</td><td>Type of the primitive to render.</td></tr>
    <tr><td class="paramname">first</td><td>Index of the first vertex in the primitive.</td></tr>
    <tr><td class="paramname">count</td><td>Number of vertices in the primitive.</td></tr>
    <tr><td class="paramname">baseInstance</td><td>Instance number of the first primitive instance.</td></tr>
    <tr><td class="paramname">instanceCount</td><td>Number of primitive instances to render. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabe27aeb078f485947d4c4454182c8fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe27aeb078f485947d4c4454182c8fde">&#9670;&nbsp;</a></span>nvnCommandBufferDrawElementsInstanced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferDrawElementsInstanced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaaf90e0c2dbdc1e42db8192f0c0cb1522">NVNindexType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>indexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instanceCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render multiple copies (instances) of a primitive with vertex indices fetched from an index buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the draw operation.</td></tr>
    <tr><td class="paramname">mode</td><td>Type of the primitive to render.</td></tr>
    <tr><td class="paramname">type</td><td>Type of index values stored in the index buffer.</td></tr>
    <tr><td class="paramname">count</td><td>Number of vertices in the primitive.</td></tr>
    <tr><td class="paramname">indexBuffer</td><td>GPU address of buffer object memory used as the index buffer.</td></tr>
    <tr><td class="paramname">baseVertex</td><td>Base vertex value, added to each index fetched from the index buffer.</td></tr>
    <tr><td class="paramname">baseInstance</td><td>Instance number of the first primitive instance.</td></tr>
    <tr><td class="paramname">instanceCount</td><td>Number of primitive instances to render. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7266e9a35bb52a07df08a09333b1e2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7266e9a35bb52a07df08a09333b1e2e8">&#9670;&nbsp;</a></span>nvnCommandBufferDrawArraysIndirect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferDrawArraysIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>indirectBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render primitives with consecutive vertex indices, using draw parameters fetched from an indirect data buffer. </p>
<p>The parameters of the draw are stored in <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object memory using the <a class="el" href="struct_n_v_ndraw_arrays_indirect_data.html" title="Data structure representing values used by indirect DrawArrays commands.">NVNdrawArraysIndirectData</a> structure.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the indirect data are produced by previous commands executed on the GPU, applications must call nvnCommandBufferBarrier with the <a class="el" href="group__nvn__c__enum.html#ggaab4eabfc248236cc6b42d9de9d735621ad90225b2b4d5e8e3b710573a967ac67e" title="Ensure that all work before the barrier completes before fetching per-draw data for indirect draws an...">NVN_BARRIER_ORDER_INDIRECT_DATA_BIT</a> bit set to ensure that the GPU doesn't fetch the indirect data before previous commands are finished writing the data. Waiting via nvnQueueFinish, nvnQueueWaitSync, or nvnCommandBufferWaitSync is not sufficient to ensure that GPU-produced indirect data are not fetched prematurely.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the draw operation.</td></tr>
    <tr><td class="paramname">mode</td><td>Type of the primitive to render.</td></tr>
    <tr><td class="paramname">indirectBuffer</td><td>GPU address of buffer object memory holding the indirect draw data. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a27ead5808358b8c8d7bc9a058e246751" title="Minimum alignment of indirect draw data.">NVN_DEVICE_INFO_INDIRECT_DRAW_ALIGNMENT</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0ea4fb762b38faa6bce7d27c075011e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ea4fb762b38faa6bce7d27c075011e4">&#9670;&nbsp;</a></span>nvnCommandBufferDrawElementsIndirect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferDrawElementsIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaaf90e0c2dbdc1e42db8192f0c0cb1522">NVNindexType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>indexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>indirectBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render primitives with vertex indices fetched from an index buffer, using draw parameters fetched from an indirect data buffer. </p>
<p>The parameters of the draw are stored in <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object memory using the <a class="el" href="struct_n_v_ndraw_elements_indirect_data.html" title="Data structure representing values used by indirect DrawElements commands.">NVNdrawElementsIndirectData</a> structure.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the indirect data are produced by previous commands executed on the GPU, applications must call nvnCommandBufferBarrier with the <a class="el" href="group__nvn__c__enum.html#ggaab4eabfc248236cc6b42d9de9d735621ad90225b2b4d5e8e3b710573a967ac67e" title="Ensure that all work before the barrier completes before fetching per-draw data for indirect draws an...">NVN_BARRIER_ORDER_INDIRECT_DATA_BIT</a> bit set to ensure that the GPU doesn't fetch the indirect data before previous commands are finished writing the data. Waiting via nvnQueueFinish, nvnQueueWaitSync, or nvnCommandBufferWaitSync is not sufficient to ensure that GPU-produced indirect data are not fetched prematurely.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the draw operation.</td></tr>
    <tr><td class="paramname">mode</td><td>Type of the primitive to render.</td></tr>
    <tr><td class="paramname">type</td><td>Type of index values stored in the index buffer.</td></tr>
    <tr><td class="paramname">indexBuffer</td><td>GPU address of buffer object memory used as the index buffer.</td></tr>
    <tr><td class="paramname">indirectBuffer</td><td>GPU address of buffer object memory holding the indirect draw data. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a27ead5808358b8c8d7bc9a058e246751" title="Minimum alignment of indirect draw data.">NVN_DEVICE_INFO_INDIRECT_DRAW_ALIGNMENT</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga06413e93f9e3d29a45fa878540947a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06413e93f9e3d29a45fa878540947a8f">&#9670;&nbsp;</a></span>nvnCommandBufferMultiDrawArraysIndirectCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferMultiDrawArraysIndirectCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>indirectBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>parameterBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxDrawCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render multiple primitives with vertices fetched from a vertex buffer, using draw parameters fetched from an indirect data buffer and the number of primitives fetched from a parameter buffer. </p>
<p>The parameters of the draw are stored in <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object memory using the <a class="el" href="struct_n_v_ndraw_arrays_indirect_data.html" title="Data structure representing values used by indirect DrawArrays commands.">NVNdrawArraysIndirectData</a> structure.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the indirect data or the draw count data are produced by previous commands executed on the GPU, applications must call nvnCommandBufferBarrier with the <a class="el" href="group__nvn__c__enum.html#ggaab4eabfc248236cc6b42d9de9d735621ad90225b2b4d5e8e3b710573a967ac67e" title="Ensure that all work before the barrier completes before fetching per-draw data for indirect draws an...">NVN_BARRIER_ORDER_INDIRECT_DATA_BIT</a> bit set to ensure that the GPU doesn't fetch the indirect data before previous commands are finished writing the data. Waiting via nvnQueueFinish, nvnQueueWaitSync, or nvnCommandBufferWaitSync is not sufficient to ensure that GPU-produced indirect data are not fetched prematurely.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the draw operation.</td></tr>
    <tr><td class="paramname">mode</td><td>Type of the primitive to render.</td></tr>
    <tr><td class="paramname">indirectBuffer</td><td>GPU address of buffer object memory holding the indirect draw data. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a27ead5808358b8c8d7bc9a058e246751" title="Minimum alignment of indirect draw data.">NVN_DEVICE_INFO_INDIRECT_DRAW_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">parameterBuffer</td><td>GPU address of buffer object memory holding the draw count. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a27ead5808358b8c8d7bc9a058e246751" title="Minimum alignment of indirect draw data.">NVN_DEVICE_INFO_INDIRECT_DRAW_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">maxDrawCount</td><td>Specifies the maximum number of draws that are allowed. If the draw count in GPU memory pointed to by <em>parameterBuffer</em> is greater than <em>maxDrawCount</em>, only the first <em>maxDrawCount</em> primitives will be drawn.</td></tr>
    <tr><td class="paramname">stride</td><td>Stride (in bytes) between elements in <em>indirectBuffer</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga181160adcfe4ed4870196d02ff457a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga181160adcfe4ed4870196d02ff457a72">&#9670;&nbsp;</a></span>nvnCommandBufferMultiDrawElementsIndirectCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferMultiDrawElementsIndirectCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaaf90e0c2dbdc1e42db8192f0c0cb1522">NVNindexType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>indexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>indirectBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>parameterBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxDrawCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render multiple primitives with vertex indices fetched from an index buffer, using draw parameters fetched from an indirect data buffer and the number of primitives fetched from a parameter buffer. </p>
<p>The parameters of the draw are stored in buffer object memory using the <a class="el" href="struct_n_v_ndraw_elements_indirect_data.html" title="Data structure representing values used by indirect DrawElements commands.">NVNdrawElementsIndirectData</a> structure.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the indirect data or the draw count data are produced by previous commands executed on the GPU, applications must call nvnCommandBufferBarrier with the <a class="el" href="group__nvn__c__enum.html#ggaab4eabfc248236cc6b42d9de9d735621ad90225b2b4d5e8e3b710573a967ac67e" title="Ensure that all work before the barrier completes before fetching per-draw data for indirect draws an...">NVN_BARRIER_ORDER_INDIRECT_DATA_BIT</a> bit set to ensure that the GPU doesn't fetch the indirect data before previous commands are finished writing the data. Waiting via nvnQueueFinish, nvnQueueWaitSync, or nvnCommandBufferWaitSync is not sufficient to ensure that GPU-produced indirect data are not fetched prematurely.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the draw operation.</td></tr>
    <tr><td class="paramname">mode</td><td>Type of the primitive to render.</td></tr>
    <tr><td class="paramname">type</td><td>Type of index values stored in the index buffer.</td></tr>
    <tr><td class="paramname">indexBuffer</td><td>GPU address of buffer object memory used as the index buffer.</td></tr>
    <tr><td class="paramname">indirectBuffer</td><td>GPU address of buffer object memory holding the indirect draw data. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a27ead5808358b8c8d7bc9a058e246751" title="Minimum alignment of indirect draw data.">NVN_DEVICE_INFO_INDIRECT_DRAW_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">parameterBuffer</td><td>GPU address of buffer object memory holding the draw count. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a27ead5808358b8c8d7bc9a058e246751" title="Minimum alignment of indirect draw data.">NVN_DEVICE_INFO_INDIRECT_DRAW_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">maxDrawCount</td><td>Specifies the maximum number of draws that are allowed. If the draw count in GPU memory pointed to by <em>parameterBuffer</em> is greater than <em>maxDrawCount</em>, only the first <em>maxDrawCount</em> primitives will be drawn.</td></tr>
    <tr><td class="paramname">stride</td><td>Stride (in bytes) between elements in <em>indirectBuffer</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae891eb7519f90d437a89e3ca17cddf7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae891eb7519f90d437a89e3ca17cddf7a">&#9670;&nbsp;</a></span>nvnCommandBufferClearColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferClearColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const float *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a color buffer using floating-point clear color values. </p>
<p>This command should be used only to clear color buffers with floating-point or <em>normalized</em> signed or unsigned integer components. When clearing color buffers with unnormalized integer components (with formats ending in "I" or "UI"), the values in <code>color</code> will be re-interpreted as integers. For example, clearing an integer color buffer to the value 1.0 will instead clear to 0x3F800000, the IEEE-754 encoding of 1.0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the clear.</td></tr>
    <tr><td class="paramname">index</td><td>Index of the color target to clear. Must be less than 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a9f4ab24a0b8c08e3f2b66ce04e379b16" title="Number of color buffer binding points.">NVN_DEVICE_INFO_COLOR_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">color</td><td>Array of four floating-point (RGBA) clear color values.</td></tr>
    <tr><td class="paramname">mask</td><td>Bitfield indicating which color channels should be cleared. See <a class="el" href="group__nvn__c__enum.html#gac703c5549157a2c6efb057f8047bde0f" title="Specifies the set of color buffer channels enabled for writing.">NVNclearColorMask</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga397b5f686c588f1e71e374d5b8d6276b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga397b5f686c588f1e71e374d5b8d6276b">&#9670;&nbsp;</a></span>nvnCommandBufferClearColori()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferClearColori </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const int *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a color buffer using signed integer clear color values. </p>
<p>This command should be used only to clear color buffers with <em>unnormalized</em> signed integer components (with formats ending in "I"). When clearing color buffers with floating-point or normalized integer components, the values in <code>color</code> will be re-interpreted as floating-point values. For example, clearing a floating-point color buffer to the value 0x3F800000 will instead clear to 1.0 (the IEEE-754 floating-point equivalent). When clearing color buffers with unsigned integer components, the signed clear color will be re-interpreted as unsigned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the clear.</td></tr>
    <tr><td class="paramname">index</td><td>Index of the color target to clear. Must be less than 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a9f4ab24a0b8c08e3f2b66ce04e379b16" title="Number of color buffer binding points.">NVN_DEVICE_INFO_COLOR_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">color</td><td>Array of four signed integer (RGBA) clear color values.</td></tr>
    <tr><td class="paramname">mask</td><td>Bitfield indicating which color channels should be cleared. See <a class="el" href="group__nvn__c__enum.html#gac703c5549157a2c6efb057f8047bde0f" title="Specifies the set of color buffer channels enabled for writing.">NVNclearColorMask</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad9c2f476b24cd629f774c48c5f7f364d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9c2f476b24cd629f774c48c5f7f364d">&#9670;&nbsp;</a></span>nvnCommandBufferClearColorui()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferClearColorui </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const uint32_t *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a color buffer using unsigned integer clear color values. </p>
<p>This command should be used only to clear color buffers with <em>unnormalized</em> unsigned integer components (with formats ending in "UI"). When clearing color buffers with floating-point or normalized integer components, the values in <code>color</code> will be re-interpreted as floating-point values. For example, clearing a floating-point color buffer to the value 0x3F800000 will instead clear to 1.0 (the IEEE-754 floating-point equivalent). When clearing color buffers with signed integer components, the unsigned clear color will be re-interpreted as signed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the clear.</td></tr>
    <tr><td class="paramname">index</td><td>Index of the color target to clear. Must be less than 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a9f4ab24a0b8c08e3f2b66ce04e379b16" title="Number of color buffer binding points.">NVN_DEVICE_INFO_COLOR_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">color</td><td>Array of four unsigned integer (RGBA) clear color values.</td></tr>
    <tr><td class="paramname">mask</td><td>Bitfield indicating which color channels should be cleared. See <a class="el" href="group__nvn__c__enum.html#gac703c5549157a2c6efb057f8047bde0f" title="Specifies the set of color buffer channels enabled for writing.">NVNclearColorMask</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae5f7adad6751d801a89cd1101253fa85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5f7adad6751d801a89cd1101253fa85">&#9670;&nbsp;</a></span>nvnCommandBufferClearDepthStencil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferClearDepthStencil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>depthValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>depthMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stencilValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stencilMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a depth/stencil buffer. </p>
<p>This command clears depth and stencil buffers of all formats.</p>
<dl class="section warning"><dt>Warning</dt><dd>On NX and the Windows reference implementation for Turing and older GPUs, calling nvnCommandBufferBarrier with the barrier <a class="el" href="group__nvn__c__enum.html#ggaab4eabfc248236cc6b42d9de9d735621acbf29d4462be775452aec0f326b6607a" title="Ensure that fragments from after the barrier don&#39;t start until all fragments from before the barrier ...">NVN_BARRIER_ORDER_FRAGMENTS_BIT</a> is not sufficient to ensure that previous rendering using the depth/stencil buffer as a texture completes before the depth/stencil buffer clear starts. In such cases, a heavier barrier like <a class="el" href="group__nvn__c__enum.html#ggaab4eabfc248236cc6b42d9de9d735621a1890ed150f5e94894ce3e448e38dce53" title="Ensure that primitives and compute dispatches from after the barrier don&#39;t start until all such work ...">NVN_BARRIER_ORDER_PRIMITIVES_BIT</a> is necessary to ensure that the clear does not corrupt rendering commands submitted prior to the barrier.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the clear.</td></tr>
    <tr><td class="paramname">depthValue</td><td>Floating-point depth clear value (in the range [0.0, 1.0]).</td></tr>
    <tr><td class="paramname">depthMask</td><td>Enable (TRUE) or disable (FALSE) clearing of the depth channel.</td></tr>
    <tr><td class="paramname">stencilValue</td><td>Stencil clear value.</td></tr>
    <tr><td class="paramname">stencilMask</td><td>Mask indicating the bits of the stencil buffer to clear. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga32b1e19b7700460afce5817b7c9d7bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32b1e19b7700460afce5817b7c9d7bee">&#9670;&nbsp;</a></span>nvnCommandBufferDispatchCompute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferDispatchCompute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>groupsX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>groupsY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>groupsZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch a new grid of compute shader work groups for processing. </p>
<p>Each compute shader dispatch spawns a three-dimensional array of work groups for processing. Each work group is processed independently, with a three-dimensional array of threads whose size is specified in the compute shader.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to dispatch the compute work.</td></tr>
    <tr><td class="paramname">groupsX</td><td>The number of compute work groups in the X dimension. Must be less than or equal to 65535 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a69a6d14c905f7669aebe64db6d5bc0c6" title="Maximum number of work groups in the X dimension supported in a compute dispatch.">NVN_DEVICE_INFO_MAX_COMPUTE_DISPATCH_WORK_GROUPS_X</a>).</td></tr>
    <tr><td class="paramname">groupsY</td><td>The number of compute work groups in the Y dimension. Must be less than or equal to 65535 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a5f2caf0b93f02718c5db35ccf3bd02ba" title="Maximum number of work groups in the Y dimension supported in a compute dispatch.">NVN_DEVICE_INFO_MAX_COMPUTE_DISPATCH_WORK_GROUPS_Y</a>).</td></tr>
    <tr><td class="paramname">groupsZ</td><td>The number of compute work groups in the Z dimension. Must be less than or equal to 65535 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50adca24846860ee2ba71a911b9811fd676" title="Maximum number of work groups in the Z dimension supported in a compute dispatch.">NVN_DEVICE_INFO_MAX_COMPUTE_DISPATCH_WORK_GROUPS_Z</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafa16fbe913a0dc193ff71d835abcf404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa16fbe913a0dc193ff71d835abcf404">&#9670;&nbsp;</a></span>nvnCommandBufferDispatchComputeIndirect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferDispatchComputeIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>indirectBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch a new grid of compute shader work groups for processing. </p>
<p>Each compute shader dispatch spawns a three-dimensional array of work groups for processing. Each work group is processed independently, with a three-dimensional array of threads whose size is specified in the compute shader. The number of compute workgroups in each dimension is read from buffer memory.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the indirect data are produced by previous commands executed on the GPU, applications must call nvnCommandBufferBarrier with the <a class="el" href="group__nvn__c__enum.html#ggaab4eabfc248236cc6b42d9de9d735621ad90225b2b4d5e8e3b710573a967ac67e" title="Ensure that all work before the barrier completes before fetching per-draw data for indirect draws an...">NVN_BARRIER_ORDER_INDIRECT_DATA_BIT</a> bit set to ensure that the GPU doesn't fetch the indirect data before previous commands are finished writing the data. Waiting via nvnQueueFinish, nvnQueueWaitSync, or nvnCommandBufferWaitSync is not sufficient to ensure that GPU-produced indirect data are not fetched prematurely.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to dispatch the compute work.</td></tr>
    <tr><td class="paramname">indirectBuffer</td><td>GPU address of buffer object memory holding the indirect dispatch data. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a8b0a281dbb6991d93e30ecbe4d2f63e2" title="Minimum alignment of indirect dispatch data.">NVN_DEVICE_INFO_INDIRECT_DISPATCH_ALIGNMENT</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac4cadef7ff012bc4d218bfd9e510a888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4cadef7ff012bc4d218bfd9e510a888">&#9670;&nbsp;</a></span>nvnCommandBufferSetViewport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetViewport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the rectangle for viewport 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">x</td><td>Smallest X coordinate of the viewport rectangle.</td></tr>
    <tr><td class="paramname">y</td><td>Smallest Y coordinate of the viewport rectangle.</td></tr>
    <tr><td class="paramname">w</td><td>Width of the viewport rectangle.</td></tr>
    <tr><td class="paramname">h</td><td>Height of the viewport rectangle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2730fee1fd83ed7b15d81b46f6c73c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2730fee1fd83ed7b15d81b46f6c73c41">&#9670;&nbsp;</a></span>nvnCommandBufferSetViewports()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetViewports </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const float *&#160;</td>
          <td class="paramname"><em>ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify one or more viewport rectangles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">first</td><td>Index of the first viewport to modify.</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous viewports to set.</td></tr>
    <tr><td class="paramname">ranges</td><td>An array of values to use for the viewports. The array must contain 4 * <em>count</em> values corresponding to the range of viewports specified by <em>first</em> and <em>count</em>. Each quartet of values corresponds to, in order: the smallest X coordinate of the viewport, the smallest Y coordinate of the viewport, the width of the viewport, and the height of the viewport. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga92a714477d6eaad9ca388efc5ecd31e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92a714477d6eaad9ca388efc5ecd31e3">&#9670;&nbsp;</a></span>nvnCommandBufferSetViewportSwizzles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetViewportSwizzles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="group__nvn__c__enum.html#ga00e92e1d7e5fff49496f813b6288ec0f">NVNviewportSwizzle</a> *&#160;</td>
          <td class="paramname"><em>swizzles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a set of viewport swizzle selectors for one or more viewport rectangles. </p>
<p>As part of the viewport transformation, each vertex is transformed by the viewport swizzle operation before the vertex is transformed to screen space. The viewport swizzle produces a four-component swizzled position, where each component is produced by selecting and optionally negating one of the four compenents of the original vertex position. This command specifies sets of four swizzle selectors used to produce the transformed position. The default swizzles for each viewport are POSITIVE_X, POSITIVE_Y, POSITIVE_Z, and POSITIVE_W, which specify no change to the incoming position.</p>
<dl class="section note"><dt>Note</dt><dd>There is a separate set of four viewport swizzle values for each viewport. A primitive broadcast to multiple viewports will have a separate swizzle applied for each viewport.</dd>
<dd>
Viewport swizzles rasterization is only supported on NX and second-generation Maxwell and later GPUs. Query the SUPPORTS_VIEWPORT_SWIZZLE device property to determine if this command is supported.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">first</td><td>Index of the first viewport to modify.</td></tr>
    <tr><td class="paramname">count</td><td>Number of consecutive viewports to update.</td></tr>
    <tr><td class="paramname">swizzles</td><td>An array of swizzle values to use for the viewports. This array must contain 4 * <em>count</em> values corresponding to the range of viewports specified by <em>first</em> and <em>count</em>. Each set of four values identifies the input position component used for the X, Y, Z, and W components, respectively, of the position vector produced by the viewport swizzle operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac6c38cac9330ae402f2f911d1e1aa757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6c38cac9330ae402f2f911d1e1aa757">&#9670;&nbsp;</a></span>nvnCommandBufferSetScissor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetScissor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the scissor rectangle used for clipping primitives and clears. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">x</td><td>Smallest X coordinate of the scissor rectangle.</td></tr>
    <tr><td class="paramname">y</td><td>Smallest Y coordinate of the scissor rectangle.</td></tr>
    <tr><td class="paramname">w</td><td>Width of the scissor rectangle.</td></tr>
    <tr><td class="paramname">h</td><td>Height of the scissor rectangle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1c88523532adae470502025229b62f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c88523532adae470502025229b62f08">&#9670;&nbsp;</a></span>nvnCommandBufferSetScissors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetScissors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const int *&#160;</td>
          <td class="paramname"><em>rects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify one or more scissor rectangles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">first</td><td>Index of the first scissor rectangle to modify.</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous scissor rectangles to set.</td></tr>
    <tr><td class="paramname">rects</td><td>An array of values to use for the scissor rectangles. The array must contain 4 * <em>count</em> values corresponding to the range of scissor rectangles specified by <em>first</em> and <em>count</em>. Each quartet of values corresponds to, in order: the smallest X coordinate of the rectangle, the smallest Y coordinate of the rectangle, the width of the rectangle, and the height of the rectangle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga82e8dc14164ab8018898a76e07e6e86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82e8dc14164ab8018898a76e07e6e86a">&#9670;&nbsp;</a></span>nvnCommandBufferSetDepthRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetDepthRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the range of depth values for rendered primitives. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to change the depth range.</td></tr>
    <tr><td class="paramname">n</td><td>Depth value corresponding to the near clip plane.</td></tr>
    <tr><td class="paramname">f</td><td>Depth value corresponding to the far clip plane. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4b174a2678de189471d5466ca2bfd4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b174a2678de189471d5466ca2bfd4d3">&#9670;&nbsp;</a></span>nvnCommandBufferSetDepthBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetDepthBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control the operation of the depth bounds test. </p>
<p>This command lets applications enable or disable the depth bounds test. When enabled, the depth bounds test will discard any fragments where the stored Z value in the depth buffer is outside the range [<em>n</em>, <em>f</em>]. By default, the depth bounds test is disabled.</p>
<dl class="section warning"><dt>Warning</dt><dd>When the depth bounds test is enabled, <em>n</em> must be less than or equal to <em>f</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to change the depth bounds test.</td></tr>
    <tr><td class="paramname">enable</td><td>Enable or disable the depth bounds test.</td></tr>
    <tr><td class="paramname">n</td><td>Minimum value of the depth bounds test range.</td></tr>
    <tr><td class="paramname">f</td><td>Maximum value of the depth bounds test range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6edc6a9aa34e0f383cfbdb0e78d20605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6edc6a9aa34e0f383cfbdb0e78d20605">&#9670;&nbsp;</a></span>nvnCommandBufferSetDepthRanges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetDepthRanges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const float *&#160;</td>
          <td class="paramname"><em>ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets multiple ranges of depth values for rendered primitives. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">first</td><td>Index of the first depth range to modify.</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous depth ranges to set.</td></tr>
    <tr><td class="paramname">ranges</td><td>An array of values to use for the depth ranges. It must contain <em>count</em> pairs of values corresponding to the depth ranges specified by <em>first</em> and <em>count</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae2e294bc785c1a41a874f71fe5b277d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2e294bc785c1a41a874f71fe5b277d4">&#9670;&nbsp;</a></span>nvnCommandBufferSetTiledCacheAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetTiledCacheAction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaa34a73b0ed878a1ee610efb60d5bbb9c">NVNtiledCacheAction</a>&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a specified operation related to tiled caching. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">action</td><td>Tiled caching operation to perform. Actions include enabling, disabling, or flushing the tiled cache binner. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga682b6f01fe95daff5aa16c5b044fca32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga682b6f01fe95daff5aa16c5b044fca32">&#9670;&nbsp;</a></span>nvnCommandBufferSetTiledCacheTileSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetTiledCacheTileSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tileWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tileHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the tile size used for tiled caching. </p>
<p>If the tile size has changed, the hardware will automatically flush the tiled cache binner. The tile size is clamped to [16, 16384] in either dimension.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">tileWidth</td><td>Sets the tile width, in pixels.</td></tr>
    <tr><td class="paramname">tileHeight</td><td>Sets the tile height, in pixels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9b5b85ce0b512e73c9d3b5ad067c3bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b5b85ce0b512e73c9d3b5ad067c3bbe">&#9670;&nbsp;</a></span>nvnCommandBufferBindSeparateTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindSeparateTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_nseparate_texture_handle.html">NVNseparateTextureHandle</a>&#160;</td>
          <td class="paramname"><em>textureHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a separate <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> to use for texture mapping in shaders. </p>
<p>This command binds a separate texture handle (without sampler information) for use with shaders using separate texture types. These bindings are not used for variables with combined sampler types (such as "sampler2D" in GLSL shaders).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the separate <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> binding point to update.</td></tr>
    <tr><td class="paramname">index</td><td>Separate <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> binding point number to update. Must be less than 128 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a908ba4406dc9e894d8a13f8e2b8c4bbf" title="Number of separate texture bindings supported for each shader stage.">NVN_DEVICE_INFO_SEPARATE_TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">textureHandle</td><td>Separate <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> handle for the separate <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaee3d37a925075c3b7309519710eba21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee3d37a925075c3b7309519710eba21c">&#9670;&nbsp;</a></span>nvnCommandBufferBindSeparateSampler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindSeparateSampler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_nseparate_sampler_handle.html">NVNseparateSamplerHandle</a>&#160;</td>
          <td class="paramname"><em>samplerHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a separate <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> to use for texture mapping in shaders. </p>
<p>This command binds a separate sampler handle (without texture information) for use with shaders using separate sampler types. These bindings are not used for variables with combined sampler types (such as "sampler2D" in GLSL shaders).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the separate <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> binding point to update.</td></tr>
    <tr><td class="paramname">index</td><td>Separate <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> binding point number to update. Must be less than 32 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a238ded224f2bed89b13843fb328771cc" title="Number of separate sampler bindings supported for each shader stage.">NVN_DEVICE_INFO_SEPARATE_SAMPLER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">samplerHandle</td><td>Separate <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> handle for the separate <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> object to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae2120b1cf857f2c687ee18530b6aef0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2120b1cf857f2c687ee18530b6aef0e">&#9670;&nbsp;</a></span>nvnCommandBufferBindSeparateTextures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindSeparateTextures </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_nseparate_texture_handle.html">NVNseparateTextureHandle</a> *&#160;</td>
          <td class="paramname"><em>textureHandles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more separate textures to use for texture mapping in shaders. </p>
<p>This command binds one or more separate texture handles (without sampler information) for use with shaders using separate texture types. These bindings are not used for variables with combined sampler types (such as "sampler2D" in GLSL shaders). This command is equivalent to making multiple calls to BindSeparateTexture.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding points to update.</td></tr>
    <tr><td class="paramname">first</td><td>First separate texture binding point number to update. Must be less than 128 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a908ba4406dc9e894d8a13f8e2b8c4bbf" title="Number of separate texture bindings supported for each shader stage.">NVN_DEVICE_INFO_SEPARATE_TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous separate texture binding points to update. Must be less than or equal to 128 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a908ba4406dc9e894d8a13f8e2b8c4bbf" title="Number of separate texture bindings supported for each shader stage.">NVN_DEVICE_INFO_SEPARATE_TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">textureHandles</td><td>Array of handles of separate <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1ae38068201854f531108a986b081d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ae38068201854f531108a986b081d4b">&#9670;&nbsp;</a></span>nvnCommandBufferBindSeparateSamplers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindSeparateSamplers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_nseparate_sampler_handle.html">NVNseparateSamplerHandle</a> *&#160;</td>
          <td class="paramname"><em>samplerHandles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more Samplers to use for texture mapping in shaders. </p>
<p>This command binds one or more separate sampler handles (without texture information) for use with shaders using separate sampler types. These bindings are not used for variables with combined sampler types (such as "sampler2D" in GLSL shaders). This command is equivalent to making multiple calls to BindSeparateSampler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding points to update.</td></tr>
    <tr><td class="paramname">first</td><td>First separate sampler binding point number to update. Must be less than 32 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a238ded224f2bed89b13843fb328771cc" title="Number of separate sampler bindings supported for each shader stage.">NVN_DEVICE_INFO_SEPARATE_SAMPLER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous separate sampler binding points to update. Must be less than or equal to 32 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a238ded224f2bed89b13843fb328771cc" title="Number of separate sampler bindings supported for each shader stage.">NVN_DEVICE_INFO_SEPARATE_SAMPLER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">samplerHandles</td><td>Array of handles of separate <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga84c5b79a065744d3c4937123af4e17b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84c5b79a065744d3c4937123af4e17b3">&#9670;&nbsp;</a></span>nvnCommandBufferBindSeparateTexturesDeferred()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindSeparateTexturesDeferred </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nseparate_texture_handle.html">NVNseparateTextureHandle</a> *&#160;</td>
          <td class="paramname"><em>textureHandles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more separate textures to use for texture mapping in shaders. </p>
<p>This command binds one or more separate texture handles (without sampler information) for use with shaders using separate texture types. These bindings are not used for variables with combined sampler types (such as "sampler2D" in GLSL shaders). This command is equivalent to making multiple calls to BindSeparateTexture.</p>
<p>When recording this command, the pointer to the set of separate texture handles is not dereferenced when the command set is recorded. Instead, it is dereferenced only when the command set containing this command is submitted to a queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding points to update.</td></tr>
    <tr><td class="paramname">first</td><td>First separate texture binding point number to update. Must be less than 128 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a908ba4406dc9e894d8a13f8e2b8c4bbf" title="Number of separate texture bindings supported for each shader stage.">NVN_DEVICE_INFO_SEPARATE_TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous separate texture binding points to update. Must be less than or equal to 128 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a908ba4406dc9e894d8a13f8e2b8c4bbf" title="Number of separate texture bindings supported for each shader stage.">NVN_DEVICE_INFO_SEPARATE_TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">textureHandles</td><td>Array of handles of separate <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9fa5a61a760f767ada6c768ba8c18a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fa5a61a760f767ada6c768ba8c18a71">&#9670;&nbsp;</a></span>nvnCommandBufferBindSeparateTexturesDeferred_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnCommandBufferBindSeparateTexturesDeferred_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nseparate_texture_handle.html">NVNseparateTextureHandle</a> *&#160;</td>
          <td class="paramname"><em>textureHandles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more separate textures to use for texture mapping in shaders. </p>
<p>Fastpath variant.</p>
<p>This command binds one or more separate texture handles (without sampler information) for use with shaders using separate texture types. These bindings are not used for variables with combined sampler types (such as "sampler2D" in GLSL shaders). This command is equivalent to making multiple calls to BindSeparateTexture.</p>
<p>When recording this command, the pointer to the set of separate texture handles is not dereferenced when the command set is recorded. Instead, it is dereferenced only when the command set containing this command is submitted to a queue.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnCommandBufferBindSeparateTexturesDeferred, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding points to update.</td></tr>
    <tr><td class="paramname">first</td><td>First separate texture binding point number to update. Must be less than 128 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a908ba4406dc9e894d8a13f8e2b8c4bbf" title="Number of separate texture bindings supported for each shader stage.">NVN_DEVICE_INFO_SEPARATE_TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous separate texture binding points to update. Must be less than or equal to 128 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a908ba4406dc9e894d8a13f8e2b8c4bbf" title="Number of separate texture bindings supported for each shader stage.">NVN_DEVICE_INFO_SEPARATE_TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">textureHandles</td><td>Array of handles of separate <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> objects to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae4df7161364cf51b04adbc44f41cb809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4df7161364cf51b04adbc44f41cb809">&#9670;&nbsp;</a></span>nvnCommandBufferBindSeparateSamplersDeferred()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindSeparateSamplersDeferred </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nseparate_sampler_handle.html">NVNseparateSamplerHandle</a> *&#160;</td>
          <td class="paramname"><em>samplerHandles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more Samplers to use for texture mapping in shaders. </p>
<p>This command binds one or more separate sampler handles (without texture information) for use with shaders using separate sampler types. These bindings are not used for variables with combined sampler types (such as "sampler2D" in GLSL shaders). This command is equivalent to making multiple calls to BindSeparateSampler.</p>
<p>When recording this command, the pointer to the set of separate sampler handles is not dereferenced when the command set is recorded. Instead, it is dereferenced only when the command set containing this command is submitted to a queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding points to update.</td></tr>
    <tr><td class="paramname">first</td><td>First separate sampler binding point number to update. Must be less than 32 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a238ded224f2bed89b13843fb328771cc" title="Number of separate sampler bindings supported for each shader stage.">NVN_DEVICE_INFO_SEPARATE_SAMPLER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous separate sampler binding points to update. Must be less than or equal to 32 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a238ded224f2bed89b13843fb328771cc" title="Number of separate sampler bindings supported for each shader stage.">NVN_DEVICE_INFO_SEPARATE_SAMPLER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">samplerHandles</td><td>Array of handles of separate <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga78c40fd8ad57f52512ac2f3e534edab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78c40fd8ad57f52512ac2f3e534edab6">&#9670;&nbsp;</a></span>nvnCommandBufferBindSeparateSamplersDeferred_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnCommandBufferBindSeparateSamplersDeferred_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nseparate_sampler_handle.html">NVNseparateSamplerHandle</a> *&#160;</td>
          <td class="paramname"><em>samplerHandles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more Samplers to use for texture mapping in shaders. </p>
<p>Fastpath variant.</p>
<p>This command binds one or more separate sampler handles (without texture information) for use with shaders using separate sampler types. These bindings are not used for variables with combined sampler types (such as "sampler2D" in GLSL shaders). This command is equivalent to making multiple calls to BindSeparateSampler.</p>
<p>When recording this command, the pointer to the set of separate sampler handles is not dereferenced when the command set is recorded. Instead, it is dereferenced only when the command set containing this command is submitted to a queue.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnCommandBufferBindSeparateSamplersDeferred, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding points to update.</td></tr>
    <tr><td class="paramname">first</td><td>First separate sampler binding point number to update. Must be less than 32 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a238ded224f2bed89b13843fb328771cc" title="Number of separate sampler bindings supported for each shader stage.">NVN_DEVICE_INFO_SEPARATE_SAMPLER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous separate sampler binding points to update. Must be less than or equal to 32 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a238ded224f2bed89b13843fb328771cc" title="Number of separate sampler bindings supported for each shader stage.">NVN_DEVICE_INFO_SEPARATE_SAMPLER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">samplerHandles</td><td>Array of handles of separate <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab057345ad441b37deda70d0434d0cb5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab057345ad441b37deda70d0434d0cb5f">&#9670;&nbsp;</a></span>nvnCommandBufferSetStencilValueMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetStencilValueMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a>&#160;</td>
          <td class="paramname"><em>faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a mask that will be applied to the stencil index and reference values prior to performing the stencil test. </p>
<p>There are separate stencil value masks for front- and back-facing primitives. This function can update the value of either or both masks. If stencil testing is disabled, the stencil value mask has no effect. The default value for both front and back masks is 0xFF (all bits set).</p>
<dl class="section note"><dt>Note</dt><dd>In API versions prior to 53.8, the default mask was unintentionally set to zero.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">faces</td><td>Specifies the face(s) (front and/or back) using the new stencil value mask.</td></tr>
    <tr><td class="paramname">mask</td><td>Mask to be applied to stencil index and reference values prior to the stencil test </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5f084072b85bde09e40e4920fce1be65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f084072b85bde09e40e4920fce1be65">&#9670;&nbsp;</a></span>nvnCommandBufferSetStencilMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetStencilMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a>&#160;</td>
          <td class="paramname"><em>faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a mask to apply to stencil values written by the stencil test. </p>
<p>Bits in the existing stencil index corresponding to zero bits in the stencil mask will not be updated by the stencil test. There are separate stencil masks for front- and back-facing primitives. This function can update the value of either or both masks. If stencil testing is disabled, the stencil mask has no effect. The default value for both front and back masks is 0xFF (all bits set).</p>
<dl class="section note"><dt>Note</dt><dd>In API versions prior to 53.8, the default mask was unintentionally set to zero.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">faces</td><td>Specifies the face(s) (front and/or back) using the new stencil mask.</td></tr>
    <tr><td class="paramname">mask</td><td>Mask to apply to stencil values written by the stencil test. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3670a8f6d5e0a5267dfb69919d46d8d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3670a8f6d5e0a5267dfb69919d46d8d5">&#9670;&nbsp;</a></span>nvnCommandBufferSetStencilRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetStencilRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a>&#160;</td>
          <td class="paramname"><em>faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a stencil reference value used by the stencil test. </p>
<p>There are separate reference values for front- and back-facing primitives. This function can update the value of either or both values. If stencil testing is disabled, the stencil reference value has no effect. The default reference value for both front and back is zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">faces</td><td>Specifies the face(s) (front and/or back) using the new stencil reference value.</td></tr>
    <tr><td class="paramname">ref</td><td>Stencil reference value used by the stencil test. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5a8731d746a400b1cb433971c1091bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a8731d746a400b1cb433971c1091bd6">&#9670;&nbsp;</a></span>nvnCommandBufferSetBlendColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetBlendColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const float *&#160;</td>
          <td class="paramname"><em>blendColor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies a constant color that may be used by blending functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">blendColor</td><td>Array of four floating-point (RGBA) blend color values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf3a20e6577e2780cf1de7487730a2086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3a20e6577e2780cf1de7487730a2086">&#9670;&nbsp;</a></span>nvnCommandBufferSetPointSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetPointSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pointSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the size (in pixels) of point primitives to render. </p>
<p>If the last enabled vertex, tessellation control, tessellation evaluation, or geometry shader writes to gl_PointSize, this value is ignored and point size written in that shader will be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">pointSize</td><td>Size (in pixels) of point primitives to render. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafb4bb0bdb2ac78ee60e2e3e5138ce22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb4bb0bdb2ac78ee60e2e3e5138ce22e">&#9670;&nbsp;</a></span>nvnCommandBufferSetLineWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetLineWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lineWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the width (in pixels) of line primitives to render. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">lineWidth</td><td>Width (in pixels) of line primitives to render. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga81867da9e1301f27904dae46435c931b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81867da9e1301f27904dae46435c931b">&#9670;&nbsp;</a></span>nvnCommandBufferSetPolygonOffsetClamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetPolygonOffsetClamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>units</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>clamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies values used to compute a depth offset value when polygon offset is enabled. </p>
<p>The offset is computed by multiplying the maximum depth slope of the primitive [sqrt((dz/dx)^2 + (dz/dy)^2)] by <em>factor</em>, adding in the minimum resolvable difference in depth values multiplied by <em>units</em>, and clamping the result as described in the documentation for <em>clamp</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">factor</td><td>Value multiplied by the maximum depth slope when computing offset.</td></tr>
    <tr><td class="paramname">units</td><td>Value multiplied by the minimum resolvable depth difference when computing offset.</td></tr>
    <tr><td class="paramname">clamp</td><td>Value used to clamp the computed offset. If <code>clamp</code> is positive, the computed depth offset will be clamped to a value less than or equal to <code>clamp</code>. If <code>clamp</code> is negative, the computed depth offset will be clamped to a value greater than or equal to <code>clamp</code>. If <code>clamp</code> is zero, the computed depth offset will not be clamped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab298722737de06614902b5e15ffadea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab298722737de06614902b5e15ffadea6">&#9670;&nbsp;</a></span>nvnCommandBufferSetAlphaRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetAlphaRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies a reference value to use for alpha testing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">ref</td><td>Reference value for the alpha test. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadcba5a3b987a3f421ca0566a48dbf62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcba5a3b987a3f421ca0566a48dbf62e">&#9670;&nbsp;</a></span>nvnCommandBufferSetSampleMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetSampleMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies a mask of samples that may be covered by rendered primitives. </p>
<p>If bit N is zero in the provided mask, sample N will never be considered to be covered when rasterizing primitives.</p>
<p>The default sample mask is ~0 (all bits enabled).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">mask</td><td>Mask of samples that may be covered by rendered primitives. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacff1db19e51d3dec85a952263345dcff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacff1db19e51d3dec85a952263345dcff">&#9670;&nbsp;</a></span>nvnCommandBufferSetRasterizerDiscard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetRasterizerDiscard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>discard</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable rasterizer discard. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to change the rasterizer discard state. When enabled, rasterizer discard instructs the GPU to discard all primitives produced by Draw* commands prior to rasterization and fragment processing. Such primitives are still processed by vertex, tessellation, and geometry shaders and will be captured by transform feedback, if enabled. Additionally, when enabled, clears of color, depth, and stencil buffers will be discarded.</td></tr>
    <tr><td class="paramname">discard</td><td>True if primitives should be discarded; false (default) otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5ddab005c7a86e3b0b29a62932893cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ddab005c7a86e3b0b29a62932893cb4">&#9670;&nbsp;</a></span>nvnCommandBufferSetDepthClamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetDepthClamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>clamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/disable depth clamping of rendered primitives. </p>
<p>When enabled, primitives are not clipped to the near and far clip planes. Instead, primitives are rasterized without clipping in Z, and interpolated Z values are clamped to the extents of the depth range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to change the depth range.</td></tr>
    <tr><td class="paramname">clamp</td><td>TRUE if depth clamping should be enabled; FALSE otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1e231e88d224fc168ca94e22252be6e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e231e88d224fc168ca94e22252be6e3">&#9670;&nbsp;</a></span>nvnCommandBufferSetConservativeRasterEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetConservativeRasterEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/disable conservative rasterization of rendered primitives. </p>
<p>Conservative rasterization is only supported on second-generation Maxwell and later GPUs. Query the SUPPORTS_CONSERVATIVE_RASTER device property to determine support.</p>
<p>By default, conservative rasterization is disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to toggle conservative rasterization.</td></tr>
    <tr><td class="paramname">enable</td><td>TRUE if conservative rasterization should be enabled; FALSE, otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaced655069ef6e505fddd493fb0d33606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaced655069ef6e505fddd493fb0d33606">&#9670;&nbsp;</a></span>nvnCommandBufferSetConservativeRasterDilate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetConservativeRasterDilate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dilate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the degree of primitive dilation when conservative rasterization is enabled. </p>
<p>This provides a mechanism for "over-conservative" rasterization by dilating (expanding) primitives prior to rasterization. <em>dilate</em> is automatically clamped to the range [0.0, 0.75] and rounded up to a multiple of 0.25. When <em>dilate</em> is 0.0, ordinary conservative rasterization is performed. When dilate is greater than 0.0, rasterized primitives are dilated by <em>dilate</em> pixels. If conservative rasterization is disabled, dilation has no effect on rasterization. This function is only supported on second-generation Maxwell and later GPUs. Query the SUPPORTS_CONSERVATIVE_RASTER device property to determine support.</p>
<p>By default, conservative rasterization is disabled.</p>
<dl class="section warning"><dt>Warning</dt><dd>Changing the dilation setting requires idling the GPU and results in reduced performance. Applications should avoid changing the dilation factor frequently.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to update conservative raster dilation.</td></tr>
    <tr><td class="paramname">dilate</td><td>The fraction of a pixel by which to dilate rasterized primitives. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6c5fe84c110d0a48de87c2f6f83eb6e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c5fe84c110d0a48de87c2f6f83eb6e3">&#9670;&nbsp;</a></span>nvnCommandBufferSetSubpixelPrecisionBias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetSubpixelPrecisionBias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>yBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the number of additional bits of subpixel precision to be used for primitive rasterization when conservative rasterization is enabled. </p>
<p>When vertices are transformed to window coordinates, they are snapped to fixed-point positions. By default, the number of bits of fractional precision within a pixel is given by the device property SUBPIXEL_BITS. This function enables applications to increase the subpixel precision for snapped vertex positions. If conservative rasterization is disabled, additional bias bits have no effect on rasterization.</p>
<p>Additional subpixel precision allows for consistent conservative rasterization when rendering the same geometry at different resolutions. Rasterizing a scene at 64x64 with 3 extra subpixel bits in X and Y will have the same snapping behavior as rasterizing the same scene at 512x512 with no extra subpixel bits.</p>
<p>By default, the subpixel precision bias is 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to update conservative raster bias bits.</td></tr>
    <tr><td class="paramname">xBits</td><td>The number of additional bits of subpixel precision in the horizontal direction. Must be less than or equal to 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a5f9b4fb232267d68961d17111ed70752" title="The maximum number of additional bits of subpixel precision that can be used to represent vertex wind...">NVN_DEVICE_INFO_MAX_SUBPIXEL_BIAS_BITS</a>).</td></tr>
    <tr><td class="paramname">yBits</td><td>The number of additional bits of subpixel precision in the vertical direction. Must be less than or equal to 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a5f9b4fb232267d68961d17111ed70752" title="The maximum number of additional bits of subpixel precision that can be used to represent vertex wind...">NVN_DEVICE_INFO_MAX_SUBPIXEL_BIAS_BITS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga61bd6278e489d30dc49f054f1ea00cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61bd6278e489d30dc49f054f1ea00cff">&#9670;&nbsp;</a></span>nvnCommandBufferCopyBufferToTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferCopyBufferToTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>dstTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>dstView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *&#160;</td>
          <td class="paramname"><em>dstRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy texture data from buffer memory into a region of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the copy.</td></tr>
    <tr><td class="paramname">src</td><td>Address of the buffer holding the source data for the copy.</td></tr>
    <tr><td class="paramname">dstTexture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object used as the destination for the copy.</td></tr>
    <tr><td class="paramname">dstView</td><td>View of the texture object used as the destination for the copy. A texture view, if specified, can be used to override properties of the corresponding texture <em>dstTexture</em>. This parameter identifies a specific mipmap level, set of layers or alternate format in the specified texture. Other fields, such as swizzle, are ignored. If NULL is specified, the base level of the texture <em>dstTexture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">dstRegion</td><td>Region of the destination texture to update for the copy.</td></tr>
    <tr><td class="paramname">flags</td><td>Specifies options used when performing the copy. See <a class="el" href="group__nvn__c__enum.html#ga264a21eefa322cd0ad9acf4c2ab949ad" title="Flags controlling the operation of copy commands.">NVNcopyFlags</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaad014cbb33dea53090529aafb29ecfe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad014cbb33dea53090529aafb29ecfe8">&#9670;&nbsp;</a></span>nvnCommandBufferCopyTextureToBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferCopyTextureToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>srcTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>srcView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *&#160;</td>
          <td class="paramname"><em>srcRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy texture data from a region of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object into buffer memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the copy.</td></tr>
    <tr><td class="paramname">srcTexture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object used as the source for the copy.</td></tr>
    <tr><td class="paramname">srcView</td><td>View of the texture object used as the source for the copy. A texture view, if specified, can be used to override properties of the corresponding texture <em>srcTexture</em>. This parameter identifies a specific mipmap level, set of layers or alternate format in the specified texture. Other fields, such as swizzle, are ignored. If NULL is specified, the base level of the texture <em>srcTexture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">srcRegion</td><td>Region of the source texture to copy from.</td></tr>
    <tr><td class="paramname">dst</td><td>Address of the buffer holding the destination data for the copy.</td></tr>
    <tr><td class="paramname">flags</td><td>Specifies options used when performing the copy. See <a class="el" href="group__nvn__c__enum.html#ga264a21eefa322cd0ad9acf4c2ab949ad" title="Flags controlling the operation of copy commands.">NVNcopyFlags</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0ff5b7b182fe231019b0927b419a799b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ff5b7b182fe231019b0927b419a799b">&#9670;&nbsp;</a></span>nvnCommandBufferCopyTextureToTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferCopyTextureToTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>srcTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>srcView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *&#160;</td>
          <td class="paramname"><em>srcRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>dstTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>dstView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *&#160;</td>
          <td class="paramname"><em>dstRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy texture data from a region of one <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object into a region of another <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object. </p>
<p>Copies texture data from the region <em>srcRegion</em> of a view of the source texture to the region <em>dstRegion</em> of a view of the destination texture. If <em>srcRegion</em> and <em>dstRegion</em> are of different sizes, the source region will be scaled when copying. If <a class="el" href="group__nvn__c__enum.html#gga264a21eefa322cd0ad9acf4c2ab949ada538f93eef3f762d31d30bef43ba898e0" title="Enable linear filtering for texture-to-texture copies.">NVN_COPY_FLAGS_LINEAR_FILTER_BIT</a> is set in <em>flags</em> when scaling, the copy will average texels from the source. Otherwise, the copy will select the nearest source texel for each destination texel.</p>
<dl class="section note"><dt>Note</dt><dd>If the source and destination regions overlap in memory, the results of the copy will be undefined.</dd>
<dd>
Filtering across layers of a source texture is not supported; the number of layers in <em>srcRegion</em> and <em>dstRegion</em> must match.</dd>
<dd>
Linear filtering is supported for a limited subset of source and destination formats, as documented in the Programming Guide.</dd>
<dd>
Copies involving multisample textures are not supported.</dd>
<dd>
Copies of compressed formats must be aligned on compression block boundaries and do not support scaling.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the copy.</td></tr>
    <tr><td class="paramname">srcTexture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object holding the source data for the copy.</td></tr>
    <tr><td class="paramname">srcView</td><td>View of the texture object used as the source for the copy. A texture view, if specified, can be used to override properties of the corresponding texture <em>srcTexture</em>. This parameter identifies a specific mipmap level, set of layers or alternate format in the specified texture. Other fields, such as swizzle, are ignored. If NULL is specified, the base level of the texture <em>srcTexture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">srcRegion</td><td>Region of the source texture to read from.</td></tr>
    <tr><td class="paramname">dstTexture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object used as the destination for the copy.</td></tr>
    <tr><td class="paramname">dstView</td><td>View of the texture object used as the destination for the copy. A texture view, if specified, can be used to override properties of the corresponding texture <em>dstTexture</em>. This parameter identifies a specific mipmap level, set of layers or alternate format in the specified texture. Other fields, such as swizzle, are ignored. If NULL is specified, the base level of the texture <em>dstTexture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">dstRegion</td><td>Region of the destination texture to write to.</td></tr>
    <tr><td class="paramname">flags</td><td>Specifies options used when performing the copy. See <a class="el" href="group__nvn__c__enum.html#ga264a21eefa322cd0ad9acf4c2ab949ad" title="Flags controlling the operation of copy commands.">NVNcopyFlags</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafd877eff408eaf5795b2e6affa58d2c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd877eff408eaf5795b2e6affa58d2c7">&#9670;&nbsp;</a></span>nvnCommandBufferCopyBufferToBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferCopyBufferToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule a copy of data from one <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object into another <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the copy.</td></tr>
    <tr><td class="paramname">src</td><td>Address of the buffer holding the source data for the copy.</td></tr>
    <tr><td class="paramname">dst</td><td>Address of the buffer holding the destination data for the copy.</td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to copy between source and destination buffers.</td></tr>
    <tr><td class="paramname">flags</td><td>Specifies options used when performing the copy. See of <a class="el" href="group__nvn__c__enum.html#ga264a21eefa322cd0ad9acf4c2ab949ad" title="Flags controlling the operation of copy commands.">NVNcopyFlags</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab0d38dd93f857f1242072e0fc1d3aa05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0d38dd93f857f1242072e0fc1d3aa05">&#9670;&nbsp;</a></span>nvnCommandBufferClearBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferClearBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a buffer to a 32-bit integer value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the clear.</td></tr>
    <tr><td class="paramname">dst</td><td>Address of the buffer holding the destination data for the clear. This address should be aligned to 4 bytes.</td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to clear. Size must be a multiple of four. Clears with zero size are treated as no-ops.</td></tr>
    <tr><td class="paramname">value</td><td>32-bit integer value to clear with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa49f5f00f5245458671621105c1258b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa49f5f00f5245458671621105c1258b9">&#9670;&nbsp;</a></span>nvnCommandBufferClearTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferClearTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>dstTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>dstView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *&#160;</td>
          <td class="paramname"><em>dstRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const float *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a color buffer using floating point clear color values. </p>
<p>Clears texture data from the region <em>region</em> of a view of the destination texture.</p>
<p>This command supports only texture formats that can be bound as a render target. Please refer to the 'Render' column in the programming guide's <a class="el" href="nvn_index.html#nvn_guide_formats_table">formats table</a> for supported formats.</p>
<dl class="section warning"><dt>Warning</dt><dd>Unlike Copy commands, ClearTexure renders to the texture using the 3D Engine. Before accessing the cleared texture, applications must ensure that the GPU commands producing the new data have completed with <a class="el" href="group__nvn__c__enum.html#gaab4eabfc248236cc6b42d9de9d735621" title="Controls the ordering of commands and invalidation of caches for nvnCommandBufferBarrier.">NVNbarrierBits</a> of ORDER_FRAGMENTS and INVALIDATE_TEXTURE or by waiting on a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object. When clearing a linear texture, the texture must have been created with the LINEAR_RENDER_TARGET flag set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the clear.</td></tr>
    <tr><td class="paramname">dstTexture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object used as the destination for the clear.</td></tr>
    <tr><td class="paramname">dstView</td><td>View of the texture object used as the destination for the clear. A texture view, if specified, can be used to override properties of the corresponding texture <em>dstTexture</em>. If NULL is specified, the base level of the texture <em>dstTexture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">dstRegion</td><td>Region of the destination texture to write to.</td></tr>
    <tr><td class="paramname">color</td><td>Array of four floating-point (RGBA) clear color values.</td></tr>
    <tr><td class="paramname">mask</td><td>Bitfield indicating which color channels should be cleared. See of <a class="el" href="group__nvn__c__enum.html#gac703c5549157a2c6efb057f8047bde0f" title="Specifies the set of color buffer channels enabled for writing.">NVNclearColorMask</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2ba0b1e7a75abe28a3ce14d815de7509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ba0b1e7a75abe28a3ce14d815de7509">&#9670;&nbsp;</a></span>nvnCommandBufferClearTexturei()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferClearTexturei </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>dstTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>dstView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *&#160;</td>
          <td class="paramname"><em>dstRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const int *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a color buffer using signed integer clear color values. </p>
<p>Clears texture data from the region <em>region</em> of a view of the destination texture.</p>
<p>This command supports only texture formats that can be bound as a render target. Please refer to the 'Render' column in the programming guide's <a class="el" href="nvn_index.html#nvn_guide_formats_table">formats table</a> for supported formats.</p>
<dl class="section warning"><dt>Warning</dt><dd>Unlike Copy commands, ClearTexure renders to the texture using the 3D Engine. Before accessing the cleared texture, applications must ensure that the GPU commands producing the new data have completed with <a class="el" href="group__nvn__c__enum.html#gaab4eabfc248236cc6b42d9de9d735621" title="Controls the ordering of commands and invalidation of caches for nvnCommandBufferBarrier.">NVNbarrierBits</a> of ORDER_FRAGMENTS and INVALIDATE_TEXTURE or by waiting on a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object. When clearing a linear texture, the texture must have been created with the LINEAR_RENDER_TARGET flag set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the clear.</td></tr>
    <tr><td class="paramname">dstTexture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object used as the destination for the clear.</td></tr>
    <tr><td class="paramname">dstView</td><td>View of the texture object used as the destination for the clear. A texture view, if specified, can be used to override properties of the corresponding texture <em>dstTexture</em>. If NULL is specified, the base level of the texture <em>dstTexture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">dstRegion</td><td>Region of the destination texture to write to.</td></tr>
    <tr><td class="paramname">color</td><td>Array of four signed integer (RGBA) clear color values.</td></tr>
    <tr><td class="paramname">mask</td><td>Bitfield indicating which color channels should be cleared. See <a class="el" href="group__nvn__c__enum.html#gac703c5549157a2c6efb057f8047bde0f" title="Specifies the set of color buffer channels enabled for writing.">NVNclearColorMask</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga468e09110c2f176ec9bda5f47284ae6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga468e09110c2f176ec9bda5f47284ae6b">&#9670;&nbsp;</a></span>nvnCommandBufferClearTextureui()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferClearTextureui </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>dstTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>dstView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *&#160;</td>
          <td class="paramname"><em>dstRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const uint32_t *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a color buffer using unsigned integer clear color values. </p>
<p>Clears texture data from the region <em>region</em> of a view of the destination texture.</p>
<p>This command supports only texture formats that can be bound as a render target. Please refer to the 'Render' column in the programming guide's <a class="el" href="nvn_index.html#nvn_guide_formats_table">formats table</a> for supported formats.</p>
<dl class="section warning"><dt>Warning</dt><dd>Unlike Copy commands, ClearTexure renders to the texture using the 3D Engine. Before accessing the cleared texture, applications must ensure that the GPU commands producing the new data have completed with <a class="el" href="group__nvn__c__enum.html#gaab4eabfc248236cc6b42d9de9d735621" title="Controls the ordering of commands and invalidation of caches for nvnCommandBufferBarrier.">NVNbarrierBits</a> of ORDER_FRAGMENTS and INVALIDATE_TEXTURE or by waiting on a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object. When clearing a linear texture, the texture must have been created with the LINEAR_RENDER_TARGET flag set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the clear.</td></tr>
    <tr><td class="paramname">dstTexture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> object used as the destination for the clear.</td></tr>
    <tr><td class="paramname">dstView</td><td>View of the texture object used as the destination for the clear. A texture view, if specified, can be used to override properties of the corresponding texture <em>dstTexture</em>. If NULL is specified, the base level of the texture <em>dstTexture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">dstRegion</td><td>Region of the destination texture to write to.</td></tr>
    <tr><td class="paramname">color</td><td>Array of four unsigned integer (RGBA) clear color values.</td></tr>
    <tr><td class="paramname">mask</td><td>Bitfield indicating which color channels should be cleared. See of <a class="el" href="group__nvn__c__enum.html#gac703c5549157a2c6efb057f8047bde0f" title="Specifies the set of color buffer channels enabled for writing.">NVNclearColorMask</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacea9343e5ef30fb540cc2f021bfa0f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacea9343e5ef30fb540cc2f021bfa0f74">&#9670;&nbsp;</a></span>nvnCommandBufferUpdateUniformBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferUpdateUniformBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>updateOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>updateSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the contents of a uniform buffer. </p>
<p>This command schedules an update of the contents of a uniform buffer, which will execute without waiting for previous draw calls prior to the update. The update will wait on the completion of previous compute dispatches. Draw calls and compute dispatches issued after the update will use the new uniform buffer values. Calls before the update will use the old values.</p>
<p>To get correct ordering of updates, the range of buffer memory identified by <em>buffer</em> and <em>bufferSize</em> must exactly match the memory range bound via nvnCommandBufferBindUniformBuffer. If any other uniform buffer binding (using a different base address or size) overlaps the range of memory updated by this command, shader accesses using that binding (from commands before or after the update) will return undefined values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the uniform buffer update.</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of the full uniform buffer to update. Must be a multiple of 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ac5b90148e47e9a26cd38b367123ff374" title="Minimum alignment of uniform buffer bindings.">NVN_DEVICE_INFO_UNIFORM_BUFFER_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">bufferSize</td><td>Size (in bytes) of the full uniform buffer to update. Must be less than or equal to 65536 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a3f3db4bfcb9457a4ca25046221f97409" title="Maximum size (in bytes) of a bound uniform buffer.">NVN_DEVICE_INFO_MAX_UNIFORM_BUFFER_SIZE</a>).</td></tr>
    <tr><td class="paramname">updateOffset</td><td>Offset (in bytes) of the first byte to update inside the uniform buffer. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a3a3153b5b8aa5509e8b13aed2c8042f3" title="Alignment required (in bytes) for the offset and size of uniform buffer updates via nvnCommandBufferU...">NVN_DEVICE_INFO_UNIFORM_BUFFER_UPDATE_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">updateSize</td><td>Number of bytes to update inside the uniform buffer. Must be less than or equal to 65536 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a3f3db4bfcb9457a4ca25046221f97409" title="Maximum size (in bytes) of a bound uniform buffer.">NVN_DEVICE_INFO_MAX_UNIFORM_BUFFER_SIZE</a>). Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a3a3153b5b8aa5509e8b13aed2c8042f3" title="Alignment required (in bytes) for the offset and size of uniform buffer updates via nvnCommandBufferU...">NVN_DEVICE_INFO_UNIFORM_BUFFER_UPDATE_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">data</td><td>New data to write into the uniform buffer. The data is consumed before the call returns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0bf01e6a51e19855a7906f9172ce3e39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bf01e6a51e19855a7906f9172ce3e39">&#9670;&nbsp;</a></span>nvnCommandBufferUpdateUniformBuffer_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE void nvnCommandBufferUpdateUniformBuffer_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>updateOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>updateSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the contents of a uniform buffer. </p>
<p>Fastpath variant.</p>
<p>This command schedules an update of the contents of a uniform buffer, which will execute without waiting for previous draw calls prior to the update. The update will wait on the completion of previous compute dispatches. Draw calls and compute dispatches issued after the update will use the new uniform buffer values. Calls before the update will use the old values.</p>
<p>To get correct ordering of updates, the range of buffer memory identified by <em>buffer</em> and <em>bufferSize</em> must exactly match the memory range bound via nvnCommandBufferBindUniformBuffer. If any other uniform buffer binding (using a different base address or size) overlaps the range of memory updated by this command, shader accesses using that binding (from commands before or after the update) will return undefined values.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnCommandBufferUpdateUniformBuffer, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the uniform buffer update.</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of the full uniform buffer to update. Must be a multiple of 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ac5b90148e47e9a26cd38b367123ff374" title="Minimum alignment of uniform buffer bindings.">NVN_DEVICE_INFO_UNIFORM_BUFFER_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">bufferSize</td><td>Size (in bytes) of the full uniform buffer to update. Must be less than or equal to 65536 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a3f3db4bfcb9457a4ca25046221f97409" title="Maximum size (in bytes) of a bound uniform buffer.">NVN_DEVICE_INFO_MAX_UNIFORM_BUFFER_SIZE</a>).</td></tr>
    <tr><td class="paramname">updateOffset</td><td>Offset (in bytes) of the first byte to update inside the uniform buffer. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a3a3153b5b8aa5509e8b13aed2c8042f3" title="Alignment required (in bytes) for the offset and size of uniform buffer updates via nvnCommandBufferU...">NVN_DEVICE_INFO_UNIFORM_BUFFER_UPDATE_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">updateSize</td><td>Number of bytes to update inside the uniform buffer. Must be less than or equal to 65536 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a3f3db4bfcb9457a4ca25046221f97409" title="Maximum size (in bytes) of a bound uniform buffer.">NVN_DEVICE_INFO_MAX_UNIFORM_BUFFER_SIZE</a>). Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a3a3153b5b8aa5509e8b13aed2c8042f3" title="Alignment required (in bytes) for the offset and size of uniform buffer updates via nvnCommandBufferU...">NVN_DEVICE_INFO_UNIFORM_BUFFER_UPDATE_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">data</td><td>New data to write into the uniform buffer. The data is consumed before the call returns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gade6b81268dfab6d9e22de06bbd170951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade6b81268dfab6d9e22de06bbd170951">&#9670;&nbsp;</a></span>nvnCommandBufferReportCounter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferReportCounter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga280033bdac9f8e19de62817c8d200773">NVNcounterType</a>&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a GPU counter and timestamp into buffer object memory. </p>
<p>The GPU maintains a set of counters for each queue that will be incremented on certain events. This function requests that the current value of the counter be written to a specified offset in the specified buffer object. 16 bytes will be written to the buffer object.</p>
<p>Except for the <a class="el" href="group__nvn__c__enum.html#gga280033bdac9f8e19de62817c8d200773a70f06f4dc0079b53603c5c2632a0d470" title="Report zcull counters.">NVN_COUNTER_TYPE_ZCULL_STATS</a> counter, the first 8 bytes hold the 64-bit counter value and the second 8 bytes hold a timestamp when the counter value was reported. <a class="el" href="group__nvn__c__enum.html#gga280033bdac9f8e19de62817c8d200773a70f06f4dc0079b53603c5c2632a0d470" title="Report zcull counters.">NVN_COUNTER_TYPE_ZCULL_STATS</a> reports four 32-bit counter values.</p>
<dl class="section note"><dt>Note</dt><dd>If tiled caching is enabled, this command will trigger an implicit tiled cache flush.</dd>
<dd>
For timestamp, please refer to the <a class="el" href="nvn_index.html#nvn_guide_counter_resolution_of_timestamp">NVN Programming Guide</a> for details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the counter report operation.</td></tr>
    <tr><td class="paramname">counter</td><td>Type of counter that will be written.</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of buffer memory where the counter will be written. Must be a multiple of 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a17852f8ea9a95fc08cce83cbd2886bb1" title="Minimum alignment for counter reports.">NVN_DEVICE_INFO_COUNTER_ALIGNMENT</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga49ee8eb6d0cecd901d9de38d983ceb1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49ee8eb6d0cecd901d9de38d983ceb1a">&#9670;&nbsp;</a></span>nvnCommandBufferResetCounter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferResetCounter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga280033bdac9f8e19de62817c8d200773">NVNcounterType</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset a GPU counter to zero. </p>
<p>The GPU maintains a set of counters for each queue that will be incremented on certain events. This function resets the current value of the counter to zero.</p>
<dl class="section note"><dt>Note</dt><dd>If tiled caching is enabled, this command will trigger an implicit tiled cache flush.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the counter reset operation.</td></tr>
    <tr><td class="paramname">counter</td><td>Type of counter that will be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9642c6dc30a8a0f71464a7de155c0f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9642c6dc30a8a0f71464a7de155c0f2e">&#9670;&nbsp;</a></span>nvnCommandBufferReportValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferReportValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a GPU counter report and timestamp into buffer object memory using an application-provided value. </p>
<p>This command will cause the GPU to write a counter report (of type <a class="el" href="struct_n_v_ncounter_data.html" title="Data structure describing how counter values are written to buffer memory.">NVNcounterData</a>) to buffer object memory, with the counter value replaced by an unsigned 32-bit value provided in the command. In the report, the first 8 bytes hold a 64-bit integer set to the provided report value and the second 8 bytes hold a timestamp when the report was performed.</p>
<dl class="section note"><dt>Note</dt><dd>If tiled caching is enabled, this command will trigger an implicit tiled cache flush.</dd>
<dd>
For timestamp, please refer to the <a class="el" href="nvn_index.html#nvn_guide_counter_resolution_of_timestamp">NVN Programming Guide</a> for the details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the counter report operation.</td></tr>
    <tr><td class="paramname">value</td><td>Value that be written in the counter report.</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of buffer memory where the counter will be written. Must be a multiple of 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a17852f8ea9a95fc08cce83cbd2886bb1" title="Minimum alignment for counter reports.">NVN_DEVICE_INFO_COUNTER_ALIGNMENT</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gada2e0273010f55fc9c3a44e57320a0d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada2e0273010f55fc9c3a44e57320a0d2">&#9670;&nbsp;</a></span>nvnCommandBufferSetRenderEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetRenderEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the render enable for a queue. </p>
<p>The render enable allows applications to disable all rendering to a queue unconditionally. If rendering is disabled for a queue, all rendering commands (framebuffer clears, Draw commands) will be discarded without any processing. Commands changing queue state will be executed even if rendering is disabled and will affect subsequent rendering commands if/when rendering is re-enabled. SetRenderEnable and SetRenderEnableConditional affect the same state in the queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to enable or disable rendering.</td></tr>
    <tr><td class="paramname">enable</td><td>NVN_TRUE if rendering should be enabled; NVN_FALSE if rendering should be disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa29e43ea6dbe7c77ea050ae7ae95758c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa29e43ea6dbe7c77ea050ae7ae95758c">&#9670;&nbsp;</a></span>nvnCommandBufferSetRenderEnableConditional()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetRenderEnableConditional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gae555b5b8ce83bd8c76b77f40481adc8b">NVNconditionalRenderMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>counters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables rendering for a queue, depending on the equality of counters. </p>
<p>Enable or disable rendering based on whether two 64-bit values in buffer memory are equal. If the values are written using the SAMPLES_PASSED counter, this function can be used in an implementation of occlusion culling. SetRenderEnable and SetRenderEnableConditional affect the same state in the queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> for which rendering should be enabled or disabled.</td></tr>
    <tr><td class="paramname">mode</td><td>NVN_CONDITIONAL_RENDER_MODE_RENDER_IF_EQUAL if rendering should be enabled if the buffer values are equal, NVN_CONDITIONAL_RENDER_MODE_RENDER_IF_NOT_EQUAL otherwise.</td></tr>
    <tr><td class="paramname">counters</td><td><a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a> address of the two values to be compared. There must be at least 32 bytes of buffer memory starting at this address. The first value is contained in the first eight bytes starting at this address, and the second value is contained in the eight bytes starting at <em>bufferAddress</em> + 16. Note that this layout is consistent with two counter query results stored consecutively in memory. Must be a multiple of 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a17852f8ea9a95fc08cce83cbd2886bb1" title="Minimum alignment for counter reports.">NVN_DEVICE_INFO_COUNTER_ALIGNMENT</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga75b3bc276a95e8c5a8bbd08ea3e9593a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75b3bc276a95e8c5a8bbd08ea3e9593a">&#9670;&nbsp;</a></span>nvnCommandBufferSetRenderTargets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetRenderTargets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numColors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *const *&#160;</td>
          <td class="paramname"><em>colors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *const *&#160;</td>
          <td class="paramname"><em>colorViews</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>depthStencilView</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets color and depth/stencil textures in the framebuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to program the new render targets.</td></tr>
    <tr><td class="paramname">numColors</td><td>Number of color textures in the framebuffer. If zero is specified, the framebuffer will be programmed with no color textures. Any color binding point numbered <em>numColors</em> or higher will be programmed with no color texture. Must be less than or equal to 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a9f4ab24a0b8c08e3f2b66ce04e379b16" title="Number of color buffer binding points.">NVN_DEVICE_INFO_COLOR_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">colors</td><td>Array of <em>numColors</em> color textures to program in the framebuffer. If any element in the array is set to NULL, the corresponding color target in the framebuffer will be programmed with no texture.</td></tr>
    <tr><td class="paramname">colorViews</td><td>Array of <em>numColors</em> color texture views to program in the framebuffer. The texture views, if specified, can be used to override properties of the corresponding texture in the array <em>colors</em>. If NULL is specified, all textures in <em>colors</em> will be used as-is. If a non-NULL array of views is specified but one or more entries in that array is NULL, the corresponding textures in <em>colors</em> will be used as-is.</td></tr>
    <tr><td class="paramname">depthStencil</td><td>Depth/stencil texture to program in the framebuffer. If NULL is specified, the framebuffer will be programmed with no depth/stencil buffer.</td></tr>
    <tr><td class="paramname">depthStencilView</td><td>Depth/stencil texture view to program in the framebuffer. A texture view, if specified, can be used to override properties of the corresponding texture <em>depthStencil</em>. If NULL is specified, the texture <em>depthStencil</em> will be used as-is. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae319235f09374fb2e5968d09cfbba7f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae319235f09374fb2e5968d09cfbba7f7">&#9670;&nbsp;</a></span>nvnCommandBufferDiscardColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferDiscardColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discard the contents of the specified bound color render target. </p>
<p>After discarding the contents of a color render target, its values will become undefined. This command can be useful for saving memory bandwidth for 'transient' rendering operations such as rendering to a multisample texture. After rendering to a multisample texture, the contents are often filtered to produce single-sample texels using nvnCommandBufferDownsample. Discarding the contents of a multisample texture after the downsample allows the GPU to throw away its contents before writing values to memory.</p>
<p>Only the portion of the render target contained inside the current scissor rectangle will be discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the discard operation.</td></tr>
    <tr><td class="paramname">index</td><td>Number of the color target whose contents should be discarded. Must be less than 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a9f4ab24a0b8c08e3f2b66ce04e379b16" title="Number of color buffer binding points.">NVN_DEVICE_INFO_COLOR_BUFFER_BINDINGS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga883170655ee34cb170ebe9475679c946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga883170655ee34cb170ebe9475679c946">&#9670;&nbsp;</a></span>nvnCommandBufferDiscardDepthStencil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferDiscardDepthStencil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discard the contents of the currently bound depth/stencil render target. </p>
<p>After discarding the contents of a depth/stencil render target, its values will become undefined. This command can be useful for saving memory bandwidth for 'transient' rendering operations such as rendering to a depth/stencil buffer that is only used to generate a color buffer image in the same frame. Discarding the contents of a texture allows the GPU to throw away its contents before writing values to main memory.</p>
<p>Only the portion of the render target contained inside the current scissor rectangle will be discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the discard operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadd85afea943735121bd9ce1755d65623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd85afea943735121bd9ce1755d65623">&#9670;&nbsp;</a></span>nvnCommandBufferDownsample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferDownsample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a filtered version of a multisample source texture to produce a single-sample destination texture. </p>
<p>This command completes the execution of all previous rendering commands before performing the downsample operation. In particular, it will flush all primitives accumulated by tiled caching logic. When using tiled caching, nvnCommandBufferTiledDownsample will perform better. This command is performed by the RSTR2D unit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the downsample operation. When performing the downsample operation, any commands previously submitted to the queue are completed prior to the downsample. The downsample does not synchronize with commands submitted to any other queue.</td></tr>
    <tr><td class="paramname">src</td><td>Source texture for the downsample operation.</td></tr>
    <tr><td class="paramname">dst</td><td>Destination texture for the downsample operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga09ac3a51249e04fe24e778d62fa0717b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09ac3a51249e04fe24e778d62fa0717b">&#9670;&nbsp;</a></span>nvnCommandBufferTiledDownsample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferTiledDownsample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a filtered version of a multisample source texture to produce a single-sample destination texture. </p>
<p>When tiled caching is enabled, the downsample operation performed by this command will be accumulated along with other rendered primitives. The actual downsample will be performed on a tile-by-tile basis, and may complete on one tile before regular rendering for another tile begins. When tiled caching is disabled, this command will behave similarly to nvnCommandBufferDownsample, which fully flushes previous work before starting the downsample operation. This command is performed by the 3D pipeline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the downsample operation. When performing the downsample operation, any commands previously submitted to the queue are completed prior to the downsample. The downsample does not synchronize with commands submitted to any other queue.</td></tr>
    <tr><td class="paramname">src</td><td>Source texture for the downsample operation.</td></tr>
    <tr><td class="paramname">dst</td><td>Destination texture for the downsample operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga800eedcf58d0e3deff9b0c2a47fc5e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga800eedcf58d0e3deff9b0c2a47fc5e29">&#9670;&nbsp;</a></span>nvnCommandBufferDownsampleTextureView()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferDownsampleTextureView </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>srcView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>dstView</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a filtered version of a multisample source texture and texture view to produce a single-sample destination texture through a texture view. </p>
<p>This command completes the execution of all previous rendering commands before performing the downsample operation. In particular, it will flush all primitives accumulated by tiled caching logic. When using tiled caching, nvnCommandBufferTiledDownsample will perform better. This command is performed by the RSTR2D unit. The texture views may only describe one single level/layer of a texture.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the downsample operation. When performing the downsample operation, any commands previously submitted to the queue are completed prior to the downsample. The downsample does not synchronize with commands submitted to any other queue.</td></tr>
    <tr><td class="paramname">src</td><td>Source texture for the downsample operation.</td></tr>
    <tr><td class="paramname">srcView</td><td>Source texture view for the downsample operation. Selects one level/layer.</td></tr>
    <tr><td class="paramname">dst</td><td>Destination texture for the downsample operation.</td></tr>
    <tr><td class="paramname">dstView</td><td>Destination texture view for the downsample operation. Selects one level/layer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2c1557296bd5eea6bbf2f2cbb8692aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c1557296bd5eea6bbf2f2cbb8692aa6">&#9670;&nbsp;</a></span>nvnCommandBufferTiledDownsampleTextureView()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferTiledDownsampleTextureView </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>srcView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>dstView</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a filtered version of a multisample source texture texture view to produce a single-sample destination texture view. </p>
<p>When tiled caching is enabled, the downsample operation performed by this command will be accumulated along with other rendered primitives. The actual downsample will be performed on a tile-by-tile basis, and may complete on one tile before regular rendering for another tile begins. When tiled caching is disabled, this command will behave similarly to nvnCommandBufferDownsample, which fully flushes previous work before starting the downsample operation. This command is performed by the 3D pipeline. The texture views must each describe only a single level/layer of a texture.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the downsample operation. When performing the downsample operation, any commands previously submitted to the queue are completed prior to the downsample. The downsample does not synchronize with commands submitted to any other queue.</td></tr>
    <tr><td class="paramname">src</td><td>Source texture for the downsample operation.</td></tr>
    <tr><td class="paramname">srcView</td><td>Source texture view for the downsample operation. Selects one level/layer.</td></tr>
    <tr><td class="paramname">dst</td><td>Destination texture for the downsample operation.</td></tr>
    <tr><td class="paramname">dstView</td><td>Destination texture view for the downsample operation. Selects one level/layer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8004a74da7c68a5424ac4466653dce34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8004a74da7c68a5424ac4466653dce34">&#9670;&nbsp;</a></span>nvnCommandBufferBarrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBarrier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>barrier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a barrier ordering execution of GPU commands and invalidating internal GPU caches. </p>
<p>Rendering and compute dispatch commands sent to NVN queues are executed on the GPU using a hardware pipeline, with no guarantee that work for one draw call or dispatch completes before work on the next draw call or dispatch starts. Additionally, some units of the GPU maintain caches that are not automatically invalidated when cached data are overwritten by the CPU or other units of the GPU. This command allows applications to order the processing of commands sent before and after the barrier and to invalidate GPU caches before processing commands sent after the barrier.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to insert the barrier.</td></tr>
    <tr><td class="paramname">barrier</td><td>Bitfield controlling the order of commands before and after the barrier and the invalidation of GPU caches for commands after the barrier. See <a class="el" href="group__nvn__c__enum.html#gaab4eabfc248236cc6b42d9de9d735621" title="Controls the ordering of commands and invalidation of caches for nvnCommandBufferBarrier.">NVNbarrierBits</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7e5ab25595c79c070fc8dd7442a69d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e5ab25595c79c070fc8dd7442a69d6d">&#9670;&nbsp;</a></span>nvnCommandBufferWaitSync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferWaitSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsync.html">NVNsync</a> *&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object to be signaled on the GPU before processing any further commands in the specified <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object whose subsequent commands wait on the <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object.</td></tr>
    <tr><td class="paramname">sync</td><td><a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object to wait on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7649fa38fde42a6fc9ec32b1133d5528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7649fa38fde42a6fc9ec32b1133d5528">&#9670;&nbsp;</a></span>nvnCommandBufferFenceSync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferFenceSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsync.html">NVNsync</a> *&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga6ab26a343b68da722799167ea97ec69d">NVNsyncCondition</a>&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object as signaled when all previous commands have completed in the <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object. </p>
<dl class="section warning"><dt>Warning</dt><dd>FenceSync commands are not automatically flushed for processing by the GPU. Before waiting on a FenceSync call with the CPU using nvnSyncWait or from another <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> using nvnQueueWaitSync, applications must ensure that the previous FenceSync call was flushed using nvnQueueFlush. Waiting on a FenceSync call using nvnQueueWaitSync in the same queue requires no manual flush.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If tiled caching is enabled, this command will trigger an implicit tiled cache flush.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object with commands to wait on before signaling completion.</td></tr>
    <tr><td class="paramname">sync</td><td><a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object to mark as signaled when commands complete.</td></tr>
    <tr><td class="paramname">condition</td><td>Type of command completion to wait for.</td></tr>
    <tr><td class="paramname">flags</td><td>Bitfield of additional operations to perform before signaling. See <a class="el" href="group__nvn__c__enum.html#ga5aa7e7ddcb3ce72c5b38ab55edc9f199" title="Specifies additional operations performed when a FenceSync command is processed.">NVNsyncFlagBits</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga43781240fe1741acfa122ad4fd63b802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43781240fe1741acfa122ad4fd63b802">&#9670;&nbsp;</a></span>nvnCommandBufferSetTexturePool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetTexturePool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *&#160;</td>
          <td class="paramname"><em>texturePool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a new texture pool used for subsequent rendering operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used for programming new texture pool.</td></tr>
    <tr><td class="paramname">texturePool</td><td><a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">NVNtexturePool</a> object to be programmed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga71cd4e0a83ae73c92c76333d3adc6212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71cd4e0a83ae73c92c76333d3adc6212">&#9670;&nbsp;</a></span>nvnCommandBufferSetSamplerPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetSamplerPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *&#160;</td>
          <td class="paramname"><em>samplerPool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a new sampler pool used for subsequent rendering operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used for programming new sampler pool.</td></tr>
    <tr><td class="paramname">samplerPool</td><td><a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">NVNsamplerPool</a> object to be programmed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafccbb352a6e0b28138c1a1e727fc1f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafccbb352a6e0b28138c1a1e727fc1f83">&#9670;&nbsp;</a></span>nvnCommandBufferSetShaderScratchMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetShaderScratchMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify scratch memory required for shader execution. </p>
<p>The scratch memory provided by this function allows shaders to require temporary (scratch) memory during execution to save the results of intermediate computations or flow control state. Each queue has its own block of scratch memory, programmed via command buffers. Scratch memory will be shared by all active shaders running on the queue. Multiple queues can share the same block of scratch memory.</p>
<p>Each compiled shader will report a minimum and recommended amount of scratch memory required. We recommend that applications provide the largest recommended amount of scratch memory for optimal performance. Providing less memory may resolve in lower shader performance, and providing less than the minimum amount of memory will result in crashes. For more information, consult the programming guide.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used for programming new scratch memory.</td></tr>
    <tr><td class="paramname">pool</td><td>Memory pool providing storage for the shader scratch memory.</td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) of the first byte of shader scratch memory. Must be a multiple of 4096 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ad7057e277907059442d45e1a1af16b70" title="Alignment required (in bytes) for the shader scratch memory.">NVN_DEVICE_INFO_SHADER_SCRATCH_MEMORY_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the scratch memory. Must be a multiple of 131072 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50af0acd8cf2a4d4b92edcd57fc887e5526" title="Required granularity for shader scratch memory provided to NVN.">NVN_DEVICE_INFO_SHADER_SCRATCH_MEMORY_GRANULARITY</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaf22d0bc677beea73eac74721ddfb325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf22d0bc677beea73eac74721ddfb325">&#9670;&nbsp;</a></span>nvnCommandBufferSaveZCullData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSaveZCullData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the current ZCull state for the current depth render target. </p>
<p>The ZCull unit of the GPU tracks the contents of the currently bound depth render target and uses this information to perform high-speed depth and stencil testing. When applications switch between depth render targets, ZCull discards tracking information for the old render target. This command allows applications to instead save the ZCull state to buffer memory so that it can be later restored when switching back to the old target. When saving information for a depth render target, SaveZCullData should be called immediately before switching render targets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the operation.</td></tr>
    <tr><td class="paramname">dst</td><td>GPU address of buffer object memory where the ZCull contents will be stored. Must be a multiple of 32 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a0ed594e80e327869a5f693ae2cdc2835" title="Minimum alignment for ZCull save/restore buffers.">NVN_DEVICE_INFO_ZCULL_SAVE_RESTORE_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the destination buffer. To determine the amount of memory required to save and restore ZCull data, call <a class="el" href="group__nvn__c__functions.html#ga73cb447f019bda7152e2ab27a5a9156d" title="Returns the amount of memory (in bytes) required to hold a ZCull save/restore buffer for a depth text...">nvnTextureGetZCullStorageSize()</a> or <a class="el" href="group__nvn__c__functions.html#gaa00aaba8acd99e423733589231ac411a" title="Returns the amount of memory (in bytes) required to hold a ZCull save/restore buffer for a depth text...">nvnTextureBuilderGetZCullStorageSize()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad6f7056d3e1f5a0c04ebfb301bf26a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6f7056d3e1f5a0c04ebfb301bf26a22">&#9670;&nbsp;</a></span>nvnCommandBufferRestoreZCullData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferRestoreZCullData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the current ZCull state to use saved state from a previous render target. </p>
<p>The ZCull unit of the GPU tracks the contents of the currently bound depth render target and uses this information to perform high-speed depth and stencil testing. When applications switch between depth render targets, ZCull discards tracking information for the old render target. This command allows applications restore previously saved ZCull state from buffer memory so that it can be used when continuing to render to the new target. When restoring information for a depth render target, RestoreZCullData should be called immediately after switching render targets.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data restored by this command must have been previously saved by nvnCommandBufferSaveZCullData. Additionally, the same depth/stencil texture and texture view must be bound as a render target at the time of the restore and the previous save. In case of a mismatch, the results of the restore are undefined and may result in GPU exceptions.</dd>
<dd>
If the current contents of the depth render target are inconsistent with the contents of the render target when SaveZCullData was called, the state written by RestoreZCullData is invalid and the results of depth and stencil testing are undefined.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the operation.</td></tr>
    <tr><td class="paramname">src</td><td>GPU address of buffer object memory where the ZCull contents will be loaded from. Must be a multiple of 32 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a0ed594e80e327869a5f693ae2cdc2835" title="Minimum alignment for ZCull save/restore buffers.">NVN_DEVICE_INFO_ZCULL_SAVE_RESTORE_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the source buffer. To determine the amount of memory required to save and restore ZCull data, call <a class="el" href="group__nvn__c__functions.html#ga73cb447f019bda7152e2ab27a5a9156d" title="Returns the amount of memory (in bytes) required to hold a ZCull save/restore buffer for a depth text...">nvnTextureGetZCullStorageSize()</a> or <a class="el" href="group__nvn__c__functions.html#gaa00aaba8acd99e423733589231ac411a" title="Returns the amount of memory (in bytes) required to hold a ZCull save/restore buffer for a depth text...">nvnTextureBuilderGetZCullStorageSize()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6face2746fa0f109f61ba3d3b349fb9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6face2746fa0f109f61ba3d3b349fb9f">&#9670;&nbsp;</a></span>nvnCommandBufferSetCopyRowStride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetCopyRowStride </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the row stride used for copies between buffer and texture memory. </p>
<p>This command sets the stride (in bytes) between rows of texels in buffer memory when copying texels between buffer and texture memory. With the default stride of zero (default), texel data in buffer memory will be treated as densely packed, where each new row in memory starts immediately after the end of the previous row.</p>
<dl class="section note"><dt>Note</dt><dd>Setting a stride affects any subsequent calls to nvnCommandBufferCopyBufferToTexture and nvnCommandBufferCopyTextureToBuffer using this command buffer. Unlike most <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> calls, this command does not store the stride in command or control memory and does not affect future submissions of previously recorded copy commands or copy commands recorded using other command buffers.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object used to store row stride.</td></tr>
    <tr><td class="paramname">stride</td><td>Stride (in bytes) between rows of texels in buffer memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga58fb857e055afc2512209f671e3d89ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58fb857e055afc2512209f671e3d89ca">&#9670;&nbsp;</a></span>nvnCommandBufferSetCopyImageStride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetCopyImageStride </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the image stride used for copies between buffer and texture memory. </p>
<p>This command sets the stride (in bytes) between layers of texels in buffer memory when copying texels between buffer and texture memory. With the default stride of zero (default), texel data in buffer memory will be treated as densely packed, where each new layer in memory starts immediately after the end of the previous layer.</p>
<dl class="section note"><dt>Note</dt><dd>Setting a stride affects any subsequent calls to nvnCommandBufferCopyBufferToTexture and nvnCommandBufferCopyTextureToBuffer using this command buffer. Unlike most <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> calls, this command does not store the stride in command or control memory and does not affect future submissions of previously recorded copy commands or copy commands recorded using other command buffers.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object used to store image stride.</td></tr>
    <tr><td class="paramname">stride</td><td>Stride (in bytes) between 2D arrays of texels in buffer memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaca29ca51ef0664b03280efdcc1e36323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca29ca51ef0664b03280efdcc1e36323">&#9670;&nbsp;</a></span>nvnCommandBufferGetCopyRowStride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t nvnCommandBufferGetCopyRowStride </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current copy row stride stored in a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga72e2b27a9a418f0eb48b0675c47809b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72e2b27a9a418f0eb48b0675c47809b4">&#9670;&nbsp;</a></span>nvnCommandBufferGetCopyImageStride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t nvnCommandBufferGetCopyImageStride </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current copy image stride stored in a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga01170f44ca8ae6f10aa10ad7fdefbfe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01170f44ca8ae6f10aa10ad7fdefbfe0">&#9670;&nbsp;</a></span>nvnCommandBufferDrawTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferDrawTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#gaa1a1fc7a9e690ce93870bcd71ea6b446">NVNtextureHandle</a>&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_ndraw_texture_region.html">NVNdrawTextureRegion</a> *&#160;</td>
          <td class="paramname"><em>dstRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const <a class="el" href="struct_n_v_ndraw_texture_region.html">NVNdrawTextureRegion</a> *&#160;</td>
          <td class="paramname"><em>srcRegion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draws an on-screen rectangle displaying the contents of a provided texture. </p>
<p>This command renders an axis-aligned rectangle into color target zero of the framebuffer, displaying some or all of the contents of a two-dimensional texture or rectangle texture. The caller specifies a texture handle identifying the source texture, a destination region in window coordinates, and a source region in non-normalized texture coordinates. For each fragment produced by the rectangle, DrawTexture computes coordinates in the source region, performs a texture lookup, and uses the texture result as the fragment color. Most per-fragment operations (including blending) are performed, and the results are written into color target zero.</p>
<p>DrawTexture has a number of limitations. Using illegal state may result in undefined behavior or GPU errors:</p><ul>
<li>The source texture must be two-dimensional (or rectangle).</li>
<li>Level of detail selection is not supported; level zero of the original texture is used.</li>
<li>Calling DrawTexture with multiple color targets is illegal.</li>
<li>Calling DrawTexture with blend modes selecting a second source color is illegal.</li>
<li>Conservative rasterization is treated as disabled.</li>
<li>Depth, depth bounds, and stencil tests are treated as disabled.</li>
<li>Anisotropic filtering and wrap modes that mirror or repeat are unsupported.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the operation.</td></tr>
    <tr><td class="paramname">texture</td><td>Handle for the pair of <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data.">NVNtexture</a> and <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">NVNsampler</a> objects to use.</td></tr>
    <tr><td class="paramname">dstRegion</td><td>Region identifying the portion of the color target to update. Coordinates (x0,y0) and (x1,y1) identify opposite corners of the region, in screen coordinates. All coordinates must be in the range [-65536, +65535], and x1-x0 and y1-y0 must be in the range [0, 65535].</td></tr>
    <tr><td class="paramname">srcRegion</td><td>Region identifying the portion of <em>texture</em> to access. Coordinates (x0,y0) and (x1,y1) identify opposite corners of the region, in non-normalized texel coordinates. All coordinates must be in the range [-65536, +65535]. The texture region will be mirrored horizontally and/or vertically if x0 &gt; x1 or y0 &gt; y1, respectively. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafe101d51f91200d5c59c756b8f754961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe101d51f91200d5c59c756b8f754961">&#9670;&nbsp;</a></span>nvnProgramSetSubroutineLinkage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnProgramSetSubroutineLinkage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__nvn__c__api__typedefs.html#gab66e1162e92eb9ed7611be8e01118116">NVNsubroutineLinkageMapPtr</a> *&#160;</td>
          <td class="paramname"><em>linkageMapPtrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the program's subroutine linkage maps for future use with nvnCommandBufferSetProgramSubroutines. </p>
<p>When using shader subroutines, applications update the values of subroutine uniforms using nvnCommandBufferSetProgramSubroutines. Such updates require the driver to adjust function pointers and related data to reflect the new uniform values. This linkage mapping must be set before submitting any commands from a nvnCommandBufferSetProgramSubroutines call. For each shader stage with subroutines, the compiler provides a <em>linkage map</em> that applications must provide to the driver to support subroutine updates. The linkage maps for a program must be set before binding the program or attempting to update subroutine uniforms. The linkage maps must be exactly what the compiler outputs for the input program in order for correctness. If the driver detects any inconsistencies between the input linkage maps and what the program requires, such as not providing linkage maps for all the stages of the program that use subroutines, NVN_FALSE is returned. Additionally, the data may be modified internally by the driver, so the data backed by this pointer must remain live for the lifetime of the program after calling SetSubroutineLinkage, and must not be modified by the application. The driver might also write to the contents of the linkage map during run-time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td><a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives.">NVNprogram</a> object to set up.</td></tr>
    <tr><td class="paramname">count</td><td>Number of linkage maps to use, one for each shader stage that uses subroutines.</td></tr>
    <tr><td class="paramname">linkageMapPtrs</td><td>An array of subroutine linkage map pointers where each subroutine linkage map was produced by the offline compiler. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab36aecb89c1a84c9cb2a2ca621056f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab36aecb89c1a84c9cb2a2ca621056f89">&#9670;&nbsp;</a></span>nvnCommandBufferSetProgramSubroutines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetProgramSubroutines </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const int *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the subroutine uniform parameters. </p>
<p>Sets subroutine uniform parameters for program subroutine, similar to the ARB_shader_subroutine functionality in OpenGL. Subroutines allow a application to dynamically switch between using different sets of functions instead without having to recompile the program, similar to setting function pointers in C-based languages. In order to use this feature, some linkage information from the offline compiler needs to be set in the program first via a call to SetSubroutineLinkage. This function allows a program to set a range of uniform locations to point to the input subroutines denoted by the index values in the array <em>values</em>. See the offline compiler documentation and the NVN documentation for more information on how to use this feature.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the operation.</td></tr>
    <tr><td class="paramname">program</td><td><a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives.">NVNprogram</a> object to perform the operation on.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage to update.</td></tr>
    <tr><td class="paramname">first</td><td>First subroutine uniform location in the program to update, and corresponds to the first array entry in the <em>values</em> input.</td></tr>
    <tr><td class="paramname">count</td><td>Number of subroutine uniform locations to update, starting with uniform with location <em>first</em>, and corresponds to the number of entries in the input array <em>values</em>.</td></tr>
    <tr><td class="paramname">values</td><td>An array of <em>count</em> subroutine index values to be assigned to successive subroutine uniform locations, where the first entry in the array corresponds to subroutine uniform location <em>first</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga30bc114cd2aad54bb5c54dbba0b74ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30bc114cd2aad54bb5c54dbba0b74ce1">&#9670;&nbsp;</a></span>nvnCommandBufferBindCoverageModulationTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindCoverageModulationTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const float *&#160;</td>
          <td class="paramname"><em>entries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds or unbinds a coverage modulation table used for target-independent rasterization. </p>
<p>By default, the color modulation feature of target-independent rasterization scales color using a factor based on the fraction of covered samples. For example, if three out of four samples for a fragment are covered, the default modulation factor will be 0.75. This function allows applications to override this behavior by specifying a 16-element table of modulation factors. If the modulation table is used with a render target with N raster samples per color sample and M samples are covered in a fragment, the modulation factor will be <em>entries</em>[(M-1) * 16 / N]. If no modulation table is bound (i.e., <em>entries</em> is NULL), the modulation factor will be M / N.</p>
<p>By default, no modulation table is bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the operation.</td></tr>
    <tr><td class="paramname">entries</td><td>Table of color modulation factors. If NULL, color modulation will use the fraction of covered raster samples as the color modulation factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2f474458657c1fea18b88dd48777b581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f474458657c1fea18b88dd48777b581">&#9670;&nbsp;</a></span>nvnCommandBufferResolveDepthBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferResolveDepthBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve depth values in a compressible depth render target. </p>
<p>Compressible depth render targets may store depth values in a compressed form, where individual values are reconstructed using compressed depth data and the current set of sample locations. This command decompresses the depth buffer, resolving individual depth values based on the current sample locations. This command should be used in the unlikely event that an application needs to change sample locations for a render target but use depth values that reflect the old locations. It is not necessary to decompress depth render targets for any other reason, including to use them for texture mapping. If there is no current depth render target, this command will have no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to perform the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga41c02cd9b5c931fd6b233b48ca245daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41c02cd9b5c931fd6b233b48ca245daa">&#9670;&nbsp;</a></span>nvnCommandBufferSetColorReductionEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetColorReductionEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable lossy color reduction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the enable or disable operation.</td></tr>
    <tr><td class="paramname">enable</td><td>If NVN_TRUE, enable lossy color reduction. Otherwise disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga75a746908aa8a2688d6269f5441bf758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75a746908aa8a2688d6269f5441bf758">&#9670;&nbsp;</a></span>nvnCommandBufferSetColorReductionThresholds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetColorReductionThresholds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac983c7ec7de25e7b97dacc14b163b5a5">NVNformatClass</a>&#160;</td>
          <td class="paramname"><em>formatClass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thresholdConservative</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thresholdAggressive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify new lossy color reduction thresholds for a format class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the Set operation.</td></tr>
    <tr><td class="paramname">formatClass</td><td><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab" title="Identifies how data elements stored in texture or buffer objects are encoded.">NVNformat</a> class for which to set thresholds</td></tr>
    <tr><td class="paramname">thresholdConservative</td><td>Color reduction threshold for possible primitive edges. This threshold is used if a tile is used for more than one rasterization operation before flushing to L2 cache.</td></tr>
    <tr><td class="paramname">thresholdAggressive</td><td>Color reduction threshold for interior pixels. This threshold is used if a tile is used for exactly once in a rasterization operation before flushing to L2 cache. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga54bb644ef7005a664579254b47587c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54bb644ef7005a664579254b47587c93">&#9670;&nbsp;</a></span>nvnCommandBufferPushDebugGroupStatic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferPushDebugGroupStatic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pushes a debug group into the command stream. </p>
<p>Debug groups provide a method for annotating a command stream with discrete groups of commands using a descriptive name. New debug groups are pushed to the top of the debug group stack. Debug groups are strictly hierarchical and their sequences may be nested within other debug groups but can not overlap. These groups may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<p>This entry point is for use with debug groups whose description is composed of a static string. The contents of <code>description</code> are not copied. Applications must ensure the string storage used by <code>description</code> is not reclaimed as long as the command set can be executed on a queue, or it is part of a debug group stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to push the new debug group.</td></tr>
    <tr><td class="paramname">domainId</td><td>Debug domain ID. It is given by nvnDeviceGenerateDebugDomainId. Different domain identifiers help debug tools to discriminate between concurrent, possibly overlapping, debug group stacks.</td></tr>
    <tr><td class="paramname">description</td><td>Text string used to annotate the debug group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac103cf83c2d69ae2c1bfd49ba0fd41d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac103cf83c2d69ae2c1bfd49ba0fd41d5">&#9670;&nbsp;</a></span>nvnCommandBufferPushDebugGroupDynamic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferPushDebugGroupDynamic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const char *&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pushes a debug group into the command stream. </p>
<p>Debug groups provide a method for annotating a command stream with discrete groups of commands using a descriptive name. New debug groups are pushed to the top of the debug group stack. Debug groups are strictly hierarchical and their sequences may be nested within other debug groups but can not overlap. These groups may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<p>This entry point is for use with debug groups whose description is composed of a dynamic string. The description string can be freed immediately after this function returns, unlike nvnCommandBufferPushDebugGroupStatic. The contents of <code>description</code> are copied, and the copy is automatically stored as long as necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to push the new debug group.</td></tr>
    <tr><td class="paramname">domainId</td><td>Debug domain ID. It is given by nvnDeviceGenerateDebugDomainId. Different domain identifiers help debug tools to discriminate between concurrent, possibly overlapping, debug group stacks.</td></tr>
    <tr><td class="paramname">description</td><td>Text string used to annotate the debug group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac328ee49a5aecdaf097da8d156837955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac328ee49a5aecdaf097da8d156837955">&#9670;&nbsp;</a></span>nvnCommandBufferPushDebugGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferPushDebugGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pushes a debug group into the command stream. </p>
<p>Debug groups provide a method for annotating a command stream with discrete groups of commands using a descriptive name. New debug groups are pushed to the top of the debug group stack. Debug groups are strictly hierarchical and their sequences may be nested within other debug groups but can not overlap. These groups may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<p>This entry point is equivalent to calling nvnCommandBufferPushDebugGroupStatic with a debug domain ID of 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to push the new debug group.</td></tr>
    <tr><td class="paramname">description</td><td>Text string used to annotate the debug group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9e093d931066afbd07f7dc62f728a1d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e093d931066afbd07f7dc62f728a1d3">&#9670;&nbsp;</a></span>nvnCommandBufferPopDebugGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferPopDebugGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pops the active debug group off the command stream. </p>
<p>This entry point is equivalent to calling nvnCommandBufferPopDebugGroupId with a debug domain ID of 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to pop the debug group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab9a3654de302a8d7725d78a793f47571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9a3654de302a8d7725d78a793f47571">&#9670;&nbsp;</a></span>nvnCommandBufferPopDebugGroupId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferPopDebugGroupId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>domainId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pops the active debug group off the command stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to pop the debug group.</td></tr>
    <tr><td class="paramname">domainId</td><td>Debug domain ID. It is given by nvnDeviceGenerateDebugDomainId. Different domain identifiers help debug tools to discriminate between concurrent, possibly overlapping, debug group stacks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga68f148606bec51c995b3b86f851c5b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68f148606bec51c995b3b86f851c5b09">&#9670;&nbsp;</a></span>nvnCommandBufferInsertDebugMarkerStatic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferInsertDebugMarkerStatic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a debug event marker to the command stream. </p>
<p>Inserts a debug marker to annotate a command stream with a descriptive text marker. These event markers may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<p>This entry point is for use with debug markers whose description is composed of a static string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to add the event marker.</td></tr>
    <tr><td class="paramname">domainId</td><td>Debug domain ID. It is given by nvnDeviceGenerateDebugDomainId. Different domain identifiers help debug tools to discriminate between concurrent, possibly overlapping, debug group stacks.</td></tr>
    <tr><td class="paramname">description</td><td>Text string used to annotate the event marker. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3df18b5df1b162e23c2315f19f45a936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3df18b5df1b162e23c2315f19f45a936">&#9670;&nbsp;</a></span>nvnCommandBufferInsertDebugMarkerDynamic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferInsertDebugMarkerDynamic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const char *&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a debug event marker to the command stream. </p>
<p>Inserts a debug marker to annotate a command stream with a descriptive text marker. These event markers may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<p>This entry point can be used with dynamically allocated strings, as it copies the data onto the command buffer itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to add the event marker.</td></tr>
    <tr><td class="paramname">domainId</td><td>Debug domain ID. It is given by nvnDeviceGenerateDebugDomainId. Different domain identifiers help debug tools to discriminate between concurrent, possibly overlapping, debug group stacks.</td></tr>
    <tr><td class="paramname">description</td><td>Text string used to annotate the event marker. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4d91848e0c99bad0ca343ba3710278e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d91848e0c99bad0ca343ba3710278e0">&#9670;&nbsp;</a></span>nvnCommandBufferInsertDebugMarker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferInsertDebugMarker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a debug event marker to the command stream. </p>
<p>Inserts a debug marker to annotate a command stream with a descriptive text marker. These event markers may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<p>This entry point is identical to nvnCommandBufferInsertDebugMarkerStatic with a domainId of 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> used to add the event marker.</td></tr>
    <tr><td class="paramname">description</td><td>Text string used to annotate the event marker. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1b241dbc3db41646a27cf4fe10ef3538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b241dbc3db41646a27cf4fe10ef3538">&#9670;&nbsp;</a></span>nvnCommandBufferGetMemoryCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__funcptrs.html#gac2d9ed5522cd4167d6a59f16d379bb1c">PFNNVNCOMMANDBUFFERMEMORYCALLBACKPROC</a> nvnCommandBufferGetMemoryCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query a callback function for a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object that will be called if it runs out of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaf726c18072c4b8ece85794276cfd991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf726c18072c4b8ece85794276cfd991">&#9670;&nbsp;</a></span>nvnCommandBufferGetMemoryCallbackData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nvnCommandBufferGetMemoryCallbackData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query a generic pointer that will be passed to a callback function if the command buffer runs out of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object to update. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf0790bc37a5893867aa5258dfbfe7923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0790bc37a5893867aa5258dfbfe7923">&#9670;&nbsp;</a></span>nvnCommandBufferIsRecording()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnCommandBufferIsRecording </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether the command buffer is currently recording. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad8eeff0f19eaa7bb9b57ea8134411baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8eeff0f19eaa7bb9b57ea8134411baa">&#9670;&nbsp;</a></span>nvnSyncInitialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnSyncInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsync.html">NVNsync</a> *&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object for the specified device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync</td><td><a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object to initialize.</td></tr>
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> owning the <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga918f1f02b17ba89d048372ead736a929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga918f1f02b17ba89d048372ead736a929">&#9670;&nbsp;</a></span>nvnSyncFinalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSyncFinalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsync.html">NVNsync</a> *&#160;</td>
          <td class="paramname"><em>sync</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync</td><td><a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object to finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga052a5bc70782ffe27301d0e317e6382b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga052a5bc70782ffe27301d0e317e6382b">&#9670;&nbsp;</a></span>nvnSyncSetDebugLabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSyncSetDebugLabel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsync.html">NVNsync</a> *&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debug label string for a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object. </p>
<p>Annotates a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object with a descriptive text label. This label may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync</td><td><a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object to set debug label.</td></tr>
    <tr><td class="paramname">label</td><td>Text string used to annotate the <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae646129720b27503c239a22db9653fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae646129720b27503c239a22db9653fa0">&#9670;&nbsp;</a></span>nvnQueueFenceSync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueueFenceSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsync.html">NVNsync</a> *&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga6ab26a343b68da722799167ea97ec69d">NVNsyncCondition</a>&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object as signaled when all previous commands have completed in the <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> object. </p>
<dl class="section warning"><dt>Warning</dt><dd>FenceSync commands are not automatically flushed for processing by the GPU. Before waiting on a FenceSync call with the CPU using nvnSyncWait or from another <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> using nvnQueueWaitSync, applications must ensure that the previous FenceSync call was flushed using nvnQueueFlush. Waiting on a FenceSync call using nvnQueueWaitSync in the same queue requires no manual flush.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If tiled caching is enabled, this command will trigger an implicit tiled cache flush.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> object with commands to wait on before signaling completion.</td></tr>
    <tr><td class="paramname">sync</td><td><a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object to mark as signaled when commands complete.</td></tr>
    <tr><td class="paramname">condition</td><td>Type of command completion to wait for.</td></tr>
    <tr><td class="paramname">flags</td><td>Bitfield of additional operations to perform before signaling. See <a class="el" href="group__nvn__c__enum.html#ga5aa7e7ddcb3ce72c5b38ab55edc9f199" title="Specifies additional operations performed when a FenceSync command is processed.">NVNsyncFlagBits</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2e9deb5d068866fe0c32929a3f82baf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e9deb5d068866fe0c32929a3f82baf3">&#9670;&nbsp;</a></span>nvnSyncWait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga52ff133a79fc03ef1f60a3e7946332a1">NVNsyncWaitResult</a> nvnSyncWait </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsync.html">NVNsync</a> *&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeoutNs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object to be signaled on the CPU before returning. </p>
<p>The value returned indicates the status of the <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object when the command returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync</td><td><a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object to wait on.</td></tr>
    <tr><td class="paramname">timeoutNs</td><td>Minimum time (in nanoseconds) to wait for the <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object to be signaled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaad28b8279c1f539d143c1902212df11f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad28b8279c1f539d143c1902212df11f">&#9670;&nbsp;</a></span>nvnQueueWaitSync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnQueueWaitSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsync.html">NVNsync</a> *&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object to be signaled on the GPU before processing any further commands in the specified <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU.">NVNqueue</a> whose subsequent commands wait on the <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object.</td></tr>
    <tr><td class="paramname">sync</td><td><a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object to wait on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9e8bc9ad7077caaf6c73d93a7d49f0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e8bc9ad7077caaf6c73d93a7d49f0e8">&#9670;&nbsp;</a></span>nvnSyncInitializeFromFencedGLSync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnSyncInitializeFromFencedGLSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsync.html">NVNsync</a> *&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>glSync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaa4f7646e09407139b1ec66c53f6a1cbf">NVNsyncInteropStatus</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use a fenced and flushed GLsync object to initialize a NVN <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object. </p>
<p>Use this function instead of Initialize for NVN <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> objects created from GLsync objects. This function initializes a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object that signals after a corresponding GLsync object. This enables OpenGL to NVN synchronization (fencing is done on the OpenGL object and waiting on its NVN counterpart). The value returned indicates the status of the <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object. See nvnSyncCreateGLSync.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sync</td><td>The <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object to initialize.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device.">NVNdevice</a> owning the <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">glSync</td><td>The name of the OpenGL or OpenGL ES sync to use as a source. <ul>
<li>The GLsync object must be a valid OpenGL or OpenGL ES GLsync object. </li>
<li>The GLsync object must have already been flushed in the GL command stream. </li>
<li>It needs to be valid for the lifetime of the <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>Detailed error status. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae11ae660cf9aa3a973a6f38f1174d8a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae11ae660cf9aa3a973a6f38f1174d8a9">&#9670;&nbsp;</a></span>nvnSyncCreateGLSync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#gaa4f7646e09407139b1ec66c53f6a1cbf">NVNsyncInteropStatus</a> nvnSyncCreateGLSync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsync.html">NVNsync</a> *&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>glSync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use a fenced and flushed NVN <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object to create a GLsync. </p>
<p>This function initializes a GLsync object that signals after a corresponding NVN sync object. This enables NVN to OpenGL synchronization (fencing is done on the NVN <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object and waiting on its GLsync counterpart). The value returned indicates the status of the <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object. See nvnSyncInitializeFromFencedGLSync.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sync</td><td>The NVN <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object to use as a source. <ul>
<li>Must be a valid NVN <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object. </li>
<li>Must be fenced and flushed before calling this. </li>
<li>Needs to be valid for the lifetime of the GLsync object, i.e. the source <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object must not be finalized while there is any GL work pending on the GLsync object. After the source NVN <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> object is finalized, the GLsync object should not be used in any API function, and its state is undefined.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">glSync</td><td>The GLsync to initialize, cast to uint64_t*. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf9cbb0430ea71279858b791e61bbddae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9cbb0430ea71279858b791e61bbddae">&#9670;&nbsp;</a></span>nvnEventBuilderSetDefaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnEventBuilderSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nevent_builder.html">NVNeventBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects.">NVNeventBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects.">NVNeventBuilder</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga220c8fbd5686a7d0bb8629205ad0ce7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga220c8fbd5686a7d0bb8629205ad0ce7d">&#9670;&nbsp;</a></span>nvnEventBuilderSetStorage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnEventBuilderSetStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nevent_builder.html">NVNeventBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the location in a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">NVNmemoryPool</a> used to hold the state of an <a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> created from the <a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects.">NVNeventBuilder</a>. </p>
<p>Each <a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object created by an event builder has a 32-bit unsigned integer value stored in GPU-accessible memory in a memory pool. API commands are provided to read and write to this value and to wait for it to reach a specified value. When an <a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object is initialized, its initial value comes from the current contents of the associated storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects.">NVNeventBuilder</a> object to modify.</td></tr>
    <tr><td class="paramname">pool</td><td>Memory pool used to hold the state of the event. If the event is signaled or queried by the CPU, a CPU_UNCACHED memory pool is recommended. If a CPU_CACHED memory pool is used, the event object's memory must be flushed from the CPU data cache using nvnMemoryPoolFlushMappedRange after calling nvnEventSignal and must be invalidated from the CPU data cache using nvnMemoryPoolInvalidateMappedRange before calling nvnEventGetValue. Memory pools created with the VIRTUAL, PHYSICAL, and GPU_NO_ACCESS flags are not supported. Memory pools created with GPU_CACHED are only supported if the pool also uses CPU_NO_ACCESS. Memory pools created with CPU_CACHED are not supported on the Windows reference implementation.</td></tr>
    <tr><td class="paramname">offset</td><td>offset in <em>pool</em> for event write back location. <em>offset</em> must be aligned to the size of an event which is a 32-bit unsigned integer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga798a91d0cfa6b69b33678a78631f6d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga798a91d0cfa6b69b33678a78631f6d38">&#9670;&nbsp;</a></span>nvnEventBuilderGetStorage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a>* nvnEventBuilderGetStorage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nevent_builder.html">NVNeventBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the memory pool and the offset associated with this <a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects.">NVNeventBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects.">NVNeventBuilder</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">offset</td><td>Offset into the memory pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7a91710b2481a42679ee132f0d56fb78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a91710b2481a42679ee132f0d56fb78">&#9670;&nbsp;</a></span>nvnEventBuilderGetMemoryPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a>* nvnEventBuilderGetMemoryPool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nevent_builder.html">NVNeventBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the memory pool associated with this <a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects.">NVNeventBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects.">NVNeventBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa8a022cb514b7a57a4918d01871b3b0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8a022cb514b7a57a4918d01871b3b0a">&#9670;&nbsp;</a></span>nvnEventBuilderGetMemoryPool_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a>* nvnEventBuilderGetMemoryPool_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nevent_builder.html">NVNeventBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the memory pool associated with this <a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects.">NVNeventBuilder</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnEventBuilderGetMemoryPool, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects.">NVNeventBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1e667fa73cc3c548f4a951831c471a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e667fa73cc3c548f4a951831c471a5c">&#9670;&nbsp;</a></span>nvnEventBuilderGetMemoryOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t nvnEventBuilderGetMemoryOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nevent_builder.html">NVNeventBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the memory pool offset associated with this <a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects.">NVNeventBuilder</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects.">NVNeventBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2361f65d66b8967fc7f1a864b055ae84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2361f65d66b8967fc7f1a864b055ae84">&#9670;&nbsp;</a></span>nvnEventBuilderGetMemoryOffset_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE int64_t nvnEventBuilderGetMemoryOffset_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nevent_builder.html">NVNeventBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the memory pool offset associated with this <a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects.">NVNeventBuilder</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnEventBuilderGetMemoryOffset, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects.">NVNeventBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga969cdf368faed960c33d23f25d72e16b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga969cdf368faed960c33d23f25d72e16b">&#9670;&nbsp;</a></span>nvnEventInitialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnEventInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nevent.html">NVNevent</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nevent_builder.html">NVNeventBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an <a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td><a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object to initialize.</td></tr>
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects.">NVNeventBuilder</a> object to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3396c994019a4149ee5cf81d6fdf368c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3396c994019a4149ee5cf81d6fdf368c">&#9670;&nbsp;</a></span>nvnEventFinalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnEventFinalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nevent.html">NVNevent</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a <a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td><a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object to finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga95d214178cd0d00385e74cba7b2c2b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95d214178cd0d00385e74cba7b2c2b76">&#9670;&nbsp;</a></span>nvnEventGetValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nvnEventGetValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nevent.html">NVNevent</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value associated with an <a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td><a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8ea5599a30f15446978d9b535e3aabf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ea5599a30f15446978d9b535e3aabf9">&#9670;&nbsp;</a></span>nvnEventSignal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnEventSignal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nevent.html">NVNevent</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gae0c7c9637d4f93ea56fc315c97f17a7e">NVNeventSignalMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the CPU to signal an <a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td><a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object to initialize.</td></tr>
    <tr><td class="paramname">mode</td><td><a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> signal mode.</td></tr>
    <tr><td class="paramname">value</td><td>Signal value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga28078a24c2d5dda89524575e17d8424e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28078a24c2d5dda89524575e17d8424e">&#9670;&nbsp;</a></span>nvnEventGetMemoryPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a>* nvnEventGetMemoryPool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nevent.html">NVNevent</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the memory pool associated with this <a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td><a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac181724f3d88162a0534c9a96402864c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac181724f3d88162a0534c9a96402864c">&#9670;&nbsp;</a></span>nvnEventGetMemoryPool_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a>* nvnEventGetMemoryPool_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nevent.html">NVNevent</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the memory pool associated with this <a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnEventGetMemoryPool, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td><a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa9a056dded99e0b175123549802b1e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9a056dded99e0b175123549802b1e54">&#9670;&nbsp;</a></span>nvnEventGetMemoryOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t nvnEventGetMemoryOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nevent.html">NVNevent</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the memory pool offset associated with this <a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td><a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf8be19e0ecd2669f0d428f2cf52cccfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8be19e0ecd2669f0d428f2cf52cccfa">&#9670;&nbsp;</a></span>nvnEventGetMemoryOffset_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNINLINE int64_t nvnEventGetMemoryOffset_fastpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nevent.html">NVNevent</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the memory pool offset associated with this <a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to nvnEventGetMemoryOffset, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td><a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga81d0bfe6252b8f44e1b0a3607856d71c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81d0bfe6252b8f44e1b0a3607856d71c">&#9670;&nbsp;</a></span>nvnCommandBufferWaitEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferWaitEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nevent.html">NVNevent</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga6062c139aaf05b84d9c59913ff914cad">NVNeventWaitMode</a>&#160;</td>
          <td class="paramname"><em>waitMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pause work on the GPU until an event is signaled. </p>
<p>When applications use this command, they are required to ensure that the memory associated with the event will eventually contain a value that passes the test specified by <em>waitMode</em>. If not, a GPU timeout error will occur.</p>
<dl class="section warning"><dt>Warning</dt><dd>On the Windows reference implementation, <a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> objects do not support synchronization between queues. Submitting a command set containing a WaitEvent command on one queue to wait on an event signaled by a nvnCommandBufferSignalEvent command submitted to another queue may result in GPU timeout errors. Applications can use <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> objects to reliably synchronize between queues on all platforms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object to use.</td></tr>
    <tr><td class="paramname">event</td><td><a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object to wait on.</td></tr>
    <tr><td class="paramname">waitMode</td><td><a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> wait mode. The wait mode specifies a test use to compare the value in memory associated with the <a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object and the <em>value</em> provided in this command. The event is considered to be signaled when this test passes.</td></tr>
    <tr><td class="paramname">value</td><td>Value to compare to the value in the <a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object's memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae26f02577d10f5b39bb432d34d4b8649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae26f02577d10f5b39bb432d34d4b8649">&#9670;&nbsp;</a></span>nvnCommandBufferSignalEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSignalEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nevent.html">NVNevent</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gae0c7c9637d4f93ea56fc315c97f17a7e">NVNeventSignalMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga46d20cb478c11853f23d27890c28f4ee">NVNeventSignalLocation</a>&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the GPU to signal an <a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object to use.</td></tr>
    <tr><td class="paramname">event</td><td><a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object to signal.</td></tr>
    <tr><td class="paramname">mode</td><td>Method used to update the memory associated with the <a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object.</td></tr>
    <tr><td class="paramname">location</td><td>Location in the GPU pipeline that the command must reach before the signal operation is performed.</td></tr>
    <tr><td class="paramname">flags</td><td>Flags used to control the signal operation. See <a class="el" href="group__nvn__c__enum.html#ga3a070a6e8b4c2fe6b7dfaa5caffab64f" title="Flags controlling the behavior of nvnCommandBufferSignalEvent.">NVNeventSignalFlags</a>.</td></tr>
    <tr><td class="paramname">value</td><td>Value used to update the memory associated with the <a class="el" href="struct_n_v_nevent.html" title="NVNevent object.">NVNevent</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3fdbe92539c8703c2e92cec46a3ce654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fdbe92539c8703c2e92cec46a3ce654">&#9670;&nbsp;</a></span>nvnCommandBufferSetStencilCullCriteria()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetStencilCullCriteria </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gab50861ff9b46503782bb66c4edb734ae">NVNstencilFunc</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the criteria that is used by the ZCull HW for stencil culling. </p>
<p>This function sets the criteria that is used by the ZCull HW for stencil culling. ZCull will only try to discard pixels/fragments if the cull criteria matches the current stencil state and if the depth texture of the current render target was created using the ZCULL_SUPPORT_STENCIL flag. Note that calling this function will make the current ZCull region invalid until the next clear. This might have a negative impact on the depth culling performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object to use.</td></tr>
    <tr><td class="paramname">func</td><td>Stencil function to be used for stencil culling.</td></tr>
    <tr><td class="paramname">ref</td><td>Specify a stencil reference value used for stencil culling.</td></tr>
    <tr><td class="paramname">mask</td><td>Mask used for stencil culling. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8510eb82e5aa827f42b527aac457d94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8510eb82e5aa827f42b527aac457d94e">&#9670;&nbsp;</a></span>nvnCommandBufferOverrideSubtileSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferOverrideSubtileSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>override</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subtileSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override the default number of fragment shader warps in a single subtile. </p>
<p>Fragments generated by rasterization are arranged into groups called <em>subtiles</em>, which are processed as a unit by the fragment shading hardware. The subtile size is configured by the NVN driver, which computes a default subtile size based on properties of the fragment shader and GPU hardware. Larger subtiles can result in better locality for memory accesses, but also have increased overhead when launching, synchronizing, and retiring the larger sets of fragment shaders. This command allows applications to override the default subtile size in cases where the defaults are non-optimal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">override</td><td>Override the default subtile size. If true, use the subtile size specified by <em>subtileSize</em>. Otherwise, use a default subtile size derived from program state.</td></tr>
    <tr><td class="paramname">subtileSize</td><td>Subtile size used when overriding is enabled. When <em>override</em> is true, this specifies a limit on the maximum number of fragment shader warps contained in a single subtile. This parameter is expressed as a fraction of the maximum possible subtile size, with 128 specifying the maximum size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga27b79a7f5a59ef54146d7bd76fdbb3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27b79a7f5a59ef54146d7bd76fdbb3b2">&#9670;&nbsp;</a></span>nvnCommandBufferInsertCheckpointStatic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnCommandBufferInsertCheckpointStatic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>markerData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>markerDataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a checkpoint event marker to the command set. </p>
<p>Inserts a checkpoint event marker into a command set. In case of a GPU crash, the checkpoint event markers that were last processed by the GPU will be included in NVN Aftermath crash dumps to aid in narrowing down the command that has led to the crash. The lifetime of the marker data specified when calling this entry point is managed by the application. The data is not copied and the application must ensure the memory pointed to by markerData is valid at least as long as the currently recorded command set can still be executed on a queue. If the checkpoint is set sucessfully, NVN_TRUE is returned. If any of the passed in parameters is invalid or a problem occurs when setting the checkpoint, NVN_FALSE is returned and no checkpoint is set.</p>
<dl class="section note"><dt>Note</dt><dd>This function is a no-op if the application is not linked with the NVN Aftermath target library.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the checkpoint event marker operation.</td></tr>
    <tr><td class="paramname">markerData</td><td>Data to associate with the checkpoint event marker.</td></tr>
    <tr><td class="paramname">markerDataSize</td><td>Size (in bytes) of the checkpoint event marker data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga471e3ef75091f5d2c42b680694efcbff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga471e3ef75091f5d2c42b680694efcbff">&#9670;&nbsp;</a></span>nvnCommandBufferInsertCheckpointDynamic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnCommandBufferInsertCheckpointDynamic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVN_NOESCAPE const void *&#160;</td>
          <td class="paramname"><em>markerData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>markerDataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a checkpoint event marker to the command set. </p>
<p>Inserts a checkpoint event marker into a command set. In case of a GPU crash, the checkpoint event markers that were last processed by the GPU will be included in NVN Aftermath crash dumps to aid in narrowing down the command that has led to the crash. The lifetime of the marker data specified when calling this entry point only needs to extend for the duration of the call. A copy of the data is made and the application can free the passed in marker data buffer immediately after this function returns. If the checkpoint is set sucessfully, NVN_TRUE is returned. If any of the passed in parameters is invalid or a problem occurs when setting the checkpoint, NVN_FALSE is returned and no checkpoint is set.</p>
<dl class="section note"><dt>Note</dt><dd>This function is a no-op if the application is not linked with the NVN Aftermath target library.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the checkpoint event marker operation.</td></tr>
    <tr><td class="paramname">markerData</td><td>Data to associate with the checkpoint event marker.</td></tr>
    <tr><td class="paramname">markerDataSize</td><td>Size (in bytes) of the checkpoint event marker data. Must be less than or equal to 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a825be9b4c9fda5b296b29df21d934849" title="Maximum size (in bytes) of dynamic checkpoint marker data.">NVN_DEVICE_INFO_CHECKPOINT_MAXIMUM_DYNAMIC_MARKER_DATA_SIZE</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga70069b0add7841395efa76905f4f3833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70069b0add7841395efa76905f4f3833">&#9670;&nbsp;</a></span>nvnCommandBufferSetZCullZF32CompressionEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetZCullZF32CompressionEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables/Disables the compression for ZF32 values in the ZCull <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">NVNbuffer</a>. </p>
<p>By default ZF32 values (i.e., the contents of <a class="el" href="group__nvn__c__enum.html#gga99463f5b9af6151e604b01dfdd5fecabafb1417ff7fa8ad938ebbf64da47af845" title="A 32-bit floating-point depth component.">NVN_FORMAT_DEPTH32F</a> or <a class="el" href="group__nvn__c__enum.html#gga99463f5b9af6151e604b01dfdd5fecabab397ddb358bcbe9e3fdd68b57d8e6001" title="A 32-bit floating-point depth component packed with an 8-bit unsigned integer stencil component.">NVN_FORMAT_DEPTH32F_STENCIL8</a> depth buffers) are compressed in the ZCull buffer, i.e. equivalent to setting 'enable' to 'true'. Since the compression is lossy, this can significantly reduce the ZCull performance for depth values near 0.0. When using GREATER as depth function it is recommended to disable ZF32Compression for the case where precision near 0.0 is required. Toggling the ZF32 compression mode is a comparatively slow operation. Frequent toggles may adversely affect performance. After toggling, the result of any ZCull test will be undefined until after a depth buffer is cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues.">NVNcommandBuffer</a> object to update.</td></tr>
    <tr><td class="paramname">enable</td><td>If NVN_TRUE, enable ZF32 compression. Otherwise disable it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga99557bee9c57748558aa42d74c1ecbea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99557bee9c57748558aa42d74c1ecbea">&#9670;&nbsp;</a></span>nvnDeviceSetAutomaticCheckpointsEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnDeviceSetAutomaticCheckpointsEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control automatic checkpoint event markers. </p>
<p>If automatic checkpoint event markers are enabled, a checkpoint marker is added automatically for draw, dispatch, or copy commands recorded into a command set. In the case of a GPU crash, the checkpoint event markers that were last processed by the GPU will be included in NVN Aftermath crash dumps to aid in narrowing down the command that has led to the crash. If automatic checkpoints are sucessfully enabled, NVN_TRUE is returned. If any of the passed in parameters is invalid or a problem occurs when enabling automatic checkpoints, NVN_FALSE is returned and the currently set state remains unchanged.</p>
<dl class="section note"><dt>Note</dt><dd>This function is a no-op if the application is not linked with the NVN Aftermath target library. </dd>
<dd>
Calling this function while a command buffer is being recorded on the device will result in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to be modified.</td></tr>
    <tr><td class="paramname">enable</td><td>Enable automatic checkpoint event markers if true; disable if false. Automatic checkpoint event markers are disabled by default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad1f6dccb79d0016bc5f9fadd91bc37f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1f6dccb79d0016bc5f9fadd91bc37f5">&#9670;&nbsp;</a></span>nvnDeviceSetAutomaticCheckpointsMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnDeviceSetAutomaticCheckpointsMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control for which commands automatic checkpoint event markers are added. </p>
<p>If automatic checkpoint event markers are enabled, the mask set by this function specifies for which subset of the commands automatic checkpoints are added. If the mask is sucessfully set, NVN_TRUE is returned. If any of the passed in parameters is invalid or a problem occurs when setting the mask, NVN_FALSE is returned and the currently set state remains unchanged. </p><dl class="section note"><dt>Note</dt><dd>This function is a no-op if the application is not linked with the NVN Aftermath target library. </dd>
<dd>
Calling this function while a command buffer is being recorded on the device will result in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to be modified.</td></tr>
    <tr><td class="paramname">mask</td><td>Bitfield indicating for which commands automatic checkpoints should be added. The default is to add automatic checkpoints for all supported commands. See <a class="el" href="group__nvn__c__enum.html#gaa5f102f34dd4fbcdb1745eaa92bd7257" title="Flags controlling automatic checkpoint event marker creation.">NVNautomaticCheckpointsMask</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga05a0ec24e19814c9f38c3ae315cc82ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05a0ec24e19814c9f38c3ae315cc82ed">&#9670;&nbsp;</a></span>nvnDeviceSetAutomaticCheckpointsSamplingInterval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnDeviceSetAutomaticCheckpointsSamplingInterval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control how frequently automatic checkpoint event markers are inserted. </p>
<p>If automatic checkpoint event markers are enabled, this function specifies how frequently they are added. If the sampling interval is set sucessfully, NVN_TRUE is returned. If any of the passed in parameters is invalid or a problem occurs when setting the sampling interval, NVN_FALSE is returned and the currently set sampling interval remains unchanged.</p>
<dl class="section note"><dt>Note</dt><dd>This function is a no-op if the application is not linked with the NVN Aftermath target library. </dd>
<dd>
Calling this function while a command buffer is being recorded on the device will result in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to be modified.</td></tr>
    <tr><td class="paramname">interval</td><td>A value of n will insert a checkpoint marker only on every n-th command. A value of n will insert a checkpoint only on every n-th command. The default value for the sampling interval is 1, which means a checkpoint will be inserted on every draw, dispatch, or copy command. Must be greater than zero. Must be less than or equal to 65535 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a58a05bffc44188c1a5329808ce2fc1fb" title="Maximum supported length of the event sampling interval for automatic checkpoint event markers.">NVN_DEVICE_INFO_CHECKPOINT_MAXIMUM_SAMPLING_INTERVAL_LENGTH</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadd59fdbbc8eafae5e42bd86236e714f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd59fdbbc8eafae5e42bd86236e714f8">&#9670;&nbsp;</a></span>nvnDeviceSetAutomaticCheckpointsByDebugGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnDeviceSetAutomaticCheckpointsByDebugGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>debugGroupName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control automatic checkpoint event markers by debug group. </p>
<p>Specifies that automatic checkpoint event markers should only be added if the name of the debug group at the top of the selected debug group stack matches the provided debug group name. If the debug group name filter is set sucessfully, NVN_TRUE is returned. If any of the passed in parameters is invalid or a problem occurs when setting the debug group name filter, NVN_FALSE is returned and the currently set debug group name filter remains unchanged.</p>
<dl class="section note"><dt>Note</dt><dd>This function is a no-op if the application is not linked with the NVN Aftermath target library. </dd>
<dd>
Calling this function while a command buffer is being recorded on the device will result in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to be modified.</td></tr>
    <tr><td class="paramname">domainId</td><td>Debug domain ID. Selects the debug group stack used for filtering.</td></tr>
    <tr><td class="paramname">debugGroupName</td><td>Name of the debug group for which automatic event markers are inserted. Call with nullptr to disable the filtering by debug group name. The default setting is to apply no filter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8367dbc5aa88a0efc6b1419cb7fb1a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8367dbc5aa88a0efc6b1419cb7fb1a5a">&#9670;&nbsp;</a></span>nvnDeviceSetCheckpointCallStacksEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnDeviceSetCheckpointCallStacksEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control call stack capture for checkpoint event markers. </p>
<p>If call stack capture for checkpoint event markers is enabled, the CPU call stack for every function call inserting event markers (user or automatic) is captured and is associated as additional payload with the event marker. In the case of a GPU crash this data is also added into the NVN Aftermath crash dump and can provide additional hints about the origin of the problem. If call stack capture is sucessfully enabled, NVN_TRUE is returned. If any of the passed in parameters is invalid or a problem occurs when enabling call stack capture, NVN_FALSE is returned and the currently set state remains unchanged.</p>
<dl class="section note"><dt>Note</dt><dd>This function is a no-op if the application is not linked with the NVN Aftermath target library. </dd>
<dd>
Calling this function while a command buffer is being recorded on the device will result in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to be modified.</td></tr>
    <tr><td class="paramname">enable</td><td>Enable or disable call stack capture for checkpoint event markers. Call stack capture is disabled by default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga05b69b6c497c67926c7a0a27cb84181c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05b69b6c497c67926c7a0a27cb84181c">&#9670;&nbsp;</a></span>nvnDeviceSetCheckpointMaxCallStacksDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvnDeviceSetCheckpointMaxCallStacksDepth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control call stack capture depth for checkpoint event markers. </p>
<p>Specify the maximum captured call stack depth for checkpoint event markers. If the call stack capture depth is set sucessfully, NVN_TRUE is returned. If any of the passed in parameters is invalid or a problem occurs when setting the call stack capture depth, NVN_FALSE is returned and the currently set value remains unchanged.</p>
<dl class="section note"><dt>Note</dt><dd>This function is a no-op if the application is not linked with the NVN Aftermath target library. </dd>
<dd>
Calling this function while a command buffer is being recorded on the device will result in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to be modified.</td></tr>
    <tr><td class="paramname">depth</td><td>Maximum depth of call stack capture. The default value for the call stack capture depth is 8 levels. Must be greater than zero. Must be less than or equal to 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50abe9d7e11dc92c0db258b22c9c8b39096" title="Maximum number of call stack entries that can be captured for checkpoint event markers.">NVN_DEVICE_INFO_CHECKPOINT_MAXIMUM_CALL_STACK_CAPTURE_DEPTH</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
