<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nn::profiler Namespace Reference | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenn.html">nn</a></li><li class="navelem"><a class="el" href="namespacenn_1_1profiler.html">profiler</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">nn::profiler Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Nintendo NX CPU Profiler Namespace.  
<a href="namespacenn_1_1profiler.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1profiler_1_1_result_already_done.html">ResultAlreadyDone</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>profiler</code>: The requested action has already been performed.).  <a href="classnn_1_1profiler_1_1_result_already_done.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1profiler_1_1_result_could_not_attach.html">ResultCouldNotAttach</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>profiler</code>: Could not attach to the target application.).  <a href="classnn_1_1profiler_1_1_result_could_not_attach.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1profiler_1_1_result_debugger_attached.html">ResultDebuggerAttached</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>profiler</code>: A debugger is already attached to the process.).  <a href="classnn_1_1profiler_1_1_result_debugger_attached.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1profiler_1_1_result_feature_unavailable.html">ResultFeatureUnavailable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>profiler</code>: This feature is not available at this time, further setup is required.).  <a href="classnn_1_1profiler_1_1_result_feature_unavailable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1profiler_1_1_result_graphics_hooks_not_installed.html">ResultGraphicsHooksNotInstalled</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>profiler</code>: This operation requires that the graphics hooks be installed.).  <a href="classnn_1_1profiler_1_1_result_graphics_hooks_not_installed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1profiler_1_1_result_invalid_argument.html">ResultInvalidArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>profiler</code>: An argument was invalid.).  <a href="classnn_1_1profiler_1_1_result_invalid_argument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1profiler_1_1_result_invalid_profiler_status.html">ResultInvalidProfilerStatus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>profiler</code>: Attempting to perform this operation is invalid with the current status.).  <a href="classnn_1_1profiler_1_1_result_invalid_profiler_status.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1profiler_1_1_result_memory_allocation_failure.html">ResultMemoryAllocationFailure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>profiler</code>: A problem occurred with memory allocation.).  <a href="classnn_1_1profiler_1_1_result_memory_allocation_failure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1profiler_1_1_result_not_initialized.html">ResultNotInitialized</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>profiler</code>: The profiler is not initialized.).  <a href="classnn_1_1profiler_1_1_result_not_initialized.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1profiler_1_1_result_null_argument.html">ResultNullArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>profiler</code>: An argument was NULL.).  <a href="classnn_1_1profiler_1_1_result_null_argument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1profiler_1_1_result_out_of_process_unavailable.html">ResultOutOfProcessUnavailable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>profiler</code>: Out of process profiling is unavailable in 4GB memory mode.).  <a href="classnn_1_1profiler_1_1_result_out_of_process_unavailable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1profiler_1_1_result_skipped_record.html">ResultSkippedRecord</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>profiler</code>: The profiler skipped recording the data.).  <a href="classnn_1_1profiler_1_1_result_skipped_record.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1profiler_1_1_result_unknown_error.html">ResultUnknownError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>profiler</code>: An unknown error occurred.).  <a href="classnn_1_1profiler_1_1_result_unknown_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1profiler_1_1_scoped_code_block.html">ScopedCodeBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialized class for code block scope-based Push/Pop functionality.  <a href="classnn_1_1profiler_1_1_scoped_code_block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1profiler_1_1_string_literal.html">StringLiteral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class for using constant string literals.  <a href="classnn_1_1profiler_1_1_string_literal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3f33fb75d3e0480ff9694565fbc1f421"><td class="memItemLeft" align="right" valign="top"><a id="a3f33fb75d3e0480ff9694565fbc1f421"></a>
typedef uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a></td></tr>
<tr class="memdesc:a3f33fb75d3e0480ff9694565fbc1f421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition of a tracking id. <br /></td></tr>
<tr class="separator:a3f33fb75d3e0480ff9694565fbc1f421"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a4399ee2dc75cd00ff55e1b7cb984753d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a4399ee2dc75cd00ff55e1b7cb984753d">AudioPerformanceMetricsControl</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a4399ee2dc75cd00ff55e1b7cb984753da23524272abace8e05f23532e476c88de">AudioPerformanceMetricsControl_Automatic</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a4399ee2dc75cd00ff55e1b7cb984753da8574cd1b4c04a3f5568cb792b255a59b">AudioPerformanceMetricsControl_Manual</a> = 1
<br />
 }</td></tr>
<tr class="memdesc:a4399ee2dc75cd00ff55e1b7cb984753d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the profiler who will be in control of the AudioRenderer performance frame buffer.  <a href="namespacenn_1_1profiler.html#a4399ee2dc75cd00ff55e1b7cb984753d">More...</a><br /></td></tr>
<tr class="separator:a4399ee2dc75cd00ff55e1b7cb984753d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae600326a48953627efa2c28ad9762f84"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#ae600326a48953627efa2c28ad9762f84">Cores</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#ae600326a48953627efa2c28ad9762f84a570406ee8ac132e5411980a74f0983ce">Cores_0</a> = (1 &lt;&lt; 0)
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#ae600326a48953627efa2c28ad9762f84ad37a2f0bfcf1809cbbddfb7c05842bd9">Cores_1</a> = (1 &lt;&lt; 1)
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#ae600326a48953627efa2c28ad9762f84a8b17be965dfae5adb2497ff0d08fc057">Cores_2</a> = (1 &lt;&lt; 2)
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#ae600326a48953627efa2c28ad9762f84aac74f924100217bb262d658f646b8057">Cores_All</a> = (Cores_0 | Cores_1 | Cores_2)
<br />
 }</td></tr>
<tr class="memdesc:ae600326a48953627efa2c28ad9762f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the set of cores that data can be collected on.  <a href="namespacenn_1_1profiler.html#ae600326a48953627efa2c28ad9762f84">More...</a><br /></td></tr>
<tr class="separator:ae600326a48953627efa2c28ad9762f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a494bd9ad9ee12e0f68bb64263cc416f7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a494bd9ad9ee12e0f68bb64263cc416f7">Flags</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a494bd9ad9ee12e0f68bb64263cc416f7a0cae9c46e389056f41bf68ce8800fc24">Flags_Simple</a> = (1 &lt;&lt; 0)
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a494bd9ad9ee12e0f68bb64263cc416f7afaddb8c59d9ea3f2f062d407a209a378">Flags_Callstack</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a494bd9ad9ee12e0f68bb64263cc416f7aecf478c090f9ba12d973bb091ee7a095">Flags_PerformanceCounters</a> = (1 &lt;&lt; 2)
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a494bd9ad9ee12e0f68bb64263cc416f7a304d2673c36980a078c16a7a8da40f66">Flags_RingBuffer</a> = (1 &lt;&lt; 3)
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a494bd9ad9ee12e0f68bb64263cc416f7a650fcd5cedbd2374dcc8dda450c499e8">Flags_OutOfProcessProfiling</a> = (1 &lt;&lt; 8)
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a494bd9ad9ee12e0f68bb64263cc416f7aa1e0595d19d578048a0be7e86cdfaab3">Flags_GraphicsTrace</a> = (1 &lt;&lt; 9)
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a494bd9ad9ee12e0f68bb64263cc416f7af63383d4948327755e3a5761bebdec50">Flags_AudioTrace</a> = (1 &lt;&lt; 11)
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a494bd9ad9ee12e0f68bb64263cc416f7ace540f9245886075d980c6ffe3c10d0b">Flags_FileSystemTrace</a> = (1 &lt;&lt; 13)
<br />
 }</td></tr>
<tr class="memdesc:a494bd9ad9ee12e0f68bb64263cc416f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags used to control how the profiler works.  <a href="namespacenn_1_1profiler.html#a494bd9ad9ee12e0f68bb64263cc416f7">More...</a><br /></td></tr>
<tr class="separator:a494bd9ad9ee12e0f68bb64263cc416f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd43485bd61fe04afe4b789a73b98c4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a8bd43485bd61fe04afe4b789a73b98c4">Heartbeats</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a8bd43485bd61fe04afe4b789a73b98c4afef7944828c76c000d169f2d4b0d5ac2">Heartbeats_Main</a> = 0x0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a8bd43485bd61fe04afe4b789a73b98c4ab3d52cfc664c4c0e55b7f51c8ecad73b">Heartbeats_Vsync</a> = 0x1
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a8bd43485bd61fe04afe4b789a73b98c4a2dc8161b04b066ce18ac6754acb66dbf">Heartbeats_User1</a> = 0x8
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a8bd43485bd61fe04afe4b789a73b98c4a6d6a6b0e6d3487cf31c081eb110f1ce1">Heartbeats_User2</a> = 0x9
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a8bd43485bd61fe04afe4b789a73b98c4ad7308fffcc8e7e09d2b833ddd288383f">Heartbeats_User3</a> = 0xA
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a8bd43485bd61fe04afe4b789a73b98c4a5d48523379e8d9d7515cc2065ccf32f4">Heartbeats_User4</a> = 0xB
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a8bd43485bd61fe04afe4b789a73b98c4ad9d0e91d666822171df43fbb579b2bea">Heartbeats_User5</a> = 0xC
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a8bd43485bd61fe04afe4b789a73b98c4a55fa4c1ddce7c775c3621314504dfa56">Heartbeats_User6</a> = 0xD
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a8bd43485bd61fe04afe4b789a73b98c4a66cd421aa21cbc15b344f8fbc8f097a4">Heartbeats_User7</a> = 0xE
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a8bd43485bd61fe04afe4b789a73b98c4a7a64993a78bdc2843c9c621e90d190e2">Heartbeats_User8</a> = 0xF
, <br />
&#160;&#160;<b>Heartbeats_MAX</b> = 0xF
<br />
 }</td></tr>
<tr class="memdesc:a8bd43485bd61fe04afe4b789a73b98c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name of a heartbeat when calling RecordHeartbeat().  <a href="namespacenn_1_1profiler.html#a8bd43485bd61fe04afe4b789a73b98c4">More...</a><br /></td></tr>
<tr class="separator:a8bd43485bd61fe04afe4b789a73b98c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c2f344cd2732c68fd3e207df06ab83"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a08c2f344cd2732c68fd3e207df06ab83">PerformanceCounterGroup</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a08c2f344cd2732c68fd3e207df06ab83a5e455e51df4ea90c128ef9076f05a5c8">PerformanceCounterGroup_Disabled</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a08c2f344cd2732c68fd3e207df06ab83a843b65aca97444ad2e4e6499619dd8ae">PerformanceCounterGroup_InstructionsExecuted</a> = 1
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a08c2f344cd2732c68fd3e207df06ab83ac265eb5d56930c63e3cc58a6ee913414">PerformanceCounterGroup_L1ICache</a> = 2
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a08c2f344cd2732c68fd3e207df06ab83a43f25b1d81744b033591c356c0d4e3ed">PerformanceCounterGroup_L1DCache</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a08c2f344cd2732c68fd3e207df06ab83a0d6f92438ccba0cd084385d65afac358">PerformanceCounterGroup_L2Cache</a> = 4
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a08c2f344cd2732c68fd3e207df06ab83a6638ef7f6ad99a3ab80ef3e3b0ac2acf">PerformanceCounterGroup_Atomics</a> = 5
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a08c2f344cd2732c68fd3e207df06ab83a16ff04192aedb88fcc5d03d94931a805">PerformanceCounterGroup_Branches</a> = 6
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a08c2f344cd2732c68fd3e207df06ab83a1b950c3cddf12351324caef5ee7e12c8">PerformanceCounterGroup_SystemCalls</a> = 7
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a08c2f344cd2732c68fd3e207df06ab83a08020fa81c0d4d0abea2d0f8b4703602">PerformanceCounterGroup_UnalignedDataAccess</a> = 8
<br />
 }</td></tr>
<tr class="memdesc:a08c2f344cd2732c68fd3e207df06ab83"><td class="mdescLeft">&#160;</td><td class="mdescRight">The performance counters that can be used in profiling.  <a href="namespacenn_1_1profiler.html#a08c2f344cd2732c68fd3e207df06ab83">More...</a><br /></td></tr>
<tr class="separator:a08c2f344cd2732c68fd3e207df06ab83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fea676000503cc4f931e0d93d51f5f2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a7fea676000503cc4f931e0d93d51f5f2">ProfilerStatus</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a7fea676000503cc4f931e0d93d51f5f2ac627e59e1ed1d4933a4160e31df553f4">ProfilerStatus_Offline</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a7fea676000503cc4f931e0d93d51f5f2a43d093c36283760e4102c94f54458c09">ProfilerStatus_Active</a> = 1
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a7fea676000503cc4f931e0d93d51f5f2aee16006157055d994c7694213ee3be42">ProfilerStatus_Profiling</a> = 2
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1profiler.html#a7fea676000503cc4f931e0d93d51f5f2ab2d31e18bc33aa3304cb0e14eed05911">ProfilerStatus_Transferring</a> = 3
, <br />
&#160;&#160;<b>ProfilerStatus_Max</b>
<br />
 }</td></tr>
<tr class="memdesc:a7fea676000503cc4f931e0d93d51f5f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enumeration of the different states the profiler can be in.  <a href="namespacenn_1_1profiler.html#a7fea676000503cc4f931e0d93d51f5f2">More...</a><br /></td></tr>
<tr class="separator:a7fea676000503cc4f931e0d93d51f5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88514e8daffe2e3bea8cf6ba79922572"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a88514e8daffe2e3bea8cf6ba79922572">SampleRate</a> { <br />
 }</td></tr>
<tr class="memdesc:a88514e8daffe2e3bea8cf6ba79922572"><td class="mdescLeft">&#160;</td><td class="mdescRight">The different sampling rates supported by the profiler.  <a href="namespacenn_1_1profiler.html#a88514e8daffe2e3bea8cf6ba79922572">More...</a><br /></td></tr>
<tr class="separator:a88514e8daffe2e3bea8cf6ba79922572"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a686d62f2d301026212a1f2f19d32e5e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a686d62f2d301026212a1f2f19d32e5e0">Finalize</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a686d62f2d301026212a1f2f19d32e5e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuts down the profiler.  <a href="namespacenn_1_1profiler.html#a686d62f2d301026212a1f2f19d32e5e0">More...</a><br /></td></tr>
<tr class="separator:a686d62f2d301026212a1f2f19d32e5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6188c8828050128b52e98bf5fc953b05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1profiler.html#a7fea676000503cc4f931e0d93d51f5f2">ProfilerStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a6188c8828050128b52e98bf5fc953b05">GetProfilerStatus</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6188c8828050128b52e98bf5fc953b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current status of the profiler.  <a href="namespacenn_1_1profiler.html#a6188c8828050128b52e98bf5fc953b05">More...</a><br /></td></tr>
<tr class="separator:a6188c8828050128b52e98bf5fc953b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd4585e5e75647e1cb20bb264f58f6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a1fd4585e5e75647e1cb20bb264f58f6e">Initialize</a> (void *pBuffer, size_t bufferSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1fd4585e5e75647e1cb20bb264f58f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the profiler.  <a href="namespacenn_1_1profiler.html#a1fd4585e5e75647e1cb20bb264f58f6e">More...</a><br /></td></tr>
<tr class="separator:a1fd4585e5e75647e1cb20bb264f58f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Graphics API</div></td></tr>
<tr class="memitem:a907804e676e1b37f7e1b62f5bace7992"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a907804e676e1b37f7e1b62f5bace7992">InstallGraphicsHooks</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a907804e676e1b37f7e1b62f5bace7992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs graphics hooks needed to enable the GPU Trace feature.  <a href="namespacenn_1_1profiler.html#a907804e676e1b37f7e1b62f5bace7992">More...</a><br /></td></tr>
<tr class="separator:a907804e676e1b37f7e1b62f5bace7992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eba4662b2649f42259c6604171e7425"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a7eba4662b2649f42259c6604171e7425">SetQueuePerFrameOperationEstimates</a> (<a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *queue, int numDraws, int numDebugPushes, int numComputeDispatches) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7eba4662b2649f42259c6604171e7425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the estimated max number of draws, debug pushes, and compute operations per frame for this queue.  <a href="namespacenn_1_1profiler.html#a7eba4662b2649f42259c6604171e7425">More...</a><br /></td></tr>
<tr class="separator:a7eba4662b2649f42259c6604171e7425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">File System Trace API</div></td></tr>
<tr class="memitem:a1e84c62cb23cbe2b7c628448d1a2fd2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a1e84c62cb23cbe2b7c628448d1a2fd2a">EnableFileSystemTrace</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1e84c62cb23cbe2b7c628448d1a2fd2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the profiler library to gather information on file system activities.  <a href="namespacenn_1_1profiler.html#a1e84c62cb23cbe2b7c628448d1a2fd2a">More...</a><br /></td></tr>
<tr class="separator:a1e84c62cb23cbe2b7c628448d1a2fd2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Logging API</div></td></tr>
<tr class="memitem:a90d857e6e5c2a9fe9f8938f1dd8d1829"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a90d857e6e5c2a9fe9f8938f1dd8d1829">RecordHeartbeat</a> (<a class="el" href="namespacenn_1_1profiler.html#a8bd43485bd61fe04afe4b789a73b98c4">Heartbeats</a> heartbeat) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a90d857e6e5c2a9fe9f8938f1dd8d1829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records the specified heartbeat into the current core's buffer.  <a href="namespacenn_1_1profiler.html#a90d857e6e5c2a9fe9f8938f1dd8d1829">More...</a><br /></td></tr>
<tr class="separator:a90d857e6e5c2a9fe9f8938f1dd8d1829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bcc0188395af2ef6c82c28465693edd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a9bcc0188395af2ef6c82c28465693edd">RecordData</a> (uint64_t id, uint64_t data) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9bcc0188395af2ef6c82c28465693edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records the specified data into the current core's buffer.  <a href="namespacenn_1_1profiler.html#a9bcc0188395af2ef6c82c28465693edd">More...</a><br /></td></tr>
<tr class="separator:a9bcc0188395af2ef6c82c28465693edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62432871a7838a486dbc49039b5f36f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a62432871a7838a486dbc49039b5f36f1">RecordData</a> (const char *id, uint64_t data) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a62432871a7838a486dbc49039b5f36f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records the specified data into the current core's buffer.  <a href="namespacenn_1_1profiler.html#a62432871a7838a486dbc49039b5f36f1">More...</a><br /></td></tr>
<tr class="separator:a62432871a7838a486dbc49039b5f36f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5d7e05cde34898be489559a05d7f1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#acd5d7e05cde34898be489559a05d7f1a">RecordData</a> (uint64_t id, double data) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acd5d7e05cde34898be489559a05d7f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records the specified data into the current core's buffer.  <a href="namespacenn_1_1profiler.html#acd5d7e05cde34898be489559a05d7f1a">More...</a><br /></td></tr>
<tr class="separator:acd5d7e05cde34898be489559a05d7f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab473595809a769ba153c7d7ad0ac172c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#ab473595809a769ba153c7d7ad0ac172c">RecordData</a> (const char *id, double data) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab473595809a769ba153c7d7ad0ac172c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records the specified data into the current core's buffer.  <a href="namespacenn_1_1profiler.html#ab473595809a769ba153c7d7ad0ac172c">More...</a><br /></td></tr>
<tr class="separator:ab473595809a769ba153c7d7ad0ac172c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Audio API</div></td></tr>
<tr class="memitem:a9312a49b962cc1cee3ee4a2be86c21fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a9312a49b962cc1cee3ee4a2be86c21fa">RegisterAudioRenderer</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html">nn::audio::AudioRendererParameter</a> &amp;parameter, <a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">nn::audio::AudioRendererConfig</a> *pConfig, <a class="el" href="namespacenn_1_1profiler.html#a4399ee2dc75cd00ff55e1b7cb984753d">AudioPerformanceMetricsControl</a> control) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9312a49b962cc1cee3ee4a2be86c21fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Audio Trace feature by registering an AudioRenderer with the profiler.  <a href="namespacenn_1_1profiler.html#a9312a49b962cc1cee3ee4a2be86c21fa">More...</a><br /></td></tr>
<tr class="separator:a9312a49b962cc1cee3ee4a2be86c21fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff43cb30e5803f4a44ce4f3a741c300"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#aaff43cb30e5803f4a44ce4f3a741c300">RecordAudioRendererPerformance</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">nn::audio::AudioRendererConfig</a> *pConfig) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aaff43cb30e5803f4a44ce4f3a741c300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Informs the profiler that it is safe to record AudioRenderer performance metrics.  <a href="namespacenn_1_1profiler.html#aaff43cb30e5803f4a44ce4f3a741c300">More...</a><br /></td></tr>
<tr class="separator:aaff43cb30e5803f4a44ce4f3a741c300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708429086a2791606968f789489e9c74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a708429086a2791606968f789489e9c74">RecordAudioRendererPerformance</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">nn::audio::AudioRendererConfig</a> *pConfig, const void *pPerformanceBuffer, size_t performanceBufferSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a708429086a2791606968f789489e9c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Informs the profiler that it is safe to record AudioRenderer performance metrics.  <a href="namespacenn_1_1profiler.html#a708429086a2791606968f789489e9c74">More...</a><br /></td></tr>
<tr class="separator:a708429086a2791606968f789489e9c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb1e473760f5461603df15a9d497ce4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a8eb1e473760f5461603df15a9d497ce4">SetAudioRendererTimeLimit</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">nn::audio::AudioRendererConfig</a> *pConfig, int limitPercent)</td></tr>
<tr class="memdesc:a8eb1e473760f5461603df15a9d497ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inform the profiler about changes to the audio renderer rendering time limit.  <a href="namespacenn_1_1profiler.html#a8eb1e473760f5461603df15a9d497ce4">More...</a><br /></td></tr>
<tr class="separator:a8eb1e473760f5461603df15a9d497ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Code Blocks API</div></td></tr>
<tr class="memitem:acd040cd20c33f208f315e60bdd0df745"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#acd040cd20c33f208f315e60bdd0df745">EnterCodeBlock</a> (uint64_t id) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acd040cd20c33f208f315e60bdd0df745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records a code block entry in the profile data.  <a href="namespacenn_1_1profiler.html#acd040cd20c33f208f315e60bdd0df745">More...</a><br /></td></tr>
<tr class="separator:acd040cd20c33f208f315e60bdd0df745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b1e434f5b815a86f8185b277df3d1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#af2b1e434f5b815a86f8185b277df3d1e">EnterCodeBlock</a> (const char *id) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af2b1e434f5b815a86f8185b277df3d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records a code block entry in the profile data.  <a href="namespacenn_1_1profiler.html#af2b1e434f5b815a86f8185b277df3d1e">More...</a><br /></td></tr>
<tr class="separator:af2b1e434f5b815a86f8185b277df3d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40482ccaf3b2a56eb6e8e7aeddfebacb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a40482ccaf3b2a56eb6e8e7aeddfebacb">ExitCodeBlock</a> (uint64_t id) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a40482ccaf3b2a56eb6e8e7aeddfebacb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records a code block exit in the profile data.  <a href="namespacenn_1_1profiler.html#a40482ccaf3b2a56eb6e8e7aeddfebacb">More...</a><br /></td></tr>
<tr class="separator:a40482ccaf3b2a56eb6e8e7aeddfebacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550d2f8bd7556acffb35b270cf708109"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a550d2f8bd7556acffb35b270cf708109">ExitCodeBlock</a> (const char *id) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a550d2f8bd7556acffb35b270cf708109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records a code block exit in the profile data.  <a href="namespacenn_1_1profiler.html#a550d2f8bd7556acffb35b270cf708109">More...</a><br /></td></tr>
<tr class="separator:a550d2f8bd7556acffb35b270cf708109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600680a6479c8e9aac5fd83e9db32cc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a600680a6479c8e9aac5fd83e9db32cc6">PushCodeBlock</a> (uint64_t id) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a600680a6479c8e9aac5fd83e9db32cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records a code block entry in the profile data.  <a href="namespacenn_1_1profiler.html#a600680a6479c8e9aac5fd83e9db32cc6">More...</a><br /></td></tr>
<tr class="separator:a600680a6479c8e9aac5fd83e9db32cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab089513cba1402e8d1b97c6732ba6188"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#ab089513cba1402e8d1b97c6732ba6188">PushCodeBlock</a> (const char *id) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab089513cba1402e8d1b97c6732ba6188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records a code block entry in the profile data.  <a href="namespacenn_1_1profiler.html#ab089513cba1402e8d1b97c6732ba6188">More...</a><br /></td></tr>
<tr class="separator:ab089513cba1402e8d1b97c6732ba6188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924cdef2a315b52be1fcc90627be9c09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a924cdef2a315b52be1fcc90627be9c09">PopCodeBlock</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a924cdef2a315b52be1fcc90627be9c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records a code block exit in the profile data.  <a href="namespacenn_1_1profiler.html#a924cdef2a315b52be1fcc90627be9c09">More...</a><br /></td></tr>
<tr class="separator:a924cdef2a315b52be1fcc90627be9c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Runtime Control API</div></td></tr>
<tr class="memitem:ad48cc14a1e10f1c84d4b59aacbaaecdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#ad48cc14a1e10f1c84d4b59aacbaaecdc">SetProfileSettings</a> (nn::Bit64 affinityMask, int flags, <a class="el" href="namespacenn_1_1profiler.html#a08c2f344cd2732c68fd3e207df06ab83">PerformanceCounterGroup</a> performanceCounterGroup, <a class="el" href="namespacenn_1_1profiler.html#a88514e8daffe2e3bea8cf6ba79922572">SampleRate</a> sampleRate) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad48cc14a1e10f1c84d4b59aacbaaecdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets profile settings for runtime based control.  <a href="namespacenn_1_1profiler.html#ad48cc14a1e10f1c84d4b59aacbaaecdc">More...</a><br /></td></tr>
<tr class="separator:ad48cc14a1e10f1c84d4b59aacbaaecdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b190188b23662a7ab1848053c530da9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a4b190188b23662a7ab1848053c530da9">StartProfiling</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4b190188b23662a7ab1848053c530da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start recording a profile.  <a href="namespacenn_1_1profiler.html#a4b190188b23662a7ab1848053c530da9">More...</a><br /></td></tr>
<tr class="separator:a4b190188b23662a7ab1848053c530da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03155333e1717521240f2de797d1c5ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a03155333e1717521240f2de797d1c5ca">StopProfiling</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a03155333e1717521240f2de797d1c5ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop recording a profile.  <a href="namespacenn_1_1profiler.html#a03155333e1717521240f2de797d1c5ca">More...</a><br /></td></tr>
<tr class="separator:a03155333e1717521240f2de797d1c5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Memory Tracking API</div></td></tr>
<tr class="memitem:a3bf0a5b9753b627089dfcc0d0493d64c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a3bf0a5b9753b627089dfcc0d0493d64c">RecordHeapRange</a> (void const *startAddress, void const *endAddress, char const *heapName) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3bf0a5b9753b627089dfcc0d0493d64c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records a heap name to be used for a given range of addresses.  <a href="namespacenn_1_1profiler.html#a3bf0a5b9753b627089dfcc0d0493d64c">More...</a><br /></td></tr>
<tr class="separator:a3bf0a5b9753b627089dfcc0d0493d64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfe8af38e4660d5d09a8c9fca2235d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a9bfe8af38e4660d5d09a8c9fca2235d5">TrackMalloc</a> (void const *address, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9bfe8af38e4660d5d09a8c9fca2235d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to malloc has occurred.  <a href="namespacenn_1_1profiler.html#a9bfe8af38e4660d5d09a8c9fca2235d5">More...</a><br /></td></tr>
<tr class="separator:a9bfe8af38e4660d5d09a8c9fca2235d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386470fad7781bac5a2b963d143b6450"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a386470fad7781bac5a2b963d143b6450">TrackMalloc</a> (void const *address, size_t size, char const *systemName) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a386470fad7781bac5a2b963d143b6450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to malloc has occurred.  <a href="namespacenn_1_1profiler.html#a386470fad7781bac5a2b963d143b6450">More...</a><br /></td></tr>
<tr class="separator:a386470fad7781bac5a2b963d143b6450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f77f933adf4b05ece605efe0695754"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a05f77f933adf4b05ece605efe0695754">TrackMalloc</a> (void const *address, size_t size, char const *systemName, int alignment) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a05f77f933adf4b05ece605efe0695754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to malloc has occurred.  <a href="namespacenn_1_1profiler.html#a05f77f933adf4b05ece605efe0695754">More...</a><br /></td></tr>
<tr class="separator:a05f77f933adf4b05ece605efe0695754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e26be5a4478b0d68a195e98a41972be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a1e26be5a4478b0d68a195e98a41972be">TrackCalloc</a> (void const *address, size_t num, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1e26be5a4478b0d68a195e98a41972be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to calloc has occurred.  <a href="namespacenn_1_1profiler.html#a1e26be5a4478b0d68a195e98a41972be">More...</a><br /></td></tr>
<tr class="separator:a1e26be5a4478b0d68a195e98a41972be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8864c08a9d8dea42318f14d373501f19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a8864c08a9d8dea42318f14d373501f19">TrackCalloc</a> (void const *address, size_t num, size_t size, char const *systemName) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8864c08a9d8dea42318f14d373501f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to calloc has occurred.  <a href="namespacenn_1_1profiler.html#a8864c08a9d8dea42318f14d373501f19">More...</a><br /></td></tr>
<tr class="separator:a8864c08a9d8dea42318f14d373501f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4413497f025f7969a6b0a2159b30318"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#ae4413497f025f7969a6b0a2159b30318">TrackCalloc</a> (void const *address, size_t num, size_t size, char const *systemName, int alignment) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae4413497f025f7969a6b0a2159b30318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to calloc has occurred.  <a href="namespacenn_1_1profiler.html#ae4413497f025f7969a6b0a2159b30318">More...</a><br /></td></tr>
<tr class="separator:ae4413497f025f7969a6b0a2159b30318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5fe5ac6184841e72de8c05a3cb6f91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a9a5fe5ac6184841e72de8c05a3cb6f91">TrackRealloc</a> (void const *oldAddress, void const *address, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9a5fe5ac6184841e72de8c05a3cb6f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to realloc has occurred.  <a href="namespacenn_1_1profiler.html#a9a5fe5ac6184841e72de8c05a3cb6f91">More...</a><br /></td></tr>
<tr class="separator:a9a5fe5ac6184841e72de8c05a3cb6f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a480619bc9e15b4726433088e1cdd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#ad6a480619bc9e15b4726433088e1cdd3">TrackRealloc</a> (void const *oldAddress, void const *address, size_t size, char const *systemName) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad6a480619bc9e15b4726433088e1cdd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to realloc has occurred.  <a href="namespacenn_1_1profiler.html#ad6a480619bc9e15b4726433088e1cdd3">More...</a><br /></td></tr>
<tr class="separator:ad6a480619bc9e15b4726433088e1cdd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2066520971eca6b78634a040a6a55e2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a2066520971eca6b78634a040a6a55e2c">TrackRealloc</a> (void const *oldAddress, void const *address, size_t size, char const *systemName, int alignment) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2066520971eca6b78634a040a6a55e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to realloc has occurred.  <a href="namespacenn_1_1profiler.html#a2066520971eca6b78634a040a6a55e2c">More...</a><br /></td></tr>
<tr class="separator:a2066520971eca6b78634a040a6a55e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c9804d8d9b83dcd77ef68856ae6b2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#ad9c9804d8d9b83dcd77ef68856ae6b2f">TrackFree</a> (void const *address) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad9c9804d8d9b83dcd77ef68856ae6b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to free has occurred.  <a href="namespacenn_1_1profiler.html#ad9c9804d8d9b83dcd77ef68856ae6b2f">More...</a><br /></td></tr>
<tr class="separator:ad9c9804d8d9b83dcd77ef68856ae6b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3ef93ec17409afe2ecce193766a50d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a0b3ef93ec17409afe2ecce193766a50d">TrackFree</a> (void const *address, char const *systemName) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0b3ef93ec17409afe2ecce193766a50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to free has occurred.  <a href="namespacenn_1_1profiler.html#a0b3ef93ec17409afe2ecce193766a50d">More...</a><br /></td></tr>
<tr class="separator:a0b3ef93ec17409afe2ecce193766a50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c8d86f75c8e20a2a422eb4f46b6b84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#ad5c8d86f75c8e20a2a422eb4f46b6b84">TrackNew</a> (void const *address, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad5c8d86f75c8e20a2a422eb4f46b6b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to new has occurred.  <a href="namespacenn_1_1profiler.html#ad5c8d86f75c8e20a2a422eb4f46b6b84">More...</a><br /></td></tr>
<tr class="separator:ad5c8d86f75c8e20a2a422eb4f46b6b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3efb8b90b93543737c558674105fa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#afe3efb8b90b93543737c558674105fa6">TrackNew</a> (void const *address, size_t size, char const *systemName) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:afe3efb8b90b93543737c558674105fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to new has occurred.  <a href="namespacenn_1_1profiler.html#afe3efb8b90b93543737c558674105fa6">More...</a><br /></td></tr>
<tr class="separator:afe3efb8b90b93543737c558674105fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae301f90d0c7ed1db7165fca52cc99270"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#ae301f90d0c7ed1db7165fca52cc99270">TrackNew</a> (void const *address, size_t size, char const *systemName, int alignment) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae301f90d0c7ed1db7165fca52cc99270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to new has occurred.  <a href="namespacenn_1_1profiler.html#ae301f90d0c7ed1db7165fca52cc99270">More...</a><br /></td></tr>
<tr class="separator:ae301f90d0c7ed1db7165fca52cc99270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26fb8437ca8cc2670127919900fc0f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#ae26fb8437ca8cc2670127919900fc0f3">TrackNew</a> (void const *address, size_t size, char const *systemName, bool isVector) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae26fb8437ca8cc2670127919900fc0f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to new has occurred.  <a href="namespacenn_1_1profiler.html#ae26fb8437ca8cc2670127919900fc0f3">More...</a><br /></td></tr>
<tr class="separator:ae26fb8437ca8cc2670127919900fc0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa317471e9629ec143a4657e0c3b1665d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#aa317471e9629ec143a4657e0c3b1665d">TrackNew</a> (void const *address, size_t size, char const *systemName, int alignment, bool isVector) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa317471e9629ec143a4657e0c3b1665d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to new has occurred.  <a href="namespacenn_1_1profiler.html#aa317471e9629ec143a4657e0c3b1665d">More...</a><br /></td></tr>
<tr class="separator:aa317471e9629ec143a4657e0c3b1665d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa879772ab7830431310aa39fafed3033"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#aa879772ab7830431310aa39fafed3033">TrackDelete</a> (void const *address) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa879772ab7830431310aa39fafed3033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to delete has occurred.  <a href="namespacenn_1_1profiler.html#aa879772ab7830431310aa39fafed3033">More...</a><br /></td></tr>
<tr class="separator:aa879772ab7830431310aa39fafed3033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb1f323af3ff13f604ba0b492a9ba39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a7bb1f323af3ff13f604ba0b492a9ba39">TrackDelete</a> (void const *address, char const *systemName) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7bb1f323af3ff13f604ba0b492a9ba39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to delete has occurred.  <a href="namespacenn_1_1profiler.html#a7bb1f323af3ff13f604ba0b492a9ba39">More...</a><br /></td></tr>
<tr class="separator:a7bb1f323af3ff13f604ba0b492a9ba39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c20b36512995567c400ac954a93f19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a88c20b36512995567c400ac954a93f19">TrackDelete</a> (void const *address, char const *systemName, bool isVector) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a88c20b36512995567c400ac954a93f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to delete has occurred.  <a href="namespacenn_1_1profiler.html#a88c20b36512995567c400ac954a93f19">More...</a><br /></td></tr>
<tr class="separator:a88c20b36512995567c400ac954a93f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf33f5085549b0184a827cf6a902def7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#abf33f5085549b0184a827cf6a902def7">GenerateNextTrackingId</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:abf33f5085549b0184a827cf6a902def7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates tracking information for a specific call to Track* functions.  <a href="namespacenn_1_1profiler.html#abf33f5085549b0184a827cf6a902def7">More...</a><br /></td></tr>
<tr class="separator:abf33f5085549b0184a827cf6a902def7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fbafbd6cf9c09fbc2629af278c77d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a70fbafbd6cf9c09fbc2629af278c77d1">TrackMalloc</a> (<a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;id, void const *address, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a70fbafbd6cf9c09fbc2629af278c77d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to malloc has occurred.  <a href="namespacenn_1_1profiler.html#a70fbafbd6cf9c09fbc2629af278c77d1">More...</a><br /></td></tr>
<tr class="separator:a70fbafbd6cf9c09fbc2629af278c77d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69d91e1c97014ba96993db2700e1fbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#aa69d91e1c97014ba96993db2700e1fbd">TrackMalloc</a> (<a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;id, void const *address, size_t size, char const *systemName) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa69d91e1c97014ba96993db2700e1fbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to malloc has occurred.  <a href="namespacenn_1_1profiler.html#aa69d91e1c97014ba96993db2700e1fbd">More...</a><br /></td></tr>
<tr class="separator:aa69d91e1c97014ba96993db2700e1fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ed55d4a2bc608c57227e6221f7b856"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a71ed55d4a2bc608c57227e6221f7b856">TrackMalloc</a> (<a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;id, void const *address, size_t size, char const *systemName, int alignment) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a71ed55d4a2bc608c57227e6221f7b856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to malloc has occurred.  <a href="namespacenn_1_1profiler.html#a71ed55d4a2bc608c57227e6221f7b856">More...</a><br /></td></tr>
<tr class="separator:a71ed55d4a2bc608c57227e6221f7b856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c41fcc6fed61a4e72c2fa7348b1bd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#ac1c41fcc6fed61a4e72c2fa7348b1bd1">TrackCalloc</a> (<a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;id, void const *address, size_t num, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac1c41fcc6fed61a4e72c2fa7348b1bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to calloc has occurred.  <a href="namespacenn_1_1profiler.html#ac1c41fcc6fed61a4e72c2fa7348b1bd1">More...</a><br /></td></tr>
<tr class="separator:ac1c41fcc6fed61a4e72c2fa7348b1bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317bfa9b36a0d6bc5225549f2ea34e70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a317bfa9b36a0d6bc5225549f2ea34e70">TrackCalloc</a> (<a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;id, void const *address, size_t num, size_t size, char const *systemName) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a317bfa9b36a0d6bc5225549f2ea34e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to calloc has occurred.  <a href="namespacenn_1_1profiler.html#a317bfa9b36a0d6bc5225549f2ea34e70">More...</a><br /></td></tr>
<tr class="separator:a317bfa9b36a0d6bc5225549f2ea34e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e142abaea2e0649e18bb7fac8cad15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a64e142abaea2e0649e18bb7fac8cad15">TrackCalloc</a> (<a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;id, void const *address, size_t num, size_t size, char const *systemName, int alignment) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a64e142abaea2e0649e18bb7fac8cad15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to calloc has occurred.  <a href="namespacenn_1_1profiler.html#a64e142abaea2e0649e18bb7fac8cad15">More...</a><br /></td></tr>
<tr class="separator:a64e142abaea2e0649e18bb7fac8cad15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ac7c2d6d79eac32b2eec77ec4e3d8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#ae8ac7c2d6d79eac32b2eec77ec4e3d8f">TrackRealloc</a> (<a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;id, void const *oldAddress, void const *address, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae8ac7c2d6d79eac32b2eec77ec4e3d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to realloc has occurred.  <a href="namespacenn_1_1profiler.html#ae8ac7c2d6d79eac32b2eec77ec4e3d8f">More...</a><br /></td></tr>
<tr class="separator:ae8ac7c2d6d79eac32b2eec77ec4e3d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1066aeac58c1d2ebe478cfcfa7580bd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a1066aeac58c1d2ebe478cfcfa7580bd5">TrackRealloc</a> (<a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;id, void const *oldAddress, void const *address, size_t size, char const *systemName) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1066aeac58c1d2ebe478cfcfa7580bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to realloc has occurred.  <a href="namespacenn_1_1profiler.html#a1066aeac58c1d2ebe478cfcfa7580bd5">More...</a><br /></td></tr>
<tr class="separator:a1066aeac58c1d2ebe478cfcfa7580bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c193ffd767e9dfdf3ab129b1738a81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a03c193ffd767e9dfdf3ab129b1738a81">TrackRealloc</a> (<a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;id, void const *oldAddress, void const *address, size_t size, char const *systemName, int alignment) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a03c193ffd767e9dfdf3ab129b1738a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to realloc has occurred.  <a href="namespacenn_1_1profiler.html#a03c193ffd767e9dfdf3ab129b1738a81">More...</a><br /></td></tr>
<tr class="separator:a03c193ffd767e9dfdf3ab129b1738a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bdc5d99fd0eb045c23efc9a7c1590f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a60bdc5d99fd0eb045c23efc9a7c1590f">TrackFree</a> (<a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;id, void const *address) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a60bdc5d99fd0eb045c23efc9a7c1590f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to free has occurred.  <a href="namespacenn_1_1profiler.html#a60bdc5d99fd0eb045c23efc9a7c1590f">More...</a><br /></td></tr>
<tr class="separator:a60bdc5d99fd0eb045c23efc9a7c1590f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf389407e06a908483b004d09e417923"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#aaf389407e06a908483b004d09e417923">TrackFree</a> (<a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;id, void const *address, char const *systemName) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aaf389407e06a908483b004d09e417923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to free has occurred.  <a href="namespacenn_1_1profiler.html#aaf389407e06a908483b004d09e417923">More...</a><br /></td></tr>
<tr class="separator:aaf389407e06a908483b004d09e417923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4e25fff994339d493473a30b84b92e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#aaf4e25fff994339d493473a30b84b92e">TrackNew</a> (<a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;id, void const *address, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aaf4e25fff994339d493473a30b84b92e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to new has occurred.  <a href="namespacenn_1_1profiler.html#aaf4e25fff994339d493473a30b84b92e">More...</a><br /></td></tr>
<tr class="separator:aaf4e25fff994339d493473a30b84b92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76c3b7e171f41142e98e30d583bcf55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#ab76c3b7e171f41142e98e30d583bcf55">TrackNew</a> (<a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;id, void const *address, size_t size, char const *systemName) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab76c3b7e171f41142e98e30d583bcf55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to new has occurred.  <a href="namespacenn_1_1profiler.html#ab76c3b7e171f41142e98e30d583bcf55">More...</a><br /></td></tr>
<tr class="separator:ab76c3b7e171f41142e98e30d583bcf55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9fda43b70a36a60560d88ca0ad02d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a5b9fda43b70a36a60560d88ca0ad02d8">TrackNew</a> (<a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;id, void const *address, size_t size, char const *systemName, int alignment) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5b9fda43b70a36a60560d88ca0ad02d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to new has occurred.  <a href="namespacenn_1_1profiler.html#a5b9fda43b70a36a60560d88ca0ad02d8">More...</a><br /></td></tr>
<tr class="separator:a5b9fda43b70a36a60560d88ca0ad02d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a84631afe077b0ed1ea6e8b0e645955"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a1a84631afe077b0ed1ea6e8b0e645955">TrackNew</a> (<a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;id, void const *address, size_t size, char const *systemName, bool isVector) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1a84631afe077b0ed1ea6e8b0e645955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to new has occurred.  <a href="namespacenn_1_1profiler.html#a1a84631afe077b0ed1ea6e8b0e645955">More...</a><br /></td></tr>
<tr class="separator:a1a84631afe077b0ed1ea6e8b0e645955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5bcf375daf8362b57df034556555ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#aeb5bcf375daf8362b57df034556555ae">TrackNew</a> (<a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;id, void const *address, size_t size, char const *systemName, int alignment, bool isVector) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aeb5bcf375daf8362b57df034556555ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to new has occurred.  <a href="namespacenn_1_1profiler.html#aeb5bcf375daf8362b57df034556555ae">More...</a><br /></td></tr>
<tr class="separator:aeb5bcf375daf8362b57df034556555ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e3eab3983f6f2de28eba7b8a277992"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a59e3eab3983f6f2de28eba7b8a277992">TrackDelete</a> (<a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;id, void const *address) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a59e3eab3983f6f2de28eba7b8a277992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to delete has occurred.  <a href="namespacenn_1_1profiler.html#a59e3eab3983f6f2de28eba7b8a277992">More...</a><br /></td></tr>
<tr class="separator:a59e3eab3983f6f2de28eba7b8a277992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57926ce88ab4ef7ddaccd89ae1a547c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#af57926ce88ab4ef7ddaccd89ae1a547c">TrackDelete</a> (<a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;id, void const *address, char const *systemName) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af57926ce88ab4ef7ddaccd89ae1a547c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to delete has occurred.  <a href="namespacenn_1_1profiler.html#af57926ce88ab4ef7ddaccd89ae1a547c">More...</a><br /></td></tr>
<tr class="separator:af57926ce88ab4ef7ddaccd89ae1a547c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62f019cb92043d3aac05b10b39628d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#ac62f019cb92043d3aac05b10b39628d4">TrackDelete</a> (<a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;id, void const *address, char const *systemName, bool isVector) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac62f019cb92043d3aac05b10b39628d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a call to delete has occurred.  <a href="namespacenn_1_1profiler.html#ac62f019cb92043d3aac05b10b39628d4">More...</a><br /></td></tr>
<tr class="separator:ac62f019cb92043d3aac05b10b39628d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e55d65c34ed2242e18640212b808ba6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1os_1_1_system_event_type.html">nn::os::SystemEventType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a3e55d65c34ed2242e18640212b808ba6">GetMemoryTrackingHostConnectedEvent</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3e55d65c34ed2242e18640212b808ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="namespacenn_1_1os.html#aa689721442ec303678047dd75c957bea" title="Waits for a system event to enter a signaled state.">nn::os::WaitSystemEvent</a> that is signaled when the memory tracking tool is connected.  <a href="namespacenn_1_1profiler.html#a3e55d65c34ed2242e18640212b808ba6">More...</a><br /></td></tr>
<tr class="separator:a3e55d65c34ed2242e18640212b808ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a9bc180dcf49e08d2b3c8f0bb7d8358b6"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1profiler.html#a9bc180dcf49e08d2b3c8f0bb7d8358b6">MinimumBufferSize</a> = 64 * 1024 * 1024</td></tr>
<tr class="memdesc:a9bc180dcf49e08d2b3c8f0bb7d8358b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum buffer size needed by the profiler to function.  <a href="namespacenn_1_1profiler.html#a9bc180dcf49e08d2b3c8f0bb7d8358b6">More...</a><br /></td></tr>
<tr class="separator:a9bc180dcf49e08d2b3c8f0bb7d8358b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Nintendo NX CPU Profiler Namespace. </p>
<p> <b>Details</b> <br  />
 Nintendo NX CPU Profiler Namespace</p>
<h4><a class="anchor" id="autotoc_md318"></a>
Memory Tracking API</h4>
<p>The Memory Tracking API records data regarding the status of the heap. To receive this data, the Heap Inspector tool must be connected. Currently, the function parameters <em>systemName</em>, <em>alignment</em>, and <em>isVector</em> are not supported by the Heap Inspector tool. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a4399ee2dc75cd00ff55e1b7cb984753d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4399ee2dc75cd00ff55e1b7cb984753d">&#9670;&nbsp;</a></span>AudioPerformanceMetricsControl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1profiler.html#a4399ee2dc75cd00ff55e1b7cb984753d">nn::profiler::AudioPerformanceMetricsControl</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells the profiler who will be in control of the AudioRenderer performance frame buffer. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4399ee2dc75cd00ff55e1b7cb984753da23524272abace8e05f23532e476c88de"></a>AudioPerformanceMetricsControl_Automatic&#160;</td><td class="fielddoc"><p>Have the profiler library manage the performance frame buffer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4399ee2dc75cd00ff55e1b7cb984753da8574cd1b4c04a3f5568cb792b255a59b"></a>AudioPerformanceMetricsControl_Manual&#160;</td><td class="fielddoc"><p>The performance frame buffer is provided to the profiler library. </p>
</td></tr>
</table>

</div>
</div>
<a id="ae600326a48953627efa2c28ad9762f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae600326a48953627efa2c28ad9762f84">&#9670;&nbsp;</a></span>Cores</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1profiler.html#ae600326a48953627efa2c28ad9762f84">nn::profiler::Cores</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the set of cores that data can be collected on. </p>
<p> <b>Details</b> <br  />
These enumerations are used as a bitwise OR and passed into <a class="el" href="namespacenn_1_1profiler.html#ad48cc14a1e10f1c84d4b59aacbaaecdc" title="Sets profile settings for runtime based control.">nn::profiler::SetProfileSettings()</a>. These flags correspond to the <em>Core</em> buttons on the <em>Sampled Profile</em> tab in the GUI. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae600326a48953627efa2c28ad9762f84a570406ee8ac132e5411980a74f0983ce"></a>Cores_0&#160;</td><td class="fielddoc"><p>Core 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae600326a48953627efa2c28ad9762f84ad37a2f0bfcf1809cbbddfb7c05842bd9"></a>Cores_1&#160;</td><td class="fielddoc"><p>Core 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae600326a48953627efa2c28ad9762f84a8b17be965dfae5adb2497ff0d08fc057"></a>Cores_2&#160;</td><td class="fielddoc"><p>Core 2. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae600326a48953627efa2c28ad9762f84aac74f924100217bb262d658f646b8057"></a>Cores_All&#160;</td><td class="fielddoc"><p>All three cores. </p>
</td></tr>
</table>

</div>
</div>
<a id="a494bd9ad9ee12e0f68bb64263cc416f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a494bd9ad9ee12e0f68bb64263cc416f7">&#9670;&nbsp;</a></span>Flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1profiler.html#a494bd9ad9ee12e0f68bb64263cc416f7">nn::profiler::Flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags used to control how the profiler works. </p>
<p> <b>Details</b> <br  />
These flags are used as a bitwise OR and are passed into <a class="el" href="namespacenn_1_1profiler.html#ad48cc14a1e10f1c84d4b59aacbaaecdc" title="Sets profile settings for runtime based control.">nn::profiler::SetProfileSettings()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a494bd9ad9ee12e0f68bb64263cc416f7a0cae9c46e389056f41bf68ce8800fc24"></a>Flags_Simple&#160;</td><td class="fielddoc"><p>Only Program counters are recorded. </p>
<p> <b>Details</b> <br  />
This flag corresponds to have the <em>Leaf Only</em> button toggled in the GUI.</p>
<p>When this flag is set, only Program Counters will be recorded in the profile data. This flag is mutually exclusive with <a class="el" href="namespacenn_1_1profiler.html#a494bd9ad9ee12e0f68bb64263cc416f7afaddb8c59d9ea3f2f062d407a209a378" title="Callstacks will be recorded.">nn::profiler::Flags_Callstack</a>. Other flags can be used in conjunction with this flag.</p>
<p>This flag is useful because it will show where the sample occurred. There is less overhead with this when compared to <a class="el" href="namespacenn_1_1profiler.html#a494bd9ad9ee12e0f68bb64263cc416f7afaddb8c59d9ea3f2f062d407a209a378" title="Callstacks will be recorded.">nn::profiler::Flags_Callstack</a>. Because less data is recorded, longer profiles can also be taken. </p>
</td></tr>
<tr><td class="fieldname"><a id="a494bd9ad9ee12e0f68bb64263cc416f7afaddb8c59d9ea3f2f062d407a209a378"></a>Flags_Callstack&#160;</td><td class="fielddoc"><p>Callstacks will be recorded. </p>
<p> <b>Details</b> <br  />
This flag corresponds to have the <em>Callstack</em> button toggled in the GUI.</p>
<p>When this flag is set, full callstack data will be recorded in the profile data. This flag is mutually exclusive with <a class="el" href="namespacenn_1_1profiler.html#a494bd9ad9ee12e0f68bb64263cc416f7a0cae9c46e389056f41bf68ce8800fc24" title="Only Program counters are recorded.">nn::profiler::Flags_Simple</a>. Other flags can be used in conjunction with this flag.</p>
<p>This flag is useful because it will show the complete callstack where the sample occurred. There is more overhead with this when compared to <a class="el" href="namespacenn_1_1profiler.html#a494bd9ad9ee12e0f68bb64263cc416f7a0cae9c46e389056f41bf68ce8800fc24" title="Only Program counters are recorded.">nn::profiler::Flags_Simple</a>. Because more data is recorded, profile time is reduced. </p>
</td></tr>
<tr><td class="fieldname"><a id="a494bd9ad9ee12e0f68bb64263cc416f7aecf478c090f9ba12d973bb091ee7a095"></a>Flags_PerformanceCounters&#160;</td><td class="fielddoc"><p>When a sample is taken, also record performance counter data. </p>
<p> <b>Details</b> <br  />
This flag corresponds to selecting a performance counter group in the GUI.</p>
<p>When this flag is set, performance counter data is recorded in the profile data.</p>
<p>When using this option, a <a class="el" href="namespacenn_1_1profiler.html#a08c2f344cd2732c68fd3e207df06ab83">performance counter group</a> should be supplied in <a class="el" href="namespacenn_1_1profiler.html#ad48cc14a1e10f1c84d4b59aacbaaecdc" title="Sets profile settings for runtime based control.">nn::profiler::SetProfileSettings()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a494bd9ad9ee12e0f68bb64263cc416f7a304d2673c36980a078c16a7a8da40f66"></a>Flags_RingBuffer&#160;</td><td class="fielddoc"><p>As data is collected, use ring buffers to allow for continuous profiling. </p>
<p> <b>Details</b> <br  />
This flag corresponds to changing the buffer mode to <em>Ring Buffer</em> in the GUI. When the flag is not set, it equates to the buffer mode <em>Stop When Full</em>.</p>
<p>Using this option allows for collecting data continuously until explicitly stopped. This can be useful for tracking down issues that do not occur consistently. </p>
</td></tr>
<tr><td class="fieldname"><a id="a494bd9ad9ee12e0f68bb64263cc416f7a650fcd5cedbd2374dcc8dda450c499e8"></a>Flags_OutOfProcessProfiling&#160;</td><td class="fielddoc"><p>Take a profile using out-of-process profiling, rather than in-process profiling. </p>
<p> <b>Details</b> <br  />
This flag corresponds to the <em>In-Process</em> and <em>Out-of-Process</em> buttons in the GUI on the <em>Sampled Profile</em> tab.</p>
<p>The default behavior of the profiler is to use the in-process profiler. Setting this flag allows for the use the out-of-process profiler instead. Please see the GUI and/or manual for information on the two available profiling modes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a494bd9ad9ee12e0f68bb64263cc416f7aa1e0595d19d578048a0be7e86cdfaab3"></a>Flags_GraphicsTrace&#160;</td><td class="fielddoc"><p>Take a profile with the Graphics Trace feature enabled. </p>
<p> <b>Details</b> <br  />
This flag corresponds to the <em>Graphics</em> button in the GUI on the <em>Sampled Profile</em> tab.</p>
<p>To use this flag, the application must have called <a class="el" href="namespacenn_1_1profiler.html#a907804e676e1b37f7e1b62f5bace7992" title="Installs graphics hooks needed to enable the GPU Trace feature.">nn::profiler::InstallGraphicsHooks()</a>.</p>
<p>When this flag is set, it will enable profiling with the Graphics Trace feature, sending information about when NVN functions were called to the PC. </p>
</td></tr>
<tr><td class="fieldname"><a id="a494bd9ad9ee12e0f68bb64263cc416f7af63383d4948327755e3a5761bebdec50"></a>Flags_AudioTrace&#160;</td><td class="fielddoc"><p>Take a profile with the Audio Trace feature enabled. </p>
<p> <b>Details</b> <br  />
This flag corresponds to the <em>Audio</em> button in the GUI on the <em>Sampled Profile</em> tab.</p>
<p>To use this flag, the application must have called <a class="el" href="namespacenn_1_1profiler.html#a9312a49b962cc1cee3ee4a2be86c21fa" title="Enables the Audio Trace feature by registering an AudioRenderer with the profiler.">nn::profiler::RegisterAudioRenderer()</a>.</p>
<p>When this flag is et, it will enable profiling with the Audio Trace feature, placing Audio Renderer usage information in the profile buffers. </p>
</td></tr>
<tr><td class="fieldname"><a id="a494bd9ad9ee12e0f68bb64263cc416f7ace540f9245886075d980c6ffe3c10d0b"></a>Flags_FileSystemTrace&#160;</td><td class="fielddoc"><p>Take a profile with the File System Trace feature enabled. </p>
<p> <b>Details</b> <br  />
This flag corresponds to the <em>File</em> button in the GUI on the <em>Sampled Profile</em> tab.</p>
<p>To use this flag, the application must have called <a class="el" href="namespacenn_1_1profiler.html#a1e84c62cb23cbe2b7c628448d1a2fd2a" title="Enables the profiler library to gather information on file system activities.">nn::profiler::EnableFileSystemTrace()</a>.</p>
<p>When this flag is set, it will enable profiling with the File System Trace feature, placing File System access information in the profile buffers. </p>
</td></tr>
</table>

</div>
</div>
<a id="a08c2f344cd2732c68fd3e207df06ab83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c2f344cd2732c68fd3e207df06ab83">&#9670;&nbsp;</a></span>PerformanceCounterGroup</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1profiler.html#a08c2f344cd2732c68fd3e207df06ab83">nn::profiler::PerformanceCounterGroup</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The performance counters that can be used in profiling. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a08c2f344cd2732c68fd3e207df06ab83a5e455e51df4ea90c128ef9076f05a5c8"></a>PerformanceCounterGroup_Disabled&#160;</td><td class="fielddoc"><p>No performance counter data is recorded. </p>
</td></tr>
<tr><td class="fieldname"><a id="a08c2f344cd2732c68fd3e207df06ab83a843b65aca97444ad2e4e6499619dd8ae"></a>PerformanceCounterGroup_InstructionsExecuted&#160;</td><td class="fielddoc"><p>Shows a variety of performance counters on the instructions executed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a08c2f344cd2732c68fd3e207df06ab83ac265eb5d56930c63e3cc58a6ee913414"></a>PerformanceCounterGroup_L1ICache&#160;</td><td class="fielddoc"><p>Shows how instructions interact with the L1 instruction cache. </p>
</td></tr>
<tr><td class="fieldname"><a id="a08c2f344cd2732c68fd3e207df06ab83a43f25b1d81744b033591c356c0d4e3ed"></a>PerformanceCounterGroup_L1DCache&#160;</td><td class="fielddoc"><p>Shows how data interact with the L1 data cache. </p>
</td></tr>
<tr><td class="fieldname"><a id="a08c2f344cd2732c68fd3e207df06ab83a0d6f92438ccba0cd084385d65afac358"></a>PerformanceCounterGroup_L2Cache&#160;</td><td class="fielddoc"><p>Shows how instructions and data interact with the unified L2 cache. </p>
</td></tr>
<tr><td class="fieldname"><a id="a08c2f344cd2732c68fd3e207df06ab83a6638ef7f6ad99a3ab80ef3e3b0ac2acf"></a>PerformanceCounterGroup_Atomics&#160;</td><td class="fielddoc"><p>Tracks instruction usage related to the use of atomic values. </p>
</td></tr>
<tr><td class="fieldname"><a id="a08c2f344cd2732c68fd3e207df06ab83a16ff04192aedb88fcc5d03d94931a805"></a>PerformanceCounterGroup_Branches&#160;</td><td class="fielddoc"><p>Tracks branch instruction usage. </p>
</td></tr>
<tr><td class="fieldname"><a id="a08c2f344cd2732c68fd3e207df06ab83a1b950c3cddf12351324caef5ee7e12c8"></a>PerformanceCounterGroup_SystemCalls&#160;</td><td class="fielddoc"><p>Tracks system calls made by the application. </p>
</td></tr>
<tr><td class="fieldname"><a id="a08c2f344cd2732c68fd3e207df06ab83a08020fa81c0d4d0abea2d0f8b4703602"></a>PerformanceCounterGroup_UnalignedDataAccess&#160;</td><td class="fielddoc"><p>Tracks reads and writes where data is not properly aligned. </p>
</td></tr>
</table>

</div>
</div>
<a id="a88514e8daffe2e3bea8cf6ba79922572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88514e8daffe2e3bea8cf6ba79922572">&#9670;&nbsp;</a></span>SampleRate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1profiler.html#a88514e8daffe2e3bea8cf6ba79922572">nn::profiler::SampleRate</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The different sampling rates supported by the profiler. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a88514e8daffe2e3bea8cf6ba79922572a8a13c027dbd0edce2b065db53aedf5ca"></a>SampleRate_ByTime5x&#160;</td><td class="fielddoc"><p>Sample 5 times every 60Hz frame. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88514e8daffe2e3bea8cf6ba79922572a97f44081a51ee3354f4903d1131fe0c0"></a>SampleRate_ByTime10x&#160;</td><td class="fielddoc"><p>Sample 10 times every 60Hz frame. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88514e8daffe2e3bea8cf6ba79922572a75b170ef7b0ae5650f1bd92e05cbbd0c"></a>SampleRate_ByTime25x&#160;</td><td class="fielddoc"><p>Sample 25 times every 60Hz frame. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88514e8daffe2e3bea8cf6ba79922572ae5f71dadb555c207c88262875ad66144"></a>SampleRate_ByTime50x&#160;</td><td class="fielddoc"><p>Sample 50 times every 60Hz frame. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88514e8daffe2e3bea8cf6ba79922572aa439e6f68833751726f38c8d5ed9d908"></a>SampleRate_ByTime75x&#160;</td><td class="fielddoc"><p>Sample 75 times every 60Hz frame. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88514e8daffe2e3bea8cf6ba79922572aac1d0c6564ca981e37970b44da0585e3"></a>SampleRate_ByTime100x&#160;</td><td class="fielddoc"><p>Sample 100 times every 60Hz frame. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88514e8daffe2e3bea8cf6ba79922572a20111d6cc7f32379a51fb5e62ef730e6"></a>SampleRate_ByTime250x&#160;</td><td class="fielddoc"><p>Sample 250 times every 60Hz frame. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88514e8daffe2e3bea8cf6ba79922572ac1f81a1ab1a9d284efc482f6368bedc9"></a>SampleRate_ByTime500x&#160;</td><td class="fielddoc"><p>Sample 500 times every 60Hz frame. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88514e8daffe2e3bea8cf6ba79922572ac2b1f5b25db80f1478f46aad107e4bcb"></a>SampleRate_ByTime750x&#160;</td><td class="fielddoc"><p>Sample 750 times every 60Hz frame. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88514e8daffe2e3bea8cf6ba79922572a97e867bc4d894195874e5e1f75fd2115"></a>SampleRate_ByTime1000x&#160;</td><td class="fielddoc"><p>Sample 1000 times every 60Hz frame. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88514e8daffe2e3bea8cf6ba79922572a4fe5ac36b4409496fb15a4f940385973"></a>SampleRate_ByTime2000x&#160;</td><td class="fielddoc"><p>Sample 2000 times every 60Hz frame. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88514e8daffe2e3bea8cf6ba79922572adb70b30d9074f04f306d7892b3a5a0c7"></a>SampleRate_ByTime4000x&#160;</td><td class="fielddoc"><p>Sample 4000 times every 60Hz frame. </p>
</td></tr>
</table>

</div>
</div>
<a id="a7fea676000503cc4f931e0d93d51f5f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fea676000503cc4f931e0d93d51f5f2">&#9670;&nbsp;</a></span>ProfilerStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1profiler.html#a7fea676000503cc4f931e0d93d51f5f2">nn::profiler::ProfilerStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An enumeration of the different states the profiler can be in. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7fea676000503cc4f931e0d93d51f5f2ac627e59e1ed1d4933a4160e31df553f4"></a>ProfilerStatus_Offline&#160;</td><td class="fielddoc"><p>The profiler has not yet been initialized, or has been finalized. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7fea676000503cc4f931e0d93d51f5f2a43d093c36283760e4102c94f54458c09"></a>ProfilerStatus_Active&#160;</td><td class="fielddoc"><p>The profiler is ready to take a profile. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7fea676000503cc4f931e0d93d51f5f2aee16006157055d994c7694213ee3be42"></a>ProfilerStatus_Profiling&#160;</td><td class="fielddoc"><p>The profiler is currently taking a profile. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7fea676000503cc4f931e0d93d51f5f2ab2d31e18bc33aa3304cb0e14eed05911"></a>ProfilerStatus_Transferring&#160;</td><td class="fielddoc"><p>The profiler has finished profiling but is still transferring data to the PC. </p>
</td></tr>
</table>

</div>
</div>
<a id="a8bd43485bd61fe04afe4b789a73b98c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd43485bd61fe04afe4b789a73b98c4">&#9670;&nbsp;</a></span>Heartbeats</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1profiler.html#a8bd43485bd61fe04afe4b789a73b98c4">nn::profiler::Heartbeats</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the name of a heartbeat when calling <a class="el" href="namespacenn_1_1profiler.html#a90d857e6e5c2a9fe9f8938f1dd8d1829" title="Records the specified heartbeat into the current core&#39;s buffer.">RecordHeartbeat()</a>. </p>
<p> <b>Details</b> <br  />
</p><dl class="section note"><dt>Note</dt><dd>The Main heartbeat should only be used in a single location. If it is used in multiple locations, the Sample Graph view in the GUI may not draw correctly. For tracking more than one heartbeat (such as graphics and audio), please make make use of the User heartbeats. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8bd43485bd61fe04afe4b789a73b98c4afef7944828c76c000d169f2d4b0d5ac2"></a>Heartbeats_Main&#160;</td><td class="fielddoc"><p>Main is used to determine framerate. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8bd43485bd61fe04afe4b789a73b98c4ab3d52cfc664c4c0e55b7f51c8ecad73b"></a>Heartbeats_Vsync&#160;</td><td class="fielddoc"><p>Used internally, do not use directly. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8bd43485bd61fe04afe4b789a73b98c4a2dc8161b04b066ce18ac6754acb66dbf"></a>Heartbeats_User1&#160;</td><td class="fielddoc"><p>&#160; </p>
</td></tr>
<tr><td class="fieldname"><a id="a8bd43485bd61fe04afe4b789a73b98c4a6d6a6b0e6d3487cf31c081eb110f1ce1"></a>Heartbeats_User2&#160;</td><td class="fielddoc"><p>&#160; </p>
</td></tr>
<tr><td class="fieldname"><a id="a8bd43485bd61fe04afe4b789a73b98c4ad7308fffcc8e7e09d2b833ddd288383f"></a>Heartbeats_User3&#160;</td><td class="fielddoc"><p>&#160; </p>
</td></tr>
<tr><td class="fieldname"><a id="a8bd43485bd61fe04afe4b789a73b98c4a5d48523379e8d9d7515cc2065ccf32f4"></a>Heartbeats_User4&#160;</td><td class="fielddoc"><p>&#160; </p>
</td></tr>
<tr><td class="fieldname"><a id="a8bd43485bd61fe04afe4b789a73b98c4ad9d0e91d666822171df43fbb579b2bea"></a>Heartbeats_User5&#160;</td><td class="fielddoc"><p>&#160; </p>
</td></tr>
<tr><td class="fieldname"><a id="a8bd43485bd61fe04afe4b789a73b98c4a55fa4c1ddce7c775c3621314504dfa56"></a>Heartbeats_User6&#160;</td><td class="fielddoc"><p>&#160; </p>
</td></tr>
<tr><td class="fieldname"><a id="a8bd43485bd61fe04afe4b789a73b98c4a66cd421aa21cbc15b344f8fbc8f097a4"></a>Heartbeats_User7&#160;</td><td class="fielddoc"><p>&#160; </p>
</td></tr>
<tr><td class="fieldname"><a id="a8bd43485bd61fe04afe4b789a73b98c4a7a64993a78bdc2843c9c621e90d190e2"></a>Heartbeats_User8&#160;</td><td class="fielddoc"><p>&#160; </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1fd4585e5e75647e1cb20bb264f58f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd4585e5e75647e1cb20bb264f58f6e">&#9670;&nbsp;</a></span>Initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::profiler::Initialize </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the profiler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBuffer</td><td>A memory buffer for the profiler to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size of the memory buffer passed in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The process completed as expected.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_null_argument.html">nn::profiler::ResultNullArgument</a> One of the arguments was NULL.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_invalid_argument.html">nn::profiler::ResultInvalidArgument</a> One of the arguments was invalid.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_memory_allocation_failure.html">nn::profiler::ResultMemoryAllocationFailure</a> There was a problem either setting up the memory to use or allocating from the memory space.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_already_done.html">nn::profiler::ResultAlreadyDone</a> The profiler is already initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
This initializes the profiler, setting up and running multiple threads. There is one thread that control main profiler thread. Two threads, Send and Receive, for communicating with the PC. One thread per core that your application runs on.</p>
<p>If it is planned to capture NVN graphics information, be sure to call <a class="el" href="namespacenn_1_1profiler.html#a907804e676e1b37f7e1b62f5bace7992" title="Installs graphics hooks needed to enable the GPU Trace feature.">nn::profiler::InstallGraphicsHooks</a> before calling this function.</p>
<dl class="section note"><dt>Note</dt><dd>The profiler needs HTCS in order to function correctly. If HTCS is not already initialized, it will internally call <a class="el" href="namespacenn_1_1htcs.html#a7eab72b8843a2a9ff763f52b78da680e" title="Initializes the host-target socket communication.">nn::htcs::Initialize()</a>. If your application also uses HTCS, be sure to initialize it before calling the profiler.</dd>
<dd>
When using Graphics Tracing, this function should be called before any NVN queues are created. If this is not possible, it will be necessary to call <a class="el" href="namespacenn_1_1profiler.html#a7eba4662b2649f42259c6604171e7425" title="Set the estimated max number of draws, debug pushes, and compute operations per frame for this queue.">nn::profiler::SetQueuePerFrameOperationEstimates</a> for each queue.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenn_1_1profiler.html#a686d62f2d301026212a1f2f19d32e5e0" title="Shuts down the profiler.">Finalize</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_simple_framework_8cpp-example.html#a33">NvnSimple/NvnSimpleSharedLib/SimpleFramework.cpp</a>, <a class="el" href="_profiler_simple_2_profiler_simple_8cpp-example.html#a11">ProfilerSimple/ProfilerSimple.cpp</a>, and <a class="el" href="_profiler_thread_state_2_profiler_thread_state_8cpp-example.html#a8">ProfilerThreadState/ProfilerThreadState.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a686d62f2d301026212a1f2f19d32e5e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a686d62f2d301026212a1f2f19d32e5e0">&#9670;&nbsp;</a></span>Finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::profiler::Finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shuts down the profiler. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The process completed as expected.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
Shuts down all of the profiler threads and releases the resources allocated.</p>
<dl class="section note"><dt>Note</dt><dd>If the profiler initialized HTCS communication, this will finalize it. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_simple_framework_8cpp-example.html#a34">NvnSimple/NvnSimpleSharedLib/SimpleFramework.cpp</a>, <a class="el" href="_profiler_simple_2_profiler_simple_8cpp-example.html#a18">ProfilerSimple/ProfilerSimple.cpp</a>, and <a class="el" href="_profiler_thread_state_2_profiler_thread_state_8cpp-example.html#a22">ProfilerThreadState/ProfilerThreadState.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a6188c8828050128b52e98bf5fc953b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6188c8828050128b52e98bf5fc953b05">&#9670;&nbsp;</a></span>GetProfilerStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1profiler.html#a7fea676000503cc4f931e0d93d51f5f2">ProfilerStatus</a> nn::profiler::GetProfilerStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current status of the profiler. </p>
<dl class="section return"><dt>Returns</dt><dd>The profiler's current status.</dd></dl>
<p> <b>Details</b> <br  />
 Gets the current status of the profiler. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_profiler_simple_2_profiler_simple_8cpp-example.html#a0">ProfilerSimple/ProfilerSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a907804e676e1b37f7e1b62f5bace7992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a907804e676e1b37f7e1b62f5bace7992">&#9670;&nbsp;</a></span>InstallGraphicsHooks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::profiler::InstallGraphicsHooks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Installs graphics hooks needed to enable the GPU Trace feature. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The process completed as expected.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_invalid_profiler_status.html">nn::profiler::ResultInvalidProfilerStatus</a> Attempted to install the hooks after <a class="el" href="namespacenn_1_1profiler.html#a1fd4585e5e75647e1cb20bb264f58f6e" title="Initializes the profiler.">nn::profiler::Initialize</a> was called.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_already_done.html">nn::profiler::ResultAlreadyDone</a> Graphics hooks have already been installed.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
Installs the hooks for adding graphics performance data to a profile session.</p>
<p>This function must be called before the NVN function pointers are loaded using nvnLoadCProcs or nvnLoadCPPProcs. Additionally, this function must be called before calling <a class="el" href="namespacenn_1_1profiler.html#a1fd4585e5e75647e1cb20bb264f58f6e" title="Initializes the profiler.">nn::profiler::Initialize</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Make sure <a class="el" href="namespacenn_1_1profiler.html#a1fd4585e5e75647e1cb20bb264f58f6e" title="Initializes the profiler.">nn::profiler::Initialize</a> is called before any queues are created. </dd></dl>

</div>
</div>
<a id="a7eba4662b2649f42259c6604171e7425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eba4662b2649f42259c6604171e7425">&#9670;&nbsp;</a></span>SetQueuePerFrameOperationEstimates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::profiler::SetQueuePerFrameOperationEstimates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numDraws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numDebugPushes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numComputeDispatches</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the estimated max number of draws, debug pushes, and compute operations per frame for this queue. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The process completed as expected.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_null_argument.html">nn::profiler::ResultNullArgument</a> The queue argument was set to null.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_invalid_argument.html">nn::profiler::ResultInvalidArgument</a> One of the arguments was set to an invalid value.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>The queue for which to set the estimates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numDraws</td><td>The maximum number draw calls per frame. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numDebugPushes</td><td>The maximum number of debug group pushes per frame. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numComputeDispatches</td><td>The maximum number of compute operations per frame.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
Sets up sizes of internal data structure for recording of graphics performance data.</p>
<p>The following are the default values used for each queue:</p><ul>
<li><em>numDraws</em> : 8000</li>
<li><em>numDebugPushes</em> : 50</li>
<li><em>numComputeDispatches</em> : 128</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This function is meant to be called once per program run, not once per frame. </dd></dl>

</div>
</div>
<a id="a1e84c62cb23cbe2b7c628448d1a2fd2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e84c62cb23cbe2b7c628448d1a2fd2a">&#9670;&nbsp;</a></span>EnableFileSystemTrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::profiler::EnableFileSystemTrace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the profiler library to gather information on file system activities. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The process completed as expected.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_already_done.html">nn::profiler::ResultAlreadyDone</a> File System Tracing is already enabled.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
Performs setup and integration with the <a class="el" href="namespacenn_1_1fs.html" title="Namespace for the file system library.">nn::fs</a> APIs to allow for capturing of file system calls while profiling.</p>
<p>This function should be called before any calls to <a class="el" href="namespacenn_1_1fs.html" title="Namespace for the file system library.">nn::fs</a> APIs. Failure to do so will result in the profiler being unable to gather information. It is especially important that it is called before any nn::fs::Mount* function is called.</p>
<p>It is safe to call this function before calling <a class="el" href="namespacenn_1_1profiler.html#a1fd4585e5e75647e1cb20bb264f58f6e" title="Initializes the profiler.">nn::profiler::Initialize</a>. </p>

</div>
</div>
<a id="a90d857e6e5c2a9fe9f8938f1dd8d1829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d857e6e5c2a9fe9f8938f1dd8d1829">&#9670;&nbsp;</a></span>RecordHeartbeat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::profiler::RecordHeartbeat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1profiler.html#a8bd43485bd61fe04afe4b789a73b98c4">Heartbeats</a>&#160;</td>
          <td class="paramname"><em>heartbeat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Records the specified heartbeat into the current core's buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heartbeat</td><td>The heartbeat to record.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The heartbeat was recorded into the buffer.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_invalid_argument.html">nn::profiler::ResultInvalidArgument</a> The heartbeat passed in was invalid.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_skipped_record.html">nn::profiler::ResultSkippedRecord</a> The heartbeat was not recorded into the buffer.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
This function records a heartbeat in a game or application. The most common form of heartbeat is the main update loop and has been provided a preexisting name. Other heartbeat types are provided as User heartbeat numbers. The heartbeat will be recorded as long as profiling is active.</p>
<p>The default heartbeat that the profiler GUI looks for is <a class="el" href="namespacenn_1_1profiler.html#a8bd43485bd61fe04afe4b789a73b98c4afef7944828c76c000d169f2d4b0d5ac2">Heartbeats_Main</a>. This is used to determine frames in the profiler - which will result in a framerate graph and visual markings showing the frames. The call to set this up should look like: </p><div class="fragment"><div class="line"><a class="code" href="namespacenn_1_1profiler.html#a90d857e6e5c2a9fe9f8938f1dd8d1829">nn::profiler::RecordHeartbeat</a>(<a class="code" href="namespacenn_1_1profiler.html#a8bd43485bd61fe04afe4b789a73b98c4afef7944828c76c000d169f2d4b0d5ac2">nn::profiler::Heartbeats_Main</a>);</div>
<div class="ttc" id="anamespacenn_1_1profiler_html_a8bd43485bd61fe04afe4b789a73b98c4afef7944828c76c000d169f2d4b0d5ac2"><div class="ttname"><a href="namespacenn_1_1profiler.html#a8bd43485bd61fe04afe4b789a73b98c4afef7944828c76c000d169f2d4b0d5ac2">nn::profiler::Heartbeats_Main</a></div><div class="ttdeci">@ Heartbeats_Main</div><div class="ttdoc">Main is used to determine framerate.</div><div class="ttdef"><b>Definition:</b> profiler_Types.h:59</div></div>
<div class="ttc" id="anamespacenn_1_1profiler_html_a90d857e6e5c2a9fe9f8938f1dd8d1829"><div class="ttname"><a href="namespacenn_1_1profiler.html#a90d857e6e5c2a9fe9f8938f1dd8d1829">nn::profiler::RecordHeartbeat</a></div><div class="ttdeci">nn::Result RecordHeartbeat(Heartbeats heartbeat) NN_NOEXCEPT</div><div class="ttdoc">Records the specified heartbeat into the current core's buffer.</div></div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_simple_framework_8cpp-example.html#a39">NvnSimple/NvnSimpleSharedLib/SimpleFramework.cpp</a>, <a class="el" href="_profiler_simple_2_profiler_simple_8cpp-example.html#a13">ProfilerSimple/ProfilerSimple.cpp</a>, and <a class="el" href="_profiler_thread_state_2_profiler_thread_state_8cpp-example.html#a16">ProfilerThreadState/ProfilerThreadState.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a9bcc0188395af2ef6c82c28465693edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bcc0188395af2ef6c82c28465693edd">&#9670;&nbsp;</a></span>RecordData() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::profiler::RecordData </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Records the specified data into the current core's buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>A numeric ID used to identify the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The 64-bit integer to record.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The data was recorded into the buffer.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_skipped_record.html">nn::profiler::ResultSkippedRecord</a> The data was not recorded into the buffer.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
This function records a single 64-bit integer value into the profile data. The data is identified on the PC using the provided integer. The data will only be recorded if profiling is active.</p>
<p>An example call to this function is: </p><div class="fragment"><div class="line">uint64_t data = 12345uL;</div>
<div class="line"><a class="code" href="namespacenn_1_1profiler.html#a9bcc0188395af2ef6c82c28465693edd">nn::profiler::RecordData</a>(10, data);</div>
<div class="ttc" id="anamespacenn_1_1profiler_html_a9bcc0188395af2ef6c82c28465693edd"><div class="ttname"><a href="namespacenn_1_1profiler.html#a9bcc0188395af2ef6c82c28465693edd">nn::profiler::RecordData</a></div><div class="ttdeci">nn::Result RecordData(uint64_t id, uint64_t data) NN_NOEXCEPT</div><div class="ttdoc">Records the specified data into the current core's buffer.</div></div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_profiler_simple_2_profiler_simple_8cpp-example.html#a5">ProfilerSimple/ProfilerSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a62432871a7838a486dbc49039b5f36f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62432871a7838a486dbc49039b5f36f1">&#9670;&nbsp;</a></span>RecordData() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::profiler::RecordData </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Records the specified data into the current core's buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>A string used to identify the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The 64-bit integer to record.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The data was recorded into the buffer.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_skipped_record.html">nn::profiler::ResultSkippedRecord</a> The data was not recorded into the buffer.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_null_argument.html">nn::profiler::ResultNullArgument</a> One of the arguments was NULL.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
This function records a single 64-bit integer value into the profile data. The data is identified on the PC using the provided string. The data will only be recorded if profiling is active.</p>
<p>Strings up to 254 bytes may be used; longer strings will be truncated. The string used must be null-terminated. An internal buffer stores the strings provided, so dynamically created strings may be used. If that internal buffer becomes full, the GUI will use the value UINT64_MAX as the ID.</p>
<p>An example call to this function is: </p><div class="fragment"><div class="line"><a class="code" href="namespacenn_1_1profiler.html#a9bcc0188395af2ef6c82c28465693edd">nn::profiler::RecordData</a>(<span class="stringliteral">&quot;Example Data&quot;</span>, <span class="keyword">static_cast&lt;</span>uint64_t<span class="keyword">&gt;</span>(12345));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="acd5d7e05cde34898be489559a05d7f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5d7e05cde34898be489559a05d7f1a">&#9670;&nbsp;</a></span>RecordData() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::profiler::RecordData </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Records the specified data into the current core's buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>A numeric ID used to identify the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The 64-bit floating-point to record.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The data was recorded into the buffer.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_skipped_record.html">nn::profiler::ResultSkippedRecord</a> The data was not recorded into the buffer.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
This function records a single 64-bit floating-point value into the profile data. The data is identified on the PC using the provided integer. The data will only be recorded if profiling is active.</p>
<p>An example call to this function is: </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> data = 123.45;</div>
<div class="line"><a class="code" href="namespacenn_1_1profiler.html#a9bcc0188395af2ef6c82c28465693edd">nn::profiler::RecordData</a>(10, data);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab473595809a769ba153c7d7ad0ac172c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab473595809a769ba153c7d7ad0ac172c">&#9670;&nbsp;</a></span>RecordData() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::profiler::RecordData </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Records the specified data into the current core's buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>A string used to identify the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The 64-bit floating-point to record.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The data was recorded into the buffer.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_skipped_record.html">nn::profiler::ResultSkippedRecord</a> The data was not recorded into the buffer.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_null_argument.html">nn::profiler::ResultNullArgument</a> One of the arguments was NULL.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
This function records a single 64-bit floating-point value into the profile data. The data is identified on the PC using the provided string. The data will only be recorded if profiling is active.</p>
<p>Strings up to 254 bytes may be used; longer strings will be truncated. The string used must be null-terminated. An internal buffer stores the strings provided, so dynamically created strings may be used. If that internal buffer becomes full, the GUI will use the value UINT64_MAX as the ID.</p>
<p>An example call to this function is: </p><div class="fragment"><div class="line"><a class="code" href="namespacenn_1_1profiler.html#a9bcc0188395af2ef6c82c28465693edd">nn::profiler::RecordData</a>(<span class="stringliteral">&quot;Example Data&quot;</span>, 123.45);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9312a49b962cc1cee3ee4a2be86c21fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9312a49b962cc1cee3ee4a2be86c21fa">&#9670;&nbsp;</a></span>RegisterAudioRenderer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::profiler::RegisterAudioRenderer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html">nn::audio::AudioRendererParameter</a> &amp;&#160;</td>
          <td class="paramname"><em>parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">nn::audio::AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1profiler.html#a4399ee2dc75cd00ff55e1b7cb984753d">AudioPerformanceMetricsControl</a>&#160;</td>
          <td class="paramname"><em>control</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the Audio Trace feature by registering an AudioRenderer with the profiler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter</td><td>The audio parameter used when creating the config. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pConfig</td><td>The configuration used when initializing audio renderer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">control</td><td>A value indicating who will control the performance buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The process completed as expected.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_invalid_profiler_status.html">nn::profiler::ResultInvalidProfilerStatus</a> Attempted to call the function while profiling was in progress.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_invalid_argument.html">nn::profiler::ResultInvalidArgument</a> One of the arguments passed into the function was invalid.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>parameter.performanceFrameCount</em> is &gt; 0 </dd>
<dd>
<em>pConfig</em> is not null and initialized</dd></dl>
<p> <b>Details</b> <br  />
Registers an AudioRenderer to collect audio performance data from when profiling. Call this function after calling <a class="el" href="namespacenn_1_1audio.html#a0fc7ed6656395abc8493f13abe2d04d0" title="Initialize AudioRendererConfig.">nn::audio::InitializeAudioRendererConfig()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>When <em>control</em> is set to AudioPerformanceMetricsControl_Automatic, it is recommended to call this function before <a class="el" href="namespacenn_1_1profiler.html#a1fd4585e5e75647e1cb20bb264f58f6e" title="Initializes the profiler.">nn::profiler::Initialize()</a>. With this ordering, it is possible for the profiler library to adjust its heap size to ensure space is available for the audio performance buffers based on the values provided in <em>parameter</em>. Some space in the heap is currently available even if the call order is inverted, but it is possible that there will be insufficient memory. When <em>control</em> is AudioPerformanceMetricsControl_Manual, this memory allocation is not performed, so the ordering with <a class="el" href="namespacenn_1_1profiler.html#a1fd4585e5e75647e1cb20bb264f58f6e" title="Initializes the profiler.">nn::profiler::Initialize()</a> doesn't matter.</dd></dl>
<p>The profiler will hold onto the <a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">nn::audio::AudioRendererConfig</a> pointer. When <em>control</em> is set to AudioPerformanceMetricsControl_Automatic, the profiler will use this stored pointer to collect the performance data. When using AudioPerformanceMetricsControl_Manual, the pointer is never used.</p>
<p>Calling this function is required to enable the Audio Trace feature in the profiler. The <a class="el" href="namespacenn_1_1profiler.html#a1fd4585e5e75647e1cb20bb264f58f6e" title="Initializes the profiler.">nn::profiler::Initialize()</a> function must also be called to enable the feature.</p>
<p>It is recommended that <a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html#adc0048497f26f959223bdffa24ac4a53" title="The maximum number of audio frames for the accumulated performance information.">nn::audio::AudioRendererParameter.performanceFrameCount</a> be in the range [2, 5]. The value used results in a multiplicative increase to the memory requirements. If a value of 1 is set, it is likely that no Audio Trace data will be present in the final data. This is due to how frame data is recorded by the AudioRenderer performance API. Similarly, as long as <a class="el" href="namespacenn_1_1profiler.html#aaff43cb30e5803f4a44ce4f3a741c300" title="Informs the profiler that it is safe to record AudioRenderer performance metrics.">RecordAudioRendererPerformance()</a> is called each frame, there is less of a reason to use larger values as there will likely only be one frame's data to record. If you notice missing frames, try increasing the value to see if it improves the situation.</p>
<dl class="section note"><dt>Note</dt><dd>Internally, the profiler makes use of the AudioRenderer performance APIs. If you are using any other tools that make use of these functions, such as Spy, be sure to specify AudioPerformanceMetricsControl_Manual in the <em>control</em> argument.</dd>
<dd>
Only a single AudioRenderer is currently supported, do not attempt to register more than one.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenn_1_1profiler.html#aaff43cb30e5803f4a44ce4f3a741c300" title="Informs the profiler that it is safe to record AudioRenderer performance metrics.">RecordAudioRendererPerformance(nn::audio::AudioRendererConfig*)</a>, RecordAudioRendererPerformance(nn::audio::AudioRendererConfig*, const void*) </dd></dl>

</div>
</div>
<a id="aaff43cb30e5803f4a44ce4f3a741c300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff43cb30e5803f4a44ce4f3a741c300">&#9670;&nbsp;</a></span>RecordAudioRendererPerformance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::RecordAudioRendererPerformance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">nn::audio::AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Informs the profiler that it is safe to record AudioRenderer performance metrics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pConfig</td><td>The configuration used when initializing audio renderer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>pConfig</em> is not null and has been passed into <a class="el" href="namespacenn_1_1profiler.html#a9312a49b962cc1cee3ee4a2be86c21fa" title="Enables the Audio Trace feature by registering an AudioRenderer with the profiler.">RegisterAudioRenderer()</a>.</dd></dl>
<p> <b>Details</b> <br  />
Call this function in your AudioRenderer loop after <a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a>. This informs the profiler that it is safe to work with the performance frame buffers.</p>
<dl class="section note"><dt>Note</dt><dd>It is safe to call this function before <a class="el" href="namespacenn_1_1profiler.html#a1fd4585e5e75647e1cb20bb264f58f6e" title="Initializes the profiler.">nn::profiler::Initialize()</a> is called.</dd>
<dd>
This version of the function should only be used when AudioPerformanceMetricsControl_Automatic is specified in <a class="el" href="namespacenn_1_1profiler.html#a9312a49b962cc1cee3ee4a2be86c21fa" title="Enables the Audio Trace feature by registering an AudioRenderer with the profiler.">RegisterAudioRenderer()</a>. When using AudioPerformanceMetricsControl_Manual, RecordAudioRendererPerformance(nn::audio::AudioRendererConfig*, const void*) must be called instead. </dd></dl>

</div>
</div>
<a id="a708429086a2791606968f789489e9c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708429086a2791606968f789489e9c74">&#9670;&nbsp;</a></span>RecordAudioRendererPerformance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::RecordAudioRendererPerformance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">nn::audio::AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pPerformanceBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>performanceBufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Informs the profiler that it is safe to record AudioRenderer performance metrics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pConfig</td><td>The configuration used when initializing audio renderer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pPerformanceBuffer</td><td>The performance frame buffer to pull data from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">performanceBufferSize</td><td>The size of <em>pPerformanceBuffer</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>pConfig</em> is not null and has been passed into <a class="el" href="namespacenn_1_1profiler.html#a9312a49b962cc1cee3ee4a2be86c21fa" title="Enables the Audio Trace feature by registering an AudioRenderer with the profiler.">RegisterAudioRenderer()</a>.</dd></dl>
<p> <b>Details</b> <br  />
This version of the function can be used with either <em>AudioPerformanceMetricsControl_Manual</em> or <em>AudioPerformanceMetricsControl_Automatic</em>. When the control is set to Manual, pass in the buffer your application is using to this function. If control is set to Automatic, the value passed in to <em>pPerformanceBuffer</em> is ignored.</p>
<p>Call this function in your AudioRenderer loop after <a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a>. This informs the profiler that it is safe to work with the performance frame buffers.</p>
<dl class="section note"><dt>Note</dt><dd>It is safe to call this function before <a class="el" href="namespacenn_1_1profiler.html#a1fd4585e5e75647e1cb20bb264f58f6e" title="Initializes the profiler.">nn::profiler::Initialize()</a> is called. </dd></dl>

</div>
</div>
<a id="a8eb1e473760f5461603df15a9d497ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb1e473760f5461603df15a9d497ce4">&#9670;&nbsp;</a></span>SetAudioRendererTimeLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::SetAudioRendererTimeLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">nn::audio::AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>limitPercent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inform the profiler about changes to the audio renderer rendering time limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pConfig</td><td>The configuration used when initializing audio renderer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">limitPercent</td><td>The renderering time limit for the audio renderer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>pConfig</em> is not null and has been passed into <a class="el" href="namespacenn_1_1profiler.html#a9312a49b962cc1cee3ee4a2be86c21fa" title="Enables the Audio Trace feature by registering an AudioRenderer with the profiler.">RegisterAudioRenderer()</a>. </dd>
<dd>
<em>limitPercent</em> &gt;= 0 &amp;&amp; <em>limitPercent</em> &lt;= 100</dd></dl>
<p> <b>Details</b> <br  />
Call this function after calling <a class="el" href="namespacenn_1_1audio.html#ab54fa3067e8bd1916ece8ed7384dd11f" title="Sets the upper limit on the rendering time allocated to the audio renderer.">nn::audio::SetAudioRendererRenderingTimeLimit()</a>. When a time limit is set, the profiler can show the set value in relation to the renderering time spent in the AudioRenderer.</p>
<dl class="section note"><dt>Note</dt><dd>It is safe to call this function before <a class="el" href="namespacenn_1_1profiler.html#a1fd4585e5e75647e1cb20bb264f58f6e" title="Initializes the profiler.">nn::profiler::Initialize()</a> is called. </dd></dl>

</div>
</div>
<a id="acd040cd20c33f208f315e60bdd0df745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd040cd20c33f208f315e60bdd0df745">&#9670;&nbsp;</a></span>EnterCodeBlock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::profiler::EnterCodeBlock </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Records a code block entry in the profile data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>An integer to denote this code block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The value was recorded into the buffer.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_skipped_record.html">nn::profiler::ResultSkippedRecord</a> The data was not recorded into the buffer.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
This function stores a code block entry marker into the profile data. The identifier provided is the integer that will appear in the profiler GUI to denote this specific code block.</p>
<p>An example call to this function is: </p><div class="fragment"><div class="line"><a class="code" href="namespacenn_1_1profiler.html#acd040cd20c33f208f315e60bdd0df745">nn::profiler::EnterCodeBlock</a>(10);</div>
<div class="ttc" id="anamespacenn_1_1profiler_html_acd040cd20c33f208f315e60bdd0df745"><div class="ttname"><a href="namespacenn_1_1profiler.html#acd040cd20c33f208f315e60bdd0df745">nn::profiler::EnterCodeBlock</a></div><div class="ttdeci">nn::Result EnterCodeBlock(uint64_t id) NN_NOEXCEPT</div><div class="ttdoc">Records a code block entry in the profile data.</div></div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_profiler_simple_2_profiler_simple_8cpp-example.html#a15">ProfilerSimple/ProfilerSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af2b1e434f5b815a86f8185b277df3d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b1e434f5b815a86f8185b277df3d1e">&#9670;&nbsp;</a></span>EnterCodeBlock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::profiler::EnterCodeBlock </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Records a code block entry in the profile data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>A string to denote this code block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The value was recorded into the buffer.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_skipped_record.html">nn::profiler::ResultSkippedRecord</a> The data was not recorded into the buffer.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_null_argument.html">nn::profiler::ResultNullArgument</a> One of the arguments was NULL.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
This function stores a code block entry marker into the profile data. The identifier provided is the string that will appear in the profiler GUI to denote this specific code block.</p>
<p>Strings up to 254 bytes may be used; longer strings will be truncated. The string used must be null-terminated. An internal buffer stores the strings provided, so dynamically created strings may be used. If that internal buffer becomes full, the GUI will use the value UINT64_MAX as the ID.</p>
<p>An example call to this function is: </p><div class="fragment"><div class="line"><a class="code" href="namespacenn_1_1profiler.html#acd040cd20c33f208f315e60bdd0df745">nn::profiler::EnterCodeBlock</a>(<span class="stringliteral">&quot;Example Code Block&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a40482ccaf3b2a56eb6e8e7aeddfebacb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40482ccaf3b2a56eb6e8e7aeddfebacb">&#9670;&nbsp;</a></span>ExitCodeBlock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::profiler::ExitCodeBlock </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Records a code block exit in the profile data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>An integer to denote this code block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The value was recorded into the buffer.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_skipped_record.html">nn::profiler::ResultSkippedRecord</a> The data was not recorded into the buffer.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
This function stores a code block exit marker into the profile data. The identifier provided is the integer that will appear in the profiler GUI to denote this specific code block.</p>
<p>An example call to this function is: </p><div class="fragment"><div class="line"><a class="code" href="namespacenn_1_1profiler.html#a40482ccaf3b2a56eb6e8e7aeddfebacb">nn::profiler::ExitCodeBlock</a>(10);</div>
<div class="ttc" id="anamespacenn_1_1profiler_html_a40482ccaf3b2a56eb6e8e7aeddfebacb"><div class="ttname"><a href="namespacenn_1_1profiler.html#a40482ccaf3b2a56eb6e8e7aeddfebacb">nn::profiler::ExitCodeBlock</a></div><div class="ttdeci">nn::Result ExitCodeBlock(uint64_t id) NN_NOEXCEPT</div><div class="ttdoc">Records a code block exit in the profile data.</div></div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_profiler_simple_2_profiler_simple_8cpp-example.html#a17">ProfilerSimple/ProfilerSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a550d2f8bd7556acffb35b270cf708109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a550d2f8bd7556acffb35b270cf708109">&#9670;&nbsp;</a></span>ExitCodeBlock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::profiler::ExitCodeBlock </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Records a code block exit in the profile data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>A string to denote this code block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The value was recorded into the buffer.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_skipped_record.html">nn::profiler::ResultSkippedRecord</a> The data was not recorded into the buffer.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_null_argument.html">nn::profiler::ResultNullArgument</a> One of the arguments was NULL.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
This function stores a code block exit marker into the profile data. The identifier provided is the string that will appear in the profiler GUI to denote this specific code block.</p>
<p>Strings up to 254 bytes may be used; longer strings will be truncated. The string used must be null-terminated. An internal buffer stores the strings provided, so dynamically created strings may be used. If that internal buffer becomes full, the GUI will use the value UINT64_MAX as the ID.</p>
<p>An example call to this function is: </p><div class="fragment"><div class="line"><a class="code" href="namespacenn_1_1profiler.html#a40482ccaf3b2a56eb6e8e7aeddfebacb">nn::profiler::ExitCodeBlock</a>(<span class="stringliteral">&quot;Example Code Block&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a600680a6479c8e9aac5fd83e9db32cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600680a6479c8e9aac5fd83e9db32cc6">&#9670;&nbsp;</a></span>PushCodeBlock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::profiler::PushCodeBlock </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Records a code block entry in the profile data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>An integer to denote this code block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The value was recorded into the buffer.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_skipped_record.html">nn::profiler::ResultSkippedRecord</a> The data was not recorded into the buffer.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
This function stores a code block entry marker into the profile data. The identifier provided is the integer that will appear in the profiler GUI to denote this specific code block.</p>
<p>A call to push a code block must be matched with a call to <a class="el" href="namespacenn_1_1profiler.html#a924cdef2a315b52be1fcc90627be9c09" title="Records a code block exit in the profile data.">nn::profiler::PopCodeBlock()</a>. Pushes and pops are tracked based on the thread from which the call was made.</p>
<dl class="section note"><dt>Note</dt><dd>It is not possible to call <a class="el" href="namespacenn_1_1profiler.html#a600680a6479c8e9aac5fd83e9db32cc6" title="Records a code block entry in the profile data.">nn::profiler::PushCodeBlock()</a> from one thread and <a class="el" href="namespacenn_1_1profiler.html#a924cdef2a315b52be1fcc90627be9c09" title="Records a code block exit in the profile data.">nn::profiler::PopCodeBlock()</a> from another.</dd></dl>
<p>An example call to this function is: </p><div class="fragment"><div class="line"><a class="code" href="namespacenn_1_1profiler.html#a600680a6479c8e9aac5fd83e9db32cc6">nn::profiler::PushCodeBlock</a>(10);</div>
<div class="line"><span class="comment">// timed code</span></div>
<div class="line"><a class="code" href="namespacenn_1_1profiler.html#a924cdef2a315b52be1fcc90627be9c09">nn::profiler::PopCodeBlock</a>();</div>
<div class="ttc" id="anamespacenn_1_1profiler_html_a600680a6479c8e9aac5fd83e9db32cc6"><div class="ttname"><a href="namespacenn_1_1profiler.html#a600680a6479c8e9aac5fd83e9db32cc6">nn::profiler::PushCodeBlock</a></div><div class="ttdeci">nn::Result PushCodeBlock(uint64_t id) NN_NOEXCEPT</div><div class="ttdoc">Records a code block entry in the profile data.</div></div>
<div class="ttc" id="anamespacenn_1_1profiler_html_a924cdef2a315b52be1fcc90627be9c09"><div class="ttname"><a href="namespacenn_1_1profiler.html#a924cdef2a315b52be1fcc90627be9c09">nn::profiler::PopCodeBlock</a></div><div class="ttdeci">nn::Result PopCodeBlock() NN_NOEXCEPT</div><div class="ttdoc">Records a code block exit in the profile data.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab089513cba1402e8d1b97c6732ba6188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab089513cba1402e8d1b97c6732ba6188">&#9670;&nbsp;</a></span>PushCodeBlock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::profiler::PushCodeBlock </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Records a code block entry in the profile data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>A string to denote this code block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The value was recorded into the buffer.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_skipped_record.html">nn::profiler::ResultSkippedRecord</a> The data was not recorded into the buffer.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_null_argument.html">nn::profiler::ResultNullArgument</a> One of the arguments was NULL.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
This function stores a code block entry marker into the profile data. The identifier provided is the string that will appear in the profiler GUI to denote this specific code block.</p>
<p>Strings up to 254 bytes may be used; longer strings will be truncated. The string used must be null-terminated. An internal buffer stores the strings provided, so dynamically created strings may be used. If that internal buffer becomes full, the GUI will use the value UINT64_MAX as the ID.</p>
<p>A call to push a code block must be matched with a call to <a class="el" href="namespacenn_1_1profiler.html#a924cdef2a315b52be1fcc90627be9c09" title="Records a code block exit in the profile data.">nn::profiler::PopCodeBlock()</a>. Pushes and pops are tracked based on the thread from which the call was made.</p>
<dl class="section note"><dt>Note</dt><dd>It is not possible to call <a class="el" href="namespacenn_1_1profiler.html#a600680a6479c8e9aac5fd83e9db32cc6" title="Records a code block entry in the profile data.">nn::profiler::PushCodeBlock()</a> from one thread and <a class="el" href="namespacenn_1_1profiler.html#a924cdef2a315b52be1fcc90627be9c09" title="Records a code block exit in the profile data.">nn::profiler::PopCodeBlock()</a> from another.</dd></dl>
<p>An example call to this function is: </p><div class="fragment"><div class="line"><a class="code" href="namespacenn_1_1profiler.html#a600680a6479c8e9aac5fd83e9db32cc6">nn::profiler::PushCodeBlock</a>(<span class="stringliteral">&quot;Example Code Block&quot;</span>);</div>
<div class="line"><span class="comment">// timed code</span></div>
<div class="line"><a class="code" href="namespacenn_1_1profiler.html#a924cdef2a315b52be1fcc90627be9c09">nn::profiler::PopCodeBlock</a>();</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a924cdef2a315b52be1fcc90627be9c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a924cdef2a315b52be1fcc90627be9c09">&#9670;&nbsp;</a></span>PopCodeBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::profiler::PopCodeBlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Records a code block exit in the profile data. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The value was recorded into the buffer.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_skipped_record.html">nn::profiler::ResultSkippedRecord</a> The data was not recorded into the buffer.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_null_argument.html">nn::profiler::ResultNullArgument</a> One of the arguments was NULL.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
This function stores a code block exit marker into the profile data. The identifier provided is the string that will appear in the profiler GUI to denote this specific code block.</p>
<p>A call to pop a code block must be matched with a call to <a class="el" href="namespacenn_1_1profiler.html#a600680a6479c8e9aac5fd83e9db32cc6" title="Records a code block entry in the profile data.">nn::profiler::PushCodeBlock()</a>. Pushes and pops are tracked based on the thread from which the call was made.</p>
<dl class="section note"><dt>Note</dt><dd>It is not possible to call <a class="el" href="namespacenn_1_1profiler.html#a600680a6479c8e9aac5fd83e9db32cc6" title="Records a code block entry in the profile data.">nn::profiler::PushCodeBlock()</a> from one thread and <a class="el" href="namespacenn_1_1profiler.html#a924cdef2a315b52be1fcc90627be9c09" title="Records a code block exit in the profile data.">nn::profiler::PopCodeBlock()</a> from another.</dd></dl>
<p>An example call to this function is: </p><div class="fragment"><div class="line"><a class="code" href="namespacenn_1_1profiler.html#a600680a6479c8e9aac5fd83e9db32cc6">nn::profiler::PushCodeBlock</a>(<span class="stringliteral">&quot;Example Code Block&quot;</span>);</div>
<div class="line"><span class="comment">// timed code</span></div>
<div class="line"><a class="code" href="namespacenn_1_1profiler.html#a924cdef2a315b52be1fcc90627be9c09">nn::profiler::PopCodeBlock</a>();</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad48cc14a1e10f1c84d4b59aacbaaecdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad48cc14a1e10f1c84d4b59aacbaaecdc">&#9670;&nbsp;</a></span>SetProfileSettings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::profiler::SetProfileSettings </td>
          <td>(</td>
          <td class="paramtype">nn::Bit64&#160;</td>
          <td class="paramname"><em>affinityMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1profiler.html#a08c2f344cd2732c68fd3e207df06ab83">PerformanceCounterGroup</a>&#160;</td>
          <td class="paramname"><em>performanceCounterGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1profiler.html#a88514e8daffe2e3bea8cf6ba79922572">SampleRate</a>&#160;</td>
          <td class="paramname"><em>sampleRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets profile settings for runtime based control. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">affinityMask</td><td>The cores that should be recorded when profiling. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies which flags should be used for profiling. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">performanceCounterGroup</td><td>The performance counter group to use while profiling. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleRate</td><td>The requested sample rate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> Settings were set successfully.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_not_initialized.html">nn::profiler::ResultNotInitialized</a> Settings cannot be set as the profiler has not been initialized.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_invalid_profiler_status.html">nn::profiler::ResultInvalidProfilerStatus</a> The settings cannot be changed as a profile is being taken.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_invalid_argument.html">nn::profiler::ResultInvalidArgument</a> One of the arguments passed in contained an invalid value.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_could_not_attach.html">nn::profiler::ResultCouldNotAttach</a> Flags_OutOfProcessProfiling was set but the profiler could not attach to the application.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_feature_unavailable.html">nn::profiler::ResultFeatureUnavailable</a> A flag was specified where all the steps to enable the feature have not been performed.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
This sets the settings that will be used when profiling is started by calling <a class="el" href="namespacenn_1_1profiler.html#a4b190188b23662a7ab1848053c530da9" title="Start recording a profile.">nn::profiler::StartProfiling()</a>.</p>
<p>The values passed in <code>affinityMask</code> should be a bitwise OR of values from <a class="el" href="namespacenn_1_1profiler.html#ae600326a48953627efa2c28ad9762f84" title="Defines the set of cores that data can be collected on.">nn::profiler::Cores</a>.</p>
<p>The values passed in <code>flags</code> should be a bitwise OR of values from <a class="el" href="namespacenn_1_1profiler.html#a494bd9ad9ee12e0f68bb64263cc416f7" title="Flags used to control how the profiler works.">nn::profiler::Flags</a>.</p>
<p>Only a single <a class="el" href="namespacenn_1_1profiler.html#a08c2f344cd2732c68fd3e207df06ab83" title="The performance counters that can be used in profiling.">nn::profiler::PerformanceCounterGroup</a> can be specified for recording. The default is <a class="el" href="namespacenn_1_1profiler.html#a08c2f344cd2732c68fd3e207df06ab83a5e455e51df4ea90c128ef9076f05a5c8" title="No performance counter data is recorded.">nn::profiler::PerformanceCounterGroup_Disabled</a>. The value set in <code>performanceCounterGroup</code> is only used when <a class="el" href="namespacenn_1_1profiler.html#a494bd9ad9ee12e0f68bb64263cc416f7aecf478c090f9ba12d973bb091ee7a095" title="When a sample is taken, also record performance counter data.">nn::profiler::Flags_PerformanceCounters</a> is set in <code>flags</code>.</p>
<p>When <a class="el" href="namespacenn_1_1profiler.html#a1fd4585e5e75647e1cb20bb264f58f6e" title="Initializes the profiler.">nn::profiler::Initialize()</a> is called the settings are set to their default values. This defaults are the same as the default settings when launching the GUI. To reset the settings back to default, make the following call: </p><div class="fragment"><div class="line"><a class="code" href="namespacenn_1_1profiler.html#ad48cc14a1e10f1c84d4b59aacbaaecdc">nn::profiler::SetProfileSettings</a>(</div>
<div class="line">    <a class="code" href="namespacenn_1_1profiler.html#ae600326a48953627efa2c28ad9762f84aac74f924100217bb262d658f646b8057">nn::profiler::Cores_All</a>,</div>
<div class="line">    <a class="code" href="namespacenn_1_1profiler.html#a494bd9ad9ee12e0f68bb64263cc416f7afaddb8c59d9ea3f2f062d407a209a378">nn::profiler::Flags_Callstack</a>,</div>
<div class="line">    <a class="code" href="namespacenn_1_1profiler.html#a08c2f344cd2732c68fd3e207df06ab83a5e455e51df4ea90c128ef9076f05a5c8">nn::profiler::PerformanceCounterGroup_Disabled</a>,</div>
<div class="line">    <a class="code" href="namespacenn_1_1profiler.html#a88514e8daffe2e3bea8cf6ba79922572aac1d0c6564ca981e37970b44da0585e3">nn::profiler::SampleRate_ByTime100x</a>);</div>
<div class="ttc" id="anamespacenn_1_1profiler_html_a08c2f344cd2732c68fd3e207df06ab83a5e455e51df4ea90c128ef9076f05a5c8"><div class="ttname"><a href="namespacenn_1_1profiler.html#a08c2f344cd2732c68fd3e207df06ab83a5e455e51df4ea90c128ef9076f05a5c8">nn::profiler::PerformanceCounterGroup_Disabled</a></div><div class="ttdeci">@ PerformanceCounterGroup_Disabled</div><div class="ttdoc">No performance counter data is recorded.</div><div class="ttdef"><b>Definition:</b> profiler_Control.h:171</div></div>
<div class="ttc" id="anamespacenn_1_1profiler_html_a494bd9ad9ee12e0f68bb64263cc416f7afaddb8c59d9ea3f2f062d407a209a378"><div class="ttname"><a href="namespacenn_1_1profiler.html#a494bd9ad9ee12e0f68bb64263cc416f7afaddb8c59d9ea3f2f062d407a209a378">nn::profiler::Flags_Callstack</a></div><div class="ttdeci">@ Flags_Callstack</div><div class="ttdoc">Callstacks will be recorded.</div><div class="ttdef"><b>Definition:</b> profiler_Control.h:84</div></div>
<div class="ttc" id="anamespacenn_1_1profiler_html_a88514e8daffe2e3bea8cf6ba79922572aac1d0c6564ca981e37970b44da0585e3"><div class="ttname"><a href="namespacenn_1_1profiler.html#a88514e8daffe2e3bea8cf6ba79922572aac1d0c6564ca981e37970b44da0585e3">nn::profiler::SampleRate_ByTime100x</a></div><div class="ttdeci">@ SampleRate_ByTime100x</div><div class="ttdoc">Sample 100 times every 60Hz frame.</div><div class="ttdef"><b>Definition:</b> profiler_Control.h:211</div></div>
<div class="ttc" id="anamespacenn_1_1profiler_html_ad48cc14a1e10f1c84d4b59aacbaaecdc"><div class="ttname"><a href="namespacenn_1_1profiler.html#ad48cc14a1e10f1c84d4b59aacbaaecdc">nn::profiler::SetProfileSettings</a></div><div class="ttdeci">nn::Result SetProfileSettings(nn::Bit64 affinityMask, int flags, PerformanceCounterGroup performanceCounterGroup, SampleRate sampleRate) NN_NOEXCEPT</div><div class="ttdoc">Sets profile settings for runtime based control.</div></div>
<div class="ttc" id="anamespacenn_1_1profiler_html_ae600326a48953627efa2c28ad9762f84aac74f924100217bb262d658f646b8057"><div class="ttname"><a href="namespacenn_1_1profiler.html#ae600326a48953627efa2c28ad9762f84aac74f924100217bb262d658f646b8057">nn::profiler::Cores_All</a></div><div class="ttdeci">@ Cores_All</div><div class="ttdoc">All three cores.</div><div class="ttdef"><b>Definition:</b> profiler_Control.h:42</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a4b190188b23662a7ab1848053c530da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b190188b23662a7ab1848053c530da9">&#9670;&nbsp;</a></span>StartProfiling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::profiler::StartProfiling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start recording a profile. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> Profiling has started.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_not_initialized.html">nn::profiler::ResultNotInitialized</a> <a class="el" href="namespacenn_1_1profiler.html#a1fd4585e5e75647e1cb20bb264f58f6e" title="Initializes the profiler.">nn::profiler::Initialize()</a> has not been called.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_already_done.html">nn::profiler::ResultAlreadyDone</a> Profiler status is not <a class="el" href="namespacenn_1_1profiler.html#a7fea676000503cc4f931e0d93d51f5f2a43d093c36283760e4102c94f54458c09" title="The profiler is ready to take a profile.">nn::profiler::ProfilerStatus_Active</a>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
This function starts profiling from the application. The settings used for profiling will be whatever were the last ones set, either from code or from the GUI. To set the settings from code, call <a class="el" href="namespacenn_1_1profiler.html#ad48cc14a1e10f1c84d4b59aacbaaecdc" title="Sets profile settings for runtime based control.">nn::profiler::SetProfileSettings()</a>. Profiling will continue until the internal buffer is full, <a class="el" href="namespacenn_1_1profiler.html#a03155333e1717521240f2de797d1c5ca" title="Stop recording a profile.">nn::profiler::StopProfiling()</a> is called or the <em>Stop</em> button is pressed in the GUI.</p>
<p>If <a class="el" href="namespacenn_1_1profiler.html#a4b190188b23662a7ab1848053c530da9" title="Start recording a profile.">nn::profiler::StartProfiling()</a> is called before any settings have been explicitly set the default settings will be used. See <a class="el" href="namespacenn_1_1profiler.html#ad48cc14a1e10f1c84d4b59aacbaaecdc" title="Sets profile settings for runtime based control.">nn::profiler::SetProfileSettings()</a> for a description of the default settings.</p>
<dl class="section note"><dt>Note</dt><dd>For profile data to be transferred to the PC, the GUI will need to be Synced. The latest profile data will be cached so if the PC connects later, the most recent profile data is sent. </dd></dl>

</div>
</div>
<a id="a03155333e1717521240f2de797d1c5ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03155333e1717521240f2de797d1c5ca">&#9670;&nbsp;</a></span>StopProfiling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::profiler::StopProfiling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop recording a profile. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> Profiling has been stopped.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_not_initialized.html">nn::profiler::ResultNotInitialized</a> <a class="el" href="namespacenn_1_1profiler.html#a1fd4585e5e75647e1cb20bb264f58f6e" title="Initializes the profiler.">nn::profiler::Initialize()</a> has not been called.</li>
<li><a class="el" href="classnn_1_1profiler_1_1_result_already_done.html">nn::profiler::ResultAlreadyDone</a> Profiler status is not <a class="el" href="namespacenn_1_1profiler.html#a7fea676000503cc4f931e0d93d51f5f2aee16006157055d994c7694213ee3be42" title="The profiler is currently taking a profile.">nn::profiler::ProfilerStatus_Profiling</a>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
This function causes profiling to stop and the captured profile data to be sent back to the PC. Profiling can also be stopped if the internal buffers completely fill or if the <em>Stop</em> button in the GUI is pressed.</p>
<dl class="section note"><dt>Note</dt><dd>For profile data to be transferred to the PC, the GUI will need to be Synced. The latest profile data will be cached so if the PC connects later, the most recent profile data is sent. </dd></dl>

</div>
</div>
<a id="a3bf0a5b9753b627089dfcc0d0493d64c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf0a5b9753b627089dfcc0d0493d64c">&#9670;&nbsp;</a></span>RecordHeapRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::RecordHeapRange </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>startAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>endAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>heapName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Records a heap name to be used for a given range of addresses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startAddress</td><td>A pointer to the memory location to associate as the start of the heap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endAddress</td><td>A pointer to the memory location to associate as the end of the heap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heapName</td><td>The name to associate with the heap memory range.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
This function informs the memory tracking system of the profiler of a name to associate with addresses that live within a given address range. When one of the Track functions is called, it will search through the list of registered heaps in reverse order to find the associated name of the heap.</p>
<p>This function may be called before the profiler is initialized.</p>
<p>This function is not thread-safe. Care should be used when calling this function to ensure that multiple threads do not attempt to record heap information at the same time.</p>
<dl class="section note"><dt>Note</dt><dd>With the current implementation, only 5 heaps can be registered until the profiler is initialized. After initialization, Heap Inspector currently supports a maximum of 256 heaps.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">nn::lmem::HeapHandle</a> exampleHeap =</div>
<div class="line">    <a class="code" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc">nn::lmem::CreateExpHeap</a>(startAddress, size, <a class="code" href="namespacenn_1_1lmem.html#a5200a4ef197dbd700f31a3111eacf5b2a30c3b2cd8b36e40049c5c88b7c47a45f">nn::lmem::CreationOption_NoOption</a>);</div>
<div class="line"><span class="keywordtype">void</span>* endAddress = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(startAddress) + size;</div>
<div class="line"><a class="code" href="namespacenn_1_1profiler.html#a3bf0a5b9753b627089dfcc0d0493d64c">nn::profiler::RecordHeapRange</a>(startAddress, endAddress, <span class="stringliteral">&quot;Example&quot;</span>);</div>
<div class="ttc" id="anamespacenn_1_1lmem_html_a3d46d370c3b53aed4a127962761ed0fc"><div class="ttname"><a href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc">nn::lmem::CreateExpHeap</a></div><div class="ttdeci">HeapHandle CreateExpHeap(void *startAddress, size_t size, int option) NN_NOEXCEPT</div><div class="ttdoc">Creates an expanded heap.</div></div>
<div class="ttc" id="anamespacenn_1_1lmem_html_a5200a4ef197dbd700f31a3111eacf5b2a30c3b2cd8b36e40049c5c88b7c47a45f"><div class="ttname"><a href="namespacenn_1_1lmem.html#a5200a4ef197dbd700f31a3111eacf5b2a30c3b2cd8b36e40049c5c88b7c47a45f">nn::lmem::CreationOption_NoOption</a></div><div class="ttdeci">@ CreationOption_NoOption</div><div class="ttdoc">No option specified.</div><div class="ttdef"><b>Definition:</b> lmem_Common.h:59</div></div>
<div class="ttc" id="anamespacenn_1_1lmem_html_ab893a05f9834a881447ea604c7d60400"><div class="ttname"><a href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">nn::lmem::HeapHandle</a></div><div class="ttdeci">struct detail::HeapHead * HeapHandle</div><div class="ttdoc">The heap common handle.</div><div class="ttdef"><b>Definition:</b> lmem_Common.h:105</div></div>
<div class="ttc" id="anamespacenn_1_1profiler_html_a3bf0a5b9753b627089dfcc0d0493d64c"><div class="ttname"><a href="namespacenn_1_1profiler.html#a3bf0a5b9753b627089dfcc0d0493d64c">nn::profiler::RecordHeapRange</a></div><div class="ttdeci">void RecordHeapRange(void const *startAddress, void const *endAddress, char const *heapName) NN_NOEXCEPT</div><div class="ttdoc">Records a heap name to be used for a given range of addresses.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9bfe8af38e4660d5d09a8c9fca2235d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bfe8af38e4660d5d09a8c9fca2235d5">&#9670;&nbsp;</a></span>TrackMalloc() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackMalloc </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to malloc has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was returned by the call to malloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size/amount of memory that was requested to be allocated.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
See <a class="el" href="namespacenn_1_1profiler.html#a05f77f933adf4b05ece605efe0695754" title="Record that a call to malloc has occurred.">nn::profiler::TrackMalloc(void const*, size_t, char const*, int)</a>. </p>

</div>
</div>
<a id="a386470fad7781bac5a2b963d143b6450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386470fad7781bac5a2b963d143b6450">&#9670;&nbsp;</a></span>TrackMalloc() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackMalloc </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>systemName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to malloc has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was returned by the call to malloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size/amount of memory that was requested to be allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemName</td><td>The name of a system to attribute to the call.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
See <a class="el" href="namespacenn_1_1profiler.html#a05f77f933adf4b05ece605efe0695754" title="Record that a call to malloc has occurred.">nn::profiler::TrackMalloc(void const*, size_t, char const*, int)</a>. </p>

</div>
</div>
<a id="a05f77f933adf4b05ece605efe0695754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f77f933adf4b05ece605efe0695754">&#9670;&nbsp;</a></span>TrackMalloc() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackMalloc </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>systemName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to malloc has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was returned by the call to malloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size/amount of memory that was requested to be allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemName</td><td>The name of a system to attribute to the call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>The alignment requirement of the allocation.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
This function informs the memory tracking system that a call to malloc has occurred. When the PC memory tracking tool is connected, this will result in information on memory allocation being sent to the PC. As such, calls to this function may be slow.</p>
<p>This function may be called before the profiler is initialized.</p>
<p>This function is thread-safe.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span>* MallocMemory(<span class="keywordtype">size_t</span> size)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span>* memory = malloc(size);</div>
<div class="line">    <a class="code" href="namespacenn_1_1profiler.html#a9bfe8af38e4660d5d09a8c9fca2235d5">nn::profiler::TrackMalloc</a>(memory, size, <span class="stringliteral">&quot;Example&quot;</span>, 0);</div>
<div class="line">    <span class="keywordflow">return</span> memory;</div>
<div class="line">}</div>
<div class="ttc" id="anamespacenn_1_1profiler_html_a9bfe8af38e4660d5d09a8c9fca2235d5"><div class="ttname"><a href="namespacenn_1_1profiler.html#a9bfe8af38e4660d5d09a8c9fca2235d5">nn::profiler::TrackMalloc</a></div><div class="ttdeci">void TrackMalloc(void const *address, size_t size) NN_NOEXCEPT</div><div class="ttdoc">Record that a call to malloc has occurred.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1e26be5a4478b0d68a195e98a41972be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e26be5a4478b0d68a195e98a41972be">&#9670;&nbsp;</a></span>TrackCalloc() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackCalloc </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to calloc has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was returned by the call to calloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>The number of elements that were requested to be allocated by the call to calloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of each element.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
See <a class="el" href="namespacenn_1_1profiler.html#ae4413497f025f7969a6b0a2159b30318" title="Record that a call to calloc has occurred.">TrackCalloc(void const*, size_t, size_t, char const*, int)</a>. </p>

</div>
</div>
<a id="a8864c08a9d8dea42318f14d373501f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8864c08a9d8dea42318f14d373501f19">&#9670;&nbsp;</a></span>TrackCalloc() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackCalloc </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>systemName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to calloc has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was returned by the call to calloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>The number of elements that were requested to be allocated by the call to calloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of each element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemName</td><td>The name of a system to attribute to the call.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
See <a class="el" href="namespacenn_1_1profiler.html#ae4413497f025f7969a6b0a2159b30318" title="Record that a call to calloc has occurred.">TrackCalloc(void const*, size_t, size_t, char const*, int)</a>. </p>

</div>
</div>
<a id="ae4413497f025f7969a6b0a2159b30318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4413497f025f7969a6b0a2159b30318">&#9670;&nbsp;</a></span>TrackCalloc() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackCalloc </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>systemName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to calloc has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was returned by the call to calloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>The number of elements that were requested to be allocated by the call to calloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of each element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemName</td><td>The name of a system to attribute to the call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>The alignment requirement of the allocation.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
This function informs the memory tracking system that a call to calloc has occurred. When the PC memory tracking tool is connected, this will result in information on memory allocation being sent to the PC. As such, calls to this function may be slow.</p>
<p>This function may be called before the profiler is initialized.</p>
<p>This function is thread-safe.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span>* CallocMemory(<span class="keywordtype">size_t</span> num, <span class="keywordtype">size_t</span> size)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span>* memory = calloc(num, size);</div>
<div class="line">    <a class="code" href="namespacenn_1_1profiler.html#a1e26be5a4478b0d68a195e98a41972be">nn::profiler::TrackCalloc</a>(memory, num, size, <span class="stringliteral">&quot;Example&quot;</span>, 0);</div>
<div class="line">    <span class="keywordflow">return</span> memory;</div>
<div class="line">}</div>
<div class="ttc" id="anamespacenn_1_1profiler_html_a1e26be5a4478b0d68a195e98a41972be"><div class="ttname"><a href="namespacenn_1_1profiler.html#a1e26be5a4478b0d68a195e98a41972be">nn::profiler::TrackCalloc</a></div><div class="ttdeci">void TrackCalloc(void const *address, size_t num, size_t size) NN_NOEXCEPT</div><div class="ttdoc">Record that a call to calloc has occurred.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9a5fe5ac6184841e72de8c05a3cb6f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a5fe5ac6184841e72de8c05a3cb6f91">&#9670;&nbsp;</a></span>TrackRealloc() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackRealloc </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>oldAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to realloc has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">oldAddress</td><td>The original address of the allocation that was passed to realloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was returned by the call to realloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size, in bytes, of the memory requested.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
See <a class="el" href="namespacenn_1_1profiler.html#a2066520971eca6b78634a040a6a55e2c" title="Record that a call to realloc has occurred.">nn::profiler::TrackRealloc(void const*, void const*, size_t, char const*, int)</a>. </p>

</div>
</div>
<a id="ad6a480619bc9e15b4726433088e1cdd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a480619bc9e15b4726433088e1cdd3">&#9670;&nbsp;</a></span>TrackRealloc() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackRealloc </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>oldAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>systemName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to realloc has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">oldAddress</td><td>The original address of the allocation that was passed to realloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was returned by the call to realloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size, in bytes, of the memory requested. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemName</td><td>The name of a system to attribute to the call.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
See <a class="el" href="namespacenn_1_1profiler.html#a2066520971eca6b78634a040a6a55e2c" title="Record that a call to realloc has occurred.">nn::profiler::TrackRealloc(void const*, void const*, size_t, char const*, int)</a>. </p>

</div>
</div>
<a id="a2066520971eca6b78634a040a6a55e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2066520971eca6b78634a040a6a55e2c">&#9670;&nbsp;</a></span>TrackRealloc() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackRealloc </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>oldAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>systemName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to realloc has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">oldAddress</td><td>The original address of the allocation that was passed to realloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was returned by the call to realloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size, in bytes, of the memory requested. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemName</td><td>The name of a system to attribute to the call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>The alignment requirement of the allocation.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
This function informs the memory tracking system that a call to realloc has occurred. When the PC memory tracking tool is connected, this will result in information on memory allocation being sent to the PC. As such, calls to this function may be slow.</p>
<p>This function may be called before the profiler is initialized.</p>
<p>This function is thread-safe.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span>* ReallocMemory(<span class="keywordtype">void</span>* address, <span class="keywordtype">size_t</span> size)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span>* memory = realloc(address, size);</div>
<div class="line">    <a class="code" href="namespacenn_1_1profiler.html#a9a5fe5ac6184841e72de8c05a3cb6f91">nn::profiler::TrackRealloc</a>(address, memory, size, <span class="stringliteral">&quot;Example&quot;</span>, 0);</div>
<div class="line">    <span class="keywordflow">return</span> memory;</div>
<div class="line">}</div>
<div class="ttc" id="anamespacenn_1_1profiler_html_a9a5fe5ac6184841e72de8c05a3cb6f91"><div class="ttname"><a href="namespacenn_1_1profiler.html#a9a5fe5ac6184841e72de8c05a3cb6f91">nn::profiler::TrackRealloc</a></div><div class="ttdeci">void TrackRealloc(void const *oldAddress, void const *address, size_t size) NN_NOEXCEPT</div><div class="ttdoc">Record that a call to realloc has occurred.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad9c9804d8d9b83dcd77ef68856ae6b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c9804d8d9b83dcd77ef68856ae6b2f">&#9670;&nbsp;</a></span>TrackFree() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackFree </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to free has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was passed into the call to free.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
See <a class="el" href="namespacenn_1_1profiler.html#a0b3ef93ec17409afe2ecce193766a50d" title="Record that a call to free has occurred.">nn::profiler::TrackFree(void const*, char const*)</a>. </p>

</div>
</div>
<a id="a0b3ef93ec17409afe2ecce193766a50d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b3ef93ec17409afe2ecce193766a50d">&#9670;&nbsp;</a></span>TrackFree() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackFree </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>systemName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to free has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was passed into the call to free. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemName</td><td>The name of a system to attribute to the call.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
This function informs the memory tracking system that a call to free has occurred. When the PC memory tracking tool is connected, this will result in information on memory allocation being sent to the PC. As such, calls to this function may be slow.</p>
<p>This function may be called before the profiler is initialized.</p>
<p>This function is thread-safe.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> FreeMemory(<span class="keywordtype">void</span>* address)</div>
<div class="line">{</div>
<div class="line">    free(address);</div>
<div class="line">    <a class="code" href="namespacenn_1_1profiler.html#ad9c9804d8d9b83dcd77ef68856ae6b2f">nn::profiler::TrackFree</a>(address, <span class="stringliteral">&quot;Example&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="anamespacenn_1_1profiler_html_ad9c9804d8d9b83dcd77ef68856ae6b2f"><div class="ttname"><a href="namespacenn_1_1profiler.html#ad9c9804d8d9b83dcd77ef68856ae6b2f">nn::profiler::TrackFree</a></div><div class="ttdeci">void TrackFree(void const *address) NN_NOEXCEPT</div><div class="ttdoc">Record that a call to free has occurred.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad5c8d86f75c8e20a2a422eb4f46b6b84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c8d86f75c8e20a2a422eb4f46b6b84">&#9670;&nbsp;</a></span>TrackNew() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackNew </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to new has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was returned by the call to new. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size, in bytes, of the memory requested.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
See <a class="el" href="namespacenn_1_1profiler.html#aa317471e9629ec143a4657e0c3b1665d" title="Record that a call to new has occurred.">nn::profiler::TrackNew(void const*, size_t, char const*, int, bool)</a>. </p>

</div>
</div>
<a id="afe3efb8b90b93543737c558674105fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe3efb8b90b93543737c558674105fa6">&#9670;&nbsp;</a></span>TrackNew() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackNew </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>systemName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to new has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was returned by the call to new. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size, in bytes, of the memory requested. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemName</td><td>The name of a system to attribute to the call.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
See <a class="el" href="namespacenn_1_1profiler.html#aa317471e9629ec143a4657e0c3b1665d" title="Record that a call to new has occurred.">nn::profiler::TrackNew(void const*, size_t, char const*, int, bool)</a>. </p>

</div>
</div>
<a id="ae301f90d0c7ed1db7165fca52cc99270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae301f90d0c7ed1db7165fca52cc99270">&#9670;&nbsp;</a></span>TrackNew() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackNew </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>systemName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to new has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was returned by the call to new. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size, in bytes, of the memory requested. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemName</td><td>The name of a system to attribute to the call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>The alignment requirement of the allocation.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
See <a class="el" href="namespacenn_1_1profiler.html#aa317471e9629ec143a4657e0c3b1665d" title="Record that a call to new has occurred.">nn::profiler::TrackNew(void const*, size_t, char const*, int, bool)</a>. </p>

</div>
</div>
<a id="ae26fb8437ca8cc2670127919900fc0f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26fb8437ca8cc2670127919900fc0f3">&#9670;&nbsp;</a></span>TrackNew() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackNew </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>systemName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to new has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was returned by the call to new. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size, in bytes, of the memory requested. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemName</td><td>The name of a system to attribute to the call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isVector</td><td>Specifies which variant of new was called. If false, new; otherwise, new[].</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
See <a class="el" href="namespacenn_1_1profiler.html#aa317471e9629ec143a4657e0c3b1665d" title="Record that a call to new has occurred.">nn::profiler::TrackNew(void const*, size_t, char const*, int, bool)</a>. </p>

</div>
</div>
<a id="aa317471e9629ec143a4657e0c3b1665d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa317471e9629ec143a4657e0c3b1665d">&#9670;&nbsp;</a></span>TrackNew() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackNew </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>systemName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to new has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was returned by the call to new. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size, in bytes, of the memory requested. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemName</td><td>The name of a system to attribute to the call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>The alignment requirement of the allocation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isVector</td><td>Specifies which variant of new was called. If false, new; otherwise, new[].</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
This function informs the memory tracking system that a call to new has occurred. When the PC memory tracking tool is connected, this will result in information on memory allocation being sent to the PC. As such, calls to this function may be slow.</p>
<p>This function may be called before the profiler is initialized.</p>
<p>This function is thread-safe.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span>* NewMemory(<span class="keywordtype">size_t</span> size)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span>* memory = <span class="keyword">new</span> <span class="keywordtype">char</span>[size];</div>
<div class="line">    <a class="code" href="namespacenn_1_1profiler.html#ad5c8d86f75c8e20a2a422eb4f46b6b84">nn::profiler::TrackNew</a>(memory, size, <span class="stringliteral">&quot;Example&quot;</span>, 0, <span class="keyword">true</span>);</div>
<div class="line">    <span class="keywordflow">return</span> memory;</div>
<div class="line">}</div>
<div class="ttc" id="anamespacenn_1_1profiler_html_ad5c8d86f75c8e20a2a422eb4f46b6b84"><div class="ttname"><a href="namespacenn_1_1profiler.html#ad5c8d86f75c8e20a2a422eb4f46b6b84">nn::profiler::TrackNew</a></div><div class="ttdeci">void TrackNew(void const *address, size_t size) NN_NOEXCEPT</div><div class="ttdoc">Record that a call to new has occurred.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa879772ab7830431310aa39fafed3033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa879772ab7830431310aa39fafed3033">&#9670;&nbsp;</a></span>TrackDelete() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackDelete </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to delete has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was passed int the call to delete.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
See <a class="el" href="namespacenn_1_1profiler.html#a88c20b36512995567c400ac954a93f19" title="Record that a call to delete has occurred.">nn::profiler::TrackDelete(void const*, char const*, bool)</a>. </p>

</div>
</div>
<a id="a7bb1f323af3ff13f604ba0b492a9ba39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb1f323af3ff13f604ba0b492a9ba39">&#9670;&nbsp;</a></span>TrackDelete() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackDelete </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>systemName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to delete has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was passed int the call to delete. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemName</td><td>The name of a system to attribute to the call.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
See <a class="el" href="namespacenn_1_1profiler.html#a88c20b36512995567c400ac954a93f19" title="Record that a call to delete has occurred.">nn::profiler::TrackDelete(void const*, char const*, bool)</a>. </p>

</div>
</div>
<a id="a88c20b36512995567c400ac954a93f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c20b36512995567c400ac954a93f19">&#9670;&nbsp;</a></span>TrackDelete() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackDelete </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>systemName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to delete has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was passed int the call to delete. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemName</td><td>The name of a system to attribute to the call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isVector</td><td>Specifies which variant of delete was called. If false, delete; otherwise, delete[].</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
This function informs the memory tracking system that a call to delete has occurred. When the PC memory tracking tool is connected, this will result in information on memory allocation being sent to the PC. As such, calls to this function may be slow.</p>
<p>This function may be called before the profiler is initialized.</p>
<p>This function is thread-safe.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> DeleteMemory(<span class="keywordtype">void</span>* address)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">delete</span> [] <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(address);</div>
<div class="line">    <a class="code" href="namespacenn_1_1profiler.html#aa879772ab7830431310aa39fafed3033">nn::profiler::TrackDelete</a>(address, <span class="stringliteral">&quot;Example&quot;</span>, <span class="keyword">true</span>);</div>
<div class="line">}</div>
<div class="ttc" id="anamespacenn_1_1profiler_html_aa879772ab7830431310aa39fafed3033"><div class="ttname"><a href="namespacenn_1_1profiler.html#aa879772ab7830431310aa39fafed3033">nn::profiler::TrackDelete</a></div><div class="ttdeci">void TrackDelete(void const *address) NN_NOEXCEPT</div><div class="ttdoc">Record that a call to delete has occurred.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="abf33f5085549b0184a827cf6a902def7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf33f5085549b0184a827cf6a902def7">&#9670;&nbsp;</a></span>GenerateNextTrackingId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> nn::profiler::GenerateNextTrackingId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates tracking information for a specific call to Track* functions. </p>
<dl class="section return"><dt>Returns</dt><dd>A one-time use object used to denote a specific heap operation.</dd></dl>
<p> <b>Details</b> <br  />
Tracking ids provide increased accuracy for timing and ordering of memory function calls.</p>
<p>The TrackingId that is obtained from this function is a single-use object. The intention is that the object be passed into the next Track* function that is called.</p>
<p>This function <em>must</em> be paired with a call to a Track* function which takes a TrackingId as its first parameter. Failure to do so may lead to improper operation of the memory tracking API. This may include a deadlock and/or application crash.</p>
<p>This function may be called before the profiler is initialized.</p>
<p>This function is thread-safe.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span>* MallocMemory(<span class="keywordtype">size_t</span> size)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">nn::profiler::TrackingId</a> <span class="keyword">const</span> <span class="keywordtype">id</span> = <a class="code" href="namespacenn_1_1profiler.html#abf33f5085549b0184a827cf6a902def7">nn::profiler::GenerateNextTrackingId</a>();</div>
<div class="line">    <span class="keywordtype">void</span>* memory = malloc(size);</div>
<div class="line">    <a class="code" href="namespacenn_1_1profiler.html#a9bfe8af38e4660d5d09a8c9fca2235d5">nn::profiler::TrackMalloc</a>(<span class="keywordtype">id</span>, memory, size, <span class="stringliteral">&quot;Example&quot;</span>, 0);</div>
<div class="line">    <span class="keywordflow">return</span> memory;</div>
<div class="line">}</div>
<div class="ttc" id="anamespacenn_1_1profiler_html_a3f33fb75d3e0480ff9694565fbc1f421"><div class="ttname"><a href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">nn::profiler::TrackingId</a></div><div class="ttdeci">uintptr_t TrackingId</div><div class="ttdoc">Type definition of a tracking id.</div><div class="ttdef"><b>Definition:</b> profiler_Memory.h:38</div></div>
<div class="ttc" id="anamespacenn_1_1profiler_html_abf33f5085549b0184a827cf6a902def7"><div class="ttname"><a href="namespacenn_1_1profiler.html#abf33f5085549b0184a827cf6a902def7">nn::profiler::GenerateNextTrackingId</a></div><div class="ttdeci">TrackingId GenerateNextTrackingId() NN_NOEXCEPT</div><div class="ttdoc">Generates tracking information for a specific call to Track* functions.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a70fbafbd6cf9c09fbc2629af278c77d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70fbafbd6cf9c09fbc2629af278c77d1">&#9670;&nbsp;</a></span>TrackMalloc() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackMalloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to malloc has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The id to associate with this tracking information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was returned by the call to malloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size/amount of memory that was requested to be allocated.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
See <a class="el" href="namespacenn_1_1profiler.html#a71ed55d4a2bc608c57227e6221f7b856" title="Record that a call to malloc has occurred.">nn::profiler::TrackMalloc(TrackingId const&amp;, void const*, size_t, char const*, int)</a>. </p>

</div>
</div>
<a id="aa69d91e1c97014ba96993db2700e1fbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa69d91e1c97014ba96993db2700e1fbd">&#9670;&nbsp;</a></span>TrackMalloc() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackMalloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>systemName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to malloc has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The id to associate with this tracking information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was returned by the call to malloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size/amount of memory that was requested to be allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemName</td><td>The name of a system to attribute to the call.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
See <a class="el" href="namespacenn_1_1profiler.html#a71ed55d4a2bc608c57227e6221f7b856" title="Record that a call to malloc has occurred.">nn::profiler::TrackMalloc(TrackingId const&amp;, void const*, size_t, char const*, int)</a>. </p>

</div>
</div>
<a id="a71ed55d4a2bc608c57227e6221f7b856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ed55d4a2bc608c57227e6221f7b856">&#9670;&nbsp;</a></span>TrackMalloc() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackMalloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>systemName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to malloc has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The id to associate with this tracking information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was returned by the call to malloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size/amount of memory that was requested to be allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemName</td><td>The name of a system to attribute to the call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>The alignment requirement of the allocation.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
This function informs the memory tracking system that a call to malloc has occurred. When the PC memory tracking tool is connected, this will result in information on memory allocation being sent to the PC. As such, calls to this function may be slow.</p>
<p>This function call must be paired with a call to <a class="el" href="namespacenn_1_1profiler.html#abf33f5085549b0184a827cf6a902def7" title="Generates tracking information for a specific call to Track* functions.">GenerateNextTrackingId()</a>. Failure to do so may lead to improper operation of the memory tracking API. This may include a deadlock and/or application crash.</p>
<p>This function may be called before the profiler is initialized.</p>
<p>This function is thread-safe.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span>* MallocMemory(<span class="keywordtype">size_t</span> size)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">nn::profiler::TrackingId</a> <span class="keyword">const</span> <span class="keywordtype">id</span> = <a class="code" href="namespacenn_1_1profiler.html#abf33f5085549b0184a827cf6a902def7">nn::profiler::GenerateNextTrackingId</a>();</div>
<div class="line">    <span class="keywordtype">void</span>* memory = malloc(size);</div>
<div class="line">    <a class="code" href="namespacenn_1_1profiler.html#a9bfe8af38e4660d5d09a8c9fca2235d5">nn::profiler::TrackMalloc</a>(<span class="keywordtype">id</span>, memory, size, <span class="stringliteral">&quot;Example&quot;</span>, 0);</div>
<div class="line">    <span class="keywordflow">return</span> memory;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac1c41fcc6fed61a4e72c2fa7348b1bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c41fcc6fed61a4e72c2fa7348b1bd1">&#9670;&nbsp;</a></span>TrackCalloc() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackCalloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to calloc has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The id to associate with this tracking information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was returned by the call to calloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>The number of elements that were requested to be allocated by the call to calloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of each element.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
See <a class="el" href="namespacenn_1_1profiler.html#a64e142abaea2e0649e18bb7fac8cad15" title="Record that a call to calloc has occurred.">nn::profiler::TrackCalloc(TrackingId const&amp;, void const*, size_t, size_t, char const*, int)</a>. </p>

</div>
</div>
<a id="a317bfa9b36a0d6bc5225549f2ea34e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a317bfa9b36a0d6bc5225549f2ea34e70">&#9670;&nbsp;</a></span>TrackCalloc() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackCalloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>systemName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to calloc has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The id to associate with this tracking information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was returned by the call to calloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>The number of elements that were requested to be allocated by the call to calloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of each element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemName</td><td>The name of a system to attribute to the call.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
See <a class="el" href="namespacenn_1_1profiler.html#a64e142abaea2e0649e18bb7fac8cad15" title="Record that a call to calloc has occurred.">nn::profiler::TrackCalloc(TrackingId const&amp;, void const*, size_t, size_t, char const*, int)</a>. </p>

</div>
</div>
<a id="a64e142abaea2e0649e18bb7fac8cad15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e142abaea2e0649e18bb7fac8cad15">&#9670;&nbsp;</a></span>TrackCalloc() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackCalloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>systemName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to calloc has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The id to associate with this tracking information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was returned by the call to calloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>The number of elements that were requested to be allocated by the call to calloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of each element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemName</td><td>The name of a system to attribute to the call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>The alignment requirement of the allocation.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
This function informs the memory tracking system that a call to calloc has occurred. When the PC memory tracking tool is connected, this will result in information on memory allocation being sent to the PC. As such, calls to this function may be slow.</p>
<p>This function call must be paired with a call to <a class="el" href="namespacenn_1_1profiler.html#abf33f5085549b0184a827cf6a902def7" title="Generates tracking information for a specific call to Track* functions.">GenerateNextTrackingId()</a>. Failure to do so may lead to improper operation of the memory tracking API. This may include a deadlock and/or application crash.</p>
<p>This function may be called before the profiler is initialized.</p>
<p>This function is thread-safe.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span>* CallocMemory(<span class="keywordtype">size_t</span> num, <span class="keywordtype">size_t</span> size)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">nn::profiler::TrackingId</a> <span class="keyword">const</span> <span class="keywordtype">id</span> = <a class="code" href="namespacenn_1_1profiler.html#abf33f5085549b0184a827cf6a902def7">nn::profiler::GenerateNextTrackingId</a>();</div>
<div class="line">    <span class="keywordtype">void</span>* memory = calloc(num, size);</div>
<div class="line">    <a class="code" href="namespacenn_1_1profiler.html#a1e26be5a4478b0d68a195e98a41972be">nn::profiler::TrackCalloc</a>(<span class="keywordtype">id</span>, memory, num, size, <span class="stringliteral">&quot;Example&quot;</span>, 0);</div>
<div class="line">    <span class="keywordflow">return</span> memory;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae8ac7c2d6d79eac32b2eec77ec4e3d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ac7c2d6d79eac32b2eec77ec4e3d8f">&#9670;&nbsp;</a></span>TrackRealloc() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackRealloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>oldAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to realloc has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The id to associate with this tracking information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oldAddress</td><td>The original address of the allocation that was passed to realloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was returned by the call to realloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size, in bytes, of the memory requested.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
See <a class="el" href="namespacenn_1_1profiler.html#a03c193ffd767e9dfdf3ab129b1738a81" title="Record that a call to realloc has occurred.">nn::profiler::TrackRealloc(TrackingId const&amp;, void const*, void const*, size_t, char const*, int)</a>. </p>

</div>
</div>
<a id="a1066aeac58c1d2ebe478cfcfa7580bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1066aeac58c1d2ebe478cfcfa7580bd5">&#9670;&nbsp;</a></span>TrackRealloc() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackRealloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>oldAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>systemName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to realloc has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The id to associate with this tracking information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oldAddress</td><td>The original address of the allocation that was passed to realloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was returned by the call to realloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size, in bytes, of the memory requested. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemName</td><td>The name of a system to attribute to the call.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
See <a class="el" href="namespacenn_1_1profiler.html#a03c193ffd767e9dfdf3ab129b1738a81" title="Record that a call to realloc has occurred.">nn::profiler::TrackRealloc(TrackingId const&amp;, void const*, void const*, size_t, char const*, int)</a>. </p>

</div>
</div>
<a id="a03c193ffd767e9dfdf3ab129b1738a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c193ffd767e9dfdf3ab129b1738a81">&#9670;&nbsp;</a></span>TrackRealloc() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackRealloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>oldAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>systemName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to realloc has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The id to associate with this tracking information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oldAddress</td><td>The original address of the allocation that was passed to realloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was returned by the call to realloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size, in bytes, of the memory requested. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemName</td><td>The name of a system to attribute to the call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>The alignment requirement of the allocation.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
This function informs the memory tracking system that a call to realloc has occurred. When the PC memory tracking tool is connected, this will result in information on memory allocation being sent to the PC. As such, calls to this function may be slow.</p>
<p>This function call must be paired with a call to <a class="el" href="namespacenn_1_1profiler.html#abf33f5085549b0184a827cf6a902def7" title="Generates tracking information for a specific call to Track* functions.">GenerateNextTrackingId()</a>. Failure to do so may lead to improper operation of the memory tracking API. This may include a deadlock and/or application crash.</p>
<p>This function may be called before the profiler is initialized.</p>
<p>This function is thread-safe.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span>* ReallocMemory(<span class="keywordtype">void</span>* address, <span class="keywordtype">size_t</span> size)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">nn::profiler::TrackingId</a> <span class="keyword">const</span> <span class="keywordtype">id</span> = <a class="code" href="namespacenn_1_1profiler.html#abf33f5085549b0184a827cf6a902def7">nn::profiler::GenerateNextTrackingId</a>();</div>
<div class="line">    <span class="keywordtype">void</span>* memory = realloc(address, size);</div>
<div class="line">    <a class="code" href="namespacenn_1_1profiler.html#a9a5fe5ac6184841e72de8c05a3cb6f91">nn::profiler::TrackRealloc</a>(<span class="keywordtype">id</span>, address, memory, size, <span class="stringliteral">&quot;Example&quot;</span>, 0);</div>
<div class="line">    <span class="keywordflow">return</span> memory;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a60bdc5d99fd0eb045c23efc9a7c1590f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60bdc5d99fd0eb045c23efc9a7c1590f">&#9670;&nbsp;</a></span>TrackFree() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to free has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The id to associate with this tracking information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was passed into the call to free.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
See <a class="el" href="namespacenn_1_1profiler.html#aaf389407e06a908483b004d09e417923" title="Record that a call to free has occurred.">nn::profiler::TrackFree(TrackingId const&amp;, void const*, char const*)</a>. </p>

</div>
</div>
<a id="aaf389407e06a908483b004d09e417923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf389407e06a908483b004d09e417923">&#9670;&nbsp;</a></span>TrackFree() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>systemName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to free has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The id to associate with this tracking information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was passed into the call to free. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemName</td><td>The name of a system to attribute to the call.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
This function informs the memory tracking system that a call to free has occurred. When the PC memory tracking tool is connected, this will result in information on memory allocation being sent to the PC. As such, calls to this function may be slow.</p>
<p>This function call must be paired with a call to <a class="el" href="namespacenn_1_1profiler.html#abf33f5085549b0184a827cf6a902def7" title="Generates tracking information for a specific call to Track* functions.">GenerateNextTrackingId()</a>. Failure to do so may lead to improper operation of the memory tracking API. This may include a deadlock and/or application crash.</p>
<p>This function may be called before the profiler is initialized.</p>
<p>This function is thread-safe.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> FreeMemory(<span class="keywordtype">void</span>* address)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">nn::profiler::TrackingId</a> <span class="keyword">const</span> <span class="keywordtype">id</span> = <a class="code" href="namespacenn_1_1profiler.html#abf33f5085549b0184a827cf6a902def7">nn::profiler::GenerateNextTrackingId</a>();</div>
<div class="line">    free(address);</div>
<div class="line">    <a class="code" href="namespacenn_1_1profiler.html#ad9c9804d8d9b83dcd77ef68856ae6b2f">nn::profiler::TrackFree</a>(<span class="keywordtype">id</span>, address, <span class="stringliteral">&quot;Example&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aaf4e25fff994339d493473a30b84b92e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf4e25fff994339d493473a30b84b92e">&#9670;&nbsp;</a></span>TrackNew() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackNew </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to new has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The id to associate with this tracking information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was returned by the call to new. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size, in bytes, of the memory requested.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
See <a class="el" href="namespacenn_1_1profiler.html#aeb5bcf375daf8362b57df034556555ae" title="Record that a call to new has occurred.">nn::profiler::TrackNew(TrackingId const&amp;, void const*, size_t, char const*, int, bool)</a>. </p>

</div>
</div>
<a id="ab76c3b7e171f41142e98e30d583bcf55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab76c3b7e171f41142e98e30d583bcf55">&#9670;&nbsp;</a></span>TrackNew() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackNew </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>systemName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to new has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The id to associate with this tracking information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was returned by the call to new. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size, in bytes, of the memory requested. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemName</td><td>The name of a system to attribute to the call.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
See <a class="el" href="namespacenn_1_1profiler.html#aeb5bcf375daf8362b57df034556555ae" title="Record that a call to new has occurred.">nn::profiler::TrackNew(TrackingId const&amp;, void const*, size_t, char const*, int, bool)</a>. </p>

</div>
</div>
<a id="a5b9fda43b70a36a60560d88ca0ad02d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b9fda43b70a36a60560d88ca0ad02d8">&#9670;&nbsp;</a></span>TrackNew() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackNew </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>systemName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to new has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The id to associate with this tracking information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was returned by the call to new. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size, in bytes, of the memory requested. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemName</td><td>The name of a system to attribute to the call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>The alignment requirement of the allocation.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
See <a class="el" href="namespacenn_1_1profiler.html#aeb5bcf375daf8362b57df034556555ae" title="Record that a call to new has occurred.">nn::profiler::TrackNew(TrackingId const&amp;, void const*, size_t, char const*, int, bool)</a>. </p>

</div>
</div>
<a id="a1a84631afe077b0ed1ea6e8b0e645955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a84631afe077b0ed1ea6e8b0e645955">&#9670;&nbsp;</a></span>TrackNew() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackNew </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>systemName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to new has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The id to associate with this tracking information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was returned by the call to new. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size, in bytes, of the memory requested. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemName</td><td>The name of a system to attribute to the call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isVector</td><td>Specifies which variant of new was called. If false, new; otherwise, new[].</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
See <a class="el" href="namespacenn_1_1profiler.html#aeb5bcf375daf8362b57df034556555ae" title="Record that a call to new has occurred.">nn::profiler::TrackNew(TrackingId const&amp;, void const*, size_t, char const*, int, bool)</a>. </p>

</div>
</div>
<a id="aeb5bcf375daf8362b57df034556555ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb5bcf375daf8362b57df034556555ae">&#9670;&nbsp;</a></span>TrackNew() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackNew </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>systemName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to new has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The id to associate with this tracking information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was returned by the call to new. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size, in bytes, of the memory requested. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemName</td><td>The name of a system to attribute to the call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>The alignment requirement of the allocation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isVector</td><td>Specifies which variant of new was called. If false, new; otherwise, new[].</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
This function informs the memory tracking system that a call to new has occurred. When the PC memory tracking tool is connected, this will result in information on memory allocation being sent to the PC. As such, calls to this function may be slow.</p>
<p>This function call must be paired with a call to <a class="el" href="namespacenn_1_1profiler.html#abf33f5085549b0184a827cf6a902def7" title="Generates tracking information for a specific call to Track* functions.">GenerateNextTrackingId()</a>. Failure to do so may lead to improper operation of the memory tracking API. This may include a deadlock and/or application crash.</p>
<p>This function may be called before the profiler is initialized.</p>
<p>This function is thread-safe.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span>* NewMemory(<span class="keywordtype">size_t</span> size)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">nn::profiler::TrackingId</a> <span class="keyword">const</span> <span class="keywordtype">id</span> = <a class="code" href="namespacenn_1_1profiler.html#abf33f5085549b0184a827cf6a902def7">nn::profiler::GenerateNextTrackingId</a>();</div>
<div class="line">    <span class="keywordtype">void</span>* memory = <span class="keyword">new</span> <span class="keywordtype">char</span>[size];</div>
<div class="line">    <a class="code" href="namespacenn_1_1profiler.html#ad5c8d86f75c8e20a2a422eb4f46b6b84">nn::profiler::TrackNew</a>(<span class="keywordtype">id</span>, memory, size, <span class="stringliteral">&quot;Example&quot;</span>, 0, <span class="keyword">true</span>);</div>
<div class="line">    <span class="keywordflow">return</span> memory;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a59e3eab3983f6f2de28eba7b8a277992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e3eab3983f6f2de28eba7b8a277992">&#9670;&nbsp;</a></span>TrackDelete() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackDelete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to delete has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The id to associate with this tracking information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was passed int the call to delete.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
See <a class="el" href="namespacenn_1_1profiler.html#ac62f019cb92043d3aac05b10b39628d4" title="Record that a call to delete has occurred.">nn::profiler::TrackDelete(TrackingId const&amp;, void const*, char const*, bool)</a>. </p>

</div>
</div>
<a id="af57926ce88ab4ef7ddaccd89ae1a547c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af57926ce88ab4ef7ddaccd89ae1a547c">&#9670;&nbsp;</a></span>TrackDelete() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackDelete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>systemName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to delete has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The id to associate with this tracking information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was passed int the call to delete. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemName</td><td>The name of a system to attribute to the call.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
See <a class="el" href="namespacenn_1_1profiler.html#ac62f019cb92043d3aac05b10b39628d4" title="Record that a call to delete has occurred.">nn::profiler::TrackDelete(TrackingId const&amp;, void const*, char const*, bool)</a>. </p>

</div>
</div>
<a id="ac62f019cb92043d3aac05b10b39628d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac62f019cb92043d3aac05b10b39628d4">&#9670;&nbsp;</a></span>TrackDelete() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::profiler::TrackDelete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">TrackingId</a> const &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>systemName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that a call to delete has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The id to associate with this tracking information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address that was passed int the call to delete. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemName</td><td>The name of a system to attribute to the call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isVector</td><td>Specifies which variant of delete was called. If false, delete; otherwise, delete[].</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
This function informs the memory tracking system that a call to delete has occurred. When the PC memory tracking tool is connected, this will result in information on memory allocation being sent to the PC. As such, calls to this function may be slow.</p>
<p>This function call must be paired with a call to <a class="el" href="namespacenn_1_1profiler.html#abf33f5085549b0184a827cf6a902def7" title="Generates tracking information for a specific call to Track* functions.">GenerateNextTrackingId()</a>. Failure to do so may lead to improper operation of the memory tracking API. This may include a deadlock and/or application crash.</p>
<p>This function may be called before the profiler is initialized.</p>
<p>This function is thread-safe.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> DeleteMemory(<span class="keywordtype">void</span>* address)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="namespacenn_1_1profiler.html#a3f33fb75d3e0480ff9694565fbc1f421">nn::profiler::TrackingId</a> <span class="keyword">const</span> <span class="keywordtype">id</span> = <a class="code" href="namespacenn_1_1profiler.html#abf33f5085549b0184a827cf6a902def7">nn::profiler::GenerateNextTrackingId</a>();</div>
<div class="line">    <span class="keyword">delete</span> [] <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(address);</div>
<div class="line">    <a class="code" href="namespacenn_1_1profiler.html#aa879772ab7830431310aa39fafed3033">nn::profiler::TrackDelete</a>(<span class="keywordtype">id</span>, address, <span class="stringliteral">&quot;Example&quot;</span>, <span class="keyword">true</span>);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3e55d65c34ed2242e18640212b808ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e55d65c34ed2242e18640212b808ba6">&#9670;&nbsp;</a></span>GetMemoryTrackingHostConnectedEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1os_1_1_system_event_type.html">nn::os::SystemEventType</a>* nn::profiler::GetMemoryTrackingHostConnectedEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="namespacenn_1_1os.html#aa689721442ec303678047dd75c957bea" title="Waits for a system event to enter a signaled state.">nn::os::WaitSystemEvent</a> that is signaled when the memory tracking tool is connected. </p>
<p> <b>Details</b> <br  />
This function returns an <a class="el" href="namespacenn_1_1os.html#aa689721442ec303678047dd75c957bea" title="Waits for a system event to enter a signaled state.">nn::os::WaitSystemEvent</a> object from the memory tracking system.</p>
<p>When the memory tracking tool is connected, this event will be set to the signaled state.</p>
<p>This event is initialized with <a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a8b702480f5120eeeb01e7102227285da" title="Manually cleared event.">nn::os::EventClearMode_ManualClear</a> enabled. When the memory tracking system recognizes that the memory tracking tool is disconnected, the event is cleared.</p>
<p>This function may be called before the profiler is initialized. Note that the memory tracking tool is unable to connect until <a class="el" href="namespacenn_1_1profiler.html#a1fd4585e5e75647e1cb20bb264f58f6e" title="Initializes the profiler.">nn::profiler::Initialize</a> and <a class="el" href="namespacenn_1_1profiler.html#a3bf0a5b9753b627089dfcc0d0493d64c" title="Records a heap name to be used for a given range of addresses.">nn::profiler::RecordHeapRange</a> are called.</p>
<p>This function is thread-safe.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="structnn_1_1os_1_1_system_event_type.html">nn::os::SystemEventType</a>* connectionEvent = <a class="code" href="namespacenn_1_1profiler.html#a3e55d65c34ed2242e18640212b808ba6">nn::profiler::GetMemoryTrackingHostConnectedEvent</a>();</div>
<div class="line"><a class="code" href="namespacenn_1_1os.html#aa689721442ec303678047dd75c957bea">nn::os::WaitSystemEvent</a>(connectionEvent);</div>
<div class="ttc" id="anamespacenn_1_1os_html_aa689721442ec303678047dd75c957bea"><div class="ttname"><a href="namespacenn_1_1os.html#aa689721442ec303678047dd75c957bea">nn::os::WaitSystemEvent</a></div><div class="ttdeci">void WaitSystemEvent(SystemEventType *event) NN_NOEXCEPT</div><div class="ttdoc">Waits for a system event to enter a signaled state.</div></div>
<div class="ttc" id="anamespacenn_1_1profiler_html_a3e55d65c34ed2242e18640212b808ba6"><div class="ttname"><a href="namespacenn_1_1profiler.html#a3e55d65c34ed2242e18640212b808ba6">nn::profiler::GetMemoryTrackingHostConnectedEvent</a></div><div class="ttdeci">nn::os::SystemEventType * GetMemoryTrackingHostConnectedEvent() NN_NOEXCEPT</div><div class="ttdoc">Get a nn::os::WaitSystemEvent that is signaled when the memory tracking tool is connected.</div></div>
<div class="ttc" id="astructnn_1_1os_1_1_system_event_type_html"><div class="ttname"><a href="structnn_1_1os_1_1_system_event_type.html">nn::os::SystemEventType</a></div><div class="ttdoc">This structure defines a system event object.</div><div class="ttdef"><b>Definition:</b> os_SystemEventTypes.h:94</div></div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a9bc180dcf49e08d2b3c8f0bb7d8358b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc180dcf49e08d2b3c8f0bb7d8358b6">&#9670;&nbsp;</a></span>MinimumBufferSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t nn::profiler::MinimumBufferSize = 64 * 1024 * 1024</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The minimum buffer size needed by the profiler to function. </p>
<p> <b>Details</b> <br  />
Of this space, 1MB is reserved for internal usage while the remaining space is used for the profile data storage. If <a class="el" href="namespacenn_1_1profiler.html#a907804e676e1b37f7e1b62f5bace7992" title="Installs graphics hooks needed to enable the GPU Trace feature.">nn::profiler::InstallGraphicsHooks</a> was called, the internal usage requirement bumps up to 5MB, with the remaining space use for profile data storage.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenn_1_1profiler.html#a1fd4585e5e75647e1cb20bb264f58f6e" title="Initializes the profiler.">Initialize</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_simple_framework_8cpp-example.html#a31">NvnSimple/NvnSimpleSharedLib/SimpleFramework.cpp</a>, <a class="el" href="_profiler_simple_2_profiler_simple_8cpp-example.html#a9">ProfilerSimple/ProfilerSimple.cpp</a>, and <a class="el" href="_profiler_thread_state_2_profiler_thread_state_8cpp-example.html#a7">ProfilerThreadState/ProfilerThreadState.cpp</a>.</dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
