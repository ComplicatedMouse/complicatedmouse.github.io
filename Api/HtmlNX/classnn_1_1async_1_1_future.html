<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nn::async::Future&lt; T &gt; Class Template Reference | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenn.html">nn</a></li><li class="navelem"><a class="el" href="namespacenn_1_1async.html">async</a></li><li class="navelem"><a class="el" href="classnn_1_1async_1_1_future.html">Future</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classnn_1_1async_1_1_future-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">nn::async::Future&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The class for getting the results of asynchronous processes.  
 <a href="classnn_1_1async_1_1_future.html#details">More...</a></p>

<p><code>#include &lt;nn/async/async_FutureDecl.h&gt;</code></p>

<p>Inherits detail::FutureBaseT&lt; T &gt;.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab715e80643f711ff43a7871e3c100725"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1async_1_1_future.html#ab715e80643f711ff43a7871e3c100725">Future</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a>=default</td></tr>
<tr class="memdesc:ab715e80643f711ff43a7871e3c100725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="el" href="classnn_1_1async_1_1_future.html" title="The class for getting the results of asynchronous processes.">Future</a></code> object that does not reference a shared state.  <a href="classnn_1_1async_1_1_future.html#ab715e80643f711ff43a7871e3c100725">More...</a><br /></td></tr>
<tr class="separator:ab715e80643f711ff43a7871e3c100725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf57f9b0b285ace02c0f8ffa813882b"><td class="memItemLeft" align="right" valign="top"><a id="aabf57f9b0b285ace02c0f8ffa813882b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1async_1_1_future.html#aabf57f9b0b285ace02c0f8ffa813882b">Future</a> (const <a class="el" href="classnn_1_1async_1_1_future.html">Future</a>&lt; T &gt; &amp;)=delete</td></tr>
<tr class="memdesc:aabf57f9b0b285ace02c0f8ffa813882b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="classnn_1_1async_1_1_future.html" title="The class for getting the results of asynchronous processes.">Future</a></code> object cannot be copied. <br /></td></tr>
<tr class="separator:aabf57f9b0b285ace02c0f8ffa813882b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0f188efcebfb422db246e2cc5eb93c"><td class="memItemLeft" align="right" valign="top"><a id="a2f0f188efcebfb422db246e2cc5eb93c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1async_1_1_future.html#a2f0f188efcebfb422db246e2cc5eb93c">Future</a> (<a class="el" href="classnn_1_1async_1_1_future.html">Future</a>&lt; T &gt; &amp;&amp;)=default</td></tr>
<tr class="memdesc:a2f0f188efcebfb422db246e2cc5eb93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:a2f0f188efcebfb422db246e2cc5eb93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dca1b5a0e19b2d1a0fbc04e79351485"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1async_1_1_future.html#a0dca1b5a0e19b2d1a0fbc04e79351485">~Future</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a>=default</td></tr>
<tr class="memdesc:a0dca1b5a0e19b2d1a0fbc04e79351485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the <code><a class="el" href="classnn_1_1async_1_1_future.html" title="The class for getting the results of asynchronous processes.">Future</a></code> object.  <a href="classnn_1_1async_1_1_future.html#a0dca1b5a0e19b2d1a0fbc04e79351485">More...</a><br /></td></tr>
<tr class="separator:a0dca1b5a0e19b2d1a0fbc04e79351485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40821903a5646af0e132b56b9dec48f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1async_1_1_future.html#af40821903a5646af0e132b56b9dec48f">AttachCompletionEvent</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">os::MultiWaitHolderType</a> *holder) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af40821903a5646af0e132b56b9dec48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the specified multiple wait holder object so it can wait for the completion of asynchronous processing.  <a href="classnn_1_1async_1_1_future.html#af40821903a5646af0e132b56b9dec48f">More...</a><br /></td></tr>
<tr class="separator:af40821903a5646af0e132b56b9dec48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38bfb4c7dd19a0282eccdb46cf55afa2"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1async_1_1_future.html#a38bfb4c7dd19a0282eccdb46cf55afa2">Get</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a38bfb4c7dd19a0282eccdb46cf55afa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the result of asynchronous processing.  <a href="classnn_1_1async_1_1_future.html#a38bfb4c7dd19a0282eccdb46cf55afa2">More...</a><br /></td></tr>
<tr class="separator:a38bfb4c7dd19a0282eccdb46cf55afa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cddd642d4f48b6d9d753860434dc55c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1async_1_1_future.html#a2cddd642d4f48b6d9d753860434dc55c">IsValid</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2cddd642d4f48b6d9d753860434dc55c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a shared state is being referenced.  <a href="classnn_1_1async_1_1_future.html#a2cddd642d4f48b6d9d753860434dc55c">More...</a><br /></td></tr>
<tr class="separator:a2cddd642d4f48b6d9d753860434dc55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842a20c3dbb18ee7e42a1d5e0bec2c87"><td class="memItemLeft" align="right" valign="top"><a id="a842a20c3dbb18ee7e42a1d5e0bec2c87"></a>
<a class="el" href="classnn_1_1async_1_1_future.html">Future</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1async_1_1_future.html#a842a20c3dbb18ee7e42a1d5e0bec2c87">operator=</a> (const <a class="el" href="classnn_1_1async_1_1_future.html">Future</a>&lt; T &gt; &amp;)=delete</td></tr>
<tr class="memdesc:a842a20c3dbb18ee7e42a1d5e0bec2c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="classnn_1_1async_1_1_future.html" title="The class for getting the results of asynchronous processes.">Future</a></code> object cannot be copied. <br /></td></tr>
<tr class="separator:a842a20c3dbb18ee7e42a1d5e0bec2c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729213f33000b7bee6d08c870b2ae374"><td class="memItemLeft" align="right" valign="top"><a id="a729213f33000b7bee6d08c870b2ae374"></a>
<a class="el" href="classnn_1_1async_1_1_future.html">Future</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1async_1_1_future.html#a729213f33000b7bee6d08c870b2ae374">operator=</a> (<a class="el" href="classnn_1_1async_1_1_future.html">Future</a>&lt; T &gt; &amp;&amp;)=default</td></tr>
<tr class="memdesc:a729213f33000b7bee6d08c870b2ae374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. <br /></td></tr>
<tr class="separator:a729213f33000b7bee6d08c870b2ae374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674edc5eb7cef52a6758f8cb63c3d142"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1async_1_1_shared_future.html">SharedFuture</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1async_1_1_future.html#a674edc5eb7cef52a6758f8cb63c3d142">Share</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a674edc5eb7cef52a6758f8cb63c3d142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="el" href="classnn_1_1async_1_1_shared_future.html" title="Class that can get the asynchronous processing result multiple times.">SharedFuture</a></code> object and moves the shared state reference.  <a href="classnn_1_1async_1_1_future.html#a674edc5eb7cef52a6758f8cb63c3d142">More...</a><br /></td></tr>
<tr class="separator:a674edc5eb7cef52a6758f8cb63c3d142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b1b0ac60781b95b5b6eff19c69afa4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1async_1_1_future.html#a54b1b0ac60781b95b5b6eff19c69afa4">TimedWait</a> (<a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> timeout) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a54b1b0ac60781b95b5b6eff19c69afa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for a limited amount of time for the asynchronous process to complete.  <a href="classnn_1_1async_1_1_future.html#a54b1b0ac60781b95b5b6eff19c69afa4">More...</a><br /></td></tr>
<tr class="separator:a54b1b0ac60781b95b5b6eff19c69afa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22c064c292a57728b8f4515cf62bba0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1async_1_1_future.html#ad22c064c292a57728b8f4515cf62bba0">TryWait</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad22c064c292a57728b8f4515cf62bba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the completion status of the asynchronous process.  <a href="classnn_1_1async_1_1_future.html#ad22c064c292a57728b8f4515cf62bba0">More...</a><br /></td></tr>
<tr class="separator:ad22c064c292a57728b8f4515cf62bba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9d2ba66466ae6b894c7313861f81f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1async_1_1_future.html#ade9d2ba66466ae6b894c7313861f81f7">Wait</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ade9d2ba66466ae6b894c7313861f81f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the completion of the asynchronous process.  <a href="classnn_1_1async_1_1_future.html#ade9d2ba66466ae6b894c7313861f81f7">More...</a><br /></td></tr>
<tr class="separator:ade9d2ba66466ae6b894c7313861f81f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class nn::async::Future&lt; T &gt;</h3>

<p>The class for getting the results of asynchronous processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type for the result of an asynchronous process.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
 The <code><a class="el" href="classnn_1_1async_1_1_future.html" title="The class for getting the results of asynchronous processes.">Future</a></code> class provides the necessary interface for getting the results of asynchronous processes. To be specific, this class provides the following functionality.</p>
<ul>
<li>Getting the result of execution</li>
<li>Waiting for the asynchronous process to complete</li>
</ul>
<p>The <code><a class="el" href="classnn_1_1async_1_1_future.html" title="The class for getting the results of asynchronous processes.">Future</a></code> class is a generic interface, and the execution result values differ depending on the asynchronous function that created the <code><a class="el" href="classnn_1_1async_1_1_future.html" title="The class for getting the results of asynchronous processes.">Future</a></code> object. For additional information, see the API reference for each function.</p>
<p>The <code><a class="el" href="classnn_1_1async_1_1_future.html" title="The class for getting the results of asynchronous processes.">Future</a></code> object references a maximum of one shared state. A shared state is an internal object for communicating with the thread that is running the asynchronous process. By referencing a shared state, the <code><a class="el" href="classnn_1_1async_1_1_future.html" title="The class for getting the results of asynchronous processes.">Future</a></code> object can get the completion status of the asynchronous process and the execution result. A <code><a class="el" href="classnn_1_1async_1_1_future.html" title="The class for getting the results of asynchronous processes.">Future</a></code> object that is not referencing a shared state cannot provide these features. Most of the member functions of the <code><a class="el" href="classnn_1_1async_1_1_future.html" title="The class for getting the results of asynchronous processes.">Future</a></code> object require as a precondition that a shared state is being referenced.</p>
<p>Some of the member functions of the <code><a class="el" href="classnn_1_1async_1_1_future.html" title="The class for getting the results of asynchronous processes.">Future</a></code> object destroy this shared state reference after they have been called. Make sure you understand the preconditions and postconditions for each member function. You can use the <code><a class="el" href="classnn_1_1async_1_1_future.html#a2cddd642d4f48b6d9d753860434dc55c" title="Determines whether a shared state is being referenced.">IsValid()</a></code> to determine whether the current <code><a class="el" href="classnn_1_1async_1_1_future.html" title="The class for getting the results of asynchronous processes.">Future</a></code> object is referencing a shared state.</p>
<p>You can only get the execution result from the <code><a class="el" href="classnn_1_1async_1_1_future.html" title="The class for getting the results of asynchronous processes.">Future</a></code> object one time. If you need to get multiple execution results, call the <code><a class="el" href="classnn_1_1async_1_1_future.html#a674edc5eb7cef52a6758f8cb63c3d142" title="Creates a SharedFuture object and moves the shared state reference.">Share()</a></code> function and create a <code><a class="el" href="classnn_1_1async_1_1_shared_future.html" title="Class that can get the asynchronous processing result multiple times.">SharedFuture</a></code> object. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab715e80643f711ff43a7871e3c100725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab715e80643f711ff43a7871e3c100725">&#9670;&nbsp;</a></span>Future()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1async_1_1_future.html">nn::async::Future</a>&lt; T &gt;::<a class="el" href="classnn_1_1async_1_1_future.html">Future</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <code><a class="el" href="classnn_1_1async_1_1_future.html" title="The class for getting the results of asynchronous processes.">Future</a></code> object that does not reference a shared state. </p>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="classnn_1_1async_1_1_future.html#a2cddd642d4f48b6d9d753860434dc55c" title="Determines whether a shared state is being referenced.">IsValid()</a></code> == <code>false</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0dca1b5a0e19b2d1a0fbc04e79351485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dca1b5a0e19b2d1a0fbc04e79351485">&#9670;&nbsp;</a></span>~Future()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1async_1_1_future.html">nn::async::Future</a>&lt; T &gt;::~<a class="el" href="classnn_1_1async_1_1_future.html">Future</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the <code><a class="el" href="classnn_1_1async_1_1_future.html" title="The class for getting the results of asynchronous processes.">Future</a></code> object. </p>
<p> <b>Details</b> <br  />
 Destroys the object if it is referencing a shared state. In some cases, the memory resource is also destroyed.</p>
<p>The destructor does not wait for the execution of the asynchronous process to complete. The destructor can be called even before or during the execution of the asynchronous process. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2cddd642d4f48b6d9d753860434dc55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cddd642d4f48b6d9d753860434dc55c">&#9670;&nbsp;</a></span>IsValid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classnn_1_1async_1_1_future.html">nn::async::Future</a>&lt; T &gt;::IsValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a shared state is being referenced. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if <code>*this</code> is referencing a shared state. </dd></dl>

</div>
</div>
<a id="a38bfb4c7dd19a0282eccdb46cf55afa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38bfb4c7dd19a0282eccdb46cf55afa2">&#9670;&nbsp;</a></span>Get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classnn_1_1async_1_1_future.html">nn::async::Future</a>&lt; T &gt;::Get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the result of asynchronous processing. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classnn_1_1_result.html" title="Represents the generic result of an operation.">Result</a> of asynchronous processing.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><a class="el" href="classnn_1_1async_1_1_future.html#a2cddd642d4f48b6d9d753860434dc55c" title="Determines whether a shared state is being referenced.">IsValid()</a></code> == <code>true</code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="classnn_1_1async_1_1_future.html#a2cddd642d4f48b6d9d753860434dc55c" title="Determines whether a shared state is being referenced.">IsValid()</a></code> == <code>false</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The <code><a class="el" href="classnn_1_1async_1_1_future.html#ade9d2ba66466ae6b894c7313861f81f7" title="Waits for the completion of the asynchronous process.">Wait()</a></code> function is called implicitly inside this function. If the asynchronous process is not finished, the calling thread is blocked until it has completed.</p>
<p>This function returns the value stored in the shared state by moving. In addition, this function destroys the reference to the shared state. If you want to get the value multiple times, call <code><a class="el" href="classnn_1_1async_1_1_future.html#a674edc5eb7cef52a6758f8cb63c3d142" title="Creates a SharedFuture object and moves the shared state reference.">Share()</a></code> and create a <code><a class="el" href="classnn_1_1async_1_1_shared_future.html" title="Class that can get the asynchronous processing result multiple times.">SharedFuture</a></code> object. </p>

</div>
</div>
<a id="a674edc5eb7cef52a6758f8cb63c3d142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674edc5eb7cef52a6758f8cb63c3d142">&#9670;&nbsp;</a></span>Share()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1async_1_1_shared_future.html">SharedFuture</a>&lt; T &gt; <a class="el" href="classnn_1_1async_1_1_future.html">nn::async::Future</a>&lt; T &gt;::Share</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <code><a class="el" href="classnn_1_1async_1_1_shared_future.html" title="Class that can get the asynchronous processing result multiple times.">SharedFuture</a></code> object and moves the shared state reference. </p>
<dl class="section return"><dt>Returns</dt><dd>The <code><a class="el" href="classnn_1_1async_1_1_shared_future.html" title="Class that can get the asynchronous processing result multiple times.">SharedFuture</a></code> object to which the shared state reference held by <code>*this</code> was moved.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="classnn_1_1async_1_1_future.html#a2cddd642d4f48b6d9d753860434dc55c" title="Determines whether a shared state is being referenced.">IsValid()</a></code> == <code>false</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Moves the shared state reference of <code>*this</code> to a <code><a class="el" href="classnn_1_1async_1_1_shared_future.html" title="Class that can get the asynchronous processing result multiple times.">SharedFuture</a></code> object. If <code>*this</code> was not referencing a shared state before this function was called, the <code><a class="el" href="classnn_1_1async_1_1_shared_future.html" title="Class that can get the asynchronous processing result multiple times.">SharedFuture</a></code> object in the return value does not reference a shared state either.</p>
<p>The <code><a class="el" href="classnn_1_1async_1_1_shared_future.html" title="Class that can get the asynchronous processing result multiple times.">SharedFuture</a></code> object that can be obtained using this function is equivalent to the <code><a class="el" href="classnn_1_1async_1_1_shared_future.html" title="Class that can get the asynchronous processing result multiple times.">SharedFuture</a></code> object created by <code>SharedFuture&lt;T&gt;(std::move(*this))</code>. </p>

</div>
</div>
<a id="af40821903a5646af0e132b56b9dec48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40821903a5646af0e132b56b9dec48f">&#9670;&nbsp;</a></span>AttachCompletionEvent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnn_1_1async_1_1_future.html">nn::async::Future</a>&lt; T &gt;::AttachCompletionEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">os::MultiWaitHolderType</a> *&#160;</td>
          <td class="paramname"><em>holder</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the specified multiple wait holder object so it can wait for the completion of asynchronous processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">holder</td><td>The multiple wait holder object to initialize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><a class="el" href="classnn_1_1async_1_1_future.html#a2cddd642d4f48b6d9d753860434dc55c" title="Determines whether a shared state is being referenced.">IsValid()</a></code> == <code>true</code>.</li>
<li><code><em>holder</em></code> != <code>nullptr</code>.</li>
<li><code><em>holder</em></code> is uninitialized.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>holder</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Initializes the object specified by <code><em>holder</em></code> in a way similar to <code><a class="el" href="namespacenn_1_1os.html#a4f8d998425d067cb5fec2604ae7845dc" title="Initializes a multiWaitHolder object and binds it to an event.">nn::os::InitializeMultiWaitHolder()</a></code> and associates it with an asynchronous process completion event. After this function has been called you can use the object with the <code><a class="el" href="namespacenn_1_1os.html#a7cd9b25e14bee063959eb9e7f62a4aa8" title="Links a multiWaitHolder object to a multiWait object header.">nn::os::LinkMultiWaitHolder()</a></code> function for a multiple wait. After you are done using it, finalize it using the <code><a class="el" href="namespacenn_1_1os.html#a2de358e6bfa261b74c399b5b59c0da1d" title="Finalizes a multiWaitHolder object.">nn::os::FinalizeMultiWaitHolder()</a></code> function. For more information about using the multiple wait feature, see<a href="../../Package/contents/Pages/Page_83955865.html">the documentation for the os library</a>. </p>

</div>
</div>
<a id="ade9d2ba66466ae6b894c7313861f81f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9d2ba66466ae6b894c7313861f81f7">&#9670;&nbsp;</a></span>Wait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnn_1_1async_1_1_future.html">nn::async::Future</a>&lt; T &gt;::Wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for the completion of the asynchronous process. </p>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><a class="el" href="classnn_1_1async_1_1_future.html#a2cddd642d4f48b6d9d753860434dc55c" title="Determines whether a shared state is being referenced.">IsValid()</a></code> == <code>true</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Blocks the calling thread until the asynchronous process is completed. The function returns control immediately if the asynchronous process is already completed. </p>

</div>
</div>
<a id="ad22c064c292a57728b8f4515cf62bba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22c064c292a57728b8f4515cf62bba0">&#9670;&nbsp;</a></span>TryWait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classnn_1_1async_1_1_future.html">nn::async::Future</a>&lt; T &gt;::TryWait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the completion status of the asynchronous process. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the asynchronous process is completed.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><a class="el" href="classnn_1_1async_1_1_future.html#a2cddd642d4f48b6d9d753860434dc55c" title="Determines whether a shared state is being referenced.">IsValid()</a></code> == <code>true</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function returns control immediately without blocking the caller. </p>

</div>
</div>
<a id="a54b1b0ac60781b95b5b6eff19c69afa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b1b0ac60781b95b5b6eff19c69afa4">&#9670;&nbsp;</a></span>TimedWait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classnn_1_1async_1_1_future.html">nn::async::Future</a>&lt; T &gt;::TimedWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for a limited amount of time for the asynchronous process to complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Wait time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the asynchronous process is completed.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><a class="el" href="classnn_1_1async_1_1_future.html#a2cddd642d4f48b6d9d753860434dc55c" title="Determines whether a shared state is being referenced.">IsValid()</a></code> == <code>true</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The function returns <code>true</code> if the asynchronous process completed within the time indicated by the <code><em>timeout</em></code> parameter, or <code>false</code> if not. It returns <code>true</code> immediately if the asynchronous process is already completed. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
