<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nn::audio Namespace Reference | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenn.html">nn</a></li><li class="navelem"><a class="el" href="namespacenn_1_1audio.html">audio</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">nn::audio Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace for the audio library.  
<a href="namespacenn_1_1audio.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_adpcm_context.html">AdpcmContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADPCM context information.  <a href="structnn_1_1audio_1_1_adpcm_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_adpcm_header_info.html">AdpcmHeaderInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADPCM header information.  <a href="structnn_1_1audio_1_1_adpcm_header_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_adpcm_parameter.html">AdpcmParameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADPCM coefficient parameter information.  <a href="structnn_1_1audio_1_1_adpcm_parameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_audio_device_name.html">AudioDeviceName</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure representing the names of the devices supported by the platform.  <a href="structnn_1_1audio_1_1_audio_device_name.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for managing an audio input.  <a href="structnn_1_1audio_1_1_audio_in.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_audio_in_buffer.html">AudioInBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing an audio input buffer.  <a href="structnn_1_1audio_1_1_audio_in_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_audio_in_info.html">AudioInInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing audio input information.  <a href="structnn_1_1audio_1_1_audio_in_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_audio_in_parameter.html">AudioInParameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter for audio input.  <a href="structnn_1_1audio_1_1_audio_in_parameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for managing an audio output.  <a href="structnn_1_1audio_1_1_audio_out.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_audio_out_buffer.html">AudioOutBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing an audio output buffer.  <a href="structnn_1_1audio_1_1_audio_out_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_audio_out_info.html">AudioOutInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing audio output information.  <a href="structnn_1_1audio_1_1_audio_out_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_audio_out_parameter.html">AudioOutParameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter for audio output.  <a href="structnn_1_1audio_1_1_audio_out_parameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that manages audio renderer settings.  <a href="structnn_1_1audio_1_1_audio_renderer_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_handle.html">AudioRendererHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The audio renderer handle.  <a href="structnn_1_1audio_1_1_audio_renderer_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html">AudioRendererParameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The audio renderer parameters.  <a href="structnn_1_1audio_1_1_audio_renderer_parameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_aux_buffer_statistics.html">AuxBufferStatistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistical information associated with the <code>SendBuffer</code> and <code>ReturnBuffer</code> managed by <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code>.  <a href="structnn_1_1audio_1_1_aux_buffer_statistics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1audio_1_1_aux_delay.html">AuxDelay</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for handling the <code>Delay</code> effect utility applied to <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">nn::audio::AuxType</a></code>.  <a href="classnn_1_1audio_1_1_aux_delay.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html">AuxDelayType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for the <code>Delay</code> effect applied to <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">nn::audio::AuxType</a></code>.  <a href="structnn_1_1audio_1_1_aux_delay_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1audio_1_1_aux_i3dl2_reverb.html">AuxI3dl2Reverb</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for handling the <code>I3dl2Reverb</code> effect utility applied to <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">nn::audio::AuxType</a></code>.  <a href="classnn_1_1audio_1_1_aux_i3dl2_reverb.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html">AuxI3dl2ReverbType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The utility of the <code>I3dl2Reverb</code> effect applied to <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">nn::audio::AuxType</a></code>.  <a href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1audio_1_1_aux_light_limiter.html">AuxLightLimiter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for handling the <code>LightLimiter</code> effect utility applied to <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">nn::audio::AuxType</a></code>.  <a href="classnn_1_1audio_1_1_aux_light_limiter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html">AuxLightLimiterType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility that applies a LightLimiter effect to <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">nn::audio::AuxType</a></code>.  <a href="structnn_1_1audio_1_1_aux_light_limiter_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1audio_1_1_aux_limiter.html">AuxLimiter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for handling the <code>Limiter</code> effect utility applied to <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">nn::audio::AuxType</a></code>.  <a href="classnn_1_1audio_1_1_aux_limiter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html">AuxLimiterType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The utility of the Limiter effect applied to <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">nn::audio::AuxType</a></code>.  <a href="structnn_1_1audio_1_1_aux_limiter_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1audio_1_1_aux_reverb.html">AuxReverb</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for handling the <code>Reverb</code> effect utility applied to <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">nn::audio::AuxType</a></code>.  <a href="classnn_1_1audio_1_1_aux_reverb.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html">AuxReverbType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for reverb effects applying to <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">nn::audio::AuxType</a></code>.  <a href="structnn_1_1audio_1_1_aux_reverb_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Effect used to incorporate an effect process that the user can define.  <a href="structnn_1_1audio_1_1_aux_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_biquad_filter_parameter.html">BiquadFilterParameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Biquad filter parameters.  <a href="structnn_1_1audio_1_1_biquad_filter_parameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html">BiquadFilterType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code>BiquadFilter</code> effect.  <a href="structnn_1_1audio_1_1_biquad_filter_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_buffer_mixer_type.html">BufferMixerType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>BufferMixer</code> effects.  <a href="structnn_1_1audio_1_1_buffer_mixer_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_capture_type.html">CaptureType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An effect for incorporating the process of getting sample data.  <a href="structnn_1_1audio_1_1_capture_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_circular_buffer_sink_type.html">CircularBufferSinkType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sink to output the rendering results to memory.  <a href="structnn_1_1audio_1_1_circular_buffer_sink_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_delay_parameter_set.html">DelayParameterSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The delay effect parameters.  <a href="structnn_1_1audio_1_1_delay_parameter_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>Delay</code> effects.  <a href="structnn_1_1audio_1_1_delay_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_device_sink_type.html">DeviceSinkType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sink to output the rendering results to the audio output device.  <a href="structnn_1_1audio_1_1_device_sink_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing <code>FinalMix</code>.  <a href="structnn_1_1audio_1_1_final_mix_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_parameter_set.html">I3dl2ReverbParameterSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>I3dl2Reverb</code> effect parameters.  <a href="structnn_1_1audio_1_1_i3dl2_reverb_parameter_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>I3dl2Reverb</code> effect.  <a href="structnn_1_1audio_1_1_i3dl2_reverb_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_light_limiter_channel_statistics.html">LightLimiterChannelStatistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics for each channel resulting from the <code>LightLimiter</code> processing.  <a href="structnn_1_1audio_1_1_light_limiter_channel_statistics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_light_limiter_parameter_set.html">LightLimiterParameterSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LightLimiter effect parameter set.  <a href="structnn_1_1audio_1_1_light_limiter_parameter_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">LightLimiter effect.  <a href="structnn_1_1audio_1_1_light_limiter_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_limiter_parameter_set.html">LimiterParameterSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Limiter effect parameters.  <a href="structnn_1_1audio_1_1_limiter_parameter_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html">MemoryPoolType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for representing memory regions used by an audio renderer.  <a href="structnn_1_1audio_1_1_memory_pool_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_performance_detail.html">PerformanceDetail</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detailed performance information linked to each <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, and <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> object.  <a href="structnn_1_1audio_1_1_performance_detail.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_performance_entry.html">PerformanceEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performance information for each instance of <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, and <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>.  <a href="structnn_1_1audio_1_1_performance_entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_performance_frame_header.html">PerformanceFrameHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The header for the performance information for a single audio frame of the audio renderer.  <a href="structnn_1_1audio_1_1_performance_frame_header.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1audio_1_1_performance_info.html">PerformanceInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for working with performance information retrieved using the <code><a class="el" href="namespacenn_1_1audio.html#a7d1532644fd22daad0fe71d9f409ba72" title="Sets a starting address to output performance information to.">nn::audio::SetPerformanceFrameBuffer</a></code> function.  <a href="classnn_1_1audio_1_1_performance_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1audio_1_1_polyphase_resampler.html">PolyphaseResampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for handling the polyphase resampler.  <a href="classnn_1_1audio_1_1_polyphase_resampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_polyphase_resampler_type.html">PolyphaseResamplerType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure for managing the resampler.  <a href="structnn_1_1audio_1_1_polyphase_resampler_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1audio_1_1_resampler.html">Resampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for handling the resampler.  <a href="classnn_1_1audio_1_1_resampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_resampler_type.html">ResamplerType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure for managing the resampler.  <a href="structnn_1_1audio_1_1_resampler_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1audio_1_1_result_already_open.html">ResultAlreadyOpen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>audio</code>: Already opened.).  <a href="classnn_1_1audio_1_1_result_already_open.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1audio_1_1_result_applet_resource_user_id_not_found.html">ResultAppletResourceUserIdNotFound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>audio</code>: The specified applet identifier was not found.).  <a href="classnn_1_1audio_1_1_result_applet_resource_user_id_not_found.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1audio_1_1_result_audio_renderer_unknown_error.html">ResultAudioRendererUnknownError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>audio</code>: An unknown error occurred while AudioRenderer was running.).  <a href="classnn_1_1audio_1_1_result_audio_renderer_unknown_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1audio_1_1_result_cycle_detected.html">ResultCycleDetected</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>audio</code>: A closed circuit was detected in the SubMix or FinalMix connection passed to the audio renderer.).  <a href="classnn_1_1audio_1_1_result_cycle_detected.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1audio_1_1_result_default_audio_in_not_available.html">ResultDefaultAudioInNotAvailable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>audio</code>: The default audio input is not available.).  <a href="classnn_1_1audio_1_1_result_default_audio_in_not_available.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1audio_1_1_result_default_audio_out_not_available.html">ResultDefaultAudioOutNotAvailable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>audio</code>: The default audio output is not available.).  <a href="classnn_1_1audio_1_1_result_default_audio_out_not_available.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1audio_1_1_result_insufficient_buffer.html">ResultInsufficientBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>audio</code>: Insufficient buffer.).  <a href="classnn_1_1audio_1_1_result_insufficient_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1audio_1_1_result_invalid_channel_count.html">ResultInvalidChannelCount</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>audio</code>: An invalid number of channels was specified.).  <a href="classnn_1_1audio_1_1_result_invalid_channel_count.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1audio_1_1_result_invalid_codec_volume.html">ResultInvalidCodecVolume</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>audio</code>: An invalid codec volume was specified.).  <a href="classnn_1_1audio_1_1_result_invalid_codec_volume.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1audio_1_1_result_invalid_codec_volume_target.html">ResultInvalidCodecVolumeTarget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>audio</code>: An invalid codec volume target was specified.).  <a href="classnn_1_1audio_1_1_result_invalid_codec_volume_target.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1audio_1_1_result_invalid_sample_rate.html">ResultInvalidSampleRate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>audio</code>: An invalid sampling rate was specified.).  <a href="classnn_1_1audio_1_1_result_invalid_sample_rate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1audio_1_1_result_invalid_update_info.html">ResultInvalidUpdateInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>audio</code>: The data passed to <a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a> is corrupted.).  <a href="classnn_1_1audio_1_1_result_invalid_update_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1audio_1_1_result_max_applet_resource_user_id.html">ResultMaxAppletResourceUserId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>audio</code>: The limit for applet identifier registrations has already been reached.).  <a href="classnn_1_1audio_1_1_result_max_applet_resource_user_id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1audio_1_1_result_no_audio_device_found.html">ResultNoAudioDeviceFound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>audio</code>: Audio device does not exist in the system.).  <a href="classnn_1_1audio_1_1_result_no_audio_device_found.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1audio_1_1_result_no_memory_pool_entry.html">ResultNoMemoryPoolEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>audio</code>: No <a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html" title="Structure for representing memory regions used by an audio renderer.">nn::audio::MemoryPoolType</a> object containing the passed address exists.).  <a href="classnn_1_1audio_1_1_result_no_memory_pool_entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1audio_1_1_result_not_found.html">ResultNotFound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>audio</code>: The specified item could not be found.).  <a href="classnn_1_1audio_1_1_result_not_found.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1audio_1_1_result_not_implemented.html">ResultNotImplemented</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>audio</code>: This feature is not implemented.).  <a href="classnn_1_1audio_1_1_result_not_implemented.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1audio_1_1_result_not_supported.html">ResultNotSupported</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>audio</code>: This functionality is not supported.).  <a href="classnn_1_1audio_1_1_result_not_supported.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1audio_1_1_result_operation_failed.html">ResultOperationFailed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>audio</code>: The process failed.).  <a href="classnn_1_1audio_1_1_result_operation_failed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html">ResultOutOfResource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>audio</code>: Insufficient resources.).  <a href="classnn_1_1audio_1_1_result_out_of_resource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1audio_1_1_result_update_audio_renderer_error.html">ResultUpdateAudioRendererError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>audio</code>: An unknown error occurred while the audio renderer was updating.).  <a href="classnn_1_1audio_1_1_result_update_audio_renderer_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_reverb_parameter_set.html">ReverbParameterSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reverb effect parameters.  <a href="structnn_1_1audio_1_1_reverb_parameter_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverb effect.  <a href="structnn_1_1audio_1_1_reverb_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_splitter_type.html">SplitterType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure provides a feature to distribute the sample data of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> / <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> input source to multiple output destinations.  <a href="structnn_1_1audio_1_1_splitter_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing <code>SubMix</code>.  <a href="structnn_1_1audio_1_1_sub_mix_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that controls waveform input to the renderer.  <a href="structnn_1_1audio_1_1_voice_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html">WaveBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for handling waveform input provided to a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>.  <a href="structnn_1_1audio_1_1_wave_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a347cdc16fef8e35aad9d8d0cd2e79e38"><td class="memItemLeft" align="right" valign="top"><a id="a347cdc16fef8e35aad9d8d0cd2e79e38"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a347cdc16fef8e35aad9d8d0cd2e79e38">NodeId</a></td></tr>
<tr class="memdesc:a347cdc16fef8e35aad9d8d0cd2e79e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ID within the audio renderer <code>Voice</code>, <code>SubMix</code>, and <code>FinalMix</code>. <br /></td></tr>
<tr class="separator:a347cdc16fef8e35aad9d8d0cd2e79e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a0a1874bce5c774a70d6e980790392ffa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a0a1874bce5c774a70d6e980790392ffa">AudioInState</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a0a1874bce5c774a70d6e980790392ffaaebe92f50f4502d18a959161c8a39fe8b">AudioInState_Started</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a0a1874bce5c774a70d6e980790392ffaa5e86cc78ca08b5202af4be54ce493395">AudioInState_Stopped</a>
<br />
 }</td></tr>
<tr class="memdesc:a0a1874bce5c774a70d6e980790392ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated type representing the states of an audio input.  <a href="namespacenn_1_1audio.html#a0a1874bce5c774a70d6e980790392ffa">More...</a><br /></td></tr>
<tr class="separator:a0a1874bce5c774a70d6e980790392ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6dfba2e7415ea48852b3f07216f2f31"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ad6dfba2e7415ea48852b3f07216f2f31">AudioOutState</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#ad6dfba2e7415ea48852b3f07216f2f31a88576f200d2c91da21684d4ca31203ca">AudioOutState_Started</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#ad6dfba2e7415ea48852b3f07216f2f31ad092b713343a91f72ab142cbead28cd3">AudioOutState_Stopped</a>
<br />
 }</td></tr>
<tr class="memdesc:ad6dfba2e7415ea48852b3f07216f2f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated type representing the states of an audio output.  <a href="namespacenn_1_1audio.html#ad6dfba2e7415ea48852b3f07216f2f31">More...</a><br /></td></tr>
<tr class="separator:ad6dfba2e7415ea48852b3f07216f2f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe8ba78d8df1cffa01e726924471e35"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#abfe8ba78d8df1cffa01e726924471e35">AudioRendererExecutionMode</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#abfe8ba78d8df1cffa01e726924471e35a794cd663cfcf7d70450fcf317f7ecf45">AudioRendererExecutionMode_AutoExecution</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#abfe8ba78d8df1cffa01e726924471e35a779f8ffa3797802237909514ec53ba9e">AudioRendererExecutionMode_ManualExecution</a>
<br />
 }</td></tr>
<tr class="memdesc:abfe8ba78d8df1cffa01e726924471e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated type that represents the rendering mode of the audio renderer.  <a href="namespacenn_1_1audio.html#abfe8ba78d8df1cffa01e726924471e35">More...</a><br /></td></tr>
<tr class="separator:abfe8ba78d8df1cffa01e726924471e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b67f0c9d1ae83ebaea784964373f56"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a46b67f0c9d1ae83ebaea784964373f56">AudioRendererRenderingDevice</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a46b67f0c9d1ae83ebaea784964373f56a550beeb25cdd6d8c2f0ef5062282dc62">AudioRendererRenderingDevice_AudioCoprocessor</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a46b67f0c9d1ae83ebaea784964373f56a46aff03ba5cf2fde86d7cc6bee1324e5">AudioRendererRenderingDevice_Cpu</a>
<br />
 }</td></tr>
<tr class="memdesc:a46b67f0c9d1ae83ebaea784964373f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated type that represents the device used by the audio renderer for rendering.  <a href="namespacenn_1_1audio.html#a46b67f0c9d1ae83ebaea784964373f56">More...</a><br /></td></tr>
<tr class="separator:a46b67f0c9d1ae83ebaea784964373f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c5ac6aa2921d6a52fb1c44471d4661"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a44c5ac6aa2921d6a52fb1c44471d4661">AudioRendererState</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a44c5ac6aa2921d6a52fb1c44471d4661ab7f98e352ea8fe399028e2ac38c81dc6">AudioRendererState_Started</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a44c5ac6aa2921d6a52fb1c44471d4661ad5a62596d304f2e23af3451855303500">AudioRendererState_Stopped</a>
<br />
 }</td></tr>
<tr class="memdesc:a44c5ac6aa2921d6a52fb1c44471d4661"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enumerated type that indicates the audio renderer state.  <a href="namespacenn_1_1audio.html#a44c5ac6aa2921d6a52fb1c44471d4661">More...</a><br /></td></tr>
<tr class="separator:a44c5ac6aa2921d6a52fb1c44471d4661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5febdb32531c0ab471ab02f6a0c2892"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ae5febdb32531c0ab471ab02f6a0c2892">ChannelMapping</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#ae5febdb32531c0ab471ab02f6a0c2892a4ef16b2ffb413506d04e548a98a61ab9">ChannelMapping_FrontLeft</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#ae5febdb32531c0ab471ab02f6a0c2892a45f9acfb3cfbbe1a5c256bff1da701f2">ChannelMapping_FrontRight</a> = 1
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#ae5febdb32531c0ab471ab02f6a0c2892ac3b343b9fbe3d544196e3926b5fd4753">ChannelMapping_FrontCenter</a> = 2
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#ae5febdb32531c0ab471ab02f6a0c2892a56622a5f09d4db57bfc556f976824a3d">ChannelMapping_LowFrequency</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#ae5febdb32531c0ab471ab02f6a0c2892a23c930f0e638ec3d72130e87e55f049d">ChannelMapping_RearLeft</a> = 4
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#ae5febdb32531c0ab471ab02f6a0c2892acaa91a1abea9cb4377c2d7fa6b027507">ChannelMapping_RearRight</a> = 5
<br />
 }</td></tr>
<tr class="memdesc:ae5febdb32531c0ab471ab02f6a0c2892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the mapping between <code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> output channels and their indices.  <a href="namespacenn_1_1audio.html#ae5febdb32531c0ab471ab02f6a0c2892">More...</a><br /></td></tr>
<tr class="separator:ae5febdb32531c0ab471ab02f6a0c2892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b8d931adba0b54dfc9570bfc26f51d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a43b8d931adba0b54dfc9570bfc26f51d">PerformanceDetailType</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a43b8d931adba0b54dfc9570bfc26f51da41b51d01258879e16cb79291f1f5c25b">PerformanceDetailType_Unknown</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a43b8d931adba0b54dfc9570bfc26f51dad70936cdc3ed6c9112415f364b1cf96c">PerformanceDetailType_PcmInt16DataSource</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a43b8d931adba0b54dfc9570bfc26f51daa761b06268289c7c7e73a7c9a2c85bab">PerformanceDetailType_AdpcmDataSource</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a43b8d931adba0b54dfc9570bfc26f51da3b1c927ae1cac757f0d02794c4e73081">PerformanceDetailType_Volume</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a43b8d931adba0b54dfc9570bfc26f51da1450c5f24af032100ae58e605d45ebd0">PerformanceDetailType_BiquadFilter</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a43b8d931adba0b54dfc9570bfc26f51da3e10584b5320dbcf065a9d208cc52cec">PerformanceDetailType_Mix</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a43b8d931adba0b54dfc9570bfc26f51da90065cff31db0db16d5cbd59c7848c1e">PerformanceDetailType_Delay</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a43b8d931adba0b54dfc9570bfc26f51da75e9a1f2a2f12d9ba73bf2b82a2806d8">PerformanceDetailType_Aux</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a43b8d931adba0b54dfc9570bfc26f51da2736c4d9e4704741a16ecb70c149515c">PerformanceDetailType_Reverb</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a43b8d931adba0b54dfc9570bfc26f51da8c225b9ba32f7cba9ea0240ff906439b">PerformanceDetailType_I3dl2Reverb</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a43b8d931adba0b54dfc9570bfc26f51da1a846e9155fba75a29957f4bf03d28ed">PerformanceDetailType_PcmFloatDataSource</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a43b8d931adba0b54dfc9570bfc26f51da8844f663f073a5284f1813d740b2b301">PerformanceDetailType_LightLimiter</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a43b8d931adba0b54dfc9570bfc26f51da1b0a410539baf7a83c3514725df62a0e">PerformanceDetailType_Capture</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a43b8d931adba0b54dfc9570bfc26f51dacc02884567f0eda4c663db6cdfb3da53">PerformanceDetailType_Count</a>
<br />
 }</td></tr>
<tr class="memdesc:a43b8d931adba0b54dfc9570bfc26f51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated type representing the type of detailed performance information.  <a href="namespacenn_1_1audio.html#a43b8d931adba0b54dfc9570bfc26f51d">More...</a><br /></td></tr>
<tr class="separator:a43b8d931adba0b54dfc9570bfc26f51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101308636faebd9967ab60b4c662fa83"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a101308636faebd9967ab60b4c662fa83">PerformanceEntryType</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a101308636faebd9967ab60b4c662fa83ac4ad5dfa3b972835a5c81fb3c2d6736f">PerformanceEntryType_Unknown</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a101308636faebd9967ab60b4c662fa83ab52cc2884b2949cb44eee1d1f194aa39">PerformanceEntryType_Voice</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a101308636faebd9967ab60b4c662fa83a29ae09e6088ae9c9e0275dc114f3de6d">PerformanceEntryType_SubMix</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a101308636faebd9967ab60b4c662fa83a979fb5d1709225274fbc51761934404f">PerformanceEntryType_FinalMix</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a101308636faebd9967ab60b4c662fa83acf74b50354d447607276acf91cdbc42b">PerformanceEntryType_Sink</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a101308636faebd9967ab60b4c662fa83ad116d72c3ec479d39ed2b79526a3dcf8">PerformanceEntryType_Count</a>
<br />
 }</td></tr>
<tr class="memdesc:a101308636faebd9967ab60b4c662fa83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated type representing the type of performance information.  <a href="namespacenn_1_1audio.html#a101308636faebd9967ab60b4c662fa83">More...</a><br /></td></tr>
<tr class="separator:a101308636faebd9967ab60b4c662fa83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2edc363ab06840fc2eaf2acb551bf0c1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1">SampleFormat</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1a8728147897e0971a612c15b731457af5">SampleFormat_Invalid</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1ae983446e68d537f5194a65c3a66d40c7">SampleFormat_PcmInt8</a> = 1
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1a28ddfdb7464233b0bd4fa406aff3e31a">SampleFormat_PcmInt16</a> = 2
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1ab2d559fd9c854347e69b0b9fbb04e4e1">SampleFormat_PcmInt24</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1acac06db0dedb23848423a26eb4e18482">SampleFormat_PcmInt32</a> = 4
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1a9f815cfc16990e6afc2f53500516e1d5">SampleFormat_PcmFloat</a> = 5
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1ab78e0cfd4dc7851b77c0b4ad3c355a72">SampleFormat_Adpcm</a> = 6
<br />
 }</td></tr>
<tr class="memdesc:a2edc363ab06840fc2eaf2acb551bf0c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates the sample formats.  <a href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1">More...</a><br /></td></tr>
<tr class="separator:a2edc363ab06840fc2eaf2acb551bf0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a60295a8c5476bca95083daaa9cbf098d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a60295a8c5476bca95083daaa9cbf098d">GetAudioInDeviceGain</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *pAudioIn) noexcept</td></tr>
<tr class="memdesc:a60295a8c5476bca95083daaa9cbf098d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the device gain of the audio buffer.  <a href="namespacenn_1_1audio.html#a60295a8c5476bca95083daaa9cbf098d">More...</a><br /></td></tr>
<tr class="separator:a60295a8c5476bca95083daaa9cbf098d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcee810c22efb0dc1d65c3dc9197779"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aebcee810c22efb0dc1d65c3dc9197779">SetAudioInDeviceGain</a> (<a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *pAudioIn, float gain) noexcept</td></tr>
<tr class="memdesc:aebcee810c22efb0dc1d65c3dc9197779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the device gain for the audio input.  <a href="namespacenn_1_1audio.html#aebcee810c22efb0dc1d65c3dc9197779">More...</a><br /></td></tr>
<tr class="separator:aebcee810c22efb0dc1d65c3dc9197779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Other</div></td></tr>
<tr class="memitem:ab7e84ce4ddd07fd3e5fc45f2f7b82204"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ab7e84ce4ddd07fd3e5fc45f2f7b82204">ParseAdpcmHeader</a> (<a class="el" href="structnn_1_1audio_1_1_adpcm_header_info.html">AdpcmHeaderInfo</a> *pOutInfo, const void *header, std::size_t size) noexcept</td></tr>
<tr class="memdesc:ab7e84ce4ddd07fd3e5fc45f2f7b82204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyzes the ADPCM header information.  <a href="namespacenn_1_1audio.html#ab7e84ce4ddd07fd3e5fc45f2f7b82204">More...</a><br /></td></tr>
<tr class="separator:ab7e84ce4ddd07fd3e5fc45f2f7b82204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154b8f763869f00d19eb611df3434a77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a154b8f763869f00d19eb611df3434a77">GetActiveAudioOutputDeviceName</a> (<a class="el" href="structnn_1_1audio_1_1_audio_device_name.html">AudioDeviceName</a> *pOutDeviceName) noexcept</td></tr>
<tr class="memdesc:a154b8f763869f00d19eb611df3434a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of the device to which audio is currently being output.  <a href="namespacenn_1_1audio.html#a154b8f763869f00d19eb611df3434a77">More...</a><br /></td></tr>
<tr class="separator:a154b8f763869f00d19eb611df3434a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1dc98d9291c9b9a24a329000fe04b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#afc1dc98d9291c9b9a24a329000fe04b5">GetActiveAudioDeviceName</a> (<a class="el" href="structnn_1_1audio_1_1_audio_device_name.html">AudioDeviceName</a> *pOutDeviceName) noexcept</td></tr>
<tr class="memdesc:afc1dc98d9291c9b9a24a329000fe04b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is deprecated.  <a href="namespacenn_1_1audio.html#afc1dc98d9291c9b9a24a329000fe04b5">More...</a><br /></td></tr>
<tr class="separator:afc1dc98d9291c9b9a24a329000fe04b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb316babd47fa36c30a8d4747c64860a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#adb316babd47fa36c30a8d4747c64860a">AcquireAudioDeviceNotificationForOutput</a> (<a class="el" href="classnn_1_1os_1_1_system_event.html">nn::os::SystemEvent</a> *pOutSystemEvent) noexcept</td></tr>
<tr class="memdesc:adb316babd47fa36c30a8d4747c64860a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets events that provide notification of the occurrence of audio output device events.  <a href="namespacenn_1_1audio.html#adb316babd47fa36c30a8d4747c64860a">More...</a><br /></td></tr>
<tr class="separator:adb316babd47fa36c30a8d4747c64860a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa780020ea9e44b78f43a0ee8148f9569"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aa780020ea9e44b78f43a0ee8148f9569">AcquireAudioDeviceNotificationForInput</a> (<a class="el" href="classnn_1_1os_1_1_system_event.html">nn::os::SystemEvent</a> *pOutSystemEvent) noexcept</td></tr>
<tr class="memdesc:aa780020ea9e44b78f43a0ee8148f9569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets events that provide notification of the occurrence of events of the device that is the source of the audio input.  <a href="namespacenn_1_1audio.html#aa780020ea9e44b78f43a0ee8148f9569">More...</a><br /></td></tr>
<tr class="separator:aa780020ea9e44b78f43a0ee8148f9569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca25bfcda5285cd394b9abbb6149eb2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a3ca25bfcda5285cd394b9abbb6149eb2">GetActiveAudioDeviceChannelCountForOutput</a> () noexcept</td></tr>
<tr class="memdesc:a3ca25bfcda5285cd394b9abbb6149eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of channels output from the audio output device.  <a href="namespacenn_1_1audio.html#a3ca25bfcda5285cd394b9abbb6149eb2">More...</a><br /></td></tr>
<tr class="separator:a3ca25bfcda5285cd394b9abbb6149eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90597870d6de0b335ac9344f728a59b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ad90597870d6de0b335ac9344f728a59b">ListAudioOutputDeviceName</a> (<a class="el" href="structnn_1_1audio_1_1_audio_device_name.html">AudioDeviceName</a> *outDeviceNames, int count) noexcept</td></tr>
<tr class="memdesc:ad90597870d6de0b335ac9344f728a59b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the supported device list for the platform.  <a href="namespacenn_1_1audio.html#ad90597870d6de0b335ac9344f728a59b">More...</a><br /></td></tr>
<tr class="separator:ad90597870d6de0b335ac9344f728a59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55647cb74f20480d980354a8dc7f0907"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a55647cb74f20480d980354a8dc7f0907">ListAudioDeviceName</a> (<a class="el" href="structnn_1_1audio_1_1_audio_device_name.html">AudioDeviceName</a> *outDeviceNames, int count) noexcept</td></tr>
<tr class="memdesc:a55647cb74f20480d980354a8dc7f0907"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is deprecated.  <a href="namespacenn_1_1audio.html#a55647cb74f20480d980354a8dc7f0907">More...</a><br /></td></tr>
<tr class="separator:a55647cb74f20480d980354a8dc7f0907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fb7f5f687932689399a44c0da8d206"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a70fb7f5f687932689399a44c0da8d206">SetAudioDeviceOutputVolume</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_device_name.html">AudioDeviceName</a> *pDeviceName, float volume) noexcept</td></tr>
<tr class="memdesc:a70fb7f5f687932689399a44c0da8d206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the volume for the output destination device.  <a href="namespacenn_1_1audio.html#a70fb7f5f687932689399a44c0da8d206">More...</a><br /></td></tr>
<tr class="separator:a70fb7f5f687932689399a44c0da8d206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46f887f6bbd8c3ed7232932cb86ece0"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ae46f887f6bbd8c3ed7232932cb86ece0">GetAudioDeviceOutputVolume</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_device_name.html">AudioDeviceName</a> *pDeviceName) noexcept</td></tr>
<tr class="memdesc:ae46f887f6bbd8c3ed7232932cb86ece0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the volume of the output destination device.  <a href="namespacenn_1_1audio.html#ae46f887f6bbd8c3ed7232932cb86ece0">More...</a><br /></td></tr>
<tr class="separator:ae46f887f6bbd8c3ed7232932cb86ece0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3f2d72e87f3c1bcd8dafe7f1a5b301"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#acf3f2d72e87f3c1bcd8dafe7f1a5b301">SetAudioDeviceMapping</a> (const char *virtualName, const <a class="el" href="structnn_1_1audio_1_1_audio_device_name.html">AudioDeviceName</a> *pDeviceName) noexcept</td></tr>
<tr class="memdesc:acf3f2d72e87f3c1bcd8dafe7f1a5b301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns an actual audio device to a virtual audio device.  <a href="namespacenn_1_1audio.html#acf3f2d72e87f3c1bcd8dafe7f1a5b301">More...</a><br /></td></tr>
<tr class="separator:acf3f2d72e87f3c1bcd8dafe7f1a5b301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20de4a3eb5e5c4fba0f3b45e0b9e24c8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a20de4a3eb5e5c4fba0f3b45e0b9e24c8">GetSampleByteSize</a> (<a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1">SampleFormat</a> sampleFormat) noexcept</td></tr>
<tr class="memdesc:a20de4a3eb5e5c4fba0f3b45e0b9e24c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size in bytes of an audio sample represented by the specified sample format.  <a href="namespacenn_1_1audio.html#a20de4a3eb5e5c4fba0f3b45e0b9e24c8">More...</a><br /></td></tr>
<tr class="separator:a20de4a3eb5e5c4fba0f3b45e0b9e24c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Audio Input</div></td></tr>
<tr class="memitem:a183262306a7103d73852c3842af67e8a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a183262306a7103d73852c3842af67e8a">ListAudioIns</a> (<a class="el" href="structnn_1_1audio_1_1_audio_in_info.html">AudioInInfo</a> *outAudioIns, int count) noexcept</td></tr>
<tr class="memdesc:a183262306a7103d73852c3842af67e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a list of available audio inputs.  <a href="namespacenn_1_1audio.html#a183262306a7103d73852c3842af67e8a">More...</a><br /></td></tr>
<tr class="separator:a183262306a7103d73852c3842af67e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b8cea2511b7c0621fbaab18e2eb368"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ac7b8cea2511b7c0621fbaab18e2eb368">InitializeAudioInParameter</a> (<a class="el" href="structnn_1_1audio_1_1_audio_in_parameter.html">AudioInParameter</a> *pOutParameter) noexcept</td></tr>
<tr class="memdesc:ac7b8cea2511b7c0621fbaab18e2eb368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the audio input parameters.  <a href="namespacenn_1_1audio.html#ac7b8cea2511b7c0621fbaab18e2eb368">More...</a><br /></td></tr>
<tr class="separator:ac7b8cea2511b7c0621fbaab18e2eb368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1bfdd6f316ddd864046026095f83fcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ac1bfdd6f316ddd864046026095f83fcc">OpenDefaultAudioIn</a> (<a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *pOutAudioIn, const <a class="el" href="structnn_1_1audio_1_1_audio_in_parameter.html">AudioInParameter</a> &amp;parameter) noexcept</td></tr>
<tr class="memdesc:ac1bfdd6f316ddd864046026095f83fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the default audio input and gets an accessor.  <a href="namespacenn_1_1audio.html#ac1bfdd6f316ddd864046026095f83fcc">More...</a><br /></td></tr>
<tr class="separator:ac1bfdd6f316ddd864046026095f83fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ca7def0d62477aa4f20f27fd9c70c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#af6ca7def0d62477aa4f20f27fd9c70c6">OpenAudioIn</a> (<a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *pOutAudioIn, const char *name, const <a class="el" href="structnn_1_1audio_1_1_audio_in_parameter.html">AudioInParameter</a> &amp;parameter) noexcept</td></tr>
<tr class="memdesc:af6ca7def0d62477aa4f20f27fd9c70c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the audio input specified in <code><em>name</em></code> and gets an accessor.  <a href="namespacenn_1_1audio.html#af6ca7def0d62477aa4f20f27fd9c70c6">More...</a><br /></td></tr>
<tr class="separator:af6ca7def0d62477aa4f20f27fd9c70c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9b579f0edf49dfce4ea62938317b06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aea9b579f0edf49dfce4ea62938317b06">CloseAudioIn</a> (<a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *pAudioIn) noexcept</td></tr>
<tr class="memdesc:aea9b579f0edf49dfce4ea62938317b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the audio input and destroys the accessor.  <a href="namespacenn_1_1audio.html#aea9b579f0edf49dfce4ea62938317b06">More...</a><br /></td></tr>
<tr class="separator:aea9b579f0edf49dfce4ea62938317b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72d3c3851733f838d4c7e72a26b307d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#af72d3c3851733f838d4c7e72a26b307d">StartAudioIn</a> (<a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *pAudioIn) noexcept</td></tr>
<tr class="memdesc:af72d3c3851733f838d4c7e72a26b307d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts recording a waveform from an audio input.  <a href="namespacenn_1_1audio.html#af72d3c3851733f838d4c7e72a26b307d">More...</a><br /></td></tr>
<tr class="separator:af72d3c3851733f838d4c7e72a26b307d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29049cc380b643521d79d058a62d9e93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a29049cc380b643521d79d058a62d9e93">StopAudioIn</a> (<a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *pAudioIn) noexcept</td></tr>
<tr class="memdesc:a29049cc380b643521d79d058a62d9e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops recording a waveform from an audio input.  <a href="namespacenn_1_1audio.html#a29049cc380b643521d79d058a62d9e93">More...</a><br /></td></tr>
<tr class="separator:a29049cc380b643521d79d058a62d9e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8b6791e28759f30e546c086d02fb61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1audio.html#a0a1874bce5c774a70d6e980790392ffa">AudioInState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a4d8b6791e28759f30e546c086d02fb61">GetAudioInState</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *pAudioIn) noexcept</td></tr>
<tr class="memdesc:a4d8b6791e28759f30e546c086d02fb61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the state of an audio input.  <a href="namespacenn_1_1audio.html#a4d8b6791e28759f30e546c086d02fb61">More...</a><br /></td></tr>
<tr class="separator:a4d8b6791e28759f30e546c086d02fb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407bc1b8e97beb48934527f57893dc16"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a407bc1b8e97beb48934527f57893dc16">GetAudioInName</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *pAudioIn) noexcept</td></tr>
<tr class="memdesc:a407bc1b8e97beb48934527f57893dc16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of an audio input.  <a href="namespacenn_1_1audio.html#a407bc1b8e97beb48934527f57893dc16">More...</a><br /></td></tr>
<tr class="separator:a407bc1b8e97beb48934527f57893dc16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba56b33544577ad7773c54b6a44107bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aba56b33544577ad7773c54b6a44107bb">GetAudioInSampleRate</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *pAudioIn) noexcept</td></tr>
<tr class="memdesc:aba56b33544577ad7773c54b6a44107bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sampling rate of an audio input.  <a href="namespacenn_1_1audio.html#aba56b33544577ad7773c54b6a44107bb">More...</a><br /></td></tr>
<tr class="separator:aba56b33544577ad7773c54b6a44107bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09a8952d37766dd6ea7cec4e4d1618e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ae09a8952d37766dd6ea7cec4e4d1618e">GetAudioInChannelCount</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *pAudioIn) noexcept</td></tr>
<tr class="memdesc:ae09a8952d37766dd6ea7cec4e4d1618e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of channels of an audio input.  <a href="namespacenn_1_1audio.html#ae09a8952d37766dd6ea7cec4e4d1618e">More...</a><br /></td></tr>
<tr class="separator:ae09a8952d37766dd6ea7cec4e4d1618e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7601ac0b7d81fb3f867c8f63165cdab6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1">SampleFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a7601ac0b7d81fb3f867c8f63165cdab6">GetAudioInSampleFormat</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *pAudioIn) noexcept</td></tr>
<tr class="memdesc:a7601ac0b7d81fb3f867c8f63165cdab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sample format of an audio input.  <a href="namespacenn_1_1audio.html#a7601ac0b7d81fb3f867c8f63165cdab6">More...</a><br /></td></tr>
<tr class="separator:a7601ac0b7d81fb3f867c8f63165cdab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ebc560c7c9cb913c9df8c40fceaeca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aa9ebc560c7c9cb913c9df8c40fceaeca">SetAudioInBufferInfo</a> (<a class="el" href="structnn_1_1audio_1_1_audio_in_buffer.html">AudioInBuffer</a> *pOutAudioInBuffer, void *buffer, size_t bufferSize, size_t dataSize) noexcept</td></tr>
<tr class="memdesc:aa9ebc560c7c9cb913c9df8c40fceaeca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets information in an audio input buffer.  <a href="namespacenn_1_1audio.html#aa9ebc560c7c9cb913c9df8c40fceaeca">More...</a><br /></td></tr>
<tr class="separator:aa9ebc560c7c9cb913c9df8c40fceaeca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5fe3dfc47ec857f420675315f4f468d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ae5fe3dfc47ec857f420675315f4f468d">GetAudioInBufferDataPointer</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_in_buffer.html">AudioInBuffer</a> *pAudioInBuffer) noexcept</td></tr>
<tr class="memdesc:ae5fe3dfc47ec857f420675315f4f468d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to the data buffer in an audio input buffer.  <a href="namespacenn_1_1audio.html#ae5fe3dfc47ec857f420675315f4f468d">More...</a><br /></td></tr>
<tr class="separator:ae5fe3dfc47ec857f420675315f4f468d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25eff7af269116b7d12e27a57eac2e7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ab25eff7af269116b7d12e27a57eac2e7">GetAudioInBufferBufferSize</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_in_buffer.html">AudioInBuffer</a> *pAudioInBuffer) noexcept</td></tr>
<tr class="memdesc:ab25eff7af269116b7d12e27a57eac2e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the data buffer in an audio input buffer.  <a href="namespacenn_1_1audio.html#ab25eff7af269116b7d12e27a57eac2e7">More...</a><br /></td></tr>
<tr class="separator:ab25eff7af269116b7d12e27a57eac2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9e4271b6f713c2f0fee3e3dcdc1684"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a0e9e4271b6f713c2f0fee3e3dcdc1684">GetAudioInBufferDataSize</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_in_buffer.html">AudioInBuffer</a> *pAudioInBuffer) noexcept</td></tr>
<tr class="memdesc:a0e9e4271b6f713c2f0fee3e3dcdc1684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of data to input in the audio input buffer.  <a href="namespacenn_1_1audio.html#a0e9e4271b6f713c2f0fee3e3dcdc1684">More...</a><br /></td></tr>
<tr class="separator:a0e9e4271b6f713c2f0fee3e3dcdc1684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c217d690202ef43230d4409852f3c1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a2c217d690202ef43230d4409852f3c1d">AppendAudioInBuffer</a> (<a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *pAudioIn, <a class="el" href="structnn_1_1audio_1_1_audio_in_buffer.html">AudioInBuffer</a> *pAudioInBuffer) noexcept</td></tr>
<tr class="memdesc:a2c217d690202ef43230d4409852f3c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers an audio input buffer.  <a href="namespacenn_1_1audio.html#a2c217d690202ef43230d4409852f3c1d">More...</a><br /></td></tr>
<tr class="separator:a2c217d690202ef43230d4409852f3c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe3341bdd916299f38a8eaa2c8de534"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1audio_1_1_audio_in_buffer.html">AudioInBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a4fe3341bdd916299f38a8eaa2c8de534">GetReleasedAudioInBuffer</a> (<a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *pAudioIn) noexcept</td></tr>
<tr class="memdesc:a4fe3341bdd916299f38a8eaa2c8de534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an audio input buffer that has already been recorded to.  <a href="namespacenn_1_1audio.html#a4fe3341bdd916299f38a8eaa2c8de534">More...</a><br /></td></tr>
<tr class="separator:a4fe3341bdd916299f38a8eaa2c8de534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae347a7d7697820e65d72b0b325e10037"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ae347a7d7697820e65d72b0b325e10037">ContainsAudioInBuffer</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *pAudioIn, const <a class="el" href="structnn_1_1audio_1_1_audio_in_buffer.html">AudioInBuffer</a> *pAudioInBuffer) noexcept</td></tr>
<tr class="memdesc:ae347a7d7697820e65d72b0b325e10037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether an <code><a class="el" href="structnn_1_1audio_1_1_audio_in_buffer.html" title="Structure representing an audio input buffer.">AudioInBuffer</a></code> object was appended to an <code><a class="el" href="structnn_1_1audio_1_1_audio_in.html" title="Structure for managing an audio input.">AudioIn</a></code> object.  <a href="namespacenn_1_1audio.html#ae347a7d7697820e65d72b0b325e10037">More...</a><br /></td></tr>
<tr class="separator:ae347a7d7697820e65d72b0b325e10037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b6d6a72d7e98f3f25a6c43ae526849"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a21b6d6a72d7e98f3f25a6c43ae526849">OpenDefaultAudioIn</a> (<a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *pOutAudioIn, <a class="el" href="classnn_1_1os_1_1_system_event.html">nn::os::SystemEvent</a> *pOutSystemEvent, const <a class="el" href="structnn_1_1audio_1_1_audio_in_parameter.html">AudioInParameter</a> &amp;parameter) noexcept</td></tr>
<tr class="memdesc:a21b6d6a72d7e98f3f25a6c43ae526849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the default audio input, gets an accessor, and initializes a synchronization object for notification purposes.  <a href="namespacenn_1_1audio.html#a21b6d6a72d7e98f3f25a6c43ae526849">More...</a><br /></td></tr>
<tr class="separator:a21b6d6a72d7e98f3f25a6c43ae526849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9339dcb48c7d40b47f4852df0c9fe073"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a9339dcb48c7d40b47f4852df0c9fe073">OpenAudioIn</a> (<a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *pOutAudioIn, <a class="el" href="classnn_1_1os_1_1_system_event.html">nn::os::SystemEvent</a> *pOutSystemEvent, const char *name, const <a class="el" href="structnn_1_1audio_1_1_audio_in_parameter.html">AudioInParameter</a> &amp;parameter) noexcept</td></tr>
<tr class="memdesc:a9339dcb48c7d40b47f4852df0c9fe073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the audio input specified by <code><em>name</em></code>, gets an accessor, and initializes a synchronization object for notification purposes.  <a href="namespacenn_1_1audio.html#a9339dcb48c7d40b47f4852df0c9fe073">More...</a><br /></td></tr>
<tr class="separator:a9339dcb48c7d40b47f4852df0c9fe073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab496656f1bdaf174b87be48862e1096c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ab496656f1bdaf174b87be48862e1096c">GetAudioInBufferCount</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *pAudioIn) noexcept</td></tr>
<tr class="memdesc:ab496656f1bdaf174b87be48862e1096c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of audio input buffers registered in <code><a class="el" href="structnn_1_1audio_1_1_audio_in.html" title="Structure for managing an audio input.">AudioIn</a></code>.  <a href="namespacenn_1_1audio.html#ab496656f1bdaf174b87be48862e1096c">More...</a><br /></td></tr>
<tr class="separator:ab496656f1bdaf174b87be48862e1096c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d7d49b6b4b6337313bd32001814bfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#af1d7d49b6b4b6337313bd32001814bfa">FlushAudioInBuffers</a> (<a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *pAudioIn) noexcept</td></tr>
<tr class="memdesc:af1d7d49b6b4b6337313bd32001814bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records to all audio input buffers registered to <code><a class="el" href="structnn_1_1audio_1_1_audio_in.html" title="Structure for managing an audio input.">AudioIn</a></code> that have not been recorded to.  <a href="namespacenn_1_1audio.html#af1d7d49b6b4b6337313bd32001814bfa">More...</a><br /></td></tr>
<tr class="separator:af1d7d49b6b4b6337313bd32001814bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Audio Output</div></td></tr>
<tr class="memitem:a498ae2617b91a690e130c9dfc21483d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a498ae2617b91a690e130c9dfc21483d6">ListAudioOuts</a> (<a class="el" href="structnn_1_1audio_1_1_audio_out_info.html">AudioOutInfo</a> *outAudioOuts, int count) noexcept</td></tr>
<tr class="memdesc:a498ae2617b91a690e130c9dfc21483d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a list of available audio outputs.  <a href="namespacenn_1_1audio.html#a498ae2617b91a690e130c9dfc21483d6">More...</a><br /></td></tr>
<tr class="separator:a498ae2617b91a690e130c9dfc21483d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53eb3602be04d214fd6973fa4b63e637"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a53eb3602be04d214fd6973fa4b63e637">InitializeAudioOutParameter</a> (<a class="el" href="structnn_1_1audio_1_1_audio_out_parameter.html">AudioOutParameter</a> *pOutParameter) noexcept</td></tr>
<tr class="memdesc:a53eb3602be04d214fd6973fa4b63e637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the audio output parameters.  <a href="namespacenn_1_1audio.html#a53eb3602be04d214fd6973fa4b63e637">More...</a><br /></td></tr>
<tr class="separator:a53eb3602be04d214fd6973fa4b63e637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4ddedf1f043b725b4e3a5236a05417"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a7d4ddedf1f043b725b4e3a5236a05417">OpenDefaultAudioOut</a> (<a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *pOutAudioOut, const <a class="el" href="structnn_1_1audio_1_1_audio_out_parameter.html">AudioOutParameter</a> &amp;parameter) noexcept</td></tr>
<tr class="memdesc:a7d4ddedf1f043b725b4e3a5236a05417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the default audio output and gets an accessor.  <a href="namespacenn_1_1audio.html#a7d4ddedf1f043b725b4e3a5236a05417">More...</a><br /></td></tr>
<tr class="separator:a7d4ddedf1f043b725b4e3a5236a05417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5db3e97ec537448f1d916cbb97453f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ab5db3e97ec537448f1d916cbb97453f3">OpenDefaultAudioOut</a> (<a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *pOutAudioOut, <a class="el" href="classnn_1_1os_1_1_system_event.html">nn::os::SystemEvent</a> *pOutSystemEvent, const <a class="el" href="structnn_1_1audio_1_1_audio_out_parameter.html">AudioOutParameter</a> &amp;parameter) noexcept</td></tr>
<tr class="memdesc:ab5db3e97ec537448f1d916cbb97453f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the default audio output, gets an accessor, and initializes a synchronization object for notification purposes.  <a href="namespacenn_1_1audio.html#ab5db3e97ec537448f1d916cbb97453f3">More...</a><br /></td></tr>
<tr class="separator:ab5db3e97ec537448f1d916cbb97453f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6028627437e481cb9c0b3a3f49ac280"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aa6028627437e481cb9c0b3a3f49ac280">OpenAudioOut</a> (<a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *pOutAudioOut, const char *name, const <a class="el" href="structnn_1_1audio_1_1_audio_out_parameter.html">AudioOutParameter</a> &amp;parameter) noexcept</td></tr>
<tr class="memdesc:aa6028627437e481cb9c0b3a3f49ac280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the audio output specified in <code><em>name</em></code> and gets an accessor.  <a href="namespacenn_1_1audio.html#aa6028627437e481cb9c0b3a3f49ac280">More...</a><br /></td></tr>
<tr class="separator:aa6028627437e481cb9c0b3a3f49ac280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e936ca301d0c9363975a4bfc837ea4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a23e936ca301d0c9363975a4bfc837ea4">OpenAudioOut</a> (<a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *pOutAudioOut, <a class="el" href="classnn_1_1os_1_1_system_event.html">nn::os::SystemEvent</a> *pOutSystemEvent, const char *name, const <a class="el" href="structnn_1_1audio_1_1_audio_out_parameter.html">AudioOutParameter</a> &amp;parameter) noexcept</td></tr>
<tr class="memdesc:a23e936ca301d0c9363975a4bfc837ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the audio output specified by <code><em>name</em></code>, gets an accessor, and initializes a synchronization object for notification purposes.  <a href="namespacenn_1_1audio.html#a23e936ca301d0c9363975a4bfc837ea4">More...</a><br /></td></tr>
<tr class="separator:a23e936ca301d0c9363975a4bfc837ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abecd28c6321841cde54d0d16a8800da4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#abecd28c6321841cde54d0d16a8800da4">CloseAudioOut</a> (<a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *pAudioOut) noexcept</td></tr>
<tr class="memdesc:abecd28c6321841cde54d0d16a8800da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the audio output and destroys the accessor.  <a href="namespacenn_1_1audio.html#abecd28c6321841cde54d0d16a8800da4">More...</a><br /></td></tr>
<tr class="separator:abecd28c6321841cde54d0d16a8800da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa522149d7a0b48763dd5c1eb32609505"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aa522149d7a0b48763dd5c1eb32609505">StartAudioOut</a> (<a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *pAudioOut) noexcept</td></tr>
<tr class="memdesc:aa522149d7a0b48763dd5c1eb32609505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts playing a waveform from an audio output.  <a href="namespacenn_1_1audio.html#aa522149d7a0b48763dd5c1eb32609505">More...</a><br /></td></tr>
<tr class="separator:aa522149d7a0b48763dd5c1eb32609505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad908ac057d85fa7d4d4c4f047edc6c4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ad908ac057d85fa7d4d4c4f047edc6c4d">StopAudioOut</a> (<a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *pAudioOut) noexcept</td></tr>
<tr class="memdesc:ad908ac057d85fa7d4d4c4f047edc6c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops playing a waveform from an audio output.  <a href="namespacenn_1_1audio.html#ad908ac057d85fa7d4d4c4f047edc6c4d">More...</a><br /></td></tr>
<tr class="separator:ad908ac057d85fa7d4d4c4f047edc6c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378f44305f3e9d304073d5fd3bb5c8e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1audio.html#ad6dfba2e7415ea48852b3f07216f2f31">AudioOutState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a378f44305f3e9d304073d5fd3bb5c8e5">GetAudioOutState</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *pAudioOut) noexcept</td></tr>
<tr class="memdesc:a378f44305f3e9d304073d5fd3bb5c8e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the playback state of an audio output.  <a href="namespacenn_1_1audio.html#a378f44305f3e9d304073d5fd3bb5c8e5">More...</a><br /></td></tr>
<tr class="separator:a378f44305f3e9d304073d5fd3bb5c8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c895123269f19a2d9cf15160ead920"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a43c895123269f19a2d9cf15160ead920">GetAudioOutName</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *pAudioOut) noexcept</td></tr>
<tr class="memdesc:a43c895123269f19a2d9cf15160ead920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of an audio output.  <a href="namespacenn_1_1audio.html#a43c895123269f19a2d9cf15160ead920">More...</a><br /></td></tr>
<tr class="separator:a43c895123269f19a2d9cf15160ead920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e4f07c8ed98d958ec79532f5962b96"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a48e4f07c8ed98d958ec79532f5962b96">GetAudioOutSampleRate</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *pAudioOut) noexcept</td></tr>
<tr class="memdesc:a48e4f07c8ed98d958ec79532f5962b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sampling rate of an audio output.  <a href="namespacenn_1_1audio.html#a48e4f07c8ed98d958ec79532f5962b96">More...</a><br /></td></tr>
<tr class="separator:a48e4f07c8ed98d958ec79532f5962b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5ea724a3c41100cce1fbd7b031b64e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aae5ea724a3c41100cce1fbd7b031b64e">GetAudioOutChannelCount</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *pAudioOut) noexcept</td></tr>
<tr class="memdesc:aae5ea724a3c41100cce1fbd7b031b64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of channels of an audio output.  <a href="namespacenn_1_1audio.html#aae5ea724a3c41100cce1fbd7b031b64e">More...</a><br /></td></tr>
<tr class="separator:aae5ea724a3c41100cce1fbd7b031b64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36250ba99a54f2adbd9bd993f63fc4b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1">SampleFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a36250ba99a54f2adbd9bd993f63fc4b4">GetAudioOutSampleFormat</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *pAudioOut) noexcept</td></tr>
<tr class="memdesc:a36250ba99a54f2adbd9bd993f63fc4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sample format of an audio output.  <a href="namespacenn_1_1audio.html#a36250ba99a54f2adbd9bd993f63fc4b4">More...</a><br /></td></tr>
<tr class="separator:a36250ba99a54f2adbd9bd993f63fc4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ffe215f031b4b64e1cce6fe195b5c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aa1ffe215f031b4b64e1cce6fe195b5c4">SetAudioOutBufferInfo</a> (<a class="el" href="structnn_1_1audio_1_1_audio_out_buffer.html">AudioOutBuffer</a> *pOutAudioOutBuffer, void *buffer, size_t bufferSize, size_t dataSize) noexcept</td></tr>
<tr class="memdesc:aa1ffe215f031b4b64e1cce6fe195b5c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets information in an audio output buffer.  <a href="namespacenn_1_1audio.html#aa1ffe215f031b4b64e1cce6fe195b5c4">More...</a><br /></td></tr>
<tr class="separator:aa1ffe215f031b4b64e1cce6fe195b5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60d0ae60bafcbf7b3baae780efcce77"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ac60d0ae60bafcbf7b3baae780efcce77">GetAudioOutBufferDataPointer</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_out_buffer.html">AudioOutBuffer</a> *pAudioOutBuffer) noexcept</td></tr>
<tr class="memdesc:ac60d0ae60bafcbf7b3baae780efcce77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to the data buffer in an audio output buffer.  <a href="namespacenn_1_1audio.html#ac60d0ae60bafcbf7b3baae780efcce77">More...</a><br /></td></tr>
<tr class="separator:ac60d0ae60bafcbf7b3baae780efcce77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2b4696c057fbbc45b88c8020c0028a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a8f2b4696c057fbbc45b88c8020c0028a">GetAudioOutBufferBufferSize</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_out_buffer.html">AudioOutBuffer</a> *pAudioOutBuffer) noexcept</td></tr>
<tr class="memdesc:a8f2b4696c057fbbc45b88c8020c0028a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the data buffer in an audio output buffer.  <a href="namespacenn_1_1audio.html#a8f2b4696c057fbbc45b88c8020c0028a">More...</a><br /></td></tr>
<tr class="separator:a8f2b4696c057fbbc45b88c8020c0028a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163daf352ea5548b5b9601db735f260c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a163daf352ea5548b5b9601db735f260c">GetAudioOutBufferDataSize</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_out_buffer.html">AudioOutBuffer</a> *pAudioOutBuffer) noexcept</td></tr>
<tr class="memdesc:a163daf352ea5548b5b9601db735f260c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of data to play in the audio output buffer.  <a href="namespacenn_1_1audio.html#a163daf352ea5548b5b9601db735f260c">More...</a><br /></td></tr>
<tr class="separator:a163daf352ea5548b5b9601db735f260c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6ae7da062359e04d32ec1ec51b84a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#adf6ae7da062359e04d32ec1ec51b84a0">AppendAudioOutBuffer</a> (<a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *pAudioOut, <a class="el" href="structnn_1_1audio_1_1_audio_out_buffer.html">AudioOutBuffer</a> *pAudioOutBuffer) noexcept</td></tr>
<tr class="memdesc:adf6ae7da062359e04d32ec1ec51b84a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers an audio output buffer.  <a href="namespacenn_1_1audio.html#adf6ae7da062359e04d32ec1ec51b84a0">More...</a><br /></td></tr>
<tr class="separator:adf6ae7da062359e04d32ec1ec51b84a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf1c9d96a5761b3dca59f7f13155ad8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1audio_1_1_audio_out_buffer.html">AudioOutBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a9bf1c9d96a5761b3dca59f7f13155ad8">GetReleasedAudioOutBuffer</a> (<a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *pAudioOut) noexcept</td></tr>
<tr class="memdesc:a9bf1c9d96a5761b3dca59f7f13155ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an audio output buffer that has already been played.  <a href="namespacenn_1_1audio.html#a9bf1c9d96a5761b3dca59f7f13155ad8">More...</a><br /></td></tr>
<tr class="separator:a9bf1c9d96a5761b3dca59f7f13155ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1502f99ce36793793ff4f397e6b66dac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a1502f99ce36793793ff4f397e6b66dac">ContainsAudioOutBuffer</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *pAudioOut, const <a class="el" href="structnn_1_1audio_1_1_audio_out_buffer.html">AudioOutBuffer</a> *pAudioOutBuffer) noexcept</td></tr>
<tr class="memdesc:a1502f99ce36793793ff4f397e6b66dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether an <code><a class="el" href="structnn_1_1audio_1_1_audio_out_buffer.html" title="Structure representing an audio output buffer.">AudioOutBuffer</a></code> object was appended to an <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code> object.  <a href="namespacenn_1_1audio.html#a1502f99ce36793793ff4f397e6b66dac">More...</a><br /></td></tr>
<tr class="separator:a1502f99ce36793793ff4f397e6b66dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79170ba08007d9d5692a07ad5a0af18b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a79170ba08007d9d5692a07ad5a0af18b">GetAudioOutBufferCount</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *pAudioOut) noexcept</td></tr>
<tr class="memdesc:a79170ba08007d9d5692a07ad5a0af18b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of audio output buffers registered to <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code>.  <a href="namespacenn_1_1audio.html#a79170ba08007d9d5692a07ad5a0af18b">More...</a><br /></td></tr>
<tr class="separator:a79170ba08007d9d5692a07ad5a0af18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab131bfe56aeb5b9fbb7cb45495226837"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ab131bfe56aeb5b9fbb7cb45495226837">GetAudioOutPlayedSampleCount</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_out.html">nn::audio::AudioOut</a> *pAudioOut) noexcept</td></tr>
<tr class="memdesc:ab131bfe56aeb5b9fbb7cb45495226837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of samples of the data played back by <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code>.  <a href="namespacenn_1_1audio.html#ab131bfe56aeb5b9fbb7cb45495226837">More...</a><br /></td></tr>
<tr class="separator:ab131bfe56aeb5b9fbb7cb45495226837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177e0933097148ce854aa90a65e503ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a177e0933097148ce854aa90a65e503ae">FlushAudioOutBuffers</a> (<a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *pAudioOut) noexcept</td></tr>
<tr class="memdesc:a177e0933097148ce854aa90a65e503ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all of the unplayed audio output buffers registered in <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code> to played.  <a href="namespacenn_1_1audio.html#a177e0933097148ce854aa90a65e503ae">More...</a><br /></td></tr>
<tr class="separator:a177e0933097148ce854aa90a65e503ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9768fb1e31dd0bcf4c28a4e7dae42da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ac9768fb1e31dd0bcf4c28a4e7dae42da">SetAudioOutVolume</a> (<a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *pAudioOut, float volume) noexcept</td></tr>
<tr class="memdesc:ac9768fb1e31dd0bcf4c28a4e7dae42da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the volume for <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code>.  <a href="namespacenn_1_1audio.html#ac9768fb1e31dd0bcf4c28a4e7dae42da">More...</a><br /></td></tr>
<tr class="separator:ac9768fb1e31dd0bcf4c28a4e7dae42da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3d2c5ebd83da79959162eca6272510"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aaf3d2c5ebd83da79959162eca6272510">GetAudioOutVolume</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *pAudioOut) noexcept</td></tr>
<tr class="memdesc:aaf3d2c5ebd83da79959162eca6272510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the volume of the <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code> object.  <a href="namespacenn_1_1audio.html#aaf3d2c5ebd83da79959162eca6272510">More...</a><br /></td></tr>
<tr class="separator:aaf3d2c5ebd83da79959162eca6272510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Audio Renderer Sample</div></td></tr>
<tr class="memitem:a9eaff763648679c45d3360d717e28618"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a9eaff763648679c45d3360d717e28618">InitializeAudioRendererParameter</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html">AudioRendererParameter</a> *pOutParameter) noexcept</td></tr>
<tr class="memdesc:a9eaff763648679c45d3360d717e28618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the audio renderer parameters.  <a href="namespacenn_1_1audio.html#a9eaff763648679c45d3360d717e28618">More...</a><br /></td></tr>
<tr class="separator:a9eaff763648679c45d3360d717e28618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42518470ed50c8dd6b1395f3c55efeae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a42518470ed50c8dd6b1395f3c55efeae">IsValidAudioRendererParameter</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html">AudioRendererParameter</a> &amp;parameter) noexcept</td></tr>
<tr class="memdesc:a42518470ed50c8dd6b1395f3c55efeae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the audio renderer parameter is valid.  <a href="namespacenn_1_1audio.html#a42518470ed50c8dd6b1395f3c55efeae">More...</a><br /></td></tr>
<tr class="separator:a42518470ed50c8dd6b1395f3c55efeae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306899c2641a5b13daf5680a6f5d6430"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a306899c2641a5b13daf5680a6f5d6430">GetAudioRendererConfigWorkBufferSize</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html">AudioRendererParameter</a> &amp;parameter) noexcept</td></tr>
<tr class="memdesc:a306899c2641a5b13daf5680a6f5d6430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the work buffer required to initialize <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code>.  <a href="namespacenn_1_1audio.html#a306899c2641a5b13daf5680a6f5d6430">More...</a><br /></td></tr>
<tr class="separator:a306899c2641a5b13daf5680a6f5d6430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc7ed6656395abc8493f13abe2d04d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a0fc7ed6656395abc8493f13abe2d04d0">InitializeAudioRendererConfig</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, const <a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html">AudioRendererParameter</a> &amp;parameter, void *buffer, size_t size) noexcept</td></tr>
<tr class="memdesc:a0fc7ed6656395abc8493f13abe2d04d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize <a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a>.  <a href="namespacenn_1_1audio.html#a0fc7ed6656395abc8493f13abe2d04d0">More...</a><br /></td></tr>
<tr class="separator:a0fc7ed6656395abc8493f13abe2d04d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e81d1f5281360daa5ca6e4d55912607"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a2e81d1f5281360daa5ca6e4d55912607">SetAudioRendererExclusiveControlLeakageCheckEnabled</a> (bool enabled) noexcept</td></tr>
<tr class="memdesc:a2e81d1f5281360daa5ca6e4d55912607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables mutual exclusion error detection functionality when using the audio renderer.  <a href="namespacenn_1_1audio.html#a2e81d1f5281360daa5ca6e4d55912607">More...</a><br /></td></tr>
<tr class="separator:a2e81d1f5281360daa5ca6e4d55912607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963d645d0bd91e1543144dad88a78050"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a963d645d0bd91e1543144dad88a78050">IsAudioRendererExclusiveControlLeakageCheckEnabled</a> () noexcept</td></tr>
<tr class="memdesc:a963d645d0bd91e1543144dad88a78050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the enabled status of the mutual exclusion error detection functionality when using the audio renderer.  <a href="namespacenn_1_1audio.html#a963d645d0bd91e1543144dad88a78050">More...</a><br /></td></tr>
<tr class="separator:a963d645d0bd91e1543144dad88a78050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276f9c79640dbd5d6b8c15bd53c69f93"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a276f9c79640dbd5d6b8c15bd53c69f93">GetAudioRendererElapsedFrameCount</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pConfig) noexcept</td></tr>
<tr class="memdesc:a276f9c79640dbd5d6b8c15bd53c69f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of frames that have elapsed in the audio renderer.  <a href="namespacenn_1_1audio.html#a276f9c79640dbd5d6b8c15bd53c69f93">More...</a><br /></td></tr>
<tr class="separator:a276f9c79640dbd5d6b8c15bd53c69f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Audio Renderer</div></td></tr>
<tr class="memitem:a855da5a3e7dd33233c653a7dd2db775a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a855da5a3e7dd33233c653a7dd2db775a">OpenAudioRenderer</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_handle.html">AudioRendererHandle</a> *outHandle, const <a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html">AudioRendererParameter</a> &amp;parameter, void *workBuffer, size_t workBufferSize) noexcept</td></tr>
<tr class="memdesc:a855da5a3e7dd33233c653a7dd2db775a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the audio renderer.  <a href="namespacenn_1_1audio.html#a855da5a3e7dd33233c653a7dd2db775a">More...</a><br /></td></tr>
<tr class="separator:a855da5a3e7dd33233c653a7dd2db775a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3a5802629c5486c62bf7984ff5f438"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a3f3a5802629c5486c62bf7984ff5f438">OpenAudioRenderer</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_handle.html">AudioRendererHandle</a> *outHandle, <a class="el" href="classnn_1_1os_1_1_system_event.html">nn::os::SystemEvent</a> *pOutSystemEvent, const <a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html">AudioRendererParameter</a> &amp;parameter, void *workBuffer, size_t workBufferSize) noexcept</td></tr>
<tr class="memdesc:a3f3a5802629c5486c62bf7984ff5f438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the audio renderer and initializes the synchronization object for notification purposes.  <a href="namespacenn_1_1audio.html#a3f3a5802629c5486c62bf7984ff5f438">More...</a><br /></td></tr>
<tr class="separator:a3f3a5802629c5486c62bf7984ff5f438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac008e23e04fb6c5efbb8796dd2aa9f38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ac008e23e04fb6c5efbb8796dd2aa9f38">CloseAudioRenderer</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_handle.html">AudioRendererHandle</a> handle) noexcept</td></tr>
<tr class="memdesc:ac008e23e04fb6c5efbb8796dd2aa9f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the audio renderer.  <a href="namespacenn_1_1audio.html#ac008e23e04fb6c5efbb8796dd2aa9f38">More...</a><br /></td></tr>
<tr class="separator:ac008e23e04fb6c5efbb8796dd2aa9f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0345ad13fb013d06f6cdb812a0a6fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a2c0345ad13fb013d06f6cdb812a0a6fd">StartAudioRenderer</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_handle.html">AudioRendererHandle</a> handle) noexcept</td></tr>
<tr class="memdesc:a2c0345ad13fb013d06f6cdb812a0a6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts rendering with the audio renderer.  <a href="namespacenn_1_1audio.html#a2c0345ad13fb013d06f6cdb812a0a6fd">More...</a><br /></td></tr>
<tr class="separator:a2c0345ad13fb013d06f6cdb812a0a6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7590b47d3fcdb9d6b48d1b41184336a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a7590b47d3fcdb9d6b48d1b41184336a6">StopAudioRenderer</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_handle.html">AudioRendererHandle</a> handle) noexcept</td></tr>
<tr class="memdesc:a7590b47d3fcdb9d6b48d1b41184336a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops rendering with the audio renderer.  <a href="namespacenn_1_1audio.html#a7590b47d3fcdb9d6b48d1b41184336a6">More...</a><br /></td></tr>
<tr class="separator:a7590b47d3fcdb9d6b48d1b41184336a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ee6f076a7eb80a0fc937c42d41e652"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a25ee6f076a7eb80a0fc937c42d41e652">GetAudioRendererSampleRate</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_handle.html">AudioRendererHandle</a> handle) noexcept</td></tr>
<tr class="memdesc:a25ee6f076a7eb80a0fc937c42d41e652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sampling rate of the audio renderer processing.  <a href="namespacenn_1_1audio.html#a25ee6f076a7eb80a0fc937c42d41e652">More...</a><br /></td></tr>
<tr class="separator:a25ee6f076a7eb80a0fc937c42d41e652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4185f6faa85bc692ceed25c3e62eb3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#abf4185f6faa85bc692ceed25c3e62eb3">GetAudioRendererSampleCount</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_handle.html">AudioRendererHandle</a> handle) noexcept</td></tr>
<tr class="memdesc:abf4185f6faa85bc692ceed25c3e62eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of audio renderer mix buffer samples.  <a href="namespacenn_1_1audio.html#abf4185f6faa85bc692ceed25c3e62eb3">More...</a><br /></td></tr>
<tr class="separator:abf4185f6faa85bc692ceed25c3e62eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8544bdfe35b41171afecfd38eabcdc24"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a8544bdfe35b41171afecfd38eabcdc24">GetAudioRendererMixBufferCount</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_handle.html">AudioRendererHandle</a> handle) noexcept</td></tr>
<tr class="memdesc:a8544bdfe35b41171afecfd38eabcdc24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of audio renderer mix buffers.  <a href="namespacenn_1_1audio.html#a8544bdfe35b41171afecfd38eabcdc24">More...</a><br /></td></tr>
<tr class="separator:a8544bdfe35b41171afecfd38eabcdc24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aead9bb2b33389f39a8845b75ba6d23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1audio.html#a44c5ac6aa2921d6a52fb1c44471d4661">AudioRendererState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a8aead9bb2b33389f39a8845b75ba6d23">GetAudioRendererState</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_handle.html">AudioRendererHandle</a> handle) noexcept</td></tr>
<tr class="memdesc:a8aead9bb2b33389f39a8845b75ba6d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the state of an audio renderer.  <a href="namespacenn_1_1audio.html#a8aead9bb2b33389f39a8845b75ba6d23">More...</a><br /></td></tr>
<tr class="separator:a8aead9bb2b33389f39a8845b75ba6d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac555128156197608dfaeeb5e824780a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6">RequestUpdateAudioRenderer</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_handle.html">AudioRendererHandle</a> handle, const <a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pConfig) noexcept</td></tr>
<tr class="memdesc:ac555128156197608dfaeeb5e824780a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the parameters for <code>Voice</code> objects bound to the audio renderer.  <a href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6">More...</a><br /></td></tr>
<tr class="separator:ac555128156197608dfaeeb5e824780a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd51fa35997672709890d7274f303d4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#afcd51fa35997672709890d7274f303d4">GetAudioRendererWorkBufferSize</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html">AudioRendererParameter</a> &amp;parameter) noexcept</td></tr>
<tr class="memdesc:afcd51fa35997672709890d7274f303d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the working buffer required to open an audio renderer.  <a href="namespacenn_1_1audio.html#afcd51fa35997672709890d7274f303d4">More...</a><br /></td></tr>
<tr class="separator:afcd51fa35997672709890d7274f303d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54fa3067e8bd1916ece8ed7384dd11f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ab54fa3067e8bd1916ece8ed7384dd11f">SetAudioRendererRenderingTimeLimit</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_handle.html">AudioRendererHandle</a> handle, int limitPercent) noexcept</td></tr>
<tr class="memdesc:ab54fa3067e8bd1916ece8ed7384dd11f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the upper limit on the rendering time allocated to the audio renderer.  <a href="namespacenn_1_1audio.html#ab54fa3067e8bd1916ece8ed7384dd11f">More...</a><br /></td></tr>
<tr class="separator:ab54fa3067e8bd1916ece8ed7384dd11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4623b80df57739915f88e9913d4dcfd0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a4623b80df57739915f88e9913d4dcfd0">GetAudioRendererRenderingTimeLimit</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_handle.html">AudioRendererHandle</a> handle) noexcept</td></tr>
<tr class="memdesc:a4623b80df57739915f88e9913d4dcfd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the upper limit on the rendering time allocated to the audio renderer.  <a href="namespacenn_1_1audio.html#a4623b80df57739915f88e9913d4dcfd0">More...</a><br /></td></tr>
<tr class="separator:a4623b80df57739915f88e9913d4dcfd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88d3b7c00c314f03079ef582e3e7a81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ac88d3b7c00c314f03079ef582e3e7a81">ExecuteAudioRendererRendering</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_handle.html">AudioRendererHandle</a> handle) noexcept</td></tr>
<tr class="memdesc:ac88d3b7c00c314f03079ef582e3e7a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes rendering processing with the audio renderer.  <a href="namespacenn_1_1audio.html#ac88d3b7c00c314f03079ef582e3e7a81">More...</a><br /></td></tr>
<tr class="separator:ac88d3b7c00c314f03079ef582e3e7a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8079b796ed899e8cb519f07e5456c77b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1audio.html#a46b67f0c9d1ae83ebaea784964373f56">AudioRendererRenderingDevice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a8079b796ed899e8cb519f07e5456c77b">GetAudioRendererRenderingDevice</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_handle.html">AudioRendererHandle</a> handle) noexcept</td></tr>
<tr class="memdesc:a8079b796ed899e8cb519f07e5456c77b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the device used by the audio renderer for rendering.  <a href="namespacenn_1_1audio.html#a8079b796ed899e8cb519f07e5456c77b">More...</a><br /></td></tr>
<tr class="separator:a8079b796ed899e8cb519f07e5456c77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7abfcbf0385e9e2bf86bbfce40430f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1audio.html#abfe8ba78d8df1cffa01e726924471e35">AudioRendererExecutionMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a0a7abfcbf0385e9e2bf86bbfce40430f">GetAudioRendererExecutionMode</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_handle.html">AudioRendererHandle</a> handle) noexcept</td></tr>
<tr class="memdesc:a0a7abfcbf0385e9e2bf86bbfce40430f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the rendering mode of the audio renderer.  <a href="namespacenn_1_1audio.html#a0a7abfcbf0385e9e2bf86bbfce40430f">More...</a><br /></td></tr>
<tr class="separator:a0a7abfcbf0385e9e2bf86bbfce40430f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">API Resources for CPU AuxDelay</div></td></tr>
<tr class="memitem:a5032bc2f04b92ab0892bb6d85adfd5d0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a5032bc2f04b92ab0892bb6d85adfd5d0">GetRequiredBufferSizeForAuxDelay</a> (<a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> delayTimeMax, int sampleRate, int channelCountMax) noexcept</td></tr>
<tr class="memdesc:a5032bc2f04b92ab0892bb6d85adfd5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the buffer required for using <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code>.  <a href="namespacenn_1_1audio.html#a5032bc2f04b92ab0892bb6d85adfd5d0">More...</a><br /></td></tr>
<tr class="separator:a5032bc2f04b92ab0892bb6d85adfd5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1ab19629487599a70f6cf5c851b286"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#afb1ab19629487599a70f6cf5c851b286">InitializeAuxDelay</a> (<a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html">AuxDelayType</a> *pOutDelay, void *buffer, size_t bufferSize, <a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> delayTimeMax, int sampleRate, int channelCountMax) noexcept</td></tr>
<tr class="memdesc:afb1ab19629487599a70f6cf5c851b286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code>.  <a href="namespacenn_1_1audio.html#afb1ab19629487599a70f6cf5c851b286">More...</a><br /></td></tr>
<tr class="separator:afb1ab19629487599a70f6cf5c851b286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a44fc9820b4d519d0828d7588e0508"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a51a44fc9820b4d519d0828d7588e0508">GetAuxDelayChannelCountMax</a> (const <a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html">AuxDelayType</a> *pDelay) noexcept</td></tr>
<tr class="memdesc:a51a44fc9820b4d519d0828d7588e0508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum number of channels that can be set for <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">AuxDelayType</a></code>.  <a href="namespacenn_1_1audio.html#a51a44fc9820b4d519d0828d7588e0508">More...</a><br /></td></tr>
<tr class="separator:a51a44fc9820b4d519d0828d7588e0508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41b5f59e5efa09a2311b3cec93106fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#af41b5f59e5efa09a2311b3cec93106fb">GetAuxDelayInputOutput</a> (int8_t *outInput, int8_t *outOutput, int *pOutCount, const <a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html">AuxDelayType</a> *pDelay, int count) noexcept</td></tr>
<tr class="memdesc:af41b5f59e5efa09a2311b3cec93106fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the input/output channel indexes for <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code>.  <a href="namespacenn_1_1audio.html#af41b5f59e5efa09a2311b3cec93106fb">More...</a><br /></td></tr>
<tr class="separator:af41b5f59e5efa09a2311b3cec93106fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056b975436e2c63c8dfe4efd142f5907"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a056b975436e2c63c8dfe4efd142f5907">SetAuxDelayInputOutput</a> (<a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html">AuxDelayType</a> *pOutDelay, const int8_t *input, const int8_t *output, int count) noexcept</td></tr>
<tr class="memdesc:a056b975436e2c63c8dfe4efd142f5907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the input/output channel indexes for <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code>  <a href="namespacenn_1_1audio.html#a056b975436e2c63c8dfe4efd142f5907">More...</a><br /></td></tr>
<tr class="separator:a056b975436e2c63c8dfe4efd142f5907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df8d80c2dee7d620e6ae88ec3ddf9e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a3df8d80c2dee7d620e6ae88ec3ddf9e2">GetAuxDelayTimeMax</a> (const <a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html">AuxDelayType</a> *pDelay) noexcept</td></tr>
<tr class="memdesc:a3df8d80c2dee7d620e6ae88ec3ddf9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum delay time that can be set for <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">AuxDelayType</a></code>.  <a href="namespacenn_1_1audio.html#a3df8d80c2dee7d620e6ae88ec3ddf9e2">More...</a><br /></td></tr>
<tr class="separator:a3df8d80c2dee7d620e6ae88ec3ddf9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9afa0f0546fd479e5b47f90498edc34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1audio_1_1_delay_parameter_set.html">DelayParameterSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ac9afa0f0546fd479e5b47f90498edc34">GetAuxDelayParameters</a> (const <a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html">AuxDelayType</a> *pDelay) noexcept</td></tr>
<tr class="memdesc:ac9afa0f0546fd479e5b47f90498edc34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code> effect parameters.  <a href="namespacenn_1_1audio.html#ac9afa0f0546fd479e5b47f90498edc34">More...</a><br /></td></tr>
<tr class="separator:ac9afa0f0546fd479e5b47f90498edc34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3be8ea84abff5e7dcf08517240d88c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ab3be8ea84abff5e7dcf08517240d88c3">SetAuxDelayParameters</a> (<a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html">AuxDelayType</a> *pOutDelay, const <a class="el" href="structnn_1_1audio_1_1_delay_parameter_set.html">DelayParameterSet</a> *pParameterSet) noexcept</td></tr>
<tr class="memdesc:ab3be8ea84abff5e7dcf08517240d88c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code> effect parameters.  <a href="namespacenn_1_1audio.html#ab3be8ea84abff5e7dcf08517240d88c3">More...</a><br /></td></tr>
<tr class="separator:ab3be8ea84abff5e7dcf08517240d88c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b23cd50dc12cc8a11b5f089e192869"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ab2b23cd50dc12cc8a11b5f089e192869">ProcessAuxDelay</a> (<a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html">AuxDelayType</a> *pOutDelay, int32_t *outBuffer, const int32_t *inBuffer, const uint32_t samplesPerFrame) noexcept</td></tr>
<tr class="memdesc:ab2b23cd50dc12cc8a11b5f089e192869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code> effect process.  <a href="namespacenn_1_1audio.html#ab2b23cd50dc12cc8a11b5f089e192869">More...</a><br /></td></tr>
<tr class="separator:ab2b23cd50dc12cc8a11b5f089e192869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29470a53139cf1cd3ab4c66ca25a9a13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a29470a53139cf1cd3ab4c66ca25a9a13">ResetAuxDelay</a> (<a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html">AuxDelayType</a> *pOutDelay) noexcept</td></tr>
<tr class="memdesc:a29470a53139cf1cd3ab4c66ca25a9a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the delay component of the <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code> effect.  <a href="namespacenn_1_1audio.html#a29470a53139cf1cd3ab4c66ca25a9a13">More...</a><br /></td></tr>
<tr class="separator:a29470a53139cf1cd3ab4c66ca25a9a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">CPU AuxI3DL2Reverb API</div></td></tr>
<tr class="memitem:ae57b6b6fc54d22f22d63dc227397fd66"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ae57b6b6fc54d22f22d63dc227397fd66">GetRequiredBufferSizeForAuxI3dl2Reverb</a> (int sampleRate, int channelCountMax) noexcept</td></tr>
<tr class="memdesc:ae57b6b6fc54d22f22d63dc227397fd66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the buffer required to use <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">nn::audio::AuxI3dl2ReverbType</a></code>.  <a href="namespacenn_1_1audio.html#ae57b6b6fc54d22f22d63dc227397fd66">More...</a><br /></td></tr>
<tr class="separator:ae57b6b6fc54d22f22d63dc227397fd66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992d642a3d5a5162e42afd45abeb02bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a992d642a3d5a5162e42afd45abeb02bb">InitializeAuxI3dl2Reverb</a> (<a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html">AuxI3dl2ReverbType</a> *pOutReverb, void *buffer, size_t bufferSize, int sampleRate, int channelCountMax) noexcept</td></tr>
<tr class="memdesc:a992d642a3d5a5162e42afd45abeb02bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">nn::audio::AuxI3dl2ReverbType</a></code>.  <a href="namespacenn_1_1audio.html#a992d642a3d5a5162e42afd45abeb02bb">More...</a><br /></td></tr>
<tr class="separator:a992d642a3d5a5162e42afd45abeb02bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b01dc4e367ca2adaaf7f0c1519c481a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a1b01dc4e367ca2adaaf7f0c1519c481a">GetAuxI3dl2ReverbChannelCountMax</a> (const <a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html">AuxI3dl2ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:a1b01dc4e367ca2adaaf7f0c1519c481a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum number of channels that can be set for <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">AuxI3dl2ReverbType</a></code>.  <a href="namespacenn_1_1audio.html#a1b01dc4e367ca2adaaf7f0c1519c481a">More...</a><br /></td></tr>
<tr class="separator:a1b01dc4e367ca2adaaf7f0c1519c481a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47b730de287406be81a86fa4ee5730e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#af47b730de287406be81a86fa4ee5730e">GetAuxI3dl2ReverbInputOutput</a> (int8_t *outInput, int8_t *outOutput, int *pOutCount, const <a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html">AuxI3dl2ReverbType</a> *pReverb, int count) noexcept</td></tr>
<tr class="memdesc:af47b730de287406be81a86fa4ee5730e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the input/output channel index for <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">nn::audio::AuxI3dl2ReverbType</a></code>.  <a href="namespacenn_1_1audio.html#af47b730de287406be81a86fa4ee5730e">More...</a><br /></td></tr>
<tr class="separator:af47b730de287406be81a86fa4ee5730e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae79674a28d7fcf9876bfb9a6a9ff51b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aae79674a28d7fcf9876bfb9a6a9ff51b">SetAuxI3dl2ReverbInputOutput</a> (<a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html">AuxI3dl2ReverbType</a> *pOutReverb, const int8_t *input, const int8_t *output, int count) noexcept</td></tr>
<tr class="memdesc:aae79674a28d7fcf9876bfb9a6a9ff51b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the input/output channel indexes for <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">nn::audio::AuxI3dl2ReverbType</a></code>.  <a href="namespacenn_1_1audio.html#aae79674a28d7fcf9876bfb9a6a9ff51b">More...</a><br /></td></tr>
<tr class="separator:aae79674a28d7fcf9876bfb9a6a9ff51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae21306b8e05825ebf09acd6fa1b2176"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aae21306b8e05825ebf09acd6fa1b2176">SetAuxI3dl2ReverbParameters</a> (<a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html">AuxI3dl2ReverbType</a> *pOutReverb, const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_parameter_set.html">I3dl2ReverbParameterSet</a> *pParameterSet) noexcept</td></tr>
<tr class="memdesc:aae21306b8e05825ebf09acd6fa1b2176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">nn::audio::AuxI3dl2ReverbType</a></code> effect parameters.  <a href="namespacenn_1_1audio.html#aae21306b8e05825ebf09acd6fa1b2176">More...</a><br /></td></tr>
<tr class="separator:aae21306b8e05825ebf09acd6fa1b2176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b88b9debda9b3cfaf064c977bc5a4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_parameter_set.html">I3dl2ReverbParameterSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a86b88b9debda9b3cfaf064c977bc5a4c">GetAuxI3dl2ReverbParameters</a> (const <a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html">AuxI3dl2ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:a86b88b9debda9b3cfaf064c977bc5a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">nn::audio::AuxI3dl2ReverbType</a></code> effect parameters.  <a href="namespacenn_1_1audio.html#a86b88b9debda9b3cfaf064c977bc5a4c">More...</a><br /></td></tr>
<tr class="separator:a86b88b9debda9b3cfaf064c977bc5a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6455a4a487adec605cd53a8bf747d3df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a6455a4a487adec605cd53a8bf747d3df">ProcessAuxI3dl2Reverb</a> (<a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html">AuxI3dl2ReverbType</a> *pOutReverb, int32_t *outBuffer, const int32_t *inBuffer, const uint32_t samplesPerFrame) noexcept</td></tr>
<tr class="memdesc:a6455a4a487adec605cd53a8bf747d3df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">nn::audio::AuxI3dl2ReverbType</a></code> effect processing.  <a href="namespacenn_1_1audio.html#a6455a4a487adec605cd53a8bf747d3df">More...</a><br /></td></tr>
<tr class="separator:a6455a4a487adec605cd53a8bf747d3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0894e91a8cd9e229e7ba5561f93ff69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ac0894e91a8cd9e229e7ba5561f93ff69">ResetAuxI3dl2Reverb</a> (<a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html">AuxI3dl2ReverbType</a> *pOutReverb) noexcept</td></tr>
<tr class="memdesc:ac0894e91a8cd9e229e7ba5561f93ff69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the reverberation element of the <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">nn::audio::AuxI3dl2ReverbType</a></code> effect.  <a href="namespacenn_1_1audio.html#ac0894e91a8cd9e229e7ba5561f93ff69">More...</a><br /></td></tr>
<tr class="separator:ac0894e91a8cd9e229e7ba5561f93ff69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">API Resources for CPU AuxLightLimiter</div></td></tr>
<tr class="memitem:a47e63c0750cec8d569c61303f760570b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a47e63c0750cec8d569c61303f760570b">InitializeAuxLightLimiter</a> (<a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html">AuxLightLimiterType</a> *pOutEffect, void *buffer, size_t bufferSize, <a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> lookAheadTimeMax, int sampleRate, int channelCountMax) noexcept</td></tr>
<tr class="memdesc:a47e63c0750cec8d569c61303f760570b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">nn::audio::AuxLightLimiterType</a></code>.  <a href="namespacenn_1_1audio.html#a47e63c0750cec8d569c61303f760570b">More...</a><br /></td></tr>
<tr class="separator:a47e63c0750cec8d569c61303f760570b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16c8dc3eb3b9ed0c12dd4cbd8fc2649"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ac16c8dc3eb3b9ed0c12dd4cbd8fc2649">SetAuxLightLimiterInputOutput</a> (<a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html">AuxLightLimiterType</a> *pOutEffect, const int8_t *input, const int8_t *output, int count) noexcept</td></tr>
<tr class="memdesc:ac16c8dc3eb3b9ed0c12dd4cbd8fc2649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the input and output channel indexes for <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">nn::audio::AuxLightLimiterType</a></code>.  <a href="namespacenn_1_1audio.html#ac16c8dc3eb3b9ed0c12dd4cbd8fc2649">More...</a><br /></td></tr>
<tr class="separator:ac16c8dc3eb3b9ed0c12dd4cbd8fc2649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9774f9b25c3c675217ef2fd1a863d9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#af9774f9b25c3c675217ef2fd1a863d9f">GetAuxLightLimiterInputOutput</a> (int8_t *outInput, int8_t *outOutput, int *pOutCount, const <a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html">AuxLightLimiterType</a> *pEffect, int count) noexcept</td></tr>
<tr class="memdesc:af9774f9b25c3c675217ef2fd1a863d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the input/output channel indexes of <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">nn::audio::AuxLightLimiterType</a></code>.  <a href="namespacenn_1_1audio.html#af9774f9b25c3c675217ef2fd1a863d9f">More...</a><br /></td></tr>
<tr class="separator:af9774f9b25c3c675217ef2fd1a863d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adedd1e7e36d502b824e198df1ae53835"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#adedd1e7e36d502b824e198df1ae53835">SetAuxLightLimiterParameters</a> (<a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html">AuxLightLimiterType</a> *pOutEffect, const <a class="el" href="structnn_1_1audio_1_1_light_limiter_parameter_set.html">LightLimiterParameterSet</a> *pParameterSet) noexcept</td></tr>
<tr class="memdesc:adedd1e7e36d502b824e198df1ae53835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">nn::audio::AuxLightLimiterType</a></code> effect parameters.  <a href="namespacenn_1_1audio.html#adedd1e7e36d502b824e198df1ae53835">More...</a><br /></td></tr>
<tr class="separator:adedd1e7e36d502b824e198df1ae53835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b3af6bf453576de59f831c0f76a16f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1audio_1_1_light_limiter_parameter_set.html">LightLimiterParameterSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a72b3af6bf453576de59f831c0f76a16f">GetAuxLightLimiterParameters</a> (const <a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html">AuxLightLimiterType</a> *pEffect) noexcept</td></tr>
<tr class="memdesc:a72b3af6bf453576de59f831c0f76a16f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">nn::audio::AuxLightLimiterType</a></code> effect parameters.  <a href="namespacenn_1_1audio.html#a72b3af6bf453576de59f831c0f76a16f">More...</a><br /></td></tr>
<tr class="separator:a72b3af6bf453576de59f831c0f76a16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb99ef2347d04915476de47a0173f2db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#abb99ef2347d04915476de47a0173f2db">GetAuxLightLimiterLookAheadTimeMax</a> (const <a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html">AuxLightLimiterType</a> *pEffect) noexcept</td></tr>
<tr class="memdesc:abb99ef2347d04915476de47a0173f2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum look-ahead time that can be set for <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">AuxLightLimiterType</a></code>.  <a href="namespacenn_1_1audio.html#abb99ef2347d04915476de47a0173f2db">More...</a><br /></td></tr>
<tr class="separator:abb99ef2347d04915476de47a0173f2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0662825718b21c3d5bf08538b9c05b3d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a0662825718b21c3d5bf08538b9c05b3d">GetAuxLightLimiterChannelCountMax</a> (const <a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html">AuxLightLimiterType</a> *pEffect) noexcept</td></tr>
<tr class="memdesc:a0662825718b21c3d5bf08538b9c05b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum number of channels that can be set for <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">AuxLightLimiterType</a></code>.  <a href="namespacenn_1_1audio.html#a0662825718b21c3d5bf08538b9c05b3d">More...</a><br /></td></tr>
<tr class="separator:a0662825718b21c3d5bf08538b9c05b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7df867ca3877b8331ca0cda0dae6cd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a4f7df867ca3877b8331ca0cda0dae6cd">GetRequiredBufferSizeForAuxLightLimiter</a> (<a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> lookAheadTimeMax, int sampleRate, int channelCountMax) noexcept</td></tr>
<tr class="memdesc:a4f7df867ca3877b8331ca0cda0dae6cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the buffer size required for using <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">nn::audio::AuxLightLimiterType</a></code>.  <a href="namespacenn_1_1audio.html#a4f7df867ca3877b8331ca0cda0dae6cd">More...</a><br /></td></tr>
<tr class="separator:a4f7df867ca3877b8331ca0cda0dae6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadda2ec39f13f8cdf64339978f8afe95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aadda2ec39f13f8cdf64339978f8afe95">ProcessAuxLightLimiter</a> (<a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html">AuxLightLimiterType</a> *pOutEffect, int32_t *outBuffer, const int32_t *inBuffer, const uint32_t samplesPerFrame) noexcept</td></tr>
<tr class="memdesc:aadda2ec39f13f8cdf64339978f8afe95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes the <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">nn::audio::AuxLightLimiterType</a></code> effect.  <a href="namespacenn_1_1audio.html#aadda2ec39f13f8cdf64339978f8afe95">More...</a><br /></td></tr>
<tr class="separator:aadda2ec39f13f8cdf64339978f8afe95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe82b30cd9aeae5950599034b454cb17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#afe82b30cd9aeae5950599034b454cb17">ResetAuxLightLimiter</a> (<a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html">AuxLightLimiterType</a> *pOutEffect) noexcept</td></tr>
<tr class="memdesc:afe82b30cd9aeae5950599034b454cb17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the internal state of the <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">nn::audio::AuxLightLimiterType</a></code> effect.  <a href="namespacenn_1_1audio.html#afe82b30cd9aeae5950599034b454cb17">More...</a><br /></td></tr>
<tr class="separator:afe82b30cd9aeae5950599034b454cb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">CPU AuxLimiter Functions</div></td></tr>
<tr class="memitem:ae5fcb428ba5abc86c2e33debc02d78c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ae5fcb428ba5abc86c2e33debc02d78c2">InitializeAuxLimiter</a> (<a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html">AuxLimiterType</a> *pOutLimiter, void *buffer, size_t bufferSize, <a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> attackTimeMax, <a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> releaseTimeMax, int sampleRate, int channelCountMax) noexcept</td></tr>
<tr class="memdesc:ae5fcb428ba5abc86c2e33debc02d78c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code>.  <a href="namespacenn_1_1audio.html#ae5fcb428ba5abc86c2e33debc02d78c2">More...</a><br /></td></tr>
<tr class="separator:ae5fcb428ba5abc86c2e33debc02d78c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e992c4ca9e3077076c369a3796e9c01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a4e992c4ca9e3077076c369a3796e9c01">SetAuxLimiterInputOutput</a> (<a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html">AuxLimiterType</a> *pLimiter, const int8_t *input, const int8_t *output, int count) noexcept</td></tr>
<tr class="memdesc:a4e992c4ca9e3077076c369a3796e9c01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the input/output channel index for <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code>.  <a href="namespacenn_1_1audio.html#a4e992c4ca9e3077076c369a3796e9c01">More...</a><br /></td></tr>
<tr class="separator:a4e992c4ca9e3077076c369a3796e9c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b0f254b61c227ed91315917e4d00bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a31b0f254b61c227ed91315917e4d00bf">GetAuxLimiterInputOutput</a> (int8_t *outInput, int8_t *outOutput, int *pOutCount, const <a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html">AuxLimiterType</a> *pLimiter, int count) noexcept</td></tr>
<tr class="memdesc:a31b0f254b61c227ed91315917e4d00bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the input/output channel index for <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code>.  <a href="namespacenn_1_1audio.html#a31b0f254b61c227ed91315917e4d00bf">More...</a><br /></td></tr>
<tr class="separator:a31b0f254b61c227ed91315917e4d00bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa758a7f9a058db6b42b2de72c6537130"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aa758a7f9a058db6b42b2de72c6537130">SetAuxLimiterParameters</a> (<a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html">AuxLimiterType</a> *pOutLimiter, const <a class="el" href="structnn_1_1audio_1_1_limiter_parameter_set.html">LimiterParameterSet</a> *pParameterSet) noexcept</td></tr>
<tr class="memdesc:aa758a7f9a058db6b42b2de72c6537130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code> effect parameters.  <a href="namespacenn_1_1audio.html#aa758a7f9a058db6b42b2de72c6537130">More...</a><br /></td></tr>
<tr class="separator:aa758a7f9a058db6b42b2de72c6537130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae019e6dae2ad37aaac8b0e9cd0aba6da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1audio_1_1_limiter_parameter_set.html">LimiterParameterSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ae019e6dae2ad37aaac8b0e9cd0aba6da">GetAuxLimiterParameters</a> (const <a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html">AuxLimiterType</a> *pLimiter) noexcept</td></tr>
<tr class="memdesc:ae019e6dae2ad37aaac8b0e9cd0aba6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code> effect parameters.  <a href="namespacenn_1_1audio.html#ae019e6dae2ad37aaac8b0e9cd0aba6da">More...</a><br /></td></tr>
<tr class="separator:ae019e6dae2ad37aaac8b0e9cd0aba6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aea93b35a8452f08527e1bacd648328"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a9aea93b35a8452f08527e1bacd648328">GetAuxLimiterAttackTimeMax</a> (const <a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html">AuxLimiterType</a> *pLimiter) noexcept</td></tr>
<tr class="memdesc:a9aea93b35a8452f08527e1bacd648328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum value that can be set as the attack time for <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">AuxLimiterType</a></code>.  <a href="namespacenn_1_1audio.html#a9aea93b35a8452f08527e1bacd648328">More...</a><br /></td></tr>
<tr class="separator:a9aea93b35a8452f08527e1bacd648328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380ede62b6c80cf2023c43dbc9387ee4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a380ede62b6c80cf2023c43dbc9387ee4">GetAuxLimiterReleaseTimeMax</a> (const <a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html">AuxLimiterType</a> *pLimiter) noexcept</td></tr>
<tr class="memdesc:a380ede62b6c80cf2023c43dbc9387ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum value that can be set as the release time for <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">AuxLimiterType</a></code>.  <a href="namespacenn_1_1audio.html#a380ede62b6c80cf2023c43dbc9387ee4">More...</a><br /></td></tr>
<tr class="separator:a380ede62b6c80cf2023c43dbc9387ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a0c6d9ed79bd7ab4210395e4633542"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ac5a0c6d9ed79bd7ab4210395e4633542">GetAuxLimiterChannelCountMax</a> (const <a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html">AuxLimiterType</a> *pLimiter) noexcept</td></tr>
<tr class="memdesc:ac5a0c6d9ed79bd7ab4210395e4633542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum number of channels that can be set for <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">AuxLimiterType</a></code>.  <a href="namespacenn_1_1audio.html#ac5a0c6d9ed79bd7ab4210395e4633542">More...</a><br /></td></tr>
<tr class="separator:ac5a0c6d9ed79bd7ab4210395e4633542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e2cf8c25a9738c51fe37eb83b4c109"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a43e2cf8c25a9738c51fe37eb83b4c109">GetRequiredBufferSizeForAuxLimiter</a> (<a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> attackTimeMax, int sampleRate, int channelCountMax) noexcept</td></tr>
<tr class="memdesc:a43e2cf8c25a9738c51fe37eb83b4c109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the buffer required to use <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code>.  <a href="namespacenn_1_1audio.html#a43e2cf8c25a9738c51fe37eb83b4c109">More...</a><br /></td></tr>
<tr class="separator:a43e2cf8c25a9738c51fe37eb83b4c109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d81d89ba7c6be9675e46ef6eb65896"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ab4d81d89ba7c6be9675e46ef6eb65896">ProcessAuxLimiter</a> (<a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html">AuxLimiterType</a> *pOutLimiter, int32_t *outBuffer, const int32_t *inBuffer, const uint32_t samplesPerFrame) noexcept</td></tr>
<tr class="memdesc:ab4d81d89ba7c6be9675e46ef6eb65896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code> effect processing.  <a href="namespacenn_1_1audio.html#ab4d81d89ba7c6be9675e46ef6eb65896">More...</a><br /></td></tr>
<tr class="separator:ab4d81d89ba7c6be9675e46ef6eb65896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac653792517f39a0c863c1c0a2e5e8fbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ac653792517f39a0c863c1c0a2e5e8fbe">ResetAuxLimiter</a> (<a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html">AuxLimiterType</a> *pOutLimiter) noexcept</td></tr>
<tr class="memdesc:ac653792517f39a0c863c1c0a2e5e8fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the internal state of the <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code> effect.  <a href="namespacenn_1_1audio.html#ac653792517f39a0c863c1c0a2e5e8fbe">More...</a><br /></td></tr>
<tr class="separator:ac653792517f39a0c863c1c0a2e5e8fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">API Resources for CPU AuxReverb</div></td></tr>
<tr class="memitem:a3c8b46d68be8064cf2ca7a9a6b948f4a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a3c8b46d68be8064cf2ca7a9a6b948f4a">GetRequiredBufferSizeForAuxReverb</a> (int sampleRate, int channelCountMax) noexcept</td></tr>
<tr class="memdesc:a3c8b46d68be8064cf2ca7a9a6b948f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of buffer required for using <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">nn::audio::AuxReverbType</a></code>.  <a href="namespacenn_1_1audio.html#a3c8b46d68be8064cf2ca7a9a6b948f4a">More...</a><br /></td></tr>
<tr class="separator:a3c8b46d68be8064cf2ca7a9a6b948f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a66d864ded702393bf65a1a8d1f3ff5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a4a66d864ded702393bf65a1a8d1f3ff5">InitializeAuxReverb</a> (<a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html">AuxReverbType</a> *pOutReverb, void *buffer, size_t bufferSize, int sampleRate, int channelCountMax) noexcept</td></tr>
<tr class="memdesc:a4a66d864ded702393bf65a1a8d1f3ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">nn::audio::AuxReverbType</a></code>.  <a href="namespacenn_1_1audio.html#a4a66d864ded702393bf65a1a8d1f3ff5">More...</a><br /></td></tr>
<tr class="separator:a4a66d864ded702393bf65a1a8d1f3ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea1a1571158d877e27a9d7c9676ad5f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aeea1a1571158d877e27a9d7c9676ad5f">GetAuxReverbChannelCountMax</a> (const <a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html">AuxReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:aeea1a1571158d877e27a9d7c9676ad5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum number of channels that can be set for <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">AuxReverbType</a></code>.  <a href="namespacenn_1_1audio.html#aeea1a1571158d877e27a9d7c9676ad5f">More...</a><br /></td></tr>
<tr class="separator:aeea1a1571158d877e27a9d7c9676ad5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298b3fbc0ea1677b3cfc8aeedc7e1ba7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a298b3fbc0ea1677b3cfc8aeedc7e1ba7">GetAuxReverbInputOutput</a> (int8_t *outInput, int8_t *outOutput, int *pOutCount, const <a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html">AuxReverbType</a> *pReverb, int count) noexcept</td></tr>
<tr class="memdesc:a298b3fbc0ea1677b3cfc8aeedc7e1ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">nn::audio::AuxReverbType</a></code> input/output channel indexes.  <a href="namespacenn_1_1audio.html#a298b3fbc0ea1677b3cfc8aeedc7e1ba7">More...</a><br /></td></tr>
<tr class="separator:a298b3fbc0ea1677b3cfc8aeedc7e1ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f356593e701e68767f89243e7ae777e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a0f356593e701e68767f89243e7ae777e">SetAuxReverbInputOutput</a> (<a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html">AuxReverbType</a> *pOutReverb, const int8_t *input, const int8_t *output, int count) noexcept</td></tr>
<tr class="memdesc:a0f356593e701e68767f89243e7ae777e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">nn::audio::AuxReverbType</a></code> input/output channel indexes.  <a href="namespacenn_1_1audio.html#a0f356593e701e68767f89243e7ae777e">More...</a><br /></td></tr>
<tr class="separator:a0f356593e701e68767f89243e7ae777e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3193c0f8fd5d1849ef1223497b103681"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1audio_1_1_reverb_parameter_set.html">ReverbParameterSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a3193c0f8fd5d1849ef1223497b103681">GetAuxReverbParameters</a> (const <a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html">AuxReverbType</a> *pReverb)</td></tr>
<tr class="memdesc:a3193c0f8fd5d1849ef1223497b103681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">nn::audio::AuxReverbType</a></code> effect parameter.  <a href="namespacenn_1_1audio.html#a3193c0f8fd5d1849ef1223497b103681">More...</a><br /></td></tr>
<tr class="separator:a3193c0f8fd5d1849ef1223497b103681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4a7aad7e1bf499f3f8025829aae95c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a7c4a7aad7e1bf499f3f8025829aae95c">SetAuxReverbParameters</a> (<a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html">AuxReverbType</a> *pOutReverb, const <a class="el" href="structnn_1_1audio_1_1_reverb_parameter_set.html">nn::audio::ReverbParameterSet</a> *pParameterSet) noexcept</td></tr>
<tr class="memdesc:a7c4a7aad7e1bf499f3f8025829aae95c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">nn::audio::AuxReverbType</a></code> effect parameter.  <a href="namespacenn_1_1audio.html#a7c4a7aad7e1bf499f3f8025829aae95c">More...</a><br /></td></tr>
<tr class="separator:a7c4a7aad7e1bf499f3f8025829aae95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc918bae3e4385df2cebbfa4befda66b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#afc918bae3e4385df2cebbfa4befda66b">ProcessAuxReverb</a> (<a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html">AuxReverbType</a> *pOutReverb, int32_t *outBuffer, const int32_t *inBuffer, const uint32_t samplesPerFrame) noexcept</td></tr>
<tr class="memdesc:afc918bae3e4385df2cebbfa4befda66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">nn::audio::AuxReverbType</a></code> effect processing.  <a href="namespacenn_1_1audio.html#afc918bae3e4385df2cebbfa4befda66b">More...</a><br /></td></tr>
<tr class="separator:afc918bae3e4385df2cebbfa4befda66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8974b91abe2ba832ea9e0b5202462d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#acf8974b91abe2ba832ea9e0b5202462d">ResetAuxReverb</a> (<a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html">AuxReverbType</a> *pOutReverb) noexcept</td></tr>
<tr class="memdesc:acf8974b91abe2ba832ea9e0b5202462d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the reverberation component of the <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">nn::audio::AuxReverbType</a></code> effect.  <a href="namespacenn_1_1audio.html#acf8974b91abe2ba832ea9e0b5202462d">More...</a><br /></td></tr>
<tr class="separator:acf8974b91abe2ba832ea9e0b5202462d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">API Resources For Audio Renderer BufferMixer Effects</div></td></tr>
<tr class="memitem:a7bd3cc176b82c7cd5659c364ab97ab08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a7bd3cc176b82c7cd5659c364ab97ab08">AddBufferMixer</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_buffer_mixer_type.html">BufferMixerType</a> *pBufferMixer, <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pFinalMix) noexcept</td></tr>
<tr class="memdesc:a7bd3cc176b82c7cd5659c364ab97ab08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <code>BufferMixer</code> to <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>.  <a href="namespacenn_1_1audio.html#a7bd3cc176b82c7cd5659c364ab97ab08">More...</a><br /></td></tr>
<tr class="separator:a7bd3cc176b82c7cd5659c364ab97ab08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca36cb068895cb7d5624f1682b86204"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a9ca36cb068895cb7d5624f1682b86204">AddBufferMixer</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_buffer_mixer_type.html">BufferMixerType</a> *pBufferMixer, <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pSubMix) noexcept</td></tr>
<tr class="memdesc:a9ca36cb068895cb7d5624f1682b86204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <code>BufferMixer</code> to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>.  <a href="namespacenn_1_1audio.html#a9ca36cb068895cb7d5624f1682b86204">More...</a><br /></td></tr>
<tr class="separator:a9ca36cb068895cb7d5624f1682b86204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400aff980a26fd295d911adbffd5f8ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a400aff980a26fd295d911adbffd5f8ae">RemoveBufferMixer</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_buffer_mixer_type.html">BufferMixerType</a> *pBufferMixer, <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pFinalMix) noexcept</td></tr>
<tr class="memdesc:a400aff980a26fd295d911adbffd5f8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes <code>BufferMixer</code> from <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>.  <a href="namespacenn_1_1audio.html#a400aff980a26fd295d911adbffd5f8ae">More...</a><br /></td></tr>
<tr class="separator:a400aff980a26fd295d911adbffd5f8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6995d87955c29acb8d5b4ee02d579b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ac6995d87955c29acb8d5b4ee02d579b0">RemoveBufferMixer</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_buffer_mixer_type.html">BufferMixerType</a> *pBufferMixer, <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pSubMix) noexcept</td></tr>
<tr class="memdesc:ac6995d87955c29acb8d5b4ee02d579b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes <code>BufferMixer</code> from <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>.  <a href="namespacenn_1_1audio.html#ac6995d87955c29acb8d5b4ee02d579b0">More...</a><br /></td></tr>
<tr class="separator:ac6995d87955c29acb8d5b4ee02d579b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4ccfc22243f9770188dcf3df330f6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a0f4ccfc22243f9770188dcf3df330f6b">GetBufferMixerInputOutput</a> (const <a class="el" href="structnn_1_1audio_1_1_buffer_mixer_type.html">BufferMixerType</a> *pBufferMixer, int8_t *outInput, int8_t *outOutput, int *pOutCount, int count) noexcept</td></tr>
<tr class="memdesc:a0f4ccfc22243f9770188dcf3df330f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the input/output relationship of the mixing process set in <code>BufferMixer</code>.  <a href="namespacenn_1_1audio.html#a0f4ccfc22243f9770188dcf3df330f6b">More...</a><br /></td></tr>
<tr class="separator:a0f4ccfc22243f9770188dcf3df330f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ca2b0217074d7daf6534da7db1de0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a70ca2b0217074d7daf6534da7db1de0b">SetBufferMixerInputOutput</a> (<a class="el" href="structnn_1_1audio_1_1_buffer_mixer_type.html">BufferMixerType</a> *pBufferMixer, const int8_t *input, const int8_t *output, int count) noexcept</td></tr>
<tr class="memdesc:a70ca2b0217074d7daf6534da7db1de0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the input/output relationship of the mixing process performed by <code>BufferMixer</code>.  <a href="namespacenn_1_1audio.html#a70ca2b0217074d7daf6534da7db1de0b">More...</a><br /></td></tr>
<tr class="separator:a70ca2b0217074d7daf6534da7db1de0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0768296111890d9b3bfbafba0068fa"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a8a0768296111890d9b3bfbafba0068fa">GetBufferMixerVolume</a> (const <a class="el" href="structnn_1_1audio_1_1_buffer_mixer_type.html">BufferMixerType</a> *pBufferMixer, int index) noexcept</td></tr>
<tr class="memdesc:a8a0768296111890d9b3bfbafba0068fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the volume setting for each input/output relationship of <code>BufferMixer</code>.  <a href="namespacenn_1_1audio.html#a8a0768296111890d9b3bfbafba0068fa">More...</a><br /></td></tr>
<tr class="separator:a8a0768296111890d9b3bfbafba0068fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcd31951156f6c1422c409b2685ab3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a0bcd31951156f6c1422c409b2685ab3e">SetBufferMixerVolume</a> (<a class="el" href="structnn_1_1audio_1_1_buffer_mixer_type.html">BufferMixerType</a> *pBufferMixer, int index, float volume) noexcept</td></tr>
<tr class="memdesc:a0bcd31951156f6c1422c409b2685ab3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the volume for each input/output relationship of <code>BufferMixer</code>.  <a href="namespacenn_1_1audio.html#a0bcd31951156f6c1422c409b2685ab3e">More...</a><br /></td></tr>
<tr class="separator:a0bcd31951156f6c1422c409b2685ab3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3a75afb0f259cc0a8b6589d8f29977"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a5e3a75afb0f259cc0a8b6589d8f29977">IsBufferMixerEnabled</a> (const <a class="el" href="structnn_1_1audio_1_1_buffer_mixer_type.html">BufferMixerType</a> *pBufferMixer) noexcept</td></tr>
<tr class="memdesc:a5e3a75afb0f259cc0a8b6589d8f29977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether <code>BufferMixer</code> is enabled.  <a href="namespacenn_1_1audio.html#a5e3a75afb0f259cc0a8b6589d8f29977">More...</a><br /></td></tr>
<tr class="separator:a5e3a75afb0f259cc0a8b6589d8f29977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c25ec42c8ffed62574963de0d2765c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a45c25ec42c8ffed62574963de0d2765c">SetBufferMixerEnabled</a> (<a class="el" href="structnn_1_1audio_1_1_buffer_mixer_type.html">BufferMixerType</a> *pBufferMixer, bool enable) noexcept</td></tr>
<tr class="memdesc:a45c25ec42c8ffed62574963de0d2765c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether a <code>BufferMixer</code> is enabled or disabled.  <a href="namespacenn_1_1audio.html#a45c25ec42c8ffed62574963de0d2765c">More...</a><br /></td></tr>
<tr class="separator:a45c25ec42c8ffed62574963de0d2765c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f1d1c9f9cc0b68547f4c6553cfaa8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a16f1d1c9f9cc0b68547f4c6553cfaa8f">IsBufferMixerRemovable</a> (const <a class="el" href="structnn_1_1audio_1_1_buffer_mixer_type.html">BufferMixerType</a> *pBufferMixer) noexcept</td></tr>
<tr class="memdesc:a16f1d1c9f9cc0b68547f4c6553cfaa8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether <code>BufferMixer</code> can be safely removed.  <a href="namespacenn_1_1audio.html#a16f1d1c9f9cc0b68547f4c6553cfaa8f">More...</a><br /></td></tr>
<tr class="separator:a16f1d1c9f9cc0b68547f4c6553cfaa8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">API Resources For Audio Renderer Delay Effects</div></td></tr>
<tr class="memitem:a0ee72c85c663f6518ca13201159be052"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a0ee72c85c663f6518ca13201159be052">GetRequiredBufferSizeForDelay</a> (<a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> delayTimeMax, int sampleRate, int channelCountMax) noexcept</td></tr>
<tr class="memdesc:a0ee72c85c663f6518ca13201159be052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the work buffer size required for the renderer to use <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code>.  <a href="namespacenn_1_1audio.html#a0ee72c85c663f6518ca13201159be052">More...</a><br /></td></tr>
<tr class="separator:a0ee72c85c663f6518ca13201159be052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad332d3b8805f5157ef98572a99a9f2a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ad332d3b8805f5157ef98572a99a9f2a0">AddDelay</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *pDelay, void *buffer, size_t bufferSize, <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pFinalMix, <a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> delayTimeMax, int channelCountMax) noexcept</td></tr>
<tr class="memdesc:ad332d3b8805f5157ef98572a99a9f2a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>.  <a href="namespacenn_1_1audio.html#ad332d3b8805f5157ef98572a99a9f2a0">More...</a><br /></td></tr>
<tr class="separator:ad332d3b8805f5157ef98572a99a9f2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6ab91177240adfa5dbc5029ccd8280"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a4a6ab91177240adfa5dbc5029ccd8280">AddDelay</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *pDelay, void *buffer, size_t bufferSize, <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pSubMix, <a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> delayTimeMax, int channelCountMax) noexcept</td></tr>
<tr class="memdesc:a4a6ab91177240adfa5dbc5029ccd8280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>.  <a href="namespacenn_1_1audio.html#a4a6ab91177240adfa5dbc5029ccd8280">More...</a><br /></td></tr>
<tr class="separator:a4a6ab91177240adfa5dbc5029ccd8280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47262039889d9d23aeac0d82ed318ac0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a47262039889d9d23aeac0d82ed318ac0">RemoveDelay</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *pDelay, <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pFinalMix) noexcept</td></tr>
<tr class="memdesc:a47262039889d9d23aeac0d82ed318ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object from <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>.  <a href="namespacenn_1_1audio.html#a47262039889d9d23aeac0d82ed318ac0">More...</a><br /></td></tr>
<tr class="separator:a47262039889d9d23aeac0d82ed318ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25592ceaa97f898a3b361c9404beab04"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a25592ceaa97f898a3b361c9404beab04">RemoveDelay</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *pDelay, <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pSubMix) noexcept</td></tr>
<tr class="memdesc:a25592ceaa97f898a3b361c9404beab04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object from <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>.  <a href="namespacenn_1_1audio.html#a25592ceaa97f898a3b361c9404beab04">More...</a><br /></td></tr>
<tr class="separator:a25592ceaa97f898a3b361c9404beab04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb54e0c9a1ccc61a87e3df141969ff6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#adb54e0c9a1ccc61a87e3df141969ff6a">GetDelayInputOutput</a> (const <a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *pDelay, int8_t *outInput, int8_t *outOutput, int *pOutCount, int count) noexcept</td></tr>
<tr class="memdesc:adb54e0c9a1ccc61a87e3df141969ff6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the indexes of the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> input/output mix buffers.  <a href="namespacenn_1_1audio.html#adb54e0c9a1ccc61a87e3df141969ff6a">More...</a><br /></td></tr>
<tr class="separator:adb54e0c9a1ccc61a87e3df141969ff6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac9e44ccd0d4f0fd0865cd6871949e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a7ac9e44ccd0d4f0fd0865cd6871949e8">SetDelayInputOutput</a> (<a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *pDelay, const int8_t *input, const int8_t *output, int count) noexcept</td></tr>
<tr class="memdesc:a7ac9e44ccd0d4f0fd0865cd6871949e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> input/output mix buffer indexes.  <a href="namespacenn_1_1audio.html#a7ac9e44ccd0d4f0fd0865cd6871949e8">More...</a><br /></td></tr>
<tr class="separator:a7ac9e44ccd0d4f0fd0865cd6871949e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eda2c006ca593d631a8caa7bd2d33c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a7eda2c006ca593d631a8caa7bd2d33c6">GetDelayTimeMax</a> (const <a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *pDelay) noexcept</td></tr>
<tr class="memdesc:a7eda2c006ca593d631a8caa7bd2d33c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum delay time value that can be set for <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code>.  <a href="namespacenn_1_1audio.html#a7eda2c006ca593d631a8caa7bd2d33c6">More...</a><br /></td></tr>
<tr class="separator:a7eda2c006ca593d631a8caa7bd2d33c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3889d816ceb7e79268913d9453fb020"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#af3889d816ceb7e79268913d9453fb020">GetDelayChannelCountMax</a> (const <a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *pDelay) noexcept</td></tr>
<tr class="memdesc:af3889d816ceb7e79268913d9453fb020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum number of channels that can be set for <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code>.  <a href="namespacenn_1_1audio.html#af3889d816ceb7e79268913d9453fb020">More...</a><br /></td></tr>
<tr class="separator:af3889d816ceb7e79268913d9453fb020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14dede97c7c28ba18a41418da43bf690"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a14dede97c7c28ba18a41418da43bf690">GetDelayTime</a> (const <a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *pDelay) noexcept</td></tr>
<tr class="memdesc:a14dede97c7c28ba18a41418da43bf690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the delay time of the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object.  <a href="namespacenn_1_1audio.html#a14dede97c7c28ba18a41418da43bf690">More...</a><br /></td></tr>
<tr class="separator:a14dede97c7c28ba18a41418da43bf690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b0a4aba0c4bbb672a370b53335bdc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ab8b0a4aba0c4bbb672a370b53335bdc7">SetDelayTime</a> (<a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *pDelay, <a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> time) noexcept</td></tr>
<tr class="memdesc:ab8b0a4aba0c4bbb672a370b53335bdc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the delay time of the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object.  <a href="namespacenn_1_1audio.html#ab8b0a4aba0c4bbb672a370b53335bdc7">More...</a><br /></td></tr>
<tr class="separator:ab8b0a4aba0c4bbb672a370b53335bdc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4a6269c07ff5f77eb9209d00af595e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a7f4a6269c07ff5f77eb9209d00af595e">GetDelayFeedbackGain</a> (const <a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *pDelay) noexcept</td></tr>
<tr class="memdesc:a7f4a6269c07ff5f77eb9209d00af595e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the feedback gain of the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object.  <a href="namespacenn_1_1audio.html#a7f4a6269c07ff5f77eb9209d00af595e">More...</a><br /></td></tr>
<tr class="separator:a7f4a6269c07ff5f77eb9209d00af595e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab435746ebd9510b866571bb5f51ada0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ab435746ebd9510b866571bb5f51ada0e">SetDelayFeedbackGain</a> (<a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *pDelay, float feedbackGain) noexcept</td></tr>
<tr class="memdesc:ab435746ebd9510b866571bb5f51ada0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the feedback gain of the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object.  <a href="namespacenn_1_1audio.html#ab435746ebd9510b866571bb5f51ada0e">More...</a><br /></td></tr>
<tr class="separator:ab435746ebd9510b866571bb5f51ada0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7db23976c5c7ce25d354b46fbb41f8"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a7e7db23976c5c7ce25d354b46fbb41f8">GetDelayDryGain</a> (const <a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *pDelay) noexcept</td></tr>
<tr class="memdesc:a7e7db23976c5c7ce25d354b46fbb41f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the dry gain of the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object.  <a href="namespacenn_1_1audio.html#a7e7db23976c5c7ce25d354b46fbb41f8">More...</a><br /></td></tr>
<tr class="separator:a7e7db23976c5c7ce25d354b46fbb41f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fec11e5f1f1f3631724c47bd6025962"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a0fec11e5f1f1f3631724c47bd6025962">SetDelayDryGain</a> (<a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *pDelay, float dryGain) noexcept</td></tr>
<tr class="memdesc:a0fec11e5f1f1f3631724c47bd6025962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dry gain of the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object.  <a href="namespacenn_1_1audio.html#a0fec11e5f1f1f3631724c47bd6025962">More...</a><br /></td></tr>
<tr class="separator:a0fec11e5f1f1f3631724c47bd6025962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e4daa91121a5eb404eb54ecdc08fc5"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a30e4daa91121a5eb404eb54ecdc08fc5">GetDelayInGain</a> (const <a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *pDelay) noexcept</td></tr>
<tr class="memdesc:a30e4daa91121a5eb404eb54ecdc08fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the in gain of the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object.  <a href="namespacenn_1_1audio.html#a30e4daa91121a5eb404eb54ecdc08fc5">More...</a><br /></td></tr>
<tr class="separator:a30e4daa91121a5eb404eb54ecdc08fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329bfdf77c21faf791e3d8d3fea994ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a329bfdf77c21faf791e3d8d3fea994ff">SetDelayInGain</a> (<a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *pDelay, float inGain) noexcept</td></tr>
<tr class="memdesc:a329bfdf77c21faf791e3d8d3fea994ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the in gain of the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object.  <a href="namespacenn_1_1audio.html#a329bfdf77c21faf791e3d8d3fea994ff">More...</a><br /></td></tr>
<tr class="separator:a329bfdf77c21faf791e3d8d3fea994ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b59f407ca82ae84883c7bc05e51c10"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a16b59f407ca82ae84883c7bc05e51c10">GetDelayChannelSpread</a> (const <a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *pDelay) noexcept</td></tr>
<tr class="memdesc:a16b59f407ca82ae84883c7bc05e51c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the channel spread of the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object.  <a href="namespacenn_1_1audio.html#a16b59f407ca82ae84883c7bc05e51c10">More...</a><br /></td></tr>
<tr class="separator:a16b59f407ca82ae84883c7bc05e51c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533af8968ee99402d8941b01d17badbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a533af8968ee99402d8941b01d17badbb">SetDelayChannelSpread</a> (<a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *pDelay, float channelSpread) noexcept</td></tr>
<tr class="memdesc:a533af8968ee99402d8941b01d17badbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the channel spread of the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object.  <a href="namespacenn_1_1audio.html#a533af8968ee99402d8941b01d17badbb">More...</a><br /></td></tr>
<tr class="separator:a533af8968ee99402d8941b01d17badbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61abee481b45e4c907b91262f647a2c5"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a61abee481b45e4c907b91262f647a2c5">GetDelayLowPassAmount</a> (const <a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *pDelay) noexcept</td></tr>
<tr class="memdesc:a61abee481b45e4c907b91262f647a2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the low-pass filter parameter of the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object.  <a href="namespacenn_1_1audio.html#a61abee481b45e4c907b91262f647a2c5">More...</a><br /></td></tr>
<tr class="separator:a61abee481b45e4c907b91262f647a2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c256f18c08f3345aeb8d3649056b12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a95c256f18c08f3345aeb8d3649056b12">SetDelayLowPassAmount</a> (<a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *pDelay, float lowPassAmount) noexcept</td></tr>
<tr class="memdesc:a95c256f18c08f3345aeb8d3649056b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the low-pass filter parameter of the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object.  <a href="namespacenn_1_1audio.html#a95c256f18c08f3345aeb8d3649056b12">More...</a><br /></td></tr>
<tr class="separator:a95c256f18c08f3345aeb8d3649056b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44e602a06822569e8320430cfe56fcb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#af44e602a06822569e8320430cfe56fcb">IsDelayEnabled</a> (const <a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *pDelay) noexcept</td></tr>
<tr class="memdesc:af44e602a06822569e8320430cfe56fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object is enabled.  <a href="namespacenn_1_1audio.html#af44e602a06822569e8320430cfe56fcb">More...</a><br /></td></tr>
<tr class="separator:af44e602a06822569e8320430cfe56fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22e23e037505f7842e41730fa686724"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#af22e23e037505f7842e41730fa686724">SetDelayEnabled</a> (<a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *pDelay, bool enable) noexcept</td></tr>
<tr class="memdesc:af22e23e037505f7842e41730fa686724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object.  <a href="namespacenn_1_1audio.html#af22e23e037505f7842e41730fa686724">More...</a><br /></td></tr>
<tr class="separator:af22e23e037505f7842e41730fa686724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974890d53eaa0f0a7b16a5593535ce84"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a974890d53eaa0f0a7b16a5593535ce84">IsDelayRemovable</a> (const <a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *pDelay) noexcept</td></tr>
<tr class="memdesc:a974890d53eaa0f0a7b16a5593535ce84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object can be safely removed.  <a href="namespacenn_1_1audio.html#a974890d53eaa0f0a7b16a5593535ce84">More...</a><br /></td></tr>
<tr class="separator:a974890d53eaa0f0a7b16a5593535ce84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9783541dea0fef4e4bfed1b9b43d98e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1audio_1_1_delay_parameter_set.html">DelayParameterSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ae9783541dea0fef4e4bfed1b9b43d98e">GetDelayParameters</a> (const <a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *pDelay) noexcept</td></tr>
<tr class="memdesc:ae9783541dea0fef4e4bfed1b9b43d98e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">nn::audio::DelayType</a></code> effect parameters.  <a href="namespacenn_1_1audio.html#ae9783541dea0fef4e4bfed1b9b43d98e">More...</a><br /></td></tr>
<tr class="separator:ae9783541dea0fef4e4bfed1b9b43d98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc46b8476782082ba3b97e32e983e24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aedc46b8476782082ba3b97e32e983e24">SetDelayParameters</a> (<a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *pOutDelay, const <a class="el" href="structnn_1_1audio_1_1_delay_parameter_set.html">DelayParameterSet</a> *pParameterSet) noexcept</td></tr>
<tr class="memdesc:aedc46b8476782082ba3b97e32e983e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">nn::audio::DelayType</a></code> effect parameters.  <a href="namespacenn_1_1audio.html#aedc46b8476782082ba3b97e32e983e24">More...</a><br /></td></tr>
<tr class="separator:aedc46b8476782082ba3b97e32e983e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">API Resources For Audio Renderer Reverb Effects</div></td></tr>
<tr class="memitem:ac15587e48e655921e4a3816e20602080"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ac15587e48e655921e4a3816e20602080">GetRequiredBufferSizeForReverb</a> (int sampleRate, int channelCountMax) noexcept</td></tr>
<tr class="memdesc:ac15587e48e655921e4a3816e20602080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the work buffer size required for the renderer in order to use <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code>.  <a href="namespacenn_1_1audio.html#ac15587e48e655921e4a3816e20602080">More...</a><br /></td></tr>
<tr class="separator:ac15587e48e655921e4a3816e20602080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa081b9cab7e4ca8d079093c1fc50bb4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aa081b9cab7e4ca8d079093c1fc50bb4d">AddReverb</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb, void *buffer, size_t bufferSize, <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pFinalMix, int channelCountMax) noexcept</td></tr>
<tr class="memdesc:aa081b9cab7e4ca8d079093c1fc50bb4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>.  <a href="namespacenn_1_1audio.html#aa081b9cab7e4ca8d079093c1fc50bb4d">More...</a><br /></td></tr>
<tr class="separator:aa081b9cab7e4ca8d079093c1fc50bb4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058f117990f85d9d9e846282f6641e56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a058f117990f85d9d9e846282f6641e56">AddReverb</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb, void *buffer, size_t bufferSize, <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pSubMix, int channelCountMax) noexcept</td></tr>
<tr class="memdesc:a058f117990f85d9d9e846282f6641e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>.  <a href="namespacenn_1_1audio.html#a058f117990f85d9d9e846282f6641e56">More...</a><br /></td></tr>
<tr class="separator:a058f117990f85d9d9e846282f6641e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dda67780e46472ca22360376e6eb831"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a8dda67780e46472ca22360376e6eb831">RemoveReverb</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb, <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pFinalMix) noexcept</td></tr>
<tr class="memdesc:a8dda67780e46472ca22360376e6eb831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a <code><em><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></em></code> object from <code>FinalMix</code>.  <a href="namespacenn_1_1audio.html#a8dda67780e46472ca22360376e6eb831">More...</a><br /></td></tr>
<tr class="separator:a8dda67780e46472ca22360376e6eb831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd0546c68c93f7c420c9c93877eb59c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#abfd0546c68c93f7c420c9c93877eb59c">RemoveReverb</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb, <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pSubMix) noexcept</td></tr>
<tr class="memdesc:abfd0546c68c93f7c420c9c93877eb59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a <code><em><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></em></code> object from <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>.  <a href="namespacenn_1_1audio.html#abfd0546c68c93f7c420c9c93877eb59c">More...</a><br /></td></tr>
<tr class="separator:abfd0546c68c93f7c420c9c93877eb59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4e54df3d6356d4f5e8271acd78bd79"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aff4e54df3d6356d4f5e8271acd78bd79">GetReverbChannelCountMax</a> (const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:aff4e54df3d6356d4f5e8271acd78bd79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum number of channels that can be set for <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code>.  <a href="namespacenn_1_1audio.html#aff4e54df3d6356d4f5e8271acd78bd79">More...</a><br /></td></tr>
<tr class="separator:aff4e54df3d6356d4f5e8271acd78bd79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0e36cd224e963c355f8ef8fa88c38a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aff0e36cd224e963c355f8ef8fa88c38a">SetReverbInputOutput</a> (<a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb, const int8_t *input, const int8_t *output, int count) noexcept</td></tr>
<tr class="memdesc:aff0e36cd224e963c355f8ef8fa88c38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> input/output mix buffer indexes.  <a href="namespacenn_1_1audio.html#aff0e36cd224e963c355f8ef8fa88c38a">More...</a><br /></td></tr>
<tr class="separator:aff0e36cd224e963c355f8ef8fa88c38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c82e46e546877b86967dccd7f67f4b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a8c82e46e546877b86967dccd7f67f4b1">GetReverbInputOutput</a> (const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb, int8_t *outInput, int8_t *outOutput, int *pOutCount, int count) noexcept</td></tr>
<tr class="memdesc:a8c82e46e546877b86967dccd7f67f4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the indexes of the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> input/output mix buffers.  <a href="namespacenn_1_1audio.html#a8c82e46e546877b86967dccd7f67f4b1">More...</a><br /></td></tr>
<tr class="separator:a8c82e46e546877b86967dccd7f67f4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d434d80021951b86f047646bf365fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1audio_1_1_reverb_type.html#aba28878a06e614f8cfcebe12af7e0d50">ReverbType::EarlyMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ad2d434d80021951b86f047646bf365fb">GetReverbEarlyMode</a> (const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:ad2d434d80021951b86f047646bf365fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the early reflected sound mode of the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#ad2d434d80021951b86f047646bf365fb">More...</a><br /></td></tr>
<tr class="separator:ad2d434d80021951b86f047646bf365fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27abfee25a0a706e70ff422ce1e98052"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a27abfee25a0a706e70ff422ce1e98052">SetReverbEarlyMode</a> (<a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb, <a class="el" href="structnn_1_1audio_1_1_reverb_type.html#aba28878a06e614f8cfcebe12af7e0d50">ReverbType::EarlyMode</a> mode) noexcept</td></tr>
<tr class="memdesc:a27abfee25a0a706e70ff422ce1e98052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the early reflected sound mode for the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#a27abfee25a0a706e70ff422ce1e98052">More...</a><br /></td></tr>
<tr class="separator:a27abfee25a0a706e70ff422ce1e98052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f673bcf0e2f9732a182bdeb0a8c57a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a27f673bcf0e2f9732a182bdeb0a8c57a">GetReverbEarlyGain</a> (const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:a27f673bcf0e2f9732a182bdeb0a8c57a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the gain of the early reflected sound of the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#a27f673bcf0e2f9732a182bdeb0a8c57a">More...</a><br /></td></tr>
<tr class="separator:a27f673bcf0e2f9732a182bdeb0a8c57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f590b0ee7bb678ed5fe5dd4c7a34625"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a9f590b0ee7bb678ed5fe5dd4c7a34625">SetReverbEarlyGain</a> (<a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb, float gain) noexcept</td></tr>
<tr class="memdesc:a9f590b0ee7bb678ed5fe5dd4c7a34625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the gain of the early reflected sound for the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#a9f590b0ee7bb678ed5fe5dd4c7a34625">More...</a><br /></td></tr>
<tr class="separator:a9f590b0ee7bb678ed5fe5dd4c7a34625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f70a8ace1728dd6be20426d375df8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a18f70a8ace1728dd6be20426d375df8d">GetReverbPredelayTime</a> (const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:a18f70a8ace1728dd6be20426d375df8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pre-delay time of the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#a18f70a8ace1728dd6be20426d375df8d">More...</a><br /></td></tr>
<tr class="separator:a18f70a8ace1728dd6be20426d375df8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48695d8f40bbbc14bef58d2d1033bd7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a48695d8f40bbbc14bef58d2d1033bd7e">SetReverbPredelayTime</a> (<a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb, <a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> time) noexcept</td></tr>
<tr class="memdesc:a48695d8f40bbbc14bef58d2d1033bd7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the pre-delay time for the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#a48695d8f40bbbc14bef58d2d1033bd7e">More...</a><br /></td></tr>
<tr class="separator:a48695d8f40bbbc14bef58d2d1033bd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482077842a0a7eff2cf07674d7d1cc4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1audio_1_1_reverb_type.html#a180b7274e24a924de18f2523852626ac">ReverbType::LateMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a482077842a0a7eff2cf07674d7d1cc4d">GetReverbLateMode</a> (const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:a482077842a0a7eff2cf07674d7d1cc4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the late reverb sound mode of the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#a482077842a0a7eff2cf07674d7d1cc4d">More...</a><br /></td></tr>
<tr class="separator:a482077842a0a7eff2cf07674d7d1cc4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697f7a665c9bcc92536e9415a0143e24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a697f7a665c9bcc92536e9415a0143e24">SetReverbLateMode</a> (<a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb, <a class="el" href="structnn_1_1audio_1_1_reverb_type.html#a180b7274e24a924de18f2523852626ac">ReverbType::LateMode</a> mode) noexcept</td></tr>
<tr class="memdesc:a697f7a665c9bcc92536e9415a0143e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the late reverb sound mode for the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#a697f7a665c9bcc92536e9415a0143e24">More...</a><br /></td></tr>
<tr class="separator:a697f7a665c9bcc92536e9415a0143e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87d0bc0f4478187c6bd792ab847f3c0"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#af87d0bc0f4478187c6bd792ab847f3c0">GetReverbLateGain</a> (const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:af87d0bc0f4478187c6bd792ab847f3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the gain of the late reverb of the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#af87d0bc0f4478187c6bd792ab847f3c0">More...</a><br /></td></tr>
<tr class="separator:af87d0bc0f4478187c6bd792ab847f3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7938c31a464de54d5a8e0e655dfe6381"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a7938c31a464de54d5a8e0e655dfe6381">SetReverbLateGain</a> (<a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb, float gain) noexcept</td></tr>
<tr class="memdesc:a7938c31a464de54d5a8e0e655dfe6381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the gain of the late reverb for the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#a7938c31a464de54d5a8e0e655dfe6381">More...</a><br /></td></tr>
<tr class="separator:a7938c31a464de54d5a8e0e655dfe6381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4e3eb8a6f9379bd4fa39f976861ac1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aba4e3eb8a6f9379bd4fa39f976861ac1">GetReverbDecayTime</a> (const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:aba4e3eb8a6f9379bd4fa39f976861ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the reverberation time of the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#aba4e3eb8a6f9379bd4fa39f976861ac1">More...</a><br /></td></tr>
<tr class="separator:aba4e3eb8a6f9379bd4fa39f976861ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18ec92d863f3795cca87501c0fae0fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ae18ec92d863f3795cca87501c0fae0fe">SetReverbDecayTime</a> (<a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb, <a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> time) noexcept</td></tr>
<tr class="memdesc:ae18ec92d863f3795cca87501c0fae0fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the reverberation time for the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#ae18ec92d863f3795cca87501c0fae0fe">More...</a><br /></td></tr>
<tr class="separator:ae18ec92d863f3795cca87501c0fae0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9529458496a896c0346d89c59b00514"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ab9529458496a896c0346d89c59b00514">GetReverbHighFrequencyDecayRatio</a> (const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:ab9529458496a896c0346d89c59b00514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the high-frequency attenuation rate of the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#ab9529458496a896c0346d89c59b00514">More...</a><br /></td></tr>
<tr class="separator:ab9529458496a896c0346d89c59b00514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d498965acc8537a96cb09975beaffb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a5d498965acc8537a96cb09975beaffb3">SetReverbHighFrequencyDecayRatio</a> (<a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb, float ratio) noexcept</td></tr>
<tr class="memdesc:a5d498965acc8537a96cb09975beaffb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the high-frequency attenuation rate for the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#a5d498965acc8537a96cb09975beaffb3">More...</a><br /></td></tr>
<tr class="separator:a5d498965acc8537a96cb09975beaffb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b63fd521d0802b30c5225e16f02a38"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a15b63fd521d0802b30c5225e16f02a38">GetReverbColoration</a> (const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:a15b63fd521d0802b30c5225e16f02a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the reverb coloration parameter of the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#a15b63fd521d0802b30c5225e16f02a38">More...</a><br /></td></tr>
<tr class="separator:a15b63fd521d0802b30c5225e16f02a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4ac77900079e7b2ed46d4786ea6d47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aad4ac77900079e7b2ed46d4786ea6d47">SetReverbColoration</a> (<a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb, float value) noexcept</td></tr>
<tr class="memdesc:aad4ac77900079e7b2ed46d4786ea6d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the reverb coloration parameter for the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#aad4ac77900079e7b2ed46d4786ea6d47">More...</a><br /></td></tr>
<tr class="separator:aad4ac77900079e7b2ed46d4786ea6d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d20ae6043da7f7ce625c8f995ae5e3f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a1d20ae6043da7f7ce625c8f995ae5e3f">GetReverbReverbGain</a> (const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:a1d20ae6043da7f7ce625c8f995ae5e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the reverb gain of the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#a1d20ae6043da7f7ce625c8f995ae5e3f">More...</a><br /></td></tr>
<tr class="separator:a1d20ae6043da7f7ce625c8f995ae5e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe0d6397b0092e46b93632a7ac5e55e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#adfe0d6397b0092e46b93632a7ac5e55e">SetReverbReverbGain</a> (<a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb, float gain) noexcept</td></tr>
<tr class="memdesc:adfe0d6397b0092e46b93632a7ac5e55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the reverb gain for the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#adfe0d6397b0092e46b93632a7ac5e55e">More...</a><br /></td></tr>
<tr class="separator:adfe0d6397b0092e46b93632a7ac5e55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98af6a84f74bfea25631b3f0d0e2ff19"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a98af6a84f74bfea25631b3f0d0e2ff19">GetReverbOutGain</a> (const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:a98af6a84f74bfea25631b3f0d0e2ff19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the output gain of the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#a98af6a84f74bfea25631b3f0d0e2ff19">More...</a><br /></td></tr>
<tr class="separator:a98af6a84f74bfea25631b3f0d0e2ff19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16465cda5c37905584b55897af87e57f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a16465cda5c37905584b55897af87e57f">SetReverbOutGain</a> (<a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb, float gain) noexcept</td></tr>
<tr class="memdesc:a16465cda5c37905584b55897af87e57f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the output gain for the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#a16465cda5c37905584b55897af87e57f">More...</a><br /></td></tr>
<tr class="separator:a16465cda5c37905584b55897af87e57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83cd9776d37fb17187714acdc0bdbcab"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a83cd9776d37fb17187714acdc0bdbcab">GetReverbDryGain</a> (const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:a83cd9776d37fb17187714acdc0bdbcab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the dry gain of the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#a83cd9776d37fb17187714acdc0bdbcab">More...</a><br /></td></tr>
<tr class="separator:a83cd9776d37fb17187714acdc0bdbcab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9937a89c853ffa172d1ccef907419cb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a9937a89c853ffa172d1ccef907419cb2">SetReverbDryGain</a> (<a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb, float gain) noexcept</td></tr>
<tr class="memdesc:a9937a89c853ffa172d1ccef907419cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dry gain for the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#a9937a89c853ffa172d1ccef907419cb2">More...</a><br /></td></tr>
<tr class="separator:a9937a89c853ffa172d1ccef907419cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e68ef8212f9dc5599d727f925db5fca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1audio_1_1_reverb_parameter_set.html">ReverbParameterSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a8e68ef8212f9dc5599d727f925db5fca">GetReverbParameters</a> (const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:a8e68ef8212f9dc5599d727f925db5fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">nn::audio::ReverbType</a></code> effect parameter.  <a href="namespacenn_1_1audio.html#a8e68ef8212f9dc5599d727f925db5fca">More...</a><br /></td></tr>
<tr class="separator:a8e68ef8212f9dc5599d727f925db5fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075fd070a208ac1d593d4e7614b5305f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a075fd070a208ac1d593d4e7614b5305f">SetReverbParameters</a> (<a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pOutReverb, const <a class="el" href="structnn_1_1audio_1_1_reverb_parameter_set.html">ReverbParameterSet</a> *pParameterSet) noexcept</td></tr>
<tr class="memdesc:a075fd070a208ac1d593d4e7614b5305f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">nn::audio::ReverbType</a></code> effect parameter.  <a href="namespacenn_1_1audio.html#a075fd070a208ac1d593d4e7614b5305f">More...</a><br /></td></tr>
<tr class="separator:a075fd070a208ac1d593d4e7614b5305f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5fe53550704575b0591936be0538be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a6f5fe53550704575b0591936be0538be">IsReverbEnabled</a> (const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:a6f5fe53550704575b0591936be0538be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object is enabled.  <a href="namespacenn_1_1audio.html#a6f5fe53550704575b0591936be0538be">More...</a><br /></td></tr>
<tr class="separator:a6f5fe53550704575b0591936be0538be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538fed00cd1c56b19858e73f6d06a59c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a538fed00cd1c56b19858e73f6d06a59c">SetReverbEnabled</a> (<a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb, bool enable) noexcept</td></tr>
<tr class="memdesc:a538fed00cd1c56b19858e73f6d06a59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object to be enabled or disabled.  <a href="namespacenn_1_1audio.html#a538fed00cd1c56b19858e73f6d06a59c">More...</a><br /></td></tr>
<tr class="separator:a538fed00cd1c56b19858e73f6d06a59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3b452f9bc03b127c6d1ea4b7e340eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#afb3b452f9bc03b127c6d1ea4b7e340eb">IsReverbRemovable</a> (const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:afb3b452f9bc03b127c6d1ea4b7e340eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object can be safely removed.  <a href="namespacenn_1_1audio.html#afb3b452f9bc03b127c6d1ea4b7e340eb">More...</a><br /></td></tr>
<tr class="separator:afb3b452f9bc03b127c6d1ea4b7e340eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">API Resources For Audio Renderer Aux Effects</div></td></tr>
<tr class="memitem:a55c33abdb3faf91f7f21f7fbf13c30fa"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a55c33abdb3faf91f7f21f7fbf13c30fa">GetRequiredBufferSizeForAuxSendReturnBuffer</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html">AudioRendererParameter</a> *pParameter, int mixBufferFrameCount, int channelCountMax) noexcept</td></tr>
<tr class="memdesc:a55c33abdb3faf91f7f21f7fbf13c30fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the work buffer size required for the renderer to use <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code>.  <a href="namespacenn_1_1audio.html#a55c33abdb3faf91f7f21f7fbf13c30fa">More...</a><br /></td></tr>
<tr class="separator:a55c33abdb3faf91f7f21f7fbf13c30fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086c8ae883a8dabacad2c3ff3e995f13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a086c8ae883a8dabacad2c3ff3e995f13">AddAux</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *pAux, <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pFinalMix, void *pSendBuffer, void *pReturnBuffer, size_t sendReturnBufferSize) noexcept</td></tr>
<tr class="memdesc:a086c8ae883a8dabacad2c3ff3e995f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>.  <a href="namespacenn_1_1audio.html#a086c8ae883a8dabacad2c3ff3e995f13">More...</a><br /></td></tr>
<tr class="separator:a086c8ae883a8dabacad2c3ff3e995f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9ded54aaf3b24b923e7f35f6bd80b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a9b9ded54aaf3b24b923e7f35f6bd80b7">AddAux</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *pAux, <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pSubMix, void *pSendBuffer, void *pReturnBuffer, size_t sendReturnBufferSize) noexcept</td></tr>
<tr class="memdesc:a9b9ded54aaf3b24b923e7f35f6bd80b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>.  <a href="namespacenn_1_1audio.html#a9b9ded54aaf3b24b923e7f35f6bd80b7">More...</a><br /></td></tr>
<tr class="separator:a9b9ded54aaf3b24b923e7f35f6bd80b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5133a62d6f97d3054e9ad428ae866102"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a5133a62d6f97d3054e9ad428ae866102">RemoveAux</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *pAux, <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pFinalMix) noexcept</td></tr>
<tr class="memdesc:a5133a62d6f97d3054e9ad428ae866102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> object from <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>.  <a href="namespacenn_1_1audio.html#a5133a62d6f97d3054e9ad428ae866102">More...</a><br /></td></tr>
<tr class="separator:a5133a62d6f97d3054e9ad428ae866102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8ec792b7a22fddb98d03bbefd81d80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a6e8ec792b7a22fddb98d03bbefd81d80">RemoveAux</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *pAux, <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pSubMix) noexcept</td></tr>
<tr class="memdesc:a6e8ec792b7a22fddb98d03bbefd81d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> object from <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>.  <a href="namespacenn_1_1audio.html#a6e8ec792b7a22fddb98d03bbefd81d80">More...</a><br /></td></tr>
<tr class="separator:a6e8ec792b7a22fddb98d03bbefd81d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c449b97f855ce0326406d1b48cc852"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ab5c449b97f855ce0326406d1b48cc852">GetAuxChannelCountMax</a> (const <a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *pAux) noexcept</td></tr>
<tr class="memdesc:ab5c449b97f855ce0326406d1b48cc852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum number of channels that can be set for <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code>.  <a href="namespacenn_1_1audio.html#ab5c449b97f855ce0326406d1b48cc852">More...</a><br /></td></tr>
<tr class="separator:ab5c449b97f855ce0326406d1b48cc852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa5e908a8184cac74c099faae2fbdd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a1fa5e908a8184cac74c099faae2fbdd3">GetAuxInputOutput</a> (const <a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *pAux, int8_t *pOutInput, int8_t *pOutOutput, int *pOutCount, int count) noexcept</td></tr>
<tr class="memdesc:a1fa5e908a8184cac74c099faae2fbdd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the indexes of the <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> input/output mix buffers.  <a href="namespacenn_1_1audio.html#a1fa5e908a8184cac74c099faae2fbdd3">More...</a><br /></td></tr>
<tr class="separator:a1fa5e908a8184cac74c099faae2fbdd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5f32d682169896adb6d6e6b08f5155"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a9d5f32d682169896adb6d6e6b08f5155">SetAuxInputOutput</a> (<a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *pAux, const int8_t *input, const int8_t *output, const int count) noexcept</td></tr>
<tr class="memdesc:a9d5f32d682169896adb6d6e6b08f5155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the input/output buffer indexes for <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code>.  <a href="namespacenn_1_1audio.html#a9d5f32d682169896adb6d6e6b08f5155">More...</a><br /></td></tr>
<tr class="separator:a9d5f32d682169896adb6d6e6b08f5155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf2f0b6dfbaa1b020d61cd56b963965"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#adaf2f0b6dfbaa1b020d61cd56b963965">ReadAuxSendBuffer</a> (<a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *pAux, int32_t *pOutData, int count) noexcept</td></tr>
<tr class="memdesc:adaf2f0b6dfbaa1b020d61cd56b963965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads <code><em>count</em></code> number of samples from <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code>.  <a href="namespacenn_1_1audio.html#adaf2f0b6dfbaa1b020d61cd56b963965">More...</a><br /></td></tr>
<tr class="separator:adaf2f0b6dfbaa1b020d61cd56b963965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28965347a7dc482c646c14e579449359"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a28965347a7dc482c646c14e579449359">WriteAuxReturnBuffer</a> (<a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *pAux, const int32_t *pData, int count) noexcept</td></tr>
<tr class="memdesc:a28965347a7dc482c646c14e579449359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes <code><em>count</em></code> number of samples to <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code>.  <a href="namespacenn_1_1audio.html#a28965347a7dc482c646c14e579449359">More...</a><br /></td></tr>
<tr class="separator:a28965347a7dc482c646c14e579449359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2970bf3cba541e147e48d4d66d4e90b3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a2970bf3cba541e147e48d4d66d4e90b3">GetAuxSampleRate</a> (const <a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *pAux) noexcept</td></tr>
<tr class="memdesc:a2970bf3cba541e147e48d4d66d4e90b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sample rate of the <code>SendBuffer</code> and <code>ReturnBuffer</code> managed by <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code>.  <a href="namespacenn_1_1audio.html#a2970bf3cba541e147e48d4d66d4e90b3">More...</a><br /></td></tr>
<tr class="separator:a2970bf3cba541e147e48d4d66d4e90b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93cec9d3d8321e68c73e10636d34a1e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a93cec9d3d8321e68c73e10636d34a1e2">GetAuxSampleCount</a> (const <a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *pAux) noexcept</td></tr>
<tr class="memdesc:a93cec9d3d8321e68c73e10636d34a1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum number of samples that can be held by the <code>SendBuffer</code> and <code>ReturnBuffer</code> objects managed by <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code>.  <a href="namespacenn_1_1audio.html#a93cec9d3d8321e68c73e10636d34a1e2">More...</a><br /></td></tr>
<tr class="separator:a93cec9d3d8321e68c73e10636d34a1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b050f16f147043944dc199115105bc9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a3b050f16f147043944dc199115105bc9">IsAuxEnabled</a> (const <a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *pAux) noexcept</td></tr>
<tr class="memdesc:a3b050f16f147043944dc199115105bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> is enabled.  <a href="namespacenn_1_1audio.html#a3b050f16f147043944dc199115105bc9">More...</a><br /></td></tr>
<tr class="separator:a3b050f16f147043944dc199115105bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2b1ab69fe2131d81a8439e8a7ca5b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#afd2b1ab69fe2131d81a8439e8a7ca5b9">SetAuxEnabled</a> (<a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *pAux, bool enable) noexcept</td></tr>
<tr class="memdesc:afd2b1ab69fe2131d81a8439e8a7ca5b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether a <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> is enabled.  <a href="namespacenn_1_1audio.html#afd2b1ab69fe2131d81a8439e8a7ca5b9">More...</a><br /></td></tr>
<tr class="separator:afd2b1ab69fe2131d81a8439e8a7ca5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b94b1f2bb19fac01f8859ed4f3cc19e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a3b94b1f2bb19fac01f8859ed4f3cc19e">IsAuxRemovable</a> (const <a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *pAux) noexcept</td></tr>
<tr class="memdesc:a3b94b1f2bb19fac01f8859ed4f3cc19e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> can be safely removed.  <a href="namespacenn_1_1audio.html#a3b94b1f2bb19fac01f8859ed4f3cc19e">More...</a><br /></td></tr>
<tr class="separator:a3b94b1f2bb19fac01f8859ed4f3cc19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbadc0832469ad712cf5239701963b79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1audio_1_1_aux_buffer_statistics.html">AuxBufferStatistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#adbadc0832469ad712cf5239701963b79">GetAuxBufferStatistics</a> (const <a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *pEffect) noexcept</td></tr>
<tr class="memdesc:adbadc0832469ad712cf5239701963b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets statistical information associated with the <code>SendBuffer</code> and <code>ReturnBuffer</code> managed by <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code>.  <a href="namespacenn_1_1audio.html#adbadc0832469ad712cf5239701963b79">More...</a><br /></td></tr>
<tr class="separator:adbadc0832469ad712cf5239701963b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ccb484757258ce2b9500822b3a763c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a44ccb484757258ce2b9500822b3a763c">ResetAuxBufferStatistics</a> (<a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *pEffect) noexcept</td></tr>
<tr class="memdesc:a44ccb484757258ce2b9500822b3a763c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets statistical information associated with the <code>SendBuffer</code> and <code>ReturnBuffer</code> managed by <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code>.  <a href="namespacenn_1_1audio.html#a44ccb484757258ce2b9500822b3a763c">More...</a><br /></td></tr>
<tr class="separator:a44ccb484757258ce2b9500822b3a763c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">API Resources For Audio Renderer I3DL2Reverb Effects</div></td></tr>
<tr class="memitem:acffef82a64528c1598e0c49ee718c621"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#acffef82a64528c1598e0c49ee718c621">GetRequiredBufferSizeForI3dl2Reverb</a> (int sampleRate, int channelCountMax) noexcept</td></tr>
<tr class="memdesc:acffef82a64528c1598e0c49ee718c621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the work buffer size required for the renderer to use <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code>.  <a href="namespacenn_1_1audio.html#acffef82a64528c1598e0c49ee718c621">More...</a><br /></td></tr>
<tr class="separator:acffef82a64528c1598e0c49ee718c621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88bff95c7242f9d37ae5f631e825648b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a88bff95c7242f9d37ae5f631e825648b">AddI3dl2Reverb</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pOutReverb, void *buffer, size_t bufferSize, <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pFinalMix, int channelCountMax) noexcept</td></tr>
<tr class="memdesc:a88bff95c7242f9d37ae5f631e825648b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>.  <a href="namespacenn_1_1audio.html#a88bff95c7242f9d37ae5f631e825648b">More...</a><br /></td></tr>
<tr class="separator:a88bff95c7242f9d37ae5f631e825648b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c50625e1c29fd3cd2c7b6f2365f8d50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a0c50625e1c29fd3cd2c7b6f2365f8d50">AddI3dl2Reverb</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pOutReverb, void *buffer, size_t bufferSize, <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pSubMix, int channelCountMax) noexcept</td></tr>
<tr class="memdesc:a0c50625e1c29fd3cd2c7b6f2365f8d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>.  <a href="namespacenn_1_1audio.html#a0c50625e1c29fd3cd2c7b6f2365f8d50">More...</a><br /></td></tr>
<tr class="separator:a0c50625e1c29fd3cd2c7b6f2365f8d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e1724b072fff4284c19e597ac94d84"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a32e1724b072fff4284c19e597ac94d84">RemoveI3dl2Reverb</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb, <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pFinalMix) noexcept</td></tr>
<tr class="memdesc:a32e1724b072fff4284c19e597ac94d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a <code><em><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></em></code> object from <code>FinalMix</code>.  <a href="namespacenn_1_1audio.html#a32e1724b072fff4284c19e597ac94d84">More...</a><br /></td></tr>
<tr class="separator:a32e1724b072fff4284c19e597ac94d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473dc9ed4c9710f507a21809c5baf5e4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a473dc9ed4c9710f507a21809c5baf5e4">RemoveI3dl2Reverb</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb, <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pSubMix) noexcept</td></tr>
<tr class="memdesc:a473dc9ed4c9710f507a21809c5baf5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a <code><em><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></em></code> object from <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>.  <a href="namespacenn_1_1audio.html#a473dc9ed4c9710f507a21809c5baf5e4">More...</a><br /></td></tr>
<tr class="separator:a473dc9ed4c9710f507a21809c5baf5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252041cc7854a8ca48f6e9877b545ed1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a252041cc7854a8ca48f6e9877b545ed1">IsI3dl2ReverbRemovable</a> (const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:a252041cc7854a8ca48f6e9877b545ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object can be safely removed.  <a href="namespacenn_1_1audio.html#a252041cc7854a8ca48f6e9877b545ed1">More...</a><br /></td></tr>
<tr class="separator:a252041cc7854a8ca48f6e9877b545ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf04a6b384cf7f7fe6137d628c62871e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#adf04a6b384cf7f7fe6137d628c62871e">GetI3dl2ReverbChannelCountMax</a> (const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:adf04a6b384cf7f7fe6137d628c62871e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum number of channels that can be set for <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code>.  <a href="namespacenn_1_1audio.html#adf04a6b384cf7f7fe6137d628c62871e">More...</a><br /></td></tr>
<tr class="separator:adf04a6b384cf7f7fe6137d628c62871e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a90f3cc29f82384d648da644233ed23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a4a90f3cc29f82384d648da644233ed23">GetI3dl2ReverbInputOutput</a> (const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb, int8_t *outInput, int8_t *outOutput, int *pOutCount, int count) noexcept</td></tr>
<tr class="memdesc:a4a90f3cc29f82384d648da644233ed23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> input/output mix buffer indexes.  <a href="namespacenn_1_1audio.html#a4a90f3cc29f82384d648da644233ed23">More...</a><br /></td></tr>
<tr class="separator:a4a90f3cc29f82384d648da644233ed23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a31783d96a7f992dc95ebd30a9ad3db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a8a31783d96a7f992dc95ebd30a9ad3db">SetI3dl2ReverbInputOutput</a> (<a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb, const int8_t *input, const int8_t *output, int count) noexcept</td></tr>
<tr class="memdesc:a8a31783d96a7f992dc95ebd30a9ad3db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> input/output mix buffer indexes.  <a href="namespacenn_1_1audio.html#a8a31783d96a7f992dc95ebd30a9ad3db">More...</a><br /></td></tr>
<tr class="separator:a8a31783d96a7f992dc95ebd30a9ad3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3b9fcb3a508698685e01de1dddcba1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a6d3b9fcb3a508698685e01de1dddcba1">SetI3dl2ReverbRoomGain</a> (<a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb, float room) noexcept</td></tr>
<tr class="memdesc:a6d3b9fcb3a508698685e01de1dddcba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the room gain of the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#a6d3b9fcb3a508698685e01de1dddcba1">More...</a><br /></td></tr>
<tr class="separator:a6d3b9fcb3a508698685e01de1dddcba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9d95aae46a165e9452c0a519d9926d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a9e9d95aae46a165e9452c0a519d9926d">GetI3dl2ReverbRoomGain</a> (const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:a9e9d95aae46a165e9452c0a519d9926d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the room gain of the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#a9e9d95aae46a165e9452c0a519d9926d">More...</a><br /></td></tr>
<tr class="separator:a9e9d95aae46a165e9452c0a519d9926d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9838aad6e5138efe0e492b6586a742"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aae9838aad6e5138efe0e492b6586a742">SetI3dl2ReverbRoomHfGain</a> (<a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb, float roomHf) noexcept</td></tr>
<tr class="memdesc:aae9838aad6e5138efe0e492b6586a742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the attenuation for high-frequency components, using low-frequency components as the basis, for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#aae9838aad6e5138efe0e492b6586a742">More...</a><br /></td></tr>
<tr class="separator:aae9838aad6e5138efe0e492b6586a742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305d3c374ac911c69b0642f5360bb052"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a305d3c374ac911c69b0642f5360bb052">GetI3dl2ReverbRoomHfGain</a> (const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:a305d3c374ac911c69b0642f5360bb052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the attenuation for high-frequency components, using low-frequency components as the basis, for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#a305d3c374ac911c69b0642f5360bb052">More...</a><br /></td></tr>
<tr class="separator:a305d3c374ac911c69b0642f5360bb052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a11597710a0f2bbb30eb60e28808cfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a6a11597710a0f2bbb30eb60e28808cfa">SetI3dl2ReverbLateReverbDecayTime</a> (<a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb, <a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> time) noexcept</td></tr>
<tr class="memdesc:a6a11597710a0f2bbb30eb60e28808cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the reverberation time for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#a6a11597710a0f2bbb30eb60e28808cfa">More...</a><br /></td></tr>
<tr class="separator:a6a11597710a0f2bbb30eb60e28808cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98093560487330f1a25ab13b826427f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a98093560487330f1a25ab13b826427f5">GetI3dl2ReverbLateReverbDecayTime</a> (const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:a98093560487330f1a25ab13b826427f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the reverberation time of the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#a98093560487330f1a25ab13b826427f5">More...</a><br /></td></tr>
<tr class="separator:a98093560487330f1a25ab13b826427f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad30ac49698bba62743bc16134c9fa9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aad30ac49698bba62743bc16134c9fa9f">SetI3dl2ReverbLateReverbHfDecayRatio</a> (<a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb, float hfDecayRatio) noexcept</td></tr>
<tr class="memdesc:aad30ac49698bba62743bc16134c9fa9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the ratio of reverb time for high-frequency components as compared to reverb time for low-frequency components for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#aad30ac49698bba62743bc16134c9fa9f">More...</a><br /></td></tr>
<tr class="separator:aad30ac49698bba62743bc16134c9fa9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7bff456f63109630c5051f31896f01c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ab7bff456f63109630c5051f31896f01c">GetI3dl2ReverbLateReverbHfDecayRatio</a> (const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:ab7bff456f63109630c5051f31896f01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the ratio of reverb time for high-frequency components as compared to reverb time for low-frequency components for <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code>.  <a href="namespacenn_1_1audio.html#ab7bff456f63109630c5051f31896f01c">More...</a><br /></td></tr>
<tr class="separator:ab7bff456f63109630c5051f31896f01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6dc3f9e7027504cf7e617495831288"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#afa6dc3f9e7027504cf7e617495831288">SetI3dl2ReverbReflectionsGain</a> (<a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb, float reflections) noexcept</td></tr>
<tr class="memdesc:afa6dc3f9e7027504cf7e617495831288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the early reflected sound level based on the room gain for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#afa6dc3f9e7027504cf7e617495831288">More...</a><br /></td></tr>
<tr class="separator:afa6dc3f9e7027504cf7e617495831288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45ebec61b8d07839bf8dc6fa8e36f30"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ab45ebec61b8d07839bf8dc6fa8e36f30">GetI3dl2ReverbReflectionsGain</a> (const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:ab45ebec61b8d07839bf8dc6fa8e36f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the early reflected sound level based on the room gain for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#ab45ebec61b8d07839bf8dc6fa8e36f30">More...</a><br /></td></tr>
<tr class="separator:ab45ebec61b8d07839bf8dc6fa8e36f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b8448789678f7c4eb96e299b245889"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a78b8448789678f7c4eb96e299b245889">SetI3dl2ReverbReflectionDelayTime</a> (<a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb, <a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> time) noexcept</td></tr>
<tr class="memdesc:a78b8448789678f7c4eb96e299b245889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the latency of the early reflected sound based on the direct sound for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#a78b8448789678f7c4eb96e299b245889">More...</a><br /></td></tr>
<tr class="separator:a78b8448789678f7c4eb96e299b245889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41959e9a0094f683cfcff34b3157b500"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a41959e9a0094f683cfcff34b3157b500">GetI3dl2ReverbReflectionDelayTime</a> (const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:a41959e9a0094f683cfcff34b3157b500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the latency of the early reflected sound based on the direct sound for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#a41959e9a0094f683cfcff34b3157b500">More...</a><br /></td></tr>
<tr class="separator:a41959e9a0094f683cfcff34b3157b500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370d8d1264111192626a30c1e398f3c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a370d8d1264111192626a30c1e398f3c3">SetI3dl2ReverbReverbGain</a> (<a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb, float reverb) noexcept</td></tr>
<tr class="memdesc:a370d8d1264111192626a30c1e398f3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the early reflected sound level based on the room gain for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#a370d8d1264111192626a30c1e398f3c3">More...</a><br /></td></tr>
<tr class="separator:a370d8d1264111192626a30c1e398f3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5366afdedba8ad877154cd3ffb94c2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a9f5366afdedba8ad877154cd3ffb94c2">GetI3dl2ReverbReverbGain</a> (const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:a9f5366afdedba8ad877154cd3ffb94c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the late reverberation level based on the room gain for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#a9f5366afdedba8ad877154cd3ffb94c2">More...</a><br /></td></tr>
<tr class="separator:a9f5366afdedba8ad877154cd3ffb94c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2109f9f8c35ae695cd4b4b9d4883c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a4e2109f9f8c35ae695cd4b4b9d4883c1">SetI3dl2ReverbLateReverbDelayTime</a> (<a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb, <a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> time) noexcept</td></tr>
<tr class="memdesc:a4e2109f9f8c35ae695cd4b4b9d4883c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the latency of the late reverberation based on the early reflected sound for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#a4e2109f9f8c35ae695cd4b4b9d4883c1">More...</a><br /></td></tr>
<tr class="separator:a4e2109f9f8c35ae695cd4b4b9d4883c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae098ed845f298857adaea3ad8ce84450"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ae098ed845f298857adaea3ad8ce84450">GetI3dl2ReverbLateReverbDelayTime</a> (const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:ae098ed845f298857adaea3ad8ce84450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the latency of the late reverberation based on the early reflected sound for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#ae098ed845f298857adaea3ad8ce84450">More...</a><br /></td></tr>
<tr class="separator:ae098ed845f298857adaea3ad8ce84450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae214c1d78ad0282973bd915854acd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#adae214c1d78ad0282973bd915854acd5">SetI3dl2ReverbLateReverbDiffusion</a> (<a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb, float diffusion) noexcept</td></tr>
<tr class="memdesc:adae214c1d78ad0282973bd915854acd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the echo density of the late reverberation for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#adae214c1d78ad0282973bd915854acd5">More...</a><br /></td></tr>
<tr class="separator:adae214c1d78ad0282973bd915854acd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488235ededae0fa48e55b7296f7b7a28"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a488235ededae0fa48e55b7296f7b7a28">GetI3dl2ReverbLateReverbDiffusion</a> (const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:a488235ededae0fa48e55b7296f7b7a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the echo density of the late reverberation of the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#a488235ededae0fa48e55b7296f7b7a28">More...</a><br /></td></tr>
<tr class="separator:a488235ededae0fa48e55b7296f7b7a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33ac8b566a98f9967a603a98c39cb38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ab33ac8b566a98f9967a603a98c39cb38">SetI3dl2ReverbLateReverbDensity</a> (<a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb, float density) noexcept</td></tr>
<tr class="memdesc:ab33ac8b566a98f9967a603a98c39cb38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the modal density of the late reverberation for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#ab33ac8b566a98f9967a603a98c39cb38">More...</a><br /></td></tr>
<tr class="separator:ab33ac8b566a98f9967a603a98c39cb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9683dabafbc1785cfe8bca1874bbe8"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#acb9683dabafbc1785cfe8bca1874bbe8">GetI3dl2ReverbLateReverbDensity</a> (const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:acb9683dabafbc1785cfe8bca1874bbe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the modal density of the late reverberation for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#acb9683dabafbc1785cfe8bca1874bbe8">More...</a><br /></td></tr>
<tr class="separator:acb9683dabafbc1785cfe8bca1874bbe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7c0584a83e1cd1309f59234c3ec693"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#abc7c0584a83e1cd1309f59234c3ec693">SetI3dl2ReverbHfReference</a> (<a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb, float hfReference) noexcept</td></tr>
<tr class="memdesc:abc7c0584a83e1cd1309f59234c3ec693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the high-frequency reference frequency for <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> objects.  <a href="namespacenn_1_1audio.html#abc7c0584a83e1cd1309f59234c3ec693">More...</a><br /></td></tr>
<tr class="separator:abc7c0584a83e1cd1309f59234c3ec693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2a8a9c28a5fc5500dbbf553e0c183b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aea2a8a9c28a5fc5500dbbf553e0c183b">GetI3dl2ReverbHfReference</a> (const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:aea2a8a9c28a5fc5500dbbf553e0c183b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the high-frequency reference frequency for <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> objects.  <a href="namespacenn_1_1audio.html#aea2a8a9c28a5fc5500dbbf553e0c183b">More...</a><br /></td></tr>
<tr class="separator:aea2a8a9c28a5fc5500dbbf553e0c183b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b700e630d0b1ab68099dd4477cb70c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a21b700e630d0b1ab68099dd4477cb70c">SetI3dl2ReverbDryGain</a> (<a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb, float dryGain) noexcept</td></tr>
<tr class="memdesc:a21b700e630d0b1ab68099dd4477cb70c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> dry gain for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#a21b700e630d0b1ab68099dd4477cb70c">More...</a><br /></td></tr>
<tr class="separator:a21b700e630d0b1ab68099dd4477cb70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c9e3063f2ff99589dea564c67f96bd"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aa0c9e3063f2ff99589dea564c67f96bd">GetI3dl2ReverbDryGain</a> (const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:aa0c9e3063f2ff99589dea564c67f96bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the dry gain of the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object.  <a href="namespacenn_1_1audio.html#aa0c9e3063f2ff99589dea564c67f96bd">More...</a><br /></td></tr>
<tr class="separator:aa0c9e3063f2ff99589dea564c67f96bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fba605639e5efcebf031e9fb1f1829a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a9fba605639e5efcebf031e9fb1f1829a">SetI3dl2ReverbParameters</a> (<a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pOutReverb, const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_parameter_set.html">I3dl2ReverbParameterSet</a> *pParameterSet) noexcept</td></tr>
<tr class="memdesc:a9fba605639e5efcebf031e9fb1f1829a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">nn::audio::I3dl2ReverbType</a></code> effect parameters.  <a href="namespacenn_1_1audio.html#a9fba605639e5efcebf031e9fb1f1829a">More...</a><br /></td></tr>
<tr class="separator:a9fba605639e5efcebf031e9fb1f1829a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091075a7213e39d2b1df8359256dab70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_parameter_set.html">I3dl2ReverbParameterSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a091075a7213e39d2b1df8359256dab70">GetI3dl2ReverbParameters</a> (const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:a091075a7213e39d2b1df8359256dab70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">nn::audio::I3dl2ReverbType</a></code> effect parameters.  <a href="namespacenn_1_1audio.html#a091075a7213e39d2b1df8359256dab70">More...</a><br /></td></tr>
<tr class="separator:a091075a7213e39d2b1df8359256dab70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a1099a74d7eb2226b53e0759ee5ef0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#af9a1099a74d7eb2226b53e0759ee5ef0">LoadI3dl2ReverbPreset</a> (<a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_parameter_set.html">I3dl2ReverbParameterSet</a> *pOutParameter, <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html#a56691f5a002784e036b1a462ef7067bc">I3dl2ReverbType::Preset</a> preset) noexcept</td></tr>
<tr class="memdesc:af9a1099a74d7eb2226b53e0759ee5ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">nn::audio::I3dl2ReverbType</a></code> effect parameters comparable to a preset.  <a href="namespacenn_1_1audio.html#af9a1099a74d7eb2226b53e0759ee5ef0">More...</a><br /></td></tr>
<tr class="separator:af9a1099a74d7eb2226b53e0759ee5ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3b4f1b5b17ad7caa0ca2e8a9ea9f90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aca3b4f1b5b17ad7caa0ca2e8a9ea9f90">SetI3dl2ReverbEnabled</a> (<a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb, bool enable) noexcept</td></tr>
<tr class="memdesc:aca3b4f1b5b17ad7caa0ca2e8a9ea9f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> is enabled or disabled.  <a href="namespacenn_1_1audio.html#aca3b4f1b5b17ad7caa0ca2e8a9ea9f90">More...</a><br /></td></tr>
<tr class="separator:aca3b4f1b5b17ad7caa0ca2e8a9ea9f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df877ba35284f3a2b973777e9c80c74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a3df877ba35284f3a2b973777e9c80c74">IsI3dl2ReverbEnabled</a> (const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *pReverb) noexcept</td></tr>
<tr class="memdesc:a3df877ba35284f3a2b973777e9c80c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> is enabled.  <a href="namespacenn_1_1audio.html#a3df877ba35284f3a2b973777e9c80c74">More...</a><br /></td></tr>
<tr class="separator:a3df877ba35284f3a2b973777e9c80c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">API Resources For BiquadFilter Audio Renderer Effects</div></td></tr>
<tr class="memitem:ad771f7516d8c6eea51938171d9389af7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ad771f7516d8c6eea51938171d9389af7">AddBiquadFilter</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html">BiquadFilterType</a> *pBiquadFilter, <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pFinalMix) noexcept</td></tr>
<tr class="memdesc:ad771f7516d8c6eea51938171d9389af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <code><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html" title="A BiquadFilter effect.">BiquadFilterType</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>.  <a href="namespacenn_1_1audio.html#ad771f7516d8c6eea51938171d9389af7">More...</a><br /></td></tr>
<tr class="separator:ad771f7516d8c6eea51938171d9389af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c3462ac3e635e3d4be8d6bc760c566"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a76c3462ac3e635e3d4be8d6bc760c566">AddBiquadFilter</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html">BiquadFilterType</a> *pBiquadFilter, <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pSubMix) noexcept</td></tr>
<tr class="memdesc:a76c3462ac3e635e3d4be8d6bc760c566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <code><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html" title="A BiquadFilter effect.">BiquadFilterType</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>.  <a href="namespacenn_1_1audio.html#a76c3462ac3e635e3d4be8d6bc760c566">More...</a><br /></td></tr>
<tr class="separator:a76c3462ac3e635e3d4be8d6bc760c566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2163e3d699edc8244383a94ed760f0be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a2163e3d699edc8244383a94ed760f0be">RemoveBiquadFilter</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html">BiquadFilterType</a> *pBiquadFilter, <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pFinalMix) noexcept</td></tr>
<tr class="memdesc:a2163e3d699edc8244383a94ed760f0be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a <code><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html" title="A BiquadFilter effect.">BiquadFilterType</a></code> object from <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>.  <a href="namespacenn_1_1audio.html#a2163e3d699edc8244383a94ed760f0be">More...</a><br /></td></tr>
<tr class="separator:a2163e3d699edc8244383a94ed760f0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3676a4d2cf28de8e4cda2f53c308fb2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a3676a4d2cf28de8e4cda2f53c308fb2a">RemoveBiquadFilter</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html">BiquadFilterType</a> *pBiquadFilter, <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pSubMix) noexcept</td></tr>
<tr class="memdesc:a3676a4d2cf28de8e4cda2f53c308fb2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a <code><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html" title="A BiquadFilter effect.">BiquadFilterType</a></code> object from <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>.  <a href="namespacenn_1_1audio.html#a3676a4d2cf28de8e4cda2f53c308fb2a">More...</a><br /></td></tr>
<tr class="separator:a3676a4d2cf28de8e4cda2f53c308fb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881e5c537d7ea1a12be0fa65e0d7cafa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a881e5c537d7ea1a12be0fa65e0d7cafa">GetBiquadFilterInputOutput</a> (const <a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html">BiquadFilterType</a> *pBiquadFilter, int8_t *outInput, int8_t *outOutput, int *pOutCount, int count) noexcept</td></tr>
<tr class="memdesc:a881e5c537d7ea1a12be0fa65e0d7cafa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the input/output relationship of the mixing process set in <code><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html" title="A BiquadFilter effect.">BiquadFilterType</a></code>.  <a href="namespacenn_1_1audio.html#a881e5c537d7ea1a12be0fa65e0d7cafa">More...</a><br /></td></tr>
<tr class="separator:a881e5c537d7ea1a12be0fa65e0d7cafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4e2ea3271f853614264e81fcb8b834"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a3b4e2ea3271f853614264e81fcb8b834">SetBiquadFilterInputOutput</a> (<a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html">BiquadFilterType</a> *pBiquadFilter, const int8_t *input, const int8_t *output, int count) noexcept</td></tr>
<tr class="memdesc:a3b4e2ea3271f853614264e81fcb8b834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the input/output relationship of the mixing process performed by <code><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html" title="A BiquadFilter effect.">BiquadFilterType</a></code>.  <a href="namespacenn_1_1audio.html#a3b4e2ea3271f853614264e81fcb8b834">More...</a><br /></td></tr>
<tr class="separator:a3b4e2ea3271f853614264e81fcb8b834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b01667fb80b99e942315cffd097170"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1audio_1_1_biquad_filter_parameter.html">BiquadFilterParameter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ac9b01667fb80b99e942315cffd097170">GetBiquadFilterParameter</a> (const <a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html">BiquadFilterType</a> *pBiquadFilter) noexcept</td></tr>
<tr class="memdesc:ac9b01667fb80b99e942315cffd097170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <code><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html" title="A BiquadFilter effect.">BiquadFilterType</a></code> parameter.  <a href="namespacenn_1_1audio.html#ac9b01667fb80b99e942315cffd097170">More...</a><br /></td></tr>
<tr class="separator:ac9b01667fb80b99e942315cffd097170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e10457a7df070f7199b648b233f98e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a14e10457a7df070f7199b648b233f98e">SetBiquadFilterParameter</a> (<a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html">BiquadFilterType</a> *pBiquadFilter, const <a class="el" href="structnn_1_1audio_1_1_biquad_filter_parameter.html">BiquadFilterParameter</a> &amp;parameter) noexcept</td></tr>
<tr class="memdesc:a14e10457a7df070f7199b648b233f98e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <code><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html" title="A BiquadFilter effect.">BiquadFilterType</a></code> parameter.  <a href="namespacenn_1_1audio.html#a14e10457a7df070f7199b648b233f98e">More...</a><br /></td></tr>
<tr class="separator:a14e10457a7df070f7199b648b233f98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37143a7c7866ddc82e23c22d48f4bfca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a37143a7c7866ddc82e23c22d48f4bfca">IsBiquadFilterEnabled</a> (const <a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html">BiquadFilterType</a> *pBiquadFilter) noexcept</td></tr>
<tr class="memdesc:a37143a7c7866ddc82e23c22d48f4bfca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether <code>BiquadFilter</code> is enabled.  <a href="namespacenn_1_1audio.html#a37143a7c7866ddc82e23c22d48f4bfca">More...</a><br /></td></tr>
<tr class="separator:a37143a7c7866ddc82e23c22d48f4bfca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9d1c5cea01758a759108877d4b25c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#acb9d1c5cea01758a759108877d4b25c8">SetBiquadFilterEnabled</a> (<a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html">BiquadFilterType</a> *pBiquadFilter, bool enable) noexcept</td></tr>
<tr class="memdesc:acb9d1c5cea01758a759108877d4b25c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html" title="A BiquadFilter effect.">BiquadFilterType</a></code> as enabled or disabled.  <a href="namespacenn_1_1audio.html#acb9d1c5cea01758a759108877d4b25c8">More...</a><br /></td></tr>
<tr class="separator:acb9d1c5cea01758a759108877d4b25c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb233d493168659a563a2a875d3514b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aeb233d493168659a563a2a875d3514b1">IsBiquadFilterRemovable</a> (const <a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html">BiquadFilterType</a> *pBiquadFilter) noexcept</td></tr>
<tr class="memdesc:aeb233d493168659a563a2a875d3514b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the <code>BiquadFilterTyp</code> object can be safely removed.  <a href="namespacenn_1_1audio.html#aeb233d493168659a563a2a875d3514b1">More...</a><br /></td></tr>
<tr class="separator:aeb233d493168659a563a2a875d3514b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">API Resources for Capture Audio Renderer Effects</div></td></tr>
<tr class="memitem:a953c597ac5ecfb87755ad2233c142002"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a953c597ac5ecfb87755ad2233c142002">GetRequiredBufferSizeForCapture</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html">AudioRendererParameter</a> *pParameter, int mixBufferFrameCount, int channelCountMax) noexcept</td></tr>
<tr class="memdesc:a953c597ac5ecfb87755ad2233c142002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of work buffer required by the renderer to use <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code>.  <a href="namespacenn_1_1audio.html#a953c597ac5ecfb87755ad2233c142002">More...</a><br /></td></tr>
<tr class="separator:a953c597ac5ecfb87755ad2233c142002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3024a56e39831c3ba5fc8e52bca1a7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ab3024a56e39831c3ba5fc8e52bca1a7e">AddCapture</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_capture_type.html">CaptureType</a> *pEffect, <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pFinalMix, void *buffer, size_t bufferSize) noexcept</td></tr>
<tr class="memdesc:ab3024a56e39831c3ba5fc8e52bca1a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>.  <a href="namespacenn_1_1audio.html#ab3024a56e39831c3ba5fc8e52bca1a7e">More...</a><br /></td></tr>
<tr class="separator:ab3024a56e39831c3ba5fc8e52bca1a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533a6e60124d6f2294ac1192f11f6278"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a533a6e60124d6f2294ac1192f11f6278">AddCapture</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_capture_type.html">CaptureType</a> *pEffect, <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pSubMix, void *buffer, size_t bufferSize) noexcept</td></tr>
<tr class="memdesc:a533a6e60124d6f2294ac1192f11f6278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>.  <a href="namespacenn_1_1audio.html#a533a6e60124d6f2294ac1192f11f6278">More...</a><br /></td></tr>
<tr class="separator:a533a6e60124d6f2294ac1192f11f6278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd8807d5efcb1fae477f690c8a8b48d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a3fd8807d5efcb1fae477f690c8a8b48d">RemoveCapture</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_capture_type.html">CaptureType</a> *pEffect, <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pFinalMix) noexcept</td></tr>
<tr class="memdesc:a3fd8807d5efcb1fae477f690c8a8b48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> object from <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>.  <a href="namespacenn_1_1audio.html#a3fd8807d5efcb1fae477f690c8a8b48d">More...</a><br /></td></tr>
<tr class="separator:a3fd8807d5efcb1fae477f690c8a8b48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5c8d26319bfa5a5aebd7dd137b66ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a1b5c8d26319bfa5a5aebd7dd137b66ca">RemoveCapture</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_capture_type.html">CaptureType</a> *pEffect, <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pSubMix) noexcept</td></tr>
<tr class="memdesc:a1b5c8d26319bfa5a5aebd7dd137b66ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> object from <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>.  <a href="namespacenn_1_1audio.html#a1b5c8d26319bfa5a5aebd7dd137b66ca">More...</a><br /></td></tr>
<tr class="separator:a1b5c8d26319bfa5a5aebd7dd137b66ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30cc12a3a588d65ee5b6ac6b0ef0139f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a30cc12a3a588d65ee5b6ac6b0ef0139f">GetCaptureChannelCountMax</a> (const <a class="el" href="structnn_1_1audio_1_1_capture_type.html">CaptureType</a> *pEffect) noexcept</td></tr>
<tr class="memdesc:a30cc12a3a588d65ee5b6ac6b0ef0139f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum number of channels that can be set for <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code>.  <a href="namespacenn_1_1audio.html#a30cc12a3a588d65ee5b6ac6b0ef0139f">More...</a><br /></td></tr>
<tr class="separator:a30cc12a3a588d65ee5b6ac6b0ef0139f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ee227d53b2d54410531fce49c31706"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aa0ee227d53b2d54410531fce49c31706">GetCaptureInput</a> (const <a class="el" href="structnn_1_1audio_1_1_capture_type.html">CaptureType</a> *pEffect, int8_t *pOutInput, int *pOutCount, int count) noexcept</td></tr>
<tr class="memdesc:aa0ee227d53b2d54410531fce49c31706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> input buffer indexes.  <a href="namespacenn_1_1audio.html#aa0ee227d53b2d54410531fce49c31706">More...</a><br /></td></tr>
<tr class="separator:aa0ee227d53b2d54410531fce49c31706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521d657d2d1033e0712094701d5a19d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a521d657d2d1033e0712094701d5a19d3">SetCaptureInput</a> (<a class="el" href="structnn_1_1audio_1_1_capture_type.html">CaptureType</a> *pEffect, const int8_t *input, const int count) noexcept</td></tr>
<tr class="memdesc:a521d657d2d1033e0712094701d5a19d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> input buffer indexes.  <a href="namespacenn_1_1audio.html#a521d657d2d1033e0712094701d5a19d3">More...</a><br /></td></tr>
<tr class="separator:a521d657d2d1033e0712094701d5a19d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11831c5f69d9088ecb36cd6e10ee741b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a11831c5f69d9088ecb36cd6e10ee741b">ReadCaptureBuffer</a> (<a class="el" href="structnn_1_1audio_1_1_capture_type.html">CaptureType</a> *pEffect, int32_t *pOutData, int count) noexcept</td></tr>
<tr class="memdesc:a11831c5f69d9088ecb36cd6e10ee741b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads <code><em>count</em></code> number of samples from <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code>.  <a href="namespacenn_1_1audio.html#a11831c5f69d9088ecb36cd6e10ee741b">More...</a><br /></td></tr>
<tr class="separator:a11831c5f69d9088ecb36cd6e10ee741b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419eabf43313e806b6ca6000d4bd98fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a419eabf43313e806b6ca6000d4bd98fe">GetCaptureSampleRate</a> (const <a class="el" href="structnn_1_1audio_1_1_capture_type.html">CaptureType</a> *pEffect) noexcept</td></tr>
<tr class="memdesc:a419eabf43313e806b6ca6000d4bd98fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sample rate of the buffer managed by <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code>.  <a href="namespacenn_1_1audio.html#a419eabf43313e806b6ca6000d4bd98fe">More...</a><br /></td></tr>
<tr class="separator:a419eabf43313e806b6ca6000d4bd98fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c1ae605dd4de1a59af6c0d123c5bd5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a53c1ae605dd4de1a59af6c0d123c5bd5">GetCaptureSampleCount</a> (const <a class="el" href="structnn_1_1audio_1_1_capture_type.html">CaptureType</a> *pEffect) noexcept</td></tr>
<tr class="memdesc:a53c1ae605dd4de1a59af6c0d123c5bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum number of samples that can be stored in the buffer managed by <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code>.  <a href="namespacenn_1_1audio.html#a53c1ae605dd4de1a59af6c0d123c5bd5">More...</a><br /></td></tr>
<tr class="separator:a53c1ae605dd4de1a59af6c0d123c5bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b7a0112e26b5a4f7eb4a51275b08df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ad2b7a0112e26b5a4f7eb4a51275b08df">IsCaptureEnabled</a> (const <a class="el" href="structnn_1_1audio_1_1_capture_type.html">CaptureType</a> *pEffect) noexcept</td></tr>
<tr class="memdesc:ad2b7a0112e26b5a4f7eb4a51275b08df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> is enabled.  <a href="namespacenn_1_1audio.html#ad2b7a0112e26b5a4f7eb4a51275b08df">More...</a><br /></td></tr>
<tr class="separator:ad2b7a0112e26b5a4f7eb4a51275b08df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ba1a801f4ce78363f7587ff611f192"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a25ba1a801f4ce78363f7587ff611f192">SetCaptureEnabled</a> (<a class="el" href="structnn_1_1audio_1_1_capture_type.html">CaptureType</a> *pEffect, bool enable) noexcept</td></tr>
<tr class="memdesc:a25ba1a801f4ce78363f7587ff611f192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> as either enabled or disabled.  <a href="namespacenn_1_1audio.html#a25ba1a801f4ce78363f7587ff611f192">More...</a><br /></td></tr>
<tr class="separator:a25ba1a801f4ce78363f7587ff611f192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa39f2400eb2c5de900782bac69beed2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#afa39f2400eb2c5de900782bac69beed2">IsCaptureRemovable</a> (const <a class="el" href="structnn_1_1audio_1_1_capture_type.html">CaptureType</a> *pEffect) noexcept</td></tr>
<tr class="memdesc:afa39f2400eb2c5de900782bac69beed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> object can be safely removed.  <a href="namespacenn_1_1audio.html#afa39f2400eb2c5de900782bac69beed2">More...</a><br /></td></tr>
<tr class="separator:afa39f2400eb2c5de900782bac69beed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd99cd5e9e834b1f37019a4e69b5c988"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#acd99cd5e9e834b1f37019a4e69b5c988">GetCaptureLostSampleCount</a> (const <a class="el" href="structnn_1_1audio_1_1_capture_type.html">CaptureType</a> *pEffect) noexcept</td></tr>
<tr class="memdesc:acd99cd5e9e834b1f37019a4e69b5c988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the cumulative number of samples that have been lost from the buffer managed by <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code>.  <a href="namespacenn_1_1audio.html#acd99cd5e9e834b1f37019a4e69b5c988">More...</a><br /></td></tr>
<tr class="separator:acd99cd5e9e834b1f37019a4e69b5c988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceccd794c9eaf4929fcaa37dc896d7cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aceccd794c9eaf4929fcaa37dc896d7cc">ResetCaptureLostSampleCount</a> (<a class="el" href="structnn_1_1audio_1_1_capture_type.html">CaptureType</a> *pEffect) noexcept</td></tr>
<tr class="memdesc:aceccd794c9eaf4929fcaa37dc896d7cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the cumulative number of samples that have been lost from the buffer managed by <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code>.  <a href="namespacenn_1_1audio.html#aceccd794c9eaf4929fcaa37dc896d7cc">More...</a><br /></td></tr>
<tr class="separator:aceccd794c9eaf4929fcaa37dc896d7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">API Resources for LightLimiter Audio Renderer Effects</div></td></tr>
<tr class="memitem:a599944de2f532061310662a48f6379ac"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a599944de2f532061310662a48f6379ac">GetRequiredBufferSizeForLightLimiter</a> (<a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> lookAheadTimeMax, int sampleRate, int channelCountMax) noexcept</td></tr>
<tr class="memdesc:a599944de2f532061310662a48f6379ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the work buffer size required for the renderer to use <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>.  <a href="namespacenn_1_1audio.html#a599944de2f532061310662a48f6379ac">More...</a><br /></td></tr>
<tr class="separator:a599944de2f532061310662a48f6379ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bab4b3f6c0c1c7aa0011d2ee4b33919"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a0bab4b3f6c0c1c7aa0011d2ee4b33919">AddLightLimiter</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *pEffect, void *buffer, size_t bufferSize, <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pFinalMix, <a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> lookAheadTimeMax, int channelCountMax) noexcept</td></tr>
<tr class="memdesc:a0bab4b3f6c0c1c7aa0011d2ee4b33919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>.  <a href="namespacenn_1_1audio.html#a0bab4b3f6c0c1c7aa0011d2ee4b33919">More...</a><br /></td></tr>
<tr class="separator:a0bab4b3f6c0c1c7aa0011d2ee4b33919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9893b88646627d0cf1e0a82288135c6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a9893b88646627d0cf1e0a82288135c6d">AddLightLimiter</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *pEffect, void *buffer, size_t bufferSize, <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pSubMix, <a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> lookAheadTimeMax, int channelCountMax) noexcept</td></tr>
<tr class="memdesc:a9893b88646627d0cf1e0a82288135c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>.  <a href="namespacenn_1_1audio.html#a9893b88646627d0cf1e0a82288135c6d">More...</a><br /></td></tr>
<tr class="separator:a9893b88646627d0cf1e0a82288135c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc63377e4f4f87617ff50fc981b170d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aacc63377e4f4f87617ff50fc981b170d">RemoveLightLimiter</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *pEffect, <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pFinalMix) noexcept</td></tr>
<tr class="memdesc:aacc63377e4f4f87617ff50fc981b170d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> object from <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>.  <a href="namespacenn_1_1audio.html#aacc63377e4f4f87617ff50fc981b170d">More...</a><br /></td></tr>
<tr class="separator:aacc63377e4f4f87617ff50fc981b170d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd177fde39dad044d611c844ac326001"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#abd177fde39dad044d611c844ac326001">RemoveLightLimiter</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *pEffect, <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pSubMix) noexcept</td></tr>
<tr class="memdesc:abd177fde39dad044d611c844ac326001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> object from <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>.  <a href="namespacenn_1_1audio.html#abd177fde39dad044d611c844ac326001">More...</a><br /></td></tr>
<tr class="separator:abd177fde39dad044d611c844ac326001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6860df74686ab481b40bb8420f118e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a6e6860df74686ab481b40bb8420f118e">GetLightLimiterInputOutput</a> (const <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *pEffect, int8_t *outInput, int8_t *outOutput, int *pOutCount, int count) noexcept</td></tr>
<tr class="memdesc:a6e6860df74686ab481b40bb8420f118e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the indexes of the <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> input/output mix buffers.  <a href="namespacenn_1_1audio.html#a6e6860df74686ab481b40bb8420f118e">More...</a><br /></td></tr>
<tr class="separator:a6e6860df74686ab481b40bb8420f118e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338f3d39f10cfd43d3a718d1636c1478"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a338f3d39f10cfd43d3a718d1636c1478">SetLightLimiterInputOutput</a> (<a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *pEffect, const int8_t *input, const int8_t *output, int count) noexcept</td></tr>
<tr class="memdesc:a338f3d39f10cfd43d3a718d1636c1478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> input/output mix buffer indexes.  <a href="namespacenn_1_1audio.html#a338f3d39f10cfd43d3a718d1636c1478">More...</a><br /></td></tr>
<tr class="separator:a338f3d39f10cfd43d3a718d1636c1478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d53007cb799a8edce033c9ff51fb43"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#af2d53007cb799a8edce033c9ff51fb43">IsLightLimiterEnabled</a> (const <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *pEffect) noexcept</td></tr>
<tr class="memdesc:af2d53007cb799a8edce033c9ff51fb43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> is enabled.  <a href="namespacenn_1_1audio.html#af2d53007cb799a8edce033c9ff51fb43">More...</a><br /></td></tr>
<tr class="separator:af2d53007cb799a8edce033c9ff51fb43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7455f013400526a539368885b542736a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a7455f013400526a539368885b542736a">SetLightLimiterEnabled</a> (<a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *pEffect, bool enable) noexcept</td></tr>
<tr class="memdesc:a7455f013400526a539368885b542736a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> is enabled or disabled.  <a href="namespacenn_1_1audio.html#a7455f013400526a539368885b542736a">More...</a><br /></td></tr>
<tr class="separator:a7455f013400526a539368885b542736a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203121e3dda68edafcc270e0e927870f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a203121e3dda68edafcc270e0e927870f">IsLightLimiterRemovable</a> (const <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *pEffect) noexcept</td></tr>
<tr class="memdesc:a203121e3dda68edafcc270e0e927870f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> object can be safely removed.  <a href="namespacenn_1_1audio.html#a203121e3dda68edafcc270e0e927870f">More...</a><br /></td></tr>
<tr class="separator:a203121e3dda68edafcc270e0e927870f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126e27bd6735b73018bd1ccc150b95cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a126e27bd6735b73018bd1ccc150b95cc">GetLightLimiterLookAheadTimeMax</a> (const <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *pEffect) noexcept</td></tr>
<tr class="memdesc:a126e27bd6735b73018bd1ccc150b95cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum look-ahead time that can be set for <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>.  <a href="namespacenn_1_1audio.html#a126e27bd6735b73018bd1ccc150b95cc">More...</a><br /></td></tr>
<tr class="separator:a126e27bd6735b73018bd1ccc150b95cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434871fe5c19c0c8ef28f728227f57d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a434871fe5c19c0c8ef28f728227f57d1">GetLightLimiterChannelCountMax</a> (const <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *pEffect) noexcept</td></tr>
<tr class="memdesc:a434871fe5c19c0c8ef28f728227f57d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum number of channels that can be set for <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>.  <a href="namespacenn_1_1audio.html#a434871fe5c19c0c8ef28f728227f57d1">More...</a><br /></td></tr>
<tr class="separator:a434871fe5c19c0c8ef28f728227f57d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15613bf34c399efa929410a39ff3657a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a15613bf34c399efa929410a39ff3657a">GetLightLimiterAttackTime</a> (const <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *pEffect) noexcept</td></tr>
<tr class="memdesc:a15613bf34c399efa929410a39ff3657a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the attack time of <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>.  <a href="namespacenn_1_1audio.html#a15613bf34c399efa929410a39ff3657a">More...</a><br /></td></tr>
<tr class="separator:a15613bf34c399efa929410a39ff3657a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19685a79679c2764b27059e0bba9f61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ae19685a79679c2764b27059e0bba9f61">SetLightLimiterAttackTime</a> (<a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *pEffect, <a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> value) noexcept</td></tr>
<tr class="memdesc:ae19685a79679c2764b27059e0bba9f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the attack time of <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>.  <a href="namespacenn_1_1audio.html#ae19685a79679c2764b27059e0bba9f61">More...</a><br /></td></tr>
<tr class="separator:ae19685a79679c2764b27059e0bba9f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09c40a2760271e61692ebe320a69b20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#af09c40a2760271e61692ebe320a69b20">GetLightLimiterReleaseTime</a> (const <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *pEffect) noexcept</td></tr>
<tr class="memdesc:af09c40a2760271e61692ebe320a69b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the release time of <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>.  <a href="namespacenn_1_1audio.html#af09c40a2760271e61692ebe320a69b20">More...</a><br /></td></tr>
<tr class="separator:af09c40a2760271e61692ebe320a69b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98da6468118408e6f03a2e2c0eae0b88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a98da6468118408e6f03a2e2c0eae0b88">SetLightLimiterReleaseTime</a> (<a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *pEffect, <a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> value) noexcept</td></tr>
<tr class="memdesc:a98da6468118408e6f03a2e2c0eae0b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the release time of <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>.  <a href="namespacenn_1_1audio.html#a98da6468118408e6f03a2e2c0eae0b88">More...</a><br /></td></tr>
<tr class="separator:a98da6468118408e6f03a2e2c0eae0b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee0394e913f76e1a7b3b57f3da3e214"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#afee0394e913f76e1a7b3b57f3da3e214">GetLightLimiterLookAheadTime</a> (const <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *pEffect) noexcept</td></tr>
<tr class="memdesc:afee0394e913f76e1a7b3b57f3da3e214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the look-ahead time of <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>.  <a href="namespacenn_1_1audio.html#afee0394e913f76e1a7b3b57f3da3e214">More...</a><br /></td></tr>
<tr class="separator:afee0394e913f76e1a7b3b57f3da3e214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11eddcef27393df3870156d106677dfc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a11eddcef27393df3870156d106677dfc">SetLightLimiterLookAheadTime</a> (<a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *pEffect, <a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> value) noexcept</td></tr>
<tr class="memdesc:a11eddcef27393df3870156d106677dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the look-ahead time of <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>.  <a href="namespacenn_1_1audio.html#a11eddcef27393df3870156d106677dfc">More...</a><br /></td></tr>
<tr class="separator:a11eddcef27393df3870156d106677dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95eb6cd6822e4ef2183dd8bbc9b4d60"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aa95eb6cd6822e4ef2183dd8bbc9b4d60">GetLightLimiterThreshold</a> (const <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *pEffect) noexcept</td></tr>
<tr class="memdesc:aa95eb6cd6822e4ef2183dd8bbc9b4d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the threshold of <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>.  <a href="namespacenn_1_1audio.html#aa95eb6cd6822e4ef2183dd8bbc9b4d60">More...</a><br /></td></tr>
<tr class="separator:aa95eb6cd6822e4ef2183dd8bbc9b4d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452de0ded15b4bc2cb43d6d621d26e01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a452de0ded15b4bc2cb43d6d621d26e01">SetLightLimiterThreshold</a> (<a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *pEffect, float value) noexcept</td></tr>
<tr class="memdesc:a452de0ded15b4bc2cb43d6d621d26e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the threshold of <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>.  <a href="namespacenn_1_1audio.html#a452de0ded15b4bc2cb43d6d621d26e01">More...</a><br /></td></tr>
<tr class="separator:a452de0ded15b4bc2cb43d6d621d26e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538876817582613f83a62ba77aff1719"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a538876817582613f83a62ba77aff1719">GetLightLimiterInputGain</a> (const <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *pEffect) noexcept</td></tr>
<tr class="memdesc:a538876817582613f83a62ba77aff1719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the input gain of <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>.  <a href="namespacenn_1_1audio.html#a538876817582613f83a62ba77aff1719">More...</a><br /></td></tr>
<tr class="separator:a538876817582613f83a62ba77aff1719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6296f26432d6bc4a46217957edb05a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ab6296f26432d6bc4a46217957edb05a1">SetLightLimiterInputGain</a> (<a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *pEffect, float value) noexcept</td></tr>
<tr class="memdesc:ab6296f26432d6bc4a46217957edb05a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the input gain of <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>.  <a href="namespacenn_1_1audio.html#ab6296f26432d6bc4a46217957edb05a1">More...</a><br /></td></tr>
<tr class="separator:ab6296f26432d6bc4a46217957edb05a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949f7ef952babb00c818be68f05a7f37"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a949f7ef952babb00c818be68f05a7f37">GetLightLimiterOutputGain</a> (const <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *pEffect) noexcept</td></tr>
<tr class="memdesc:a949f7ef952babb00c818be68f05a7f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the output gain of <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>.  <a href="namespacenn_1_1audio.html#a949f7ef952babb00c818be68f05a7f37">More...</a><br /></td></tr>
<tr class="separator:a949f7ef952babb00c818be68f05a7f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01be37deed50b246eb649dfcdd2a9ec5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a01be37deed50b246eb649dfcdd2a9ec5">SetLightLimiterOutputGain</a> (<a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *pEffect, float value) noexcept</td></tr>
<tr class="memdesc:a01be37deed50b246eb649dfcdd2a9ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the output gain of <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>.  <a href="namespacenn_1_1audio.html#a01be37deed50b246eb649dfcdd2a9ec5">More...</a><br /></td></tr>
<tr class="separator:a01be37deed50b246eb649dfcdd2a9ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6abcf1e9b73a69f16a5e20627650ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1audio_1_1_light_limiter_parameter_set.html">LightLimiterParameterSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a7a6abcf1e9b73a69f16a5e20627650ff">GetLightLimiterParameters</a> (const <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *pEffect) noexcept</td></tr>
<tr class="memdesc:a7a6abcf1e9b73a69f16a5e20627650ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> effect parameters.  <a href="namespacenn_1_1audio.html#a7a6abcf1e9b73a69f16a5e20627650ff">More...</a><br /></td></tr>
<tr class="separator:a7a6abcf1e9b73a69f16a5e20627650ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afefcb2450e84e8adcb5a89a61a4e994b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#afefcb2450e84e8adcb5a89a61a4e994b">SetLightLimiterParameters</a> (<a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *pEffect, const <a class="el" href="structnn_1_1audio_1_1_light_limiter_parameter_set.html">LightLimiterParameterSet</a> *pParameterSet) noexcept</td></tr>
<tr class="memdesc:afefcb2450e84e8adcb5a89a61a4e994b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> effect parameters.  <a href="namespacenn_1_1audio.html#afefcb2450e84e8adcb5a89a61a4e994b">More...</a><br /></td></tr>
<tr class="separator:afefcb2450e84e8adcb5a89a61a4e994b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb96b3d4bba546e8bf632b442584f92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a7cb96b3d4bba546e8bf632b442584f92">IsLightLimiterStatisticsEnabled</a> (const <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *pEffect) noexcept</td></tr>
<tr class="memdesc:a7cb96b3d4bba546e8bf632b442584f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> feature for getting statistics is enabled.  <a href="namespacenn_1_1audio.html#a7cb96b3d4bba546e8bf632b442584f92">More...</a><br /></td></tr>
<tr class="separator:a7cb96b3d4bba546e8bf632b442584f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3451da9165fc5da2692df3c98baa91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a5c3451da9165fc5da2692df3c98baa91">SetLightLimiterStatisticsEnabled</a> (<a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *pEffect, bool isEnabled) noexcept</td></tr>
<tr class="memdesc:a5c3451da9165fc5da2692df3c98baa91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switches between enabling and disabling the <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> feature for getting statistics.  <a href="namespacenn_1_1audio.html#a5c3451da9165fc5da2692df3c98baa91">More...</a><br /></td></tr>
<tr class="separator:a5c3451da9165fc5da2692df3c98baa91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ef8174c49997210bf030e78ef37df3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a74ef8174c49997210bf030e78ef37df3">GetLightLimiterChannelStatistics</a> (<a class="el" href="structnn_1_1audio_1_1_light_limiter_channel_statistics.html">LightLimiterChannelStatistics</a> *pOutStatistics, const <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *pEffect, int channel) noexcept</td></tr>
<tr class="memdesc:a74ef8174c49997210bf030e78ef37df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets statistics for each channel resulting from the <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> processing.  <a href="namespacenn_1_1audio.html#a74ef8174c49997210bf030e78ef37df3">More...</a><br /></td></tr>
<tr class="separator:a74ef8174c49997210bf030e78ef37df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161f679704285f187cdac5ccf29da45d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a161f679704285f187cdac5ccf29da45d">ResetLightLimiterStatistics</a> (<a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *pEffect) noexcept</td></tr>
<tr class="memdesc:a161f679704285f187cdac5ccf29da45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the statistics resulting from the <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> processing.  <a href="namespacenn_1_1audio.html#a161f679704285f187cdac5ccf29da45d">More...</a><br /></td></tr>
<tr class="separator:a161f679704285f187cdac5ccf29da45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">API Resources For the Audio Renderer FinalMix</div></td></tr>
<tr class="memitem:abcc7c4eb06afe0673e8196edc23dd9f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#abcc7c4eb06afe0673e8196edc23dd9f0">AcquireFinalMix</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pOutFinalMix, int bufferCount) noexcept</td></tr>
<tr class="memdesc:abcc7c4eb06afe0673e8196edc23dd9f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> and adds it to the <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code>.  <a href="namespacenn_1_1audio.html#abcc7c4eb06afe0673e8196edc23dd9f0">More...</a><br /></td></tr>
<tr class="separator:abcc7c4eb06afe0673e8196edc23dd9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c84c10d2ccb560293d74cc5be46e0dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a9c84c10d2ccb560293d74cc5be46e0dd">ReleaseFinalMix</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pFinalMix) noexcept</td></tr>
<tr class="memdesc:a9c84c10d2ccb560293d74cc5be46e0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> object from <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code>.  <a href="namespacenn_1_1audio.html#a9c84c10d2ccb560293d74cc5be46e0dd">More...</a><br /></td></tr>
<tr class="separator:a9c84c10d2ccb560293d74cc5be46e0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7652eae684b0d267e276cf7c01ac12d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a7652eae684b0d267e276cf7c01ac12d7">GetFinalMixBufferCount</a> (const <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pFinalMix) noexcept</td></tr>
<tr class="memdesc:a7652eae684b0d267e276cf7c01ac12d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> buffers.  <a href="namespacenn_1_1audio.html#a7652eae684b0d267e276cf7c01ac12d7">More...</a><br /></td></tr>
<tr class="separator:a7652eae684b0d267e276cf7c01ac12d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0124555bf745d4472ae4b2db1b9a044"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ab0124555bf745d4472ae4b2db1b9a044">GetFinalMixVolume</a> (const <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pFinalMix) noexcept</td></tr>
<tr class="memdesc:ab0124555bf745d4472ae4b2db1b9a044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the volume of the <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> object.  <a href="namespacenn_1_1audio.html#ab0124555bf745d4472ae4b2db1b9a044">More...</a><br /></td></tr>
<tr class="separator:ab0124555bf745d4472ae4b2db1b9a044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d0a1908dd4668211b26270705b9ba1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#af6d0a1908dd4668211b26270705b9ba1">SetFinalMixVolume</a> (<a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pFinalMix, float volume) noexcept</td></tr>
<tr class="memdesc:af6d0a1908dd4668211b26270705b9ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the volume for the <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> object.  <a href="namespacenn_1_1audio.html#af6d0a1908dd4668211b26270705b9ba1">More...</a><br /></td></tr>
<tr class="separator:af6d0a1908dd4668211b26270705b9ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf070287eca8aa946ba57e8ae056092"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1audio.html#a347cdc16fef8e35aad9d8d0cd2e79e38">NodeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#afbf070287eca8aa946ba57e8ae056092">GetFinalMixNodeId</a> (const <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pFinalMix) noexcept</td></tr>
<tr class="memdesc:afbf070287eca8aa946ba57e8ae056092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the ID of the <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> in the audio renderer.  <a href="namespacenn_1_1audio.html#afbf070287eca8aa946ba57e8ae056092">More...</a><br /></td></tr>
<tr class="separator:afbf070287eca8aa946ba57e8ae056092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b00eec5745f59f461c43723ed965f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a09b00eec5745f59f461c43723ed965f3">GetFinalMixSampleRate</a> (const <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pFinalMix) noexcept</td></tr>
<tr class="memdesc:a09b00eec5745f59f461c43723ed965f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sample rate of the <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> object.  <a href="namespacenn_1_1audio.html#a09b00eec5745f59f461c43723ed965f3">More...</a><br /></td></tr>
<tr class="separator:a09b00eec5745f59f461c43723ed965f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">API Resources for Audio Renderer Memory Pools</div></td></tr>
<tr class="memitem:a8e7b32e31ba3ea6f61c00c752c3a90d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a8e7b32e31ba3ea6f61c00c752c3a90d0">AcquireMemoryPool</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html">MemoryPoolType</a> *pOutPool, void *address, size_t size) noexcept</td></tr>
<tr class="memdesc:a8e7b32e31ba3ea6f61c00c752c3a90d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a memory pool for an audio renderer.  <a href="namespacenn_1_1audio.html#a8e7b32e31ba3ea6f61c00c752c3a90d0">More...</a><br /></td></tr>
<tr class="separator:a8e7b32e31ba3ea6f61c00c752c3a90d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf0ab532748ef3c8f6d127f1800ec1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a2bf0ab532748ef3c8f6d127f1800ec1b">ReleaseMemoryPool</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html">MemoryPoolType</a> *pPool) noexcept</td></tr>
<tr class="memdesc:a2bf0ab532748ef3c8f6d127f1800ec1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a memory pool that was created for an audio renderer.  <a href="namespacenn_1_1audio.html#a2bf0ab532748ef3c8f6d127f1800ec1b">More...</a><br /></td></tr>
<tr class="separator:a2bf0ab532748ef3c8f6d127f1800ec1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9484edc9f1bae6e41933993fbe09dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a5f9484edc9f1bae6e41933993fbe09dc">RequestAttachMemoryPool</a> (<a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html">MemoryPoolType</a> *pPool) noexcept</td></tr>
<tr class="memdesc:a5f9484edc9f1bae6e41933993fbe09dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a memory pool to an audio renderer.  <a href="namespacenn_1_1audio.html#a5f9484edc9f1bae6e41933993fbe09dc">More...</a><br /></td></tr>
<tr class="separator:a5f9484edc9f1bae6e41933993fbe09dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5341a5f593894f840b218eb1929a3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a1d5341a5f593894f840b218eb1929a3b">RequestDetachMemoryPool</a> (<a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html">MemoryPoolType</a> *pPool) noexcept</td></tr>
<tr class="memdesc:a1d5341a5f593894f840b218eb1929a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches a memory pool from an audio renderer.  <a href="namespacenn_1_1audio.html#a1d5341a5f593894f840b218eb1929a3b">More...</a><br /></td></tr>
<tr class="separator:a1d5341a5f593894f840b218eb1929a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f83d98dfc603829790bb0fbce67549"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a84f83d98dfc603829790bb0fbce67549">IsMemoryPoolAttached</a> (const <a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html">MemoryPoolType</a> *pPool) noexcept</td></tr>
<tr class="memdesc:a84f83d98dfc603829790bb0fbce67549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a memory pool is currently attached.  <a href="namespacenn_1_1audio.html#a84f83d98dfc603829790bb0fbce67549">More...</a><br /></td></tr>
<tr class="separator:a84f83d98dfc603829790bb0fbce67549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2896bdda770cd160dd31feb7e6dbf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html#ad447b3250f2b84c779d8777c3665fc16">MemoryPoolType::State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aec2896bdda770cd160dd31feb7e6dbf1">GetMemoryPoolState</a> (const <a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html">MemoryPoolType</a> *pPool) noexcept</td></tr>
<tr class="memdesc:aec2896bdda770cd160dd31feb7e6dbf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the memory pool state.  <a href="namespacenn_1_1audio.html#aec2896bdda770cd160dd31feb7e6dbf1">More...</a><br /></td></tr>
<tr class="separator:aec2896bdda770cd160dd31feb7e6dbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7175ef30c1e7c69de82769447ce241"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a9d7175ef30c1e7c69de82769447ce241">GetReleasedMemoryPoolCount</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pConfig) noexcept</td></tr>
<tr class="memdesc:a9d7175ef30c1e7c69de82769447ce241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of memory pools that can be retrieved.  <a href="namespacenn_1_1audio.html#a9d7175ef30c1e7c69de82769447ce241">More...</a><br /></td></tr>
<tr class="separator:a9d7175ef30c1e7c69de82769447ce241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847e8128383fe3e162b568bd7accc7cc"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a847e8128383fe3e162b568bd7accc7cc">GetMemoryPoolAddress</a> (const <a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html">MemoryPoolType</a> *pPool) noexcept</td></tr>
<tr class="memdesc:a847e8128383fe3e162b568bd7accc7cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the address of a memory region managed by a memory pool.  <a href="namespacenn_1_1audio.html#a847e8128383fe3e162b568bd7accc7cc">More...</a><br /></td></tr>
<tr class="separator:a847e8128383fe3e162b568bd7accc7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5db33f96169ddfb4032758e2683089"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a8b5db33f96169ddfb4032758e2683089">GetMemoryPoolSize</a> (const <a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html">MemoryPoolType</a> *pPool) noexcept</td></tr>
<tr class="memdesc:a8b5db33f96169ddfb4032758e2683089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of a memory region managed by a memory pool.  <a href="namespacenn_1_1audio.html#a8b5db33f96169ddfb4032758e2683089">More...</a><br /></td></tr>
<tr class="separator:a8b5db33f96169ddfb4032758e2683089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb36e3fd0639be1a1ff056d8d80dcc5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a2fb36e3fd0639be1a1ff056d8d80dcc5">CopyMemoryPoolData</a> (const <a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html">MemoryPoolType</a> *pPool, void *dst, const void *src, size_t size) noexcept</td></tr>
<tr class="memdesc:a2fb36e3fd0639be1a1ff056d8d80dcc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads or writes data to a memory region managed by a memory pool.  <a href="namespacenn_1_1audio.html#a2fb36e3fd0639be1a1ff056d8d80dcc5">More...</a><br /></td></tr>
<tr class="separator:a2fb36e3fd0639be1a1ff056d8d80dcc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">API Resources for Audio Renderer Performance Metrics</div></td></tr>
<tr class="memitem:a7d1532644fd22daad0fe71d9f409ba72"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a7d1532644fd22daad0fe71d9f409ba72">SetPerformanceFrameBuffer</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, void *buffer, size_t bufferSize) noexcept</td></tr>
<tr class="memdesc:a7d1532644fd22daad0fe71d9f409ba72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a starting address to output performance information to.  <a href="namespacenn_1_1audio.html#a7d1532644fd22daad0fe71d9f409ba72">More...</a><br /></td></tr>
<tr class="separator:a7d1532644fd22daad0fe71d9f409ba72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6322903ab06537b41c4330c6eff1b58"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#af6322903ab06537b41c4330c6eff1b58">GetRequiredBufferSizeForPerformanceFrames</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html">AudioRendererParameter</a> &amp;parameter) noexcept</td></tr>
<tr class="memdesc:af6322903ab06537b41c4330c6eff1b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the required size for the memory region to which performance information will be written.  <a href="namespacenn_1_1audio.html#af6322903ab06537b41c4330c6eff1b58">More...</a><br /></td></tr>
<tr class="separator:af6322903ab06537b41c4330c6eff1b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382b31fe7f6db23f10c0380365a64ba9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a382b31fe7f6db23f10c0380365a64ba9">SetPerformanceDetailTarget</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pVoice) noexcept</td></tr>
<tr class="memdesc:a382b31fe7f6db23f10c0380365a64ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the target <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> for which to get detailed performance information.  <a href="namespacenn_1_1audio.html#a382b31fe7f6db23f10c0380365a64ba9">More...</a><br /></td></tr>
<tr class="separator:a382b31fe7f6db23f10c0380365a64ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd5a07dc4d1f4ac3def71b01036875f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a0bd5a07dc4d1f4ac3def71b01036875f">SetPerformanceDetailTarget</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, const <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pSubMix) noexcept</td></tr>
<tr class="memdesc:a0bd5a07dc4d1f4ac3def71b01036875f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the target <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> for which to get detailed performance information.  <a href="namespacenn_1_1audio.html#a0bd5a07dc4d1f4ac3def71b01036875f">More...</a><br /></td></tr>
<tr class="separator:a0bd5a07dc4d1f4ac3def71b01036875f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b030fa567c26a5d943c9617fd99b721"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a4b030fa567c26a5d943c9617fd99b721">SetPerformanceDetailTarget</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, const <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pFinalMix) noexcept</td></tr>
<tr class="memdesc:a4b030fa567c26a5d943c9617fd99b721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the target <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> for which to get detailed performance information.  <a href="namespacenn_1_1audio.html#a4b030fa567c26a5d943c9617fd99b721">More...</a><br /></td></tr>
<tr class="separator:a4b030fa567c26a5d943c9617fd99b721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73533970436167d6e06d131844085916"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a73533970436167d6e06d131844085916">ClearPerformanceDetailTarget</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig) noexcept</td></tr>
<tr class="memdesc:a73533970436167d6e06d131844085916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the target for which to get detailed performance information.  <a href="namespacenn_1_1audio.html#a73533970436167d6e06d131844085916">More...</a><br /></td></tr>
<tr class="separator:a73533970436167d6e06d131844085916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Polyphase Resampler Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The polyphase resampler works most efficiently when the ratio of input and output sample rates is a rational expression where the denominator and the numerator are both positive integers of 255 or less.</p>
<p>If the values for <code><em>inputSampleRate</em></code> and <code><em>outputSampleRate</em></code> do not satisfy this condition, the polyphase resampler converts the output sample rate to the nearest value that satisfies this condition and then performs its process. You can use <code><a class="el" href="namespacenn_1_1audio.html#ab76dea35967175b6ed3879955589b37f" title="Calculates the actual output sample rate for the polyphase resampler.">nn::audio::CalculatePolyphaseResamplerActualOutputSampleRate()</a></code> to calculate the actual output sample rate and check whether that actual value differs from the specified value (either before or after initialization of <code><a class="el" href="structnn_1_1audio_1_1_polyphase_resampler_type.html" title="The structure for managing the resampler.">PolyphaseResamplerType</a></code>) and whether that difference is tolerable. </p>
</div></td></tr>
<tr class="memitem:af5822e19aca28543d2ee8787cb0e8577"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#af5822e19aca28543d2ee8787cb0e8577">GetRequiredBufferSizeForPolyphaseResampler</a> (int inputSampleRate, int outputSampleRate, int channelCount, bool isHighQuality) noexcept</td></tr>
<tr class="memdesc:af5822e19aca28543d2ee8787cb0e8577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the size of the buffer required for the polyphase resampler.  <a href="namespacenn_1_1audio.html#af5822e19aca28543d2ee8787cb0e8577">More...</a><br /></td></tr>
<tr class="separator:af5822e19aca28543d2ee8787cb0e8577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76dea35967175b6ed3879955589b37f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ab76dea35967175b6ed3879955589b37f">CalculatePolyphaseResamplerActualOutputSampleRate</a> (int inputSampleRate, int outputSampleRate) noexcept</td></tr>
<tr class="memdesc:ab76dea35967175b6ed3879955589b37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the actual output sample rate for the polyphase resampler.  <a href="namespacenn_1_1audio.html#ab76dea35967175b6ed3879955589b37f">More...</a><br /></td></tr>
<tr class="separator:ab76dea35967175b6ed3879955589b37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1600e37d5cf3718ff890321f7c3de4ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a1600e37d5cf3718ff890321f7c3de4ee">GetPolyphaseResamplerOutputSampleCount</a> (const <a class="el" href="structnn_1_1audio_1_1_polyphase_resampler_type.html">PolyphaseResamplerType</a> *pResampler, int inputSampleCount) noexcept</td></tr>
<tr class="memdesc:a1600e37d5cf3718ff890321f7c3de4ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the maximum number of output samples that will be obtained from the polyphase resampler process based on the number of input samples.  <a href="namespacenn_1_1audio.html#a1600e37d5cf3718ff890321f7c3de4ee">More...</a><br /></td></tr>
<tr class="separator:a1600e37d5cf3718ff890321f7c3de4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ccfba53d152b2a7b26b61944f90a39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a15ccfba53d152b2a7b26b61944f90a39">InitializePolyphaseResampler</a> (<a class="el" href="structnn_1_1audio_1_1_polyphase_resampler_type.html">PolyphaseResamplerType</a> *pResampler, void *buffer, size_t bufferSize, int inputSampleRate, int outputSampleRate, int channelCount, bool isHighQuality, float gain) noexcept</td></tr>
<tr class="memdesc:a15ccfba53d152b2a7b26b61944f90a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the polyphase resampler.  <a href="namespacenn_1_1audio.html#a15ccfba53d152b2a7b26b61944f90a39">More...</a><br /></td></tr>
<tr class="separator:a15ccfba53d152b2a7b26b61944f90a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d4544d97f0e4d2a15603197c96f6b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#af6d4544d97f0e4d2a15603197c96f6b9">ProcessPolyphaseResamplerBuffer</a> (<a class="el" href="structnn_1_1audio_1_1_polyphase_resampler_type.html">PolyphaseResamplerType</a> *pResampler, int *pOutputSampleCount, int16_t *pOutputBuffer, size_t outputBufferSize, const int16_t *pInputBuffer, int inputSampleCount) noexcept</td></tr>
<tr class="memdesc:af6d4544d97f0e4d2a15603197c96f6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the polyphase resampler to convert the frequency.  <a href="namespacenn_1_1audio.html#af6d4544d97f0e4d2a15603197c96f6b9">More...</a><br /></td></tr>
<tr class="separator:af6d4544d97f0e4d2a15603197c96f6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Resampler Functions</div></td></tr>
<tr class="memitem:a170d77cd0820e896556ec2838ddb375b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a170d77cd0820e896556ec2838ddb375b">GetRequiredBufferSizeForResampler</a> (int channelCount) noexcept</td></tr>
<tr class="memdesc:a170d77cd0820e896556ec2838ddb375b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the size of the buffer required for the resampler.  <a href="namespacenn_1_1audio.html#a170d77cd0820e896556ec2838ddb375b">More...</a><br /></td></tr>
<tr class="separator:a170d77cd0820e896556ec2838ddb375b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4af05ca5d0411d406afd8a691829f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a9f4af05ca5d0411d406afd8a691829f9">GetResamplerOutputSampleCount</a> (const <a class="el" href="structnn_1_1audio_1_1_resampler_type.html">ResamplerType</a> *pResampler, int inputSampleCount) noexcept</td></tr>
<tr class="memdesc:a9f4af05ca5d0411d406afd8a691829f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the maximum number of output samples that will be obtained from the resampler process based on the number of input samples.  <a href="namespacenn_1_1audio.html#a9f4af05ca5d0411d406afd8a691829f9">More...</a><br /></td></tr>
<tr class="separator:a9f4af05ca5d0411d406afd8a691829f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0e4d5282ee5a5af26aa605d60a4d7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a5b0e4d5282ee5a5af26aa605d60a4d7e">InitializeResampler</a> (<a class="el" href="structnn_1_1audio_1_1_resampler_type.html">ResamplerType</a> *pResampler, void *buffer, size_t bufferSize, int inputSampleRate, int outputSampleRate, int channelCount) noexcept</td></tr>
<tr class="memdesc:a5b0e4d5282ee5a5af26aa605d60a4d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the resampler.  <a href="namespacenn_1_1audio.html#a5b0e4d5282ee5a5af26aa605d60a4d7e">More...</a><br /></td></tr>
<tr class="separator:a5b0e4d5282ee5a5af26aa605d60a4d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5e45f72831e900530a7d0c7fd01cca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a7a5e45f72831e900530a7d0c7fd01cca">ProcessResamplerBuffer</a> (<a class="el" href="structnn_1_1audio_1_1_resampler_type.html">ResamplerType</a> *pResampler, int *pOutputSampleCount, int16_t *pOutputBuffer, size_t outputBufferSize, const int16_t *pInputBuffer, int inputSampleCount) noexcept</td></tr>
<tr class="memdesc:a7a5e45f72831e900530a7d0c7fd01cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the resampler to change the frequency.  <a href="namespacenn_1_1audio.html#a7a5e45f72831e900530a7d0c7fd01cca">More...</a><br /></td></tr>
<tr class="separator:a7a5e45f72831e900530a7d0c7fd01cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Audio Renderer Sink API</div></td></tr>
<tr class="memitem:ae8e93a633168c40c9b716c88c49c5e47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ae8e93a633168c40c9b716c88c49c5e47">AddDeviceSink</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_device_sink_type.html">DeviceSinkType</a> *pOutSink, <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pFinalMix, const int8_t *input, int inputCount, const char *name) noexcept</td></tr>
<tr class="memdesc:ae8e93a633168c40c9b716c88c49c5e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a sink for the audio output device.  <a href="namespacenn_1_1audio.html#ae8e93a633168c40c9b716c88c49c5e47">More...</a><br /></td></tr>
<tr class="separator:ae8e93a633168c40c9b716c88c49c5e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa6de7dd4ac31f578bc0ea50d857cf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a5fa6de7dd4ac31f578bc0ea50d857cf5">RemoveDeviceSink</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_device_sink_type.html">DeviceSinkType</a> *pSink, <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pFinalMix) noexcept</td></tr>
<tr class="memdesc:a5fa6de7dd4ac31f578bc0ea50d857cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes a sink for the audio output device.  <a href="namespacenn_1_1audio.html#a5fa6de7dd4ac31f578bc0ea50d857cf5">More...</a><br /></td></tr>
<tr class="separator:a5fa6de7dd4ac31f578bc0ea50d857cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc3e7a542ed11a8d218214377c4e511"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#abdc3e7a542ed11a8d218214377c4e511">SetDownMixParameter</a> (<a class="el" href="structnn_1_1audio_1_1_device_sink_type.html">DeviceSinkType</a> *pSink, const <a class="el" href="structnn_1_1audio_1_1_device_sink_type_1_1_down_mix_parameter.html">DeviceSinkType::DownMixParameter</a> *pParameter) noexcept</td></tr>
<tr class="memdesc:abdc3e7a542ed11a8d218214377c4e511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the parameter to use for downmixing.  <a href="namespacenn_1_1audio.html#abdc3e7a542ed11a8d218214377c4e511">More...</a><br /></td></tr>
<tr class="separator:abdc3e7a542ed11a8d218214377c4e511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654435955efb9603980adb8fd7ad4a6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a654435955efb9603980adb8fd7ad4a6a">GetDownMixParameter</a> (<a class="el" href="structnn_1_1audio_1_1_device_sink_type_1_1_down_mix_parameter.html">DeviceSinkType::DownMixParameter</a> *pOutParameter, const <a class="el" href="structnn_1_1audio_1_1_device_sink_type.html">DeviceSinkType</a> *pSink) noexcept</td></tr>
<tr class="memdesc:a654435955efb9603980adb8fd7ad4a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the parameter to use for downmixing.  <a href="namespacenn_1_1audio.html#a654435955efb9603980adb8fd7ad4a6a">More...</a><br /></td></tr>
<tr class="separator:a654435955efb9603980adb8fd7ad4a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae390b4fb4f79f895e18e24c93ac4483b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ae390b4fb4f79f895e18e24c93ac4483b">SetDownMixParameterEnabled</a> (<a class="el" href="structnn_1_1audio_1_1_device_sink_type.html">DeviceSinkType</a> *pSink, bool enabled) noexcept</td></tr>
<tr class="memdesc:ae390b4fb4f79f895e18e24c93ac4483b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether to enable application-specific downmixing.  <a href="namespacenn_1_1audio.html#ae390b4fb4f79f895e18e24c93ac4483b">More...</a><br /></td></tr>
<tr class="separator:ae390b4fb4f79f895e18e24c93ac4483b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07de192db43f64e0af3da756478f8858"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a07de192db43f64e0af3da756478f8858">IsDownMixParameterEnabled</a> (const <a class="el" href="structnn_1_1audio_1_1_device_sink_type.html">DeviceSinkType</a> *pSink) noexcept</td></tr>
<tr class="memdesc:a07de192db43f64e0af3da756478f8858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether application-specific downmixing is enabled or disabled.  <a href="namespacenn_1_1audio.html#a07de192db43f64e0af3da756478f8858">More...</a><br /></td></tr>
<tr class="separator:a07de192db43f64e0af3da756478f8858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af781d15dcac44311d87e69ccab19cf57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#af781d15dcac44311d87e69ccab19cf57">AddCircularBufferSink</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_circular_buffer_sink_type.html">CircularBufferSinkType</a> *pOutSink, <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pFinalMix, const int8_t *input, int inputCount, void *buffer, size_t size, <a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1">SampleFormat</a> sampleFormat) noexcept</td></tr>
<tr class="memdesc:af781d15dcac44311d87e69ccab19cf57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes <code>Sink</code> for a circular buffer.  <a href="namespacenn_1_1audio.html#af781d15dcac44311d87e69ccab19cf57">More...</a><br /></td></tr>
<tr class="separator:af781d15dcac44311d87e69ccab19cf57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474950248dbba54eb5973c722b64acf7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a474950248dbba54eb5973c722b64acf7">RemoveCircularBufferSink</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_circular_buffer_sink_type.html">CircularBufferSinkType</a> *pSink, <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pFinalMix) noexcept</td></tr>
<tr class="memdesc:a474950248dbba54eb5973c722b64acf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes a sink for a circular buffer.  <a href="namespacenn_1_1audio.html#a474950248dbba54eb5973c722b64acf7">More...</a><br /></td></tr>
<tr class="separator:a474950248dbba54eb5973c722b64acf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691cf6276a2d79af683e204a38426177"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a691cf6276a2d79af683e204a38426177">GetRequiredBufferSizeForCircularBufferSink</a> (const <a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html">AudioRendererParameter</a> *pParameter, int inputCount, int frameCount, <a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1">SampleFormat</a> sampleFormat) noexcept</td></tr>
<tr class="memdesc:a691cf6276a2d79af683e204a38426177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the buffer size required for the circular buffer <code>Sink</code>.  <a href="namespacenn_1_1audio.html#a691cf6276a2d79af683e204a38426177">More...</a><br /></td></tr>
<tr class="separator:a691cf6276a2d79af683e204a38426177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ea8ebfb7f48ae04043e2103d4c8a58"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a38ea8ebfb7f48ae04043e2103d4c8a58">ReadCircularBufferSink</a> (<a class="el" href="structnn_1_1audio_1_1_circular_buffer_sink_type.html">CircularBufferSinkType</a> *pSink, void *pOutBuffer, size_t bufferSize) noexcept</td></tr>
<tr class="memdesc:a38ea8ebfb7f48ae04043e2103d4c8a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load sample data from the circular buffer <code>Sink</code>.  <a href="namespacenn_1_1audio.html#a38ea8ebfb7f48ae04043e2103d4c8a58">More...</a><br /></td></tr>
<tr class="separator:a38ea8ebfb7f48ae04043e2103d4c8a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5a02f991e12a4b638dd2a94ada088f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1audio.html#a347cdc16fef8e35aad9d8d0cd2e79e38">NodeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a4f5a02f991e12a4b638dd2a94ada088f">GetSinkNodeId</a> (const <a class="el" href="structnn_1_1audio_1_1_device_sink_type.html">DeviceSinkType</a> *pSink) noexcept</td></tr>
<tr class="memdesc:a4f5a02f991e12a4b638dd2a94ada088f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the ID of the <code><a class="el" href="structnn_1_1audio_1_1_device_sink_type.html" title="Sink to output the rendering results to the audio output device.">DeviceSinkType</a></code> in the audio renderer.  <a href="namespacenn_1_1audio.html#a4f5a02f991e12a4b638dd2a94ada088f">More...</a><br /></td></tr>
<tr class="separator:a4f5a02f991e12a4b638dd2a94ada088f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47406b72adf5bef0659eda4247fa6d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1audio.html#a347cdc16fef8e35aad9d8d0cd2e79e38">NodeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aa47406b72adf5bef0659eda4247fa6d6">GetSinkNodeId</a> (const <a class="el" href="structnn_1_1audio_1_1_circular_buffer_sink_type.html">CircularBufferSinkType</a> *pSink) noexcept</td></tr>
<tr class="memdesc:aa47406b72adf5bef0659eda4247fa6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the ID of the <code><a class="el" href="structnn_1_1audio_1_1_circular_buffer_sink_type.html" title="Sink to output the rendering results to memory.">CircularBufferSinkType</a></code> object in the audio renderer.  <a href="namespacenn_1_1audio.html#aa47406b72adf5bef0659eda4247fa6d6">More...</a><br /></td></tr>
<tr class="separator:aa47406b72adf5bef0659eda4247fa6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Audio Renderer SplitterType Functions</div></td></tr>
<tr class="memitem:a2d3b900b04b3704eab4aad529cc4cb37"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a2d3b900b04b3704eab4aad529cc4cb37">AcquireSplitter</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_splitter_type.html">SplitterType</a> *pOutSplitter, int sampleRate, int sourceChannelCount, int destinationCount) noexcept</td></tr>
<tr class="memdesc:a2d3b900b04b3704eab4aad529cc4cb37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code> object and adds it to <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code>.  <a href="namespacenn_1_1audio.html#a2d3b900b04b3704eab4aad529cc4cb37">More...</a><br /></td></tr>
<tr class="separator:a2d3b900b04b3704eab4aad529cc4cb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad46c1c8a8f652e4223ac091cea7f8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a9ad46c1c8a8f652e4223ac091cea7f8c">ReleaseSplitter</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_splitter_type.html">SplitterType</a> *pOutSplitter) noexcept</td></tr>
<tr class="memdesc:a9ad46c1c8a8f652e4223ac091cea7f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> from <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code>.  <a href="namespacenn_1_1audio.html#a9ad46c1c8a8f652e4223ac091cea7f8c">More...</a><br /></td></tr>
<tr class="separator:a9ad46c1c8a8f652e4223ac091cea7f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364d3e39d547f60de643b7ad37011495"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a364d3e39d547f60de643b7ad37011495">SetSplitterDestination</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_splitter_type.html">SplitterType</a> *pOutSource, int destinationIndex, <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pDestination) noexcept</td></tr>
<tr class="memdesc:a364d3e39d547f60de643b7ad37011495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the <code>SubMix</code> as one output destination for <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code>.  <a href="namespacenn_1_1audio.html#a364d3e39d547f60de643b7ad37011495">More...</a><br /></td></tr>
<tr class="separator:a364d3e39d547f60de643b7ad37011495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046c9026c45c15030effcbc167a268fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a046c9026c45c15030effcbc167a268fa">SetSplitterDestination</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_splitter_type.html">SplitterType</a> *pOutSource, int destinationIndex, <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pDestination) noexcept</td></tr>
<tr class="memdesc:a046c9026c45c15030effcbc167a268fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies <code>FinalMixMix</code> as one output destination for <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code>.  <a href="namespacenn_1_1audio.html#a046c9026c45c15030effcbc167a268fa">More...</a><br /></td></tr>
<tr class="separator:a046c9026c45c15030effcbc167a268fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32840807391ce6907daefb6092f02654"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a32840807391ce6907daefb6092f02654">ClearSplitterDestination</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_splitter_type.html">SplitterType</a> *pOutSource, int destinationIndex) noexcept</td></tr>
<tr class="memdesc:a32840807391ce6907daefb6092f02654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the output destination specified for <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code>.  <a href="namespacenn_1_1audio.html#a32840807391ce6907daefb6092f02654">More...</a><br /></td></tr>
<tr class="separator:a32840807391ce6907daefb6092f02654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d211a6bf9009d4067c320541c625bd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a0d211a6bf9009d4067c320541c625bd2">SetSplitterMixVolume</a> (<a class="el" href="structnn_1_1audio_1_1_splitter_type.html">SplitterType</a> *pOutSource, int destinationIndex, <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pDestination, float volume, int sourceChannelIndex, int destinationChannelIndex) noexcept</td></tr>
<tr class="memdesc:a0d211a6bf9009d4067c320541c625bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the mix volume for the output destinations from <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code>.  <a href="namespacenn_1_1audio.html#a0d211a6bf9009d4067c320541c625bd2">More...</a><br /></td></tr>
<tr class="separator:a0d211a6bf9009d4067c320541c625bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f501358997f8809b249a64ecb74e05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#af0f501358997f8809b249a64ecb74e05">SetSplitterMixVolume</a> (<a class="el" href="structnn_1_1audio_1_1_splitter_type.html">SplitterType</a> *pOutSource, int destinationIndex, <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pDestination, float volume, int sourceChannelIndex, int destinationChannelIndex) noexcept</td></tr>
<tr class="memdesc:af0f501358997f8809b249a64ecb74e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the mix volume for the output destinations from <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code>.  <a href="namespacenn_1_1audio.html#af0f501358997f8809b249a64ecb74e05">More...</a><br /></td></tr>
<tr class="separator:af0f501358997f8809b249a64ecb74e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82155de4e1539ef1356f504f97d8993"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ad82155de4e1539ef1356f504f97d8993">GetSplitterMixVolume</a> (const <a class="el" href="structnn_1_1audio_1_1_splitter_type.html">SplitterType</a> *pSource, int destinationIndex, const <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pDestination, int sourceChannelIndex, int destinationChannelIndex) noexcept</td></tr>
<tr class="memdesc:ad82155de4e1539ef1356f504f97d8993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the mix volume for the output destinations from <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code>.  <a href="namespacenn_1_1audio.html#ad82155de4e1539ef1356f504f97d8993">More...</a><br /></td></tr>
<tr class="separator:ad82155de4e1539ef1356f504f97d8993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403ec19365da9d1bc92ebd379d7e5e55"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a403ec19365da9d1bc92ebd379d7e5e55">GetSplitterMixVolume</a> (const <a class="el" href="structnn_1_1audio_1_1_splitter_type.html">SplitterType</a> *pSource, int destinationIndex, const <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pDestination, int sourceChannelIndex, int destinationChannelIndex) noexcept</td></tr>
<tr class="memdesc:a403ec19365da9d1bc92ebd379d7e5e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the mix volume for the output destinations from <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code>.  <a href="namespacenn_1_1audio.html#a403ec19365da9d1bc92ebd379d7e5e55">More...</a><br /></td></tr>
<tr class="separator:a403ec19365da9d1bc92ebd379d7e5e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfc327793ff4c5abbd780033c1f93ae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a7bfc327793ff4c5abbd780033c1f93ae">GetSplitterSourceChannelCount</a> (const <a class="el" href="structnn_1_1audio_1_1_splitter_type.html">SplitterType</a> *pSource) noexcept</td></tr>
<tr class="memdesc:a7bfc327793ff4c5abbd780033c1f93ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of input channels for <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code>.  <a href="namespacenn_1_1audio.html#a7bfc327793ff4c5abbd780033c1f93ae">More...</a><br /></td></tr>
<tr class="separator:a7bfc327793ff4c5abbd780033c1f93ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab996d1af1b2b5590d8afbdb205277044"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ab996d1af1b2b5590d8afbdb205277044">GetSplitterDestinationCount</a> (const <a class="el" href="structnn_1_1audio_1_1_splitter_type.html">SplitterType</a> *pSource) noexcept</td></tr>
<tr class="memdesc:ab996d1af1b2b5590d8afbdb205277044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of output destinations from <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code>.  <a href="namespacenn_1_1audio.html#ab996d1af1b2b5590d8afbdb205277044">More...</a><br /></td></tr>
<tr class="separator:ab996d1af1b2b5590d8afbdb205277044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be6d0e347070786c6a7805986982fc3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a8be6d0e347070786c6a7805986982fc3">GetSplitterSampleRate</a> (const <a class="el" href="structnn_1_1audio_1_1_splitter_type.html">SplitterType</a> *pSource) noexcept</td></tr>
<tr class="memdesc:a8be6d0e347070786c6a7805986982fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sample rate specified by <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code>.  <a href="namespacenn_1_1audio.html#a8be6d0e347070786c6a7805986982fc3">More...</a><br /></td></tr>
<tr class="separator:a8be6d0e347070786c6a7805986982fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Audio Renderer SubMix API</div></td></tr>
<tr class="memitem:a24020da05700a26ee46f04f5762c157f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a24020da05700a26ee46f04f5762c157f">AcquireSubMix</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pOutSubMix, int sampleRate, int bufferCount) noexcept</td></tr>
<tr class="memdesc:a24020da05700a26ee46f04f5762c157f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> object and adds it to <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code>.  <a href="namespacenn_1_1audio.html#a24020da05700a26ee46f04f5762c157f">More...</a><br /></td></tr>
<tr class="separator:a24020da05700a26ee46f04f5762c157f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26df5e585272dfe727f08516f9b3751"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#af26df5e585272dfe727f08516f9b3751">ReleaseSubMix</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pSubMix) noexcept</td></tr>
<tr class="memdesc:af26df5e585272dfe727f08516f9b3751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> object from <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code>.  <a href="namespacenn_1_1audio.html#af26df5e585272dfe727f08516f9b3751">More...</a><br /></td></tr>
<tr class="separator:af26df5e585272dfe727f08516f9b3751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421895cf9e6a2f604a3a2d01b1e98459"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a421895cf9e6a2f604a3a2d01b1e98459">SetSubMixDestination</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pSource, <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pDestination) noexcept</td></tr>
<tr class="memdesc:a421895cf9e6a2f604a3a2d01b1e98459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> to which <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> will be output.  <a href="namespacenn_1_1audio.html#a421895cf9e6a2f604a3a2d01b1e98459">More...</a><br /></td></tr>
<tr class="separator:a421895cf9e6a2f604a3a2d01b1e98459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176c68fa47a377bc07eee5f194bdb6ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a176c68fa47a377bc07eee5f194bdb6ea">SetSubMixDestination</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pSource, <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pDestination) noexcept</td></tr>
<tr class="memdesc:a176c68fa47a377bc07eee5f194bdb6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> to which <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> will be output.  <a href="namespacenn_1_1audio.html#a176c68fa47a377bc07eee5f194bdb6ea">More...</a><br /></td></tr>
<tr class="separator:a176c68fa47a377bc07eee5f194bdb6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060b75a1633eb0304db850b7272ec0da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a060b75a1633eb0304db850b7272ec0da">SetSubMixDestination</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pSource, <a class="el" href="structnn_1_1audio_1_1_splitter_type.html">SplitterType</a> *pDestination) noexcept</td></tr>
<tr class="memdesc:a060b75a1633eb0304db850b7272ec0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code> to which <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> will be output.  <a href="namespacenn_1_1audio.html#a060b75a1633eb0304db850b7272ec0da">More...</a><br /></td></tr>
<tr class="separator:a060b75a1633eb0304db850b7272ec0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72df4d42c85ba2a3c5f4e60cf3f7ef8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a72df4d42c85ba2a3c5f4e60cf3f7ef8c">ClearSubMixDestination</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pSource) noexcept</td></tr>
<tr class="memdesc:a72df4d42c85ba2a3c5f4e60cf3f7ef8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the output destination specified for <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>.  <a href="namespacenn_1_1audio.html#a72df4d42c85ba2a3c5f4e60cf3f7ef8c">More...</a><br /></td></tr>
<tr class="separator:a72df4d42c85ba2a3c5f4e60cf3f7ef8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331b58a86c70fe45bf649941db3ca55e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a331b58a86c70fe45bf649941db3ca55e">GetSubMixSampleRate</a> (const <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pSubMix) noexcept</td></tr>
<tr class="memdesc:a331b58a86c70fe45bf649941db3ca55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sample rate of the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> object.  <a href="namespacenn_1_1audio.html#a331b58a86c70fe45bf649941db3ca55e">More...</a><br /></td></tr>
<tr class="separator:a331b58a86c70fe45bf649941db3ca55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76ce2e4c558f038dab51a3a30c068e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ad76ce2e4c558f038dab51a3a30c068e4">GetSubMixBufferCount</a> (const <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pSubMix) noexcept</td></tr>
<tr class="memdesc:ad76ce2e4c558f038dab51a3a30c068e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of mix buffers of the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> object.  <a href="namespacenn_1_1audio.html#ad76ce2e4c558f038dab51a3a30c068e4">More...</a><br /></td></tr>
<tr class="separator:ad76ce2e4c558f038dab51a3a30c068e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6050ccd7effd6dc69eb160afeb23c348"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a6050ccd7effd6dc69eb160afeb23c348">GetSubMixVolume</a> (const <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pSubMix) noexcept</td></tr>
<tr class="memdesc:a6050ccd7effd6dc69eb160afeb23c348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the volume of the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> object.  <a href="namespacenn_1_1audio.html#a6050ccd7effd6dc69eb160afeb23c348">More...</a><br /></td></tr>
<tr class="separator:a6050ccd7effd6dc69eb160afeb23c348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f337a0ec64598348a3f4a7dd9e9951"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ad9f337a0ec64598348a3f4a7dd9e9951">SetSubMixVolume</a> (<a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pSubMix, float volume) noexcept</td></tr>
<tr class="memdesc:ad9f337a0ec64598348a3f4a7dd9e9951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the volume for the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> object.  <a href="namespacenn_1_1audio.html#ad9f337a0ec64598348a3f4a7dd9e9951">More...</a><br /></td></tr>
<tr class="separator:ad9f337a0ec64598348a3f4a7dd9e9951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab363a04dff4cc4c22ae44049aae1a391"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ab363a04dff4cc4c22ae44049aae1a391">SetSubMixMixVolume</a> (<a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pSource, <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pDestination, float volume, int sourceIndex, int destinationIndex) noexcept</td></tr>
<tr class="memdesc:ab363a04dff4cc4c22ae44049aae1a391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the mix volume for the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> object.  <a href="namespacenn_1_1audio.html#ab363a04dff4cc4c22ae44049aae1a391">More...</a><br /></td></tr>
<tr class="separator:ab363a04dff4cc4c22ae44049aae1a391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d86aacbe9bfa18a76f8792219ff21a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a11d86aacbe9bfa18a76f8792219ff21a">GetSubMixMixVolume</a> (const <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pSource, const <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pDestination, int sourceIndex, int destinationIndex) noexcept</td></tr>
<tr class="memdesc:a11d86aacbe9bfa18a76f8792219ff21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the mix volume of the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> object.  <a href="namespacenn_1_1audio.html#a11d86aacbe9bfa18a76f8792219ff21a">More...</a><br /></td></tr>
<tr class="separator:a11d86aacbe9bfa18a76f8792219ff21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae389d0e44e6932bb820729f20b80941f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ae389d0e44e6932bb820729f20b80941f">SetSubMixMixVolume</a> (<a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pSource, <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pDestination, float volume, int sourceIndex, int destinationIndex) noexcept</td></tr>
<tr class="memdesc:ae389d0e44e6932bb820729f20b80941f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the mix volume for the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> object.  <a href="namespacenn_1_1audio.html#ae389d0e44e6932bb820729f20b80941f">More...</a><br /></td></tr>
<tr class="separator:ae389d0e44e6932bb820729f20b80941f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908367c4ffa5997478e7eb4a37928bd5"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a908367c4ffa5997478e7eb4a37928bd5">GetSubMixMixVolume</a> (const <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pSource, const <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pDestination, int sourceIndex, int destinationIndex) noexcept</td></tr>
<tr class="memdesc:a908367c4ffa5997478e7eb4a37928bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the mix volume of the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> object.  <a href="namespacenn_1_1audio.html#a908367c4ffa5997478e7eb4a37928bd5">More...</a><br /></td></tr>
<tr class="separator:a908367c4ffa5997478e7eb4a37928bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0746343c5cb001974880a196f781b600"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1audio.html#a347cdc16fef8e35aad9d8d0cd2e79e38">NodeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a0746343c5cb001974880a196f781b600">GetSubMixNodeId</a> (const <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pSubMix) noexcept</td></tr>
<tr class="memdesc:a0746343c5cb001974880a196f781b600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the ID of the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> object in the audio renderer.  <a href="namespacenn_1_1audio.html#a0746343c5cb001974880a196f781b600">More...</a><br /></td></tr>
<tr class="separator:a0746343c5cb001974880a196f781b600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Audio Renderer Voice API</div></td></tr>
<tr class="memitem:a3cc31617500698ba14f0d1d5e20b7668"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a3cc31617500698ba14f0d1d5e20b7668">AcquireVoiceSlot</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pOutVoice, int sampleRate, int channelCount, <a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1">SampleFormat</a> sampleFormat, int priority, const void *pParameter, size_t size, const <a class="el" href="structnn_1_1audio_1_1_voice_type_1_1_behavior_options.html">VoiceType::BehaviorOptions</a> *pBehaviorOptions) noexcept</td></tr>
<tr class="memdesc:a3cc31617500698ba14f0d1d5e20b7668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> with options that specify its behavior and adds it to <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code>.  <a href="namespacenn_1_1audio.html#a3cc31617500698ba14f0d1d5e20b7668">More...</a><br /></td></tr>
<tr class="separator:a3cc31617500698ba14f0d1d5e20b7668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1e63f9649eb722402faa1d16e0b23e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#adb1e63f9649eb722402faa1d16e0b23e">AcquireVoiceSlot</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pOutVoice, int sampleRate, int channelCount, <a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1">SampleFormat</a> sampleFormat, int priority, const void *pParameter, size_t size) noexcept</td></tr>
<tr class="memdesc:adb1e63f9649eb722402faa1d16e0b23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object and adds it to <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code>.  <a href="namespacenn_1_1audio.html#adb1e63f9649eb722402faa1d16e0b23e">More...</a><br /></td></tr>
<tr class="separator:adb1e63f9649eb722402faa1d16e0b23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88951e64989eabeb6ca689fb07932b68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a88951e64989eabeb6ca689fb07932b68">ReleaseVoiceSlot</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pVoice) noexcept</td></tr>
<tr class="memdesc:a88951e64989eabeb6ca689fb07932b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object from <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code>.  <a href="namespacenn_1_1audio.html#a88951e64989eabeb6ca689fb07932b68">More...</a><br /></td></tr>
<tr class="separator:a88951e64989eabeb6ca689fb07932b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6457f605759151613511c5ae0b6a231b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a6457f605759151613511c5ae0b6a231b">IsVoiceValid</a> (const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pVoice) noexcept</td></tr>
<tr class="memdesc:a6457f605759151613511c5ae0b6a231b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> is valid.  <a href="namespacenn_1_1audio.html#a6457f605759151613511c5ae0b6a231b">More...</a><br /></td></tr>
<tr class="separator:a6457f605759151613511c5ae0b6a231b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85cbaceb0aaf8e8169c6bc0fbb72b51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aa85cbaceb0aaf8e8169c6bc0fbb72b51">IsVoiceDroppedFlagOn</a> (const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pVoice) noexcept</td></tr>
<tr class="memdesc:aa85cbaceb0aaf8e8169c6bc0fbb72b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of voice drop flags for <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>.  <a href="namespacenn_1_1audio.html#aa85cbaceb0aaf8e8169c6bc0fbb72b51">More...</a><br /></td></tr>
<tr class="separator:aa85cbaceb0aaf8e8169c6bc0fbb72b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dec0528f1287ebf549b3e84b18fb18f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a6dec0528f1287ebf549b3e84b18fb18f">ResetVoiceDroppedFlag</a> (<a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pVoice) noexcept</td></tr>
<tr class="memdesc:a6dec0528f1287ebf549b3e84b18fb18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> voice drop flag to off.  <a href="namespacenn_1_1audio.html#a6dec0528f1287ebf549b3e84b18fb18f">More...</a><br /></td></tr>
<tr class="separator:a6dec0528f1287ebf549b3e84b18fb18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82bfb03f43f4a2680f5ad7eff0967545"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a82bfb03f43f4a2680f5ad7eff0967545">SetVoiceDestination</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pSource, <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pDestination) noexcept</td></tr>
<tr class="memdesc:a82bfb03f43f4a2680f5ad7eff0967545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <code>FinalMix</code> that is the output destination of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>.  <a href="namespacenn_1_1audio.html#a82bfb03f43f4a2680f5ad7eff0967545">More...</a><br /></td></tr>
<tr class="separator:a82bfb03f43f4a2680f5ad7eff0967545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae312c1ecdae8d3cd1ff0a83fa50b6aca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ae312c1ecdae8d3cd1ff0a83fa50b6aca">SetVoiceDestination</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pSource, <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pDestination) noexcept</td></tr>
<tr class="memdesc:ae312c1ecdae8d3cd1ff0a83fa50b6aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <code>SubMix</code> that is the output destination of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>.  <a href="namespacenn_1_1audio.html#ae312c1ecdae8d3cd1ff0a83fa50b6aca">More...</a><br /></td></tr>
<tr class="separator:ae312c1ecdae8d3cd1ff0a83fa50b6aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2308d4a669dcf38a4b4e260138e051"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a0d2308d4a669dcf38a4b4e260138e051">SetVoiceDestination</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pSource, <a class="el" href="structnn_1_1audio_1_1_splitter_type.html">SplitterType</a> *pDestination) noexcept</td></tr>
<tr class="memdesc:a0d2308d4a669dcf38a4b4e260138e051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code> that is the output destination of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>.  <a href="namespacenn_1_1audio.html#a0d2308d4a669dcf38a4b4e260138e051">More...</a><br /></td></tr>
<tr class="separator:a0d2308d4a669dcf38a4b4e260138e051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362d4c2d8e84a10893cd11211851dc08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a362d4c2d8e84a10893cd11211851dc08">ClearVoiceDestination</a> (<a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *pOutConfig, <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pSource) noexcept</td></tr>
<tr class="memdesc:a362d4c2d8e84a10893cd11211851dc08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the output destination specified for <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>.  <a href="namespacenn_1_1audio.html#a362d4c2d8e84a10893cd11211851dc08">More...</a><br /></td></tr>
<tr class="separator:a362d4c2d8e84a10893cd11211851dc08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad2134ecc8dc166e2eddce11ba7ca9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#adad2134ecc8dc166e2eddce11ba7ca9e">GetVoiceSampleRate</a> (const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pVoice) noexcept</td></tr>
<tr class="memdesc:adad2134ecc8dc166e2eddce11ba7ca9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sample rate of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object.  <a href="namespacenn_1_1audio.html#adad2134ecc8dc166e2eddce11ba7ca9e">More...</a><br /></td></tr>
<tr class="separator:adad2134ecc8dc166e2eddce11ba7ca9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da2095b63c0acec0795bb420d47019b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a6da2095b63c0acec0795bb420d47019b">GetVoiceChannelCount</a> (const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pVoice) noexcept</td></tr>
<tr class="memdesc:a6da2095b63c0acec0795bb420d47019b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of channels of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object.  <a href="namespacenn_1_1audio.html#a6da2095b63c0acec0795bb420d47019b">More...</a><br /></td></tr>
<tr class="separator:a6da2095b63c0acec0795bb420d47019b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345a0ad833ebf792efac5e4cad96f8b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1">SampleFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a345a0ad833ebf792efac5e4cad96f8b7">GetVoiceSampleFormat</a> (const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pVoice) noexcept</td></tr>
<tr class="memdesc:a345a0ad833ebf792efac5e4cad96f8b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sample format of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object.  <a href="namespacenn_1_1audio.html#a345a0ad833ebf792efac5e4cad96f8b7">More...</a><br /></td></tr>
<tr class="separator:a345a0ad833ebf792efac5e4cad96f8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfcc54fa62e17bfafb7d1db80b5783d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#adfcc54fa62e17bfafb7d1db80b5783d1">SetVoicePriority</a> (<a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pVoice, int priority) noexcept</td></tr>
<tr class="memdesc:adfcc54fa62e17bfafb7d1db80b5783d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the priority of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>.  <a href="namespacenn_1_1audio.html#adfcc54fa62e17bfafb7d1db80b5783d1">More...</a><br /></td></tr>
<tr class="separator:adfcc54fa62e17bfafb7d1db80b5783d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2bdbb3eb75d94e61b38739dff4b0044"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ae2bdbb3eb75d94e61b38739dff4b0044">GetVoicePriority</a> (const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pVoice) noexcept</td></tr>
<tr class="memdesc:ae2bdbb3eb75d94e61b38739dff4b0044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the priority of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object.  <a href="namespacenn_1_1audio.html#ae2bdbb3eb75d94e61b38739dff4b0044">More...</a><br /></td></tr>
<tr class="separator:ae2bdbb3eb75d94e61b38739dff4b0044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a09b692d969f08155cf7f0f57d9ace"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a04a09b692d969f08155cf7f0f57d9ace">SetVoicePlayState</a> (<a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pVoice, <a class="el" href="structnn_1_1audio_1_1_voice_type.html#a8a74fe64f7b887248f696c25b76baf31">VoiceType::PlayState</a> playState) noexcept</td></tr>
<tr class="memdesc:a04a09b692d969f08155cf7f0f57d9ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the play state for the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object.  <a href="namespacenn_1_1audio.html#a04a09b692d969f08155cf7f0f57d9ace">More...</a><br /></td></tr>
<tr class="separator:a04a09b692d969f08155cf7f0f57d9ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826e9a8d1f5cdc8874069d0c05a3fcbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1audio_1_1_voice_type.html#a8a74fe64f7b887248f696c25b76baf31">VoiceType::PlayState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a826e9a8d1f5cdc8874069d0c05a3fcbc">GetVoicePlayState</a> (const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pVoice) noexcept</td></tr>
<tr class="memdesc:a826e9a8d1f5cdc8874069d0c05a3fcbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the play state of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object.  <a href="namespacenn_1_1audio.html#a826e9a8d1f5cdc8874069d0c05a3fcbc">More...</a><br /></td></tr>
<tr class="separator:a826e9a8d1f5cdc8874069d0c05a3fcbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43dee40c156799c2e3e43da4e1b86cd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a43dee40c156799c2e3e43da4e1b86cd0">SetVoiceSrcQuality</a> (<a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pVoice, <a class="el" href="structnn_1_1audio_1_1_voice_type.html#a08afa9ca6e321c4a460ee9f50bc247d4">VoiceType::SrcQuality</a> srcQuality) noexcept</td></tr>
<tr class="memdesc:a43dee40c156799c2e3e43da4e1b86cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the quality of the <a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a> sample rate conversion.  <a href="namespacenn_1_1audio.html#a43dee40c156799c2e3e43da4e1b86cd0">More...</a><br /></td></tr>
<tr class="separator:a43dee40c156799c2e3e43da4e1b86cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e571f41a87a871569578709b42cbc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1audio_1_1_voice_type.html#a08afa9ca6e321c4a460ee9f50bc247d4">VoiceType::SrcQuality</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#af1e571f41a87a871569578709b42cbc3">GetVoiceSrcQuality</a> (const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pVoice) noexcept</td></tr>
<tr class="memdesc:af1e571f41a87a871569578709b42cbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the quality of the <a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a> sample rate conversion.  <a href="namespacenn_1_1audio.html#af1e571f41a87a871569578709b42cbc3">More...</a><br /></td></tr>
<tr class="separator:af1e571f41a87a871569578709b42cbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd2853027ae5ab1516dbf53dd6fb6d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aabd2853027ae5ab1516dbf53dd6fb6d9">SetVoicePitch</a> (<a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pVoice, float pitch) noexcept</td></tr>
<tr class="memdesc:aabd2853027ae5ab1516dbf53dd6fb6d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the pitch for the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object.  <a href="namespacenn_1_1audio.html#aabd2853027ae5ab1516dbf53dd6fb6d9">More...</a><br /></td></tr>
<tr class="separator:aabd2853027ae5ab1516dbf53dd6fb6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa9a327d0d3ccacdfd7aa80ad2fbad81"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aaa9a327d0d3ccacdfd7aa80ad2fbad81">GetVoicePitch</a> (const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pVoice) noexcept</td></tr>
<tr class="memdesc:aaa9a327d0d3ccacdfd7aa80ad2fbad81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pitch of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object.  <a href="namespacenn_1_1audio.html#aaa9a327d0d3ccacdfd7aa80ad2fbad81">More...</a><br /></td></tr>
<tr class="separator:aaa9a327d0d3ccacdfd7aa80ad2fbad81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab682fee631b9558bea96e8c8d554e750"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ab682fee631b9558bea96e8c8d554e750">SetVoiceVolume</a> (<a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pVoice, float volume) noexcept</td></tr>
<tr class="memdesc:ab682fee631b9558bea96e8c8d554e750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the volume for the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object.  <a href="namespacenn_1_1audio.html#ab682fee631b9558bea96e8c8d554e750">More...</a><br /></td></tr>
<tr class="separator:ab682fee631b9558bea96e8c8d554e750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1411aeea222ca74dd86380a9b54b748"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ae1411aeea222ca74dd86380a9b54b748">GetVoiceVolume</a> (const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pVoice) noexcept</td></tr>
<tr class="memdesc:ae1411aeea222ca74dd86380a9b54b748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the volume of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object.  <a href="namespacenn_1_1audio.html#ae1411aeea222ca74dd86380a9b54b748">More...</a><br /></td></tr>
<tr class="separator:ae1411aeea222ca74dd86380a9b54b748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a74d5457b16f38d3271eb452dcec395"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a9a74d5457b16f38d3271eb452dcec395">SetVoiceMixVolume</a> (<a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pSource, <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pDestination, float volume, int sourceIndex, int destinationIndex) noexcept</td></tr>
<tr class="memdesc:a9a74d5457b16f38d3271eb452dcec395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the mix volume for the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object.  <a href="namespacenn_1_1audio.html#a9a74d5457b16f38d3271eb452dcec395">More...</a><br /></td></tr>
<tr class="separator:a9a74d5457b16f38d3271eb452dcec395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b36760a203ccd45174210b0fd21818"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a87b36760a203ccd45174210b0fd21818">GetVoiceMixVolume</a> (const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pSource, const <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *pDestination, int sourceIndex, int destinationIndex) noexcept</td></tr>
<tr class="memdesc:a87b36760a203ccd45174210b0fd21818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the mix volume of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object.  <a href="namespacenn_1_1audio.html#a87b36760a203ccd45174210b0fd21818">More...</a><br /></td></tr>
<tr class="separator:a87b36760a203ccd45174210b0fd21818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ee35342e3a63683009e7d893db67b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a99ee35342e3a63683009e7d893db67b3">SetVoiceMixVolume</a> (<a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pSource, <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pDestination, float volume, int sourceIndex, int destinationIndex) noexcept</td></tr>
<tr class="memdesc:a99ee35342e3a63683009e7d893db67b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the mix volume for the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object.  <a href="namespacenn_1_1audio.html#a99ee35342e3a63683009e7d893db67b3">More...</a><br /></td></tr>
<tr class="separator:a99ee35342e3a63683009e7d893db67b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4148242de491539dc39802da024bb2fa"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a4148242de491539dc39802da024bb2fa">GetVoiceMixVolume</a> (const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pSource, const <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *pDestination, int sourceIndex, int destinationIndex) noexcept</td></tr>
<tr class="memdesc:a4148242de491539dc39802da024bb2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the mix volume of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object.  <a href="namespacenn_1_1audio.html#a4148242de491539dc39802da024bb2fa">More...</a><br /></td></tr>
<tr class="separator:a4148242de491539dc39802da024bb2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4277ca190567127f0a18b0b5f4755f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a7e4277ca190567127f0a18b0b5f4755f">SetVoiceBiquadFilterParameter</a> (<a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pVoice, int filterIndex, const <a class="el" href="structnn_1_1audio_1_1_biquad_filter_parameter.html">BiquadFilterParameter</a> &amp;parameter) noexcept</td></tr>
<tr class="memdesc:a7e4277ca190567127f0a18b0b5f4755f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the biquad filter parameter for the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object.  <a href="namespacenn_1_1audio.html#a7e4277ca190567127f0a18b0b5f4755f">More...</a><br /></td></tr>
<tr class="separator:a7e4277ca190567127f0a18b0b5f4755f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880d8f048e8f06959e08fb611f3647ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1audio_1_1_biquad_filter_parameter.html">BiquadFilterParameter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a880d8f048e8f06959e08fb611f3647ec">GetVoiceBiquadFilterParameter</a> (const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pVoice, int filterIndex) noexcept</td></tr>
<tr class="memdesc:a880d8f048e8f06959e08fb611f3647ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the biquad filter parameter of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object.  <a href="namespacenn_1_1audio.html#a880d8f048e8f06959e08fb611f3647ec">More...</a><br /></td></tr>
<tr class="separator:a880d8f048e8f06959e08fb611f3647ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58886eeb3fac72d6e84dcad5d2704df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#aa58886eeb3fac72d6e84dcad5d2704df">AppendWaveBuffer</a> (<a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pVoice, const <a class="el" href="structnn_1_1audio_1_1_wave_buffer.html">WaveBuffer</a> *pWaveBuffer) noexcept</td></tr>
<tr class="memdesc:aa58886eeb3fac72d6e84dcad5d2704df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>.  <a href="namespacenn_1_1audio.html#aa58886eeb3fac72d6e84dcad5d2704df">More...</a><br /></td></tr>
<tr class="separator:aa58886eeb3fac72d6e84dcad5d2704df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1b5be7d8f4137107b0f09d7813a76e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a4c1b5be7d8f4137107b0f09d7813a76e">AppendWaveBuffer</a> (<a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pVoice, const <a class="el" href="structnn_1_1audio_1_1_wave_buffer.html">WaveBuffer</a> *pWaveBuffer, const <a class="el" href="structnn_1_1audio_1_1_wave_buffer_1_1_member_options.html">WaveBuffer::MemberOptions</a> *pMemberOptions) noexcept</td></tr>
<tr class="memdesc:a4c1b5be7d8f4137107b0f09d7813a76e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>.  <a href="namespacenn_1_1audio.html#a4c1b5be7d8f4137107b0f09d7813a76e">More...</a><br /></td></tr>
<tr class="separator:a4c1b5be7d8f4137107b0f09d7813a76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4736cbcae273e050d01416a7625b0d8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structnn_1_1audio_1_1_wave_buffer.html">WaveBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ad4736cbcae273e050d01416a7625b0d8">GetReleasedWaveBuffer</a> (<a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pVoice) noexcept</td></tr>
<tr class="memdesc:ad4736cbcae273e050d01416a7625b0d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a> object that <a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a> has finished playing.  <a href="namespacenn_1_1audio.html#ad4736cbcae273e050d01416a7625b0d8">More...</a><br /></td></tr>
<tr class="separator:ad4736cbcae273e050d01416a7625b0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf59c1474e52088399a523222992453d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#abf59c1474e52088399a523222992453d">GetWaveBufferCount</a> (const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pVoice) noexcept</td></tr>
<tr class="memdesc:abf59c1474e52088399a523222992453d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of playable <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> objects that have been registered to <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>.  <a href="namespacenn_1_1audio.html#abf59c1474e52088399a523222992453d">More...</a><br /></td></tr>
<tr class="separator:abf59c1474e52088399a523222992453d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6913685f14bb0b350eabb2517eb11dd4"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a6913685f14bb0b350eabb2517eb11dd4">GetVoicePlayedSampleCount</a> (const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pVoice) noexcept</td></tr>
<tr class="memdesc:a6913685f14bb0b350eabb2517eb11dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of samples that have been played by the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object.  <a href="namespacenn_1_1audio.html#a6913685f14bb0b350eabb2517eb11dd4">More...</a><br /></td></tr>
<tr class="separator:a6913685f14bb0b350eabb2517eb11dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3bf0c7c1c51313ae9b05a0a3f3720f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1audio.html#a347cdc16fef8e35aad9d8d0cd2e79e38">NodeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ad3bf0c7c1c51313ae9b05a0a3f3720f7">GetVoiceNodeId</a> (const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pVoice) noexcept</td></tr>
<tr class="memdesc:ad3bf0c7c1c51313ae9b05a0a3f3720f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the ID of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> in the audio renderer.  <a href="namespacenn_1_1audio.html#ad3bf0c7c1c51313ae9b05a0a3f3720f7">More...</a><br /></td></tr>
<tr class="separator:ad3bf0c7c1c51313ae9b05a0a3f3720f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb313288140d4236cd42e19aca3f98e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#afb313288140d4236cd42e19aca3f98e6">FlushWaveBuffers</a> (<a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pVoice) noexcept</td></tr>
<tr class="memdesc:afb313288140d4236cd42e19aca3f98e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> objects registered to <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> as finished being played.  <a href="namespacenn_1_1audio.html#afb313288140d4236cd42e19aca3f98e6">More...</a><br /></td></tr>
<tr class="separator:afb313288140d4236cd42e19aca3f98e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab628a73a812066c3644a75cc2631dfd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1audio_1_1_voice_type_1_1_behavior_options.html">VoiceType::BehaviorOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ab628a73a812066c3644a75cc2631dfd9">GetVoiceBehaviorOptions</a> (const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *pVoice) noexcept</td></tr>
<tr class="memdesc:ab628a73a812066c3644a75cc2631dfd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a group of options indicating the behavior configured for a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure.  <a href="namespacenn_1_1audio.html#ab628a73a812066c3644a75cc2631dfd9">More...</a><br /></td></tr>
<tr class="separator:ab628a73a812066c3644a75cc2631dfd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a1e7645a5f10e70f9c2013551d13a6917"><td class="memItemLeft" align="right" valign="top"><a id="a1e7645a5f10e70f9c2013551d13a6917"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a1e7645a5f10e70f9c2013551d13a6917">AdpcmFrameSampleCount</a> = 14</td></tr>
<tr class="memdesc:a1e7645a5f10e70f9c2013551d13a6917"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of samples per APDCM frame. <br /></td></tr>
<tr class="separator:a1e7645a5f10e70f9c2013551d13a6917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c84b0e0d1ac06726869e3a5033577a"><td class="memItemLeft" align="right" valign="top"><a id="ac7c84b0e0d1ac06726869e3a5033577a"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ac7c84b0e0d1ac06726869e3a5033577a">AdpcmFrameSize</a> = 8</td></tr>
<tr class="memdesc:ac7c84b0e0d1ac06726869e3a5033577a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size per APDCM frame. <br /></td></tr>
<tr class="separator:ac7c84b0e0d1ac06726869e3a5033577a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865816f64ed09cc3741da83e1fec462e"><td class="memItemLeft" align="right" valign="top"><a id="a865816f64ed09cc3741da83e1fec462e"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a865816f64ed09cc3741da83e1fec462e">AdpcmHeaderSize</a> = 96</td></tr>
<tr class="memdesc:a865816f64ed09cc3741da83e1fec462e"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADPCM file header size. <br /></td></tr>
<tr class="separator:a865816f64ed09cc3741da83e1fec462e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256ee73aed3239d2e3f9455f0502cca1"><td class="memItemLeft" align="right" valign="top">static constexpr std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a256ee73aed3239d2e3f9455f0502cca1">AudioCoprocessorFrameTimeLimit</a> = 4000</td></tr>
<tr class="memdesc:a256ee73aed3239d2e3f9455f0502cca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The audio coprocessor is the maximum amount of time, in microseconds, available for processing of one audio frame.  <a href="namespacenn_1_1audio.html#a256ee73aed3239d2e3f9455f0502cca1">More...</a><br /></td></tr>
<tr class="separator:a256ee73aed3239d2e3f9455f0502cca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18679875f7f41c4912503c1738e36b9"><td class="memItemLeft" align="right" valign="top"><a id="ab18679875f7f41c4912503c1738e36b9"></a>
constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#ab18679875f7f41c4912503c1738e36b9">AudioDeviceOutputVolumeMax</a> = 128.0f</td></tr>
<tr class="memdesc:ab18679875f7f41c4912503c1738e36b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum volume that can be specified for <code><a class="el" href="namespacenn_1_1audio.html#a70fb7f5f687932689399a44c0da8d206" title="Sets the volume for the output destination device.">SetAudioDeviceOutputVolume()</a></code>. <br /></td></tr>
<tr class="separator:ab18679875f7f41c4912503c1738e36b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8856c8538ff8d63185bea7fdea3f67a9"><td class="memItemLeft" align="right" valign="top"><a id="a8856c8538ff8d63185bea7fdea3f67a9"></a>
constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a8856c8538ff8d63185bea7fdea3f67a9">AudioDeviceOutputVolumeMin</a> = 0.0f</td></tr>
<tr class="memdesc:a8856c8538ff8d63185bea7fdea3f67a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum volume that can be specified for <code><a class="el" href="namespacenn_1_1audio.html#a70fb7f5f687932689399a44c0da8d206" title="Sets the volume for the output destination device.">SetAudioDeviceOutputVolume()</a></code>. <br /></td></tr>
<tr class="separator:a8856c8538ff8d63185bea7fdea3f67a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2f3ee4c25eeae9f1421dae3de2d1be"><td class="memItemLeft" align="right" valign="top"><a id="a7f2f3ee4c25eeae9f1421dae3de2d1be"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a7f2f3ee4c25eeae9f1421dae3de2d1be">AudioInBufferCountMax</a> = 32</td></tr>
<tr class="memdesc:a7f2f3ee4c25eeae9f1421dae3de2d1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upper limit of <code><a class="el" href="structnn_1_1audio_1_1_audio_in_buffer.html" title="Structure representing an audio input buffer.">AudioInBuffer</a></code> objects able to be added to audio inputs. <br /></td></tr>
<tr class="separator:a7f2f3ee4c25eeae9f1421dae3de2d1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8caf5f89003744cef7c4d929bdf871"><td class="memItemLeft" align="right" valign="top"><a id="a6c8caf5f89003744cef7c4d929bdf871"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a6c8caf5f89003744cef7c4d929bdf871">AudioInCountMax</a> = 4</td></tr>
<tr class="memdesc:a6c8caf5f89003744cef7c4d929bdf871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum supported number of simultaneous audio inputs. <br /></td></tr>
<tr class="separator:a6c8caf5f89003744cef7c4d929bdf871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869fe9141337376f719073b69b0af3fc"><td class="memItemLeft" align="right" valign="top"><a id="a869fe9141337376f719073b69b0af3fc"></a>
constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a869fe9141337376f719073b69b0af3fc">AudioInDeviceGainMax</a> = 1.0f</td></tr>
<tr class="memdesc:a869fe9141337376f719073b69b0af3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum device gain that can be set for the audio input. <br /></td></tr>
<tr class="separator:a869fe9141337376f719073b69b0af3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165c37ecfd05f69bd73a8687998a301d"><td class="memItemLeft" align="right" valign="top"><a id="a165c37ecfd05f69bd73a8687998a301d"></a>
constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a165c37ecfd05f69bd73a8687998a301d">AudioInDeviceGainMin</a> = 0.0f</td></tr>
<tr class="memdesc:a165c37ecfd05f69bd73a8687998a301d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum device gain that can be set for the audio input. <br /></td></tr>
<tr class="separator:a165c37ecfd05f69bd73a8687998a301d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b8b06297db15c0731f7fea6d38eb47"><td class="memItemLeft" align="right" valign="top"><a id="af0b8b06297db15c0731f7fea6d38eb47"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#af0b8b06297db15c0731f7fea6d38eb47">AudioOutBufferCountMax</a> = 32</td></tr>
<tr class="memdesc:af0b8b06297db15c0731f7fea6d38eb47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upper limit of <code><a class="el" href="structnn_1_1audio_1_1_audio_out_buffer.html" title="Structure representing an audio output buffer.">AudioOutBuffer</a></code> objects able to be added to audio inputs. <br /></td></tr>
<tr class="separator:af0b8b06297db15c0731f7fea6d38eb47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e0a3dd35758eeb76621636255fc7d6"><td class="memItemLeft" align="right" valign="top"><a id="a66e0a3dd35758eeb76621636255fc7d6"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a66e0a3dd35758eeb76621636255fc7d6">AudioOutCountMax</a> = 2</td></tr>
<tr class="memdesc:a66e0a3dd35758eeb76621636255fc7d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum supported number of simultaneous audio outputs. <br /></td></tr>
<tr class="separator:a66e0a3dd35758eeb76621636255fc7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd85a57a7e996b7466bb9162ee7ff4f3"><td class="memItemLeft" align="right" valign="top"><a id="abd85a57a7e996b7466bb9162ee7ff4f3"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#abd85a57a7e996b7466bb9162ee7ff4f3">AudioRendererCountMax</a> = 2</td></tr>
<tr class="memdesc:abd85a57a7e996b7466bb9162ee7ff4f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of <code>AudioRenderer</code> instances that can be used at the same time. <br /></td></tr>
<tr class="separator:abd85a57a7e996b7466bb9162ee7ff4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61833f2e2cf0253e3054188e900315af"><td class="memItemLeft" align="right" valign="top"><a id="a61833f2e2cf0253e3054188e900315af"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a61833f2e2cf0253e3054188e900315af">BufferAlignSize</a> = 64</td></tr>
<tr class="memdesc:a61833f2e2cf0253e3054188e900315af"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alignment size for audio buffers. <br /></td></tr>
<tr class="separator:a61833f2e2cf0253e3054188e900315af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2519dd3580c74c1abf2d1ae868304f39"><td class="memItemLeft" align="right" valign="top"><a id="a2519dd3580c74c1abf2d1ae868304f39"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1audio.html#a2519dd3580c74c1abf2d1ae868304f39">MixBufferCountMax</a> = 24</td></tr>
<tr class="memdesc:a2519dd3580c74c1abf2d1ae868304f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of mix buffers that can be created for a single instance of <code>SubMix</code> or <code>FinalMix</code>. <br /></td></tr>
<tr class="separator:a2519dd3580c74c1abf2d1ae868304f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for the audio library. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a0a1874bce5c774a70d6e980790392ffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1874bce5c774a70d6e980790392ffa">&#9670;&nbsp;</a></span>AudioInState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1audio.html#a0a1874bce5c774a70d6e980790392ffa">nn::audio::AudioInState</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerated type representing the states of an audio input. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0a1874bce5c774a70d6e980790392ffaaebe92f50f4502d18a959161c8a39fe8b"></a>AudioInState_Started&#160;</td><td class="fielddoc"><p>Running. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0a1874bce5c774a70d6e980790392ffaa5e86cc78ca08b5202af4be54ce493395"></a>AudioInState_Stopped&#160;</td><td class="fielddoc"><p>Stopped. </p>
</td></tr>
</table>

</div>
</div>
<a id="ad6dfba2e7415ea48852b3f07216f2f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6dfba2e7415ea48852b3f07216f2f31">&#9670;&nbsp;</a></span>AudioOutState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1audio.html#ad6dfba2e7415ea48852b3f07216f2f31">nn::audio::AudioOutState</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerated type representing the states of an audio output. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad6dfba2e7415ea48852b3f07216f2f31a88576f200d2c91da21684d4ca31203ca"></a>AudioOutState_Started&#160;</td><td class="fielddoc"><p>Running. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad6dfba2e7415ea48852b3f07216f2f31ad092b713343a91f72ab142cbead28cd3"></a>AudioOutState_Stopped&#160;</td><td class="fielddoc"><p>Stopped. </p>
</td></tr>
</table>

</div>
</div>
<a id="a44c5ac6aa2921d6a52fb1c44471d4661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c5ac6aa2921d6a52fb1c44471d4661">&#9670;&nbsp;</a></span>AudioRendererState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1audio.html#a44c5ac6aa2921d6a52fb1c44471d4661">nn::audio::AudioRendererState</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An enumerated type that indicates the audio renderer state. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a44c5ac6aa2921d6a52fb1c44471d4661ab7f98e352ea8fe399028e2ac38c81dc6"></a>AudioRendererState_Started&#160;</td><td class="fielddoc"><p>Running. </p>
</td></tr>
<tr><td class="fieldname"><a id="a44c5ac6aa2921d6a52fb1c44471d4661ad5a62596d304f2e23af3451855303500"></a>AudioRendererState_Stopped&#160;</td><td class="fielddoc"><p>Stopped. </p>
</td></tr>
</table>

</div>
</div>
<a id="a46b67f0c9d1ae83ebaea784964373f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b67f0c9d1ae83ebaea784964373f56">&#9670;&nbsp;</a></span>AudioRendererRenderingDevice</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1audio.html#a46b67f0c9d1ae83ebaea784964373f56">nn::audio::AudioRendererRenderingDevice</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerated type that represents the device used by the audio renderer for rendering. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a46b67f0c9d1ae83ebaea784964373f56a550beeb25cdd6d8c2f0ef5062282dc62"></a>AudioRendererRenderingDevice_AudioCoprocessor&#160;</td><td class="fielddoc"><p>Audio coprocessor. </p>
</td></tr>
<tr><td class="fieldname"><a id="a46b67f0c9d1ae83ebaea784964373f56a46aff03ba5cf2fde86d7cc6bee1324e5"></a>AudioRendererRenderingDevice_Cpu&#160;</td><td class="fielddoc"><p>CPU. </p>
</td></tr>
</table>

</div>
</div>
<a id="abfe8ba78d8df1cffa01e726924471e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe8ba78d8df1cffa01e726924471e35">&#9670;&nbsp;</a></span>AudioRendererExecutionMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1audio.html#abfe8ba78d8df1cffa01e726924471e35">nn::audio::AudioRendererExecutionMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerated type that represents the rendering mode of the audio renderer. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abfe8ba78d8df1cffa01e726924471e35a794cd663cfcf7d70450fcf317f7ecf45"></a>AudioRendererExecutionMode_AutoExecution&#160;</td><td class="fielddoc"><p>Executes rendering automatically. </p>
</td></tr>
<tr><td class="fieldname"><a id="abfe8ba78d8df1cffa01e726924471e35a779f8ffa3797802237909514ec53ba9e"></a>AudioRendererExecutionMode_ManualExecution&#160;</td><td class="fielddoc"><p>Executes rendering manually. </p>
</td></tr>
</table>

</div>
</div>
<a id="ae5febdb32531c0ab471ab02f6a0c2892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5febdb32531c0ab471ab02f6a0c2892">&#9670;&nbsp;</a></span>ChannelMapping</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1audio.html#ae5febdb32531c0ab471ab02f6a0c2892">nn::audio::ChannelMapping</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the mapping between <code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> output channels and their indices. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae5febdb32531c0ab471ab02f6a0c2892a4ef16b2ffb413506d04e548a98a61ab9"></a>ChannelMapping_FrontLeft&#160;</td><td class="fielddoc"><p>Represents the front left channel. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae5febdb32531c0ab471ab02f6a0c2892a45f9acfb3cfbbe1a5c256bff1da701f2"></a>ChannelMapping_FrontRight&#160;</td><td class="fielddoc"><p>Represents the front right channel. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae5febdb32531c0ab471ab02f6a0c2892ac3b343b9fbe3d544196e3926b5fd4753"></a>ChannelMapping_FrontCenter&#160;</td><td class="fielddoc"><p>Represents the front center channel. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae5febdb32531c0ab471ab02f6a0c2892a56622a5f09d4db57bfc556f976824a3d"></a>ChannelMapping_LowFrequency&#160;</td><td class="fielddoc"><p>Represents the low-frequency channel. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae5febdb32531c0ab471ab02f6a0c2892a23c930f0e638ec3d72130e87e55f049d"></a>ChannelMapping_RearLeft&#160;</td><td class="fielddoc"><p>Represents the rear left channel. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae5febdb32531c0ab471ab02f6a0c2892acaa91a1abea9cb4377c2d7fa6b027507"></a>ChannelMapping_RearRight&#160;</td><td class="fielddoc"><p>Represents the rear right channel. </p>
</td></tr>
</table>

</div>
</div>
<a id="a101308636faebd9967ab60b4c662fa83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a101308636faebd9967ab60b4c662fa83">&#9670;&nbsp;</a></span>PerformanceEntryType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1audio.html#a101308636faebd9967ab60b4c662fa83">nn::audio::PerformanceEntryType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerated type representing the type of performance information. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a101308636faebd9967ab60b4c662fa83ac4ad5dfa3b972835a5c81fb3c2d6736f"></a>PerformanceEntryType_Unknown&#160;</td><td class="fielddoc"><p>Unknown performance information. </p>
</td></tr>
<tr><td class="fieldname"><a id="a101308636faebd9967ab60b4c662fa83ab52cc2884b2949cb44eee1d1f194aa39"></a>PerformanceEntryType_Voice&#160;</td><td class="fielddoc"><p><code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> performance information. </p>
</td></tr>
<tr><td class="fieldname"><a id="a101308636faebd9967ab60b4c662fa83a29ae09e6088ae9c9e0275dc114f3de6d"></a>PerformanceEntryType_SubMix&#160;</td><td class="fielddoc"><p><code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> performance information. </p>
</td></tr>
<tr><td class="fieldname"><a id="a101308636faebd9967ab60b4c662fa83a979fb5d1709225274fbc51761934404f"></a>PerformanceEntryType_FinalMix&#160;</td><td class="fielddoc"><p><code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> performance information. </p>
</td></tr>
<tr><td class="fieldname"><a id="a101308636faebd9967ab60b4c662fa83acf74b50354d447607276acf91cdbc42b"></a>PerformanceEntryType_Sink&#160;</td><td class="fielddoc"><p><code>Sink</code> performance information. </p>
</td></tr>
<tr><td class="fieldname"><a id="a101308636faebd9967ab60b4c662fa83ad116d72c3ec479d39ed2b79526a3dcf8"></a>PerformanceEntryType_Count&#160;</td><td class="fielddoc"><p>The number of types of performance information. </p>
</td></tr>
</table>

</div>
</div>
<a id="a43b8d931adba0b54dfc9570bfc26f51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b8d931adba0b54dfc9570bfc26f51d">&#9670;&nbsp;</a></span>PerformanceDetailType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1audio.html#a43b8d931adba0b54dfc9570bfc26f51d">nn::audio::PerformanceDetailType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerated type representing the type of detailed performance information. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a43b8d931adba0b54dfc9570bfc26f51da41b51d01258879e16cb79291f1f5c25b"></a>PerformanceDetailType_Unknown&#160;</td><td class="fielddoc"><p>Unknown performance information. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43b8d931adba0b54dfc9570bfc26f51dad70936cdc3ed6c9112415f364b1cf96c"></a>PerformanceDetailType_PcmInt16DataSource&#160;</td><td class="fielddoc"><p>Information about loading signed 16-bit integer PCM data. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43b8d931adba0b54dfc9570bfc26f51daa761b06268289c7c7e73a7c9a2c85bab"></a>PerformanceDetailType_AdpcmDataSource&#160;</td><td class="fielddoc"><p>Information about loading ADPCM data. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43b8d931adba0b54dfc9570bfc26f51da3b1c927ae1cac757f0d02794c4e73081"></a>PerformanceDetailType_Volume&#160;</td><td class="fielddoc"><p>Volume process information. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43b8d931adba0b54dfc9570bfc26f51da1450c5f24af032100ae58e605d45ebd0"></a>PerformanceDetailType_BiquadFilter&#160;</td><td class="fielddoc"><p>Information about biquad filters applied to <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> objects. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43b8d931adba0b54dfc9570bfc26f51da3e10584b5320dbcf065a9d208cc52cec"></a>PerformanceDetailType_Mix&#160;</td><td class="fielddoc"><p>Information about <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, and <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> mixes and <code>BufferMixer</code> effect mixes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43b8d931adba0b54dfc9570bfc26f51da90065cff31db0db16d5cbd59c7848c1e"></a>PerformanceDetailType_Delay&#160;</td><td class="fielddoc"><p>Information about delay effects. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43b8d931adba0b54dfc9570bfc26f51da75e9a1f2a2f12d9ba73bf2b82a2806d8"></a>PerformanceDetailType_Aux&#160;</td><td class="fielddoc"><p>Information about user-defined effects. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43b8d931adba0b54dfc9570bfc26f51da2736c4d9e4704741a16ecb70c149515c"></a>PerformanceDetailType_Reverb&#160;</td><td class="fielddoc"><p>Information about reverb effects. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43b8d931adba0b54dfc9570bfc26f51da8c225b9ba32f7cba9ea0240ff906439b"></a>PerformanceDetailType_I3dl2Reverb&#160;</td><td class="fielddoc"><p>Information about I3dl2 reverb effects. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43b8d931adba0b54dfc9570bfc26f51da1a846e9155fba75a29957f4bf03d28ed"></a>PerformanceDetailType_PcmFloatDataSource&#160;</td><td class="fielddoc"><p>Information about loading single-precision floating point PCM data. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43b8d931adba0b54dfc9570bfc26f51da8844f663f073a5284f1813d740b2b301"></a>PerformanceDetailType_LightLimiter&#160;</td><td class="fielddoc"><p>Information about LightLimiter effects. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43b8d931adba0b54dfc9570bfc26f51da1b0a410539baf7a83c3514725df62a0e"></a>PerformanceDetailType_Capture&#160;</td><td class="fielddoc"><p>Information about the Capture effects. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43b8d931adba0b54dfc9570bfc26f51dacc02884567f0eda4c663db6cdfb3da53"></a>PerformanceDetailType_Count&#160;</td><td class="fielddoc"><p>The number of types of detailed performance information. </p>
</td></tr>
</table>

</div>
</div>
<a id="a2edc363ab06840fc2eaf2acb551bf0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2edc363ab06840fc2eaf2acb551bf0c1">&#9670;&nbsp;</a></span>SampleFormat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1">nn::audio::SampleFormat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerates the sample formats. </p>
<p> <b>Details</b> <br  />
 This enumerated type represents the sample formats used by audio devices. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2edc363ab06840fc2eaf2acb551bf0c1a8728147897e0971a612c15b731457af5"></a>SampleFormat_Invalid&#160;</td><td class="fielddoc"><p>Invalid format. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2edc363ab06840fc2eaf2acb551bf0c1ae983446e68d537f5194a65c3a66d40c7"></a>SampleFormat_PcmInt8&#160;</td><td class="fielddoc"><p>8-bit signed integer PCM format. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2edc363ab06840fc2eaf2acb551bf0c1a28ddfdb7464233b0bd4fa406aff3e31a"></a>SampleFormat_PcmInt16&#160;</td><td class="fielddoc"><p>16-bit signed integer PCM format. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2edc363ab06840fc2eaf2acb551bf0c1ab2d559fd9c854347e69b0b9fbb04e4e1"></a>SampleFormat_PcmInt24&#160;</td><td class="fielddoc"><p>24-bit signed integer PCM format. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2edc363ab06840fc2eaf2acb551bf0c1acac06db0dedb23848423a26eb4e18482"></a>SampleFormat_PcmInt32&#160;</td><td class="fielddoc"><p>32-bit signed integer PCM format. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2edc363ab06840fc2eaf2acb551bf0c1a9f815cfc16990e6afc2f53500516e1d5"></a>SampleFormat_PcmFloat&#160;</td><td class="fielddoc"><p>Single-precision floating point PCM format. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2edc363ab06840fc2eaf2acb551bf0c1ab78e0cfd4dc7851b77c0b4ad3c355a72"></a>SampleFormat_Adpcm&#160;</td><td class="fielddoc"><p>ADPCM format. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab7e84ce4ddd07fd3e5fc45f2f7b82204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e84ce4ddd07fd3e5fc45f2f7b82204">&#9670;&nbsp;</a></span>ParseAdpcmHeader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::ParseAdpcmHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_adpcm_header_info.html">AdpcmHeaderInfo</a> *&#160;</td>
          <td class="paramname"><em>pOutInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Analyzes the ADPCM header information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutInfo</td><td>ADPCM header information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">header</td><td>Header data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the header data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutInfo</em></code> != <code>nullptr</code>.</li>
<li><code><em>header</em></code> != <code><em>nullptr</em></code>.</li>
<li><code><em>header</em></code> is aligned to <code>sizeof(int32_t)</code>.</li>
<li><code><em>size</em></code> &gt;= <code><a class="el" href="namespacenn_1_1audio.html#a865816f64ed09cc3741da83e1fec462e" title="ADPCM file header size.">nn::audio::AdpcmHeaderSize</a></code>. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a15">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a15">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a23">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a23">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a52">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a15">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a15">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a15">AudioSink/AudioSink.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a25">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aebcee810c22efb0dc1d65c3dc9197779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebcee810c22efb0dc1d65c3dc9197779">&#9670;&nbsp;</a></span>SetAudioInDeviceGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::audio::SetAudioInDeviceGain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *&#160;</td>
          <td class="paramname"><em>pAudioIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>gain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the device gain for the audio input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioIn</td><td>The pointer to the <code><a class="el" href="structnn_1_1audio_1_1_audio_in.html" title="Structure for managing an audio input.">AudioIn</a></code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gain</td><td>Device gain value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_not_supported.html">nn::audio::ResultNotSupported</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioIn</em></code> != <code>nullptr</code>.</li>
<li><code><em>gain</em></code> &gt;= <code><a class="el" href="namespacenn_1_1audio.html#a165c37ecfd05f69bd73a8687998a301d" title="The minimum device gain that can be set for the audio input.">nn::audio::AudioInDeviceGainMin</a></code> &amp;&amp; <code><em>gain</em></code> &lt;= <code><a class="el" href="namespacenn_1_1audio.html#a869fe9141337376f719073b69b0af3fc" title="The maximum device gain that can be set for the audio input.">nn::audio::AudioInDeviceGainMax</a></code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The device gain is set for the audio input.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sets the device gain for the audio input. The device gain is the gain value for hardware, such as microphones, that is associated with audio input. For example, you can use this function to set the gain of the microphone amplifier when using a microphone. The device gain settings may not be supported depending on the type of input device. If this occurs, this function will return <code><a class="el" href="classnn_1_1audio_1_1_result_not_supported.html" title="A class that represents error Result values (audio: This functionality is not supported....">nn::audio::ResultNotSupported</a></code> and fail. The mapping between the values specified by this function and the values actually applied to the hardware depends on the platform and device.</p>
<p>The processing for this function may require some time. Do not operate <code><em>pAudioIn</em></code> while this function is called. </p>

</div>
</div>
<a id="a60295a8c5476bca95083daaa9cbf098d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60295a8c5476bca95083daaa9cbf098d">&#9670;&nbsp;</a></span>GetAudioInDeviceGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetAudioInDeviceGain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *&#160;</td>
          <td class="paramname"><em>pAudioIn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the device gain of the audio buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioIn</td><td>The pointer to the <code><a class="el" href="structnn_1_1audio_1_1_audio_in.html" title="Structure for managing an audio input.">AudioIn</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the device gain. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioIn</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Returns <code><a class="el" href="namespacenn_1_1audio.html#a869fe9141337376f719073b69b0af3fc" title="The maximum device gain that can be set for the audio input.">nn::audio::AudioInDeviceGainMax</a></code> immediately after calling <code><a class="el" href="namespacenn_1_1audio.html#af6ca7def0d62477aa4f20f27fd9c70c6" title="Initializes the audio input specified in name and gets an accessor.">nn::audio::OpenAudioIn()</a></code> (in other words, if <code><a class="el" href="namespacenn_1_1audio.html#aebcee810c22efb0dc1d65c3dc9197779" title="Sets the device gain for the audio input.">nn::audio::SetAudioInDeviceGain()</a></code> is not called).</p>
<p>The device gain settings may not be supported depending on the type of input device. If this occurs, this function will always return <code><a class="el" href="namespacenn_1_1audio.html#a869fe9141337376f719073b69b0af3fc" title="The maximum device gain that can be set for the audio input.">nn::audio::AudioInDeviceGainMax</a></code>. </p>

</div>
</div>
<a id="a183262306a7103d73852c3842af67e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183262306a7103d73852c3842af67e8a">&#9670;&nbsp;</a></span>ListAudioIns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::ListAudioIns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_in_info.html">AudioInInfo</a> *&#160;</td>
          <td class="paramname"><em>outAudioIns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a list of available audio inputs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outAudioIns</td><td>Buffer to get audio input information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of audio inputs that can be stored in <code><em>outAudioIns</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of audio inputs retrieved and stored in <code><em>outAudioIns</em></code>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code>0</code> &lt;= <code><em>count</em></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>For a return value of <code><em>n</em></code>, data is written from <code><em>outAudioIns</em>[0]</code> to <code><em>outAudioIns</em>[<em>n</em>-1]</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 You can use the <code><em>name</em></code> from the obtained <code><a class="el" href="structnn_1_1audio_1_1_audio_in_info.html" title="Structure representing audio input information.">AudioInInfo</a></code> to open an audio input with the <code><a class="el" href="namespacenn_1_1audio.html#af6ca7def0d62477aa4f20f27fd9c70c6" title="Initializes the audio input specified in name and gets an accessor.">OpenAudioIn()</a></code> function. Note that the audio inputs that were available for use when the <code><a class="el" href="namespacenn_1_1audio.html#a183262306a7103d73852c3842af67e8a" title="Gets a list of available audio inputs.">ListAudioIns()</a></code> function was called might not be available when the <code><a class="el" href="namespacenn_1_1audio.html#af6ca7def0d62477aa4f20f27fd9c70c6" title="Initializes the audio input specified in name and gets an accessor.">OpenAudioIn()</a></code> function is called (because the connection might have been dropped). </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a63">AudioEchoback/AudioEchoback.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac7b8cea2511b7c0621fbaab18e2eb368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b8cea2511b7c0621fbaab18e2eb368">&#9670;&nbsp;</a></span>InitializeAudioInParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::InitializeAudioInParameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_in_parameter.html">AudioInParameter</a> *&#160;</td>
          <td class="paramname"><em>pOutParameter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the audio input parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutParameter</td><td>Parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutParameter</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pOutParameter</em>-&gt;sampleRate</code> == <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Initializes the audio input parameters specified in <code><em>pOutParameter</em></code>. The audio input parameters after initialization will be replaced by the initial values specified by the postconditions. Before using the audio input parameters, make sure to call this API and initialize them.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pOutParameter</em></code> while calling this function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a52">AudioEchoback/AudioEchoback.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac1bfdd6f316ddd864046026095f83fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1bfdd6f316ddd864046026095f83fcc">&#9670;&nbsp;</a></span>OpenDefaultAudioIn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::OpenDefaultAudioIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *&#160;</td>
          <td class="paramname"><em>pOutAudioIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_in_parameter.html">AudioInParameter</a> &amp;&#160;</td>
          <td class="paramname"><em>parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the default audio input and gets an accessor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutAudioIn</td><td>The pointer to the <code><a class="el" href="structnn_1_1audio_1_1_audio_in.html" title="Structure for managing an audio input.">AudioIn</a></code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter</td><td>Parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_operation_failed.html">nn::audio::ResultOperationFailed</a> must be handled.</li>
<li><a class="el" href="classnn_1_1audio_1_1_result_invalid_sample_rate.html">nn::audio::ResultInvalidSampleRate</a> must be handled.</li>
<li><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html">nn::audio::ResultOutOfResource</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutAudioIn</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the default audio input is available, the postconditions are as follows.<ul>
<li><code><em>pOutAudioIn</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a4d8b6791e28759f30e546c086d02fb61">nn::audio::GetAudioInState(pOutAudioIn)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#a0a1874bce5c774a70d6e980790392ffaa5e86cc78ca08b5202af4be54ce493395" title="Stopped.">nn::audio::AudioInState_Stopped</a></code>.</li>
</ul>
</li>
<li>If the specified audio input is not available, there are no postconditions.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The number of audio inputs that can be open at the same time is <code><a class="el" href="namespacenn_1_1audio.html#a6c8caf5f89003744cef7c4d929bdf871" title="Maximum supported number of simultaneous audio inputs.">nn::audio::AudioInCountMax</a></code>.</p>
<p>After the audio inputs are opened, you can get information from them or manipulate them with functions like <code><a class="el" href="namespacenn_1_1audio.html#a2c217d690202ef43230d4409852f3c1d" title="Registers an audio input buffer.">nn::audio::AppendAudioInBuffer()</a></code>. Audio recording does not begin until you call <code><a class="el" href="namespacenn_1_1audio.html#af72d3c3851733f838d4c7e72a26b307d" title="Starts recording a waveform from an audio input.">nn::audio::StartAudioIn()</a></code>.</p>
<p>When the <code><em>parameter</em></code> member variable is set to <code>0</code>, it takes the default value. The default is platform-dependent.</p>
<div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
 The NX platform can only use a <code><em>sampleRate</em></code> value of 48000. The default values are as follows. <ul>
<li>
<code><em>sampleRate</em></code> = <code>48000</code>. </li>
</ul>
The sample format for audio input will always become a 16 bit signed integer PCM format (<code><a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1a28ddfdb7464233b0bd4fa406aff3e31a" title="16-bit signed integer PCM format.">nn::audio::SampleFormat_PcmInt16</a></code>). The number of channels will always be two. However, the data for each channel is identical at this point.</div><div class="platform_section" data-platform="NX"></div><div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
 In the PC development environment, this default value takes the format specified in Microphone Properties. For more information, open the Control Panel and select Sound.</div><div class="platform_section" data-platform="Windows"></div><p> The processing for this function may require some time. </p>

</div>
</div>
<a id="af6ca7def0d62477aa4f20f27fd9c70c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6ca7def0d62477aa4f20f27fd9c70c6">&#9670;&nbsp;</a></span>OpenAudioIn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::OpenAudioIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *&#160;</td>
          <td class="paramname"><em>pOutAudioIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_in_parameter.html">AudioInParameter</a> &amp;&#160;</td>
          <td class="paramname"><em>parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the audio input specified in <code><em>name</em></code> and gets an accessor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutAudioIn</td><td>The pointer to the <code><a class="el" href="structnn_1_1audio_1_1_audio_in.html" title="Structure for managing an audio input.">AudioIn</a></code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the audio input. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter</td><td>Parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_not_found.html">nn::audio::ResultNotFound</a> must be handled.</li>
<li><a class="el" href="classnn_1_1audio_1_1_result_operation_failed.html">nn::audio::ResultOperationFailed</a> must be handled.</li>
<li><a class="el" href="classnn_1_1audio_1_1_result_invalid_sample_rate.html">nn::audio::ResultInvalidSampleRate</a> must be handled.</li>
<li><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html">nn::audio::ResultOutOfResource</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutAudioIn</em></code> != <code>nullptr</code>.</li>
<li><code><em>name</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the specified audio input is available, the postconditions are as follows.<ul>
<li><code><em>pOutAudioIn</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a4d8b6791e28759f30e546c086d02fb61">nn::audio::GetAudioInState(pOutAudioIn)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#a0a1874bce5c774a70d6e980790392ffaa5e86cc78ca08b5202af4be54ce493395" title="Stopped.">nn::audio::AudioInState_Stopped</a></code>.</li>
</ul>
</li>
<li>If the specified audio input is not available, there are no postconditions.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 You must use the <code><em>name</em></code> defined for each platform. You can get a list of the names of the audio inputs that are actually available with the <code><a class="el" href="namespacenn_1_1audio.html#a183262306a7103d73852c3842af67e8a" title="Gets a list of available audio inputs.">ListAudioIns()</a></code> function.</p>
<p>The number of audio inputs that can be open at the same time is <code><a class="el" href="namespacenn_1_1audio.html#a6c8caf5f89003744cef7c4d929bdf871" title="Maximum supported number of simultaneous audio inputs.">nn::audio::AudioInCountMax</a></code>.</p>
<p>After the audio inputs are opened, you can get information from them or manipulate them with functions like <code><a class="el" href="namespacenn_1_1audio.html#a2c217d690202ef43230d4409852f3c1d" title="Registers an audio input buffer.">nn::audio::AppendAudioInBuffer()</a></code>. Audio recording does not begin until you call <code><a class="el" href="namespacenn_1_1audio.html#af72d3c3851733f838d4c7e72a26b307d" title="Starts recording a waveform from an audio input.">nn::audio::StartAudioIn()</a></code>.</p>
<p>When the <code><em>parameter</em></code> member variable is set to <code>0</code>, it takes the default value. The default is platform-dependent.</p>
<div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
 The NX platform can only use a <code><em>sampleRate</em></code> value of 48000. The default values are as follows. <ul>
<li>
<code><em>sampleRate</em></code> = <code>48000</code>. </li>
</ul>
The sample format for audio input will always become a 16 bit signed integer PCM format (<code><a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1a28ddfdb7464233b0bd4fa406aff3e31a" title="16-bit signed integer PCM format.">nn::audio::SampleFormat_PcmInt16</a></code>). The number of channels will always be two. However, the data for each channel is identical at this point.</div><div class="platform_section" data-platform="NX"></div><div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
 In the PC development environment, this default value takes the format specified in Microphone Properties. For more information, open the Control Panel and select Sound.</div><div class="platform_section" data-platform="Windows"></div><p> The processing for this function may require some time. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a53">AudioEchoback/AudioEchoback.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aea9b579f0edf49dfce4ea62938317b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9b579f0edf49dfce4ea62938317b06">&#9670;&nbsp;</a></span>CloseAudioIn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::CloseAudioIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *&#160;</td>
          <td class="paramname"><em>pAudioIn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Closes the audio input and destroys the accessor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioIn</td><td>The pointer to the <code><a class="el" href="structnn_1_1audio_1_1_audio_in.html" title="Structure for managing an audio input.">AudioIn</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioIn</em></code> != <code>nullptr</code>.</li>
<li>The audio input managed by <code><em>pAudioIn</em></code> is opened.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a4d8b6791e28759f30e546c086d02fb61">nn::audio::GetAudioInState(pAudioIn)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#a0a1874bce5c774a70d6e980790392ffaa5e86cc78ca08b5202af4be54ce493395" title="Stopped.">nn::audio::AudioInState_Stopped</a></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pAudioIn</em></code> no longer manages an audio input. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a58">AudioEchoback/AudioEchoback.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af72d3c3851733f838d4c7e72a26b307d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af72d3c3851733f838d4c7e72a26b307d">&#9670;&nbsp;</a></span>StartAudioIn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::StartAudioIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *&#160;</td>
          <td class="paramname"><em>pAudioIn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts recording a waveform from an audio input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioIn</td><td>The pointer to the <code><a class="el" href="structnn_1_1audio_1_1_audio_in.html" title="Structure for managing an audio input.">AudioIn</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_operation_failed.html">nn::audio::ResultOperationFailed</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioIn</em></code> != <code>nullptr</code>.</li>
<li>The audio input managed by <code><em>pAudioIn</em></code> is opened.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a4d8b6791e28759f30e546c086d02fb61">nn::audio::GetAudioInState(pAudioIn)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#a0a1874bce5c774a70d6e980790392ffaa5e86cc78ca08b5202af4be54ce493395" title="Stopped.">nn::audio::AudioInState_Stopped</a></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a4d8b6791e28759f30e546c086d02fb61">nn::audio::GetAudioInState(pAudioIn)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#a0a1874bce5c774a70d6e980790392ffaaebe92f50f4502d18a959161c8a39fe8b" title="Running.">nn::audio::AudioInState_Started</a></code>. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a57">AudioEchoback/AudioEchoback.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a29049cc380b643521d79d058a62d9e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29049cc380b643521d79d058a62d9e93">&#9670;&nbsp;</a></span>StopAudioIn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::StopAudioIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *&#160;</td>
          <td class="paramname"><em>pAudioIn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stops recording a waveform from an audio input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioIn</td><td>The pointer to the <code><a class="el" href="structnn_1_1audio_1_1_audio_in.html" title="Structure for managing an audio input.">AudioIn</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioIn</em></code> != <code>nullptr</code>.</li>
<li>The audio input managed by <code><em>pAudioIn</em></code> is opened.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a4d8b6791e28759f30e546c086d02fb61">nn::audio::GetAudioInState(pAudioIn)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#a0a1874bce5c774a70d6e980790392ffaaebe92f50f4502d18a959161c8a39fe8b" title="Running.">nn::audio::AudioInState_Started</a></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a4d8b6791e28759f30e546c086d02fb61">nn::audio::GetAudioInState(pAudioIn)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#a0a1874bce5c774a70d6e980790392ffaa5e86cc78ca08b5202af4be54ce493395" title="Stopped.">nn::audio::AudioInState_Stopped</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 After this function is called, items that have not completed recording will no longer be accessed in the audio input buffer registered with <code><a class="el" href="namespacenn_1_1audio.html#a2c217d690202ef43230d4409852f3c1d" title="Registers an audio input buffer.">nn::audio::AppendAudioInBuffer()</a></code>, but the items are still registered and access will resume if <code><a class="el" href="namespacenn_1_1audio.html#af72d3c3851733f838d4c7e72a26b307d" title="Starts recording a waveform from an audio input.">nn::audio::StartAudioIn()</a></code> is called again. The registrations for all audio input buffers will be cleared if you call the <code><a class="el" href="namespacenn_1_1audio.html#aea9b579f0edf49dfce4ea62938317b06" title="Closes the audio input and destroys the accessor.">nn::audio::CloseAudioIn()</a></code> function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a60">AudioEchoback/AudioEchoback.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a4d8b6791e28759f30e546c086d02fb61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8b6791e28759f30e546c086d02fb61">&#9670;&nbsp;</a></span>GetAudioInState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1audio.html#a0a1874bce5c774a70d6e980790392ffa">AudioInState</a> nn::audio::GetAudioInState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *&#160;</td>
          <td class="paramname"><em>pAudioIn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the state of an audio input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioIn</td><td>The pointer to the <code><a class="el" href="structnn_1_1audio_1_1_audio_in.html" title="Structure for managing an audio input.">AudioIn</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the state. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioIn</em></code> != <code>nullptr</code>.</li>
<li>The audio input managed by <code><em>pAudioIn</em></code> is opened. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a407bc1b8e97beb48934527f57893dc16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a407bc1b8e97beb48934527f57893dc16">&#9670;&nbsp;</a></span>GetAudioInName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * nn::audio::GetAudioInName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *&#160;</td>
          <td class="paramname"><em>pAudioIn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the name of an audio input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioIn</td><td>The pointer to the <code><a class="el" href="structnn_1_1audio_1_1_audio_in.html" title="Structure for managing an audio input.">AudioIn</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the name buffer of the audio input. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioIn</em></code> != <code>nullptr</code>.</li>
<li>The audio input managed by <code><em>pAudioIn</em></code> is opened.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The content of the buffer returned by this function becomes undefined after the <code><a class="el" href="namespacenn_1_1audio.html#aea9b579f0edf49dfce4ea62938317b06" title="Closes the audio input and destroys the accessor.">nn::audio::CloseAudioIn()</a></code> function is called. </p>

</div>
</div>
<a id="aba56b33544577ad7773c54b6a44107bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba56b33544577ad7773c54b6a44107bb">&#9670;&nbsp;</a></span>GetAudioInSampleRate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetAudioInSampleRate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *&#160;</td>
          <td class="paramname"><em>pAudioIn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the sampling rate of an audio input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioIn</td><td>The pointer to the <code><a class="el" href="structnn_1_1audio_1_1_audio_in.html" title="Structure for managing an audio input.">AudioIn</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the sampling rate in Hertz. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioIn</em></code> != <code>nullptr</code>.</li>
<li>The audio input managed by <code><em>pAudioIn</em></code> is opened. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a28">AudioEchoback/AudioEchoback.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae09a8952d37766dd6ea7cec4e4d1618e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae09a8952d37766dd6ea7cec4e4d1618e">&#9670;&nbsp;</a></span>GetAudioInChannelCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetAudioInChannelCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *&#160;</td>
          <td class="paramname"><em>pAudioIn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of channels of an audio input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioIn</td><td>The pointer to the <code><a class="el" href="structnn_1_1audio_1_1_audio_in.html" title="Structure for managing an audio input.">AudioIn</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of channels. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioIn</em></code> != <code>nullptr</code>.</li>
<li>The audio input managed by <code><em>pAudioIn</em></code> is opened. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a26">AudioEchoback/AudioEchoback.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a7601ac0b7d81fb3f867c8f63165cdab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7601ac0b7d81fb3f867c8f63165cdab6">&#9670;&nbsp;</a></span>GetAudioInSampleFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1">SampleFormat</a> nn::audio::GetAudioInSampleFormat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *&#160;</td>
          <td class="paramname"><em>pAudioIn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the sample format of an audio input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioIn</td><td>The pointer to the <code><a class="el" href="structnn_1_1audio_1_1_audio_in.html" title="Structure for managing an audio input.">AudioIn</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the sample format. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioIn</em></code> != <code>nullptr</code>.</li>
<li>The audio input managed by <code><em>pAudioIn</em></code> is opened. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a30">AudioEchoback/AudioEchoback.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aa9ebc560c7c9cb913c9df8c40fceaeca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ebc560c7c9cb913c9df8c40fceaeca">&#9670;&nbsp;</a></span>SetAudioInBufferInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetAudioInBufferInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_in_buffer.html">AudioInBuffer</a> *&#160;</td>
          <td class="paramname"><em>pOutAudioInBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets information in an audio input buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutAudioInBuffer</td><td>Audio input buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Data buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of the data buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataSize</td><td>The amount of data, in bytes, to enter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioInBuffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>buffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>buffer</em></code> is aligned to <code><a class="el" href="structnn_1_1audio_1_1_audio_in_buffer.html#ad5177820e6426d99ad03ef559ee90a98" title="The alignment required for AudioInBuffer.">AudioInBuffer::AddressAlignment</a></code>.</li>
<li><code><em>bufferSize</em></code> &gt; <code>0</code> and is aligned to <code><a class="el" href="structnn_1_1audio_1_1_audio_in_buffer.html#aa1b0a735b34edd2d70e765552c80a252" title="The size granularity required for AudioInBuffer.">AudioInBuffer::SizeGranularity</a></code>.</li>
<li><code><em>dataSize</em></code> &gt; <code>0</code> and <code><em>dataSize</em></code> &lt;= <code><em>bufferSize</em></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The information in <code><em>buffer</em></code>, <code><em>bufferSize</em></code>, and <code><em>dataSize</em></code> is set in <code><em>pOutAudioInBuffer</em></code>. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a49">AudioEchoback/AudioEchoback.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae5fe3dfc47ec857f420675315f4f468d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5fe3dfc47ec857f420675315f4f468d">&#9670;&nbsp;</a></span>GetAudioInBufferDataPointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::audio::GetAudioInBufferDataPointer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_in_buffer.html">AudioInBuffer</a> *&#160;</td>
          <td class="paramname"><em>pAudioInBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a pointer to the data buffer in an audio input buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioInBuffer</td><td>Audio input buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the data buffer. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioInBuffer</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a70">AudioEchoback/AudioEchoback.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab25eff7af269116b7d12e27a57eac2e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab25eff7af269116b7d12e27a57eac2e7">&#9670;&nbsp;</a></span>GetAudioInBufferBufferSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::audio::GetAudioInBufferBufferSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_in_buffer.html">AudioInBuffer</a> *&#160;</td>
          <td class="paramname"><em>pAudioInBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the data buffer in an audio input buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioInBuffer</td><td>Audio input buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the data buffer size. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioInBuffer</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0e9e4271b6f713c2f0fee3e3dcdc1684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9e4271b6f713c2f0fee3e3dcdc1684">&#9670;&nbsp;</a></span>GetAudioInBufferDataSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::audio::GetAudioInBufferDataSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_in_buffer.html">AudioInBuffer</a> *&#160;</td>
          <td class="paramname"><em>pAudioInBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of data to input in the audio input buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioInBuffer</td><td>Audio input buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the size of the data to input. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioInBuffer</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a71">AudioEchoback/AudioEchoback.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a2c217d690202ef43230d4409852f3c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c217d690202ef43230d4409852f3c1d">&#9670;&nbsp;</a></span>AppendAudioInBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::AppendAudioInBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *&#160;</td>
          <td class="paramname"><em>pAudioIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_in_buffer.html">AudioInBuffer</a> *&#160;</td>
          <td class="paramname"><em>pAudioInBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers an audio input buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioIn</td><td>The pointer to the <code><a class="el" href="structnn_1_1audio_1_1_audio_in.html" title="Structure for managing an audio input.">AudioIn</a></code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioInBuffer</td><td>Audio input buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if registration is successful, or <code>false</code> otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioIn</em></code> != <code>nullptr</code>.</li>
<li><code><em>pAudioInBuffer</em></code> != <code>nullptr</code>.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ae5fe3dfc47ec857f420675315f4f468d">GetAudioInBufferDataPointer(pAudioInBuffer)</a></code> != <code>nullptr</code>.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ae5fe3dfc47ec857f420675315f4f468d">GetAudioInBufferDataPointer(pAudioInBuffer)</a></code> is aligned to <code><a class="el" href="structnn_1_1audio_1_1_audio_in_buffer.html#ad5177820e6426d99ad03ef559ee90a98" title="The alignment required for AudioInBuffer.">nn::audio::AudioInBuffer::AddressAlignment</a></code>.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ae347a7d7697820e65d72b0b325e10037">ContainsAudioInBuffer(pAudioInBuffer, pAudioIn)</a></code> == <code>false</code>.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a0e9e4271b6f713c2f0fee3e3dcdc1684">GetAudioInBufferDataSize(pAudioInBuffer)</a></code> % (<code><a class="el" href="namespacenn_1_1audio.html#ae09a8952d37766dd6ea7cec4e4d1618e">nn::audio::GetAudioInChannelCount(pAudioIn)</a></code> * <code><a class="el" href="namespacenn_1_1audio.html#a20de4a3eb5e5c4fba0f3b45e0b9e24c8">nn::audio::GetSampleByteSize</a></code> (<code><a class="el" href="namespacenn_1_1audio.html#a7601ac0b7d81fb3f867c8f63165cdab6">nn::audio::GetAudioInSampleFormat(pAudioIn)</a></code>)) == <code>0</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>Managed under <code><em>pAudioIn</em></code> until audio is recorded in <code><em>pAudioInBuffer</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The registered audio input buffers are managed in the audio inputs as FIFO lists and are consecutively recorded from the audio inputs in the order they were registered.</p>
<p>After registration, either check completion with the <code><a class="el" href="namespacenn_1_1audio.html#a4fe3341bdd916299f38a8eaa2c8de534" title="Gets an audio input buffer that has already been recorded to.">nn::audio::GetReleasedAudioInBuffer()</a></code> function or avoid manipulating the audio input buffers because they can still be manipulated by <code><em>pAudioIn</em></code> until the <code><a class="el" href="namespacenn_1_1audio.html#aea9b579f0edf49dfce4ea62938317b06" title="Closes the audio input and destroys the accessor.">nn::audio::CloseAudioIn()</a></code> function is called.</p>
<p>Up to <code><a class="el" href="namespacenn_1_1audio.html#a7f2f3ee4c25eeae9f1421dae3de2d1be" title="Upper limit of AudioInBuffer objects able to be added to audio inputs.">nn::audio::AudioInBufferCountMax</a></code> instances of <code><a class="el" href="structnn_1_1audio_1_1_audio_in_buffer.html" title="Structure representing an audio input buffer.">AudioInBuffer</a></code> can be added at the same time. To add more than this number of <code><a class="el" href="structnn_1_1audio_1_1_audio_in_buffer.html" title="Structure representing an audio input buffer.">AudioInBuffer</a></code> objects, you must wait for registered <code><a class="el" href="structnn_1_1audio_1_1_audio_in_buffer.html" title="Structure representing an audio input buffer.">AudioInBuffer</a></code> objects to finish recording, and then call the <code><a class="el" href="namespacenn_1_1audio.html#a9bf1c9d96a5761b3dca59f7f13155ad8" title="Gets an audio output buffer that has already been played.">nn::audio::GetReleasedAudioOutBuffer()</a></code> function.</p>
<p>The data stored in <code><a class="el" href="namespacenn_1_1audio.html#ae5fe3dfc47ec857f420675315f4f468d" title="Gets a pointer to the data buffer in an audio input buffer.">nn::audio::GetAudioInBufferDataPointer()</a></code> is in a format obtainable by <code><a class="el" href="namespacenn_1_1audio.html#a7601ac0b7d81fb3f867c8f63165cdab6" title="Gets the sample format of an audio input.">nn::audio::GetAudioInSampleFormat()</a></code> and is interleaved.</p>
<p>The following features are not provided.</p>
<ul>
<li>Deregistering audio input buffers before or during recording</li>
<li>Determining whether an audio input buffer is currently in recording</li>
<li>Treating an audio input buffer as a ring buffer when recording </li>
</ul>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a56">AudioEchoback/AudioEchoback.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a4fe3341bdd916299f38a8eaa2c8de534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe3341bdd916299f38a8eaa2c8de534">&#9670;&nbsp;</a></span>GetReleasedAudioInBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1audio_1_1_audio_in_buffer.html">AudioInBuffer</a> * nn::audio::GetReleasedAudioInBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *&#160;</td>
          <td class="paramname"><em>pAudioIn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an audio input buffer that has already been recorded to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioIn</td><td>The pointer to the <code><a class="el" href="structnn_1_1audio_1_1_audio_in.html" title="Structure for managing an audio input.">AudioIn</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an audio input buffer that has already been recorded to. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioIn</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 If multiple audio input buffers have finished recording, the one that finished recording first is returned. If no audio input buffers have finished recording, <code>nullptr</code> is returned. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a69">AudioEchoback/AudioEchoback.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae347a7d7697820e65d72b0b325e10037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae347a7d7697820e65d72b0b325e10037">&#9670;&nbsp;</a></span>ContainsAudioInBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::ContainsAudioInBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *&#160;</td>
          <td class="paramname"><em>pAudioIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_in_buffer.html">AudioInBuffer</a> *&#160;</td>
          <td class="paramname"><em>pAudioInBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether an <code><a class="el" href="structnn_1_1audio_1_1_audio_in_buffer.html" title="Structure representing an audio input buffer.">AudioInBuffer</a></code> object was appended to an <code><a class="el" href="structnn_1_1audio_1_1_audio_in.html" title="Structure for managing an audio input.">AudioIn</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioIn</td><td>The pointer to the <code><a class="el" href="structnn_1_1audio_1_1_audio_in.html" title="Structure for managing an audio input.">AudioIn</a></code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioInBuffer</td><td>Audio input buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if <code><a class="el" href="structnn_1_1audio_1_1_audio_in_buffer.html" title="Structure representing an audio input buffer.">AudioInBuffer</a></code> was appended to <code><a class="el" href="structnn_1_1audio_1_1_audio_in.html" title="Structure for managing an audio input.">AudioIn</a></code>, or <code>false</code> otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioIn</em></code> != <code>nullptr</code>.</li>
<li><code><em>pAudioInBuffer</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a21b6d6a72d7e98f3f25a6c43ae526849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b6d6a72d7e98f3f25a6c43ae526849">&#9670;&nbsp;</a></span>OpenDefaultAudioIn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::OpenDefaultAudioIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *&#160;</td>
          <td class="paramname"><em>pOutAudioIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1os_1_1_system_event.html">nn::os::SystemEvent</a> *&#160;</td>
          <td class="paramname"><em>pOutSystemEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_in_parameter.html">AudioInParameter</a> &amp;&#160;</td>
          <td class="paramname"><em>parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the default audio input, gets an accessor, and initializes a synchronization object for notification purposes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutAudioIn</td><td>The pointer to the <code><a class="el" href="structnn_1_1audio_1_1_audio_in.html" title="Structure for managing an audio input.">AudioIn</a></code> structure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSystemEvent</td><td><code>SystemEvent</code> for synchronization. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter</td><td>Parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_operation_failed.html">nn::audio::ResultOperationFailed</a> must be handled.</li>
<li><a class="el" href="classnn_1_1audio_1_1_result_invalid_sample_rate.html">nn::audio::ResultInvalidSampleRate</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutAudioIn</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutSystemEvent</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutSystemEvent</em></code> is not initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the default audio input is available, the postconditions are as follows.<ul>
<li><code><em>pOutAudioIn</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a4d8b6791e28759f30e546c086d02fb61">nn::audio::GetAudioInState(pOutAudioIn)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#a0a1874bce5c774a70d6e980790392ffaa5e86cc78ca08b5202af4be54ce493395" title="Stopped.">nn::audio::AudioInState_Stopped</a></code>.</li>
<li><code><em>*pOutSystemEvent</em></code> is initialized.</li>
</ul>
</li>
<li>If the specified audio input is not available, there are no postconditions.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code><em>pOutSystemEvent</em></code> becomes a signaled event when it is possible to release one or more of the audio output buffers appended by <code><a class="el" href="namespacenn_1_1audio.html#a2c217d690202ef43230d4409852f3c1d" title="Registers an audio input buffer.">nn::audio::AppendAudioInBuffer()</a></code>. After the event becomes signaled, make sure that you use the <code><a class="el" href="namespacenn_1_1audio.html#a4fe3341bdd916299f38a8eaa2c8de534" title="Gets an audio input buffer that has already been recorded to.">nn::audio::GetReleasedAudioInBuffer()</a></code> function to check whether the buffers have been released. <code><em>pOutSystemEvent</em></code> is initialized to <code><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a31f6133098296b3ddb7e14da3dc695cc" title="Automatically cleared event.">nn::os::EventClearMode_AutoClear</a></code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The <code><a class="el" href="classnn_1_1os_1_1_system_event.html" title="Class for handling system events.">nn::os::SystemEvent</a></code> class object specified for <code><em>pOutSystemEvent </em></code> must call <code><a class="el" href="namespacenn_1_1os.html#a3d924bc362ec80648323428be5182338" title="Destroys a SystemEventType object.">nn::os::DestroySystemEvent</a>( <em>pOutSystemEvent</em>-&gt;GetBase() )</code> after <code><a class="el" href="namespacenn_1_1audio.html#aea9b579f0edf49dfce4ea62938317b06" title="Closes the audio input and destroys the accessor.">nn::audio::CloseAudioIn()</a></code> has been called. Failure to make this call could cause the application to stop responding.</dd></dl>
<p>For more information, see <code><a class="el" href="namespacenn_1_1audio.html#ac1bfdd6f316ddd864046026095f83fcc" title="Initializes the default audio input and gets an accessor.">nn::audio::OpenDefaultAudioIn(AudioIn* pOutAudioIn, const AudioInParameter&amp; parameter)</a></code>. </p>

</div>
</div>
<a id="a9339dcb48c7d40b47f4852df0c9fe073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9339dcb48c7d40b47f4852df0c9fe073">&#9670;&nbsp;</a></span>OpenAudioIn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::OpenAudioIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *&#160;</td>
          <td class="paramname"><em>pOutAudioIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1os_1_1_system_event.html">nn::os::SystemEvent</a> *&#160;</td>
          <td class="paramname"><em>pOutSystemEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_in_parameter.html">AudioInParameter</a> &amp;&#160;</td>
          <td class="paramname"><em>parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the audio input specified by <code><em>name</em></code>, gets an accessor, and initializes a synchronization object for notification purposes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutAudioIn</td><td>The pointer to the <code><a class="el" href="structnn_1_1audio_1_1_audio_in.html" title="Structure for managing an audio input.">AudioIn</a></code> structure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSystemEvent</td><td><code>SystemEvent</code> for synchronization. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the audio input. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter</td><td>Parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_not_found.html">nn::audio::ResultNotFound</a> must be handled.</li>
<li><a class="el" href="classnn_1_1audio_1_1_result_operation_failed.html">nn::audio::ResultOperationFailed</a> must be handled.</li>
<li><a class="el" href="classnn_1_1audio_1_1_result_invalid_sample_rate.html">nn::audio::ResultInvalidSampleRate</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutAudioIn</em></code> != <code>nullptr</code>.</li>
<li><code><em>name</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutSystemEvent</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutSystemEvent</em></code> is not initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the specified audio input is available, the postconditions are as follows.<ul>
<li><code><em>pOutAudioIn</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a4d8b6791e28759f30e546c086d02fb61">nn::audio::GetAudioInState(pOutAudioIn)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#a0a1874bce5c774a70d6e980790392ffaa5e86cc78ca08b5202af4be54ce493395" title="Stopped.">nn::audio::AudioInState_Stopped</a></code>.</li>
<li><code><em>*pOutSystemEvent</em></code> is initialized.</li>
</ul>
</li>
<li>If the specified audio input is not available, there are no postconditions.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code><em>pOutSystemEvent</em></code> becomes a signaled event when it is possible to release one or more of the audio output buffers appended by <code><a class="el" href="namespacenn_1_1audio.html#a2c217d690202ef43230d4409852f3c1d" title="Registers an audio input buffer.">nn::audio::AppendAudioInBuffer()</a></code>. After the event becomes signaled, make sure that you use the <code><a class="el" href="namespacenn_1_1audio.html#a4fe3341bdd916299f38a8eaa2c8de534" title="Gets an audio input buffer that has already been recorded to.">nn::audio::GetReleasedAudioInBuffer()</a></code> function to check whether the buffers have been released. <code><em>pOutSystemEvent</em></code> is initialized to <code><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a31f6133098296b3ddb7e14da3dc695cc" title="Automatically cleared event.">nn::os::EventClearMode_AutoClear</a></code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The <code><a class="el" href="classnn_1_1os_1_1_system_event.html" title="Class for handling system events.">nn::os::SystemEvent</a></code> class object specified for <code><em>pOutSystemEvent </em></code> must call <code><a class="el" href="namespacenn_1_1os.html#a3d924bc362ec80648323428be5182338" title="Destroys a SystemEventType object.">nn::os::DestroySystemEvent</a>( <em>pOutSystemEvent</em>-&gt;GetBase() )</code> after <code><a class="el" href="namespacenn_1_1audio.html#aea9b579f0edf49dfce4ea62938317b06" title="Closes the audio input and destroys the accessor.">nn::audio::CloseAudioIn()</a></code> has been called. Failure to make this call could cause the application to stop responding.</dd></dl>
<p>For more information, see <code><a class="el" href="namespacenn_1_1audio.html#af6ca7def0d62477aa4f20f27fd9c70c6" title="Initializes the audio input specified in name and gets an accessor.">nn::audio::OpenAudioIn(AudioIn* pOutAudioIn, const char* name, const AudioInParameter&amp; parameter)</a></code>. </p>

</div>
</div>
<a id="ab496656f1bdaf174b87be48862e1096c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab496656f1bdaf174b87be48862e1096c">&#9670;&nbsp;</a></span>GetAudioInBufferCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetAudioInBufferCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *&#160;</td>
          <td class="paramname"><em>pAudioIn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of audio input buffers registered in <code><a class="el" href="structnn_1_1audio_1_1_audio_in.html" title="Structure for managing an audio input.">AudioIn</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioIn</td><td>The pointer to the <code><a class="el" href="structnn_1_1audio_1_1_audio_in.html" title="Structure for managing an audio input.">AudioIn</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of registered audio input buffers. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioIn</em></code> != <code>nullptr</code>.</li>
<li><code><em>pAudioIn</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the number of registered audio input buffers. This number includes the buffer that is currently being used for recording. </p>

</div>
</div>
<a id="af1d7d49b6b4b6337313bd32001814bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d7d49b6b4b6337313bd32001814bfa">&#9670;&nbsp;</a></span>FlushAudioInBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::FlushAudioInBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_in.html">AudioIn</a> *&#160;</td>
          <td class="paramname"><em>pAudioIn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Records to all audio input buffers registered to <code><a class="el" href="structnn_1_1audio_1_1_audio_in.html" title="Structure for managing an audio input.">AudioIn</a></code> that have not been recorded to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioIn</td><td>The pointer to the <code><a class="el" href="structnn_1_1audio_1_1_audio_in.html" title="Structure for managing an audio input.">AudioIn</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indicates whether all registered buffers have been recorded to. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioIn</em></code> != <code>nullptr</code>.</li>
<li><code><em>pAudioIn</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a4d8b6791e28759f30e546c086d02fb61">GetAudioInState(pAudioIn)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#a0a1874bce5c774a70d6e980790392ffaa5e86cc78ca08b5202af4be54ce493395" title="Stopped.">nn::audio::AudioInState_Stopped</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Records to all audio input buffers registered to <code><em>pAudioIn</em></code> that have not been recorded to. The buffers recorded to by this function have recordings of silence. When <code><em>pAudioIn</em></code> is active, audio input buffers that are recording audio are not transitioned to the recorded state by this function. When <code><em>pAudioIn</em></code> is stopped, all audio input buffers including those that are recording audio are transitioned to the recorded state by this function.</p>
<p>The function returns <code>true</code> if all audio input buffers registered to <code><em>pAudioIn</em></code> have been transitioned to the recorded state. Otherwise, the function returns <code>false</code>.</p>
<p>This function is not thread-safe. Do not operate <code><em>pAudioIn</em></code> while this function is called. </p>

</div>
</div>
<a id="a498ae2617b91a690e130c9dfc21483d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498ae2617b91a690e130c9dfc21483d6">&#9670;&nbsp;</a></span>ListAudioOuts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::ListAudioOuts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_out_info.html">AudioOutInfo</a> *&#160;</td>
          <td class="paramname"><em>outAudioOuts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a list of available audio outputs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outAudioOuts</td><td>Buffer to get audio output information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of audio outputs that can be stored in <code><em>outAudioOuts</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of audio outputs retrieved and stored in <code><em>outAudioOuts</em></code>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code>0</code> &lt;= <code><em>count</em></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>Information is written from <code><em>outAudioOuts</em>[0]</code> to <code><em>outAudioOuts</em>[n-1]</code> for return value <code><em>n</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The audio output obtained using this function is a virtual audio device that can be used in <code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code>. By using this virtual audio device, you can automatically set the output destination based on the operating environment of the program. Use <code><a class="el" href="namespacenn_1_1audio.html#acf3f2d72e87f3c1bcd8dafe7f1a5b301" title="Assigns an actual audio device to a virtual audio device.">nn::audio::SetAudioDeviceMapping()</a></code> to explicitly set the output destination in a PC environment.</p>
<p>You can open audio outputs with the <code><a class="el" href="namespacenn_1_1audio.html#aa6028627437e481cb9c0b3a3f49ac280" title="Initializes the audio output specified in name and gets an accessor.">OpenAudioOut()</a></code> function using the <code><em>name</em></code> from the obtained <code><a class="el" href="structnn_1_1audio_1_1_audio_out_info.html" title="Structure representing audio output information.">AudioOutInfo</a></code>. Note that audio outputs that were available for use when the <code><a class="el" href="namespacenn_1_1audio.html#a498ae2617b91a690e130c9dfc21483d6" title="Gets a list of available audio outputs.">ListAudioOuts()</a></code> function was called might not be available when the <code><a class="el" href="namespacenn_1_1audio.html#aa6028627437e481cb9c0b3a3f49ac280" title="Initializes the audio output specified in name and gets an accessor.">OpenAudioOut()</a></code> function is called (because the connection might have been lost). </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a45">AudioOut/AudioOut.cpp</a>, and <a class="el" href="_audio_out_with_resampler_2_audio_out_with_resampler_8cpp-example.html#a45">AudioOutWithResampler/AudioOutWithResampler.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a53eb3602be04d214fd6973fa4b63e637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53eb3602be04d214fd6973fa4b63e637">&#9670;&nbsp;</a></span>InitializeAudioOutParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::InitializeAudioOutParameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_out_parameter.html">AudioOutParameter</a> *&#160;</td>
          <td class="paramname"><em>pOutParameter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the audio output parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutParameter</td><td>Parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutParameter</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pOutParameter</em>-&gt;sampleRate</code> == <code>0</code>.</li>
<li><code><em>pOutParameter</em>-&gt;channelCount</code> == <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Initializes the audio output parameters specified in <code><em>pOutParameter</em></code>. The audio output parameters after initialization will be replaced by the initial values specified by the postconditions. Before using the audio output parameters, make sure that you call this function to initialize them.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pOutParameter</em></code> while calling this function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a47">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a81">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a47">AudioOut/AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_2_audio_out_with_resampler_8cpp-example.html#a47">AudioOutWithResampler/AudioOutWithResampler.cpp</a>, and <a class="el" href="_codec_aac_decoder_2_codec_aac_decoder_8cpp-example.html#a22">CodecAacDecoder/CodecAacDecoder.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a7d4ddedf1f043b725b4e3a5236a05417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4ddedf1f043b725b4e3a5236a05417">&#9670;&nbsp;</a></span>OpenDefaultAudioOut() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::OpenDefaultAudioOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *&#160;</td>
          <td class="paramname"><em>pOutAudioOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_out_parameter.html">AudioOutParameter</a> &amp;&#160;</td>
          <td class="paramname"><em>parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the default audio output and gets an accessor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutAudioOut</td><td>Pointer to an <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter</td><td>Parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_operation_failed.html">nn::audio::ResultOperationFailed</a> must be handled.</li>
<li><a class="el" href="classnn_1_1audio_1_1_result_invalid_sample_rate.html">nn::audio::ResultInvalidSampleRate</a> must be handled.</li>
<li><a class="el" href="classnn_1_1audio_1_1_result_invalid_channel_count.html">nn::audio::ResultInvalidChannelCount</a> must be handled.</li>
<li><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html">nn::audio::ResultOutOfResource</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioOut</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the default audio output is available, the postconditions are as follows.<ul>
<li><code><em>pAudioOut</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a378f44305f3e9d304073d5fd3bb5c8e5">GetAudioOutState(&lt;var&gt;pAudioOut&lt;/var&gt;)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#ad6dfba2e7415ea48852b3f07216f2f31ad092b713343a91f72ab142cbead28cd3" title="Stopped.">nn::audio::AudioOutState_Stopped</a></code>.</li>
</ul>
</li>
<li>If the specified audio output is not available, there are no postconditions.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The number of audio inputs that can be open at the same time is <code><a class="el" href="namespacenn_1_1audio.html#a66e0a3dd35758eeb76621636255fc7d6" title="Maximum supported number of simultaneous audio outputs.">nn::audio::AudioOutCountMax</a></code>.</p>
<p>After the audio inputs have been opened, you can get information from them and operate on them using functions like <code><a class="el" href="namespacenn_1_1audio.html#adf6ae7da062359e04d32ec1ec51b84a0" title="Registers an audio output buffer.">nn::audio::AppendAudioOutBuffer()</a></code>. Audio is not played back until you call <code><a class="el" href="namespacenn_1_1audio.html#aa522149d7a0b48763dd5c1eb32609505" title="Starts playing a waveform from an audio output.">nn::audio::StartAudioOut()</a></code>.</p>
<p>When the <code><em>parameter</em></code> member variable is set to <code>0</code>, it takes the default value. The default is platform-dependent.</p>
<div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
 The NX platform can only use a <code><em>sampleRate</em></code> value of <code>48000</code> and a <code><em>channelCount</em></code> value of either <code>2</code> or <code>6</code>. The default values are as follows. <ul>
<li>
<code><em>sampleRate</em></code> = <code>48000</code>. </li>
<li>
<code><em>channelCount</em></code> = <code>2</code>. </li>
</ul>
The sample format for audio output will always become a 16 bit signed integer PCM format (<code><a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1a28ddfdb7464233b0bd4fa406aff3e31a" title="16-bit signed integer PCM format.">nn::audio::SampleFormat_PcmInt16</a></code>).</div><div class="platform_section" data-platform="NX"></div><div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
 The default value in a PC development environment is the format you specify using the speaker properties. For more information, open the Control Panel and select Sound.</div><div class="platform_section" data-platform="Windows"></div><p> The processing for this function may require some time. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a49">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a82">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a54">AudioOut/AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_2_audio_out_with_resampler_8cpp-example.html#a54">AudioOutWithResampler/AudioOutWithResampler.cpp</a>, and <a class="el" href="_codec_aac_decoder_2_codec_aac_decoder_8cpp-example.html#a25">CodecAacDecoder/CodecAacDecoder.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab5db3e97ec537448f1d916cbb97453f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5db3e97ec537448f1d916cbb97453f3">&#9670;&nbsp;</a></span>OpenDefaultAudioOut() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::OpenDefaultAudioOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *&#160;</td>
          <td class="paramname"><em>pOutAudioOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1os_1_1_system_event.html">nn::os::SystemEvent</a> *&#160;</td>
          <td class="paramname"><em>pOutSystemEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_out_parameter.html">AudioOutParameter</a> &amp;&#160;</td>
          <td class="paramname"><em>parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the default audio output, gets an accessor, and initializes a synchronization object for notification purposes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutAudioOut</td><td>Pointer to an <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code> structure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSystemEvent</td><td><code>SystemEvent</code> for synchronization. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter</td><td>Parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_operation_failed.html">nn::audio::ResultOperationFailed</a> must be handled.</li>
<li><a class="el" href="classnn_1_1audio_1_1_result_invalid_sample_rate.html">nn::audio::ResultInvalidSampleRate</a> must be handled.</li>
<li><a class="el" href="classnn_1_1audio_1_1_result_invalid_channel_count.html">nn::audio::ResultInvalidChannelCount</a> must be handled.</li>
<li><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html">nn::audio::ResultOutOfResource</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioOut</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutSystemEvent</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutSystemEvent</em></code> is not initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the default audio output is available, the postconditions are as follows.<ul>
<li><code><em>pAudioOut</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a378f44305f3e9d304073d5fd3bb5c8e5">GetAudioOutState(&lt;var&gt;pAudioOut&lt;/var&gt;)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#ad6dfba2e7415ea48852b3f07216f2f31ad092b713343a91f72ab142cbead28cd3" title="Stopped.">nn::audio::AudioOutState_Stopped</a></code>.</li>
<li><code><em>*pOutSystemEvent</em></code> is initialized.</li>
</ul>
</li>
<li>If the specified audio output is not available, there are no postconditions.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code><em>pOutSystemEvent</em></code> becomes a signaled event when it is possible to release one or more of the audio output buffers appended by <code><a class="el" href="namespacenn_1_1audio.html#adf6ae7da062359e04d32ec1ec51b84a0" title="Registers an audio output buffer.">nn::audio::AppendAudioOutBuffer()</a></code>. After the event becomes signaled, make sure that you use the <code><a class="el" href="namespacenn_1_1audio.html#a9bf1c9d96a5761b3dca59f7f13155ad8" title="Gets an audio output buffer that has already been played.">nn::audio::GetReleasedAudioOutBuffer()</a></code> function to check whether the buffers have been released. <code><em>pOutSystemEvent</em></code> is initialized to <code><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a31f6133098296b3ddb7e14da3dc695cc" title="Automatically cleared event.">nn::os::EventClearMode_AutoClear</a></code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The <code><a class="el" href="classnn_1_1os_1_1_system_event.html" title="Class for handling system events.">nn::os::SystemEvent</a> </code> class object specified for <code><em>pOutSystemEvent</em></code> must call <code><a class="el" href="namespacenn_1_1os.html#a3d924bc362ec80648323428be5182338" title="Destroys a SystemEventType object.">nn::os::DestroySystemEvent</a>( <em>pOutSystemEvent</em>-&gt;GetBase() )</code> after <code><a class="el" href="namespacenn_1_1audio.html#abecd28c6321841cde54d0d16a8800da4" title="Closes the audio output and destroys the accessor.">nn::audio::CloseAudioOut()</a></code> has been called. Failure to make this call could cause the application to stop responding.</dd></dl>
<p>For more information, see <code><a class="el" href="namespacenn_1_1audio.html#a7d4ddedf1f043b725b4e3a5236a05417" title="Initializes the default audio output and gets an accessor.">nn::audio::OpenDefaultAudioOut(AudioOut* pOutAudioOut, const AudioOutParameter&amp; parameter)</a></code>. </p>

</div>
</div>
<a id="aa6028627437e481cb9c0b3a3f49ac280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6028627437e481cb9c0b3a3f49ac280">&#9670;&nbsp;</a></span>OpenAudioOut() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::OpenAudioOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *&#160;</td>
          <td class="paramname"><em>pOutAudioOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_out_parameter.html">AudioOutParameter</a> &amp;&#160;</td>
          <td class="paramname"><em>parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the audio output specified in <code><em>name</em></code> and gets an accessor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutAudioOut</td><td>Pointer to an <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of an audio output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter</td><td>Parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_not_found.html">nn::audio::ResultNotFound</a> must be handled.</li>
<li><a class="el" href="classnn_1_1audio_1_1_result_operation_failed.html">nn::audio::ResultOperationFailed</a> must be handled.</li>
<li><a class="el" href="classnn_1_1audio_1_1_result_invalid_sample_rate.html">nn::audio::ResultInvalidSampleRate</a> must be handled.</li>
<li><a class="el" href="classnn_1_1audio_1_1_result_invalid_channel_count.html">nn::audio::ResultInvalidChannelCount</a> must be handled.</li>
<li><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html">nn::audio::ResultOutOfResource</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioOut</em></code> != <code>nullptr</code>.</li>
<li><code><em>name</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the specified audio output is available, the postconditions are as follows.<ul>
<li><code><em>pAudioOut</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a378f44305f3e9d304073d5fd3bb5c8e5">nn::audio::GetAudioOutState(&lt;var&gt;pAudioOut&lt;/var&gt;)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#ad6dfba2e7415ea48852b3f07216f2f31ad092b713343a91f72ab142cbead28cd3" title="Stopped.">nn::audio::AudioOutState_Stopped</a></code>.</li>
</ul>
</li>
<li>If the specified audio output is not available, there are no postconditions.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 You must use the <code><em>name</em></code> defined for each platform. You can get a list of the names of the audio outputs that are actually available by using the <code><a class="el" href="namespacenn_1_1audio.html#a498ae2617b91a690e130c9dfc21483d6" title="Gets a list of available audio outputs.">ListAudioOuts()</a></code> function.</p>
<p>The number of audio outputs that can be open at the same time is <code><a class="el" href="namespacenn_1_1audio.html#a66e0a3dd35758eeb76621636255fc7d6" title="Maximum supported number of simultaneous audio outputs.">nn::audio::AudioOutCountMax</a></code>.</p>
<p>After the audio output have been opened, you can get information from them and operate on them using functions like <code><a class="el" href="namespacenn_1_1audio.html#adf6ae7da062359e04d32ec1ec51b84a0" title="Registers an audio output buffer.">nn::audio::AppendAudioOutBuffer()</a></code>. Audio is not played back until you call <code><a class="el" href="namespacenn_1_1audio.html#aa522149d7a0b48763dd5c1eb32609505" title="Starts playing a waveform from an audio output.">nn::audio::StartAudioOut()</a></code>.</p>
<p>When the <code><em>parameter</em></code> member variable is set to <code>0</code>, it takes the default value. The default is platform-dependent.</p>
<div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
 The NX platform can only use a <code><em>sampleRate</em></code> value of <code>48000</code> and a <code><em>channelCount</em></code> value of either <code>2</code> or <code>6</code>. The default values are as follows. <ul>
<li>
<code><em>sampleRate</em></code> = <code>48000</code>. </li>
<li>
<code><em>channelCount</em></code> = <code>2</code>. </li>
</ul>
The sample format for audio output will always become a 16 bit signed integer PCM format (<code><a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1a28ddfdb7464233b0bd4fa406aff3e31a" title="16-bit signed integer PCM format.">nn::audio::SampleFormat_PcmInt16</a></code>).</div><div class="platform_section" data-platform="NX"></div><div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
 The default value in a PC development environment is the format you specify using the speaker properties. For more information, open the Control Panel and select Sound.</div><div class="platform_section" data-platform="Windows"></div><p> The processing for this function may require some time. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a49">AudioOut/AudioOut.cpp</a>, and <a class="el" href="_audio_out_with_resampler_2_audio_out_with_resampler_8cpp-example.html#a49">AudioOutWithResampler/AudioOutWithResampler.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a23e936ca301d0c9363975a4bfc837ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e936ca301d0c9363975a4bfc837ea4">&#9670;&nbsp;</a></span>OpenAudioOut() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::OpenAudioOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *&#160;</td>
          <td class="paramname"><em>pOutAudioOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1os_1_1_system_event.html">nn::os::SystemEvent</a> *&#160;</td>
          <td class="paramname"><em>pOutSystemEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_out_parameter.html">AudioOutParameter</a> &amp;&#160;</td>
          <td class="paramname"><em>parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the audio output specified by <code><em>name</em></code>, gets an accessor, and initializes a synchronization object for notification purposes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutAudioOut</td><td>Pointer to an <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code> structure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSystemEvent</td><td><code>SystemEvent</code> for synchronization. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of an audio output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter</td><td>Parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_not_found.html">nn::audio::ResultNotFound</a> must be handled.</li>
<li><a class="el" href="classnn_1_1audio_1_1_result_operation_failed.html">nn::audio::ResultOperationFailed</a> must be handled.</li>
<li><a class="el" href="classnn_1_1audio_1_1_result_invalid_sample_rate.html">nn::audio::ResultInvalidSampleRate</a> must be handled.</li>
<li><a class="el" href="classnn_1_1audio_1_1_result_invalid_channel_count.html">nn::audio::ResultInvalidChannelCount</a> must be handled.</li>
<li><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html">nn::audio::ResultOutOfResource</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioOut</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutSystemEvent</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutSystemEvent</em></code> is not initialized.</li>
<li><code><em>name</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the specified audio output is available, the postconditions are as follows.<ul>
<li><code><em>pAudioOut</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a378f44305f3e9d304073d5fd3bb5c8e5">GetAudioOutState(&lt;var&gt;pAudioOut&lt;/var&gt;)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#ad6dfba2e7415ea48852b3f07216f2f31ad092b713343a91f72ab142cbead28cd3" title="Stopped.">nn::audio::AudioOutState_Stopped</a></code>.</li>
<li><code><em>*pOutSystemEvent</em></code> is initialized.</li>
</ul>
</li>
<li>If the specified audio output is not available, there are no postconditions.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code><em>pOutSystemEvent</em></code> becomes a signaled event when it is possible to release one or more of the audio output buffers appended by <code><a class="el" href="namespacenn_1_1audio.html#adf6ae7da062359e04d32ec1ec51b84a0" title="Registers an audio output buffer.">nn::audio::AppendAudioOutBuffer()</a></code>. After the event becomes signaled, make sure that you use the <code><a class="el" href="namespacenn_1_1audio.html#a9bf1c9d96a5761b3dca59f7f13155ad8" title="Gets an audio output buffer that has already been played.">nn::audio::GetReleasedAudioOutBuffer()</a></code> function to check whether the buffers have been released. <code><em>pOutSystemEvent</em></code> is initialized to <code><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a31f6133098296b3ddb7e14da3dc695cc" title="Automatically cleared event.">nn::os::EventClearMode_AutoClear</a></code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The <code><a class="el" href="classnn_1_1os_1_1_system_event.html" title="Class for handling system events.">nn::os::SystemEvent</a> </code> class object specified for <code><em>pOutSystemEvent</em></code> must call <code><a class="el" href="namespacenn_1_1os.html#a3d924bc362ec80648323428be5182338" title="Destroys a SystemEventType object.">nn::os::DestroySystemEvent</a>( <em>pOutSystemEvent</em>-&gt;GetBase() )</code> after <code><a class="el" href="namespacenn_1_1audio.html#abecd28c6321841cde54d0d16a8800da4" title="Closes the audio output and destroys the accessor.">nn::audio::CloseAudioOut()</a></code> has been called. Failure to make this call could cause the application to stop responding.</dd></dl>
<p>For more information, see <code><a class="el" href="namespacenn_1_1audio.html#aa6028627437e481cb9c0b3a3f49ac280" title="Initializes the audio output specified in name and gets an accessor.">nn::audio::OpenAudioOut(AudioOut* pOutAudioOut, const char* name, const AudioOutParameter&amp; parameter)</a></code>. </p>

</div>
</div>
<a id="abecd28c6321841cde54d0d16a8800da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abecd28c6321841cde54d0d16a8800da4">&#9670;&nbsp;</a></span>CloseAudioOut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::CloseAudioOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *&#160;</td>
          <td class="paramname"><em>pAudioOut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Closes the audio output and destroys the accessor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioOut</td><td>Pointer to an <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioOut</em></code> != <code>nullptr</code>.</li>
<li>The audio output managed by <code><em>pAudioOut</em></code> was opened.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a378f44305f3e9d304073d5fd3bb5c8e5">GetAudioOutState(&lt;var&gt;pAudioOut&lt;/var&gt;)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#ad6dfba2e7415ea48852b3f07216f2f31ad092b713343a91f72ab142cbead28cd3" title="Stopped.">nn::audio::AudioOutState_Stopped</a></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pAudioOut</em></code> no longer manages an audio output. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a160">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a110">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a50">AudioOut/AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_2_audio_out_with_resampler_8cpp-example.html#a50">AudioOutWithResampler/AudioOutWithResampler.cpp</a>, and <a class="el" href="_codec_aac_decoder_2_codec_aac_decoder_8cpp-example.html#a43">CodecAacDecoder/CodecAacDecoder.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aa522149d7a0b48763dd5c1eb32609505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa522149d7a0b48763dd5c1eb32609505">&#9670;&nbsp;</a></span>StartAudioOut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::StartAudioOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *&#160;</td>
          <td class="paramname"><em>pAudioOut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts playing a waveform from an audio output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioOut</td><td>Pointer to an <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_operation_failed.html">nn::audio::ResultOperationFailed</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioOut</em></code> != <code>nullptr</code>.</li>
<li>The audio output managed by <code><em>pAudioOut</em></code> was opened.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a378f44305f3e9d304073d5fd3bb5c8e5">GetAudioOutState(&lt;var&gt;pAudioOut&lt;/var&gt;)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#ad6dfba2e7415ea48852b3f07216f2f31ad092b713343a91f72ab142cbead28cd3" title="Stopped.">nn::audio::AudioOutState_Stopped</a></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a378f44305f3e9d304073d5fd3bb5c8e5">GetAudioOutState(&lt;var&gt;pAudioOut&lt;/var&gt;)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#ad6dfba2e7415ea48852b3f07216f2f31a88576f200d2c91da21684d4ca31203ca" title="Running.">nn::audio::AudioOutState_Started</a></code>. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a118">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a85">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a68">AudioOut/AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_2_audio_out_with_resampler_8cpp-example.html#a72">AudioOutWithResampler/AudioOutWithResampler.cpp</a>, and <a class="el" href="_codec_aac_decoder_2_codec_aac_decoder_8cpp-example.html#a35">CodecAacDecoder/CodecAacDecoder.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad908ac057d85fa7d4d4c4f047edc6c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad908ac057d85fa7d4d4c4f047edc6c4d">&#9670;&nbsp;</a></span>StopAudioOut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::StopAudioOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *&#160;</td>
          <td class="paramname"><em>pAudioOut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stops playing a waveform from an audio output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioOut</td><td>Pointer to an <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioOut</em></code> != <code>nullptr</code>.</li>
<li>The audio output managed by <code><em>pAudioOut</em></code> was opened.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a378f44305f3e9d304073d5fd3bb5c8e5">GetAudioOutState(&lt;var&gt;pAudioOut&lt;/var&gt;)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#ad6dfba2e7415ea48852b3f07216f2f31a88576f200d2c91da21684d4ca31203ca" title="Running.">nn::audio::AudioOutState_Started</a></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a378f44305f3e9d304073d5fd3bb5c8e5">GetAudioOutState(&lt;var&gt;pAudioOut&lt;/var&gt;)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#ad6dfba2e7415ea48852b3f07216f2f31ad092b713343a91f72ab142cbead28cd3" title="Stopped.">nn::audio::AudioOutState_Stopped</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Note that if you call this function, audio output buffers registered with the <code><a class="el" href="namespacenn_1_1audio.html#adf6ae7da062359e04d32ec1ec51b84a0" title="Registers an audio output buffer.">nn::audio::AppendAudioOutBuffer()</a></code> function will no longer be accessed if playback has not finished, but they remain registered and will be accessible if you call the <code><a class="el" href="namespacenn_1_1audio.html#aa522149d7a0b48763dd5c1eb32609505" title="Starts playing a waveform from an audio output.">nn::audio::StartAudioOut()</a></code> function again. The registrations for all audio output buffers will be cleared if you call the <code><a class="el" href="namespacenn_1_1audio.html#abecd28c6321841cde54d0d16a8800da4" title="Closes the audio output and destroys the accessor.">nn::audio::CloseAudioOut()</a></code> function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a159">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a109">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a92">AudioOut/AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_2_audio_out_with_resampler_8cpp-example.html#a91">AudioOutWithResampler/AudioOutWithResampler.cpp</a>, and <a class="el" href="_codec_aac_decoder_2_codec_aac_decoder_8cpp-example.html#a42">CodecAacDecoder/CodecAacDecoder.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a378f44305f3e9d304073d5fd3bb5c8e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a378f44305f3e9d304073d5fd3bb5c8e5">&#9670;&nbsp;</a></span>GetAudioOutState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1audio.html#ad6dfba2e7415ea48852b3f07216f2f31">AudioOutState</a> nn::audio::GetAudioOutState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *&#160;</td>
          <td class="paramname"><em>pAudioOut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the playback state of an audio output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioOut</td><td>Pointer to an <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the playback state. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioOut</em></code> != <code>nullptr</code>.</li>
<li>The audio output managed by <code><em>pAudioOut</em></code> was opened. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a55">AudioOut/AudioOut.cpp</a>, and <a class="el" href="_audio_out_with_resampler_2_audio_out_with_resampler_8cpp-example.html#a55">AudioOutWithResampler/AudioOutWithResampler.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a43c895123269f19a2d9cf15160ead920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c895123269f19a2d9cf15160ead920">&#9670;&nbsp;</a></span>GetAudioOutName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * nn::audio::GetAudioOutName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *&#160;</td>
          <td class="paramname"><em>pAudioOut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the name of an audio output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioOut</td><td>Pointer to an <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the name buffer of the audio output. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioOut</em></code> != <code>nullptr</code>.</li>
<li>The audio output managed by <code><em>pAudioOut</em></code> was opened.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The content of the buffer returned by this function becomes undefined after the <code><a class="el" href="namespacenn_1_1audio.html#abecd28c6321841cde54d0d16a8800da4" title="Closes the audio output and destroys the accessor.">nn::audio::CloseAudioOut()</a></code> function is called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a59">AudioOut/AudioOut.cpp</a>, and <a class="el" href="_audio_out_with_resampler_2_audio_out_with_resampler_8cpp-example.html#a57">AudioOutWithResampler/AudioOutWithResampler.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a48e4f07c8ed98d958ec79532f5962b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e4f07c8ed98d958ec79532f5962b96">&#9670;&nbsp;</a></span>GetAudioOutSampleRate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetAudioOutSampleRate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *&#160;</td>
          <td class="paramname"><em>pAudioOut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the sampling rate of an audio output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioOut</td><td>Pointer to an <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the sampling rate in Hertz. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioOut</em></code> != <code>nullptr</code>.</li>
<li>The audio output managed by <code><em>pAudioOut</em></code> was opened. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a50">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a29">AudioEchoback/AudioEchoback.cpp</a>, and <a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a57">AudioOut/AudioOut.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aae5ea724a3c41100cce1fbd7b031b64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae5ea724a3c41100cce1fbd7b031b64e">&#9670;&nbsp;</a></span>GetAudioOutChannelCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetAudioOutChannelCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *&#160;</td>
          <td class="paramname"><em>pAudioOut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of channels of an audio output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioOut</td><td>Pointer to an <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of channels. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioOut</em></code> != <code>nullptr</code>.</li>
<li>The audio output managed by <code><em>pAudioOut</em></code> was opened. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a27">AudioEchoback/AudioEchoback.cpp</a>, and <a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a56">AudioOut/AudioOut.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a36250ba99a54f2adbd9bd993f63fc4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36250ba99a54f2adbd9bd993f63fc4b4">&#9670;&nbsp;</a></span>GetAudioOutSampleFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1">SampleFormat</a> nn::audio::GetAudioOutSampleFormat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *&#160;</td>
          <td class="paramname"><em>pAudioOut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the sample format of an audio output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioOut</td><td>Pointer to an <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the sample format. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioOut</em></code> != <code>nullptr</code>.</li>
<li>The audio output managed by <code><em>pAudioOut</em></code> was opened. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a31">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a58">AudioOut/AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_2_audio_out_with_resampler_8cpp-example.html#a56">AudioOutWithResampler/AudioOutWithResampler.cpp</a>, and <a class="el" href="_codec_aac_decoder_2_codec_aac_decoder_8cpp-example.html#a26">CodecAacDecoder/CodecAacDecoder.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aa1ffe215f031b4b64e1cce6fe195b5c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ffe215f031b4b64e1cce6fe195b5c4">&#9670;&nbsp;</a></span>SetAudioOutBufferInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetAudioOutBufferInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_out_buffer.html">AudioOutBuffer</a> *&#160;</td>
          <td class="paramname"><em>pOutAudioOutBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets information in an audio output buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutAudioOutBuffer</td><td>Audio output buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Data buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of the data buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataSize</td><td>The amount of data, in bytes, to play. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioOutBuffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>buffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>buffer</em></code> is aligned to <code><a class="el" href="structnn_1_1audio_1_1_audio_out_buffer.html#aee83fe382b830ee95f7ecd7431ba9f73" title="The alignment required for AudioOutBuffer.">AudioOutBuffer::AddressAlignment</a></code>.</li>
<li><code><em>bufferSize</em></code> &gt; <code>0</code> and is aligned to <code><a class="el" href="structnn_1_1audio_1_1_audio_out_buffer.html#aa20555e970c0cf61d80914af41cf3a44" title="The size granularity required for AudioOutBuffer.">AudioOutBuffer::SizeGranularity</a></code>.</li>
<li><code><em>dataSize</em></code> &gt; <code>0</code> and <code><em>dataSize</em></code> &lt;= <code><em>bufferSize</em></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The information in <code><em>buffer</em></code>, <code><em>size</em></code>, <code><em>startOffset</em></code>, and <code><em>endOffset</em></code> is set in <code><em>pOutAudioOutBuffer</em></code>. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a116">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a84">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a66">AudioOut/AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_2_audio_out_with_resampler_8cpp-example.html#a70">AudioOutWithResampler/AudioOutWithResampler.cpp</a>, and <a class="el" href="_codec_aac_decoder_2_codec_aac_decoder_8cpp-example.html#a33">CodecAacDecoder/CodecAacDecoder.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac60d0ae60bafcbf7b3baae780efcce77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60d0ae60bafcbf7b3baae780efcce77">&#9670;&nbsp;</a></span>GetAudioOutBufferDataPointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::audio::GetAudioOutBufferDataPointer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_out_buffer.html">AudioOutBuffer</a> *&#160;</td>
          <td class="paramname"><em>pAudioOutBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a pointer to the data buffer in an audio output buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioOutBuffer</td><td>Audio output buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the data buffer. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioOutBuffer</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a153">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a39">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a90">AudioOut/AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_2_audio_out_with_resampler_8cpp-example.html#a90">AudioOutWithResampler/AudioOutWithResampler.cpp</a>, and <a class="el" href="_codec_aac_decoder_2_codec_aac_decoder_8cpp-example.html#a38">CodecAacDecoder/CodecAacDecoder.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a8f2b4696c057fbbc45b88c8020c0028a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2b4696c057fbbc45b88c8020c0028a">&#9670;&nbsp;</a></span>GetAudioOutBufferBufferSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::audio::GetAudioOutBufferBufferSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_out_buffer.html">AudioOutBuffer</a> *&#160;</td>
          <td class="paramname"><em>pAudioOutBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the data buffer in an audio output buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioOutBuffer</td><td>Audio output buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the data buffer size. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioOutBuffer</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a152">AudioCpuRenderer/AudioCpuRenderer.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a163daf352ea5548b5b9601db735f260c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163daf352ea5548b5b9601db735f260c">&#9670;&nbsp;</a></span>GetAudioOutBufferDataSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::audio::GetAudioOutBufferDataSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_out_buffer.html">AudioOutBuffer</a> *&#160;</td>
          <td class="paramname"><em>pAudioOutBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of data to play in the audio output buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioOutBuffer</td><td>Audio output buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the size of the data to play. [Byte] </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioOutBuffer</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a40">AudioEchoback/AudioEchoback.cpp</a>, and <a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a91">AudioOut/AudioOut.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="adf6ae7da062359e04d32ec1ec51b84a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf6ae7da062359e04d32ec1ec51b84a0">&#9670;&nbsp;</a></span>AppendAudioOutBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::AppendAudioOutBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *&#160;</td>
          <td class="paramname"><em>pAudioOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_out_buffer.html">AudioOutBuffer</a> *&#160;</td>
          <td class="paramname"><em>pAudioOutBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers an audio output buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioOut</td><td>Pointer to an <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioOutBuffer</td><td>Audio output buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if registration is successful, or <code>false</code> otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioOut</em></code> != <code>nullptr</code>.</li>
<li><code><em>pAudioOutBuffer</em></code> != <code>nullptr</code>.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ac60d0ae60bafcbf7b3baae780efcce77">GetAudioOutBufferDataPointer(pAudioOutBuffer)</a></code> != <code>nullptr</code>.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ac60d0ae60bafcbf7b3baae780efcce77">GetAudioOutBufferDataPointer(&lt;var&gt;pAudioOutBuffer&lt;/var&gt;)</a></code> is aligned to <code><a class="el" href="structnn_1_1audio_1_1_audio_out_buffer.html#aee83fe382b830ee95f7ecd7431ba9f73" title="The alignment required for AudioOutBuffer.">nn::audio::AudioOutBuffer::AddressAlignment</a></code>.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a1502f99ce36793793ff4f397e6b66dac">ContainsAudioOutBuffer(&lt;var&gt;pAudioOutBuffer&lt;/var&gt;, &lt;var&gt;pAudioOut&lt;/var&gt;)</a></code> == <code>false</code>.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a163daf352ea5548b5b9601db735f260c">GetAudioOutBufferDataSize(&lt;var&gt;pAudioOutBuffer&lt;/var&gt;)</a></code> % (<code><a class="el" href="namespacenn_1_1audio.html#aae5ea724a3c41100cce1fbd7b031b64e">nn::audio::GetAudioOutChannelCount(&lt;var&gt;pAudioOut&lt;/var&gt;)</a></code> * <code><a class="el" href="namespacenn_1_1audio.html#a20de4a3eb5e5c4fba0f3b45e0b9e24c8">nn::audio::GetSampleByteSize</a></code> (<code><a class="el" href="namespacenn_1_1audio.html#a36250ba99a54f2adbd9bd993f63fc4b4">nn::audio::GetAudioOutSampleFormat(&lt;var&gt;pAudioOut&lt;/var&gt;)</a></code>)) == <code>0</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>Managed under <code><em>pAudioOut</em></code> until the content of <code><em>pAudioOutBuffer</em></code> is played.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The buffers are managed in the audio inputs as FIFO lists and are consecutively recorded from the audio inputs in the order they were registered.</p>
<p>After registration, either check completion with the <code><a class="el" href="namespacenn_1_1audio.html#a9bf1c9d96a5761b3dca59f7f13155ad8" title="Gets an audio output buffer that has already been played.">nn::audio::GetReleasedAudioOutBuffer()</a></code> function or avoid manipulating the audio output buffers because they can still be manipulated by <code><em>pAudioOut</em></code> until the <code><a class="el" href="namespacenn_1_1audio.html#abecd28c6321841cde54d0d16a8800da4" title="Closes the audio output and destroys the accessor.">nn::audio::CloseAudioOut()</a></code> function is called.</p>
<p>Up to <code><a class="el" href="namespacenn_1_1audio.html#af0b8b06297db15c0731f7fea6d38eb47" title="Upper limit of AudioOutBuffer objects able to be added to audio inputs.">nn::audio::AudioOutBufferCountMax</a></code> instances of <code><a class="el" href="structnn_1_1audio_1_1_audio_out_buffer.html" title="Structure representing an audio output buffer.">AudioOutBuffer</a></code> can be added at the same time. If you want to add more than this number of <code><a class="el" href="structnn_1_1audio_1_1_audio_out_buffer.html" title="Structure representing an audio output buffer.">AudioOutBuffer</a></code> instances, you must first wait for the registered instances of <code><a class="el" href="structnn_1_1audio_1_1_audio_out_buffer.html" title="Structure representing an audio output buffer.">AudioOutBuffer</a></code> to finish playing and then call the <code><a class="el" href="namespacenn_1_1audio.html#a9bf1c9d96a5761b3dca59f7f13155ad8" title="Gets an audio output buffer that has already been played.">nn::audio::GetReleasedAudioOutBuffer()</a></code> function.</p>
<p>The data stored in <code><a class="el" href="namespacenn_1_1audio.html#ac60d0ae60bafcbf7b3baae780efcce77" title="Gets a pointer to the data buffer in an audio output buffer.">nn::audio::GetAudioOutBufferDataPointer()</a></code> must be in a format that the <code><a class="el" href="namespacenn_1_1audio.html#a36250ba99a54f2adbd9bd993f63fc4b4" title="Gets the sample format of an audio output.">nn::audio::GetAudioOutSampleFormat()</a></code> function can get, have a sample rate that the <code><a class="el" href="namespacenn_1_1audio.html#a48e4f07c8ed98d958ec79532f5962b96" title="Gets the sampling rate of an audio output.">nn::audio::GetAudioOutSampleRate()</a></code> function can get, and be interleaved (if there are two or more channels).</p>
<p>The following features are not provided.</p>
<ul>
<li>Deregistering audio output buffers before or during playback</li>
<li>Determining whether an audio output buffer is currently being played back</li>
<li>Looping playback of the audio output buffer </li>
</ul>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a117">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a41">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a67">AudioOut/AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_2_audio_out_with_resampler_8cpp-example.html#a71">AudioOutWithResampler/AudioOutWithResampler.cpp</a>, and <a class="el" href="_codec_aac_decoder_2_codec_aac_decoder_8cpp-example.html#a34">CodecAacDecoder/CodecAacDecoder.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a9bf1c9d96a5761b3dca59f7f13155ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf1c9d96a5761b3dca59f7f13155ad8">&#9670;&nbsp;</a></span>GetReleasedAudioOutBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1audio_1_1_audio_out_buffer.html">AudioOutBuffer</a> * nn::audio::GetReleasedAudioOutBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *&#160;</td>
          <td class="paramname"><em>pAudioOut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an audio output buffer that has already been played. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioOut</td><td>Pointer to an <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an audio output buffer that has already been played. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioOut</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 If multiple audio output buffers have finished playback, the one that finished playback first is returned. If no audio output buffers have finished playback, <code>nullptr</code> is returned. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a151">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a38">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a89">AudioOut/AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_2_audio_out_with_resampler_8cpp-example.html#a89">AudioOutWithResampler/AudioOutWithResampler.cpp</a>, and <a class="el" href="_codec_aac_decoder_2_codec_aac_decoder_8cpp-example.html#a37">CodecAacDecoder/CodecAacDecoder.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1502f99ce36793793ff4f397e6b66dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1502f99ce36793793ff4f397e6b66dac">&#9670;&nbsp;</a></span>ContainsAudioOutBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::ContainsAudioOutBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *&#160;</td>
          <td class="paramname"><em>pAudioOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_out_buffer.html">AudioOutBuffer</a> *&#160;</td>
          <td class="paramname"><em>pAudioOutBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether an <code><a class="el" href="structnn_1_1audio_1_1_audio_out_buffer.html" title="Structure representing an audio output buffer.">AudioOutBuffer</a></code> object was appended to an <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioOut</td><td>Pointer to an <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioOutBuffer</td><td>Audio input buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if <code><a class="el" href="structnn_1_1audio_1_1_audio_out_buffer.html" title="Structure representing an audio output buffer.">AudioOutBuffer</a></code> was appended to <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code>, or returns <code>false</code> otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioOut</em></code> != <code>nullptr</code>.</li>
<li><code><em>pAudioOutBuffer</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a79170ba08007d9d5692a07ad5a0af18b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79170ba08007d9d5692a07ad5a0af18b">&#9670;&nbsp;</a></span>GetAudioOutBufferCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetAudioOutBufferCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *&#160;</td>
          <td class="paramname"><em>pAudioOut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of audio output buffers registered to <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioOut</td><td>Pointer to an <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of registered audio output buffers. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioOut</em></code> != <code>nullptr</code>.</li>
<li><code><em>pAudioOut</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the number of registered audio output buffers. This number includes the buffer that is currently being used for playback. </p>

</div>
</div>
<a id="ab131bfe56aeb5b9fbb7cb45495226837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab131bfe56aeb5b9fbb7cb45495226837">&#9670;&nbsp;</a></span>GetAudioOutPlayedSampleCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t nn::audio::GetAudioOutPlayedSampleCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_out.html">nn::audio::AudioOut</a> *&#160;</td>
          <td class="paramname"><em>pAudioOut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of samples of the data played back by <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioOut</td><td>Pointer to an <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of samples played back by <code><em>pAudioOut</em></code> after <code><a class="el" href="namespacenn_1_1audio.html#aa522149d7a0b48763dd5c1eb32609505" title="Starts playing a waveform from an audio output.">StartAudioOut()</a></code> is called. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioOut</em></code> != <code>nullptr</code>.</li>
<li><code><em>pAudioOut</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The sample count information is only updated at set intervals. The time interval varies depending on the platform.</p>
<div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
 In the Windows environment, the sample count information is updated every 10 milliseconds.</div><div class="platform_section" data-platform="Windows"></div><div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
 In the NX environment, the sample count information is updated every 5 milliseconds.</div><div class="platform_section" data-platform="NX"></div> 
</div>
</div>
<a id="a177e0933097148ce854aa90a65e503ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a177e0933097148ce854aa90a65e503ae">&#9670;&nbsp;</a></span>FlushAudioOutBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::FlushAudioOutBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *&#160;</td>
          <td class="paramname"><em>pAudioOut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all of the unplayed audio output buffers registered in <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code> to played. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioOut</td><td>Pointer to an <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A flag indicating whether all registered buffers have been set to played. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioOut</em></code> != <code>nullptr</code>.</li>
<li><code><em>pAudioOut</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a378f44305f3e9d304073d5fd3bb5c8e5">GetAudioOutState(&lt;var&gt;pAudioOut&lt;/var&gt;)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#ad6dfba2e7415ea48852b3f07216f2f31ad092b713343a91f72ab142cbead28cd3" title="Stopped.">nn::audio::AudioOutState_Stopped</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform an operations on <code><em>pAudioOut</em></code> while calling this function. </p>

</div>
</div>
<a id="ac9768fb1e31dd0bcf4c28a4e7dae42da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9768fb1e31dd0bcf4c28a4e7dae42da">&#9670;&nbsp;</a></span>SetAudioOutVolume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::SetAudioOutVolume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *&#160;</td>
          <td class="paramname"><em>pAudioOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>volume</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the volume for <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioOut</td><td>Pointer to an <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">volume</td><td>Volume value to be configured. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><a class="el" href="structnn_1_1audio_1_1_audio_out.html#af873ccb3c05b3c2f50e950d6b134c24f" title="Gets the minimum volume that can be set.">nn::audio::AudioOut::GetVolumeMin()</a></code> &lt;= <code><em>volume</em></code> &lt;= <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html#a5b9b48db0f937da85963f9c5d1bcf07f" title="Gets the maximum volume that can be set.">nn::audio::AudioOut::GetVolumeMax()</a></code>.</li>
<li><code><em>pAudioOut</em></code> != <code>nullptr</code>.</li>
<li><code><em>pAudioOut</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>volume</em></code> == <code><a class="el" href="namespacenn_1_1audio.html#aaf3d2c5ebd83da79959162eca6272510" title="Gets the volume of the AudioOut object.">nn::audio::GetAudioOutVolume()</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sets the volume for <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code>. The default is <code>1.0f</code>. The volume that is ultimately applied to the waveforms output from <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code> is the product of the volume set by this function for each <code><code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code></code> multiplied by the device volume. For more information about the device volume, see <code><a class="el" href="namespacenn_1_1audio.html#a70fb7f5f687932689399a44c0da8d206" title="Sets the volume for the output destination device.">nn::audio::SetAudioDeviceOutputVolume()</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>Audio cutoff may occur depending on the set volume value. If audio cutoff occurs, verify that the volume is within appropriate values. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a87">AudioOut/AudioOut.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aaf3d2c5ebd83da79959162eca6272510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf3d2c5ebd83da79959162eca6272510">&#9670;&nbsp;</a></span>GetAudioOutVolume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetAudioOutVolume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_out.html">AudioOut</a> *&#160;</td>
          <td class="paramname"><em>pAudioOut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the volume of the <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAudioOut</td><td>Pointer to an <code><a class="el" href="structnn_1_1audio_1_1_audio_out.html" title="Structure for managing an audio output.">AudioOut</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAudioOut</em></code> != <code>nullptr</code>.</li>
<li><code><em>pAudioOut</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Volume value. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a84">AudioOut/AudioOut.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a9eaff763648679c45d3360d717e28618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eaff763648679c45d3360d717e28618">&#9670;&nbsp;</a></span>InitializeAudioRendererParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::InitializeAudioRendererParameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html">AudioRendererParameter</a> *&#160;</td>
          <td class="paramname"><em>pOutParameter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the audio renderer parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutParameter</td><td>Parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutParameter</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pOutParameter</em>-&gt;sampleRate</code> == <code>48000</code>.</li>
<li><code><em>pOutParameter</em>-&gt;sampleCount</code> == <code>240</code>.</li>
<li><code><em>pOutParameter</em>-&gt;mixBufferCount</code> == <code>1</code>.</li>
<li><code><em>pOutParameter</em>-&gt;subMixCount</code> == <code>0</code>.</li>
<li><code><em>pOutParameter</em>-&gt;voiceCount</code> == <code>1</code>.</li>
<li><code><em>pOutParameter</em>-&gt;sinkCount</code> == <code>1</code>.</li>
<li><code><em>pOutParameter</em>-&gt;effectCount</code> == <code>0</code>.</li>
<li><code><em>pOutParameter</em>-&gt;performanceFrameCount</code> == <code>0</code>.</li>
<li><code><em>pOutParameter</em>-&gt;isVoiceDropEnabled</code> == <code>false</code>.</li>
<li><code><em>pOutParameter</em>-&gt;executionMode</code> == <code><a class="el" href="namespacenn_1_1audio.html#abfe8ba78d8df1cffa01e726924471e35a794cd663cfcf7d70450fcf317f7ecf45" title="Executes rendering automatically.">nn::audio::AudioRendererExecutionMode_AutoExecution</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Initializes the audio renderer parameters specified by <code><em>pOutParameter</em></code>. The audio renderer parameters after initialization will be replaced by the initial values specified by the postconditions. Before using the audio renderer parameters, make sure to call this API and initialize them.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pOutParameter</em></code> while calling this function.</p>
<div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
 The following postconditions are added for the NX platform. <ul>
<li>
<code><em>pOutParameter</em>-&gt;renderingDevice</code> == <code><a class="el" href="namespacenn_1_1audio.html#a46b67f0c9d1ae83ebaea784964373f56a550beeb25cdd6d8c2f0ef5062282dc62" title="Audio coprocessor.">nn::audio::AudioRendererRenderingDevice_AudioCoprocessor</a></code>. </li>
</ul>
</div><div class="platform_section" data-platform="NX"></div><div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
 The following postconditions are added for the Windows platform. <b>-</b> <code><em>pOutParameter</em>-&gt;renderingDevice</code> == <code><a class="el" href="namespacenn_1_1audio.html#a46b67f0c9d1ae83ebaea784964373f56a46aff03ba5cf2fde86d7cc6bee1324e5" title="CPU.">nn::audio::AudioRendererRenderingDevice_Cpu</a></code>.</div><div class="platform_section" data-platform="Windows"></div> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a53">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a57">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a108">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a76">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a68">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a9">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a43">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a44">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a54">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a64">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a32">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a69">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#a23">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#a29">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a46">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a42518470ed50c8dd6b1395f3c55efeae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42518470ed50c8dd6b1395f3c55efeae">&#9670;&nbsp;</a></span>IsValidAudioRendererParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::IsValidAudioRendererParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html">AudioRendererParameter</a> &amp;&#160;</td>
          <td class="paramname"><em>parameter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the audio renderer parameter is valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter</td><td>Parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if <code><em>parameter</em></code> is allowed, or <code>false</code> otherwise.</dd></dl>
<p> <b>Details</b> <br  />
 Specifically, this function checks the following. Depending on the platform, additional conditions might be checked.</p>
<ul>
<li>
<code><em>parameter</em>.sampleRate</code> == <code>32000</code> || <code><em>parameter</em>.sampleRate</code> == <code>48000</code>. </li>
<li>
<code><em>parameter</em>.mixBufferCount</code> &gt; <code>0</code> &amp;&amp; <code><em>parameter</em>.mixBufferCount</code> &lt;= <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html#a9b2df199e934e0a68db30a010f7b7e12" title="The maximum number of mixed buffers that can be used by the audio renderer.">nn::audio::AudioRendererParameter::MixBufferCountMax</a></code>. </li>
<li>
<code><em>parameter</em>.voiceCount</code> &gt; <code>0</code> &amp;&amp; <code><em>parameter</em>.voiceCount</code> &lt;= <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html#a30bd39a7f022ca7848742747f63b06c5" title="The maximum number of voice units available to the audio renderer.">nn::audio::AudioRendererParameter::VoiceCountMax</a></code>. </li>
<li>
<code><em>parameter</em>.subMixCount</code> &gt;= <code>0</code> &amp;&amp; <code><em>parameter</em>.subMixCount</code> &lt;= <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html#a9df39f8e7faba9604f7435d2b876bc01" title="The maximum number of SubMixType instances that can be used by the audio renderer.">nn::audio::AudioRendererParameter::SubMixCountMax</a></code>. </li>
<li>
<code><em>parameter</em>.sinkCount</code> &gt; <code>0</code> &amp;&amp; <code><em>parameter</em>.sinkCount</code> &lt;= <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html#abee1385169235d9f93e2d704ad91e546" title="The maximum number of SinkType instances that can be used by the audio renderer.">nn::audio::AudioRendererParameter::SinkCountMax</a></code>. </li>
<li>
<code><em>parameter</em>.effectCount</code> &gt;= <code>0</code> &amp;&amp; <code><em>parameter</em>.effectCount</code> &lt;= <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html#afd9fa7d02c007f0f3273fa6503aa1484" title="The maximum number of EffectType instances that can be used by the audio renderer.">nn::audio::AudioRendererParameter::EffectCountMax</a></code>. </li>
<li>
<code><em>parameter</em>.sampleCount</code> == <code><em>parameter</em>.sampleRate</code> * <code>0.005</code>. </li>
</ul>
<div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
 The following additional conditions are checked for the NX platform. <ul>
<li>
(<code><em>parameter</em>.renderingDevice</code> == <code><a class="el" href="namespacenn_1_1audio.html#a46b67f0c9d1ae83ebaea784964373f56a550beeb25cdd6d8c2f0ef5062282dc62" title="Audio coprocessor.">nn::audio::AudioRendererRenderingDevice_AudioCoprocessor</a></code> &amp;&amp; <code><em>parameter</em>.renderingExecutionMode</code> == <code><a class="el" href="namespacenn_1_1audio.html#abfe8ba78d8df1cffa01e726924471e35a794cd663cfcf7d70450fcf317f7ecf45" title="Executes rendering automatically.">nn::audio::AudioRendererExecutionMode_AutoExecution</a></code>) || (<code><em>parameter</em>.renderingDevice</code> == <code><a class="el" href="namespacenn_1_1audio.html#a46b67f0c9d1ae83ebaea784964373f56a46aff03ba5cf2fde86d7cc6bee1324e5" title="CPU.">nn::audio::AudioRendererRenderingDevice_Cpu</a></code> &amp;&amp; <code><em>parameter</em>.renderingExecutionMode</code> == <code><a class="el" href="namespacenn_1_1audio.html#abfe8ba78d8df1cffa01e726924471e35a779f8ffa3797802237909514ec53ba9e" title="Executes rendering manually.">nn::audio::AudioRendererExecutionMode_ManualExecution</a></code>)  </li>
</ul>
</div><div class="platform_section" data-platform="NX"></div><div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
 The following additional conditions are checked for the Windows platform. <code><em>parameter</em>.renderingDevice</code> == <code><a class="el" href="namespacenn_1_1audio.html#a46b67f0c9d1ae83ebaea784964373f56a46aff03ba5cf2fde86d7cc6bee1324e5" title="CPU.">nn::audio::AudioRendererRenderingDevice_Cpu</a></code>.</div><div class="platform_section" data-platform="Windows"></div><p> The current release only supports a rate of 5 milliseconds per audio frame.</p>
<dl class="section note"><dt>Note</dt><dd>This function is not thread-safe. Do not perform any operations on <code><em>parameter</em></code> while calling this function. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a68">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a91">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a119">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a87">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a77">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a21">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a54">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a56">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a65">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a74">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a34">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a75">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#a29">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#a35">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a57">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a306899c2641a5b13daf5680a6f5d6430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306899c2641a5b13daf5680a6f5d6430">&#9670;&nbsp;</a></span>GetAudioRendererConfigWorkBufferSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::audio::GetAudioRendererConfigWorkBufferSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html">AudioRendererParameter</a> &amp;&#160;</td>
          <td class="paramname"><em>parameter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the work buffer required to initialize <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter</td><td>Parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the working buffer size. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a42518470ed50c8dd6b1395f3c55efeae">nn::audio::IsValidAudioRendererParameter(parameter)</a></code> == <code>true</code>. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a73">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a103">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a125">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a93">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a85">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a27">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a60">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a62">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a71">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a80">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a40">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a81">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#a35">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#a41">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a61">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a0fc7ed6656395abc8493f13abe2d04d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc7ed6656395abc8493f13abe2d04d0">&#9670;&nbsp;</a></span>InitializeAudioRendererConfig()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::InitializeAudioRendererConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html">AudioRendererParameter</a> &amp;&#160;</td>
          <td class="paramname"><em>parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize <a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td><code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter</td><td>Parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The work buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The work buffer size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the execution result. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a42518470ed50c8dd6b1395f3c55efeae">nn::audio::IsValidAudioRendererParameter(parameter)</a></code> == <code>true</code>.</li>
<li><code><em>buffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>buffer</em></code> is aligned to <code><a class="el" href="namespacenn_1_1os.html#ac880b46610757e748d5bd79211af4236" title="This constant stores the minimum unit for memory operations.">nn::os::MemoryPageSize</a></code>.</li>
<li><code><em>size</em></code> &gt;= <code><a class="el" href="namespacenn_1_1audio.html#a306899c2641a5b13daf5680a6f5d6430">nn::audio::GetAudioRendererConfigWorkBufferSize(parameter)</a></code>. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a75">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a104">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a127">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a95">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a87">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a29">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a62">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a64">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a73">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a82">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a42">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a83">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#a37">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#a43">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a62">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a2e81d1f5281360daa5ca6e4d55912607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e81d1f5281360daa5ca6e4d55912607">&#9670;&nbsp;</a></span>SetAudioRendererExclusiveControlLeakageCheckEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetAudioRendererExclusiveControlLeakageCheckEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables or disables mutual exclusion error detection functionality when using the audio renderer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enabled</td><td>Enabled or disabled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The audio renderer that was opened does not exist. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code><a class="el" href="namespacenn_1_1audio.html#a963d645d0bd91e1543144dad88a78050">nn::audio::IsAudioRendererExclusiveControlLeakageCheckEnabled()</a></code> == <code><em>enabled</em></code>.</dd></dl>
<p> <b>Details</b> <br  />
 Enables or disables detection functionality for mutual exclusion error detection when using the audio renderer. It is disabled by default. The application stops with an assertion failure when a mutual exclusion error is detected. Enabling this functionality increases the time required to call audio renderer functions for processing mutual exclusion errors. This functionality is disabled in release builds regardless of the setting.</p>
<p>Mutual exclusion error detection is performed for the following function calls in the current release.</p><ul>
<li>Calls to <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> and calls to functions that must be mutually exclusive to <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code>. </li>
</ul>

</div>
</div>
<a id="a963d645d0bd91e1543144dad88a78050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a963d645d0bd91e1543144dad88a78050">&#9670;&nbsp;</a></span>IsAudioRendererExclusiveControlLeakageCheckEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::IsAudioRendererExclusiveControlLeakageCheckEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the enabled status of the mutual exclusion error detection functionality when using the audio renderer. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if enabled, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a276f9c79640dbd5d6b8c15bd53c69f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a276f9c79640dbd5d6b8c15bd53c69f93">&#9670;&nbsp;</a></span>GetAudioRendererElapsedFrameCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t nn::audio::GetAudioRendererElapsedFrameCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of frames that have elapsed in the audio renderer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pConfig</td><td><code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of elapsed frames. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pConfig</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the number of frames that have elapsed in the audio renderer. The number of elapsed frames is a value that represents how many times audio frames have been created since rendering began in the audio renderer. For example, if each audio frame is 5 milliseconds and 15 milliseconds of audio have been rendered, this function returns <code>3</code> frames as the return value. The initial value immediately after the audio renderer has been opened is <code>0</code> frames. The value is reset to <code>0</code> when the audio renderer is started by <code><a class="el" href="namespacenn_1_1audio.html#a2c0345ad13fb013d06f6cdb812a0a6fd" title="Starts rendering with the audio renderer.">StartAudioRenderer()</a></code>.</p>
<p>The value returned by this function is updated by a call to <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code>. Rendering begins after the audio renderer has transitioned to the start state by the call to <code><a class="el" href="namespacenn_1_1audio.html#a2c0345ad13fb013d06f6cdb812a0a6fd" title="Starts rendering with the audio renderer.">StartAudioRenderer()</a></code>. For this reason, this function might return a value larger than <code>0</code> even immediately after the call to <code><a class="el" href="namespacenn_1_1audio.html#a2c0345ad13fb013d06f6cdb812a0a6fd" title="Starts rendering with the audio renderer.">StartAudioRenderer()</a></code>.</p>
<p>Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p><dl class="section note"><dt>Note</dt><dd>You can also determine the number of elapsed frames by counting how many times the <code><a class="el" href="classnn_1_1os_1_1_system_event.html" title="Class for handling system events.">nn::os::SystemEvent</a></code> object specified in <code><a class="el" href="namespacenn_1_1audio.html#a3f3a5802629c5486c62bf7984ff5f438" title="Gets the audio renderer and initializes the synchronization object for notification purposes.">nn::audio::OpenAudioRenderer(AudioRendererHandle*, nn::os::SystemEvent*, const AudioRendererParameter&amp;, void*, size_t)</a></code> has been signaled. However, the signal state does not change if an audio frame is created at the time of signaling, so you may not be able to get the accurate number of elapsed frames. If you want to get the accurate number of elapsed frames, use this function. </dd></dl>

</div>
</div>
<a id="a855da5a3e7dd33233c653a7dd2db775a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a855da5a3e7dd33233c653a7dd2db775a">&#9670;&nbsp;</a></span>OpenAudioRenderer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::OpenAudioRenderer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_handle.html">AudioRendererHandle</a> *&#160;</td>
          <td class="paramname"><em>outHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html">AudioRendererParameter</a> &amp;&#160;</td>
          <td class="paramname"><em>parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>workBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>workBufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the audio renderer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outHandle</td><td>Audio renderer handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter</td><td>Parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">workBuffer</td><td>The work buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">workBufferSize</td><td>The work buffer size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_no_audio_device_found.html">nn::audio::ResultNoAudioDeviceFound</a> must be handled.</li>
<li><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html">nn::audio::ResultOutOfResource</a> must be handled.</li>
<li><a class="el" href="classnn_1_1audio_1_1_result_insufficient_buffer.html">nn::audio::ResultInsufficientBuffer</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>outHandle</em></code> != <code>nullptr</code>.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a42518470ed50c8dd6b1395f3c55efeae">nn::audio::IsValidAudioRendererParameter(parameter)</a></code> == <code>true</code>.</li>
<li><code><em>workBuffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>workBuffer</em></code> is aligned to <code><a class="el" href="namespacenn_1_1os.html#ac880b46610757e748d5bd79211af4236" title="This constant stores the minimum unit for memory operations.">nn::os::MemoryPageSize</a></code>.</li>
<li><code><em>workBufferSize</em></code> is an integer multiple of <code><a class="el" href="namespacenn_1_1os.html#ac880b46610757e748d5bd79211af4236" title="This constant stores the minimum unit for memory operations.">nn::os::MemoryPageSize</a></code>.</li>
<li><code><em>workBufferSize</em></code> &gt;= <code><a class="el" href="namespacenn_1_1audio.html#afcd51fa35997672709890d7274f303d4">nn::audio::GetAudioRendererWorkBufferSize(parameter)</a></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>Stores a valid handle to <code>*outHandle</code>.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a8aead9bb2b33389f39a8845b75ba6d23">nn::audio::GetAudioRendererState(handle)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#a44c5ac6aa2921d6a52fb1c44471d4661ad5a62596d304f2e23af3451855303500" title="Stopped.">nn::audio::AudioRendererState_Stopped</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code>AudioRenderer</code> is in the stopped state immediately after this function is called.</p>
<div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
 The following combinations of devices and rendering modes may be used for rendering on the NX platform. <ul>
<li>
<code><a class="el" href="namespacenn_1_1audio.html#a46b67f0c9d1ae83ebaea784964373f56a550beeb25cdd6d8c2f0ef5062282dc62" title="Audio coprocessor.">nn::audio::AudioRendererRenderingDevice_AudioCoprocessor</a></code> and <code><a class="el" href="namespacenn_1_1audio.html#abfe8ba78d8df1cffa01e726924471e35a794cd663cfcf7d70450fcf317f7ecf45" title="Executes rendering automatically.">nn::audio::AudioRendererExecutionMode_AutoExecution</a></code> Rendering is executed in the audio DSP. Rendering is executed automatically within the system. </li>
<li>
<code><a class="el" href="namespacenn_1_1audio.html#a46b67f0c9d1ae83ebaea784964373f56a46aff03ba5cf2fde86d7cc6bee1324e5" title="CPU.">nn::audio::AudioRendererRenderingDevice_Cpu</a></code> and <code><a class="el" href="namespacenn_1_1audio.html#abfe8ba78d8df1cffa01e726924471e35a779f8ffa3797802237909514ec53ba9e" title="Executes rendering manually.">nn::audio::AudioRendererExecutionMode_ManualExecution</a></code> The <code><a class="el" href="namespacenn_1_1audio.html#ac88d3b7c00c314f03079ef582e3e7a81" title="Executes rendering processing with the audio renderer.">nn::audio::ExecuteAudioRendererRendering()</a></code> function is called and rendering is executed in the thread. Rendering will not be executed unless <code><a class="el" href="namespacenn_1_1audio.html#ac88d3b7c00c314f03079ef582e3e7a81" title="Executes rendering processing with the audio renderer.">nn::audio::ExecuteAudioRendererRendering()</a></code> is called. </li>
</ul>
</div><div class="platform_section" data-platform="NX"></div><div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
 The following combinations of devices and rendering modes may be used for rendering on the Windows platform. <b>-</b> <code><a class="el" href="namespacenn_1_1audio.html#a46b67f0c9d1ae83ebaea784964373f56a46aff03ba5cf2fde86d7cc6bee1324e5" title="CPU.">nn::audio::AudioRendererRenderingDevice_Cpu</a></code> and <code><a class="el" href="namespacenn_1_1audio.html#abfe8ba78d8df1cffa01e726924471e35a794cd663cfcf7d70450fcf317f7ecf45" title="Executes rendering automatically.">nn::audio::AudioRendererExecutionMode_AutoExecution</a></code> &#160;&#160;&#160;&#160; Rendering is executed automatically by the thread created within the library. <b>-</b> <code><a class="el" href="namespacenn_1_1audio.html#a46b67f0c9d1ae83ebaea784964373f56a46aff03ba5cf2fde86d7cc6bee1324e5" title="CPU.">nn::audio::AudioRendererRenderingDevice_Cpu</a></code> and <code><a class="el" href="namespacenn_1_1audio.html#abfe8ba78d8df1cffa01e726924471e35a779f8ffa3797802237909514ec53ba9e" title="Executes rendering manually.">nn::audio::AudioRendererExecutionMode_ManualExecution</a></code> &#160;&#160;&#160;&#160; The <code><a class="el" href="namespacenn_1_1audio.html#ac88d3b7c00c314f03079ef582e3e7a81" title="Executes rendering processing with the audio renderer.">nn::audio::ExecuteAudioRendererRendering()</a></code> function is called and rendering is executed in the thread. Rendering will not be executed unless <code><a class="el" href="namespacenn_1_1audio.html#ac88d3b7c00c314f03079ef582e3e7a81" title="Executes rendering processing with the audio renderer.">nn::audio::ExecuteAudioRendererRendering()</a></code> is called.</div><div class="platform_section" data-platform="Windows"></div> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a72">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a102">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a124">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a92">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a84">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a26">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a59">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a61">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a70">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a79">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a39">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a80">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#a34">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#a40">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a60">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3f3a5802629c5486c62bf7984ff5f438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3a5802629c5486c62bf7984ff5f438">&#9670;&nbsp;</a></span>OpenAudioRenderer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::OpenAudioRenderer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_handle.html">AudioRendererHandle</a> *&#160;</td>
          <td class="paramname"><em>outHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1os_1_1_system_event.html">nn::os::SystemEvent</a> *&#160;</td>
          <td class="paramname"><em>pOutSystemEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html">AudioRendererParameter</a> &amp;&#160;</td>
          <td class="paramname"><em>parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>workBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>workBufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the audio renderer and initializes the synchronization object for notification purposes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outHandle</td><td>Audio renderer handle. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSystemEvent</td><td><code>SystemEvent</code> for synchronization. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter</td><td>Parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">workBuffer</td><td>The work buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">workBufferSize</td><td>The work buffer size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_no_audio_device_found.html">nn::audio::ResultNoAudioDeviceFound</a> must be handled.</li>
<li><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html">nn::audio::ResultOutOfResource</a> must be handled.</li>
<li><a class="el" href="classnn_1_1audio_1_1_result_insufficient_buffer.html">nn::audio::ResultInsufficientBuffer</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>outHandle</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutSystemEvent</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutSystemEvent</em></code> is not initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a42518470ed50c8dd6b1395f3c55efeae">nn::audio::IsValidAudioRendererParameter(parameter)</a></code> == <code>true</code>.</li>
<li><code><em>workBuffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>workBuffer</em></code> is aligned to <code><a class="el" href="namespacenn_1_1os.html#ac880b46610757e748d5bd79211af4236" title="This constant stores the minimum unit for memory operations.">nn::os::MemoryPageSize</a></code>.</li>
<li><code><em>workBufferSize</em></code> is an integer multiple of <code><a class="el" href="namespacenn_1_1os.html#ac880b46610757e748d5bd79211af4236" title="This constant stores the minimum unit for memory operations.">nn::os::MemoryPageSize</a></code>.</li>
<li><code><em>workBufferSize</em></code> &gt;= <code><a class="el" href="namespacenn_1_1audio.html#afcd51fa35997672709890d7274f303d4">nn::audio::GetAudioRendererWorkBufferSize(parameter)</a></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>Stores a valid handle to <code>*outHandle</code>.</li>
<li><code><em>*pOutSystemEvent</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a8aead9bb2b33389f39a8845b75ba6d23">nn::audio::GetAudioRendererState(handle)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#a44c5ac6aa2921d6a52fb1c44471d4661ad5a62596d304f2e23af3451855303500" title="Stopped.">nn::audio::AudioRendererState_Stopped</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code><em>pOutSystemEvent</em></code> is initialized to <code><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a31f6133098296b3ddb7e14da3dc695cc" title="Automatically cleared event.">nn::os::EventClearMode_AutoClear</a></code>. <code><em>pOutSystemEvent</em></code> is in the signaled state each time the audio renderer begins rendering an audio frame.</p>
<dl class="section warning"><dt>Warning</dt><dd>The <code><a class="el" href="classnn_1_1os_1_1_system_event.html" title="Class for handling system events.">nn::os::SystemEvent</a></code> class object specified for <code><em>pOutSystemEvent</em></code> must call <code><a class="el" href="namespacenn_1_1os.html#a3d924bc362ec80648323428be5182338">nn::os::DestroySystemEvent( pOutSystemEvent-&gt;GetBase() )</a></code> after <code><a class="el" href="namespacenn_1_1audio.html#ac008e23e04fb6c5efbb8796dd2aa9f38" title="Frees the audio renderer.">nn::audio::CloseAudioRenderer()</a></code> has been called. Failure to make this call could cause the application to stop responding.</dd></dl>
<p><code>AudioRenderer</code> is in the stopped state immediately after this function is called.</p>
<p>The audio coprocessor executes rendering if <code><a class="el" href="namespacenn_1_1audio.html#a46b67f0c9d1ae83ebaea784964373f56a550beeb25cdd6d8c2f0ef5062282dc62" title="Audio coprocessor.">nn::audio::AudioRendererRenderingDevice_AudioCoprocessor</a></code> is specified as the device for rendering. The type of coprocessor that executes the processing depends on the platform. If <code><a class="el" href="namespacenn_1_1audio.html#a46b67f0c9d1ae83ebaea784964373f56a46aff03ba5cf2fde86d7cc6bee1324e5" title="CPU.">nn::audio::AudioRendererRenderingDevice_Cpu</a></code>, rendering will be executed in the CPU. The type of thread that executes the processing depends on the platform and specified rendering mode.</p>
<div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
 The following combinations of devices and rendering modes may be used for rendering on the NX platform. <ul>
<li>
<code><a class="el" href="namespacenn_1_1audio.html#a46b67f0c9d1ae83ebaea784964373f56a550beeb25cdd6d8c2f0ef5062282dc62" title="Audio coprocessor.">nn::audio::AudioRendererRenderingDevice_AudioCoprocessor</a></code> and <code><a class="el" href="namespacenn_1_1audio.html#abfe8ba78d8df1cffa01e726924471e35a794cd663cfcf7d70450fcf317f7ecf45" title="Executes rendering automatically.">nn::audio::AudioRendererExecutionMode_AutoExecution</a></code> Rendering is executed in the audio DSP. Rendering is executed automatically within the system. </li>
<li>
<code><a class="el" href="namespacenn_1_1audio.html#a46b67f0c9d1ae83ebaea784964373f56a46aff03ba5cf2fde86d7cc6bee1324e5" title="CPU.">nn::audio::AudioRendererRenderingDevice_Cpu</a></code> and <code><a class="el" href="namespacenn_1_1audio.html#abfe8ba78d8df1cffa01e726924471e35a779f8ffa3797802237909514ec53ba9e" title="Executes rendering manually.">nn::audio::AudioRendererExecutionMode_ManualExecution</a></code> The <code><a class="el" href="namespacenn_1_1audio.html#ac88d3b7c00c314f03079ef582e3e7a81" title="Executes rendering processing with the audio renderer.">nn::audio::ExecuteAudioRendererRendering()</a></code> function is called and rendering is executed in the thread. Rendering will not be executed unless <code><a class="el" href="namespacenn_1_1audio.html#ac88d3b7c00c314f03079ef582e3e7a81" title="Executes rendering processing with the audio renderer.">nn::audio::ExecuteAudioRendererRendering()</a></code> is called. </li>
</ul>
</div><div class="platform_section" data-platform="NX"></div><div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
 The following combinations of devices and rendering modes may be used for rendering processing on the Windows platform. <b>-</b> <code><a class="el" href="namespacenn_1_1audio.html#a46b67f0c9d1ae83ebaea784964373f56a46aff03ba5cf2fde86d7cc6bee1324e5" title="CPU.">nn::audio::AudioRendererRenderingDevice_Cpu</a></code> and <code><a class="el" href="namespacenn_1_1audio.html#abfe8ba78d8df1cffa01e726924471e35a794cd663cfcf7d70450fcf317f7ecf45" title="Executes rendering automatically.">nn::audio::AudioRendererExecutionMode_AutoExecution</a></code> &#160;&#160;&#160;&#160; Rendering is executed automatically by the thread created within the library. <b>-</b> <code><a class="el" href="namespacenn_1_1audio.html#a46b67f0c9d1ae83ebaea784964373f56a46aff03ba5cf2fde86d7cc6bee1324e5" title="CPU.">nn::audio::AudioRendererRenderingDevice_Cpu</a></code> and <code><a class="el" href="namespacenn_1_1audio.html#abfe8ba78d8df1cffa01e726924471e35a779f8ffa3797802237909514ec53ba9e" title="Executes rendering manually.">nn::audio::AudioRendererExecutionMode_ManualExecution</a></code> &#160;&#160;&#160;&#160; The <code><a class="el" href="namespacenn_1_1audio.html#ac88d3b7c00c314f03079ef582e3e7a81" title="Executes rendering processing with the audio renderer.">nn::audio::ExecuteAudioRendererRendering()</a></code> function is called and rendering is executed in the thread. Rendering will not be executed unless <code><a class="el" href="namespacenn_1_1audio.html#ac88d3b7c00c314f03079ef582e3e7a81" title="Executes rendering processing with the audio renderer.">nn::audio::ExecuteAudioRendererRendering()</a></code> is called.</div><div class="platform_section" data-platform="Windows"></div> 
</div>
</div>
<a id="ac008e23e04fb6c5efbb8796dd2aa9f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac008e23e04fb6c5efbb8796dd2aa9f38">&#9670;&nbsp;</a></span>CloseAudioRenderer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::CloseAudioRenderer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_handle.html">AudioRendererHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the audio renderer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Audio renderer handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>handle</em></code> is a valid object.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a8aead9bb2b33389f39a8845b75ba6d23">nn::audio::GetAudioRendererState(handle)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#a44c5ac6aa2921d6a52fb1c44471d4661ad5a62596d304f2e23af3451855303500" title="Stopped.">nn::audio::AudioRendererState_Stopped</a></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>handle</em></code> becomes invalid.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 After control returns from this function, <code>AudioRenderer</code> does not access the working buffer. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a156">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a131">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a210">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a168">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a120">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a60">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a166">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a149">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a118">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a158">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a80">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a129">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#a79">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#a88">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a102">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a2c0345ad13fb013d06f6cdb812a0a6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0345ad13fb013d06f6cdb812a0a6fd">&#9670;&nbsp;</a></span>StartAudioRenderer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::StartAudioRenderer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_handle.html">AudioRendererHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts rendering with the audio renderer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Audio renderer handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>handle</em></code> is a valid object.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a8aead9bb2b33389f39a8845b75ba6d23">nn::audio::GetAudioRendererState(handle)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#a44c5ac6aa2921d6a52fb1c44471d4661ad5a62596d304f2e23af3451855303500" title="Stopped.">nn::audio::AudioRendererState_Stopped</a></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a8aead9bb2b33389f39a8845b75ba6d23">nn::audio::GetAudioRendererState(handle)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#a44c5ac6aa2921d6a52fb1c44471d4661ab7f98e352ea8fe399028e2ac38c81dc6" title="Running.">nn::audio::AudioRendererState_Started</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
</p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a89">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a110">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a161">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a123">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a93">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a36">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a93">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a78">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a89">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a151">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a68">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a111">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#a63">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#a75">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a80">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a7590b47d3fcdb9d6b48d1b41184336a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7590b47d3fcdb9d6b48d1b41184336a6">&#9670;&nbsp;</a></span>StopAudioRenderer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::StopAudioRenderer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_handle.html">AudioRendererHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stops rendering with the audio renderer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Audio renderer handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>handle</em></code> is a valid object.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a8aead9bb2b33389f39a8845b75ba6d23">nn::audio::GetAudioRendererState(handle)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#a44c5ac6aa2921d6a52fb1c44471d4661ab7f98e352ea8fe399028e2ac38c81dc6" title="Running.">nn::audio::AudioRendererState_Started</a></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a8aead9bb2b33389f39a8845b75ba6d23">nn::audio::GetAudioRendererState(handle)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#a44c5ac6aa2921d6a52fb1c44471d4661ad5a62596d304f2e23af3451855303500" title="Stopped.">nn::audio::AudioRendererState_Stopped</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Even when this function is called, the internal parameters remain as they are. When you call <code><a class="el" href="namespacenn_1_1audio.html#a2c0345ad13fb013d06f6cdb812a0a6fd" title="Starts rendering with the audio renderer.">nn::audio::StartAudioRenderer()</a></code> again, playback resumes according to the stored parameters. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a155">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a130">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a209">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a167">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a119">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a59">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a165">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a148">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a117">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a157">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a79">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a128">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#a78">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#a87">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a101">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a25ee6f076a7eb80a0fc937c42d41e652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ee6f076a7eb80a0fc937c42d41e652">&#9670;&nbsp;</a></span>GetAudioRendererSampleRate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetAudioRendererSampleRate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_handle.html">AudioRendererHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the sampling rate of the audio renderer processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Audio renderer handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the process sample rate. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>handle</em></code> is a valid object.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
</p>

</div>
</div>
<a id="abf4185f6faa85bc692ceed25c3e62eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4185f6faa85bc692ceed25c3e62eb3">&#9670;&nbsp;</a></span>GetAudioRendererSampleCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetAudioRendererSampleCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_handle.html">AudioRendererHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of audio renderer mix buffer samples. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Audio renderer handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of frame samples. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>handle</em></code> is a valid object. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a8544bdfe35b41171afecfd38eabcdc24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8544bdfe35b41171afecfd38eabcdc24">&#9670;&nbsp;</a></span>GetAudioRendererMixBufferCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetAudioRendererMixBufferCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_handle.html">AudioRendererHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of audio renderer mix buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Audio renderer handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of internal buffers. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>handle</em></code> is a valid object.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
</p>

</div>
</div>
<a id="a8aead9bb2b33389f39a8845b75ba6d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aead9bb2b33389f39a8845b75ba6d23">&#9670;&nbsp;</a></span>GetAudioRendererState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1audio.html#a44c5ac6aa2921d6a52fb1c44471d4661">AudioRendererState</a> nn::audio::GetAudioRendererState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_handle.html">AudioRendererHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the state of an audio renderer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Audio renderer handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the state. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>handle</em></code> is a valid object. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac555128156197608dfaeeb5e824780a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac555128156197608dfaeeb5e824780a6">&#9670;&nbsp;</a></span>RequestUpdateAudioRenderer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::RequestUpdateAudioRenderer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_handle.html">AudioRendererHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the parameters for <code>Voice</code> objects bound to the audio renderer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Audio renderer handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pConfig</td><td><code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_invalid_update_info.html">nn::audio::ResultInvalidUpdateInfo</a> must be handled.</li>
<li><a class="el" href="classnn_1_1audio_1_1_result_no_memory_pool_entry.html">nn::audio::ResultNoMemoryPoolEntry</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>handle</em></code> is a valid object.</li>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 All settings associated with the audio renderer are applied to the audio renderer that has already been obtained with the specified <code><em>handle</em></code>.</p>
<p>With <code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code>, calling this function causes the "data handled by the audio renderer" to be applied to the audio renderer. Any changes made to the data handled by the audio renderer are not applied until this function is called. "Data handled by the audio renderer" includes the following types.</p>
<ul>
<li><code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code></li>
<li><code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code></li>
<li><code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code></li>
<li><code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code></li>
<li><code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code></li>
<li><code><a class="el" href="structnn_1_1audio_1_1_circular_buffer_sink_type.html" title="Sink to output the rendering results to memory.">CircularBufferSinkType</a></code></li>
<li><code><a class="el" href="structnn_1_1audio_1_1_device_sink_type.html" title="Sink to output the rendering results to the audio output device.">DeviceSinkType</a></code></li>
<li><code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html" title="Structure for representing memory regions used by an audio renderer.">MemoryPoolType</a></code></li>
<li>Various effects (<code><a class="el" href="structnn_1_1audio_1_1_buffer_mixer_type.html" title="BufferMixer effects.">BufferMixerType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code>)</li>
</ul>
<p>In addition to the operations on these types, the data handled by the audio renderer also includes information set by functions like <code><a class="el" href="namespacenn_1_1audio.html#a7d1532644fd22daad0fe71d9f409ba72" title="Sets a starting address to output performance information to.">nn::audio::SetPerformanceFrameBuffer()</a></code> that take <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> as an argument. Calling this function applies such information to the audio renderer.</p>
<p>If <code><a class="el" href="classnn_1_1audio_1_1_result_invalid_update_info.html" title="A class that represents error Result values (audio: The data passed to RequestUpdateAudioRenderer() i...">nn::audio::ResultInvalidUpdateInfo</a></code> is returned, the content of the passed <code><em>pConfig</em></code> is in an invalid state. When you call this function, because it is not thread-safe and can inadvertently corrupt the region referenced by <code><em>pConfig</em></code>, determine whether access to data managed by the audio renderer has been prohibited.</p>
<dl class="section note"><dt>Note</dt><dd>This function is not thread-safe. During this function call, do not perform any prohibited operations linked to the "data handled by the audio renderer" for any audio renderers specified by <code><em>handle</em></code> or <code><em>pConfig</em></code>.</dd></dl>
<p>This function cannot be called on the same <code><em>handle</em></code> using multiple <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> instances. If <code><a class="el" href="classnn_1_1os_1_1_system_event.html" title="Class for handling system events.">nn::os::SystemEvent</a></code> is specified when the <code><a class="el" href="namespacenn_1_1audio.html#a855da5a3e7dd33233c653a7dd2db775a" title="Gets the audio renderer.">nn::audio::OpenAudioRenderer()</a></code> function is called, this function is in the non-signaled state when it is called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a88">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a109">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a160">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a122">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a92">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a35">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a92">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a77">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a88">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a150">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a71">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a118">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#a70">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#a81">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a79">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="afcd51fa35997672709890d7274f303d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd51fa35997672709890d7274f303d4">&#9670;&nbsp;</a></span>GetAudioRendererWorkBufferSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::audio::GetAudioRendererWorkBufferSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html">AudioRendererParameter</a> &amp;&#160;</td>
          <td class="paramname"><em>parameter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the working buffer required to open an audio renderer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter</td><td>Parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the working buffer size. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a42518470ed50c8dd6b1395f3c55efeae">nn::audio::IsValidAudioRendererParameter(parameter)</a></code> == <code>true</code>. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a69">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a98">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a120">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a88">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a80">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a22">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a55">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a57">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a66">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a75">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a35">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a76">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#a30">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#a36">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a58">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab54fa3067e8bd1916ece8ed7384dd11f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54fa3067e8bd1916ece8ed7384dd11f">&#9670;&nbsp;</a></span>SetAudioRendererRenderingTimeLimit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::SetAudioRendererRenderingTimeLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_handle.html">AudioRendererHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>limitPercent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the upper limit on the rendering time allocated to the audio renderer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The audio renderer handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">limitPercent</td><td>The upper limit on the rendering time allocated to the audio renderer. The unit is percent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_operation_failed.html">nn::audio::ResultOperationFailed</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>handle</em></code> is a valid object.</li>
<li><code><em>limitPercent</em></code> &gt;= <code>0</code> &amp;&amp; <code><em>limitPercent</em></code> &lt;= <code>100</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a4623b80df57739915f88e9913d4dcfd0">nn::audio::GetAudioRendererRenderingTimeLimit(handle)</a></code> == <code><em>limitPercent</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Specifies as a percentage the upper limit on the rendering time allocated to the audio renderer. The default is 100%. The rendering time is the time used for the rendering of audio by the audio renderer. For example, assume that three milliseconds have been allocated for rendering in each audio frame and the upper limit for the rendering time has been set to 50%. In this case, there is a time limit of 1.5 milliseconds for rendering in each audio frame. If the rendering time exceeds the limit, frames will be dropped. The value that can be specified depends on the platform. If an unsupported value has been specified, the function will return <code><a class="el" href="classnn_1_1audio_1_1_result_operation_failed.html" title="A class that represents error Result values (audio: The process failed.).">nn::audio::ResultOperationFailed</a></code>.</p>
<div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
 On the NX platform, <code><em>limitPercent</em></code> can be set to any value between and 0% and 100%. The audio renderer performs rendering in the audio DSP. This audio DSP is shared with some of the encoding and decoding processes of the <code><a class="el" href="namespacenn_1_1codec.html" title="The namespace of the codec library for audio and video compression.">nn::codec</a></code> namespace. These encoding and decoding processes on the audio DSP have lower priority than the audio renderer, so depending on the processing load of the audio renderer, sometimes encoding and decoding may not take place. Use this function to limit the rendering time of the audio renderer if you need to make sure that encoding and decoding will be performed on the audio DSP even when the audio renderer is operating. For more information about the DSP resources assigned to the application, see <a href="../../Package/contents/Pages/Page_912051027.html#Anchor_912051027_DspResourceLimitations">DSP Resource Limitations</a>.</div><div class="platform_section" data-platform="NX"> The encoding and decoding processes of the <code><a class="el" href="namespacenn_1_1codec.html" title="The namespace of the codec library for audio and video compression.">nn::codec</a></code> namespace use the audio DSP as follows. <ul>
<li>
<a class="el" href="classnn_1_1codec_1_1_hardware_opus_decoder.html" title="The Opus decoder class for hardware use.">nn::codec::HardwareOpusDecoder</a> </li>
</ul>
</div><div class="platform_section" data-platform="NX"></div><div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
 On the Windows platform, <code><em>limitPercent</em></code> can be set to any value between and 0% and 100%. However, the specified value does not indicate the actual upper limit on rendering time.</div><div class="platform_section" data-platform="Windows"></div> <dl class="section note"><dt>Note</dt><dd>This function is not thread-safe. During this function call, do not perform any operations on "data handled by the audio renderer" linked to the audio renderer specified by <code><em>handle</em></code>. </dd></dl>

</div>
</div>
<a id="a4623b80df57739915f88e9913d4dcfd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4623b80df57739915f88e9913d4dcfd0">&#9670;&nbsp;</a></span>GetAudioRendererRenderingTimeLimit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetAudioRendererRenderingTimeLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_handle.html">AudioRendererHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the upper limit on the rendering time allocated to the audio renderer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The audio renderer handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the upper limit on the rendering time allocated to the audio renderer. The unit is percent. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>handle</em></code> is a valid object.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets a percentage value representing the upper limit on the rendering time allocated to the audio renderer. For more information about the rendering time, see <code><a class="el" href="namespacenn_1_1audio.html#ab54fa3067e8bd1916ece8ed7384dd11f" title="Sets the upper limit on the rendering time allocated to the audio renderer.">nn::audio::SetAudioRendererRenderingTimeLimit()</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>This function is not thread-safe. During this function call, do not perform any operations on "data handled by the audio renderer" linked to the audio renderer specified by <code><em>handle</em></code>. </dd></dl>

</div>
</div>
<a id="ac88d3b7c00c314f03079ef582e3e7a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88d3b7c00c314f03079ef582e3e7a81">&#9670;&nbsp;</a></span>ExecuteAudioRendererRendering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::ExecuteAudioRendererRendering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_handle.html">AudioRendererHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes rendering processing with the audio renderer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The audio renderer handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_operation_failed.html">nn::audio::ResultOperationFailed</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>handle</em></code> is a valid object.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 When calling <code><a class="el" href="namespacenn_1_1audio.html#a855da5a3e7dd33233c653a7dd2db775a" title="Gets the audio renderer.">nn::audio::OpenAudioRenderer()</a></code> and the rendering mode is set to <code><a class="el" href="namespacenn_1_1audio.html#abfe8ba78d8df1cffa01e726924471e35a779f8ffa3797802237909514ec53ba9e" title="Executes rendering manually.">nn::audio::AudioRendererExecutionMode_ManualExecution</a></code> (execute rendering manually), the audio renderer executes audio rendering for one frame. If <code><a class="el" href="namespacenn_1_1audio.html#abfe8ba78d8df1cffa01e726924471e35a794cd663cfcf7d70450fcf317f7ecf45" title="Executes rendering automatically.">nn::audio::AudioRendererExecutionMode_AutoExecution</a></code> (execute rendering automatically), rendering is not executed and <code><a class="el" href="classnn_1_1audio_1_1_result_not_supported.html" title="A class that represents error Result values (audio: This functionality is not supported....">nn::audio::ResultNotSupported()</a></code> is returned.</p>
<p>When calling <code><a class="el" href="namespacenn_1_1audio.html#a855da5a3e7dd33233c653a7dd2db775a" title="Gets the audio renderer.">nn::audio::OpenAudioRenderer()</a></code> and specifying <code><a class="el" href="namespacenn_1_1audio.html#a46b67f0c9d1ae83ebaea784964373f56a46aff03ba5cf2fde86d7cc6bee1324e5" title="CPU.">nn::audio::AudioRendererRenderingDevice_Cpu</a></code> as the rendering device, rendering is executed in the thread that called this function. This function does not return control to caller until it has finished rendering processing. This function requires processing time depending on the content of the requested rendering processing.</p>
<p>In the current release, audio renderers selected <code><a class="el" href="namespacenn_1_1audio.html#a46b67f0c9d1ae83ebaea784964373f56a550beeb25cdd6d8c2f0ef5062282dc62" title="Audio coprocessor.">nn::audio::AudioRendererRenderingDevice_AudioCoprocessor</a></code> are not supported as devices for rendering.</p>
<p>Audio renderers using manual rendering processing may not use the following features.</p><ul>
<li>Voice drop</li>
<li>Specifying the upper limit on the rendering time allocated to the audio renderer</li>
<li>Using <code><a class="el" href="structnn_1_1audio_1_1_device_sink_type.html" title="Sink to output the rendering results to the audio output device.">nn::audio::DeviceSinkType</a></code> to play back the rendering results<ul>
<li>You can get the rendering results by using <code><a class="el" href="structnn_1_1audio_1_1_circular_buffer_sink_type.html" title="Sink to output the rendering results to memory.">nn::audio::CircularBufferSinkType</a></code>. For more information, see <code><a class="el" href="structnn_1_1audio_1_1_circular_buffer_sink_type.html" title="Sink to output the rendering results to memory.">nn::audio::CircularBufferSinkType</a></code>.</li>
</ul>
</li>
</ul>
<p>If <code><a class="el" href="classnn_1_1os_1_1_system_event.html" title="Class for handling system events.">nn::os::SystemEvent</a></code> is specified when the <code><a class="el" href="namespacenn_1_1audio.html#a855da5a3e7dd33233c653a7dd2db775a" title="Gets the audio renderer.">nn::audio::OpenAudioRenderer()</a></code> function is called, this function will change to the signaled state after rendering processing is complete.</p>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe except when used simultaneously with the following functions.<ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a2c0345ad13fb013d06f6cdb812a0a6fd" title="Starts rendering with the audio renderer.">nn::audio::StartAudioRenderer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a7590b47d3fcdb9d6b48d1b41184336a6" title="Stops rendering with the audio renderer.">nn::audio::StopAudioRenderer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ac008e23e04fb6c5efbb8796dd2aa9f38" title="Frees the audio renderer.">nn::audio::CloseAudioRenderer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a8aead9bb2b33389f39a8845b75ba6d23" title="Gets the state of an audio renderer.">nn::audio::GetAudioRendererState()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ac88d3b7c00c314f03079ef582e3e7a81" title="Executes rendering processing with the audio renderer.">nn::audio::ExecuteAudioRendererRendering()</a></code> </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a149">AudioCpuRenderer/AudioCpuRenderer.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a8079b796ed899e8cb519f07e5456c77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8079b796ed899e8cb519f07e5456c77b">&#9670;&nbsp;</a></span>GetAudioRendererRenderingDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1audio.html#a46b67f0c9d1ae83ebaea784964373f56">AudioRendererRenderingDevice</a> nn::audio::GetAudioRendererRenderingDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_handle.html">AudioRendererHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the device used by the audio renderer for rendering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The audio renderer handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The device used by the audio renderer for rendering. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>handle</em></code> is a valid object. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0a7abfcbf0385e9e2bf86bbfce40430f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7abfcbf0385e9e2bf86bbfce40430f">&#9670;&nbsp;</a></span>GetAudioRendererExecutionMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1audio.html#abfe8ba78d8df1cffa01e726924471e35">AudioRendererExecutionMode</a> nn::audio::GetAudioRendererExecutionMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_handle.html">AudioRendererHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the rendering mode of the audio renderer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The audio renderer handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rendering mode of the audio renderer. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>handle</em></code> is a valid object. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5032bc2f04b92ab0892bb6d85adfd5d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5032bc2f04b92ab0892bb6d85adfd5d0">&#9670;&nbsp;</a></span>GetRequiredBufferSizeForAuxDelay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::audio::GetRequiredBufferSizeForAuxDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td>
          <td class="paramname"><em>delayTimeMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelCountMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the buffer required for using <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delayTimeMax</td><td>The maximum delay time that can be set with <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleRate</td><td>The sample rate set for the <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">nn::audio::AuxType</a></code> using <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCountMax</td><td>The maximum number of channels to specify for <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the size of the buffer. [byte] </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>(<code><em>sampleRate</em></code> == <code>32000</code>) || (<code><em>sampleRate</em></code> == <code>48000</code>).</li>
<li>(<code><em>channelCountMax</em></code> == <code>1</code>) || (<code><em>channelCountMax</em></code> == <code>2</code>) || (<code><em>channelCountMax</em></code> == <code>4</code> ) || (<code><em>channelCountMax</em></code> == <code>6</code>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="afb1ab19629487599a70f6cf5c851b286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb1ab19629487599a70f6cf5c851b286">&#9670;&nbsp;</a></span>InitializeAuxDelay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::InitializeAuxDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html">AuxDelayType</a> *&#160;</td>
          <td class="paramname"><em>pOutDelay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td>
          <td class="paramname"><em>delayTimeMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelCountMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutDelay</td><td>Pointer to the <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code> to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The work buffer to use with <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size, in bytes, of the work buffer specified for <code><em>buffer</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delayTimeMax</td><td>The maximum delay time that can be set with <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleRate</td><td>The sample rate of the sample that will be the input for <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCountMax</td><td>The number of channels in the sample that will be the input for <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>buffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>bufferSize</em></code> &gt;= <code><a class="el" href="namespacenn_1_1audio.html#a5032bc2f04b92ab0892bb6d85adfd5d0">nn::audio::GetRequiredBufferSizeForAuxDelay(delayTimeMax, sampleRate, channelCountMax)</a></code>.</li>
<li>(<code><em>sampleRate</em></code> == <code>32000</code>) || (<code><em>sampleRate</em></code> == <code>48000</code>).</li>
<li>(<code><em>channelCountMax</em></code> == <code>1</code>) || (<code><em>channelCountMax</em></code> == <code>2</code>) || (<code><em>channelCountMax</em></code> == <code>4</code> ) || (<code><em>channelCountMax</em></code> == <code>6</code>).</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 For <code><em>sampleRate</em></code>, specify the sample rate of the <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">nn::audio::AuxType</a></code> on which <code><em>pOutDelay</em></code> processes effects. Use <code><a class="el" href="namespacenn_1_1audio.html#a2970bf3cba541e147e48d4d66d4e90b3" title="Gets the sample rate of the SendBuffer and ReturnBuffer managed by AuxType.">nn::audio::GetAuxSampleRate()</a></code> to get the sample rate. For <code><em>channelCountMax</em></code>, specify the maximum number of input channels that will be specified for <code><em>pOutDelay</em></code>. </p>

</div>
</div>
<a id="a51a44fc9820b4d519d0828d7588e0508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a44fc9820b4d519d0828d7588e0508">&#9670;&nbsp;</a></span>GetAuxDelayChannelCountMax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetAuxDelayChannelCountMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html">AuxDelayType</a> *&#160;</td>
          <td class="paramname"><em>pDelay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum number of channels that can be set for <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">AuxDelayType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDelay</td><td>Pointer to an initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the maximum value for the number of channels that can be set. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDelay</em></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af41b5f59e5efa09a2311b3cec93106fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af41b5f59e5efa09a2311b3cec93106fb">&#9670;&nbsp;</a></span>GetAuxDelayInputOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::GetAuxDelayInputOutput </td>
          <td>(</td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>outInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>outOutput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html">AuxDelayType</a> *&#160;</td>
          <td class="paramname"><em>pDelay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the input/output channel indexes for <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outInput</td><td>The array from where to get the indexes of the input channels set in <code><em>pDelay</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outOutput</td><td>The array from where to get the indexes of the output channels set in <code><em>pDelay</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutCount</td><td>The number of channel indexes obtained in <code><em>outInput</em></code> and <code><em>outOutput</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pDelay</td><td>Pointer to an initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Length of the <code><em>outInput</em></code> and <code><em>outOutput</em></code> arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDelay</em></code> is initialized.</li>
<li><code><em>outInput</em></code> != <code>nullptr</code>.</li>
<li><code><em>outOutput</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutCount</em></code> != <code>nullptr</code>.</li>
<li><code><em>count</em></code> &gt; <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the array of channel indexes specified by <code><a class="el" href="namespacenn_1_1audio.html#a056b975436e2c63c8dfe4efd142f5907" title="Sets the input/output channel indexes for nn::audio::AuxDelayType">nn::audio::SetAuxDelayInputOutput()</a></code>. </p>

</div>
</div>
<a id="a056b975436e2c63c8dfe4efd142f5907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056b975436e2c63c8dfe4efd142f5907">&#9670;&nbsp;</a></span>SetAuxDelayInputOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetAuxDelayInputOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html">AuxDelayType</a> *&#160;</td>
          <td class="paramname"><em>pOutDelay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the input/output channel indexes for <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutDelay</td><td>Pointer to an initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Array of input channel indexes to set in <code><em>pOutDelay</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>Array of output channel indexes to set in <code><em>pOutDelay</em></code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of channel indexes stored in <code><em>input</em></code> and <code><em>output</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutDelay</em></code> is initialized.</li>
<li><code><em>input</em></code> != <code>nullptr</code>.</li>
<li><code><em>output</em></code> != <code>nullptr</code>.</li>
<li>(<code><em>count</em></code> == <code>1</code>) || (<code><em>count</em></code> == <code>2</code>) || (<code><em>count</em></code> == <code>4</code>) || (<code><em>count</em></code> == <code>6</code>).</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The input samples specified for <code><em>inBuffer</em></code> with the <code><a class="el" href="namespacenn_1_1audio.html#ab2b23cd50dc12cc8a11b5f089e192869" title="Executes the nn::audio::AuxDelayType effect process.">nn::audio::ProcessAuxDelay()</a></code> function are expected to be block-interleaved. This function specifies the channels to which to apply the effect processing performed by <code><a class="el" href="namespacenn_1_1audio.html#ab2b23cd50dc12cc8a11b5f089e192869" title="Executes the nn::audio::AuxDelayType effect process.">nn::audio::ProcessAuxDelay()</a></code>.</p>
<p>The <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">AuxDelayType</a></code> <code><em>input</em></code> is processed on the assumption that input channels are in the following order. Be careful not to get the order wrong when you set <code><em>input</em></code>.</p><ul>
<li>For 2 ch: <code>FrontLeft</code>, <code>FrontRight</code>.</li>
<li>For 4 ch: <code>FrontLeft</code>, <code>FrontRight</code>, <code>RearLeft</code>, <code>RearRight</code>.</li>
<li>For 6 ch: <code>FrontLeft</code>, <code>FrontRight</code>, <code>RearLeft</code>, <code>RearRight</code>, <code>FrontCenter</code>, <code>LowFrequency</code>.</li>
</ul>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pOutDelay</em></code> while calling this function. </p>

</div>
</div>
<a id="a3df8d80c2dee7d620e6ae88ec3ddf9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df8d80c2dee7d620e6ae88ec3ddf9e2">&#9670;&nbsp;</a></span>GetAuxDelayTimeMax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> nn::audio::GetAuxDelayTimeMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html">AuxDelayType</a> *&#160;</td>
          <td class="paramname"><em>pDelay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum delay time that can be set for <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">AuxDelayType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDelay</td><td>Pointer to an initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the maximum value that can be set for the delay time. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDelay</em></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac9afa0f0546fd479e5b47f90498edc34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9afa0f0546fd479e5b47f90498edc34">&#9670;&nbsp;</a></span>GetAuxDelayParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1audio_1_1_delay_parameter_set.html">DelayParameterSet</a> nn::audio::GetAuxDelayParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html">AuxDelayType</a> *&#160;</td>
          <td class="paramname"><em>pDelay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code> effect parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDelay</td><td>Pointer to an initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>outParameterSet Returns the effect parameters to set. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutDelay</em></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab3be8ea84abff5e7dcf08517240d88c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3be8ea84abff5e7dcf08517240d88c3">&#9670;&nbsp;</a></span>SetAuxDelayParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetAuxDelayParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html">AuxDelayType</a> *&#160;</td>
          <td class="paramname"><em>pOutDelay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_delay_parameter_set.html">DelayParameterSet</a> *&#160;</td>
          <td class="paramname"><em>pParameterSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code> effect parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutDelay</td><td>Pointer to an initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pParameterSet</td><td>The effect parameter to set to <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutDelay</em></code> is initialized.</li>
<li><code><em>pParameterSet</em></code> != <code>nullptr</code>.</li>
<li><code><a class="el" href="classnn_1_1_time_span.html#a2441d3c84cc24b901342ce11f87cd39c">nn::TimeSpan::FromMilliSeconds(0)</a></code> &lt;= <code><em>pParameterSet</em>-&gt;delayTime</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;delayTime</code> &lt;= <code><a class="el" href="namespacenn_1_1audio.html#a3df8d80c2dee7d620e6ae88ec3ddf9e2" title="Gets the maximum delay time that can be set for AuxDelayType.">nn::audio::GetAuxDelayTimeMax()</a></code>.</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;inGain</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;inGain</code> &lt;= <code>1.0f</code>.</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;feedbackGain</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;feedbackGain</code> &lt;= <code>1.0f</code>.</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;dryGain</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;dryGain</code> &lt;= <code>1.0f</code>.</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;channelSpread</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;channelSpread</code> &lt;= <code>1.0f</code>.</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;lowPassAmount</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;lowPassAmount</code> &lt;= <code>1.0f</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 For more information about the meanings of the parameters, see Delay Parameters in the <a href="../../Package/contents/Pages/Page_93362777.html">Audio Effects</a> documentation.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pOutDelay</em></code> while calling this function. </p>

</div>
</div>
<a id="ab2b23cd50dc12cc8a11b5f089e192869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b23cd50dc12cc8a11b5f089e192869">&#9670;&nbsp;</a></span>ProcessAuxDelay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::ProcessAuxDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html">AuxDelayType</a> *&#160;</td>
          <td class="paramname"><em>pOutDelay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>outBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t *&#160;</td>
          <td class="paramname"><em>inBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>samplesPerFrame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code> effect process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutDelay</td><td>Pointer to an initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inBuffer</td><td>Buffer that stores the sample data for implementing effects. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outBuffer</td><td>Buffer that stores the effect processing results. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">samplesPerFrame</td><td>Number of samples per audio frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutDelay</em></code> is initialized.</li>
<li><code><em>inBuffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>outBuffer</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Call this function to execute the actual effect processing.</p>
<p>The contents of the buffer specified for <code><em>inBuffer</em></code> are subjected to effect processing, and the results are sent to <code><em>outBuffer</em></code>. The sample data in <code><em>inBuffer</em></code> is expected to be block interleaved. In other words, specify a buffer to the sample data obtained by the <code><a class="el" href="namespacenn_1_1audio.html#adaf2f0b6dfbaa1b020d61cd56b963965" title="Loads count number of samples from AuxType.">nn::audio::ReadAuxSendBuffer()</a></code> function. A number of samples equivalent to one frame of one channel for block interleaving are set for <code><em>samplePerFrame</em></code>. If this value was obtained by <code><a class="el" href="namespacenn_1_1audio.html#adaf2f0b6dfbaa1b020d61cd56b963965" title="Loads count number of samples from AuxType.">nn::audio::ReadAuxSendBuffer()</a></code>, it will be identical to the <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html#a1c8b7223c7e2ce641691f4e4f93000dd" title="The number of samples maintained by one mix buffer.">AudioRendererParameter.sampleCount</a></code> value.</p>
<p>This function is executed by the calling thread. This function is not thread-safe. Do not perform any operations on <code><em>pOutDelay</em></code> while calling this function. </p>

</div>
</div>
<a id="a29470a53139cf1cd3ab4c66ca25a9a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29470a53139cf1cd3ab4c66ca25a9a13">&#9670;&nbsp;</a></span>ResetAuxDelay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::ResetAuxDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html">AuxDelayType</a> *&#160;</td>
          <td class="paramname"><em>pOutDelay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the delay component of the <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code> effect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pOutDelay</td><td>Pointer to an initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutDelay</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Calling this function clears the state of the work buffer managed by <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code> and then destroys and reinitializes the delay component. However, the effect parameters specified by the <code><a class="el" href="namespacenn_1_1audio.html#ab3be8ea84abff5e7dcf08517240d88c3" title="Sets the nn::audio::AuxDelayType effect parameters.">nn::audio::SetAuxDelayParameters()</a></code> function are retained. Call this function to disable the prior effect processing input and start new effect processing.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pOutDelay</em></code> while calling this function. </p>

</div>
</div>
<a id="ae57b6b6fc54d22f22d63dc227397fd66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57b6b6fc54d22f22d63dc227397fd66">&#9670;&nbsp;</a></span>GetRequiredBufferSizeForAuxI3dl2Reverb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::audio::GetRequiredBufferSizeForAuxI3dl2Reverb </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelCountMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the buffer required to use <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">nn::audio::AuxI3dl2ReverbType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleRate</td><td>The sample rate set for <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">nn::audio::AuxType</a></code> which uses <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">nn::audio::AuxI3dl2ReverbType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCountMax</td><td>The maximum number of channels to specify for <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">nn::audio::AuxI3dl2ReverbType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the size of the buffer. [byte] </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>(<code><em>sampleRate</em></code> == <code>32000</code>) || (<code><em>sampleRate</em></code> == <code>48000</code>).</li>
<li>(<code><em>channelCountMax</em></code> == <code>1</code>) || (<code><em>channelCountMax</em></code> == <code>2</code>) || (<code><em>channelCountMax</em></code> == <code>4</code> ) || (<code><em>channelCountMax</em></code> == <code>6</code>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a992d642a3d5a5162e42afd45abeb02bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a992d642a3d5a5162e42afd45abeb02bb">&#9670;&nbsp;</a></span>InitializeAuxI3dl2Reverb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::InitializeAuxI3dl2Reverb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html">AuxI3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pOutReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelCountMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">nn::audio::AuxI3dl2ReverbType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutReverb</td><td>Pointer to the <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">nn::audio::AuxI3dl2ReverbType</a></code> to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Work buffer used for <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">nn::audio::AuxI3dl2ReverbType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size, in bytes, of the work buffer specified for <code><em>buffer</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleRate</td><td>The sample rate of the input sample for <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">nn::audio::AuxI3dl2ReverbType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCountMax</td><td>The number of channels of the input sample for <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">nn::audio::AuxI3dl2ReverbType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>buffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>bufferSize</em></code> &gt;= <code><a class="el" href="namespacenn_1_1audio.html#ae57b6b6fc54d22f22d63dc227397fd66">nn::audio::GetRequiredBufferSizeForAuxI3dl2Reverb(sampleRate, channelCountMax)</a></code>.</li>
<li>(<code><em>sampleRate</em></code> == <code>32000</code>) || (<code><em>sampleRate</em></code> == <code>48000</code>).</li>
<li>(<code><em>channelCountMax</em></code> == <code>1</code>) || (<code><em>channelCountMax</em></code> == <code>2</code>) || (<code><em>channelCountMax</em></code> == <code>4</code> ) || (<code><em>channelCountMax</em></code> == <code>6</code>).</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 For <code><em>sampleRate</em></code>, specify the <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">nn::audio::AuxType</a></code> sample rate for which <code><em>pOutReverb</em></code> will perform effect processing. Use <code><a class="el" href="namespacenn_1_1audio.html#a2970bf3cba541e147e48d4d66d4e90b3" title="Gets the sample rate of the SendBuffer and ReturnBuffer managed by AuxType.">nn::audio::GetAuxSampleRate()</a></code> to get the sample rate. For <code><em>channelCountMax</em></code>, specify the maximum number of input channels that will be specified for <code><em>pOutReverb</em></code>. </p>

</div>
</div>
<a id="a1b01dc4e367ca2adaaf7f0c1519c481a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b01dc4e367ca2adaaf7f0c1519c481a">&#9670;&nbsp;</a></span>GetAuxI3dl2ReverbChannelCountMax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetAuxI3dl2ReverbChannelCountMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html">AuxI3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum number of channels that can be set for <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">AuxI3dl2ReverbType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>Pointer to the initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">nn::audio::AuxI3dl2ReverbType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the maximum value for the number of channels that can be set. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af47b730de287406be81a86fa4ee5730e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47b730de287406be81a86fa4ee5730e">&#9670;&nbsp;</a></span>GetAuxI3dl2ReverbInputOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::GetAuxI3dl2ReverbInputOutput </td>
          <td>(</td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>outInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>outOutput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html">AuxI3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the input/output channel index for <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">nn::audio::AuxI3dl2ReverbType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outInput</td><td>The array from which to get the indexes of the input channels set in <code><em>pReverb</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outOutput</td><td>The array from which to get the indexes of the output channels set in <code><em>pReverb</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutCount</td><td>The number of channel indexes obtained in <code><em>outInput</em></code> and <code><em>outOutput</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>Pointer to the initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">nn::audio::AuxI3dl2ReverbType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Length of the <code><em>outInput</em></code> and <code><em>outOutput</em></code> arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
<li><code><em>outInput</em></code> != <code>nullptr</code>.</li>
<li><code><em>outOutput</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutCount</em></code> != <code>nullptr</code>.</li>
<li><code><em>count</em></code> &gt; <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the channel index array specified by <code><a class="el" href="namespacenn_1_1audio.html#aae79674a28d7fcf9876bfb9a6a9ff51b" title="Sets the input/output channel indexes for nn::audio::AuxI3dl2ReverbType.">nn::audio::SetAuxI3dl2ReverbInputOutput()</a></code>. </p>

</div>
</div>
<a id="aae79674a28d7fcf9876bfb9a6a9ff51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae79674a28d7fcf9876bfb9a6a9ff51b">&#9670;&nbsp;</a></span>SetAuxI3dl2ReverbInputOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetAuxI3dl2ReverbInputOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html">AuxI3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pOutReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the input/output channel indexes for <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">nn::audio::AuxI3dl2ReverbType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutReverb</td><td>Pointer to the initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">nn::audio::AuxI3dl2ReverbType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Array of input channel indexes to set in <code><em>pOutReverb</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>Array of output channel indexes to set in <code><em>pOutReverb</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of channel indexes stored in <code><em>input</em></code> and <code><em>output</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutReverb</em></code> is initialized.</li>
<li><code><em>input</em></code> != <code>nullptr</code>.</li>
<li><code><em>output</em></code> != <code>nullptr</code>.</li>
<li>(<code><em>count</em></code> == <code>1</code>) || (<code><em>count</em></code> == <code>2</code>) || (<code><em>count</em></code> == <code>4</code>) || (<code><em>count</em></code> == <code>6</code>).</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The input samples specified for <code><em>inBuffer</em></code> using <code><a class="el" href="namespacenn_1_1audio.html#a6455a4a487adec605cd53a8bf747d3df" title="Executes the nn::audio::AuxI3dl2ReverbType effect processing.">nn::audio::ProcessAuxI3dl2Reverb()</a></code> are expected to be block interleaved. This function specifies the channels to which to apply the effects processed by <code><a class="el" href="namespacenn_1_1audio.html#a6455a4a487adec605cd53a8bf747d3df" title="Executes the nn::audio::AuxI3dl2ReverbType effect processing.">nn::audio::ProcessAuxI3dl2Reverb()</a></code>.</p>
<p>The <code>AuxI3dl2ReverbTyp</code> <code><em>input</em></code> is processed on the assumption that the input channels are in the following order. Be careful not to get the order wrong when you set <code><em>input</em></code>.</p><ul>
<li>For 2 ch: <code>FrontLeft</code>, <code>FrontRight</code>.</li>
<li>For 4 ch: <code>FrontLeft</code>, <code>FrontRight</code>, <code>RearLeft</code>, <code>RearRight</code>.</li>
<li>For 6 ch: <code>FrontLeft</code>, <code>FrontRight</code>, <code>RearLeft</code>, <code>RearRight</code>, <code>FrontCenter</code>, <code>LowFrequency</code>.</li>
</ul>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pOutReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="aae21306b8e05825ebf09acd6fa1b2176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae21306b8e05825ebf09acd6fa1b2176">&#9670;&nbsp;</a></span>SetAuxI3dl2ReverbParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetAuxI3dl2ReverbParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html">AuxI3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pOutReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_parameter_set.html">I3dl2ReverbParameterSet</a> *&#160;</td>
          <td class="paramname"><em>pParameterSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">nn::audio::AuxI3dl2ReverbType</a></code> effect parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutReverb</td><td>Pointer to the initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">nn::audio::AuxI3dl2ReverbType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pParameterSet</td><td>Effect parameters to set for <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">nn::audio::AuxI3dl2ReverbType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutReverb</em></code> is initialized.</li>
<li><code><em>pParameterSet</em></code> != <code>nullptr</code>.</li>
<li><code>-10000.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;roomGain</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;roomGain</code> &lt;= <code>0.0f</code>.</li>
<li><code>-10000.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;roomHfGain</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;roomHfGain</code> &lt;= <code>0.0f</code>.</li>
<li><code>0.1f</code> &lt;= <code><em>pParameterSet</em>-&gt;lateReverbDecayTime</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;lateReverbDecayTime</code> &lt;= <code>20.0f</code>.</li>
<li><code>0.1f</code> &lt;= <code><em>pParameterSet</em>-&gt;lateReverbHfDecayRatio</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;lateReverbHfDecayRatio</code> &lt;= <code>2.0f</code>.</li>
<li><code>-10000.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;reflectionsGain</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;reflectionsGain</code> &lt;= <code>1000.0f</code>.</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;reflectionsDelayTime</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;reflectionsDelayTime</code> &lt;= <code>0.3f</code>.</li>
<li><code>-10000.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;reverbGain</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;reverbGain</code> &lt;= <code>2000.0f</code>.</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;reverbDelayTime</code> <code>&amp;&amp; <em>pParameterSet</em>-&gt;reverbDelayTime</code> &lt;= <code>0.1f</code>.</li>
<li><code>0.1f</code> &lt;= <code><em>pParameterSet</em>-&gt;reverbDiffusion</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;reverbDiffusion</code> &lt;= <code>100.0f</code>.</li>
<li><code>0.1f</code> &lt;= <code><em>pParameterSet</em>-&gt;reverbDensity</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;reverbDensity</code> &lt;= <code>100.0f</code>.</li>
<li><code>20.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;hfReference</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;hfReference</code> &lt;= <code>20000.0f</code>.</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;dryGain</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;dryGain</code> &lt;= <code>1.0f</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 For more information about the meanings of the parameters, see I3dl2 Reverb Parameters in the <a href="../../Package/contents/Pages/Page_93362777.html">Audio Effects</a> documentation.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pOutReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="a86b88b9debda9b3cfaf064c977bc5a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b88b9debda9b3cfaf064c977bc5a4c">&#9670;&nbsp;</a></span>GetAuxI3dl2ReverbParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_parameter_set.html">I3dl2ReverbParameterSet</a> nn::audio::GetAuxI3dl2ReverbParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html">AuxI3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">nn::audio::AuxI3dl2ReverbType</a></code> effect parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>Pointer to the initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">nn::audio::AuxI3dl2ReverbType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>outParameterSet Returns the effect parameters to set. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutReverb</em></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6455a4a487adec605cd53a8bf747d3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6455a4a487adec605cd53a8bf747d3df">&#9670;&nbsp;</a></span>ProcessAuxI3dl2Reverb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::ProcessAuxI3dl2Reverb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html">AuxI3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pOutReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>outBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t *&#160;</td>
          <td class="paramname"><em>inBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>samplesPerFrame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">nn::audio::AuxI3dl2ReverbType</a></code> effect processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutReverb</td><td>Pointer to the initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">nn::audio::AuxI3dl2ReverbType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inBuffer</td><td>Buffer that stores the sample data for implementing effects. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outBuffer</td><td>Buffer that stores the effect processing results. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">samplesPerFrame</td><td>Number of samples per audio frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutReverb</em></code> is initialized.</li>
<li><code><em>inBuffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>outBuffer</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Call this function to execute the actual effect processing.</p>
<p>The contents of the buffer specified for <code><em>inBuffer</em></code> are subjected to effect processing, and the results are sent to <code><em>outBuffer</em></code>. The sample data in <code><em>inBuffer</em></code> is expected to be block interleaved. In other words, specify a buffer to the sample data obtained by the <code><a class="el" href="namespacenn_1_1audio.html#adaf2f0b6dfbaa1b020d61cd56b963965" title="Loads count number of samples from AuxType.">nn::audio::ReadAuxSendBuffer()</a></code> function. A number of samples equivalent to one frame of one channel for block interleaving are set for <code><em>samplePerFrame</em></code>. If this value was obtained by <code><a class="el" href="namespacenn_1_1audio.html#adaf2f0b6dfbaa1b020d61cd56b963965" title="Loads count number of samples from AuxType.">nn::audio::ReadAuxSendBuffer()</a></code>, it will be identical to the <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html#a1c8b7223c7e2ce641691f4e4f93000dd" title="The number of samples maintained by one mix buffer.">AudioRendererParameter.sampleCount</a></code> value.</p>
<p>This function is executed by the calling thread. This function is not thread-safe. Do not perform any operations on <code><em>pOutReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="ac0894e91a8cd9e229e7ba5561f93ff69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0894e91a8cd9e229e7ba5561f93ff69">&#9670;&nbsp;</a></span>ResetAuxI3dl2Reverb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::ResetAuxI3dl2Reverb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html">AuxI3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pOutReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the reverberation element of the <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">nn::audio::AuxI3dl2ReverbType</a></code> effect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pOutReverb</td><td>Pointer to the initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">nn::audio::AuxI3dl2ReverbType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutReverb</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Calling this function clears the state of the work buffer managed by <code><a class="el" href="structnn_1_1audio_1_1_aux_i3dl2_reverb_type.html" title="The utility of the I3dl2Reverb effect applied to nn::audio::AuxType.">nn::audio::AuxI3dl2ReverbType</a></code>, destroys the reverberation element, and then initializes. However, the effect parameters specified by the <code><a class="el" href="namespacenn_1_1audio.html#aae21306b8e05825ebf09acd6fa1b2176" title="Sets the nn::audio::AuxI3dl2ReverbType effect parameters.">nn::audio::SetAuxI3dl2ReverbParameters()</a></code> function are retained. Call this function to disable the prior effect processing input and start new effect processing.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pOutReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="a47e63c0750cec8d569c61303f760570b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e63c0750cec8d569c61303f760570b">&#9670;&nbsp;</a></span>InitializeAuxLightLimiter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::InitializeAuxLightLimiter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html">AuxLightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pOutEffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td>
          <td class="paramname"><em>lookAheadTimeMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelCountMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">nn::audio::AuxLightLimiterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutEffect</td><td>Pointer to the <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">nn::audio::AuxLightLimiterType</a></code> to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Work buffer used for <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size, in bytes, of the work buffer specified for <code><em>buffer</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lookAheadTimeMax</td><td>Maximum look-ahead time that can be set with <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleRate</td><td>Sample rate of the sample entered in <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCountMax</td><td>The maximum number of channels of the input sample for <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>buffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>bufferSize</em></code> &gt;= <a class="el" href="namespacenn_1_1audio.html#a4f7df867ca3877b8331ca0cda0dae6cd">nn::audio::GetRequiredBufferSizeForAuxLightLimiter(lookAheadTimeMax, sampleRate, channelCountMax)</a>.</li>
<li><a class="el" href="classnn_1_1_time_span.html#acce769d0612ece9d5f87d32150d1f706">nn::TimeSpan::FromMicroSeconds(0)</a> &lt;= <code><em>lookAheadTimeMax</em></code> &amp;&amp; <code><em>lookAheadTimeMax</em></code> &lt; <a class="el" href="classnn_1_1_time_span.html#acce769d0612ece9d5f87d32150d1f706">nn::TimeSpan::FromMicroSeconds(std::numeric_limits&lt;int32_t&gt;::max())</a>.</li>
<li>(<code><em>sampleRate</em></code> == <code>32000</code>) || (<code><em>sampleRate</em></code> == <code>48000</code>).</li>
<li>(<code><em>channelCountMax</em></code> == <code>1</code>) || (<code><em>channelCountMax</em></code> == <code>2</code>) || (<code><em>channelCountMax</em></code> == <code>4</code> ) || (<code><em>channelCountMax</em></code> == <code>6</code>). </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pOutEffect</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 For <code><em>sampleRate</em></code>, specify the sample rate of the <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">nn::audio::AuxType</a></code> to be the subject of the effect processing performed by <code><em>pOutEffect</em></code>. Use <code><a class="el" href="namespacenn_1_1audio.html#a2970bf3cba541e147e48d4d66d4e90b3" title="Gets the sample rate of the SendBuffer and ReturnBuffer managed by AuxType.">nn::audio::GetAuxSampleRate()</a></code> to get the sample rate. For <code><em>channelCountMax</em></code>, specify the maximum number of input channels to specify for <code><em>pOutEffect</em></code>. </p>

</div>
</div>
<a id="ac16c8dc3eb3b9ed0c12dd4cbd8fc2649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16c8dc3eb3b9ed0c12dd4cbd8fc2649">&#9670;&nbsp;</a></span>SetAuxLightLimiterInputOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetAuxLightLimiterInputOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html">AuxLightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pOutEffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the input and output channel indexes for <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">nn::audio::AuxLightLimiterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutEffect</td><td>Pointer to an initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">nn::audio::AuxLightLimiterType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Array of indexes of input channels to set for <code><em>pOutEffect</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>Array of indexes of the output channels to set for <code><em>pOutEffect</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of channel indexes stored in <code><em>input</em></code> and <code><em>output</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutEffect</em></code> is initialized.</li>
<li><code><em>input</em></code> != <code>nullptr</code>.</li>
<li><code><em>output</em></code> != <code>nullptr</code>.</li>
<li>(<code><em>count</em></code> == <code>1</code>) || (<code><em>count</em></code> == <code>2</code>) || (<code><em>count</em></code> == <code>4</code>) || (<code><em>count</em></code> == <code>6</code>).</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The input samples specified for <code><em>inBuffer</em></code> using <code><a class="el" href="namespacenn_1_1audio.html#ab4d81d89ba7c6be9675e46ef6eb65896" title="Executes the nn::audio::AuxLimiterType effect processing.">nn::audio::ProcessAuxLimiter()</a></code> are expected to be block interleaved. This function specifies the channels to which to apply the effect processing performed by <code><a class="el" href="namespacenn_1_1audio.html#aadda2ec39f13f8cdf64339978f8afe95" title="Processes the nn::audio::AuxLightLimiterType effect.">nn::audio::ProcessAuxLightLimiter()</a></code>.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pOutEffect</em></code> during the call to this function. </p>

</div>
</div>
<a id="af9774f9b25c3c675217ef2fd1a863d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9774f9b25c3c675217ef2fd1a863d9f">&#9670;&nbsp;</a></span>GetAuxLightLimiterInputOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::GetAuxLightLimiterInputOutput </td>
          <td>(</td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>outInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>outOutput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html">AuxLightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the input/output channel indexes of <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">nn::audio::AuxLightLimiterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outInput</td><td>The array from which to get the input channel indexes set for <code><em>pEffect</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outOutput</td><td>The array from which to get the output channel indexes set for <code><em>pEffect</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutCount</td><td>The number of channel indexes obtained in <code><em>outInput</em></code> and <code><em>outOutput</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>Pointer to an initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">nn::audio::AuxLightLimiterType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Length of the <code><em>outInput</em></code> and <code><em>outOutput</em></code> arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
<li><code><em>outInput</em></code> != <code>nullptr</code>.</li>
<li><code><em>outOutput</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutCount</em></code> != <code>nullptr</code>.</li>
<li><code><em>count</em></code> &gt; <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the array of channel indexes set by <code><a class="el" href="namespacenn_1_1audio.html#ac16c8dc3eb3b9ed0c12dd4cbd8fc2649" title="Sets the input and output channel indexes for nn::audio::AuxLightLimiterType.">nn::audio::SetAuxLightLimiterInputOutput()</a></code>. </p>

</div>
</div>
<a id="adedd1e7e36d502b824e198df1ae53835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adedd1e7e36d502b824e198df1ae53835">&#9670;&nbsp;</a></span>SetAuxLightLimiterParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetAuxLightLimiterParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html">AuxLightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pOutEffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_light_limiter_parameter_set.html">LightLimiterParameterSet</a> *&#160;</td>
          <td class="paramname"><em>pParameterSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">nn::audio::AuxLightLimiterType</a></code> effect parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pOutEffect</td><td>Pointer to an initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">nn::audio::AuxLightLimiterType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pParameterSet</td><td>The effect parameters set for <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">nn::audio::AuxLightLimiterType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutEffect</em></code> is initialized.</li>
<li><code><em>pParameterSet</em></code> != <code>nullptr</code>.</li>
<li><a class="el" href="classnn_1_1_time_span.html#acce769d0612ece9d5f87d32150d1f706">nn::TimeSpan::FromMicroSeconds(0)</a> &lt;= <code><em>pParameterSet</em>-&gt;attackTime</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;attackTime</code> &lt; <a class="el" href="classnn_1_1_time_span.html#acce769d0612ece9d5f87d32150d1f706">nn::TimeSpan::FromMicroSeconds(std::numeric_limits&lt;int32_t&gt;::max())</a>.</li>
<li><a class="el" href="classnn_1_1_time_span.html#acce769d0612ece9d5f87d32150d1f706">nn::TimeSpan::FromMicroSeconds(0)</a> &lt;= <code><em>pParameterSet</em>-&gt;releaseTime</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;releaseTime</code> &lt; <a class="el" href="classnn_1_1_time_span.html#acce769d0612ece9d5f87d32150d1f706">nn::TimeSpan::FromMicroSeconds(std::numeric_limits&lt;int32_t&gt;::max())</a>.</li>
<li><a class="el" href="classnn_1_1_time_span.html#acce769d0612ece9d5f87d32150d1f706">nn::TimeSpan::FromMicroSeconds(0)</a> &lt;= <code><em>pParameterSet</em>-&gt;lookAheadTime</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;lookAheadTime</code> &lt;= <a class="el" href="namespacenn_1_1audio.html#abb99ef2347d04915476de47a0173f2db">nn::audio::GetAuxLightLimiterLookAheadTimeMax(pOutEffect)</a>.</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;threshold</code>.</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;inputGain</code>.</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;outputGain</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a72b3af6bf453576de59f831c0f76a16f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b3af6bf453576de59f831c0f76a16f">&#9670;&nbsp;</a></span>GetAuxLightLimiterParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1audio_1_1_light_limiter_parameter_set.html">LightLimiterParameterSet</a> nn::audio::GetAuxLightLimiterParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html">AuxLightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">nn::audio::AuxLightLimiterType</a></code> effect parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>Pointer to an initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">nn::audio::AuxLightLimiterType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the effect parameters. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="abb99ef2347d04915476de47a0173f2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb99ef2347d04915476de47a0173f2db">&#9670;&nbsp;</a></span>GetAuxLightLimiterLookAheadTimeMax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> nn::audio::GetAuxLightLimiterLookAheadTimeMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html">AuxLightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum look-ahead time that can be set for <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">AuxLightLimiterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>Pointer to an initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">nn::audio::AuxLightLimiterType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the maximum look-ahead time that can be set. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0662825718b21c3d5bf08538b9c05b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0662825718b21c3d5bf08538b9c05b3d">&#9670;&nbsp;</a></span>GetAuxLightLimiterChannelCountMax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetAuxLightLimiterChannelCountMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html">AuxLightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum number of channels that can be set for <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">AuxLightLimiterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>Pointer to an initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">nn::audio::AuxLightLimiterType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the maximum value for the number of channels that can be set. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4f7df867ca3877b8331ca0cda0dae6cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f7df867ca3877b8331ca0cda0dae6cd">&#9670;&nbsp;</a></span>GetRequiredBufferSizeForAuxLightLimiter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::audio::GetRequiredBufferSizeForAuxLightLimiter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td>
          <td class="paramname"><em>lookAheadTimeMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelCountMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the buffer size required for using <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">nn::audio::AuxLightLimiterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lookAheadTimeMax</td><td>The maximum look-ahead time that can be set with <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">nn::audio::AuxLightLimiterType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleRate</td><td>The sample rate set for the <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">nn::audio::AuxType</a></code> that uses <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">nn::audio::AuxLightLimiterType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCountMax</td><td>The maximum number of channels that can be set for <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">nn::audio::AuxLightLimiterType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the size of the buffer. [byte] </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><a class="el" href="classnn_1_1_time_span.html#acce769d0612ece9d5f87d32150d1f706">nn::TimeSpan::FromMicroSeconds(0)</a> &lt;= <code><em>lookAheadTimeMax</em></code> &amp;&amp; <code><em>lookAheadTimeMax</em></code> &lt; <a class="el" href="classnn_1_1_time_span.html#acce769d0612ece9d5f87d32150d1f706">nn::TimeSpan::FromMicroSeconds(std::numeric_limits&lt;int32_t&gt;::max())</a>.</li>
<li>(<code><em>sampleRate</em></code> == <code>32000</code>) || (<code><em>sampleRate</em></code> == <code>48000</code>).</li>
<li>(<code><em>channelCountMax</em></code> == <code>1</code>) || (<code><em>channelCountMax</em></code> == <code>2</code>) || (<code><em>channelCountMax</em></code> == <code>4</code> ) || (<code><em>channelCountMax</em></code> == <code>6</code>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aadda2ec39f13f8cdf64339978f8afe95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadda2ec39f13f8cdf64339978f8afe95">&#9670;&nbsp;</a></span>ProcessAuxLightLimiter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::ProcessAuxLightLimiter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html">AuxLightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pOutEffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>outBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t *&#160;</td>
          <td class="paramname"><em>inBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>samplesPerFrame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Processes the <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">nn::audio::AuxLightLimiterType</a></code> effect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutEffect</td><td>Pointer to an initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">nn::audio::AuxLightLimiterType</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outBuffer</td><td>Buffer that stores the effect processing results. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inBuffer</td><td>Buffer that stores the sample data for implementing effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">samplesPerFrame</td><td>Number of samples per audio frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutEffect</em></code> is initialized.</li>
<li><code><em>inBuffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>outBuffer</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Call this function to execute the actual effect processing.</p>
<p>The contents of the buffer specified for <code><em>inBuffer</em></code> are subjected to effect processing, and the results are sent to <code><em>outBuffer</em></code>. The sample data in <code><em>inBuffer</em></code> is expected to be block interleaved. In other words, specify a buffer to the sample data obtained by the <code><a class="el" href="namespacenn_1_1audio.html#adaf2f0b6dfbaa1b020d61cd56b963965" title="Loads count number of samples from AuxType.">nn::audio::ReadAuxSendBuffer()</a></code> function. A number of samples equivalent to one frame of one channel for block interleaving are set for <code><em>samplePerFrame</em></code>. If this value was obtained by <code><a class="el" href="namespacenn_1_1audio.html#adaf2f0b6dfbaa1b020d61cd56b963965" title="Loads count number of samples from AuxType.">nn::audio::ReadAuxSendBuffer()</a></code>, it will be identical to the <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html#a1c8b7223c7e2ce641691f4e4f93000dd" title="The number of samples maintained by one mix buffer.">AudioRendererParameter.sampleCount</a></code> value.</p>
<p>This function is executed by the calling thread. This function is not thread-safe. Do not perform any operations on <code><em>pOutEffect</em></code> during the call to this function. </p>

</div>
</div>
<a id="afe82b30cd9aeae5950599034b454cb17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe82b30cd9aeae5950599034b454cb17">&#9670;&nbsp;</a></span>ResetAuxLightLimiter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::ResetAuxLightLimiter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html">AuxLightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pOutEffect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the internal state of the <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">nn::audio::AuxLightLimiterType</a></code> effect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pOutEffect</td><td>Pointer to an initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">nn::audio::AuxLightLimiterType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutEffect</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Calling this function clears and reinitializes the state of the work buffer managed by <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">nn::audio::AuxLightLimiterType</a></code>. However, the effect parameters set by the <code><a class="el" href="structnn_1_1audio_1_1_aux_light_limiter_type.html" title="Utility that applies a LightLimiter effect to nn::audio::AuxType.">nn::audio::AuxLightLimiterType()</a></code> function are retained. Call this function to disable the prior effect processing input and start new effect processing.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pOutEffect</em></code> during the call to this function. </p>

</div>
</div>
<a id="ae5fcb428ba5abc86c2e33debc02d78c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5fcb428ba5abc86c2e33debc02d78c2">&#9670;&nbsp;</a></span>InitializeAuxLimiter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::InitializeAuxLimiter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html">AuxLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pOutLimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td>
          <td class="paramname"><em>attackTimeMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td>
          <td class="paramname"><em>releaseTimeMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelCountMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutLimiter</td><td>Pointer to the <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code> to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Work buffer used for <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size, in bytes, of the work buffer specified for <code><em>buffer</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attackTimeMax</td><td>Maximum attack time that can be set with <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">releaseTimeMax</td><td>Maximum release time that can be set with <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleRate</td><td>Sample rate of the sample entered in <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCountMax</td><td>The maximum number of channels of the input sample for <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutLimiter</em></code> != <code>nullptr</code>.</li>
<li><code><em>buffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>bufferSize</em></code> &gt;= <code><a class="el" href="namespacenn_1_1audio.html#a43e2cf8c25a9738c51fe37eb83b4c109">nn::audio::GetRequiredBufferSizeForAuxLimiter</a></code> "nn::audio::GetRequiredBufferSizeForAuxLimiter(attackTime, sampleRate, channelCountMax)"</li>
<li>(<code><a class="el" href="classnn_1_1_time_span.html#a2441d3c84cc24b901342ce11f87cd39c">nn::TimeSpan::FromMilliSeconds</a></code> "nn::TimeSpan::FromMilliSeconds(0)" &lt; <code><em>attackTimeMax</em></code>) &amp;&amp; (<code><em>attackTimeMax</em></code> &lt;= <code><a class="el" href="classnn_1_1_time_span.html#a2441d3c84cc24b901342ce11f87cd39c">nn::TimeSpan::FromMilliSeconds</a></code> "nn::TimeSpan::FromMilliSeconds(300)").</li>
<li>(<code><a class="el" href="classnn_1_1_time_span.html#a2441d3c84cc24b901342ce11f87cd39c">nn::TimeSpan::FromMilliSeconds</a></code> "nn::TimeSpan::FromMilliSeconds(0)" &lt; <code><em>releaseTimeMax</em></code>) &amp;&amp; (<code><em>releaseTimeMax</em></code> &lt;= <code><a class="el" href="classnn_1_1_time_span.html#a2441d3c84cc24b901342ce11f87cd39c">nn::TimeSpan::FromMilliSeconds</a></code> "nn::TimeSpan::FromMilliSeconds(300)").</li>
<li>(<code><em>sampleRate</em></code> == <code>32000</code>) || (<code><em>sampleRate</em></code> == <code>48000</code>).</li>
<li>(<code><em>channelCountMax</em></code> == <code>1</code>) || (<code><em>channelCountMax</em></code> == <code>2</code>) || (<code><em>channelCountMax</em></code> == <code>4</code> ) || (<code><em>channelCountMax</em></code> == <code>6</code>).</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 For <code><em>sampleRate</em></code>, specify the <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">nn::audio::AuxType</a></code> sample rate for which <code><em>pOutLimiter</em></code> will perform effect processing. Use <code><a class="el" href="namespacenn_1_1audio.html#a2970bf3cba541e147e48d4d66d4e90b3" title="Gets the sample rate of the SendBuffer and ReturnBuffer managed by AuxType.">nn::audio::GetAuxSampleRate()</a></code> to get the sample rate. For <code><em>channelCountMax</em></code>, specify the maximum number of input channels that will be specified for <code><em>pOutLimiter</em></code>. </p>

</div>
</div>
<a id="a4e992c4ca9e3077076c369a3796e9c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e992c4ca9e3077076c369a3796e9c01">&#9670;&nbsp;</a></span>SetAuxLimiterInputOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetAuxLimiterInputOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html">AuxLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pLimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the input/output channel index for <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pLimiter</td><td>Pointer to the initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The array of the index of the input channel set for the <code><em>pOutLimiter</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>The array of the index of the output channel set for <code><em>pOutLimiter</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of channel indexes stored in <code><em>input</em></code> and <code><em>output</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pLimiter</em></code> != <code>nullptr</code>.</li>
<li><code><em>pLimiter</em></code> is initialized.</li>
<li><code><em>input</em></code> != <code>nullptr</code>.</li>
<li><code><em>output</em></code> != <code>nullptr</code>.</li>
<li>(<code><em>count</em></code> == <code>1</code>) || (<code><em>count</em></code> == <code>2</code>) || (<code><em>count</em></code> == <code>4</code>) || (<code><em>count</em></code> == <code>6</code>).</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The input samples specified for <code><em>inBuffer</em></code> using <code><a class="el" href="namespacenn_1_1audio.html#ab4d81d89ba7c6be9675e46ef6eb65896" title="Executes the nn::audio::AuxLimiterType effect processing.">nn::audio::ProcessAuxLimiter()</a></code> are expected to be block interleaved. This function specifies the channel to which to apply the effect processing performed by <code><a class="el" href="namespacenn_1_1audio.html#ab4d81d89ba7c6be9675e46ef6eb65896" title="Executes the nn::audio::AuxLimiterType effect processing.">nn::audio::ProcessAuxLimiter()</a></code>.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pLimiter</em></code> while calling this function. </p>

</div>
</div>
<a id="a31b0f254b61c227ed91315917e4d00bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b0f254b61c227ed91315917e4d00bf">&#9670;&nbsp;</a></span>GetAuxLimiterInputOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::GetAuxLimiterInputOutput </td>
          <td>(</td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>outInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>outOutput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html">AuxLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pLimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the input/output channel index for <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outInput</td><td>The array for which to get the index of the input channels set for <code><em>pLimiter</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outOutput</td><td>The array for which to get the index of the output channels set for <code><em>pLimiter</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutCount</td><td>The number of channel indexes obtained in <code><em>outInput</em></code> and <code><em>outOutput</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pLimiter</td><td>Pointer to the initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Length of the <code><em>outInput</em></code> and <code><em>outOutput</em></code> arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pLimiter</em></code> != <code>nullptr</code>.</li>
<li><code><em>pLimiter</em></code> is initialized.</li>
<li><code><em>outInput</em></code> != <code>nullptr</code>.</li>
<li><code><em>outOutput</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutCount</em></code> != <code>nullptr</code>.</li>
<li><code><em>count</em></code> &gt; <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the channel index array specified by <code><a class="el" href="namespacenn_1_1audio.html#a4e992c4ca9e3077076c369a3796e9c01" title="Sets the input/output channel index for nn::audio::AuxLimiterType.">nn::audio::SetAuxLimiterInputOutput()</a></code>. </p>

</div>
</div>
<a id="aa758a7f9a058db6b42b2de72c6537130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa758a7f9a058db6b42b2de72c6537130">&#9670;&nbsp;</a></span>SetAuxLimiterParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetAuxLimiterParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html">AuxLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pOutLimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_limiter_parameter_set.html">LimiterParameterSet</a> *&#160;</td>
          <td class="paramname"><em>pParameterSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code> effect parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pOutLimiter</td><td>Pointer to the initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pParameterSet</td><td>Effect parameters to set for <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutLimiter</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutLimiter</em></code> is initialized.</li>
<li><code><em>pParameterSet</em></code> != <code>nullptr</code>.</li>
<li><code><a class="el" href="classnn_1_1_time_span.html#a2441d3c84cc24b901342ce11f87cd39c">nn::TimeSpan::FromMilliSeconds</a></code> "nn::TimeSpan::FromMilliSeconds(0)" &lt; <code><em>pLimiterParamSet</em>-&gt;attackTime</code> &amp;&amp; <code><em>pLimiterParamSet</em>-&gt;attackTime</code> &lt;= <code><a class="el" href="namespacenn_1_1audio.html#a9aea93b35a8452f08527e1bacd648328">GetAuxLimiterAttackTimeMax</a></code> "GetAuxLimiterAttackTimeMax(pOutLimiter)".</li>
<li><code><a class="el" href="classnn_1_1_time_span.html#a2441d3c84cc24b901342ce11f87cd39c">nn::TimeSpan::FromMilliSeconds</a></code> "nn::TimeSpan::FromMilliSeconds(0)" &lt; <code><em>pLimiterParamSet</em>-&gt;releaseTime</code> &amp;&amp; <code><em>pLimiterParamSet</em>-&gt;releaseTime</code> &lt;= <code><a class="el" href="namespacenn_1_1audio.html#a380ede62b6c80cf2023c43dbc9387ee4">GetAuxLimiterReleaseTimeMax</a></code> "GetAuxLimiterReleaseTimeMax(pOutLimiter)".</li>
<li><code>0</code> &lt; <code><em>pLimiterParamSet</em>-&gt;threshold</code> &lt;= <code>std::numeric_limits&lt;int32_t&gt;::max()</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code><em>pParameterSet</em>-&gt;threshold</code> is a value corresponding to the <code>int32_t</code> type audio sample value handled by <code>AuxEffect</code>. For example, if you specify <code>32767</code>, <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code> works to make sure that the amplitude does not exceed this value. </p>

</div>
</div>
<a id="ae019e6dae2ad37aaac8b0e9cd0aba6da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae019e6dae2ad37aaac8b0e9cd0aba6da">&#9670;&nbsp;</a></span>GetAuxLimiterParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1audio_1_1_limiter_parameter_set.html">LimiterParameterSet</a> nn::audio::GetAuxLimiterParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html">AuxLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pLimiter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code> effect parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pLimiter</td><td>Pointer to the initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the effect parameters. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutLimiter</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutLimiter</em></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a9aea93b35a8452f08527e1bacd648328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aea93b35a8452f08527e1bacd648328">&#9670;&nbsp;</a></span>GetAuxLimiterAttackTimeMax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> nn::audio::GetAuxLimiterAttackTimeMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html">AuxLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pLimiter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum value that can be set as the attack time for <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">AuxLimiterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pLimiter</td><td>Pointer to the initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the maximum value that can be set for attack time. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pLimiter</em></code> != <code>nullptr</code>.</li>
<li><code><em>pLimiter</em></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a380ede62b6c80cf2023c43dbc9387ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380ede62b6c80cf2023c43dbc9387ee4">&#9670;&nbsp;</a></span>GetAuxLimiterReleaseTimeMax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> nn::audio::GetAuxLimiterReleaseTimeMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html">AuxLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pLimiter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum value that can be set as the release time for <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">AuxLimiterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pLimiter</td><td>Pointer to the initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the maximum value that can be set for the release time. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pLimiter</em></code> != <code>nullptr</code>.</li>
<li><code><em>pLimiter</em></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac5a0c6d9ed79bd7ab4210395e4633542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a0c6d9ed79bd7ab4210395e4633542">&#9670;&nbsp;</a></span>GetAuxLimiterChannelCountMax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetAuxLimiterChannelCountMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html">AuxLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pLimiter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum number of channels that can be set for <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">AuxLimiterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pLimiter</td><td>Pointer to the initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the maximum value for the number of channels that can be set. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pLimiter</em></code> != <code>nullptr</code>.</li>
<li><code><em>pLimiter</em></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a43e2cf8c25a9738c51fe37eb83b4c109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e2cf8c25a9738c51fe37eb83b4c109">&#9670;&nbsp;</a></span>GetRequiredBufferSizeForAuxLimiter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::audio::GetRequiredBufferSizeForAuxLimiter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td>
          <td class="paramname"><em>attackTimeMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelCountMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the buffer required to use <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">attackTimeMax</td><td>Maximum attack time that can be set with <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleRate</td><td>The sample rate set for <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">nn::audio::AuxType</a></code> which uses <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCountMax</td><td>The maximum number of channels to specify for <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the size of the buffer. [byte] </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>(<code><a class="el" href="classnn_1_1_time_span.html#a2441d3c84cc24b901342ce11f87cd39c">nn::TimeSpan::FromMilliSeconds</a></code> "nn::TimeSpan::FromMilliSeconds(0)" &lt; <code><em>attackTimeMax</em></code>) &amp;&amp; (<code><em>attackTimeMax</em></code> &lt;= <code><a class="el" href="classnn_1_1_time_span.html#a2441d3c84cc24b901342ce11f87cd39c">nn::TimeSpan::FromMilliSeconds</a></code> "nn::TimeSpan::FromMilliSeconds(300)").</li>
<li>(<code><em>sampleRate</em></code> == <code>32000</code>) || (<code><em>sampleRate</em></code> == <code>48000</code>).</li>
<li>(<code><em>channelCountMax</em></code> == <code>1</code>) || (<code><em>channelCountMax</em></code> == <code>2</code>) || (<code><em>channelCountMax</em></code> == <code>4</code> ) || (<code><em>channelCountMax</em></code> == <code>6</code>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab4d81d89ba7c6be9675e46ef6eb65896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4d81d89ba7c6be9675e46ef6eb65896">&#9670;&nbsp;</a></span>ProcessAuxLimiter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::ProcessAuxLimiter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html">AuxLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pOutLimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>outBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t *&#160;</td>
          <td class="paramname"><em>inBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>samplesPerFrame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code> effect processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutLimiter</td><td>Pointer to the initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outBuffer</td><td>Buffer that stores the effect processing results. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inBuffer</td><td>Buffer that stores the sample data for implementing effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">samplesPerFrame</td><td>Number of samples per audio frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutLimiter</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutLimiter</em></code> is initialized.</li>
<li><code><em>inBuffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>outBuffer</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Call this function to execute the actual effect processing.</p>
<p>The contents of the buffer specified for <code><em>inBuffer</em></code> are subjected to effect processing, and the results are sent to <code><em>outBuffer</em></code>. The sample data in <code><em>inBuffer</em></code> is expected to be block interleaved. In other words, specify a buffer to the sample data obtained by the <code><a class="el" href="namespacenn_1_1audio.html#adaf2f0b6dfbaa1b020d61cd56b963965" title="Loads count number of samples from AuxType.">nn::audio::ReadAuxSendBuffer()</a></code> function. A number of samples equivalent to one frame of one channel for block interleaving are set for <code><em>samplePerFrame</em></code>. If this value was obtained by <code><a class="el" href="namespacenn_1_1audio.html#adaf2f0b6dfbaa1b020d61cd56b963965" title="Loads count number of samples from AuxType.">nn::audio::ReadAuxSendBuffer()</a></code>, it will be identical to the <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html#a1c8b7223c7e2ce641691f4e4f93000dd" title="The number of samples maintained by one mix buffer.">AudioRendererParameter.sampleCount</a></code> value.</p>
<p>This function is executed by the calling thread. This function is not thread-safe. Do not perform any operations on <code><em>pOutLimiter</em></code> while calling this function. </p>

</div>
</div>
<a id="ac653792517f39a0c863c1c0a2e5e8fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac653792517f39a0c863c1c0a2e5e8fbe">&#9670;&nbsp;</a></span>ResetAuxLimiter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::ResetAuxLimiter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html">AuxLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pOutLimiter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the internal state of the <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code> effect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pOutLimiter</td><td>Pointer to an initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_delay_type.html" title="Utility for the Delay effect applied to nn::audio::AuxType.">nn::audio::AuxDelayType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutLimiter</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutLimiter</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Calling this function clears the state of the work buffer managed by <code><a class="el" href="structnn_1_1audio_1_1_aux_limiter_type.html" title="The utility of the Limiter effect applied to nn::audio::AuxType.">nn::audio::AuxLimiterType</a></code> and reinitializes. However, the effect parameters specified by the <code><a class="el" href="namespacenn_1_1audio.html#aa758a7f9a058db6b42b2de72c6537130" title="Gets the nn::audio::AuxLimiterType effect parameters.">nn::audio::SetAuxLimiterParameters()</a></code> function are retained. Call this function to disable the prior effect processing input and start new effect processing.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pOutLimiter</em></code> while calling this function. </p>

</div>
</div>
<a id="a3c8b46d68be8064cf2ca7a9a6b948f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8b46d68be8064cf2ca7a9a6b948f4a">&#9670;&nbsp;</a></span>GetRequiredBufferSizeForAuxReverb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::audio::GetRequiredBufferSizeForAuxReverb </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelCountMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of buffer required for using <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">nn::audio::AuxReverbType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleRate</td><td>The sample rate set for the <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">nn::audio::AuxType</a></code> that will use <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">nn::audio::AuxReverbType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCountMax</td><td>The maximum number of channels to specify for <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">nn::audio::AuxReverbType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the size of the buffer. [byte] </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>(<code><em>sampleRate</em></code> == <code>32000</code>) || (<code><em>sampleRate</em></code> == <code>48000</code>).</li>
<li>(<code><em>channelCountMax</em></code> == <code>1</code>) || (<code><em>channelCountMax</em></code> == <code>2</code>) || (<code><em>channelCountMax</em></code> == <code>4</code> ) || (<code><em>channelCountMax</em></code> == <code>6</code>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4a66d864ded702393bf65a1a8d1f3ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a66d864ded702393bf65a1a8d1f3ff5">&#9670;&nbsp;</a></span>InitializeAuxReverb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::InitializeAuxReverb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html">AuxReverbType</a> *&#160;</td>
          <td class="paramname"><em>pOutReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelCountMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">nn::audio::AuxReverbType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutReverb</td><td>Pointer to the <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">nn::audio::AuxReverbType</a></code> to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The work buffer to use with <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">nn::audio::AuxReverbType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size, in bytes, of the work buffer specified for <code><em>buffer</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleRate</td><td>The sample rate for the samples that will serve as input to <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">nn::audio::AuxReverbType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCountMax</td><td>The number of channels for the samples that will serve as input to <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">nn::audio::AuxReverbType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>buffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>bufferSize</em></code> &gt;= <code><a class="el" href="namespacenn_1_1audio.html#a3c8b46d68be8064cf2ca7a9a6b948f4a">nn::audio::GetRequiredBufferSizeForAuxReverb(sampleRate, channelCountMax)</a></code>.</li>
<li>(<code><em>sampleRate</em></code> == <code>32000</code>) || (<code><em>sampleRate</em></code> == <code>48000</code>).</li>
<li>(<code><em>channelCountMax</em></code> == <code>1</code>) || (<code><em>channelCountMax</em></code> == <code>2</code>) || (<code><em>channelCountMax</em></code> == <code>4</code> ) || (<code><em>channelCountMax</em></code> == <code>6</code>).</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 For <code><em>sampleRate</em></code>, specify the <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">nn::audio::AuxType</a></code> sample rate for which <code><em>pOutReverb</em></code> will perform effect processing. Use <code><a class="el" href="namespacenn_1_1audio.html#a2970bf3cba541e147e48d4d66d4e90b3" title="Gets the sample rate of the SendBuffer and ReturnBuffer managed by AuxType.">nn::audio::GetAuxSampleRate()</a></code> to get the sample rate. For <code><em>channelCountMax</em></code>, specify the maximum number of input channels that will be specified for <code><em>pOutReverb</em></code>. </p>

</div>
</div>
<a id="aeea1a1571158d877e27a9d7c9676ad5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea1a1571158d877e27a9d7c9676ad5f">&#9670;&nbsp;</a></span>GetAuxReverbChannelCountMax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetAuxReverbChannelCountMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html">AuxReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum number of channels that can be set for <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">AuxReverbType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>A pointer to an initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">nn::audio::AuxReverbType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the maximum value for the number of channels that can be set. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a298b3fbc0ea1677b3cfc8aeedc7e1ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a298b3fbc0ea1677b3cfc8aeedc7e1ba7">&#9670;&nbsp;</a></span>GetAuxReverbInputOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::GetAuxReverbInputOutput </td>
          <td>(</td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>outInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>outOutput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html">AuxReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">nn::audio::AuxReverbType</a></code> input/output channel indexes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outInput</td><td>The array from which to get the indexes of the input channels set in <code><em>pReverb</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outOutput</td><td>The array from which to get the indexes of the output channels set in <code><em>pReverb</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutCount</td><td>The number of channel indexes obtained in <code><em>outInput</em></code> and <code><em>outOutput</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>A pointer to an initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">nn::audio::AuxReverbType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Length of the <code><em>outInput</em></code> and <code><em>outOutput</em></code> arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
<li><code><em>outInput</em></code> != <code>nullptr</code>.</li>
<li><code><em>outOutput</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutCount</em></code> != <code>nullptr</code>.</li>
<li><code><em>count</em></code> &gt; <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the arrays of channel indexes specified by the <code><a class="el" href="namespacenn_1_1audio.html#a0f356593e701e68767f89243e7ae777e" title="Sets the nn::audio::AuxReverbType input/output channel indexes.">nn::audio::SetAuxReverbInputOutput()</a></code> function. </p>

</div>
</div>
<a id="a0f356593e701e68767f89243e7ae777e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f356593e701e68767f89243e7ae777e">&#9670;&nbsp;</a></span>SetAuxReverbInputOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetAuxReverbInputOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html">AuxReverbType</a> *&#160;</td>
          <td class="paramname"><em>pOutReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">nn::audio::AuxReverbType</a></code> input/output channel indexes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutReverb</td><td>A pointer to an initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">nn::audio::AuxReverbType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Array of input channel indexes to set in <code><em>pOutReverb</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>Array of output channel indexes to set in <code><em>pOutReverb</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of channel indexes stored in <code><em>input</em></code> and <code><em>output</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutReverb</em></code> is initialized.</li>
<li><code><em>input</em></code> != <code>nullptr</code>.</li>
<li><code><em>output</em></code> != <code>nullptr</code>.</li>
<li>(<code><em>count</em></code> == <code>1</code>) || (<code><em>count</em></code> == <code>2</code>) || (<code><em>count</em></code> == <code>4</code>) || (<code><em>count</em></code> == <code>6</code>).</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The input samples specified for <code><em>inBuffer</em></code> by the <code><a class="el" href="namespacenn_1_1audio.html#afc918bae3e4385df2cebbfa4befda66b" title="Executes the nn::audio::AuxReverbType effect processing.">nn::audio::ProcessAuxReverb()</a></code> function are expected to be block-interleaved. This function specifies the channels to which to apply the effect processing performed by <code><a class="el" href="namespacenn_1_1audio.html#afc918bae3e4385df2cebbfa4befda66b" title="Executes the nn::audio::AuxReverbType effect processing.">nn::audio::ProcessAuxReverb()</a></code>.</p>
<p>The <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">AuxReverbType</a></code> <code><em>input</em></code> is processed on the assumption that input channels are in the following order. Be careful not to get the order wrong when you set <code><em>input</em></code>.</p><ul>
<li>For 2 ch: <code>FrontLeft</code>, <code>FrontRight</code>.</li>
<li>For 4 ch: <code>FrontLeft</code>, <code>FrontRight</code>, <code>RearLeft</code>, <code>RearRight</code>.</li>
<li>For 6 ch: <code>FrontLeft</code>, <code>FrontRight</code>, <code>RearLeft</code>, <code>RearRight</code>, <code>FrontCenter</code>, <code>LowFrequency</code>.</li>
</ul>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pOutReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="a3193c0f8fd5d1849ef1223497b103681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3193c0f8fd5d1849ef1223497b103681">&#9670;&nbsp;</a></span>GetAuxReverbParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1audio_1_1_reverb_parameter_set.html">ReverbParameterSet</a> nn::audio::GetAuxReverbParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html">AuxReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">nn::audio::AuxReverbType</a></code> effect parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>A pointer to an initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">nn::audio::AuxReverbType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>outParameterSet Returns the effect parameters to set. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutReverb</em></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a7c4a7aad7e1bf499f3f8025829aae95c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4a7aad7e1bf499f3f8025829aae95c">&#9670;&nbsp;</a></span>SetAuxReverbParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetAuxReverbParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html">AuxReverbType</a> *&#160;</td>
          <td class="paramname"><em>pOutReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_reverb_parameter_set.html">nn::audio::ReverbParameterSet</a> *&#160;</td>
          <td class="paramname"><em>pParameterSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">nn::audio::AuxReverbType</a></code> effect parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutReverb</td><td>A pointer to an initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">nn::audio::AuxReverbType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pParameterSet</td><td>The effect parameter to set to <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">nn::audio::AuxReverbType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutReverb</em></code> is initialized.</li>
<li><code><em>pParameterSet</em></code> != <code>nullptr</code>.</li>
<li><code><em>pParameterSet</em>-&gt;earlyMode</code> == <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html#aba28878a06e614f8cfcebe12af7e0d50ad629d54d436cb80e20f34d86470eed66" title="Small room.">nn::audio::ReverbType::EarlyMode_SmallRoom</a></code> || <code><em>pParameterSet</em>-&gt;earlyMode</code> == <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html#aba28878a06e614f8cfcebe12af7e0d50a69b68a59615af3d2e469260d95d86422" title="Large room.">nn::audio::ReverbType::EarlyMode_LargeRoom</a></code> || <code><em>pParameterSet</em>-&gt;earlyMode</code> == <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html#aba28878a06e614f8cfcebe12af7e0d50a54a457d567a728bc8acc9b75d4b9abcf" title="Performance hall.">nn::audio::ReverbType::EarlyMode_Hall</a></code> || <code><em>pParameterSet</em>-&gt;earlyMode</code> == <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html#aba28878a06e614f8cfcebe12af7e0d50aa0e028d716bc5af9f4662f2a8885bde7" title="Cave.">nn::audio::ReverbType::EarlyMode_Cavern</a></code> || <code><em>pParameterSet</em>-&gt;earlyMode</code> == <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html#aba28878a06e614f8cfcebe12af7e0d50a0fe9e909d773e66cc9886c3d842d4d4f" title="No early reflected sound.">nn::audio::ReverbType::EarlyMode_NoEarlyReflection</a></code></li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;earlyGain</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;earlyGain</code> &lt;= <code>1.0f</code>.</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;predelayTimeMilliSeconds</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;predelayTimeMilliSeconds</code> &lt;= <code>300.0f</code>.</li>
<li><code><em>pParameterSet</em>-&gt;lateMode</code> == <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html#a180b7274e24a924de18f2523852626aca60625a2757218a65017a5043492501ee" title="Room.">nn::audio::ReverbType::LateMode_Room</a></code> || <code><em>pParameterSet</em>-&gt;lateMode</code> == <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html#a180b7274e24a924de18f2523852626aca405e9d554d53f558b74d7c8f8f5df846" title="Performance hall.">nn::audio::ReverbType::LateMode_Hall</a></code> || <code><em>pParameterSet</em>-&gt;lateMode</code> == <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html#a180b7274e24a924de18f2523852626aca727a8f7f82afb3d0a702b62312155943" title="Metal corridor.">nn::audio::ReverbType::LateMode_MetalCorridor</a></code> || <code><em>pParameterSet</em>-&gt;lateMode</code> == <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html#a180b7274e24a924de18f2523852626aca6aff777a5b8d8fcc5cad1de1ef9a928c" title="Cave.">nn::audio::ReverbType::LateMode_Cavern</a></code> || <code><em>pParameterSet</em>-&gt;lateMode</code> == <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html#a180b7274e24a924de18f2523852626aca999c1aa5d34604baf3754ea3226a938a" title="Maximum delay (reverb).">nn::audio::ReverbType::LateMode_MaximumDelay</a></code></li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;lateGain</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;lateGain</code> &lt;= <code>1.0f</code>.</li>
<li><code>0.1f</code> &lt;= <code><em>pParameterSet</em>-&gt;decayTimeSeconds</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;decayTimeSeconds</code> &lt;= <code>20.0f</code>.</li>
<li><code>0.1f</code> &lt;= <code><em>pParameterSet</em>-&gt;highFreqDecayRatio</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;highFreqDecayRatio</code> &lt;= <code>1.0f</code>.</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;coloration</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;coloration</code> &lt;= <code>1.0f</code>.</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;reverbGain</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;reverbGain</code> &lt;= <code>1.0f</code>.</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;outGain</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;outGain</code> &lt;= <code>1.0f</code>.</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;dryGain</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;dryGain</code> &lt;= <code>1.0f</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 For more information about the meanings of the parameters, see Reverb Parameters in the <a href="../../Package/contents/Pages/Page_93362777.html">Audio Effects</a> documentation.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pOutReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="afc918bae3e4385df2cebbfa4befda66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc918bae3e4385df2cebbfa4befda66b">&#9670;&nbsp;</a></span>ProcessAuxReverb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::ProcessAuxReverb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html">AuxReverbType</a> *&#160;</td>
          <td class="paramname"><em>pOutReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>outBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t *&#160;</td>
          <td class="paramname"><em>inBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>samplesPerFrame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">nn::audio::AuxReverbType</a></code> effect processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutReverb</td><td>A pointer to an initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">nn::audio::AuxReverbType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inBuffer</td><td>Buffer that stores the sample data for implementing effects. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outBuffer</td><td>Buffer that stores the effect processing results. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">samplesPerFrame</td><td>Number of samples per audio frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutReverb</em></code> is initialized.</li>
<li><code><em>inBuffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>outBuffer</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Call this function to execute the actual effect processing.</p>
<p>The contents of the buffer specified for <code><em>inBuffer</em></code> are subjected to effect processing, and the results are sent to <code><em>outBuffer</em></code>. The sample data in <code><em>inBuffer</em></code> is expected to be block interleaved. In other words, specify a buffer to the sample data obtained by the <code><a class="el" href="namespacenn_1_1audio.html#adaf2f0b6dfbaa1b020d61cd56b963965" title="Loads count number of samples from AuxType.">nn::audio::ReadAuxSendBuffer()</a></code> function. A number of samples equivalent to one frame of one channel for block interleaving are set for <code><em>samplePerFrame</em></code>. If this value was obtained by <code><a class="el" href="namespacenn_1_1audio.html#adaf2f0b6dfbaa1b020d61cd56b963965" title="Loads count number of samples from AuxType.">nn::audio::ReadAuxSendBuffer()</a></code>, it will be identical to the <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html#a1c8b7223c7e2ce641691f4e4f93000dd" title="The number of samples maintained by one mix buffer.">AudioRendererParameter.sampleCount</a></code> value.</p>
<p>This function is executed by the calling thread. This function is not thread-safe. Do not perform any operations on <code><em>pOutReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="acf8974b91abe2ba832ea9e0b5202462d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf8974b91abe2ba832ea9e0b5202462d">&#9670;&nbsp;</a></span>ResetAuxReverb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::ResetAuxReverb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html">AuxReverbType</a> *&#160;</td>
          <td class="paramname"><em>pOutReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the reverberation component of the <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">nn::audio::AuxReverbType</a></code> effect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pOutReverb</td><td>A pointer to an initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">nn::audio::AuxReverbType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutReverb</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Calling this function clears the state of the work buffer managed by <code><a class="el" href="structnn_1_1audio_1_1_aux_reverb_type.html" title="Utility for reverb effects applying to nn::audio::AuxType.">nn::audio::AuxReverbType</a></code>, destroys the reverberation component, and then re-initializes. The effect parameter specified by the <code><a class="el" href="namespacenn_1_1audio.html#a7c4a7aad7e1bf499f3f8025829aae95c" title="Sets the nn::audio::AuxReverbType effect parameter.">nn::audio::SetAuxReverbParameters()</a></code> is retained. Call this function to disable the prior effect processing input and start new effect processing.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pOutReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="a154b8f763869f00d19eb611df3434a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a154b8f763869f00d19eb611df3434a77">&#9670;&nbsp;</a></span>GetActiveAudioOutputDeviceName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::GetActiveAudioOutputDeviceName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_device_name.html">AudioDeviceName</a> *&#160;</td>
          <td class="paramname"><em>pOutDeviceName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the name of the device to which audio is currently being output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pOutDeviceName</td><td>Buffer for getting the device name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDeviceName</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the name of the device to which audio is being output at the time that this function is called. You can determine the timing of a switch in the output line from one device to another by checking the <code><a class="el" href="classnn_1_1os_1_1_system_event.html" title="Class for handling system events.">nn::os::SystemEvent</a></code> registered in <code><a class="el" href="namespacenn_1_1audio.html#adb316babd47fa36c30a8d4747c64860a" title="Gets events that provide notification of the occurrence of audio output device events.">nn::audio::AcquireAudioDeviceNotificationForOutput()</a></code>. If the audio output line is switched during the call to this function, the function will return the name of the device to which audio was output prior to the switch. By checking whether the <code><a class="el" href="classnn_1_1os_1_1_system_event.html" title="Class for handling system events.">nn::os::SystemEvent</a></code> object registered in <code><a class="el" href="namespacenn_1_1audio.html#adb316babd47fa36c30a8d4747c64860a" title="Gets events that provide notification of the occurrence of audio output device events.">nn::audio::AcquireAudioDeviceNotificationForOutput()</a></code> has been signaled after this function has been called, you can determine whether the output line was changed during the call.</p>
<p>The name returned to <code><em>pOutDeviceName</em></code> must be a kind of name that can be obtained by the <code><a class="el" href="namespacenn_1_1audio.html#ad90597870d6de0b335ac9344f728a59b" title="Gets the supported device list for the platform.">nn::audio::ListAudioOutputDeviceName()</a></code> function. Note that the names that are returned will differ depending on the platform. For the specific lists of output devices that can be used with each platform, see the description in <a href="../../Package/contents/Pages/Page_166500119.html">audio Library</a>in NintendoSDK Documents.</p>
<div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
<ul>
<li>The processing for this function can take time, so after the device name has been obtained for the first time, we recommend calling this function only when the event is signaled.</li>
</ul>
</div><div class="platform_section" data-platform="NX"></div><div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
<ul>
<li>This function is not supported in the Windows environment. Nothing is written to <code><em>pOutDeviceName</em></code>.</li>
</ul>
</div><div class="platform_section" data-platform="Windows"></div> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a124">AudioDevice/AudioDevice.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="afc1dc98d9291c9b9a24a329000fe04b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1dc98d9291c9b9a24a329000fe04b5">&#9670;&nbsp;</a></span>GetActiveAudioDeviceName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::GetActiveAudioDeviceName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_device_name.html">AudioDeviceName</a> *&#160;</td>
          <td class="paramname"><em>pOutDeviceName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is deprecated. </p>
<p>Please check the details for usage conditions and substitute functions. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated:</a></b></dt><dd>This function has been deprecated. We recommend using the <code><a class="el" href="namespacenn_1_1audio.html#a154b8f763869f00d19eb611df3434a77" title="Gets the name of the device to which audio is currently being output.">nn::audio::GetActiveAudioOutputDeviceName()</a></code> function instead. </dd></dl>
<p>Gets the name of the device to which audio is currently being output. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pOutDeviceName</td><td>Buffer for getting the device name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDeviceName</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the name of the device to which audio is being output at the time that this function is called. You can determine the timing of a switch in the output line from one device to another by checking the <code><a class="el" href="classnn_1_1os_1_1_system_event.html" title="Class for handling system events.">nn::os::SystemEvent</a></code> registered in <code><a class="el" href="namespacenn_1_1audio.html#adb316babd47fa36c30a8d4747c64860a" title="Gets events that provide notification of the occurrence of audio output device events.">nn::audio::AcquireAudioDeviceNotificationForOutput()</a></code>. If the audio output line is switched during the call to this function, the function will return the name of the device to which audio was output prior to the switch. By checking whether the <code><a class="el" href="classnn_1_1os_1_1_system_event.html" title="Class for handling system events.">nn::os::SystemEvent</a></code> object registered in <code><a class="el" href="namespacenn_1_1audio.html#adb316babd47fa36c30a8d4747c64860a" title="Gets events that provide notification of the occurrence of audio output device events.">nn::audio::AcquireAudioDeviceNotificationForOutput()</a></code> has been signaled after this function has been called, you can determine whether the output line was changed during the call.</p>
<p>The named returned to <code><em>pOutDeviceName</em></code> is always some name that can be obtained using <code><a class="el" href="namespacenn_1_1audio.html#a55647cb74f20480d980354a8dc7f0907" title="This function is deprecated.">nn::audio::ListAudioDeviceName()</a></code>. Note that the names that are returned will differ depending on the platform.</p>
<div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
<ul>
<li>The processing for this function can take time, so after the device name has been obtained for the first time, we recommend calling this function only when the event is signaled.</li>
</ul>
</div><div class="platform_section" data-platform="NX"></div><div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
<ul>
<li>This function is not supported in the Windows environment. Nothing is written to <code><em>pOutDeviceName</em></code>.</li>
</ul>
</div><div class="platform_section" data-platform="Windows"></div> 
</div>
</div>
<a id="adb316babd47fa36c30a8d4747c64860a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb316babd47fa36c30a8d4747c64860a">&#9670;&nbsp;</a></span>AcquireAudioDeviceNotificationForOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::audio::AcquireAudioDeviceNotificationForOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1os_1_1_system_event.html">nn::os::SystemEvent</a> *&#160;</td>
          <td class="paramname"><em>pOutSystemEvent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets events that provide notification of the occurrence of audio output device events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSystemEvent</td><td>The <code><a class="el" href="classnn_1_1os_1_1_system_event.html" title="Class for handling system events.">nn::os::SystemEvent</a></code> signaled when the event occurs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_operation_failed.html">nn::audio::ResultOperationFailed</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutSystemEvent</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutSystemEvent</em></code> is not initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pOutSystemEvent</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code><em>pOutSystemEvent</em></code> is initialized as an event that is signaled when an audio output device event occurs. <code><em>pOutSystemEvent</em></code> is signaled every time an audio output device event occurs. The platform determines what kinds of event notifications can be received.</p>
<p><code><em>pOutSystemEvent</em></code> is initialized to <code><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a31f6133098296b3ddb7e14da3dc695cc" title="Automatically cleared event.">nn::os::EventClearMode_AutoClear</a></code>.</p>
<p>You cannot call this function more than once. Calls after the first call return a failure and SystemEvent will not be initialized.</p>
<div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
<ul>
<li>In the NX environment, switches in the audio output line and changes in the number of output channels can be received as events. By waiting for this event to be signaled and then calling the <code><a class="el" href="namespacenn_1_1audio.html#a154b8f763869f00d19eb611df3434a77" title="Gets the name of the device to which audio is currently being output.">nn::audio::GetActiveAudioOutputDeviceName()</a></code> function, you can get the name of the device to which the audio output has been switched. Note, however, that there a possibility of the audio output line being switched again while <code><a class="el" href="namespacenn_1_1audio.html#a154b8f763869f00d19eb611df3434a77" title="Gets the name of the device to which audio is currently being output.">nn::audio::GetActiveAudioOutputDeviceName()</a></code> is getting the device name. For more information, see <code><a class="el" href="namespacenn_1_1audio.html#a154b8f763869f00d19eb611df3434a77" title="Gets the name of the device to which audio is currently being output.">nn::audio::GetActiveAudioOutputDeviceName()</a></code>.</li>
</ul>
</div><div class="platform_section" data-platform="NX"> In the same way, by waiting for this event to be signaled and then calling the <code><a class="el" href="namespacenn_1_1audio.html#a3ca25bfcda5285cd394b9abbb6149eb2" title="Gets the number of channels output from the audio output device.">nn::audio::GetActiveAudioDeviceChannelCountForOutput()</a></code> function, you can get the number of audio output channels after the change. Note, however, that there a possibility that the number of output channels will be changed again by a user operation while the <code><a class="el" href="namespacenn_1_1audio.html#a3ca25bfcda5285cd394b9abbb6149eb2" title="Gets the number of channels output from the audio output device.">nn::audio::GetActiveAudioDeviceChannelCountForOutput()</a></code> function is getting the output channel count. For more information, see the description of <code><a class="el" href="namespacenn_1_1audio.html#a3ca25bfcda5285cd394b9abbb6149eb2" title="Gets the number of channels output from the audio output device.">nn::audio::GetActiveAudioDeviceChannelCountForOutput()</a></code>.</div><div class="platform_section" data-platform="NX"></div><div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
<ul>
<li>This function is not supported in the Windows environment. <code><em>pOutSystemEvent</em></code> is not initialized.</li>
</ul>
</div><div class="platform_section" data-platform="Windows"></div> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a116">AudioDevice/AudioDevice.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aa780020ea9e44b78f43a0ee8148f9569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa780020ea9e44b78f43a0ee8148f9569">&#9670;&nbsp;</a></span>AcquireAudioDeviceNotificationForInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::audio::AcquireAudioDeviceNotificationForInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1os_1_1_system_event.html">nn::os::SystemEvent</a> *&#160;</td>
          <td class="paramname"><em>pOutSystemEvent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets events that provide notification of the occurrence of events of the device that is the source of the audio input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSystemEvent</td><td>The <code><a class="el" href="classnn_1_1os_1_1_system_event.html" title="Class for handling system events.">nn::os::SystemEvent</a></code> signaled when the event occurs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_operation_failed.html">nn::audio::ResultOperationFailed</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutSystemEvent</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutSystemEvent</em></code> is not initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pOutSystemEvent</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code><em>pOutSystemEvent</em></code> is initialized as an event that is signaled when an event occurs in the device that is the source of the audio input. <code><em>pOutSystemEvent</em></code> is signaled every time an event occurs in the device that is the source of the audio input. The platform determines what kinds of event notifications can be received.</p>
<p><code><em>pOutSystemEvent</em></code> is initialized to <code><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a31f6133098296b3ddb7e14da3dc695cc" title="Automatically cleared event.">nn::os::EventClearMode_AutoClear</a></code>.</p>
<p>You cannot call this function more than once. Calls after the first call return a failure and SystemEvent will not be initialized.</p>
<div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
<ul>
<li>In the NX environment, the switching of the device that is the source of the audio input can be received as an event.</li>
</ul>
</div><div class="platform_section" data-platform="NX"></div><div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
<ul>
<li>This function is not supported in the Windows environment. <code><em>pOutSystemEvent</em></code> is not initialized.</li>
</ul>
</div><div class="platform_section" data-platform="Windows"></div> 
</div>
</div>
<a id="a3ca25bfcda5285cd394b9abbb6149eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca25bfcda5285cd394b9abbb6149eb2">&#9670;&nbsp;</a></span>GetActiveAudioDeviceChannelCountForOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetActiveAudioDeviceChannelCountForOutput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of channels output from the audio output device. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of output channels.</dd></dl>
<p> <b>Details</b> <br  />
 When this function is called, gets the number of channels output from the audio output device.</p>
<div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
<ul>
<li>In the NX environment, you can determine whether the number of channels has changed by checking whether the <code><a class="el" href="classnn_1_1os_1_1_system_event.html" title="Class for handling system events.">nn::os::SystemEvent</a></code> object registered in <code><a class="el" href="namespacenn_1_1audio.html#adb316babd47fa36c30a8d4747c64860a" title="Gets events that provide notification of the occurrence of audio output device events.">nn::audio::AcquireAudioDeviceNotificationForOutput()</a></code> has been signaled after this function was called. The processing for this function can take time, so after the channel count has been obtained for the first time, we recommend calling this function only when the event is signaled.</li>
</ul>
</div><div class="platform_section" data-platform="NX"></div><div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
<ul>
<li>This function is not supported in the Windows environment. Always returns <code>0</code>.</li>
</ul>
</div><div class="platform_section" data-platform="Windows"></div> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a125">AudioDevice/AudioDevice.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad90597870d6de0b335ac9344f728a59b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90597870d6de0b335ac9344f728a59b">&#9670;&nbsp;</a></span>ListAudioOutputDeviceName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::ListAudioOutputDeviceName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_device_name.html">AudioDeviceName</a> *&#160;</td>
          <td class="paramname"><em>outDeviceNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the supported device list for the platform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outDeviceNames</td><td>Buffer for getting the device name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of <code><a class="el" href="structnn_1_1audio_1_1_audio_device_name.html" title="The structure representing the names of the devices supported by the platform.">AudioDeviceName</a></code> that can be obtained with <code><em>outDeviceNames</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of devices obtained by <code><em>outDeviceNames</em></code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>outDeviceNames</em></code> != <code>nullptr</code>.</li>
<li><code>0</code> &lt;= <code><em>count</em></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>For a return value of <code><em>n</em></code>, device names are written from <code><em>outDeviceNames</em>[0]</code> to <code><em>outDeviceNames</em>[<em>n</em>1]</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The devices that are output by audio are different depending on the platform that executes the application. Of the devices connected to the platform executing the application, this function only gets the list of output devices that can be used by the NintendoSDK.</p>
<p>For the specific lists of output devices that can be used with each platform, see the description in <a href="../../Package/contents/Pages/Page_166500119.html">audio Library</a>in NintendoSDK Documents.</p>
<p>The <code><em>outDeviceNames</em></code> obtained by this function can be used to set the master output volume for each device using <code><a class="el" href="namespacenn_1_1audio.html#a70fb7f5f687932689399a44c0da8d206" title="Sets the volume for the output destination device.">nn::audio::SetAudioDeviceOutputVolume()</a></code>.</p>
<div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
<ul>
<li>In the Windows environment, this function returns the names and quantity of devices connected to the PC.</li>
</ul>
</div><div class="platform_section" data-platform="Windows"></div> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a117">AudioDevice/AudioDevice.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a55647cb74f20480d980354a8dc7f0907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55647cb74f20480d980354a8dc7f0907">&#9670;&nbsp;</a></span>ListAudioDeviceName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::ListAudioDeviceName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_device_name.html">AudioDeviceName</a> *&#160;</td>
          <td class="paramname"><em>outDeviceNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is deprecated. </p>
<p>Please check the details for usage conditions and substitute functions. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000012">Deprecated:</a></b></dt><dd>This function has been deprecated. We recommend using the <code><a class="el" href="namespacenn_1_1audio.html#ad90597870d6de0b335ac9344f728a59b" title="Gets the supported device list for the platform.">nn::audio::ListAudioOutputDeviceName()</a></code> function instead, which has the same features. </dd></dl>
<p>Gets the supported device list for the platform. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outDeviceNames</td><td>Buffer for getting the device name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of <code><a class="el" href="structnn_1_1audio_1_1_audio_device_name.html" title="The structure representing the names of the devices supported by the platform.">AudioDeviceName</a></code> that can be obtained with <code><em>outDeviceNames</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of devices obtained by <code><em>outDeviceNames</em></code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>outDeviceNames</em></code> != <code>nullptr</code>.</li>
<li><code>0</code> &lt;= <code><em>count</em></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>For a return value of <code><em>n</em></code>, device names are written from <code><em>outDeviceNames</em>[0]</code> to <code><em>outDeviceNames</em>[<em>n</em>1]</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The devices that are output by audio are different depending on the platform that executes the application. Of the devices connected to the platform executing the application, this function only gets the list of output devices that can be used by the NintendoSDK.</p>
<div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
<ul>
<li>In the Windows environment, this function returns the names and quantity of devices connected to the PC.</li>
</ul>
</div><div class="platform_section" data-platform="Windows"></div> 
</div>
</div>
<a id="a70fb7f5f687932689399a44c0da8d206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70fb7f5f687932689399a44c0da8d206">&#9670;&nbsp;</a></span>SetAudioDeviceOutputVolume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetAudioDeviceOutputVolume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_device_name.html">AudioDeviceName</a> *&#160;</td>
          <td class="paramname"><em>pDeviceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>volume</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the volume for the output destination device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDeviceName</td><td>Name of the device supported by the platform. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">volume</td><td>Volume value to be configured.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDeviceName</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDeviceName</em></code> is included among the devices obtained by <code><a class="el" href="namespacenn_1_1audio.html#a55647cb74f20480d980354a8dc7f0907" title="This function is deprecated.">nn::audio::ListAudioDeviceName()</a></code>.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a8856c8538ff8d63185bea7fdea3f67a9" title="The minimum volume that can be specified for SetAudioDeviceOutputVolume().">nn::audio::AudioDeviceOutputVolumeMin</a></code> &lt;= <code><em>volume</em></code>&lt;= <code><a class="el" href="namespacenn_1_1audio.html#ab18679875f7f41c4912503c1738e36b9" title="The maximum volume that can be specified for SetAudioDeviceOutputVolume().">nn::audio::AudioDeviceOutputVolumeMax</a></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>volume</em></code> == <a class="el" href="namespacenn_1_1audio.html#ae46f887f6bbd8c3ed7232932cb86ece0">nn::audio::GetAudioDeviceOutputVolume(pDeviceName)</a>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sets the volume for each output destination device. If you have prepared audio output using <code><a class="el" href="namespacenn_1_1audio.html#a7d4ddedf1f043b725b4e3a5236a05417" title="Initializes the default audio output and gets an accessor.">nn::audio::OpenDefaultAudioOut()</a></code>, or prepared a <code>SinkType</code> for audio output devices by specifying <code>MainAudioOut</code> in <code><a class="el" href="namespacenn_1_1audio.html#ae8e93a633168c40c9b716c88c49c5e47" title="Initializes a sink for the audio output device.">nn::audio::AddDeviceSink()</a></code>, the audio is sent to the standard output destinations, based on the operating state of the application and the platform. This function provides the feature for setting the volume separately for these different output destinations.</p>
<p>The purpose of this function is to set the volume individually for each device, so do not use this function for device-independent volume controls. To configure device-independent volume settings, consider using the <code><a class="el" href="namespacenn_1_1audio.html#ac9768fb1e31dd0bcf4c28a4e7dae42da" title="Sets the volume for AudioOut.">nn::audio::SetAudioOutVolume()</a></code> function for audio output, and the <code><a class="el" href="namespacenn_1_1audio.html#af6d0a1908dd4668211b26270705b9ba1" title="Sets the volume for the FinalMixType object.">nn::audio::SetFinalMixVolume()</a></code> function for the audio renderer.</p>
<p>For <code><em>pDeviceName</em></code>, you can specify a device obtained by <code><a class="el" href="namespacenn_1_1audio.html#ad90597870d6de0b335ac9344f728a59b" title="Gets the supported device list for the platform.">nn::audio::ListAudioOutputDeviceName()</a></code>. For the specific lists of output devices that can be used for each platform, see Features &gt; Audio Library section in <em>NintendoSDK documents</em>.</p>
<p>If multiple outputs such as audio renderer and audio out exist in the device specified by <code><em>pDeviceName</em></code>, it applies the volume to all of the input results.</p>
<p>If this function was not called even once, the initial value is set to <code>1.0f</code> regardless of the device.</p>
<p>The volume settings for this function are only effective internally for the application that called the function. It does not affect the behavior of the system.</p>
<div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
<ul>
<li>This function is not supported in the Windows environment. The call to this function always succeeds, but it does not alter the behavior of the application.</li>
</ul>
</div><div class="platform_section" data-platform="Windows"></div> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a128">AudioDevice/AudioDevice.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae46f887f6bbd8c3ed7232932cb86ece0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46f887f6bbd8c3ed7232932cb86ece0">&#9670;&nbsp;</a></span>GetAudioDeviceOutputVolume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetAudioDeviceOutputVolume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_device_name.html">AudioDeviceName</a> *&#160;</td>
          <td class="paramname"><em>pDeviceName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the volume of the output destination device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDeviceName</td><td>Name of the output destination device that gets the volume. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the volume set for the device specified by <code><em>pDeviceName</em></code>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDeviceName</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDeviceName</em></code> is included among the devices obtained by <code><a class="el" href="namespacenn_1_1audio.html#a55647cb74f20480d980354a8dc7f0907" title="This function is deprecated.">nn::audio::ListAudioDeviceName()</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function gets the volume for each output destination device set by <code><a class="el" href="namespacenn_1_1audio.html#a70fb7f5f687932689399a44c0da8d206" title="Sets the volume for the output destination device.">nn::audio::SetAudioDeviceOutputVolume()</a></code>. For more information, see <code><a class="el" href="namespacenn_1_1audio.html#a70fb7f5f687932689399a44c0da8d206" title="Sets the volume for the output destination device.">nn::audio::SetAudioDeviceOutputVolume()</a></code>.</p>
<div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
<ul>
<li>This function is not supported in the Windows environment. Always returns the default value of <code>1.0f</code>.</li>
</ul>
</div><div class="platform_section" data-platform="Windows"></div> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a127">AudioDevice/AudioDevice.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="acf3f2d72e87f3c1bcd8dafe7f1a5b301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3f2d72e87f3c1bcd8dafe7f1a5b301">&#9670;&nbsp;</a></span>SetAudioDeviceMapping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::SetAudioDeviceMapping </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>virtualName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_device_name.html">AudioDeviceName</a> *&#160;</td>
          <td class="paramname"><em>pDeviceName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns an actual audio device to a virtual audio device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">virtualName</td><td>Virtual audio device name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pDeviceName</td><td>Actual audio device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_not_found.html">nn::audio::ResultNotFound</a> must be handled.</li>
<li><a class="el" href="classnn_1_1audio_1_1_result_not_supported.html">nn::audio::ResultNotSupported</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>virtualName</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDeviceName</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function can only be used in a PC development environment. <code><a class="el" href="classnn_1_1audio_1_1_result_not_supported.html" title="A class that represents error Result values (audio: This functionality is not supported....">ResultNotSupported</a></code> is returned, and nothing else happens when this function is used in other environments.</p>
<p>The only value that can be set for <code><em>virtualName</em></code> is <code>MainAudioOut</code>. <code>MainAudioOut</code> functions as a 5.1 channel, 48-kHz audio output device. For <code><em>pDeviceName</em></code>, you can specify a device obtained by <code><a class="el" href="namespacenn_1_1audio.html#ad90597870d6de0b335ac9344f728a59b" title="Gets the supported device list for the platform.">nn::audio::ListAudioOutputDeviceName()</a></code>. If the number of channels for the device set with <code><em>pDeviceName</em></code> is not 5.1, audio output will be downmixed.</p>
<p>This function must be called before you use any <code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> functions. </p>

</div>
</div>
<a id="a7bd3cc176b82c7cd5659c364ab97ab08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd3cc176b82c7cd5659c364ab97ab08">&#9670;&nbsp;</a></span>AddBufferMixer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::AddBufferMixer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_buffer_mixer_type.html">BufferMixerType</a> *&#160;</td>
          <td class="paramname"><em>pBufferMixer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pFinalMix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds <code>BufferMixer</code> to <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#abcc7c4eb06afe0673e8196edc23dd9f0" title="Initializes FinalMixType and adds it to the AudioRendererConfig.">nn::audio::AcquireFinalMix()</a></code> initializes <code><em>pFinalMix</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pBufferMixer</td><td>An uninitialized <code>BufferMixer</code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFinalMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> that is adding <code><em>pBufferMixer</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html">nn::audio::ResultOutOfResource</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pBufferMixer</em></code> != <code>nullptr</code>.</li>
<li><code><em>pBufferMixer</em></code> is uninitialized.</li>
<li><code><em>pFinalMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pFinalMix</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pBufferMixer</em></code> is initialized.</li>
<li><code><em>pBufferMixer</em></code> is enabled.</li>
<li>The input/output buffers for <code><em>pBufferMixer</em></code> are not configured.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Adds the effect to mix to <code><em>pFinalMix</em></code> and initializes <code><em>pBufferMixer</em></code>. When this function is called, <code><em>pBufferMixer</em></code> is associated with <code><em>pFinalMix</em></code>, which makes it possible to perform effect operations on mix buffers managed by <code><em>pFinalMix</em></code>. Use <code><em>pBufferMixer</em></code> to perform all future operations on <code><a class="el" href="structnn_1_1audio_1_1_buffer_mixer_type.html" title="BufferMixer effects.">BufferMixerType</a></code>. For a list of functions that can be used with <code><a class="el" href="structnn_1_1audio_1_1_buffer_mixer_type.html" title="BufferMixer effects.">BufferMixerType</a></code>, see the <code><a class="el" href="structnn_1_1audio_1_1_buffer_mixer_type.html" title="BufferMixer effects.">BufferMixerType</a></code> reference.</p>
<p>The mix buffers that can be used by <code><em>pBufferMixer</em></code> during the mix process are the mix buffers that are managed by the instance of <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> specified for <code><em>pFinalMix</em></code>. For more information about the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> and <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> mix buffers, see Mix Buffers in the <a href="../../Package/contents/Pages/Page_89991492.html">Audio Renderer</a> documentation.</p>
<p>Only one instance of each type of effect can be added to a single <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. A single instance of an effect cannot be added to multiple instances of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. The following warning message is displayed if an initialized effect that has already been added to an instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> is added to the same instance or another instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> again. </p><div class="fragment"><div class="line">[<a class="code" href="namespacenn_1_1audio.html">nn::audio</a>] Warning: The passed effect is already initialized. Please confirm <span class="keywordflow">if</span> (address <span class="keywordflow">for</span> effect instance) is a valid effect <span class="keywordtype">object</span>.</div>
<div class="ttc" id="anamespacenn_1_1audio_html"><div class="ttname"><a href="namespacenn_1_1audio.html">nn::audio</a></div><div class="ttdoc">Namespace for the audio library.</div></div>
</div><!-- fragment --><p> ("address for effect instance" is the address of the instance of the effect that you attempted to add.) If this warning message appears, use the <code><a class="el" href="namespacenn_1_1audio.html#a400aff980a26fd295d911adbffd5f8ae" title="Removes BufferMixer from FinalMixType.">nn::audio::RemoveBufferMixer()</a></code> function to check whether the affected instance of the effect has been removed from <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>.</p>
<p>Immediately after an effect is added to <code><em>pFinalMix</em></code>, input/output mix buffers are not connected to <code><em>pBufferMixer</em></code>, and <code><em>pBufferMixer</em></code> transitions to an enabled state. Use the <code><a class="el" href="namespacenn_1_1audio.html#a70ca2b0217074d7daf6534da7db1de0b" title="Sets the input/output relationship of the mixing process performed by BufferMixer.">nn::audio::SetBufferMixerInputOutput()</a></code> function to specify the indices of the input/output mix buffers to which to apply the effect.</p>
<p>If the process for adding the effect fails and the function returns <code><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html" title="A class that represents error Result values (audio: Insufficient resources.).">nn::audio::ResultOutOfResource</a></code>, this usually indicates that the number of effects currently being used exceeds the maximum number of effects specified for <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html" title="The audio renderer parameters.">nn::audio::AudioRendererParameter</a>.<em>effectCount</em></code>. Delete one of the other effects or increase the number specified for <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html" title="The audio renderer parameters.">nn::audio::AudioRendererParameter</a>.<em>effectCount</em></code>.</p>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad771f7516d8c6eea51938171d9389af7" title="Adds a BiquadFilterType object to FinalMixType.">nn::audio::AddBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a2163e3d699edc8244383a94ed760f0be" title="Removes a BiquadFilterType object from FinalMixType.">nn::audio::RemoveBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a7bd3cc176b82c7cd5659c364ab97ab08" title="Adds BufferMixer to FinalMixType.">nn::audio::AddBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a400aff980a26fd295d911adbffd5f8ae" title="Removes BufferMixer from FinalMixType.">nn::audio::RemoveBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad332d3b8805f5157ef98572a99a9f2a0" title="Adds a DelayType object to FinalMixType.">nn::audio::AddDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a47262039889d9d23aeac0d82ed318ac0" title="Removes a DelayType object from FinalMixType.">nn::audio::RemoveDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aa081b9cab7e4ca8d079093c1fc50bb4d" title="Adds a ReverbType object to FinalMixType.">nn::audio::AddReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a8dda67780e46472ca22360376e6eb831" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a88bff95c7242f9d37ae5f631e825648b" title="Adds a I3dl2ReverbType object to FinalMixType.">nn::audio::AddI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a32e1724b072fff4284c19e597ac94d84" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a086c8ae883a8dabacad2c3ff3e995f13" title="Adds an AuxType object to FinalMixType.">nn::audio::AddAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a5133a62d6f97d3054e9ad428ae866102" title="Removes an AuxType object from FinalMixType.">nn::audio::RemoveAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a0bab4b3f6c0c1c7aa0011d2ee4b33919" title="Adds a LightLimiterType object to FinalMixType.">nn::audio::AddLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aacc63377e4f4f87617ff50fc981b170d" title="Removes a LightLimiterType object from FinalMixType.">nn::audio::RemoveLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ab3024a56e39831c3ba5fc8e52bca1a7e" title="Adds a CaptureType object to FinalMixType.">nn::audio::AddCapture()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a3fd8807d5efcb1fae477f690c8a8b48d" title="Removes the CaptureType object from FinalMixType.">nn::audio::RemoveCapture()</a></code></li>
</ul>
<p>Also, do not perform any operations on <code><em>pFinalMix</em></code> while calling any of these functions. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a157">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a119">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a81">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a74">AudioRenderer/AudioRenderer.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a76">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a9ca36cb068895cb7d5624f1682b86204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca36cb068895cb7d5624f1682b86204">&#9670;&nbsp;</a></span>AddBufferMixer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::AddBufferMixer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_buffer_mixer_type.html">BufferMixerType</a> *&#160;</td>
          <td class="paramname"><em>pBufferMixer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pSubMix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds <code>BufferMixer</code> to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#a24020da05700a26ee46f04f5762c157f" title="Initializes a SubMixType object and adds it to AudioRendererConfig.">nn::audio::AcquireSubMix()</a></code> initializes <code><em>pSubMix</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pBufferMixer</td><td>An uninitialized <code>BufferMixer</code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSubMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> to which the effect is being added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html">nn::audio::ResultOutOfResource</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pBufferMixer</em></code> != <code>nullptr</code>.</li>
<li><code><em>pBufferMixer</em></code> is uninitialized.</li>
<li><code><em>pSubMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSubMix</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pBufferMixer</em></code> is initialized.</li>
<li><code><em>pBufferMixer</em></code> is enabled.</li>
<li>The input/output buffers for <code><em>pBufferMixer</em></code> are not configured.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Adds the effect to mix to <code><em>pSubMix</em></code> and initializes <code><em>pBufferMixer</em></code>. Except when called on an instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, this function works the same as <code><a class="el" href="namespacenn_1_1audio.html#a7bd3cc176b82c7cd5659c364ab97ab08" title="Adds BufferMixer to FinalMixType.">nn::audio::AddBufferMixer</a>(AudioRendererConfig* <em>pOutConfig</em>, BufferMixerType* <em>pBufferMixer</em>, FinalMixType* <em>pFinalMix</em></code>. </p>

</div>
</div>
<a id="a400aff980a26fd295d911adbffd5f8ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400aff980a26fd295d911adbffd5f8ae">&#9670;&nbsp;</a></span>RemoveBufferMixer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::RemoveBufferMixer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_buffer_mixer_type.html">BufferMixerType</a> *&#160;</td>
          <td class="paramname"><em>pBufferMixer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pFinalMix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes <code>BufferMixer</code> from <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#abcc7c4eb06afe0673e8196edc23dd9f0" title="Initializes FinalMixType and adds it to the AudioRendererConfig.">nn::audio::AcquireFinalMix()</a></code> initializes <code><em>pFinalMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBufferMixer</td><td>The <code>BufferMixer</code> added to <code><em>pFinalMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFinalMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> that added <code><em>pBufferMixer</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pBufferMixer</em></code> != <code>nullptr</code>.</li>
<li><code><em>pBufferMixer</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a16f1d1c9f9cc0b68547f4c6553cfaa8f">nn::audio::IsBufferMixerRemovable(pBufferMixer)</a></code> == <code>true</code>.</li>
<li><code><em>pFinalMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pFinalMix</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pBufferMixer</em></code> is uninitialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 An effect can only be removed if the audio renderer has completely stopped using that effect. This function calls the <code><a class="el" href="namespacenn_1_1audio.html#a45c25ec42c8ffed62574963de0d2765c" title="Sets whether a BufferMixer is enabled or disabled.">nn::audio::SetBufferMixerEnabled()</a></code> function to disable <code>BufferMixer</code> before removing that instance of <code>BufferMixer</code> and then calls the <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> function to notify the audio renderer that <code>BufferMixer</code> has been disabled. After the notification is sent, it may take up to two audio frames for the audio renderer to completely stop using the effect. Use the <code><a class="el" href="namespacenn_1_1audio.html#a16f1d1c9f9cc0b68547f4c6553cfaa8f" title="Determines whether BufferMixer can be safely removed.">nn::audio::IsBufferMixerRemovable()</a></code> function to determine if an effect can be safely removed.</p>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad771f7516d8c6eea51938171d9389af7" title="Adds a BiquadFilterType object to FinalMixType.">nn::audio::AddBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a2163e3d699edc8244383a94ed760f0be" title="Removes a BiquadFilterType object from FinalMixType.">nn::audio::RemoveBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a7bd3cc176b82c7cd5659c364ab97ab08" title="Adds BufferMixer to FinalMixType.">nn::audio::AddBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a400aff980a26fd295d911adbffd5f8ae" title="Removes BufferMixer from FinalMixType.">nn::audio::RemoveBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad332d3b8805f5157ef98572a99a9f2a0" title="Adds a DelayType object to FinalMixType.">nn::audio::AddDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a47262039889d9d23aeac0d82ed318ac0" title="Removes a DelayType object from FinalMixType.">nn::audio::RemoveDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aa081b9cab7e4ca8d079093c1fc50bb4d" title="Adds a ReverbType object to FinalMixType.">nn::audio::AddReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a8dda67780e46472ca22360376e6eb831" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a88bff95c7242f9d37ae5f631e825648b" title="Adds a I3dl2ReverbType object to FinalMixType.">nn::audio::AddI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a32e1724b072fff4284c19e597ac94d84" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a086c8ae883a8dabacad2c3ff3e995f13" title="Adds an AuxType object to FinalMixType.">nn::audio::AddAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a5133a62d6f97d3054e9ad428ae866102" title="Removes an AuxType object from FinalMixType.">nn::audio::RemoveAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a0bab4b3f6c0c1c7aa0011d2ee4b33919" title="Adds a LightLimiterType object to FinalMixType.">nn::audio::AddLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aacc63377e4f4f87617ff50fc981b170d" title="Removes a LightLimiterType object from FinalMixType.">nn::audio::RemoveLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ab3024a56e39831c3ba5fc8e52bca1a7e" title="Adds a CaptureType object to FinalMixType.">nn::audio::AddCapture()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a3fd8807d5efcb1fae477f690c8a8b48d" title="Removes the CaptureType object from FinalMixType.">nn::audio::RemoveCapture()</a></code></li>
</ul>
<p>Also, do not perform any operations on <code><em>pFinalMix</em></code> while calling any of these functions. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="ac6995d87955c29acb8d5b4ee02d579b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6995d87955c29acb8d5b4ee02d579b0">&#9670;&nbsp;</a></span>RemoveBufferMixer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::RemoveBufferMixer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_buffer_mixer_type.html">BufferMixerType</a> *&#160;</td>
          <td class="paramname"><em>pBufferMixer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pSubMix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes <code>BufferMixer</code> from <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#a24020da05700a26ee46f04f5762c157f" title="Initializes a SubMixType object and adds it to AudioRendererConfig.">nn::audio::AcquireSubMix()</a></code> initializes <code><em>pSubMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBufferMixer</td><td>The <code>BufferMixer</code> added to <code><em>pSubMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSubMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> that added <code><em>pBufferMixer</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pBufferMixer</em></code> != <code>nullptr</code>.</li>
<li><code><em>pBufferMixer</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a16f1d1c9f9cc0b68547f4c6553cfaa8f">nn::audio::IsBufferMixerRemovable(pBufferMixer)</a></code> == <code>true</code>.</li>
<li><code><em>pSubMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSubMix</em></code> is initialized.</li>
<li><code><em>pBufferMixer</em></code> is added to <code><em>pSubMix</em></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pBufferMixer</em></code> is uninitialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Except when called on an instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, this function works the same as <code><a class="el" href="namespacenn_1_1audio.html#a400aff980a26fd295d911adbffd5f8ae" title="Removes BufferMixer from FinalMixType.">nn::audio::RemoveBufferMixer</a>(AudioRendererConfig* <em>pOutConfig</em>, BufferMixerType* <em>pBufferMixer</em>, FinalMixType* <em>pFinalMix</em>)</code>. </p>

</div>
</div>
<a id="a0f4ccfc22243f9770188dcf3df330f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f4ccfc22243f9770188dcf3df330f6b">&#9670;&nbsp;</a></span>GetBufferMixerInputOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::GetBufferMixerInputOutput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_buffer_mixer_type.html">BufferMixerType</a> *&#160;</td>
          <td class="paramname"><em>pBufferMixer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>outInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>outOutput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the input/output relationship of the mixing process set in <code>BufferMixer</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBufferMixer</td><td>The initialized <code>BufferMixer</code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outInput</td><td>The array from which to get the indexes of the input mix buffers set in <code><em>pBufferMixer</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outOutput</td><td>The array from which to get the indexes of the output mix buffers set in <code><em>pBufferMixer</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutCount</td><td>The number of mix buffer indexes obtained in <code><em>outInput</em></code> and <code><em>outOutput</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Length of the <code><em>outInput</em></code> and <code><em>outOutput</em></code> arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pBufferMixer</em></code> != <code>nullptr</code>.</li>
<li><code><em>pBufferMixer</em></code> is initialized.</li>
<li><code><em>outInput</em></code> != <code>nullptr</code>.</li>
<li><code><em>outOutput</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutCount</em></code> != <code>nullptr</code>.</li>
<li><code><em>count</em></code> &gt; <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the input/output buffer relationship for the mix process set to the specified instance of <code>BufferMixer</code>. The indices of the source input mix buffers are stored in <code><em>outInput</em></code>, and the indices of the output mix buffers are stored in <code><em>outOutput</em></code>. <code><em>outInput</em></code> and <code><em>outOutput</em></code> can store up to <code><em>count</em></code> indices. The actual number of mix buffer indexes that are stored in <code><em>outInput</em></code> and <code><em>outOutput</em></code> is returned to <code><em>pOutCount</em></code>.</p>
<p>This function gets the input/output buffer relationship specified using the <code><a class="el" href="namespacenn_1_1audio.html#a70ca2b0217074d7daf6534da7db1de0b" title="Sets the input/output relationship of the mixing process performed by BufferMixer.">nn::audio::SetBufferMixerInputOutput()</a></code> function. If this function is called on an instance of <code>BufferMixer</code> for which the <code><a class="el" href="namespacenn_1_1audio.html#a70ca2b0217074d7daf6534da7db1de0b" title="Sets the input/output relationship of the mixing process performed by BufferMixer.">nn::audio::SetBufferMixerInputOutput()</a></code> function has not been called, nothing will be stored in <code><em>outInput</em></code> and <code>outOutput</code>, and a value of <code>0</code> will be stored in <code><em>pOutCount</em></code>. If the number of input/output mix buffer indices set in <code><em>pBufferMixer</em></code> is greater than the value specified for <code><em>count</em></code>, <code><em>outInput</em></code> and <code><em>outOutput</em></code> will only store up to <code><em>count</em></code> of the mix buffer indices.</p>
<p>For more information about the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> and <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> mix buffers, see Mix Buffers in the <a href="../../Package/contents/Pages/Page_89991492.html">Audio Renderer</a> documentation.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pBufferMixer</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="a70ca2b0217074d7daf6534da7db1de0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70ca2b0217074d7daf6534da7db1de0b">&#9670;&nbsp;</a></span>SetBufferMixerInputOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetBufferMixerInputOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_buffer_mixer_type.html">BufferMixerType</a> *&#160;</td>
          <td class="paramname"><em>pBufferMixer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the input/output relationship of the mixing process performed by <code>BufferMixer</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pBufferMixer</td><td>The initialized <code>BufferMixer</code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The array of indexes of input mix buffers set in <code><em>pBufferMixer</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>The array of indexes of output mix buffers set in <code><em>pBufferMixer</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of mix buffer indexes stored in <code><em>input</em></code> and <code><em>output</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pBufferMixer</em></code> != <code>nullptr</code>.</li>
<li><code><em>pBufferMixer</em></code> is initialized.</li>
<li><code><em>input</em></code> != <code>nullptr</code>.</li>
<li><code><em>output</em></code> != <code>nullptr</code>.</li>
<li><code>0</code> &lt; <code><em>count</em></code> &amp;&amp; <code><em>count</em></code> &lt;= <code>MixBufferCountMax</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sets the input/output relationship of the mixing process performed by <code>BufferMixer</code>. The mix buffers corresponding to the indices specified for the <code><em>input</em></code> array are set as the input mix buffers, and the mix buffers corresponding to the indices specified for the <code><em>output</em></code> array are set as the output mix buffers. For example, if you specified <code><em>input[]</em></code> = <code>{0, 1, 2}</code> and <code><em>output[]</em></code> = <code>{3, 4, 5}</code> for the parameters, the following three types of input/output buffer relationships for <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> and <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> mix buffers for which <code><em>pBufferMixer</em></code> was added would be configured, and the mix process would be performed according to this input/output buffer relationship.</p>
<ul>
<li>Input mix buffer 0 is associated with output mix buffer 3.</li>
<li>Input mix buffer 1 is associated with output mix buffer 4.</li>
<li>Input mix buffer 2 is associated with output mix buffer 5.</li>
</ul>
<p><br  />
 The mix process is performed in the order in which the buffers are specified in <code><em>input</em></code> and <code><em>output</em></code>. In the preceding example, the buffers would be mixed in the specified numerical order. Volume can also be specified for the mix. Use the <code><a class="el" href="namespacenn_1_1audio.html#a0bcd31951156f6c1422c409b2685ab3e" title="Sets the volume for each input/output relationship of BufferMixer.">nn::audio::SetBufferMixerVolume()</a></code> function to set the mix volume.</p>
<p>The same mix buffer indices can be specified for both <code><em>input</em></code> and <code><em>output</em></code>. For example, if you specified <code><em>input[]</em></code> = <code>{0, 1, 2}</code>, <code><em>output[]</em></code> = <code>{0, 1, 2}</code>, and <code><em>count</em></code> = <code>3</code> for the parameters, the volume would be set for mix buffers 0, 1, and 2, and those mix buffers would be written back to the same location.</p>
<p>Make sure that the mix buffer indices specified for <code><em>input</em></code> and <code><em>output</em></code> in this function are the indices of mix buffers managed by an instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or &lt;<code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> for which <code><em>pBufferMixer</em></code> was added.</p>
<p>For more information about the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> and <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> mix buffers, see Mix Buffers in the <a href="../../Package/contents/Pages/Page_89991492.html">Audio Renderer</a> documentation.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pBufferMixer</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a159">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a121">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a82">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a75">AudioRenderer/AudioRenderer.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a78">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a8a0768296111890d9b3bfbafba0068fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0768296111890d9b3bfbafba0068fa">&#9670;&nbsp;</a></span>GetBufferMixerVolume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetBufferMixerVolume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_buffer_mixer_type.html">BufferMixerType</a> *&#160;</td>
          <td class="paramname"><em>pBufferMixer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the volume setting for each input/output relationship of <code>BufferMixer</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBufferMixer</td><td>The initialized <code>BufferMixer</code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index of the input/output relationship. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the volume. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pBufferMixer</em></code> != <code>nullptr</code>.</li>
<li><code><em>pBufferMixer</em></code> is initialized.</li>
<li><code>0</code> &lt;= <code><em>index</em></code> &amp;&amp; <code><em>index</em></code> &lt;= <code><a class="el" href="namespacenn_1_1audio.html#a2519dd3580c74c1abf2d1ae868304f39" title="The maximum number of mix buffers that can be created for a single instance of SubMix or FinalMix.">nn::audio::MixBufferCountMax</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the volume set using the <code><a class="el" href="namespacenn_1_1audio.html#a0bcd31951156f6c1422c409b2685ab3e" title="Sets the volume for each input/output relationship of BufferMixer.">nn::audio::SetBufferMixerVolume()</a></code> function. Returns an initial value of <code>0.0f</code> for combinations of <code><em>pBufferMixer</em></code> and <code><em>index</em></code> for which the <code><a class="el" href="namespacenn_1_1audio.html#a0bcd31951156f6c1422c409b2685ab3e" title="Sets the volume for each input/output relationship of BufferMixer.">nn::audio::SetBufferMixerVolume()</a></code> function has not been called.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pBufferMixer</em></code> while calling this function. </p>

</div>
</div>
<a id="a0bcd31951156f6c1422c409b2685ab3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bcd31951156f6c1422c409b2685ab3e">&#9670;&nbsp;</a></span>SetBufferMixerVolume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetBufferMixerVolume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_buffer_mixer_type.html">BufferMixerType</a> *&#160;</td>
          <td class="paramname"><em>pBufferMixer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>volume</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the volume for each input/output relationship of <code>BufferMixer</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBufferMixer</td><td>The initialized <code>BufferMixer</code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index of the input/output relationship. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">volume</td><td>The volume to set for the mix process specified by <code><em>index</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pBufferMixer</em></code> != <code>nullptr</code>.</li>
<li><code><em>pBufferMixer</em></code> is initialized.</li>
<li><code>0</code> &lt;= <code><em>index</em></code> &amp;&amp; <code><em>index</em></code> &lt;= <code><a class="el" href="namespacenn_1_1audio.html#a2519dd3580c74c1abf2d1ae868304f39" title="The maximum number of mix buffers that can be created for a single instance of SubMix or FinalMix.">nn::audio::MixBufferCountMax</a></code>.</li>
<li><code>0.0f</code> &lt;= <code><em>volume</em></code> &amp;&amp; <code><em>volume</em></code> &lt;= <code>2.0f</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a8a0768296111890d9b3bfbafba0068fa">nn::audio::GetBufferMixerVolume(pBufferMixer, index)</a></code> == <code><em>volume</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sets the volume for the mix processes corresponding to the input/output buffer relationship specified using the <code><a class="el" href="namespacenn_1_1audio.html#a70ca2b0217074d7daf6534da7db1de0b" title="Sets the input/output relationship of the mixing process performed by BufferMixer.">nn::audio::SetBufferMixerInputOutput()</a></code> function. <code><em>index</em></code> is an index in the <code><em>input</em></code> and <code><em>output</em></code> arrays specified in the <code><a class="el" href="namespacenn_1_1audio.html#a70ca2b0217074d7daf6534da7db1de0b" title="Sets the input/output relationship of the mixing process performed by BufferMixer.">nn::audio::SetBufferMixerInputOutput()</a></code> function.</p>
<p>For example, if you specified <code><em>input</em>[]</code> = <code>{0, 1, 2}</code>, <code><em>output</em>[]</code> = <code>{3, 4, 5}</code>, and <code><em>count</em></code> = <code>3</code> to define the input/output buffer relationship when calling the <code><a class="el" href="namespacenn_1_1audio.html#a70ca2b0217074d7daf6534da7db1de0b" title="Sets the input/output relationship of the mixing process performed by BufferMixer.">nn::audio::SetBufferMixerInputOutput()</a></code> function on an instance of <code>BufferMixer</code>, and then specified <code><em>index</em></code> = <code>0</code> and <code><em>volume</em></code> = <code>0.5f</code> when calling the <code><a class="el" href="namespacenn_1_1audio.html#a0bcd31951156f6c1422c409b2685ab3e" title="Sets the volume for each input/output relationship of BufferMixer.">nn::audio::SetBufferMixerVolume()</a></code> function, mix buffer 0 would be mixed into mix buffer 3 with a volume setting of <code>0.5f</code>.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pBufferMixer</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a158">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a120">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a91">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a76">AudioRenderer/AudioRenderer.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a77">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a5e3a75afb0f259cc0a8b6589d8f29977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3a75afb0f259cc0a8b6589d8f29977">&#9670;&nbsp;</a></span>IsBufferMixerEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::IsBufferMixerEnabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_buffer_mixer_type.html">BufferMixerType</a> *&#160;</td>
          <td class="paramname"><em>pBufferMixer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether <code>BufferMixer</code> is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBufferMixer</td><td><code>BufferMixer</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if enabled, or <code>false</code> otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pBufferMixer</em></code> != <code>nullptr</code>.</li>
<li><code><em>pBufferMixer</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pBufferMixer</em></code> while calling this function. </p>

</div>
</div>
<a id="a45c25ec42c8ffed62574963de0d2765c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c25ec42c8ffed62574963de0d2765c">&#9670;&nbsp;</a></span>SetBufferMixerEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetBufferMixerEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_buffer_mixer_type.html">BufferMixerType</a> *&#160;</td>
          <td class="paramname"><em>pBufferMixer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether a <code>BufferMixer</code> is enabled or disabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBufferMixer</td><td><code>BufferMixer</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td><code>true</code> to enable, or <code>false</code> to disable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pBufferMixer</em></code> != <code>nullptr</code>.</li>
<li><code><em>pBufferMixer</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a5e3a75afb0f259cc0a8b6589d8f29977">nn::audio::IsBufferMixerEnabled(pBufferMixer)</a></code> == <code><em>enable</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 When a <code>BufferMixer</code> is disabled, all of the mix processes for the input/output buffer relationship configured for <code><em>pBufferMixer</em></code> are terminated.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pBufferMixer</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="a16f1d1c9f9cc0b68547f4c6553cfaa8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f1d1c9f9cc0b68547f4c6553cfaa8f">&#9670;&nbsp;</a></span>IsBufferMixerRemovable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::IsBufferMixerRemovable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_buffer_mixer_type.html">BufferMixerType</a> *&#160;</td>
          <td class="paramname"><em>pBufferMixer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether <code>BufferMixer</code> can be safely removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBufferMixer</td><td><code>BufferMixer</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if possible. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pBufferMixer</em></code> != <code>nullptr</code>.</li>
<li><code><em>pBufferMixer</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 An effect can only be removed if the audio renderer has completely stopped using that effect. Before calling the <code><a class="el" href="namespacenn_1_1audio.html#a400aff980a26fd295d911adbffd5f8ae" title="Removes BufferMixer from FinalMixType.">nn::audio::RemoveBufferMixer()</a></code> function, use this function to check whether the instance of <code>BufferMixer</code> that you want to remove is no longer being used. Note the following.</p><ul>
<li>The use of effects is not stopped immediately after disabling them using the<code><a class="el" href="namespacenn_1_1audio.html#a45c25ec42c8ffed62574963de0d2765c" title="Sets whether a BufferMixer is enabled or disabled.">SetBufferMixerEnabled()</a></code> function.</li>
<li>After an effect is disabled using the <code>SetBufferMixerEnable()</code> function, it can take up to two audio frames for calls to the <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> function to be completed.</li>
<li>Do not call the <code><a class="el" href="namespacenn_1_1audio.html#a400aff980a26fd295d911adbffd5f8ae" title="Removes BufferMixer from FinalMixType.">RemoveBufferMixer()</a></code> function during this time.</li>
</ul>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pBufferMixer</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="a0ee72c85c663f6518ca13201159be052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee72c85c663f6518ca13201159be052">&#9670;&nbsp;</a></span>GetRequiredBufferSizeForDelay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::audio::GetRequiredBufferSizeForDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td>
          <td class="paramname"><em>delayTimeMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelCountMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the work buffer size required for the renderer to use <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delayTimeMax</td><td>The maximum delay time that can be set with <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleRate</td><td>The sample rate set in the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> that is adding <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCountMax</td><td>The maximum number of channels to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the buffer size required for using <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>(<code><em>sampleRate</em></code> == <code>32000</code>) || (<code><em>sampleRate</em></code> == <code>48000</code>).</li>
<li>(<code><em>channelCountMax</em></code> == <code>1</code>) || (<code><em>channelCountMax</em></code> == <code>2</code>) || (<code><em>channelCountMax</em></code> == <code>4</code> ) || (<code><em>channelCountMax</em></code> == <code>6</code>).</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The required memory for <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> depends on the values configured for the delay time, sampling rate, and number of channels. Use this function to calculate the required memory for <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> based on the specified values for these parameters.</p>
<p>For <code><em>sampleRate</em></code>, specify the sampling rate set for the instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> to which <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> was added using the <code><a class="el" href="namespacenn_1_1audio.html#ad332d3b8805f5157ef98572a99a9f2a0" title="Adds a DelayType object to FinalMixType.">nn::audio::AddDelay()</a></code> function. Use the <code><a class="el" href="namespacenn_1_1audio.html#a331b58a86c70fe45bf649941db3ca55e" title="Gets the sample rate of the SubMixType object.">nn::audio::GetSubMixSampleRate()</a></code> function to get the sampling rate for <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, and use the <code><a class="el" href="namespacenn_1_1audio.html#a25ee6f076a7eb80a0fc937c42d41e652" title="Gets the sampling rate of the audio renderer processing.">nn::audio::GetAudioRendererSampleRate()</a></code> function to get the sampling rate for <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>.</p>
<p>For <code><em>channelCountMax</em></code>, specify the number of channels supported by <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a140">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a77">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, and <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a98">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad332d3b8805f5157ef98572a99a9f2a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad332d3b8805f5157ef98572a99a9f2a0">&#9670;&nbsp;</a></span>AddDelay() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::AddDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *&#160;</td>
          <td class="paramname"><em>pDelay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pFinalMix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td>
          <td class="paramname"><em>delayTimeMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelCountMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#abcc7c4eb06afe0673e8196edc23dd9f0" title="Initializes FinalMixType and adds it to the AudioRendererConfig.">nn::audio::AcquireFinalMix()</a></code> initializes <code><em>pFinalMix</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pDelay</td><td>An uninitialized <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the memory region to use for <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size of memory specified by <code><em>buffer</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFinalMix</td><td>The <code>FinalMix</code> to which the effect is being added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delayTimeMax</td><td>Value for the maximum delay time that can be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCountMax</td><td>Value for the maximum number of channels that can be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html">nn::audio::ResultOutOfResource</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDelay</em></code> is uninitialized.</li>
<li><code><em>buffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>buffer</em></code> is aligned to <code><a class="el" href="namespacenn_1_1audio.html#a61833f2e2cf0253e3054188e900315af" title="The alignment size for audio buffers.">nn::audio::BufferAlignSize</a></code>.</li>
<li><code><em>bufferSize</em></code> &gt;= <code><a class="el" href="namespacenn_1_1audio.html#a0ee72c85c663f6518ca13201159be052">nn::audio::GetRequiredBufferSizeForDelay(delayTimeMax, sampleRate, channelCountMax)</a></code>. (<code><em>sampleRate</em></code> is the sample rate set in <code><em>pFinalMix</em></code>. You can get it using <code><a class="el" href="namespacenn_1_1audio.html#a25ee6f076a7eb80a0fc937c42d41e652" title="Gets the sampling rate of the audio renderer processing.">nn::audio::GetAudioRendererSampleRate()</a></code>.)</li>
<li><code><em>pFinalMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pFinalMix</em></code> is initialized.</li>
<li>(<code><em>channelCountMax</em></code> == <code>1</code>) || (<code><em>channelCountMax</em></code> == <code>2</code>) || (<code><em>channelCountMax</em></code> == <code>4</code> ) || (<code><em>channelCountMax</em></code> == <code>6</code>). </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pDelay</em></code> is initialized.</li>
<li><code><em>pDelay</em></code> is enabled.</li>
<li>The input/output buffers for <code><em>pDelay</em></code> are not configured.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Adds the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> effect, which plays back the input audio with a delay, to <code><em>pFinalMix</em></code> and initializes <code><em>pDelay</em></code>. When this function is called, <code><em>pDelay</em></code> is associated with <code><em>pFinalMix</em></code>, which makes it possible to perform effect operations on mix buffers managed by <code><em>pFinalMix</em></code>. Use <code><em>pDelay</em></code> to perform all future operations on <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code>. For a list of functions that can be used with <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code>, see the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> reference.</p>
<p><code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> requires a work buffer to process the effect. Allocate a buffer that is at least equal to the value returned by the <code><a class="el" href="namespacenn_1_1audio.html#a0ee72c85c663f6518ca13201159be052" title="Gets the work buffer size required for the renderer to use DelayType.">nn::audio::GetRequiredBufferSizeForDelay()</a></code> in size, and specify that buffer and its size for <code><em>buffer</em></code> and <code><em>bufferSize</em></code>. The memory region specified for <code><em>buffer</em></code> must be contained within the memory region specified for <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html" title="Structure for representing memory regions used by an audio renderer.">nn::audio::MemoryPoolType</a></code>. Also, the instance of <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html" title="Structure for representing memory regions used by an audio renderer.">nn::audio::MemoryPoolType</a></code> that contains the memory region specified for <code><em>buffer</em></code> must be in the attached state.</p>
<p>Only one instance of each type of effect can be added to a single <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. A single instance of an effect cannot be added to multiple instances of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. The following warning message is displayed if an initialized effect that has already been added to an instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> is added to the same instance or another instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> again. </p><div class="fragment"><div class="line">[<a class="code" href="namespacenn_1_1audio.html">nn::audio</a>] Warning: The passed effect is already initialized. Please confirm <span class="keywordflow">if</span> (address <span class="keywordflow">for</span> effect instance) is a valid effect <span class="keywordtype">object</span>.</div>
</div><!-- fragment --><p> ("address for effect instance" is the address of the instance of the effect that you attempted to add.) For <code><em>delayTimeMax</em></code>, specify the maximum delay time that can be set while <code><em>pDelay</em></code> is being used. After doing this, you can use the <code><a class="el" href="namespacenn_1_1audio.html#ab8b0a4aba0c4bbb672a370b53335bdc7" title="Sets the delay time of the DelayType object.">nn::audio::SetDelayTime()</a></code> function at any time to specify a delay time less than or equal to <code><em>delayTimeMax</em></code>. However, after changing the delay time setting, you must call the <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> to notify the audio renderer of the change.</p>
<p>For <code><em>channelCountMax</em></code>, specify the number of channels supported by <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code>. The maximum number of channels that can be specified is the value specified for <code><em>count</em></code> in the <code><a class="el" href="namespacenn_1_1audio.html#a7ac9e44ccd0d4f0fd0865cd6871949e8" title="Sets the DelayType input/output mix buffer indexes.">nn::audio::SetDelayInputOutput()</a></code> function. For more information, see <code><a class="el" href="namespacenn_1_1audio.html#a7ac9e44ccd0d4f0fd0865cd6871949e8" title="Sets the DelayType input/output mix buffer indexes.">nn::audio::SetDelayInputOutput()</a></code>.</p>
<p>Immediately after a delay is added, <code><em>pDelay</em></code> is not connected to the input/output mix buffers, and <code><em>pDelay</em></code> transitions to an enabled state. Use the <code><a class="el" href="namespacenn_1_1audio.html#a7ac9e44ccd0d4f0fd0865cd6871949e8" title="Sets the DelayType input/output mix buffer indexes.">nn::audio::SetDelayInputOutput()</a></code> function to specify the indices of the input/output mix buffers to which to apply the effect.</p>
<p>If the process for adding the effect fails and the function returns <code><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html" title="A class that represents error Result values (audio: Insufficient resources.).">nn::audio::ResultOutOfResource</a></code>, this usually indicates that the number of effects currently being used exceeds the maximum number of effects specified for <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html" title="The audio renderer parameters.">nn::audio::AudioRendererParameter</a>.<em>effectCount</em></code>. Delete one of the other effects or increase the number specified for <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html" title="The audio renderer parameters.">nn::audio::AudioRendererParameter</a>.<em>effectCount</em></code>.</p>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad771f7516d8c6eea51938171d9389af7" title="Adds a BiquadFilterType object to FinalMixType.">nn::audio::AddBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a2163e3d699edc8244383a94ed760f0be" title="Removes a BiquadFilterType object from FinalMixType.">nn::audio::RemoveBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a7bd3cc176b82c7cd5659c364ab97ab08" title="Adds BufferMixer to FinalMixType.">nn::audio::AddBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a400aff980a26fd295d911adbffd5f8ae" title="Removes BufferMixer from FinalMixType.">nn::audio::RemoveBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad332d3b8805f5157ef98572a99a9f2a0" title="Adds a DelayType object to FinalMixType.">nn::audio::AddDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a47262039889d9d23aeac0d82ed318ac0" title="Removes a DelayType object from FinalMixType.">nn::audio::RemoveDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aa081b9cab7e4ca8d079093c1fc50bb4d" title="Adds a ReverbType object to FinalMixType.">nn::audio::AddReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a8dda67780e46472ca22360376e6eb831" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a88bff95c7242f9d37ae5f631e825648b" title="Adds a I3dl2ReverbType object to FinalMixType.">nn::audio::AddI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a32e1724b072fff4284c19e597ac94d84" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a086c8ae883a8dabacad2c3ff3e995f13" title="Adds an AuxType object to FinalMixType.">nn::audio::AddAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a5133a62d6f97d3054e9ad428ae866102" title="Removes an AuxType object from FinalMixType.">nn::audio::RemoveAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a0bab4b3f6c0c1c7aa0011d2ee4b33919" title="Adds a LightLimiterType object to FinalMixType.">nn::audio::AddLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aacc63377e4f4f87617ff50fc981b170d" title="Removes a LightLimiterType object from FinalMixType.">nn::audio::RemoveLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ab3024a56e39831c3ba5fc8e52bca1a7e" title="Adds a CaptureType object to FinalMixType.">nn::audio::AddCapture()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a3fd8807d5efcb1fae477f690c8a8b48d" title="Removes the CaptureType object from FinalMixType.">nn::audio::RemoveCapture()</a></code></li>
</ul>
<p>Also, do not perform any operations on <code><em>pFinalMix</em></code> while calling any of these functions. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a141">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a79">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, and <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a102">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a4a6ab91177240adfa5dbc5029ccd8280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6ab91177240adfa5dbc5029ccd8280">&#9670;&nbsp;</a></span>AddDelay() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::AddDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *&#160;</td>
          <td class="paramname"><em>pDelay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pSubMix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td>
          <td class="paramname"><em>delayTimeMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelCountMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#a24020da05700a26ee46f04f5762c157f" title="Initializes a SubMixType object and adds it to AudioRendererConfig.">nn::audio::AcquireSubMix()</a></code> initializes <code><em>pSubMix</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pDelay</td><td>An uninitialized <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the memory region to use for <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size of memory specified by <code><em>buffer</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSubMix</td><td>The <code>SubMix</code> to which the effect is being added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delayTimeMax</td><td>Value for the maximum delay time that can be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCountMax</td><td>Value for the maximum number of channels that can be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html">nn::audio::ResultOutOfResource</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDelay</em></code> is uninitialized.</li>
<li><code><em>buffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>buffer</em></code> is aligned to <code><a class="el" href="namespacenn_1_1audio.html#a61833f2e2cf0253e3054188e900315af" title="The alignment size for audio buffers.">nn::audio::BufferAlignSize</a></code>.</li>
<li><code><em>bufferSize</em></code> &gt;= <code><a class="el" href="namespacenn_1_1audio.html#a0ee72c85c663f6518ca13201159be052">nn::audio::GetRequiredBufferSizeForDelay</a> (delayTimeMax, <a class="el" href="namespacenn_1_1audio.html#a331b58a86c70fe45bf649941db3ca55e">GetSubMixSampleRate(pSubMix)</a>, channelCountMax)</code>.</li>
<li><code><em>pSubMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSubMix</em></code> is initialized.</li>
<li>(<code><em>channelCountMax</em></code> == <code>1</code>) || (<code><em>channelCountMax</em></code> == <code>2</code>) || (<code><em>channelCountMax</em></code> == <code>4</code> ) || (<code><em>channelCountMax</em></code> == <code>6</code>). </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pDelay</em></code> is initialized.</li>
<li><code><em>pDelay</em></code> is enabled.</li>
<li>The input/output buffers for <code><em>pDelay</em></code> are not configured.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Except when called on an instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, this function works the same as <code><a class="el" href="namespacenn_1_1audio.html#ad332d3b8805f5157ef98572a99a9f2a0" title="Adds a DelayType object to FinalMixType.">nn::audio::AddDelay</a>(AudioRendererConfig* <em>pOutConfig</em>, DelayType* <em>pDelay</em>, void* <em>buffer</em>, size_t <em>bufferSize</em>, FinalMixType* <em>pFinalMix</em>, <a class="el" href="classnn_1_1_time_span.html" title="This class represents a length of time.">nn::TimeSpan</a> delayTimeMax, int <em>channelCountMax</em>)</code>. </p>

</div>
</div>
<a id="a47262039889d9d23aeac0d82ed318ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47262039889d9d23aeac0d82ed318ac0">&#9670;&nbsp;</a></span>RemoveDelay() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * nn::audio::RemoveDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *&#160;</td>
          <td class="paramname"><em>pDelay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pFinalMix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object from <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#abcc7c4eb06afe0673e8196edc23dd9f0" title="Initializes FinalMixType and adds it to the AudioRendererConfig.">nn::audio::AcquireFinalMix()</a></code> initializes <code><em>pFinalMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pDelay</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> added to <code><em>pFinalMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFinalMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> that removes <code><em>pDelay</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the memory used for <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code>. (The memory passed to <code><em>buffer</em></code> when initialized by <code><a class="el" href="namespacenn_1_1audio.html#ad332d3b8805f5157ef98572a99a9f2a0" title="Adds a DelayType object to FinalMixType.">nn::audio::AddDelay()</a></code>.) </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDelay</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a974890d53eaa0f0a7b16a5593535ce84">nn::audio::IsDelayRemovable(pDelay)</a></code> == <code>true</code>.</li>
<li><code><em>pFinalMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pFinalMix</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pDelay</em></code> is uninitialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 An effect can only be removed if the audio renderer has completely stopped using that effect. This function calls the <code><a class="el" href="namespacenn_1_1audio.html#af22e23e037505f7842e41730fa686724" title="Enables or disables the DelayType object.">nn::audio::SetDelayEnabled()</a></code> function to disable <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> before removing that instance of <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> and then calls the <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> function to notify the audio renderer that <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> has been disabled. After calling the <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> function, use the <code><a class="el" href="namespacenn_1_1audio.html#a974890d53eaa0f0a7b16a5593535ce84" title="Determines whether DelayType object can be safely removed.">nn::audio::IsDelayRemovable()</a></code> function to determine whether the audio renderer has completely stopped using the effect and the delay can be safely removed. After calling the <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> function, it may take up to two audio frames for the audio renderer to completely stop using the effect.</p>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad771f7516d8c6eea51938171d9389af7" title="Adds a BiquadFilterType object to FinalMixType.">nn::audio::AddBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a2163e3d699edc8244383a94ed760f0be" title="Removes a BiquadFilterType object from FinalMixType.">nn::audio::RemoveBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a7bd3cc176b82c7cd5659c364ab97ab08" title="Adds BufferMixer to FinalMixType.">nn::audio::AddBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a400aff980a26fd295d911adbffd5f8ae" title="Removes BufferMixer from FinalMixType.">nn::audio::RemoveBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad332d3b8805f5157ef98572a99a9f2a0" title="Adds a DelayType object to FinalMixType.">nn::audio::AddDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a47262039889d9d23aeac0d82ed318ac0" title="Removes a DelayType object from FinalMixType.">nn::audio::RemoveDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aa081b9cab7e4ca8d079093c1fc50bb4d" title="Adds a ReverbType object to FinalMixType.">nn::audio::AddReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a8dda67780e46472ca22360376e6eb831" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a88bff95c7242f9d37ae5f631e825648b" title="Adds a I3dl2ReverbType object to FinalMixType.">nn::audio::AddI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a32e1724b072fff4284c19e597ac94d84" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a086c8ae883a8dabacad2c3ff3e995f13" title="Adds an AuxType object to FinalMixType.">nn::audio::AddAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a5133a62d6f97d3054e9ad428ae866102" title="Removes an AuxType object from FinalMixType.">nn::audio::RemoveAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a0bab4b3f6c0c1c7aa0011d2ee4b33919" title="Adds a LightLimiterType object to FinalMixType.">nn::audio::AddLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aacc63377e4f4f87617ff50fc981b170d" title="Removes a LightLimiterType object from FinalMixType.">nn::audio::RemoveLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ab3024a56e39831c3ba5fc8e52bca1a7e" title="Adds a CaptureType object to FinalMixType.">nn::audio::AddCapture()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a3fd8807d5efcb1fae477f690c8a8b48d" title="Removes the CaptureType object from FinalMixType.">nn::audio::RemoveCapture()</a></code></li>
</ul>
<p>Also, do not perform any operations on <code><em>pFinalMix</em></code> while calling any of these functions. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="a25592ceaa97f898a3b361c9404beab04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25592ceaa97f898a3b361c9404beab04">&#9670;&nbsp;</a></span>RemoveDelay() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * nn::audio::RemoveDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *&#160;</td>
          <td class="paramname"><em>pDelay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pSubMix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object from <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#a24020da05700a26ee46f04f5762c157f" title="Initializes a SubMixType object and adds it to AudioRendererConfig.">nn::audio::AcquireSubMix()</a></code> initializes <code><em>pSubMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pDelay</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object added to <code><em>pSubMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSubMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> that removes <code><em>pDelay</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the memory used for <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code>. (The memory passed to <code><em>buffer</em></code> when initialized by <code><a class="el" href="namespacenn_1_1audio.html#ad332d3b8805f5157ef98572a99a9f2a0" title="Adds a DelayType object to FinalMixType.">nn::audio::AddDelay()</a></code>.) </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDelay</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a974890d53eaa0f0a7b16a5593535ce84">nn::audio::IsDelayRemovable(pDelay)</a></code> == <code>true</code>.</li>
<li><code><em>pSubMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSubMix</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pDelay</em></code> is uninitialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Except when called on an instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, this function works the same as <code><a class="el" href="namespacenn_1_1audio.html#a47262039889d9d23aeac0d82ed318ac0" title="Removes a DelayType object from FinalMixType.">nn::audio::RemoveDelay</a>(AudioRendererConfig* <em>pOutConfig</em>, DelayType* <em>pDelay</em>, FinalMixType* <em>pFinalMix</em>)</code>. </p>

</div>
</div>
<a id="adb54e0c9a1ccc61a87e3df141969ff6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb54e0c9a1ccc61a87e3df141969ff6a">&#9670;&nbsp;</a></span>GetDelayInputOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::GetDelayInputOutput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *&#160;</td>
          <td class="paramname"><em>pDelay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>outInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>outOutput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the indexes of the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> input/output mix buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDelay</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outInput</td><td>The array from which to get the indexes of the input mix buffers set in <code><em>pDelay</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outOutput</td><td>The array from which to get the indexes of the output mix buffers set in <code><em>pDelay</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutCount</td><td>The number of mix buffer indexes obtained in <code><em>outInput</em></code> and <code><em>outOutput</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Length of the <code><em>outInput</em></code> and <code><em>outOutput</em></code> arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDelay</em></code> is initialized.</li>
<li><code><em>outInput</em></code> != <code>nullptr</code>.</li>
<li><code><em>outOutput</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutCount</em></code> != <code>nullptr</code>.</li>
<li><code><em>count</em></code> &gt; <code>0</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>Information for the number of indexes specified in <code><em>pOutCount</em></code> is written to <code><em>outInput</em></code> and <code><em>outOutput</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the input/output buffer relationship for the specified <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> effect. The indices of the source input mix buffers are stored in <code><em>outInput</em></code>, and the indices of the output mix buffers are stored in <code><em>outOutput</em></code>. <code><em>outInput</em></code> and <code><em>outOutput</em></code> can store up to <code><em>count</em></code> indices. The actual number of mix buffer indexes that are stored in <code><em>outInput</em></code> and <code><em>outOutput</em></code> is returned to <code><em>pOutCount</em></code>.</p>
<p>This function gets the input/output buffer relationship specified using the <code><a class="el" href="namespacenn_1_1audio.html#a7ac9e44ccd0d4f0fd0865cd6871949e8" title="Sets the DelayType input/output mix buffer indexes.">nn::audio::SetDelayInputOutput()</a></code> function. If this function is called on an instance of <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> for which the <code><a class="el" href="namespacenn_1_1audio.html#a7ac9e44ccd0d4f0fd0865cd6871949e8" title="Sets the DelayType input/output mix buffer indexes.">nn::audio::SetDelayInputOutput()</a></code> function has not yet been called, nothing will be stored in <code><em>outInput</em></code> and <code><em>outOutput</em></code>, and a value of <code>0</code> will be stored in <code><em>pOutCount</em></code>. Also see the description of the <code><a class="el" href="namespacenn_1_1audio.html#ad332d3b8805f5157ef98572a99a9f2a0" title="Adds a DelayType object to FinalMixType.">nn::audio::AddDelay()</a></code> function. If the number of channels set to <code><em>pDelay</em></code> is greater than the value specified for <code><em>count</em></code>, <code><em>outInput</em></code> and <code><em>outOutput</em></code> will only store up to <code><em>count</em></code> of the mix buffer indices.</p>
<p>For more information about the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> and <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> mix buffers, see Mix Buffers in the <a href="../../Package/contents/Pages/Page_89991492.html">Audio Renderer</a> documentation.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pDelay</em></code> while calling this function. </p>

</div>
</div>
<a id="a7ac9e44ccd0d4f0fd0865cd6871949e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac9e44ccd0d4f0fd0865cd6871949e8">&#9670;&nbsp;</a></span>SetDelayInputOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetDelayInputOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *&#160;</td>
          <td class="paramname"><em>pDelay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> input/output mix buffer indexes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDelay</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The array of indexes of input mix buffers to set in <code><em>pDelay</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>The array of indexes of output mix buffers to set in <code><em>pDelay</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of mix buffer indexes stored in <code><em>input</em></code> and <code><em>output</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDelay</em></code> is initialized.</li>
<li><code><em>input</em></code> != <code>nullptr</code>.</li>
<li><code><em>output</em></code> != <code>nullptr</code>.</li>
<li><code><em>count</em></code> &lt;= <code><a class="el" href="namespacenn_1_1audio.html#af3889d816ceb7e79268913d9453fb020">nn::audio::GetDelayChannelCountMax(pDelay)</a></code>.</li>
<li>(<code><em>count</em></code> == <code>1</code>) || (<code><em>count</em></code> == <code>2</code>) || (<code><em>count</em></code> == <code>4</code>) || (<code><em>count</em></code> == <code>6</code>).</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sets the input/output buffer relationship for the specified <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> effect. The mix buffers corresponding to the indices specified for the <code><em>input</em></code> array are set as the input mix buffers, and the mix buffers corresponding to the indices specified for the <code><em>output</em></code> array are set as the output mix buffers. The same mix buffer indices can be specified for both <code><em>input</em></code> and <code><em>output</em></code>.</p>
<p>There are common rules for setting the input/output buffer relationship for each type of effect. For more information, see <code><a class="el" href="namespacenn_1_1audio.html#a70ca2b0217074d7daf6534da7db1de0b" title="Sets the input/output relationship of the mixing process performed by BufferMixer.">nn::audio::SetBufferMixerInputOutput()</a></code>.</p>
<p>The <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> <code><em>input</em></code> is processed on the assumption that input channels are in the following order. Be careful not to get the order wrong when you set <code><em>input</em></code>.</p><ul>
<li>For 2 ch: <code>FrontLeft</code>, <code>FrontRight</code>.</li>
<li>For 4 ch: <code>FrontLeft</code>, <code>FrontRight</code>, <code>RearLeft</code>, <code>RearRight</code>.</li>
<li>For 6 ch: <code>FrontLeft</code>, <code>FrontRight</code>, <code>FrontCenter</code>, <code>LowFrequency</code>, <code>RearLeft</code>, <code>RearRight</code>.</li>
</ul>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pDelay</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a104">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a80">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, and <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a103">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a7eda2c006ca593d631a8caa7bd2d33c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eda2c006ca593d631a8caa7bd2d33c6">&#9670;&nbsp;</a></span>GetDelayTimeMax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> nn::audio::GetDelayTimeMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *&#160;</td>
          <td class="paramname"><em>pDelay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum delay time value that can be set for <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDelay</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the maximum value that can be set for the delay time. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDelay</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pDelay</em></code> while calling this function. </p>

</div>
</div>
<a id="af3889d816ceb7e79268913d9453fb020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3889d816ceb7e79268913d9453fb020">&#9670;&nbsp;</a></span>GetDelayChannelCountMax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetDelayChannelCountMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *&#160;</td>
          <td class="paramname"><em>pDelay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum number of channels that can be set for <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDelay</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the maximum value for the number of channels that can be set. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDelay</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pDelay</em></code> while calling this function. </p>

</div>
</div>
<a id="a14dede97c7c28ba18a41418da43bf690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14dede97c7c28ba18a41418da43bf690">&#9670;&nbsp;</a></span>GetDelayTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> nn::audio::GetDelayTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *&#160;</td>
          <td class="paramname"><em>pDelay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the delay time of the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDelay</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the delay time. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDelay</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pDelay</em></code> while calling this function. </p>

</div>
</div>
<a id="ab8b0a4aba0c4bbb672a370b53335bdc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b0a4aba0c4bbb672a370b53335bdc7">&#9670;&nbsp;</a></span>SetDelayTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetDelayTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *&#160;</td>
          <td class="paramname"><em>pDelay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the delay time of the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDelay</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>Delay time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDelay</em></code> is initialized.</li>
<li><code><em>time</em></code> &lt;= <code><a class="el" href="namespacenn_1_1audio.html#a7eda2c006ca593d631a8caa7bd2d33c6">GetDelayTimeMax(pDelay)</a></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a14dede97c7c28ba18a41418da43bf690">nn::audio::GetDelayTime(pDelay)</a></code> == <code><em>time</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pDelay</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a86">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a84">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, and <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a104">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a7f4a6269c07ff5f77eb9209d00af595e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4a6269c07ff5f77eb9209d00af595e">&#9670;&nbsp;</a></span>GetDelayFeedbackGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetDelayFeedbackGain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *&#160;</td>
          <td class="paramname"><em>pDelay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the feedback gain of the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDelay</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the feedback gain. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDelay</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pDelay</em></code> while calling this function. </p>

</div>
</div>
<a id="ab435746ebd9510b866571bb5f51ada0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab435746ebd9510b866571bb5f51ada0e">&#9670;&nbsp;</a></span>SetDelayFeedbackGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetDelayFeedbackGain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *&#160;</td>
          <td class="paramname"><em>pDelay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>feedbackGain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the feedback gain of the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDelay</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">feedbackGain</td><td>Feedback gain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDelay</em></code> is initialized.</li>
<li><code>0.0f</code> &lt;= <code><em>feedbackGain</em></code> &gt; &amp;&amp; <code><em>feedbackGain</em></code> &lt;= <code>1.0f</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a7f4a6269c07ff5f77eb9209d00af595e">nn::audio::GetDelayFeedbackGain(pDelay)</a></code> == <code><em>feedbackGain</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pDelay</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a89">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a86">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, and <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a108">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a7e7db23976c5c7ce25d354b46fbb41f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e7db23976c5c7ce25d354b46fbb41f8">&#9670;&nbsp;</a></span>GetDelayDryGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetDelayDryGain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *&#160;</td>
          <td class="paramname"><em>pDelay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the dry gain of the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDelay</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the dry gain. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDelay</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pDelay</em></code> while calling this function. </p>

</div>
</div>
<a id="a0fec11e5f1f1f3631724c47bd6025962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fec11e5f1f1f3631724c47bd6025962">&#9670;&nbsp;</a></span>SetDelayDryGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetDelayDryGain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *&#160;</td>
          <td class="paramname"><em>pDelay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dryGain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the dry gain of the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDelay</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dryGain</td><td>Dry gain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDelay</em></code> is initialized.</li>
<li><code>0.0f</code> &lt;= <code><em>dryGain</em></code> &amp;&amp; <code><em>dryGain</em></code> &lt;= <code>1.0f</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a7e7db23976c5c7ce25d354b46fbb41f8">nn::audio::GetDelayDryGain(pDelay)</a></code> == <code><em>dryGain</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pDelay</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a88">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a89">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, and <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a107">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a30e4daa91121a5eb404eb54ecdc08fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30e4daa91121a5eb404eb54ecdc08fc5">&#9670;&nbsp;</a></span>GetDelayInGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetDelayInGain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *&#160;</td>
          <td class="paramname"><em>pDelay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the in gain of the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDelay</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the in gain. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDelay</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pDelay</em></code> while calling this function. </p>

</div>
</div>
<a id="a329bfdf77c21faf791e3d8d3fea994ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a329bfdf77c21faf791e3d8d3fea994ff">&#9670;&nbsp;</a></span>SetDelayInGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetDelayInGain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *&#160;</td>
          <td class="paramname"><em>pDelay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>inGain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the in gain of the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDelay</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inGain</td><td>In gain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDelay</em></code> is initialized.</li>
<li><code>0.0f</code> &lt;= <code><em>inGain</em></code> &amp;&amp; <code><em>inGain</em></code> &lt;= <code>1.0f</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a30e4daa91121a5eb404eb54ecdc08fc5">nn::audio::GetDelayInGain(pDelay)</a></code> == <code><em>inGain</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pDelay</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a90">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a90">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, and <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a109">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a16b59f407ca82ae84883c7bc05e51c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b59f407ca82ae84883c7bc05e51c10">&#9670;&nbsp;</a></span>GetDelayChannelSpread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetDelayChannelSpread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *&#160;</td>
          <td class="paramname"><em>pDelay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the channel spread of the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDelay</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the channel spread. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDelay</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pDelay</em></code> while calling this function. </p>

</div>
</div>
<a id="a533af8968ee99402d8941b01d17badbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a533af8968ee99402d8941b01d17badbb">&#9670;&nbsp;</a></span>SetDelayChannelSpread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetDelayChannelSpread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *&#160;</td>
          <td class="paramname"><em>pDelay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>channelSpread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the channel spread of the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDelay</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelSpread</td><td>Channel spread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDelay</em></code> is initialized.</li>
<li><code>0.0f</code> &lt;= <code><em>channelSpread</em></code> &amp;&amp; <code><em>channelSpread</em></code> &lt;= <code>1.0f</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a16b59f407ca82ae84883c7bc05e51c10">nn::audio::GetDelayChannelSpread(pDelay)</a></code> == <code><em>channelSpread</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pDelay</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a87">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a87">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, and <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a106">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a61abee481b45e4c907b91262f647a2c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61abee481b45e4c907b91262f647a2c5">&#9670;&nbsp;</a></span>GetDelayLowPassAmount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetDelayLowPassAmount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *&#160;</td>
          <td class="paramname"><em>pDelay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the low-pass filter parameter of the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDelay</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the low pass filter parameters. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDelay</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pDelay</em></code> while calling this function. </p>

</div>
</div>
<a id="a95c256f18c08f3345aeb8d3649056b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95c256f18c08f3345aeb8d3649056b12">&#9670;&nbsp;</a></span>SetDelayLowPassAmount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetDelayLowPassAmount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *&#160;</td>
          <td class="paramname"><em>pDelay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lowPassAmount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the low-pass filter parameter of the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDelay</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lowPassAmount</td><td>Low pass filter parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDelay</em></code> is initialized.</li>
<li><code>0.0f</code> &lt;= <code><em>lowPassAmount</em></code> &amp;&amp; <code><em>lowPassAmount</em></code> &lt;= <code>1.0f</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a61abee481b45e4c907b91262f647a2c5">nn::audio::GetDelayLowPassAmount(pDelay)</a></code> == <code><em>lowPassAmount</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The following low-pass filter (LPF) transfer function process is applied during a delay effect.</p>
<p>LPF(<code><em>z</em></code>) = <code><em>b0</em></code> / (<code>1</code>  <code><em>a1</em></code> * <code><em>z</em></code>^{<code>-1</code>})</p>
<p><code><em>a1</em></code> and <code><em>b0</em></code> are calculated using the following equations.</p>
<p><code><em>a1</em></code> = <code>0.95</code> * <code><em>lowPassAmount</em></code> <code><em>b0</em></code> = <code>1.0</code>  <code><em>a1</em></code></p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pDelay</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a91">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a88">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, and <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a110">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af44e602a06822569e8320430cfe56fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af44e602a06822569e8320430cfe56fcb">&#9670;&nbsp;</a></span>IsDelayEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::IsDelayEnabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *&#160;</td>
          <td class="paramname"><em>pDelay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDelay</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if enabled, or <code>false</code> otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDelay</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pDelay</em></code> while calling this function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a135">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af22e23e037505f7842e41730fa686724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22e23e037505f7842e41730fa686724">&#9670;&nbsp;</a></span>SetDelayEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetDelayEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *&#160;</td>
          <td class="paramname"><em>pDelay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables or disables the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDelay</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td><code>true</code> to enable, or <code>false</code> to disable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDelay</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#af44e602a06822569e8320430cfe56fcb">nn::audio::IsDelayEnabled(pDelay)</a></code> == <code><em>enable</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 When a delay effect is enabled, the effect is applied to the content of the input mix buffers and the resulting data is written to the output mix buffers according to the input/output buffer relationship specified using the <code><a class="el" href="namespacenn_1_1audio.html#a7ac9e44ccd0d4f0fd0865cd6871949e8" title="Sets the DelayType input/output mix buffer indexes.">nn::audio::SetDelayInputOutput()</a></code> function. When the effect is disabled, the contents of the input mix buffers are output as-is to the output mix buffers without applying the effect.</p>
<p>The values of parameters other than the enabled/disabled state are maintained before and after the <code><a class="el" href="namespacenn_1_1audio.html#af22e23e037505f7842e41730fa686724" title="Enables or disables the DelayType object.">SetDelayEnabled()</a></code> function is called. However, if you specify <code>true</code> when calling the <code><a class="el" href="namespacenn_1_1audio.html#af22e23e037505f7842e41730fa686724" title="Enables or disables the DelayType object.">SetDelayEnabled()</a></code> function, the internal state of <code><em>pDelay</em></code> is cleared. Any delay effect sounds that are still playing are cleared when you specify <code>false</code>.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pDelay</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a85">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a83">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, and <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a111">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a974890d53eaa0f0a7b16a5593535ce84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a974890d53eaa0f0a7b16a5593535ce84">&#9670;&nbsp;</a></span>IsDelayRemovable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::IsDelayRemovable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *&#160;</td>
          <td class="paramname"><em>pDelay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> object can be safely removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDelay</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if possible. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDelay</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 An effect can only be removed if the audio renderer has completely stopped using that effect. Before calling the <code><a class="el" href="namespacenn_1_1audio.html#a47262039889d9d23aeac0d82ed318ac0" title="Removes a DelayType object from FinalMixType.">nn::audio::RemoveDelay()</a></code> function, use this function to check whether the instance of <code>Delay</code> that you want to remove is no longer being used. Note the following.</p><ul>
<li>The use of effects does not stop immediately after disabling them using the <code><a class="el" href="namespacenn_1_1audio.html#af22e23e037505f7842e41730fa686724" title="Enables or disables the DelayType object.">nn::audio::SetDelayEnabled()</a></code> function.</li>
<li>It can take up to two audio frames for the use of the effect to stop after the effect is disabled by <code><a class="el" href="namespacenn_1_1audio.html#af22e23e037505f7842e41730fa686724" title="Enables or disables the DelayType object.">nn::audio::SetDelayEnabled()</a></code> and the call to <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> has completed.</li>
<li>Do not call the <code><a class="el" href="namespacenn_1_1audio.html#a47262039889d9d23aeac0d82ed318ac0" title="Removes a DelayType object from FinalMixType.">nn::audio::RemoveDelay()</a></code> function during this time.</li>
</ul>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pDelay</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="ae9783541dea0fef4e4bfed1b9b43d98e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9783541dea0fef4e4bfed1b9b43d98e">&#9670;&nbsp;</a></span>GetDelayParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1audio_1_1_delay_parameter_set.html">DelayParameterSet</a> nn::audio::GetDelayParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *&#160;</td>
          <td class="paramname"><em>pDelay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">nn::audio::DelayType</a></code> effect parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDelay</td><td>Pointer to an initialized <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">nn::audio::DelayType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the effect parameters. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutDelay</em></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aedc46b8476782082ba3b97e32e983e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc46b8476782082ba3b97e32e983e24">&#9670;&nbsp;</a></span>SetDelayParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetDelayParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_delay_type.html">DelayType</a> *&#160;</td>
          <td class="paramname"><em>pOutDelay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_delay_parameter_set.html">DelayParameterSet</a> *&#160;</td>
          <td class="paramname"><em>pParameterSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">nn::audio::DelayType</a></code> effect parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutDelay</td><td>Pointer to an initialized <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">nn::audio::DelayType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pParameterSet</td><td>The effect parameter to set for <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">nn::audio::DelayType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutDelay</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutDelay</em></code> is initialized.</li>
<li><code><em>pParameterSet</em></code> != <code>nullptr</code>.</li>
<li><code><a class="el" href="classnn_1_1_time_span.html#a2441d3c84cc24b901342ce11f87cd39c">nn::TimeSpan::FromMilliSeconds(0)</a></code> &lt;= <code><em>pParameterSet</em>-&gt;delayTime</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;delayTime</code> &lt;= <code><a class="el" href="namespacenn_1_1audio.html#a7eda2c006ca593d631a8caa7bd2d33c6" title="Gets the maximum delay time value that can be set for DelayType.">nn::audio::GetDelayTimeMax()</a></code>.</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;inGain</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;inGain</code> &lt;= <code>1.0f</code>.</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;feedbackGain</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;feedbackGain</code> &lt;= <code>1.0f</code>.</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;dryGain</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;dryGain</code> &lt;= <code>1.0f</code>.</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;channelSpread</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;channelSpread</code> &lt;= <code>1.0f</code>.</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;lowPassAmount</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;lowPassAmount</code> &lt;= <code>1.0f</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 For more information about the meanings of the parameters, see Delay Parameters in the <a href="../../Package/contents/Pages/Page_93362777.html">Audio Effects</a> documentation. This function is not thread-safe. Do not perform any operations on <code><em>pOutDelay</em></code> while calling this function. </p>

</div>
</div>
<a id="ac15587e48e655921e4a3816e20602080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15587e48e655921e4a3816e20602080">&#9670;&nbsp;</a></span>GetRequiredBufferSizeForReverb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::audio::GetRequiredBufferSizeForReverb </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelCountMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the work buffer size required for the renderer in order to use <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleRate</td><td>The sample rate set in the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> object that is adding <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCountMax</td><td>The maximum number of channels to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the buffer size required for using <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>(<code><em>sampleRate</em></code> == <code>32000</code>) || (<code><em>sampleRate</em></code> == <code>48000</code>).</li>
<li>(<code><em>channelCountMax</em></code> == <code>1</code>) || (<code><em>channelCountMax</em></code> == <code>2</code>) || (<code><em>channelCountMax</em></code> == <code>4</code> ) || (<code><em>channelCountMax</em></code> == <code>6</code>).</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The required memory for <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> depends on the values configured for the sampling rate and number of channels. Use this function to calculate the required memory for <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> based on the specified values for these parameters.</p>
<p>For <code><em>sampleRate</em></code>, specify the sampling rate set for the instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> to which <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> was added using the <code><a class="el" href="namespacenn_1_1audio.html#aa081b9cab7e4ca8d079093c1fc50bb4d" title="Adds a ReverbType object to FinalMixType.">nn::audio::AddReverb()</a></code> function. Use the <code><a class="el" href="namespacenn_1_1audio.html#a331b58a86c70fe45bf649941db3ca55e" title="Gets the sample rate of the SubMixType object.">nn::audio::GetSubMixSampleRate()</a></code> function to get the sampling rate for <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, and use the <code><a class="el" href="namespacenn_1_1audio.html#a25ee6f076a7eb80a0fc937c42d41e652" title="Gets the sampling rate of the audio renderer processing.">nn::audio::GetAudioRendererSampleRate()</a></code> function to get the sampling rate for <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>.</p>
<p>For <code><em>channelCountMax</em></code>, specify the number of channels supported by <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a135">AudioEffect/AudioEffect.cpp</a>, and <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a101">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aa081b9cab7e4ca8d079093c1fc50bb4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa081b9cab7e4ca8d079093c1fc50bb4d">&#9670;&nbsp;</a></span>AddReverb() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::AddReverb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pFinalMix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelCountMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#abcc7c4eb06afe0673e8196edc23dd9f0" title="Initializes FinalMixType and adds it to the AudioRendererConfig.">nn::audio::AcquireFinalMix()</a></code> initializes <code><em>pFinalMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>An uninitialized <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the memory region to use for <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size of memory specified by <code><em>buffer</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFinalMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> that adds the effect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCountMax</td><td>The maximum number of channels that can be set for <code><em>pReverb</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html">nn::audio::ResultOutOfResource</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is uninitialized.</li>
<li><code><em>buffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>buffer</em></code> is aligned to <code><a class="el" href="namespacenn_1_1audio.html#a61833f2e2cf0253e3054188e900315af" title="The alignment size for audio buffers.">nn::audio::BufferAlignSize</a></code>.</li>
<li><code><em>bufferSize</em></code> &gt;= <code><a class="el" href="namespacenn_1_1audio.html#ac15587e48e655921e4a3816e20602080">nn::audio::GetRequiredBufferSizeForReverb(sampleRate, channelCountMax)</a></code>. (<code><em>sampleRate</em></code> is the sample rate set in <code><em>pFinalMix</em></code>. You can get it using <code><a class="el" href="namespacenn_1_1audio.html#a25ee6f076a7eb80a0fc937c42d41e652" title="Gets the sampling rate of the audio renderer processing.">nn::audio::GetAudioRendererSampleRate()</a></code>.)</li>
<li><code><em>pFinalMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pFinalMix</em></code> is initialized.</li>
<li>(<code><em>channelCountMax</em></code> == <code>1</code>) || (<code><em>channelCountMax</em></code> == <code>2</code>) || (<code><em>channelCountMax</em></code> == <code>4</code> ) || (<code><em>channelCountMax</em></code> == <code>6</code>).</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Adds an instance of <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> to <code><em>pFinalMix</em></code> and initializes <code><em>pReverb</em></code>. The <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> effect emulates the echoing sounds that occur in closed spaces. When this function is called, <code><em>pReverb</em></code> is associated with <code><em>pFinalMix</em></code>, which makes it possible to perform effect operations on mix buffers managed by <code><em>pFinalMix</em></code>. All future operations on <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> should be performed via <code><em>pReverb</em></code>. For a list of functions that can be used with <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code>, see the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> reference.</p>
<p><code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> requires a work buffer to process the effect. Allocate a buffer that is at least equal to the value returned by the <code><a class="el" href="namespacenn_1_1audio.html#ac15587e48e655921e4a3816e20602080" title="Gets the work buffer size required for the renderer in order to use ReverbType.">nn::audio::GetRequiredBufferSizeForReverb()</a></code> in size, and specify that buffer and its size for <code><em>buffer</em></code> and <code><em>bufferSize</em></code>. The memory region specified for <code><em>buffer</em></code> must be contained within the memory region specified for <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html" title="Structure for representing memory regions used by an audio renderer.">nn::audio::MemoryPoolType</a></code>. Also, the instance of <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html" title="Structure for representing memory regions used by an audio renderer.">nn::audio::MemoryPoolType</a></code> that contains the memory region specified for <code><em>buffer</em></code> must be in the attached state.</p>
<p>Only one instance of each type of effect can be added to a single <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. A single instance of an effect cannot be added to multiple instances of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. The following warning message is displayed if an initialized effect that has already been added to an instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> is added to the same instance or another instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> again. </p><div class="fragment"><div class="line">[<a class="code" href="namespacenn_1_1audio.html">nn::audio</a>] Warning: The passed effect is already initialized. Please confirm <span class="keywordflow">if</span> (address <span class="keywordflow">for</span> effect instance) is a valid effect <span class="keywordtype">object</span>.</div>
</div><!-- fragment --><p> ("address for effect instance" is the address of the instance of the effect that you attempted to add.) For <code><em>channelCountMax</em></code>, specify the number of channels supported by <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code>. The maximum number of channels that can be specified here is the value specified for <code><em>count</em></code> in the <code><a class="el" href="namespacenn_1_1audio.html#aff0e36cd224e963c355f8ef8fa88c38a" title="Sets the ReverbType input/output mix buffer indexes.">nn::audio::SetReverbInputOutput()</a></code> function. For more information, see <code><a class="el" href="namespacenn_1_1audio.html#aff0e36cd224e963c355f8ef8fa88c38a" title="Sets the ReverbType input/output mix buffer indexes.">nn::audio::SetReverbInputOutput()</a></code>.</p>
<p>Immediately after a reverb is added, <code><em>pReverb</em></code> is not connected to the input/output mix buffers, and <code><em>pReverb</em></code> transitions to an enabled state. Use the <code><a class="el" href="namespacenn_1_1audio.html#aff0e36cd224e963c355f8ef8fa88c38a" title="Sets the ReverbType input/output mix buffer indexes.">nn::audio::SetReverbInputOutput()</a></code> function to specify the indices of the input/output mix buffers to which to apply the effect.</p>
<p>If the process for adding the effect fails and the function returns <code><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html" title="A class that represents error Result values (audio: Insufficient resources.).">nn::audio::ResultOutOfResource</a></code>, this usually indicates that the number of effects currently being used exceeds the maximum number of effects specified for <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html" title="The audio renderer parameters.">nn::audio::AudioRendererParameter</a>.<em>effectCount</em></code>. Delete one of the other effects or increase the number specified for <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html" title="The audio renderer parameters.">nn::audio::AudioRendererParameter</a>.<em>effectCount</em></code>.</p>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad771f7516d8c6eea51938171d9389af7" title="Adds a BiquadFilterType object to FinalMixType.">nn::audio::AddBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a2163e3d699edc8244383a94ed760f0be" title="Removes a BiquadFilterType object from FinalMixType.">nn::audio::RemoveBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a7bd3cc176b82c7cd5659c364ab97ab08" title="Adds BufferMixer to FinalMixType.">nn::audio::AddBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a400aff980a26fd295d911adbffd5f8ae" title="Removes BufferMixer from FinalMixType.">nn::audio::RemoveBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad332d3b8805f5157ef98572a99a9f2a0" title="Adds a DelayType object to FinalMixType.">nn::audio::AddDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a47262039889d9d23aeac0d82ed318ac0" title="Removes a DelayType object from FinalMixType.">nn::audio::RemoveDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aa081b9cab7e4ca8d079093c1fc50bb4d" title="Adds a ReverbType object to FinalMixType.">nn::audio::AddReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a8dda67780e46472ca22360376e6eb831" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a88bff95c7242f9d37ae5f631e825648b" title="Adds a I3dl2ReverbType object to FinalMixType.">nn::audio::AddI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a32e1724b072fff4284c19e597ac94d84" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a086c8ae883a8dabacad2c3ff3e995f13" title="Adds an AuxType object to FinalMixType.">nn::audio::AddAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a5133a62d6f97d3054e9ad428ae866102" title="Removes an AuxType object from FinalMixType.">nn::audio::RemoveAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a0bab4b3f6c0c1c7aa0011d2ee4b33919" title="Adds a LightLimiterType object to FinalMixType.">nn::audio::AddLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aacc63377e4f4f87617ff50fc981b170d" title="Removes a LightLimiterType object from FinalMixType.">nn::audio::RemoveLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ab3024a56e39831c3ba5fc8e52bca1a7e" title="Adds a CaptureType object to FinalMixType.">nn::audio::AddCapture()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a3fd8807d5efcb1fae477f690c8a8b48d" title="Removes the CaptureType object from FinalMixType.">nn::audio::RemoveCapture()</a></code></li>
</ul>
<p>Also, do not perform any operations on <code><em>pFinalMix</em></code> while calling any of these functions. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a137">AudioEffect/AudioEffect.cpp</a>, and <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a112">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a058f117990f85d9d9e846282f6641e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058f117990f85d9d9e846282f6641e56">&#9670;&nbsp;</a></span>AddReverb() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::AddReverb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pSubMix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelCountMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#a24020da05700a26ee46f04f5762c157f" title="Initializes a SubMixType object and adds it to AudioRendererConfig.">nn::audio::AcquireSubMix()</a></code> initializes <code><em>pSubMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>An uninitialized <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the memory region to use for <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size of memory specified by <code><em>buffer</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSubMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> to which the effect is being added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCountMax</td><td>The maximum number of channels that can be set for <code><em>pReverb</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html">nn::audio::ResultOutOfResource</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is uninitialized.</li>
<li><code><em>buffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>buffer</em></code> is aligned to <code><a class="el" href="namespacenn_1_1audio.html#a61833f2e2cf0253e3054188e900315af" title="The alignment size for audio buffers.">nn::audio::BufferAlignSize</a></code>.</li>
<li><code><em>bufferSize</em></code> &gt;= <code><a class="el" href="namespacenn_1_1audio.html#ac15587e48e655921e4a3816e20602080">nn::audio::GetRequiredBufferSizeForReverb(GetSubMixSampleRate(pSubMix)</a>, channelCountMax)</code>.</li>
<li><code><em>pSubMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSubMix</em></code> is initialized.</li>
<li>(<code><em>channelCountMax</em></code> == <code>1</code>) || (<code><em>channelCountMax</em></code> == <code>2</code>) || (<code><em>channelCountMax</em></code> == <code>4</code> ) || (<code><em>channelCountMax</em></code> == <code>6</code>).</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Except when called on an instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, this function works the same as <code><a class="el" href="namespacenn_1_1audio.html#aa081b9cab7e4ca8d079093c1fc50bb4d" title="Adds a ReverbType object to FinalMixType.">nn::audio::AddReverb</a>(AudioRendererConfig* <em>pOutConfig</em>, ReverbType* <em>pReverb</em>, void* <em>buffer</em>, size_t <em>bufferSize</em>, FinalMixType* <em>pFinalMix</em>, int <em>channelCount</em>)</code>. </p>

</div>
</div>
<a id="a8dda67780e46472ca22360376e6eb831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dda67780e46472ca22360376e6eb831">&#9670;&nbsp;</a></span>RemoveReverb() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * nn::audio::RemoveReverb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pFinalMix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a <code><em><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></em></code> object from <code>FinalMix</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#abcc7c4eb06afe0673e8196edc23dd9f0" title="Initializes FinalMixType and adds it to the AudioRendererConfig.">nn::audio::AcquireFinalMix()</a></code> initializes <code><em>pFinalMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object added to <code><em>pFinalMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFinalMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> that removes <code><em>pReverb</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the memory used for <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code>. (The memory passed to <code><em>buffer</em></code> when initialized by <code><a class="el" href="namespacenn_1_1audio.html#aa081b9cab7e4ca8d079093c1fc50bb4d" title="Adds a ReverbType object to FinalMixType.">nn::audio::AddReverb()</a></code>.) </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#afb3b452f9bc03b127c6d1ea4b7e340eb">nn::audio::IsReverbRemovable(pReverb)</a></code> == <code>true</code>.</li>
<li><code><em>pFinalMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pFinalMix</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pReverb</em></code> is uninitialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 An effect can only be removed if the audio renderer has completely stopped using that effect. This function calls the <code><a class="el" href="namespacenn_1_1audio.html#a538fed00cd1c56b19858e73f6d06a59c" title="Sets the ReverbType object to be enabled or disabled.">nn::audio::SetReverbEnabled()</a></code> function to disable <code>Reverb</code> before removing that instance of <code>Reverb</code> and then calls the <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> function to notify the audio renderer that <code>Reverb</code> has been disabled. After calling the <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> function, use the <code><a class="el" href="namespacenn_1_1audio.html#afb3b452f9bc03b127c6d1ea4b7e340eb" title="Determines whether the ReverbType object can be safely removed.">nn::audio::IsReverbRemovable()</a></code> function to determine whether the audio renderer has completely stopped using the effect and the reverb can be safely removed. After calling the <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> function, it may take up to two audio frames for the audio renderer to completely stop using the effect.</p>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad771f7516d8c6eea51938171d9389af7" title="Adds a BiquadFilterType object to FinalMixType.">nn::audio::AddBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a2163e3d699edc8244383a94ed760f0be" title="Removes a BiquadFilterType object from FinalMixType.">nn::audio::RemoveBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a7bd3cc176b82c7cd5659c364ab97ab08" title="Adds BufferMixer to FinalMixType.">nn::audio::AddBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a400aff980a26fd295d911adbffd5f8ae" title="Removes BufferMixer from FinalMixType.">nn::audio::RemoveBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad332d3b8805f5157ef98572a99a9f2a0" title="Adds a DelayType object to FinalMixType.">nn::audio::AddDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a47262039889d9d23aeac0d82ed318ac0" title="Removes a DelayType object from FinalMixType.">nn::audio::RemoveDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aa081b9cab7e4ca8d079093c1fc50bb4d" title="Adds a ReverbType object to FinalMixType.">nn::audio::AddReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a8dda67780e46472ca22360376e6eb831" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a88bff95c7242f9d37ae5f631e825648b" title="Adds a I3dl2ReverbType object to FinalMixType.">nn::audio::AddI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a32e1724b072fff4284c19e597ac94d84" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a086c8ae883a8dabacad2c3ff3e995f13" title="Adds an AuxType object to FinalMixType.">nn::audio::AddAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a5133a62d6f97d3054e9ad428ae866102" title="Removes an AuxType object from FinalMixType.">nn::audio::RemoveAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a0bab4b3f6c0c1c7aa0011d2ee4b33919" title="Adds a LightLimiterType object to FinalMixType.">nn::audio::AddLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aacc63377e4f4f87617ff50fc981b170d" title="Removes a LightLimiterType object from FinalMixType.">nn::audio::RemoveLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ab3024a56e39831c3ba5fc8e52bca1a7e" title="Adds a CaptureType object to FinalMixType.">nn::audio::AddCapture()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a3fd8807d5efcb1fae477f690c8a8b48d" title="Removes the CaptureType object from FinalMixType.">nn::audio::RemoveCapture()</a></code></li>
</ul>
<p>Also, do not perform any operations on <code><em>pFinalMix</em></code> while calling any of these functions. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="abfd0546c68c93f7c420c9c93877eb59c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd0546c68c93f7c420c9c93877eb59c">&#9670;&nbsp;</a></span>RemoveReverb() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * nn::audio::RemoveReverb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pSubMix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a <code><em><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></em></code> object from <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#a24020da05700a26ee46f04f5762c157f" title="Initializes a SubMixType object and adds it to AudioRendererConfig.">nn::audio::AcquireSubMix()</a></code> initializes <code><em>pSubMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object added to <code><em>pSubMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSubMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> that removes <code><em>pReverb</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the memory used for <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code>. (The memory passed to <code><em>buffer</em></code> when initialized by <code><a class="el" href="namespacenn_1_1audio.html#aa081b9cab7e4ca8d079093c1fc50bb4d" title="Adds a ReverbType object to FinalMixType.">nn::audio::AddReverb()</a></code>.) </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#afb3b452f9bc03b127c6d1ea4b7e340eb">nn::audio::IsReverbRemovable(pReverb)</a></code> == <code>true</code>.</li>
<li><code><em>pSubMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSubMix</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pReverb</em></code> is uninitialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Except when called on an instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, this function works the same as <code><a class="el" href="namespacenn_1_1audio.html#a8dda67780e46472ca22360376e6eb831" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveReverb</a>(AudioRendererConfig* <em>pOutConfig</em>, ReverbType* <em>pReverb</em>, FinalMixType* <em>pFinalMix</em>)</code>. </p>

</div>
</div>
<a id="aff4e54df3d6356d4f5e8271acd78bd79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff4e54df3d6356d4f5e8271acd78bd79">&#9670;&nbsp;</a></span>GetReverbChannelCountMax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetReverbChannelCountMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum number of channels that can be set for <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the maximum value for the number of channels that can be set. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aff0e36cd224e963c355f8ef8fa88c38a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0e36cd224e963c355f8ef8fa88c38a">&#9670;&nbsp;</a></span>SetReverbInputOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetReverbInputOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> input/output mix buffer indexes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The array of indexes of input mix buffers to set in <code><em>pReverb</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>The array of indexes of output mix buffers set in <code><em>pReverb</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of mix buffer indexes stored in <code><em>input</em></code> and <code><em>output</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
<li><code><em>input</em></code> != <code>nullptr</code>.</li>
<li><code><em>output</em></code> != <code>nullptr</code>.</li>
<li>(<code><em>count</em></code> == <code>1</code>) || (<code><em>count</em></code> == <code>2</code>) || (<code><em>count</em></code> == <code>4</code>) || (<code><em>count</em></code> == <code>6</code>).</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sets the input/output buffer relationship for the specified <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> effect. The mix buffers corresponding to the indices specified for the <code><em>input</em></code> array are set as the input mix buffers, and the mix buffers corresponding to the indices specified for the <code><em>output</em></code> array are set as the output mix buffers. The same mix buffer indices can be specified for both <code><em>input</em></code> and <code><em>output</em></code>.</p>
<p>There are common rules for setting the input/output buffer relationship for each type of effect. For more information, see <code><a class="el" href="namespacenn_1_1audio.html#a70ca2b0217074d7daf6534da7db1de0b" title="Sets the input/output relationship of the mixing process performed by BufferMixer.">nn::audio::SetBufferMixerInputOutput()</a></code>.</p>
<p>The <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> <code><em>input</em></code> is processed on the assumption that input channels are in the following order. Be careful not to get the order wrong when you set <code><em>input</em></code>.</p><ul>
<li>For 2 ch: <code>FrontLeft</code>, <code>FrontRight</code>.</li>
<li>For 4 ch: <code>FrontLeft</code>, <code>FrontRight</code>, <code>RearLeft</code>, <code>RearRight</code>.</li>
<li>For 6 ch: <code>FrontLeft</code>, <code>FrontRight</code>, <code>FrontCenter</code>, <code>LowFrequency</code>, <code>RearLeft</code>, <code>RearRight</code>.</li>
</ul>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a103">AudioEffect/AudioEffect.cpp</a>, and <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a113">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a8c82e46e546877b86967dccd7f67f4b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c82e46e546877b86967dccd7f67f4b1">&#9670;&nbsp;</a></span>GetReverbInputOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::GetReverbInputOutput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>outInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>outOutput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the indexes of the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> input/output mix buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outInput</td><td>The array from which to get the indexes of the input mix buffers set in <code><em>pReverb</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outOutput</td><td>The array from which to get the indexes of the output mix buffers set in <code><em>pReverb</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutCount</td><td>The number of mix buffer indexes obtained in <code><em>outInput</em></code> and <code><em>outOutput</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Length of the <code><em>outInput</em></code> and <code><em>outOutput</em></code> arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
<li><code><em>outInput</em></code> != <code>nullptr</code>.</li>
<li><code><em>outOutput</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutCount</em></code> != <code>nullptr</code>.</li>
<li><code><em>count</em></code> &gt; <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the input/output buffer relationship for the specified <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> effect. The indices of the source input mix buffers are stored in <code><em>outInput</em></code>, and the indices of the output mix buffers are stored in <code><em>outOutput</em></code>. <code><em>outInput</em></code> and <code><em>outOutput</em></code> can store up to <code><em>count</em></code> indices. The actual number of mix buffer indexes that are stored in <code><em>outInput</em></code> and <code><em>outOutput</em></code> is returned to <code><em>pOutCount</em></code>.</p>
<p>This function gets the input/output buffer relationship specified using the <code><a class="el" href="namespacenn_1_1audio.html#aff0e36cd224e963c355f8ef8fa88c38a" title="Sets the ReverbType input/output mix buffer indexes.">nn::audio::SetReverbInputOutput()</a></code> function. If this function is called on an instance of <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> for which the <code><a class="el" href="namespacenn_1_1audio.html#aff0e36cd224e963c355f8ef8fa88c38a" title="Sets the ReverbType input/output mix buffer indexes.">nn::audio::SetReverbInputOutput()</a></code> function has not yet been called, nothing will be stored in <code><em>outInput</em></code> and <code><em>outOutput</em></code>, and a value of <code>0</code> will be stored in <code><em>pOutCount</em></code>. Also see the description of the <code><a class="el" href="namespacenn_1_1audio.html#aa081b9cab7e4ca8d079093c1fc50bb4d" title="Adds a ReverbType object to FinalMixType.">nn::audio::AddReverb()</a></code> function. If the number of channels set to <code><em>pReverb</em></code> is greater than the value specified for <code><em>count</em></code>, <code><em>outInput</em></code> and <code><em>outOutput</em></code> will only store up to <code><em>count</em></code> of the mix buffer indices.</p>
<p>For more information about the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> and <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> mix buffers, see Mix Buffers in the <a href="../../Package/contents/Pages/Page_89991492.html">Audio Renderer</a> documentation.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="ad2d434d80021951b86f047646bf365fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d434d80021951b86f047646bf365fb">&#9670;&nbsp;</a></span>GetReverbEarlyMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1audio_1_1_reverb_type.html#aba28878a06e614f8cfcebe12af7e0d50">ReverbType::EarlyMode</a> nn::audio::GetReverbEarlyMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the early reflected sound mode of the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_delay_type.html" title="Delay effects.">DelayType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the early reflected sound mode. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> * <code><em>pReverb</em></code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="a27abfee25a0a706e70ff422ce1e98052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27abfee25a0a706e70ff422ce1e98052">&#9670;&nbsp;</a></span>SetReverbEarlyMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetReverbEarlyMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_reverb_type.html#aba28878a06e614f8cfcebe12af7e0d50">ReverbType::EarlyMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the early reflected sound mode for the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Early reflected sound mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad2d434d80021951b86f047646bf365fb">nn::audio::GetReverbEarlyMode(pReverb)</a></code> == <code><em>mode</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a68">AudioEffect/AudioEffect.cpp</a>, and <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a114">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a27f673bcf0e2f9732a182bdeb0a8c57a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27f673bcf0e2f9732a182bdeb0a8c57a">&#9670;&nbsp;</a></span>GetReverbEarlyGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetReverbEarlyGain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the gain of the early reflected sound of the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the early reflected sound gain. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="a9f590b0ee7bb678ed5fe5dd4c7a34625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f590b0ee7bb678ed5fe5dd4c7a34625">&#9670;&nbsp;</a></span>SetReverbEarlyGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetReverbEarlyGain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>gain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the gain of the early reflected sound for the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gain</td><td>Early reflected sound gain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
<li><code>0.0f</code> &lt;= <code><em>gain</em></code> &lt;= <code>1.0f</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a27f673bcf0e2f9732a182bdeb0a8c57a">nn::audio::GetReverbEarlyGain(pReverb)</a></code> == <code><em>gain</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a69">AudioEffect/AudioEffect.cpp</a>, and <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a116">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a18f70a8ace1728dd6be20426d375df8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f70a8ace1728dd6be20426d375df8d">&#9670;&nbsp;</a></span>GetReverbPredelayTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> nn::audio::GetReverbPredelayTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the pre-delay time of the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the pre-delay time. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="a48695d8f40bbbc14bef58d2d1033bd7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48695d8f40bbbc14bef58d2d1033bd7e">&#9670;&nbsp;</a></span>SetReverbPredelayTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetReverbPredelayTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the pre-delay time for the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>Pre-delay time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
<li><code><a class="el" href="classnn_1_1_time_span.html#a2441d3c84cc24b901342ce11f87cd39c">nn::TimeSpan::FromMilliSeconds(0)</a></code> &lt;= <code><em>time</em></code> &lt;= <code><a class="el" href="classnn_1_1_time_span.html#a2441d3c84cc24b901342ce11f87cd39c">nn::TimeSpan::FromMilliSeconds(300)</a></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a18f70a8ace1728dd6be20426d375df8d">nn::audio::GetReverbPredelayTime(pReverb)</a></code> == <code><em>time</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a70">AudioEffect/AudioEffect.cpp</a>, and <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a117">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a482077842a0a7eff2cf07674d7d1cc4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482077842a0a7eff2cf07674d7d1cc4d">&#9670;&nbsp;</a></span>GetReverbLateMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1audio_1_1_reverb_type.html#a180b7274e24a924de18f2523852626ac">ReverbType::LateMode</a> nn::audio::GetReverbLateMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the late reverb sound mode of the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the latter stage reverberation sound mode. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="a697f7a665c9bcc92536e9415a0143e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a697f7a665c9bcc92536e9415a0143e24">&#9670;&nbsp;</a></span>SetReverbLateMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetReverbLateMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_reverb_type.html#a180b7274e24a924de18f2523852626ac">ReverbType::LateMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the late reverb sound mode for the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Latter stage reverberation sound mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a482077842a0a7eff2cf07674d7d1cc4d">nn::audio::GetReverbLateMode(pReverb)</a></code> == <code><em>mode</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a71">AudioEffect/AudioEffect.cpp</a>, and <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a118">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af87d0bc0f4478187c6bd792ab847f3c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af87d0bc0f4478187c6bd792ab847f3c0">&#9670;&nbsp;</a></span>GetReverbLateGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetReverbLateGain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the gain of the late reverb of the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the latter stage reverberation sound gain. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="a7938c31a464de54d5a8e0e655dfe6381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7938c31a464de54d5a8e0e655dfe6381">&#9670;&nbsp;</a></span>SetReverbLateGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetReverbLateGain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>gain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the gain of the late reverb for the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gain</td><td>Latter stage reverberation sound gain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
<li><code>0.0f</code> &lt;= <code><em>gain</em></code> &lt;= <code>1.0f</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#af87d0bc0f4478187c6bd792ab847f3c0">nn::audio::GetReverbLateGain(pReverb)</a></code> == <code><em>gain</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a72">AudioEffect/AudioEffect.cpp</a>, and <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a120">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aba4e3eb8a6f9379bd4fa39f976861ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4e3eb8a6f9379bd4fa39f976861ac1">&#9670;&nbsp;</a></span>GetReverbDecayTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> nn::audio::GetReverbDecayTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the reverberation time of the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the reverberation time. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="ae18ec92d863f3795cca87501c0fae0fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18ec92d863f3795cca87501c0fae0fe">&#9670;&nbsp;</a></span>SetReverbDecayTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetReverbDecayTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the reverberation time for the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>Reverberation time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
<li><code><a class="el" href="classnn_1_1_time_span.html#a2441d3c84cc24b901342ce11f87cd39c">nn::TimeSpan::FromMilliSeconds(100)</a></code> &lt;= <code><em>time</em></code> &lt;= <code><a class="el" href="classnn_1_1_time_span.html#a8e74f5ceb64fc02aa614eed3cc148e82">nn::TimeSpan::FromSeconds(20)</a></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#aba4e3eb8a6f9379bd4fa39f976861ac1">nn::audio::GetReverbDecayTime(pReverb)</a></code> == <code><em>time</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a73">AudioEffect/AudioEffect.cpp</a>, and <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a121">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab9529458496a896c0346d89c59b00514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9529458496a896c0346d89c59b00514">&#9670;&nbsp;</a></span>GetReverbHighFrequencyDecayRatio()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetReverbHighFrequencyDecayRatio </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the high-frequency attenuation rate of the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the high frequency attenuation rate. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="a5d498965acc8537a96cb09975beaffb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d498965acc8537a96cb09975beaffb3">&#9670;&nbsp;</a></span>SetReverbHighFrequencyDecayRatio()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetReverbHighFrequencyDecayRatio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ratio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the high-frequency attenuation rate for the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ratio</td><td>High frequency attenuation rate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
<li><code>0.1f</code> &lt;= <code><em>ratio</em></code> &lt;= <code>1.0f</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#ab9529458496a896c0346d89c59b00514">nn::audio::GetReverbHighFrequencyDecayRatio(pReverb)</a></code> == <code><em>ratio</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a74">AudioEffect/AudioEffect.cpp</a>, and <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a122">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a15b63fd521d0802b30c5225e16f02a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15b63fd521d0802b30c5225e16f02a38">&#9670;&nbsp;</a></span>GetReverbColoration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetReverbColoration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the reverb coloration parameter of the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the reverberation sound tone color. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="aad4ac77900079e7b2ed46d4786ea6d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4ac77900079e7b2ed46d4786ea6d47">&#9670;&nbsp;</a></span>SetReverbColoration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetReverbColoration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the reverb coloration parameter for the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Reverberation sound tone color. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
<li><code>0.0f</code> &lt;= <code><em>value</em></code> &lt;= <code>1.0f</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a15b63fd521d0802b30c5225e16f02a38">nn::audio::GetReverbColoration(pReverb)</a></code> == <code><em>value</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a75">AudioEffect/AudioEffect.cpp</a>, and <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a123">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1d20ae6043da7f7ce625c8f995ae5e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d20ae6043da7f7ce625c8f995ae5e3f">&#9670;&nbsp;</a></span>GetReverbReverbGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetReverbReverbGain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the reverb gain of the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the reverb gain. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="adfe0d6397b0092e46b93632a7ac5e55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe0d6397b0092e46b93632a7ac5e55e">&#9670;&nbsp;</a></span>SetReverbReverbGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetReverbReverbGain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>gain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the reverb gain for the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gain</td><td>Reverb gain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
<li><code>0.0f</code> &lt;= <code><em>gain</em></code> &lt;= <code>1.0f</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a1d20ae6043da7f7ce625c8f995ae5e3f">nn::audio::GetReverbReverbGain(pReverb)</a></code> == <code><em>gain</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a76">AudioEffect/AudioEffect.cpp</a>, and <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a124">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a98af6a84f74bfea25631b3f0d0e2ff19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98af6a84f74bfea25631b3f0d0e2ff19">&#9670;&nbsp;</a></span>GetReverbOutGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetReverbOutGain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the output gain of the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the output gain. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="a16465cda5c37905584b55897af87e57f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16465cda5c37905584b55897af87e57f">&#9670;&nbsp;</a></span>SetReverbOutGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetReverbOutGain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>gain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the output gain for the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gain</td><td>Output gain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
<li><code>0.0f</code> &lt;= <code><em>gain</em></code> &lt;= <code>1.0f</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a77">AudioEffect/AudioEffect.cpp</a>, and <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a125">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a83cd9776d37fb17187714acdc0bdbcab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83cd9776d37fb17187714acdc0bdbcab">&#9670;&nbsp;</a></span>GetReverbDryGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetReverbDryGain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the dry gain of the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the dry gain. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="a9937a89c853ffa172d1ccef907419cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9937a89c853ffa172d1ccef907419cb2">&#9670;&nbsp;</a></span>SetReverbDryGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetReverbDryGain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>gain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the dry gain for the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gain</td><td>Dry gain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
<li><code>0.0f</code> &lt;= <code><em>gain</em></code> &lt;= <code>1.0f</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a83cd9776d37fb17187714acdc0bdbcab">nn::audio::GetReverbDryGain(pReverb)</a></code> == <code><em>gain</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a78">AudioEffect/AudioEffect.cpp</a>, and <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a126">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a8e68ef8212f9dc5599d727f925db5fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e68ef8212f9dc5599d727f925db5fca">&#9670;&nbsp;</a></span>GetReverbParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1audio_1_1_reverb_parameter_set.html">ReverbParameterSet</a> nn::audio::GetReverbParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">nn::audio::ReverbType</a></code> effect parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>Pointer to an initialized <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">nn::audio::ReverbType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the effect parameters. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutReverb</em></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a075fd070a208ac1d593d4e7614b5305f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075fd070a208ac1d593d4e7614b5305f">&#9670;&nbsp;</a></span>SetReverbParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetReverbParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pOutReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_reverb_parameter_set.html">ReverbParameterSet</a> *&#160;</td>
          <td class="paramname"><em>pParameterSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">nn::audio::ReverbType</a></code> effect parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutReverb</td><td>Pointer to an initialized <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">nn::audio::ReverbType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pParameterSet</td><td>The effect parameter to set for <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">nn::audio::ReverbType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutReverb</em></code> is initialized.</li>
<li><code><em>pParameterSet</em></code> != <code>nullptr</code>.</li>
<li><code><em>pParameterSet</em>-&gt;earlyMode</code> == <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html#aba28878a06e614f8cfcebe12af7e0d50ad629d54d436cb80e20f34d86470eed66" title="Small room.">nn::audio::ReverbType::EarlyMode_SmallRoom</a></code> || <code><em>pParameterSet</em>-&gt;earlyMode</code> == <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html#aba28878a06e614f8cfcebe12af7e0d50a69b68a59615af3d2e469260d95d86422" title="Large room.">nn::audio::ReverbType::EarlyMode_LargeRoom</a></code> || <code><em>pParameterSet</em>-&gt;earlyMode</code> == <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html#aba28878a06e614f8cfcebe12af7e0d50a54a457d567a728bc8acc9b75d4b9abcf" title="Performance hall.">nn::audio::ReverbType::EarlyMode_Hall</a></code> || <code><em>pParameterSet</em>-&gt;earlyMode</code> == <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html#aba28878a06e614f8cfcebe12af7e0d50aa0e028d716bc5af9f4662f2a8885bde7" title="Cave.">nn::audio::ReverbType::EarlyMode_Cavern</a></code> || <code><em>pParameterSet</em>-&gt;earlyMode</code> == <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html#aba28878a06e614f8cfcebe12af7e0d50a0fe9e909d773e66cc9886c3d842d4d4f" title="No early reflected sound.">nn::audio::ReverbType::EarlyMode_NoEarlyReflection</a></code></li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;earlyGain</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;earlyGain</code> &lt;= <code>1.0f</code>.</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;predelayTimeMilliSeconds</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;predelayTimeMilliSeconds</code> &lt;= <code>300.0f</code>.</li>
<li><code><em>pParameterSet</em>-&gt;lateMode</code> == <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html#a180b7274e24a924de18f2523852626aca405e9d554d53f558b74d7c8f8f5df846" title="Performance hall.">nn::audio::ReverbType::LateMode_Hall</a></code> || <code><em>pParameterSet</em>-&gt;lateMode</code> == <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html#a180b7274e24a924de18f2523852626aca727a8f7f82afb3d0a702b62312155943" title="Metal corridor.">nn::audio::ReverbType::LateMode_MetalCorridor</a></code> || <code><em>pParameterSet</em>-&gt;lateMode</code> == <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html#a180b7274e24a924de18f2523852626aca6aff777a5b8d8fcc5cad1de1ef9a928c" title="Cave.">nn::audio::ReverbType::LateMode_Cavern</a></code> || <code><em>pParameterSet</em>-&gt;lateMode</code> == <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html#a180b7274e24a924de18f2523852626aca999c1aa5d34604baf3754ea3226a938a" title="Maximum delay (reverb).">nn::audio::ReverbType::LateMode_MaximumDelay</a></code></li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;lateGain</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;lateGain</code> &lt;= <code>1.0f</code>.</li>
<li><code>0.1f</code> &lt;= <code><em>pParameterSet</em>-&gt;decayTimeSeconds</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;decayTimeSeconds</code> &lt;= <code>20.0f</code>.</li>
<li><code>0.1f</code> &lt;= <code><em>pParameterSet</em>-&gt;highFreqDecayRatio</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;highFreqDecayRatio</code> &lt;= <code>1.0f</code>.</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;coloration</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;coloration</code> &lt;= <code>1.0f</code>.</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;reverbGain</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;reverbGain</code> &lt;= <code>1.0f</code>.</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;outGain</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;outGain</code> &lt;= <code>1.0f</code>.</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;dryGain</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;dryGain</code> &lt;= <code>1.0f</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 For more information about the meanings of the parameters, see Reverb Parameters in the <a href="../../Package/contents/Pages/Page_93362777.html">Audio Effects</a> documentation.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pOutReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="a6f5fe53550704575b0591936be0538be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f5fe53550704575b0591936be0538be">&#9670;&nbsp;</a></span>IsReverbEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::IsReverbEnabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if enabled, or <code>false</code> otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="a538fed00cd1c56b19858e73f6d06a59c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538fed00cd1c56b19858e73f6d06a59c">&#9670;&nbsp;</a></span>SetReverbEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetReverbEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object to be enabled or disabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td><code>true</code> to enable, or <code>false</code> to disable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a6f5fe53550704575b0591936be0538be">nn::audio::IsReverbEnabled(pReverb)</a></code> == <code><em>enable</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 When a reverb effect is enabled, the effect is applied to the content of the input mix buffers and the resulting data is written to the output mix buffers according to the input/output buffer relationship specified using the <code><a class="el" href="namespacenn_1_1audio.html#aff0e36cd224e963c355f8ef8fa88c38a" title="Sets the ReverbType input/output mix buffer indexes.">nn::audio::SetReverbInputOutput()</a></code> function. When the effect is disabled, the contents of the input mix buffers are output as-is to the output mix buffers without applying the effect.</p>
<p>The values of parameters other than the enabled/disabled state are maintained before and after the <code><a class="el" href="namespacenn_1_1audio.html#a538fed00cd1c56b19858e73f6d06a59c" title="Sets the ReverbType object to be enabled or disabled.">SetReverbEnabled()</a></code> function is called. However, if you specify <code>true</code> when calling the <code><a class="el" href="namespacenn_1_1audio.html#a538fed00cd1c56b19858e73f6d06a59c" title="Sets the ReverbType object to be enabled or disabled.">SetReverbEnabled()</a></code> function, the internal state of <code><em>pReverb</em></code> is cleared. If there is a reverberant sound even when <code>false</code> has been specified, that sound gets cleared.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a67">AudioEffect/AudioEffect.cpp</a>, and <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a127">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="afb3b452f9bc03b127c6d1ea4b7e340eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3b452f9bc03b127c6d1ea4b7e340eb">&#9670;&nbsp;</a></span>IsReverbRemovable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::IsReverbRemovable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_reverb_type.html">ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> object can be safely removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if possible. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 An effect can only be removed if the audio renderer has completely stopped using that effect. Before calling the <code><a class="el" href="namespacenn_1_1audio.html#a8dda67780e46472ca22360376e6eb831" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveReverb()</a></code> function, use this function to check whether the instance of <code>Reverb</code> that you want to remove is no longer being used. Note the following.</p><ul>
<li>The use of effects does not stop immediately after disabling them using the <code><a class="el" href="namespacenn_1_1audio.html#a538fed00cd1c56b19858e73f6d06a59c" title="Sets the ReverbType object to be enabled or disabled.">nn::audio::SetReverbEnabled()</a></code> function.</li>
<li>After an effect is disabled using the <code>nn::audio::SetReverbEnable()</code> function, it can take up to two audio frames for calls to the <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> function to be completed.</li>
<li>Do not call the <code><a class="el" href="namespacenn_1_1audio.html#a8dda67780e46472ca22360376e6eb831" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveReverb()</a></code> function during this time.</li>
</ul>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="a55c33abdb3faf91f7f21f7fbf13c30fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55c33abdb3faf91f7f21f7fbf13c30fa">&#9670;&nbsp;</a></span>GetRequiredBufferSizeForAuxSendReturnBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::audio::GetRequiredBufferSizeForAuxSendReturnBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html">AudioRendererParameter</a> *&#160;</td>
          <td class="paramname"><em>pParameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mixBufferFrameCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelCountMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the work buffer size required for the renderer to use <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pParameter</td><td>The parameter used by the <code><a class="el" href="namespacenn_1_1audio.html#a855da5a3e7dd33233c653a7dd2db775a" title="Gets the audio renderer.">nn::audio::OpenAudioRenderer()</a></code> function to get the audio renderer belonging to the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> that is adding <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mixBufferFrameCount</td><td>The number of audio frames to hold in <code>AuxBuffer</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCountMax</td><td>The number of channels to store in <code>AuxBuffer</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the buffer size in bytes. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pParameter</em></code> != <code>nullptr</code>.</li>
<li><code><em>pParameter</em></code> is initialized.</li>
<li><code><em>mixBufferFrameCount</em></code> <code>1</code>.</li>
<li><code><em>channelCountMax</em></code> &gt; <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> internally manages two buffers: <code>SendBuffer</code> and <code>ReturnBuffer</code>. <code>SendBuffer</code> is used to pass sample data from the audio renderer to the user, and <code>ReturnBuffer</code> is used in the reverse direction from the user to the audio renderer. This function returns the buffer size needed by these two buffers.</p>
<p>The audio renderer reads a certain number of samples from the <code>ReturnBuffer</code> per each audio frame. The number of samples = (<code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html#a1c8b7223c7e2ce641691f4e4f93000dd" title="The number of samples maintained by one mix buffer.">AudioRendererParameter.sampleCount</a></code>)  (the number for <code><em>count</em></code> specified by <code><a class="el" href="namespacenn_1_1audio.html#a9d5f32d682169896adb6d6e6b08f5155" title="Sets the input/output buffer indexes for AuxType.">nn::audio::SetAuxInputOutput()</a></code>). If insufficient samples were read, the output after effect processing may not be continuous, which may cause noise. Use <code><a class="el" href="namespacenn_1_1audio.html#a28965347a7dc482c646c14e579449359" title="Writes count number of samples to AuxType.">nn::audio::WriteAuxReturnBuffer()</a></code> periodically to write sample data to <code>ReturnBuffer</code> so that this number will not run low.</p>
<p>Passing a buffer of the size returned by this function to <code><a class="el" href="namespacenn_1_1audio.html#a086c8ae883a8dabacad2c3ff3e995f13" title="Adds an AuxType object to FinalMixType.">nn::audio::AddAux()</a></code> internally buffers (<code><em>mixBufferFrameCount</em></code>  <code><em>channelCountMax</em></code>  <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html#a1c8b7223c7e2ce641691f4e4f93000dd" title="The number of samples maintained by one mix buffer.">AudioRendererParameter.sampleCount</a></code>) number of samples. This allows samples for multiple audio frames corresponding to <code><em>mixBufferFrameCount</em></code> to be buffered. The user side gains some free time for effect processing. At the same time, the delay after being passed to <code>SendBuffer</code> and writing to <code>ReturnBuffer</code>, increases as the size of <code><em>mixBufferFrameCount</em></code> is increased.</p>
<p>The user must set an appropriate value to <code><em>mixBufferFrameCount</em></code> according to the needed effect processing. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a145">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a103">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a71">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a086c8ae883a8dabacad2c3ff3e995f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086c8ae883a8dabacad2c3ff3e995f13">&#9670;&nbsp;</a></span>AddAux() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::AddAux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *&#160;</td>
          <td class="paramname"><em>pAux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pFinalMix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pSendBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pReturnBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sendReturnBufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#abcc7c4eb06afe0673e8196edc23dd9f0" title="Initializes FinalMixType and adds it to the AudioRendererConfig.">nn::audio::AcquireFinalMix()</a></code> initializes <code><em>pFinalMix</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pAux</td><td>An uninitialized <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFinalMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> to which the effect is being added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSendBuffer</td><td>The buffer used to store samples from the audio renderer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pReturnBuffer</td><td>The buffer used to store the samples being returned to the audio renderer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendReturnBufferSize</td><td>The size, in bytes, of <code><em>pSendBuffer</em></code> and <code><em>pReturnBuffer</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html">nn::audio::ResultOutOfResource</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pAux</em></code> != <code>nullptr</code>.</li>
<li><code><em>pAux</em></code> is uninitialized.</li>
<li><code><em>pFinalMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSendBuffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSendBuffer</em></code> is aligned to <code><a class="el" href="namespacenn_1_1audio.html#a61833f2e2cf0253e3054188e900315af" title="The alignment size for audio buffers.">nn::audio::BufferAlignSize</a></code>.</li>
<li><code><em>pReturnBuffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReturnBuffer</em></code> is aligned to <code><a class="el" href="namespacenn_1_1audio.html#a61833f2e2cf0253e3054188e900315af" title="The alignment size for audio buffers.">nn::audio::BufferAlignSize</a></code>.</li>
<li><code><em>pReturnBuffer</em></code> != <code><em>pSendBuffer</em></code>.</li>
<li><code><em>sendReturnBufferSize</em></code> &gt; <code>0</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pAux</em></code> is initialized.</li>
<li><code><em>pAux</em></code> is enabled.</li>
<li>The <code><em>pAux</em></code> input/output buffers are not configured.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> effects provide a way to add user-defined effects to the audio renderer. When this function is called, <code><em>pAux</em></code> is associated with <code><em>pFinalMix</em></code> and initialized, which makes it possible to perform effect operations on mix buffers managed by <code><em>pFinalMix</em></code>. All future operations on <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> are routed through <code><em>pAux</em></code>. For a list of functions that can be used with <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code>, see the <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> reference.</p>
<p>A similar effect exists in the form of <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code>, but with <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code>, the user can change the sample data and write back to the audio renderer. Because buffering is performed for these write backs, the output after effect processing is delayed with <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code>.</p>
<p><code><em>pSendBuffer</em></code> and <code><em>pReturnBuffer</em></code> are managed inside <code><em>pAux</em></code> and are used to transfer data back and forth with the audio renderer. The memory regions specified for <code><em>pSendBuffer</em></code> and <code><em>pReturnBuffer</em></code> must be contained within the memory region specified for <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html" title="Structure for representing memory regions used by an audio renderer.">nn::audio::MemoryPoolType</a></code>. Also, the instance of <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html" title="Structure for representing memory regions used by an audio renderer.">nn::audio::MemoryPoolType</a></code> that contains the memory regions specified for <code><em>pSendBuffer</em></code> and <code><em>pReturnBuffer</em></code> must be in the attached state. For more information, see <code><a class="el" href="namespacenn_1_1audio.html#a55c33abdb3faf91f7f21f7fbf13c30fa" title="Gets the work buffer size required for the renderer to use AuxType.">nn::audio::GetRequiredBufferSizeForAuxSendReturnBuffer()</a></code>.</p>
<p>Only one instance of each type of effect can be added to a single <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. A single instance of an effect cannot be added to multiple instances of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. The following warning message is displayed if an initialized effect that has already been added to an instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> is added to the same instance or another instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> again. </p><div class="fragment"><div class="line">[<a class="code" href="namespacenn_1_1audio.html">nn::audio</a>] Warning: The passed effect is already initialized. Please confirm <span class="keywordflow">if</span> (address <span class="keywordflow">for</span> effect instance) is a valid effect <span class="keywordtype">object</span>.</div>
</div><!-- fragment --><p> ("address for effect instance" is the address of the instance of the effect that you attempted to add.) Immediately after the effect is added, <code><em>pAux</em></code> is not connected to the input/output mix buffers, and <code><em>pAux</em></code> transitions to an enabled state. Use the <code><a class="el" href="namespacenn_1_1audio.html#a9d5f32d682169896adb6d6e6b08f5155" title="Sets the input/output buffer indexes for AuxType.">nn::audio::SetAuxInputOutput()</a></code> function to specify the indices of the input/output mix buffers to which to apply the effect.</p>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad771f7516d8c6eea51938171d9389af7" title="Adds a BiquadFilterType object to FinalMixType.">nn::audio::AddBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a2163e3d699edc8244383a94ed760f0be" title="Removes a BiquadFilterType object from FinalMixType.">nn::audio::RemoveBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a7bd3cc176b82c7cd5659c364ab97ab08" title="Adds BufferMixer to FinalMixType.">nn::audio::AddBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a400aff980a26fd295d911adbffd5f8ae" title="Removes BufferMixer from FinalMixType.">nn::audio::RemoveBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad332d3b8805f5157ef98572a99a9f2a0" title="Adds a DelayType object to FinalMixType.">nn::audio::AddDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a47262039889d9d23aeac0d82ed318ac0" title="Removes a DelayType object from FinalMixType.">nn::audio::RemoveDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aa081b9cab7e4ca8d079093c1fc50bb4d" title="Adds a ReverbType object to FinalMixType.">nn::audio::AddReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a8dda67780e46472ca22360376e6eb831" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a88bff95c7242f9d37ae5f631e825648b" title="Adds a I3dl2ReverbType object to FinalMixType.">nn::audio::AddI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a32e1724b072fff4284c19e597ac94d84" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a086c8ae883a8dabacad2c3ff3e995f13" title="Adds an AuxType object to FinalMixType.">nn::audio::AddAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a5133a62d6f97d3054e9ad428ae866102" title="Removes an AuxType object from FinalMixType.">nn::audio::RemoveAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a0bab4b3f6c0c1c7aa0011d2ee4b33919" title="Adds a LightLimiterType object to FinalMixType.">nn::audio::AddLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aacc63377e4f4f87617ff50fc981b170d" title="Removes a LightLimiterType object from FinalMixType.">nn::audio::RemoveLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ab3024a56e39831c3ba5fc8e52bca1a7e" title="Adds a CaptureType object to FinalMixType.">nn::audio::AddCapture()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a3fd8807d5efcb1fae477f690c8a8b48d" title="Removes the CaptureType object from FinalMixType.">nn::audio::RemoveCapture()</a></code></li>
</ul>
<p>Also, do not perform any operations on <code><em>pFinalMix</em></code> while calling any of these functions. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a146">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a105">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a73">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a9b9ded54aaf3b24b923e7f35f6bd80b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9ded54aaf3b24b923e7f35f6bd80b7">&#9670;&nbsp;</a></span>AddAux() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::AddAux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *&#160;</td>
          <td class="paramname"><em>pAux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pSubMix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pSendBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pReturnBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sendReturnBufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#a24020da05700a26ee46f04f5762c157f" title="Initializes a SubMixType object and adds it to AudioRendererConfig.">nn::audio::AcquireSubMix()</a></code> initializes <code><em>pSubMix</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pAux</td><td>An uninitialized <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSubMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> to which the effect is being added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSendBuffer</td><td>The buffer used to store samples from the audio renderer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pReturnBuffer</td><td>The buffer used to store the samples being returned to the audio renderer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendReturnBufferSize</td><td>The size, in bytes, of <code><em>pSendBuffer</em></code> and <code><em>pReturnBuffer</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html">nn::audio::ResultOutOfResource</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pAux</em></code> != <code>nullptr</code>.</li>
<li><code><em>pAux</em></code> is uninitialized.</li>
<li><code><em>pSubMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSendBuffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSendBuffer</em></code> is aligned to <code><a class="el" href="namespacenn_1_1audio.html#a61833f2e2cf0253e3054188e900315af" title="The alignment size for audio buffers.">nn::audio::BufferAlignSize</a></code>.</li>
<li><code><em>pReturnBuffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReturnBuffer</em></code> is aligned to <code><a class="el" href="namespacenn_1_1audio.html#a61833f2e2cf0253e3054188e900315af" title="The alignment size for audio buffers.">nn::audio::BufferAlignSize</a></code>.</li>
<li><code><em>pReturnBuffer</em></code> != <code><em>pSendBuffer</em></code>.</li>
<li><code><em>sendReturnBufferSize</em></code> &gt; <code>0</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pAux</em></code> is initialized.</li>
<li><code><em>pAux</em></code> is enabled.</li>
<li>The <code><em>pAux</em></code> input/output buffers are not configured.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Adds <code><em>pAux</em></code> to <code><em>pSubMix</em></code> and initializes <code><em>pAux</em></code>. Except when called on an instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, this function works the same as <code><a class="el" href="namespacenn_1_1audio.html#a086c8ae883a8dabacad2c3ff3e995f13" title="Adds an AuxType object to FinalMixType.">nn::audio::AddAux</a>(AudioRendererConfig* <em>pOutConfig</em>, AuxType* <em>pAux</em>, FinalMixType* <em>pFinalMix</em>, void* <em>pSendBuffer</em>, void* <em>pReturnBuffer</em>, size_t <em>sendReturnBufferSize</em>)</code>. </p>

</div>
</div>
<a id="a5133a62d6f97d3054e9ad428ae866102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5133a62d6f97d3054e9ad428ae866102">&#9670;&nbsp;</a></span>RemoveAux() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::RemoveAux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *&#160;</td>
          <td class="paramname"><em>pAux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pFinalMix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> object from <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#abcc7c4eb06afe0673e8196edc23dd9f0" title="Initializes FinalMixType and adds it to the AudioRendererConfig.">nn::audio::AcquireFinalMix()</a></code> initializes <code><em>pFinalMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pAux</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> object added to <code><em>pFinalMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFinalMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> that removes <code><em>pAux</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pAux</em></code> != <code>nullptr</code>.</li>
<li><code><em>pAux</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a3b94b1f2bb19fac01f8859ed4f3cc19e">nn::audio::IsAuxRemovable(pAux)</a></code> == <code>true</code>.</li>
<li><code><em>pFinalMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pFinalMix</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pAux</em></code> is uninitialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 An effect can only be removed if the audio renderer has completely stopped using that effect. This function calls the <code><em><a class="el" href="namespacenn_1_1audio.html#afd2b1ab69fe2131d81a8439e8a7ca5b9" title="Sets whether a AuxType is enabled.">nn::audio::SetAuxEnabled()</a></em></code> function to disable <code>Aux</code> before removing that instance of <code>Aux</code> and then calls the <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> function to notify the audio renderer that <code>Aux</code> has been disabled. After calling the <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> function, use the <code><a class="el" href="namespacenn_1_1audio.html#a3b94b1f2bb19fac01f8859ed4f3cc19e" title="Determines whether AuxType can be safely removed.">nn::audio::IsAuxRemovable()</a></code> function to determine whether the audio renderer has completely stopped using the effect and the effect can be safely removed.</p>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad771f7516d8c6eea51938171d9389af7" title="Adds a BiquadFilterType object to FinalMixType.">nn::audio::AddBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a2163e3d699edc8244383a94ed760f0be" title="Removes a BiquadFilterType object from FinalMixType.">nn::audio::RemoveBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a7bd3cc176b82c7cd5659c364ab97ab08" title="Adds BufferMixer to FinalMixType.">nn::audio::AddBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a400aff980a26fd295d911adbffd5f8ae" title="Removes BufferMixer from FinalMixType.">nn::audio::RemoveBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad332d3b8805f5157ef98572a99a9f2a0" title="Adds a DelayType object to FinalMixType.">nn::audio::AddDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a47262039889d9d23aeac0d82ed318ac0" title="Removes a DelayType object from FinalMixType.">nn::audio::RemoveDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aa081b9cab7e4ca8d079093c1fc50bb4d" title="Adds a ReverbType object to FinalMixType.">nn::audio::AddReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a8dda67780e46472ca22360376e6eb831" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a88bff95c7242f9d37ae5f631e825648b" title="Adds a I3dl2ReverbType object to FinalMixType.">nn::audio::AddI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a32e1724b072fff4284c19e597ac94d84" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a086c8ae883a8dabacad2c3ff3e995f13" title="Adds an AuxType object to FinalMixType.">nn::audio::AddAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a5133a62d6f97d3054e9ad428ae866102" title="Removes an AuxType object from FinalMixType.">nn::audio::RemoveAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a0bab4b3f6c0c1c7aa0011d2ee4b33919" title="Adds a LightLimiterType object to FinalMixType.">nn::audio::AddLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aacc63377e4f4f87617ff50fc981b170d" title="Removes a LightLimiterType object from FinalMixType.">nn::audio::RemoveLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ab3024a56e39831c3ba5fc8e52bca1a7e" title="Adds a CaptureType object to FinalMixType.">nn::audio::AddCapture()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a3fd8807d5efcb1fae477f690c8a8b48d" title="Removes the CaptureType object from FinalMixType.">nn::audio::RemoveCapture()</a></code></li>
</ul>
<p>Also, do not perform any operations on <code><em>pFinalMix</em></code> while calling any of these functions. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="a6e8ec792b7a22fddb98d03bbefd81d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e8ec792b7a22fddb98d03bbefd81d80">&#9670;&nbsp;</a></span>RemoveAux() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::RemoveAux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *&#160;</td>
          <td class="paramname"><em>pAux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pSubMix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> object from <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#a24020da05700a26ee46f04f5762c157f" title="Initializes a SubMixType object and adds it to AudioRendererConfig.">nn::audio::AcquireSubMix()</a></code> initializes <code><em>pSubMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pAux</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> added to <code><em>pSubMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSubMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> that removes <code><em>pAux</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pAux</em></code> != <code>nullptr</code>.</li>
<li><code><em>pAux</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a3b94b1f2bb19fac01f8859ed4f3cc19e">nn::audio::IsAuxRemovable(pAux)</a></code> == <code>true</code>.</li>
<li><code><em>pSubMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSubMix</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pAux</em></code> is uninitialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 An effect can only be removed if the audio renderer has completely stopped using that effect. Except when called on an instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, this function works the same as <code><a class="el" href="namespacenn_1_1audio.html#a5133a62d6f97d3054e9ad428ae866102" title="Removes an AuxType object from FinalMixType.">nn::audio::RemoveAux</a>(AudioRendererConfig* <em>pOutConfig</em>, AuxType* <em>pAux</em>, FinalMixType* <em>pFinalMix</em>)</code>. </p>

</div>
</div>
<a id="ab5c449b97f855ce0326406d1b48cc852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5c449b97f855ce0326406d1b48cc852">&#9670;&nbsp;</a></span>GetAuxChannelCountMax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetAuxChannelCountMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *&#160;</td>
          <td class="paramname"><em>pAux</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum number of channels that can be set for <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAux</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the maximum value for the number of channels that can be set. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAux</em></code> != <code>nullptr</code>.</li>
<li><code><em>pAux</em></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1fa5e908a8184cac74c099faae2fbdd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa5e908a8184cac74c099faae2fbdd3">&#9670;&nbsp;</a></span>GetAuxInputOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::GetAuxInputOutput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *&#160;</td>
          <td class="paramname"><em>pAux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>pOutInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>pOutOutput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the indexes of the <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> input/output mix buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAux</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutInput</td><td>The array from which to get the indexes of the input mix buffers set in <code><em>pAux</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutOutput</td><td>The array from which to get the indexes of the output mix buffers set in <code><em>pAux</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutCount</td><td>The number of mix buffer indexes obtained in <code><em>pOutInput</em></code> and <code><em>pOutOutput</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Length of the <code><em>outInput</em></code> and <code><em>outOutput</em></code> arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAux</em></code> != <code>nullptr</code>.</li>
<li><code><em>pAux</em></code> is initialized.</li>
<li><code><em>pOutInput</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutOutput</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutCount</em></code> != <code>nullptr</code>.</li>
<li><code><em>count</em></code> &gt; <code>0</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>Information for the number of indexes specified in <code><em>pOutCount</em></code> is written to <code><em>pOutInput</em></code> and <code><em>pOutOutput</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the input/output buffer relationship for the specified <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> effect. The indices of the source input mix buffers are stored in <code><em>pOutInput</em></code>, and the indices of the output mix buffers are stored in <code><em>pOutOutput</em></code>. <code><em>pOutInput</em></code> and <code><em>pOutOutput</em></code> can store up to <code><em>count</em></code> indices. Also, the number of mix buffer indices that are actually stored in <code><em>pOutInput</em></code> and <code><em>pOutOutput</em></code> is stored in <code><em>pOutCount</em></code>.</p>
<p>This function gets the input/output buffer relationship specified using the <code><a class="el" href="namespacenn_1_1audio.html#a9d5f32d682169896adb6d6e6b08f5155" title="Sets the input/output buffer indexes for AuxType.">nn::audio::SetAuxInputOutput()</a></code> function. If this function is called on an instance of <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> for which the <code><a class="el" href="namespacenn_1_1audio.html#a9d5f32d682169896adb6d6e6b08f5155" title="Sets the input/output buffer indexes for AuxType.">nn::audio::SetAuxInputOutput()</a></code> function has not yet been called, nothing will be stored in <code>pOutInput</code> and <code><em>pOutOutput</em></code>, and a value of <code>0</code> will be stored in <code><em>pOutCount</em></code>. Also see the description of the <code><a class="el" href="namespacenn_1_1audio.html#a086c8ae883a8dabacad2c3ff3e995f13" title="Adds an AuxType object to FinalMixType.">nn::audio::AddAux()</a></code> function. If the number of channels set to <code><em>pAux</em></code> is greater than the value specified for <code><em>count</em></code>, <code><em>pOutInput</em></code> and <code><em>pOutOutput</em></code> will only store up to <code><em>count</em></code> of the mix buffer indices.</p>
<p>For more information about the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> and <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> mix buffers, see Mix Buffers in the <a href="../../Package/contents/Pages/Page_89991492.html">Audio Renderer</a> documentation.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pAux</em></code> while calling this function. </p>

</div>
</div>
<a id="a9d5f32d682169896adb6d6e6b08f5155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5f32d682169896adb6d6e6b08f5155">&#9670;&nbsp;</a></span>SetAuxInputOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::SetAuxInputOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *&#160;</td>
          <td class="paramname"><em>pAux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the input/output buffer indexes for <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pAux</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The array of indexes of input mix buffers to set in <code><em>pAux</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>The array of indexes of output mix buffers set in <code><em>pAux</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of mix buffer indexes stored in <code><em>input</em></code> and <code><em>output</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAux</em></code> != <code>nullptr</code>.</li>
<li><code><em>pAux</em></code> is initialized.</li>
<li><code><em>input</em></code> != <code>nullptr</code>.</li>
<li><code><em>output</em></code> != <code>nullptr</code>.</li>
<li><code>0</code> &lt; <code><em>count</em></code>.</li>
<li><code><em>count</em></code> &lt;= (The number of mix buffers held by the attached <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> / <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> when <code><em>pAux</em></code> was initialized).</li>
<li><code><em>count</em></code> &lt;= (The number of channels allowed if the size of the buffer was passed as <code><em>pSendBuffer</em></code> / <code><em>pReturnBuffer</em></code> when <code><em>pAux</em></code> was initialized).</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sets the input/output buffer relationship for the specified <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> effect. The mix buffers corresponding to the indices specified for the <code><em>input</em></code> array are set as the input mix buffers, and the mix buffers corresponding to the indices specified for the <code><em>output</em></code> array are set as the output mix buffers. The same mix buffer indices can be specified for both <code><em>input</em></code> and <code><em>output</em></code>.</p>
<p>There are common rules for setting the input/output buffer relationship for each type of effect. For more information, see <code><a class="el" href="namespacenn_1_1audio.html#a70ca2b0217074d7daf6534da7db1de0b" title="Sets the input/output relationship of the mixing process performed by BufferMixer.">nn::audio::SetBufferMixerInputOutput()</a></code>.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pAux</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a106">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a74">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a74">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="adaf2f0b6dfbaa1b020d61cd56b963965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf2f0b6dfbaa1b020d61cd56b963965">&#9670;&nbsp;</a></span>ReadAuxSendBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::ReadAuxSendBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *&#160;</td>
          <td class="paramname"><em>pAux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>pOutData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads <code><em>count</em></code> number of samples from <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAux</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutData</td><td>Buffer used to load the specified number of sample arrays. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of samples to load. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of samples actually loaded. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAux</em></code> != <code>nullptr</code>.</li>
<li><code><em>pAux</em></code> is initialized.</li>
<li><code><em>pOutData</em></code> != <code>nullptr</code>.</li>
<li><code><em>count</em></code> &gt;= <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Loads the sample data from the <code>SendBuffer</code> managed by <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> to <code><em>pOutData</em></code>. Specify a value of (<em>number of channels</em>)  (<em>number of frame samples</em>) units for <code><em>count</em></code>. For example, if one audio frame stores 240 samples, and you are loading sample data for three channels, set <code><em>count</em></code> = (<code>240</code>  <code>3</code>)  (<em>number of required audio frames</em>). Use the <code><a class="el" href="namespacenn_1_1audio.html#a93cec9d3d8321e68c73e10636d34a1e2" title="Gets the maximum number of samples that can be held by the SendBuffer and ReturnBuffer objects manage...">nn::audio::GetAuxSampleCount()</a></code> function to get the number of sample frames.</p>
<p>The sample data is stored in <code><em>pOutData</em></code> in 32-bit Q15 format. Data loaded in <code><em>pOutData</em></code> is read with block interleaving. Take the preceding example where three channels of data are loaded to <code><em>pOutData</em></code>. This <code><em>pOutData</em></code> loads the sample data in the order of 240 samples of data for channel 1, 240 samples of data for channel 2, and then 240 samples of data for channel 3.</p>
<p><code><a class="el" href="namespacenn_1_1audio.html#adaf2f0b6dfbaa1b020d61cd56b963965" title="Loads count number of samples from AuxType.">nn::audio::ReadAuxSendBuffer()</a></code> returns <code>0</code> when the sample data in <code>SendBuffer()</code> is depleted. If this happens, <code><a class="el" href="namespacenn_1_1audio.html#adaf2f0b6dfbaa1b020d61cd56b963965" title="Loads count number of samples from AuxType.">nn::audio::ReadAuxSendBuffer()</a></code> might be reading data faster than sample data is being passed to <code>SendBuffer</code> by the audio renderer. Adjust the balance between the frequency of data loads and the amount of delay as necessary by modifying the number of audio frames set for <code><em>mixBufferFrameCount</em></code> by <code><a class="el" href="namespacenn_1_1audio.html#a55c33abdb3faf91f7f21f7fbf13c30fa" title="Gets the work buffer size required for the renderer to use AuxType.">nn::audio::GetRequiredBufferSizeForAuxSendReturnBuffer()</a></code>, or by modifying the interval between calls to <code><a class="el" href="namespacenn_1_1audio.html#adaf2f0b6dfbaa1b020d61cd56b963965" title="Loads count number of samples from AuxType.">nn::audio::ReadAuxSendBuffer()</a></code>. For more information, see <code><a class="el" href="namespacenn_1_1audio.html#a55c33abdb3faf91f7f21f7fbf13c30fa" title="Gets the work buffer size required for the renderer to use AuxType.">nn::audio::GetRequiredBufferSizeForAuxSendReturnBuffer()</a></code>. Note that the total number of samples that did not have time to be processed and were lost can be obtained with the <code><a class="el" href="namespacenn_1_1audio.html#adbadc0832469ad712cf5239701963b79" title="Gets statistical information associated with the SendBuffer and ReturnBuffer managed by AuxType.">nn::audio::GetAuxBufferStatistics()</a></code> function. For more information, see the function descriptions.</p>
<p>This function can be called at the same time as <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> or <code><a class="el" href="namespacenn_1_1audio.html#ac88d3b7c00c314f03079ef582e3e7a81" title="Executes rendering processing with the audio renderer.">nn::audio::ExecuteAudioRendererRendering()</a></code> without problem. However, this function is not thread-safe. Do not perform any operations on <code><em>pAux</em></code> while calling this function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a60">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a55">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a122">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a28965347a7dc482c646c14e579449359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28965347a7dc482c646c14e579449359">&#9670;&nbsp;</a></span>WriteAuxReturnBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::WriteAuxReturnBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *&#160;</td>
          <td class="paramname"><em>pAux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes <code><em>count</em></code> number of samples to <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pAux</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pData</td><td>Buffer used to load the specified number of sample arrays. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of samples to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the actual number of samples that were written. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAux</em></code> != <code>nullptr</code>.</li>
<li><code><em>pAux</em></code> is initialized.</li>
<li><code><em>pData</em></code> != <code>nullptr</code>.</li>
<li><code><em>count</em></code> &gt;= <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Write sample data to the <code>ReturnBuffer</code> managed by <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code>. Specify a value of (<em>number of channels</em>)  (<em>number of frame samples</em>) units for <code><em>count</em></code>. For example, if one audio frame stores 240 samples, and you are writing sample data for three channels, set <code><em>count</em></code> = (<code>240</code>  <code>3</code>)  (<em>number of required audio frames</em>). Use the <code><a class="el" href="namespacenn_1_1audio.html#a93cec9d3d8321e68c73e10636d34a1e2" title="Gets the maximum number of samples that can be held by the SendBuffer and ReturnBuffer objects manage...">nn::audio::GetAuxSampleCount()</a></code> function to get the number of sample frames.</p>
<p>The audio renderer expects the sample data passed from <code><em>pData</em></code> to be in 32-bit wide Q15 format. In addition, the data stored in <code><em>pData</em></code> is expected to be block-interleaved. Take the <code><em>pData</em></code> in the earlier example that writes three channels of data. This <code><em>pData</em></code> must have sample data stored in the order of 240 samples of data for channel 1, 240 samples of data for channel 2, and 240 samples of data for channel 3.</p>
<p>When the return value is less than the value passed by <code><em>count</em></code>, the sample data may be written to <code>ReturnBuffer</code> faster than the audio renderer reading sample data from <code>ReturnBuffer</code>. To balance the processing load and the amount of delay, the user must modify the buffer size of <code>ReturnBuffer</code> set in <code><a class="el" href="namespacenn_1_1audio.html#a55c33abdb3faf91f7f21f7fbf13c30fa" title="Gets the work buffer size required for the renderer to use AuxType.">nn::audio::GetRequiredBufferSizeForAuxSendReturnBuffer()</a></code>, and the frequency of <code><a class="el" href="namespacenn_1_1audio.html#a28965347a7dc482c646c14e579449359" title="Writes count number of samples to AuxType.">nn::audio::WriteAuxReturnBuffer()</a></code> calls. For more information, see <code><a class="el" href="namespacenn_1_1audio.html#a55c33abdb3faf91f7f21f7fbf13c30fa" title="Gets the work buffer size required for the renderer to use AuxType.">nn::audio::GetRequiredBufferSizeForAuxSendReturnBuffer()</a></code>. Note that the total number of samples that did not have time to be processed and for which noise may have occurred can be obtained with the <code><a class="el" href="namespacenn_1_1audio.html#adbadc0832469ad712cf5239701963b79" title="Gets statistical information associated with the SendBuffer and ReturnBuffer managed by AuxType.">nn::audio::GetAuxBufferStatistics()</a></code> function. For more information, see the function descriptions.</p>
<p>This function can be called at the same time as <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> or <code><a class="el" href="namespacenn_1_1audio.html#ac88d3b7c00c314f03079ef582e3e7a81" title="Executes rendering processing with the audio renderer.">nn::audio::ExecuteAudioRendererRendering()</a></code> without problem. However, this function is not thread-safe. Do not perform any operations on <code><em>pAux</em></code> while calling this function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a61">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a60">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a126">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a2970bf3cba541e147e48d4d66d4e90b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2970bf3cba541e147e48d4d66d4e90b3">&#9670;&nbsp;</a></span>GetAuxSampleRate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetAuxSampleRate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *&#160;</td>
          <td class="paramname"><em>pAux</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the sample rate of the <code>SendBuffer</code> and <code>ReturnBuffer</code> managed by <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAux</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the sample rate. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAux</em></code> is initialized.</li>
<li><code><em>pAux</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Returns the sampling rate set to the instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> to which <code><em>pAux</em></code> is connected.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pAux</em></code> while calling this function. </p>

</div>
</div>
<a id="a93cec9d3d8321e68c73e10636d34a1e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93cec9d3d8321e68c73e10636d34a1e2">&#9670;&nbsp;</a></span>GetAuxSampleCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetAuxSampleCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *&#160;</td>
          <td class="paramname"><em>pAux</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum number of samples that can be held by the <code>SendBuffer</code> and <code>ReturnBuffer</code> objects managed by <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAux</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of samples. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAux</em></code> is initialized.</li>
<li><code><em>pAux</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The maximum number of samples that can be stored in <code>SendBuffer</code> and <code>ReturnBuffer</code> is determined by the value set for <code><em>sendReturnBufferSize</em></code> in the <code><a class="el" href="namespacenn_1_1audio.html#a086c8ae883a8dabacad2c3ff3e995f13" title="Adds an AuxType object to FinalMixType.">nn::audio::AddAux()</a></code> function when <code><em>pAux</em></code> was initialized. For more information, see <code><a class="el" href="namespacenn_1_1audio.html#a55c33abdb3faf91f7f21f7fbf13c30fa" title="Gets the work buffer size required for the renderer to use AuxType.">nn::audio::GetRequiredBufferSizeForAuxSendReturnBuffer()</a></code>.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pAux</em></code> while calling this function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a123">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3b050f16f147043944dc199115105bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b050f16f147043944dc199115105bc9">&#9670;&nbsp;</a></span>IsAuxEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::IsAuxEnabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *&#160;</td>
          <td class="paramname"><em>pAux</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAux</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if enabled, or <code>false</code> otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAux</em></code> != <code>nullptr</code>.</li>
<li><code><em>pAux</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pAux</em></code> while calling this function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a115">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="afd2b1ab69fe2131d81a8439e8a7ca5b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd2b1ab69fe2131d81a8439e8a7ca5b9">&#9670;&nbsp;</a></span>SetAuxEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetAuxEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *&#160;</td>
          <td class="paramname"><em>pAux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether a <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pAux</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td><code>true</code> to enable, or <code>false</code> to disable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the execution result. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAux</em></code> != <code>nullptr</code>.</li>
<li><code><em>pAux</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a3b050f16f147043944dc199115105bc9">nn::audio::IsAuxEnabled(pAux)</a></code> == <code><em>enable</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 When an aux effect is enabled, the contents of the input mix buffers are written to <code>SendBuffer</code> and the contents of <code>ReturnBuffer</code> are written to the output mix buffer according to the input/output buffer relationship configured using the <code><a class="el" href="namespacenn_1_1audio.html#a9d5f32d682169896adb6d6e6b08f5155" title="Sets the input/output buffer indexes for AuxType.">nn::audio::SetAuxInputOutput()</a></code> function. When the effect is disabled, the contents of the input mix buffers are output directly to the output mix buffers as-is without going through <code>SendBuffer</code> or <code>ReturnBuffer</code>.</p>
<p>Also, when <code><em>pAux</em></code> is disabled, the following data is destroyed.</p><ul>
<li>Samples that the <code><a class="el" href="namespacenn_1_1audio.html#adaf2f0b6dfbaa1b020d61cd56b963965" title="Loads count number of samples from AuxType.">nn::audio::ReadAuxSendBuffer()</a></code> function has not finished loading</li>
<li>Samples that the <code><a class="el" href="namespacenn_1_1audio.html#a28965347a7dc482c646c14e579449359" title="Writes count number of samples to AuxType.">nn::audio::WriteAuxReturnBuffer()</a></code> has finished writing but the audio renderer has not finished processing</li>
</ul>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pAux</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a147">AudioEffect/AudioEffect.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a116">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3b94b1f2bb19fac01f8859ed4f3cc19e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b94b1f2bb19fac01f8859ed4f3cc19e">&#9670;&nbsp;</a></span>IsAuxRemovable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::IsAuxRemovable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *&#160;</td>
          <td class="paramname"><em>pAux</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> can be safely removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAux</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if possible. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pAux</em></code> != <code>nullptr</code>.</li>
<li><code><em>pAux</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 An effect can only be removed if the audio renderer has completely stopped using that effect. Before calling the <code><a class="el" href="namespacenn_1_1audio.html#a5133a62d6f97d3054e9ad428ae866102" title="Removes an AuxType object from FinalMixType.">nn::audio::RemoveAux()</a></code> function, use this function to check whether the instance of <code>Aux</code> that you want to remove is no longer being used. Note the following.</p><ul>
<li>The use of effects does not stop immediately after disabling them using the <code><a class="el" href="namespacenn_1_1audio.html#afd2b1ab69fe2131d81a8439e8a7ca5b9" title="Sets whether a AuxType is enabled.">nn::audio::SetAuxEnabled()</a></code> function.</li>
<li>After an effect is disabled using the <code>nn::audio::SetAuxEnable()</code> function, it can take up to two audio frames for calls to the <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> function to be completed.</li>
<li>Do not call the <code><a class="el" href="namespacenn_1_1audio.html#a5133a62d6f97d3054e9ad428ae866102" title="Removes an AuxType object from FinalMixType.">nn::audio::RemoveAux()</a></code> function during this time.</li>
</ul>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pAux</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="adbadc0832469ad712cf5239701963b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbadc0832469ad712cf5239701963b79">&#9670;&nbsp;</a></span>GetAuxBufferStatistics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1audio_1_1_aux_buffer_statistics.html">AuxBufferStatistics</a> nn::audio::GetAuxBufferStatistics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets statistical information associated with the <code>SendBuffer</code> and <code>ReturnBuffer</code> managed by <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns statistical information associated with the <code>SendBuffer</code> and <code>ReturnBuffer</code> managed by <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 If there is no remaining space when the audio renderer <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> tries to write sample data to the buffer managed by <code>SendBuffer</code>, the oldest sample data is overwritten and recorded sample data is lost. In addition, if there is no remaining readable space when reading sample data from the <code>ReturnBuffer</code> managed by the audio renderer <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code>, the old sample data that was already read will be read again, resulting in the output after effect processing to not be continuous and causing noise to occur. This function returns following statistical information associated with <code>SendBuffer</code> and <code>ReturnBuffer</code>.</p><ul>
<li>Total number of samples for which <code><a class="el" href="namespacenn_1_1audio.html#adaf2f0b6dfbaa1b020d61cd56b963965" title="Loads count number of samples from AuxType.">nn::audio::ReadAuxSendBuffer()</a></code> could not perform read processing and were lost.</li>
<li>Total number of samples for which <code><a class="el" href="namespacenn_1_1audio.html#a28965347a7dc482c646c14e579449359" title="Writes count number of samples to AuxType.">nn::audio::WriteAuxReturnBuffer()</a></code> could not perform write processing and may be subject to noise.</li>
</ul>
<p>Each of the structure values returned by this function is updated not when <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> is called, but rather when the audio renderer's rendering process is executed. In addition, each of the structure values returned by this function is reset to <code>0</code> by the <code><a class="el" href="namespacenn_1_1audio.html#a44ccb484757258ce2b9500822b3a763c" title="Resets statistical information associated with the SendBuffer and ReturnBuffer managed by AuxType.">nn::audio::ResetAuxBufferStatistics()</a></code> function.</p>
<p>The upper limit of each of the structure values returned by this function is the <code>std::int32_t</code> type maximum value <code>(std::numeric_limits&lt;std::int32_t&gt;::max())</code>. When this upper limit has been reached, the value does not change until it has been reset to <code>0</code> by the <code><a class="el" href="namespacenn_1_1audio.html#a44ccb484757258ce2b9500822b3a763c" title="Resets statistical information associated with the SendBuffer and ReturnBuffer managed by AuxType.">nn::audio::ResetAuxBufferStatistics()</a></code> function.</p>
<p>Because the audio renderer does not write to <code>SendBuffer</code> or read from <code>ReturnBuffer</code> when <code><a class="el" href="namespacenn_1_1audio.html#a3b050f16f147043944dc199115105bc9" title="Determines whether AuxType is enabled.">nn::audio::IsAuxEnabled()</a></code> is <code>false</code>, the total number of lost samples is not updated.</p>
<p>This function can be called at the same time as <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> or <code><a class="el" href="namespacenn_1_1audio.html#ac88d3b7c00c314f03079ef582e3e7a81" title="Executes rendering processing with the audio renderer.">nn::audio::ExecuteAudioRendererRendering()</a></code> without problem. However, this function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a58">AudioEffect/AudioEffect.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a44ccb484757258ce2b9500822b3a763c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ccb484757258ce2b9500822b3a763c">&#9670;&nbsp;</a></span>ResetAuxBufferStatistics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::ResetAuxBufferStatistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_aux_type.html">AuxType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets statistical information associated with the <code>SendBuffer</code> and <code>ReturnBuffer</code> managed by <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function can be called at the same time as <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> or <code><a class="el" href="namespacenn_1_1audio.html#ac88d3b7c00c314f03079ef582e3e7a81" title="Executes rendering processing with the audio renderer.">nn::audio::ExecuteAudioRendererRendering()</a></code> without problem. However, this function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a207">AudioEffect/AudioEffect.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="acffef82a64528c1598e0c49ee718c621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acffef82a64528c1598e0c49ee718c621">&#9670;&nbsp;</a></span>GetRequiredBufferSizeForI3dl2Reverb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::audio::GetRequiredBufferSizeForI3dl2Reverb </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelCountMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the work buffer size required for the renderer to use <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleRate</td><td>The sample rate set in the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> object that is adding <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCountMax</td><td>The maximum number of channels to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the buffer size required to use <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>(<code><em>sampleRate</em></code> == <code>32000</code>) || (<code><em>sampleRate</em></code> == <code>48000</code>).</li>
<li>(<code><em>channelCountMax</em></code> == <code>1</code>) || (<code><em>channelCountMax</em></code> == <code>2</code>) || (<code><em>channelCountMax</em></code> == <code>4</code> ) || (<code><em>channelCountMax</em></code> == <code>6</code>). </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a138">AudioEffect/AudioEffect.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a68">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a88bff95c7242f9d37ae5f631e825648b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88bff95c7242f9d37ae5f631e825648b">&#9670;&nbsp;</a></span>AddI3dl2Reverb() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::AddI3dl2Reverb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pOutReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pFinalMix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelCountMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#abcc7c4eb06afe0673e8196edc23dd9f0" title="Initializes FinalMixType and adds it to the AudioRendererConfig.">nn::audio::AcquireFinalMix()</a></code> initializes <code><em>pFinalMix</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutReverb</td><td>An uninitialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the memory region to use for <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size of memory specified by <code><em>buffer</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFinalMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> that adds the effect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCountMax</td><td>Value for the maximum number of channels that can be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html">nn::audio::ResultOutOfResource</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pOutReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutReverb</em></code> is uninitialized.</li>
<li><code><em>buffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>buffer</em></code> is aligned to <code><a class="el" href="namespacenn_1_1audio.html#a61833f2e2cf0253e3054188e900315af" title="The alignment size for audio buffers.">nn::audio::BufferAlignSize</a></code>.</li>
<li><code><em>bufferSize</em></code> =&gt; <code><a class="el" href="namespacenn_1_1audio.html#acffef82a64528c1598e0c49ee718c621">nn::audio::GetRequiredBufferSizeForI3dl2Reverb(sampleRate, channelCountMax)</a></code>. (<code><em>sampleRate</em></code> is the sample rate set in <code><em>pFinalMix</em></code>. You can get it using <code><a class="el" href="namespacenn_1_1audio.html#a25ee6f076a7eb80a0fc937c42d41e652" title="Gets the sampling rate of the audio renderer processing.">nn::audio::GetAudioRendererSampleRate()</a></code>.)</li>
<li><code><em>pFinalMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pFinalMix</em></code> is initialized.</li>
<li>(<code><em>channelCountMax</em></code> == <code>1</code>) || (<code><em>channelCountMax</em></code> == <code>2</code>) || (<code><em>channelCountMax</em></code> == <code>4</code> ) || (<code><em>channelCountMax</em></code> == <code>6</code>). </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pOutReverb</em></code> is initialized.</li>
<li><code><em>pOutReverb</em></code> is enabled.</li>
<li>The <code><em>pOutReverb</em></code> input/output buffers are not configured.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Add <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> that is a reverb based on Interactive 3D Audio Level 2 specifications to <code><em>pFinalMix</em></code> and initialize <code><em>pOutReverb</em></code>. Calling this function links <code><em>pOutReverb</em></code> to <code><em>pFinalMix</em></code> and makes it possible for <code><em>pOutReverb</em></code> to control the effects for the mix buffer managed by <code><em>pFinalMix</em></code>. Use <code><em>pOutReverb</em></code> to perform all future operations on <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code>. For a list of functions that can be used with <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code>, see the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> reference.</p>
<p><code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> requires a work buffer to process the effect. Allocate a buffer that is at least equal to the size of the value returned by <code><a class="el" href="namespacenn_1_1audio.html#acffef82a64528c1598e0c49ee718c621" title="Gets the work buffer size required for the renderer to use I3dl2ReverbType.">nn::audio::GetRequiredBufferSizeForI3dl2Reverb()</a></code>, and specify that buffer and its size for <code><em>buffer</em></code> and <code><em>bufferSize</em></code>. The memory region specified for <code><em>buffer</em></code> must be contained within the memory region specified for <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html" title="Structure for representing memory regions used by an audio renderer.">nn::audio::MemoryPoolType</a></code>, and its <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html" title="Structure for representing memory regions used by an audio renderer.">nn::audio::MemoryPoolType</a></code> must be attached.</p>
<p>Only one instance of each type of effect can be added to a single <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. A single instance of an effect cannot be added to multiple instances of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. The following warning message is displayed if an initialized effect that has already been added to an instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> is added to the same instance or another instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> again. </p><div class="fragment"><div class="line">[<a class="code" href="namespacenn_1_1audio.html">nn::audio</a>] Warning: The passed effect is already initialized. Please confirm <span class="keywordflow">if</span> (address <span class="keywordflow">for</span> effect instance) is a valid effect <span class="keywordtype">object</span>.</div>
</div><!-- fragment --><p> ("address for effect instance" is the address of the instance of the effect that you attempted to add.) For <code><em>channelCountMax</em></code>, specify the number of channels supported by <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code>. The maximum number of channels that can be specified is the value specified for <code><em>count</em></code> in the <code><a class="el" href="namespacenn_1_1audio.html#a8a31783d96a7f992dc95ebd30a9ad3db" title="Sets the I3dl2ReverbType input/output mix buffer indexes.">nn::audio::SetI3dl2ReverbInputOutput()</a></code> function. For more information, see <code><a class="el" href="namespacenn_1_1audio.html#a8a31783d96a7f992dc95ebd30a9ad3db" title="Sets the I3dl2ReverbType input/output mix buffer indexes.">nn::audio::SetI3dl2ReverbInputOutput()</a></code>.</p>
<p>Immediately after a delay is added, <code><em>pOutReverb</em></code> is not connected to the input/output mix buffers, and <code><em>pOutReverb</em></code> transitions to an enabled state. Use the <code><a class="el" href="namespacenn_1_1audio.html#a8a31783d96a7f992dc95ebd30a9ad3db" title="Sets the I3dl2ReverbType input/output mix buffer indexes.">nn::audio::SetI3dl2ReverbInputOutput()</a></code> function to specify the indices of the input/output mix buffers to which to apply the effect.</p>
<p>If the process for adding the effect fails and the function returns <code><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html" title="A class that represents error Result values (audio: Insufficient resources.).">nn::audio::ResultOutOfResource</a></code>, this usually indicates that the number of effects currently being used exceeds the maximum number of effects specified for <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html" title="The audio renderer parameters.">nn::audio::AudioRendererParameter</a>.<em>effectCount</em></code>. Delete one of the other effects or increase the number specified for <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html" title="The audio renderer parameters.">nn::audio::AudioRendererParameter</a>.<em>effectCount</em></code>.</p>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad771f7516d8c6eea51938171d9389af7" title="Adds a BiquadFilterType object to FinalMixType.">nn::audio::AddBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a2163e3d699edc8244383a94ed760f0be" title="Removes a BiquadFilterType object from FinalMixType.">nn::audio::RemoveBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a7bd3cc176b82c7cd5659c364ab97ab08" title="Adds BufferMixer to FinalMixType.">nn::audio::AddBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a400aff980a26fd295d911adbffd5f8ae" title="Removes BufferMixer from FinalMixType.">nn::audio::RemoveBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad332d3b8805f5157ef98572a99a9f2a0" title="Adds a DelayType object to FinalMixType.">nn::audio::AddDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a47262039889d9d23aeac0d82ed318ac0" title="Removes a DelayType object from FinalMixType.">nn::audio::RemoveDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aa081b9cab7e4ca8d079093c1fc50bb4d" title="Adds a ReverbType object to FinalMixType.">nn::audio::AddReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a8dda67780e46472ca22360376e6eb831" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a88bff95c7242f9d37ae5f631e825648b" title="Adds a I3dl2ReverbType object to FinalMixType.">nn::audio::AddI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a32e1724b072fff4284c19e597ac94d84" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a086c8ae883a8dabacad2c3ff3e995f13" title="Adds an AuxType object to FinalMixType.">nn::audio::AddAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a5133a62d6f97d3054e9ad428ae866102" title="Removes an AuxType object from FinalMixType.">nn::audio::RemoveAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a0bab4b3f6c0c1c7aa0011d2ee4b33919" title="Adds a LightLimiterType object to FinalMixType.">nn::audio::AddLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aacc63377e4f4f87617ff50fc981b170d" title="Removes a LightLimiterType object from FinalMixType.">nn::audio::RemoveLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ab3024a56e39831c3ba5fc8e52bca1a7e" title="Adds a CaptureType object to FinalMixType.">nn::audio::AddCapture()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a3fd8807d5efcb1fae477f690c8a8b48d" title="Removes the CaptureType object from FinalMixType.">nn::audio::RemoveCapture()</a></code></li>
</ul>
<p>Also, do not perform any operations on <code><em>pFinalMix</em></code> while calling any of these functions. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a139">AudioEffect/AudioEffect.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a69">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a0c50625e1c29fd3cd2c7b6f2365f8d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c50625e1c29fd3cd2c7b6f2365f8d50">&#9670;&nbsp;</a></span>AddI3dl2Reverb() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::AddI3dl2Reverb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pOutReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pSubMix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelCountMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#a24020da05700a26ee46f04f5762c157f" title="Initializes a SubMixType object and adds it to AudioRendererConfig.">nn::audio::AcquireSubMix()</a></code> initializes <code><em>pSubMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pOutReverb</td><td>An uninitialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the memory region to use for <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size of memory specified by <code><em>buffer</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSubMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> to which the effect is being added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCountMax</td><td>The maximum number of channels that can be set for <code><em>pOutReverb</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html">nn::audio::ResultOutOfResource</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pOutReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutReverb</em></code> is uninitialized.</li>
<li><code><em>buffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>buffer</em></code> is aligned to <code><a class="el" href="namespacenn_1_1audio.html#a61833f2e2cf0253e3054188e900315af" title="The alignment size for audio buffers.">nn::audio::BufferAlignSize</a></code>.</li>
<li><code><em>bufferSize</em></code> =&gt; <code><a class="el" href="namespacenn_1_1audio.html#acffef82a64528c1598e0c49ee718c621">nn::audio::GetRequiredBufferSizeForI3dl2Reverb(sampleRate, channelCountMax)</a></code>.</li>
<li><code><em>pSubMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSubMix</em></code> is initialized.</li>
<li>(<code><em>channelCountMax</em></code> == <code>1</code>) || (<code><em>channelCountMax</em></code> == <code>2</code>) || (<code><em>channelCountMax</em></code> == <code>4</code> ) || (<code><em>channelCountMax</em></code> == <code>6</code>). </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pOutReverb</em></code> is initialized.</li>
<li><code><em>pOutReverb</em></code> is enabled.</li>
<li>The <code><em>pOutReverb</em></code> input/output buffers are not configured.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Except when called on an instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, this function works the same as <code><a class="el" href="namespacenn_1_1audio.html#a88bff95c7242f9d37ae5f631e825648b" title="Adds a I3dl2ReverbType object to FinalMixType.">nn::audio::AddI3dl2Reverb</a>(AudioRendererConfig* <em>pOutConfig</em>, I3dl2ReverbType* <em>pOutReverb</em>, void* <em>buffer</em>, size_t <em>bufferSize</em>, FinalMixType* <em>pFinalMix</em>, int <em>channelCountMax</em>)</code>. </p>

</div>
</div>
<a id="a32e1724b072fff4284c19e597ac94d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32e1724b072fff4284c19e597ac94d84">&#9670;&nbsp;</a></span>RemoveI3dl2Reverb() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * nn::audio::RemoveI3dl2Reverb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pFinalMix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a <code><em><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></em></code> object from <code>FinalMix</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#abcc7c4eb06afe0673e8196edc23dd9f0" title="Initializes FinalMixType and adds it to the AudioRendererConfig.">nn::audio::AcquireFinalMix()</a></code> initializes <code><em>pFinalMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object added to <code><em>pFinalMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFinalMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> that removes <code><em>pReverb</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the memory used for <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code>. (The memory passed to <code><em>buffer</em></code> when initialized by <code><a class="el" href="namespacenn_1_1audio.html#a88bff95c7242f9d37ae5f631e825648b" title="Adds a I3dl2ReverbType object to FinalMixType.">nn::audio::AddI3dl2Reverb()</a></code>.) </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a252041cc7854a8ca48f6e9877b545ed1">nn::audio::IsI3dl2ReverbRemovable(pReverb)</a></code> == <code>true</code>.</li>
<li><code><em>pFinalMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pFinalMix</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pReverb</em></code> is uninitialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 An effect can only be removed if the audio renderer has completely stopped using that effect. This function calls the <code><a class="el" href="namespacenn_1_1audio.html#aca3b4f1b5b17ad7caa0ca2e8a9ea9f90" title="Sets whether the I3dl2ReverbType is enabled or disabled.">nn::audio::SetI3dl2ReverbEnabled()</a></code> function to disable <code>Aux</code> before removing that instance of <code>Aux</code> and then calls the <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> function to notify the audio renderer that <code>Aux</code> has been disabled. After calling the <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> function, use the <code><a class="el" href="namespacenn_1_1audio.html#a252041cc7854a8ca48f6e9877b545ed1" title="Determines whether the I3dl2ReverbType object can be safely removed.">nn::audio::IsI3dl2ReverbRemovable()</a></code> function to determine whether the audio renderer has completely stopped using the effect and the effect can be safely removed. After calling the <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> function, it may take up to two audio frames for the audio renderer to completely stop using the effect.</p>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad771f7516d8c6eea51938171d9389af7" title="Adds a BiquadFilterType object to FinalMixType.">nn::audio::AddBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a2163e3d699edc8244383a94ed760f0be" title="Removes a BiquadFilterType object from FinalMixType.">nn::audio::RemoveBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a7bd3cc176b82c7cd5659c364ab97ab08" title="Adds BufferMixer to FinalMixType.">nn::audio::AddBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a400aff980a26fd295d911adbffd5f8ae" title="Removes BufferMixer from FinalMixType.">nn::audio::RemoveBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad332d3b8805f5157ef98572a99a9f2a0" title="Adds a DelayType object to FinalMixType.">nn::audio::AddDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a47262039889d9d23aeac0d82ed318ac0" title="Removes a DelayType object from FinalMixType.">nn::audio::RemoveDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aa081b9cab7e4ca8d079093c1fc50bb4d" title="Adds a ReverbType object to FinalMixType.">nn::audio::AddReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a8dda67780e46472ca22360376e6eb831" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a88bff95c7242f9d37ae5f631e825648b" title="Adds a I3dl2ReverbType object to FinalMixType.">nn::audio::AddI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a32e1724b072fff4284c19e597ac94d84" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a086c8ae883a8dabacad2c3ff3e995f13" title="Adds an AuxType object to FinalMixType.">nn::audio::AddAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a5133a62d6f97d3054e9ad428ae866102" title="Removes an AuxType object from FinalMixType.">nn::audio::RemoveAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a0bab4b3f6c0c1c7aa0011d2ee4b33919" title="Adds a LightLimiterType object to FinalMixType.">nn::audio::AddLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aacc63377e4f4f87617ff50fc981b170d" title="Removes a LightLimiterType object from FinalMixType.">nn::audio::RemoveLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ab3024a56e39831c3ba5fc8e52bca1a7e" title="Adds a CaptureType object to FinalMixType.">nn::audio::AddCapture()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a3fd8807d5efcb1fae477f690c8a8b48d" title="Removes the CaptureType object from FinalMixType.">nn::audio::RemoveCapture()</a></code></li>
</ul>
<p>Also, do not perform any operations on <code><em>pFinalMix</em></code> while calling any of these functions. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="a473dc9ed4c9710f507a21809c5baf5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473dc9ed4c9710f507a21809c5baf5e4">&#9670;&nbsp;</a></span>RemoveI3dl2Reverb() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * nn::audio::RemoveI3dl2Reverb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pSubMix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a <code><em><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></em></code> object from <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#a24020da05700a26ee46f04f5762c157f" title="Initializes a SubMixType object and adds it to AudioRendererConfig.">nn::audio::AcquireSubMix()</a></code> initializes <code><em>pSubMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object added to <code><em>pSubMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSubMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> that removes <code><em>pReverb</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the memory used for <code>I2DL2ReverbType</code>. (The memory passed to <code><em>buffer</em></code> when initialized by <code><a class="el" href="namespacenn_1_1audio.html#a88bff95c7242f9d37ae5f631e825648b" title="Adds a I3dl2ReverbType object to FinalMixType.">nn::audio::AddI3dl2Reverb()</a></code>.) </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#afb3b452f9bc03b127c6d1ea4b7e340eb">nn::audio::IsReverbRemovable(pReverb)</a></code> == <code>true</code>.</li>
<li><code><em>pSubMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSubMix</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pReverb</em></code> is uninitialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Except when called on an instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, this function works the same as <code><a class="el" href="namespacenn_1_1audio.html#a32e1724b072fff4284c19e597ac94d84" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveI3dl2Reverb</a>(AudioRendererConfig* <em>pOutConfig</em>, I3dl2ReverbType* <em>pReverb</em>, FinalMixType* <em>pFinalMix</em>)</code>. </p>

</div>
</div>
<a id="a252041cc7854a8ca48f6e9877b545ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252041cc7854a8ca48f6e9877b545ed1">&#9670;&nbsp;</a></span>IsI3dl2ReverbRemovable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::IsI3dl2ReverbRemovable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object can be safely removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_reverb_type.html" title="Reverb effect.">ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if possible. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 An effect can only be removed if the audio renderer has completely stopped using that effect. Before calling the <code><a class="el" href="namespacenn_1_1audio.html#a32e1724b072fff4284c19e597ac94d84" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveI3dl2Reverb()</a></code> function, use this function to check whether the instance of <code><em>pReverb</em></code> that you want to remove is no longer being used. Note the following.</p><ul>
<li>The use of effects does not stop immediately after disabling them using the <code><a class="el" href="namespacenn_1_1audio.html#aca3b4f1b5b17ad7caa0ca2e8a9ea9f90" title="Sets whether the I3dl2ReverbType is enabled or disabled.">nn::audio::SetI3dl2ReverbEnabled()</a></code> function.</li>
<li>After an effect is disabled using the <code>nn::audio::SetI3dl2ReverbEnable()</code> function, it can take up to two audio frames for calls to the <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> function to be completed.</li>
<li>Do not call the <code><a class="el" href="namespacenn_1_1audio.html#a32e1724b072fff4284c19e597ac94d84" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveI3dl2Reverb()</a></code> function during this time.</li>
</ul>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="adf04a6b384cf7f7fe6137d628c62871e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf04a6b384cf7f7fe6137d628c62871e">&#9670;&nbsp;</a></span>GetI3dl2ReverbChannelCountMax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetI3dl2ReverbChannelCountMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum number of channels that can be set for <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the maximum value for the number of channels that can be set. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4a90f3cc29f82384d648da644233ed23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a90f3cc29f82384d648da644233ed23">&#9670;&nbsp;</a></span>GetI3dl2ReverbInputOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::GetI3dl2ReverbInputOutput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>outInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>outOutput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> input/output mix buffer indexes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outInput</td><td>The array from which to get the indexes of the input mix buffers set in <code><em>pReverb</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outOutput</td><td>The array from which to get the indexes of the output mix buffers set in <code><em>pReverb</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutCount</td><td>The number of mix buffer indexes obtained in <code><em>outInput</em></code> and <code><em>outOutput</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Length of the <code><em>outInput</em></code> and <code><em>outOutput</em></code> arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
<li><code><em>outInput</em></code> != <code>nullptr</code>.</li>
<li><code><em>outOutput</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutCount</em></code> != <code>nullptr</code>.</li>
<li><code><em>count</em></code> &gt; <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the input/output buffer relationship for the specified <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> effect. The indices of the source input mix buffers are stored in <code><em>outInput</em></code>, and the indices of the output mix buffers are stored in <code><em>outOutput</em></code>. <code><em>outInput</em></code> and <code><em>outOutput</em></code> can store up to <code><em>count</em></code> indices. The actual number of mix buffer indexes that are stored in <code><em>outInput</em></code> and <code><em>outOutput</em></code> is returned to <code><em>pOutCount</em></code>.</p>
<p>This function gets the input/output buffer relationship specified using the <code><a class="el" href="namespacenn_1_1audio.html#a8a31783d96a7f992dc95ebd30a9ad3db" title="Sets the I3dl2ReverbType input/output mix buffer indexes.">nn::audio::SetI3dl2ReverbInputOutput()</a></code> function. If this function is called on an instance of <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> for which the <code><a class="el" href="namespacenn_1_1audio.html#a8a31783d96a7f992dc95ebd30a9ad3db" title="Sets the I3dl2ReverbType input/output mix buffer indexes.">nn::audio::SetI3dl2ReverbInputOutput()</a></code> function has not yet been called, nothing will be stored in <code><em>outInput</em></code> and <code><em>outOutput</em></code>, and a value of <code>0</code> will be stored in <code><em>pOutCount</em></code>. For more information, see <code><a class="el" href="namespacenn_1_1audio.html#a88bff95c7242f9d37ae5f631e825648b" title="Adds a I3dl2ReverbType object to FinalMixType.">nn::audio::AddI3dl2Reverb()</a></code>. If the number of channels set to <code><em>pReverb</em></code> is greater than the value specified for <code><em>count</em></code>, <code><em>outInput</em></code> and <code><em>outOutput</em></code> will only store up to <code><em>count</em></code> of the mix buffer indices.</p>
<p>For more information about the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> and <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> mix buffers, see Mix Buffers in the <a href="../../Package/contents/Pages/Page_89991492.html">Audio Renderer</a> documentation.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="a8a31783d96a7f992dc95ebd30a9ad3db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a31783d96a7f992dc95ebd30a9ad3db">&#9670;&nbsp;</a></span>SetI3dl2ReverbInputOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetI3dl2ReverbInputOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> input/output mix buffer indexes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The array of indexes of input mix buffers to set in <code><em>pReverb</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>The array of indexes of output mix buffers set in <code><em>pReverb</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of mix buffer indexes stored in <code><em>input</em></code> and <code><em>output</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
<li><code><em>input</em></code> != <code>nullptr</code>.</li>
<li><code><em>output</em></code> != <code>nullptr</code>.</li>
<li>(<code><em>count</em></code> == <code>1</code>) || (<code><em>count</em></code> == <code>2</code>) || (<code><em>count</em></code> == <code>4</code>) || (<code><em>count</em></code> == <code>6</code>).</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sets the input/output buffer relationship for the specified <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> effect. The mix buffers corresponding to the indices specified for the <code><em>input</em></code> array are set as the input mix buffers, and the mix buffers corresponding to the indices specified for the <code><em>output</em></code> array are set as the output mix buffers. The same mix buffer indices can be specified for both <code><em>input</em></code> and <code><em>output</em></code>.</p>
<p>There are common rules for setting the input/output buffer relationship for each type of effect. For more information, see <code><a class="el" href="namespacenn_1_1audio.html#a70ca2b0217074d7daf6534da7db1de0b" title="Sets the input/output relationship of the mixing process performed by BufferMixer.">nn::audio::SetBufferMixerInputOutput()</a></code>.</p>
<p>The <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> <code><em>input</em></code> is processed on the assumption that input channels are in the following order. Be careful not to get the order wrong when you set <code><em>input</em></code>.</p><ul>
<li>For 2 ch: <code>FrontLeft</code>, <code>FrontRight</code>.</li>
<li>For 4 ch: <code>FrontLeft</code>, <code>FrontRight</code>, <code>RearLeft</code>, <code>RearRight</code>.</li>
<li>For 6 ch: <code>FrontLeft</code>, <code>FrontRight</code>, <code>FrontCenter</code>, <code>LowFrequency</code>, <code>RearLeft</code>, <code>RearRight</code>.</li>
</ul>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a102">AudioEffect/AudioEffect.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a70">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a6d3b9fcb3a508698685e01de1dddcba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3b9fcb3a508698685e01de1dddcba1">&#9670;&nbsp;</a></span>SetI3dl2ReverbRoomGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetI3dl2ReverbRoomGain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>room</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the room gain of the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">room</td><td>The room gain value to set (in millibels, more commonly called <em>hundredths of a decibel</em> ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
<li><code>-10000.0f</code> &lt;= <code><em>room</em></code> &amp;&amp; <code><em>room</em></code> &lt;= <code>0.0f</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="a9e9d95aae46a165e9452c0a519d9926d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e9d95aae46a165e9452c0a519d9926d">&#9670;&nbsp;</a></span>GetI3dl2ReverbRoomGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetI3dl2ReverbRoomGain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the room gain of the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the room gain. The unit is mB (millibel, or one hundredth of a decibel). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="aae9838aad6e5138efe0e492b6586a742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae9838aad6e5138efe0e492b6586a742">&#9670;&nbsp;</a></span>SetI3dl2ReverbRoomHfGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetI3dl2ReverbRoomHfGain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>roomHf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the attenuation for high-frequency components, using low-frequency components as the basis, for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">roomHf</td><td>Attenuation for high-frequency components, using low-frequency components as the basis (in mB, or hundredths of a decibel). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
<li><code>-10000.0f</code> &lt;= <code><em>roomHf</em></code> &amp;&amp; <code><em>roomHf</em></code> &lt;= <code>0.0f</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="a305d3c374ac911c69b0642f5360bb052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a305d3c374ac911c69b0642f5360bb052">&#9670;&nbsp;</a></span>GetI3dl2ReverbRoomHfGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetI3dl2ReverbRoomHfGain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the attenuation for high-frequency components, using low-frequency components as the basis, for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the attenuation for high-frequency components that use low-frequency components as the basis. The unit is mB (millibel, or one hundredth of a decibel). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="a6a11597710a0f2bbb30eb60e28808cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a11597710a0f2bbb30eb60e28808cfa">&#9670;&nbsp;</a></span>SetI3dl2ReverbLateReverbDecayTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetI3dl2ReverbLateReverbDecayTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the reverberation time for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
<li><code><a class="el" href="classnn_1_1_time_span.html#a2441d3c84cc24b901342ce11f87cd39c">nn::TimeSpan::FromMilliSeconds(100)</a></code> &lt;= <code><em>time</em></code> &amp;&amp; <code><em>time</em></code> &lt;= <code><a class="el" href="classnn_1_1_time_span.html#a2441d3c84cc24b901342ce11f87cd39c">nn::TimeSpan::FromSeconds(20)</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="a98093560487330f1a25ab13b826427f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98093560487330f1a25ab13b826427f5">&#9670;&nbsp;</a></span>GetI3dl2ReverbLateReverbDecayTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> nn::audio::GetI3dl2ReverbLateReverbDecayTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the reverberation time of the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the reverberation time. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="aad30ac49698bba62743bc16134c9fa9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad30ac49698bba62743bc16134c9fa9f">&#9670;&nbsp;</a></span>SetI3dl2ReverbLateReverbHfDecayRatio()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetI3dl2ReverbLateReverbHfDecayRatio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>hfDecayRatio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the ratio of reverb time for high-frequency components as compared to reverb time for low-frequency components for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hfDecayRatio</td><td>The ratio of reverb time for high-frequency components as compared to reverb time for low-frequency components. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
<li><code>0.1f</code> &lt;= <code><em>hfDecayRatio</em></code> &amp;&amp; <code><em>hfDecayRatio</em></code> &lt;= <code>2.0f</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="ab7bff456f63109630c5051f31896f01c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7bff456f63109630c5051f31896f01c">&#9670;&nbsp;</a></span>GetI3dl2ReverbLateReverbHfDecayRatio()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetI3dl2ReverbLateReverbHfDecayRatio </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the ratio of reverb time for high-frequency components as compared to reverb time for low-frequency components for <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the ratio of reverb time for high-frequency components as compared to reverb time for low-frequency components. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="afa6dc3f9e7027504cf7e617495831288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6dc3f9e7027504cf7e617495831288">&#9670;&nbsp;</a></span>SetI3dl2ReverbReflectionsGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetI3dl2ReverbReflectionsGain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>reflections</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the early reflected sound level based on the room gain for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reflections</td><td>Early reflected sound level (in hundredths of decibels). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
<li><code>-10000.0f</code> &lt;= <code><em>reflections</em></code> &amp;&amp; <code><em>reflections</em></code> &lt;= <code>1000.0f</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="ab45ebec61b8d07839bf8dc6fa8e36f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab45ebec61b8d07839bf8dc6fa8e36f30">&#9670;&nbsp;</a></span>GetI3dl2ReverbReflectionsGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetI3dl2ReverbReflectionsGain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the early reflected sound level based on the room gain for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the early reflected sound level (in hundredths of decibels). The unit is mB (millibel, or one hundredth of a decibel). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="a78b8448789678f7c4eb96e299b245889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b8448789678f7c4eb96e299b245889">&#9670;&nbsp;</a></span>SetI3dl2ReverbReflectionDelayTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetI3dl2ReverbReflectionDelayTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the latency of the early reflected sound based on the direct sound for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>Latency of the early reflected sound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
<li><code><a class="el" href="classnn_1_1_time_span.html#a2441d3c84cc24b901342ce11f87cd39c">nn::TimeSpan::FromMilliSeconds(0)</a></code> &lt;= <code><em>time</em></code> &amp;&amp; <code><em>time</em></code> &lt;= <code><a class="el" href="classnn_1_1_time_span.html#a2441d3c84cc24b901342ce11f87cd39c">nn::TimeSpan::FromMilliSeconds(300)</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="a41959e9a0094f683cfcff34b3157b500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41959e9a0094f683cfcff34b3157b500">&#9670;&nbsp;</a></span>GetI3dl2ReverbReflectionDelayTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> nn::audio::GetI3dl2ReverbReflectionDelayTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the latency of the early reflected sound based on the direct sound for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the latency of the early reflected sound. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="a370d8d1264111192626a30c1e398f3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370d8d1264111192626a30c1e398f3c3">&#9670;&nbsp;</a></span>SetI3dl2ReverbReverbGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetI3dl2ReverbReverbGain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>reverb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the early reflected sound level based on the room gain for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reverb</td><td>Late reverberation level (in hundredths of decibels). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
<li><code>-10000.0f</code> &lt;= <code><em>reverb</em></code> &amp;&amp; <code><em>reverb</em></code> &lt;= <code>2000.0f</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="a9f5366afdedba8ad877154cd3ffb94c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5366afdedba8ad877154cd3ffb94c2">&#9670;&nbsp;</a></span>GetI3dl2ReverbReverbGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetI3dl2ReverbReverbGain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the late reverberation level based on the room gain for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the late reverberation level (in hundredths of decibels). The unit is mB (millibel, or one hundredth of a decibel). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="a4e2109f9f8c35ae695cd4b4b9d4883c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e2109f9f8c35ae695cd4b4b9d4883c1">&#9670;&nbsp;</a></span>SetI3dl2ReverbLateReverbDelayTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetI3dl2ReverbLateReverbDelayTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the latency of the late reverberation based on the early reflected sound for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>The late reverberation delay time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
<li><code><a class="el" href="classnn_1_1_time_span.html#a2441d3c84cc24b901342ce11f87cd39c">nn::TimeSpan::FromMilliSeconds(0)</a></code> &lt;= <code><em>time</em></code> &amp;&amp; <code><em>time</em></code> &lt;= <code><a class="el" href="classnn_1_1_time_span.html#a2441d3c84cc24b901342ce11f87cd39c">nn::TimeSpan::FromMilliSeconds(100)</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="ae098ed845f298857adaea3ad8ce84450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae098ed845f298857adaea3ad8ce84450">&#9670;&nbsp;</a></span>GetI3dl2ReverbLateReverbDelayTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> nn::audio::GetI3dl2ReverbLateReverbDelayTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the latency of the late reverberation based on the early reflected sound for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the late reverberation delay time. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="adae214c1d78ad0282973bd915854acd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae214c1d78ad0282973bd915854acd5">&#9670;&nbsp;</a></span>SetI3dl2ReverbLateReverbDiffusion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetI3dl2ReverbLateReverbDiffusion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>diffusion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the echo density of the late reverberation for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diffusion</td><td>The echo density of the late reverberation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
<li><code>0.f</code> &lt;= <code><em>diffusion</em></code> &amp;&amp; <code><em>diffusion</em></code> &lt;= <code>100.f</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="a488235ededae0fa48e55b7296f7b7a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488235ededae0fa48e55b7296f7b7a28">&#9670;&nbsp;</a></span>GetI3dl2ReverbLateReverbDiffusion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetI3dl2ReverbLateReverbDiffusion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the echo density of the late reverberation of the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the echo density of the late reverberation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="ab33ac8b566a98f9967a603a98c39cb38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33ac8b566a98f9967a603a98c39cb38">&#9670;&nbsp;</a></span>SetI3dl2ReverbLateReverbDensity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetI3dl2ReverbLateReverbDensity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>density</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the modal density of the late reverberation for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">density</td><td>The modal density of the late reverberation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
<li><code>0.f</code> &lt;= <code><em>density</em></code> &amp;&amp; <code><em>density</em></code> &lt;= <code>100.f</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="acb9683dabafbc1785cfe8bca1874bbe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb9683dabafbc1785cfe8bca1874bbe8">&#9670;&nbsp;</a></span>GetI3dl2ReverbLateReverbDensity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetI3dl2ReverbLateReverbDensity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the modal density of the late reverberation for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the modal density of the late reverberation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="abc7c0584a83e1cd1309f59234c3ec693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7c0584a83e1cd1309f59234c3ec693">&#9670;&nbsp;</a></span>SetI3dl2ReverbHfReference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetI3dl2ReverbHfReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>hfReference</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the high-frequency reference frequency for <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hfReference</td><td>The high-frequency reference frequency (in Hertz). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
<li><code>20.f</code> &lt;= <code><em>hfReference</em></code> &amp;&amp; <code><em>hfReference</em></code> &lt;= <code>20000.f</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="aea2a8a9c28a5fc5500dbbf553e0c183b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea2a8a9c28a5fc5500dbbf553e0c183b">&#9670;&nbsp;</a></span>GetI3dl2ReverbHfReference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetI3dl2ReverbHfReference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the high-frequency reference frequency for <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the high-frequency reference frequency. The unit of measurement is Hertz. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="a21b700e630d0b1ab68099dd4477cb70c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b700e630d0b1ab68099dd4477cb70c">&#9670;&nbsp;</a></span>SetI3dl2ReverbDryGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetI3dl2ReverbDryGain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dryGain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> dry gain for the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dryGain</td><td>Dry gain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
<li><code>0.f</code> &lt;= <code><em>dryGain</em></code> &amp;&amp; <code><em>dryGain</em></code> &lt;= <code>1.f</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="aa0c9e3063f2ff99589dea564c67f96bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c9e3063f2ff99589dea564c67f96bd">&#9670;&nbsp;</a></span>GetI3dl2ReverbDryGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetI3dl2ReverbDryGain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the dry gain of the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the dry gain. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="a9fba605639e5efcebf031e9fb1f1829a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fba605639e5efcebf031e9fb1f1829a">&#9670;&nbsp;</a></span>SetI3dl2ReverbParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetI3dl2ReverbParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pOutReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_parameter_set.html">I3dl2ReverbParameterSet</a> *&#160;</td>
          <td class="paramname"><em>pParameterSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">nn::audio::I3dl2ReverbType</a></code> effect parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutReverb</td><td>Pointer to an initialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">nn::audio::I3dl2ReverbType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pParameterSet</td><td>Effect parameters to set in <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_parameter_set.html" title="The I3dl2Reverb effect parameters.">nn::audio::I3dl2ReverbParameterSet</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutReverb</em></code> is initialized.</li>
<li><code><em>pParameterSet</em></code> != <code>nullptr</code>.</li>
<li><code>-10000.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;roomGain</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;roomGain</code> &lt;= <code>0.0f</code>.</li>
<li><code>-10000.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;roomHfGain</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;roomHfGain</code> &lt;= <code>0.0f</code>.</li>
<li><code>0.1f</code> &lt;= <code><em>pParameterSet</em>-&gt;lateReverbDecayTime</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;lateReverbDecayTime</code> &lt;= <code>20.0f</code>.</li>
<li><code>0.1f</code> &lt;= <code><em>pParameterSet</em>-&gt;lateReverbHfDecayRatio</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;lateReverbHfDecayRatio</code> &lt;= <code>2.0f</code>.</li>
<li><code>-10000.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;reflectionsGain</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;reflectionsGain</code> &lt;= <code>1000.0f</code>.</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;reflectionsDelayTime</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;reflectionsDelayTime</code> &lt;= <code>0.3f</code>.</li>
<li><code>-10000.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;reverbGain</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;reverbGain</code> &lt;= <code>2000.0f</code>.</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;reverbDelayTime</code> <code>&amp;&amp; <em>pParameterSet</em>-&gt;reverbDelayTime</code> &lt;= <code>0.1f</code>.</li>
<li><code>0.1f</code> &lt;= <code><em>pParameterSet</em>-&gt;reverbDiffusion</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;reverbDiffusion</code> &lt;= <code>100.0f</code>.</li>
<li><code>0.1f</code> &lt;= <code><em>pParameterSet</em>-&gt;reverbDensity</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;reverbDensity</code> &lt;= <code>100.0f</code>.</li>
<li><code>20.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;hfReference</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;hfReference</code> &lt;= <code>20000.0f</code>.</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;dryGain</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;dryGain</code> &lt;= <code>1.0f</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 For more information about the meanings of the parameters, see I3dl2 Reverb Parameters in the <a href="../../Package/contents/Pages/Page_93362777.html">Audio Effects</a> documentation.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pOutReverb</em></code> while calling this function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a83">AudioEffect/AudioEffect.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a43">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a091075a7213e39d2b1df8359256dab70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a091075a7213e39d2b1df8359256dab70">&#9670;&nbsp;</a></span>GetI3dl2ReverbParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_parameter_set.html">I3dl2ReverbParameterSet</a> nn::audio::GetI3dl2ReverbParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">nn::audio::I3dl2ReverbType</a></code> effect parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>Pointer to an initialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">nn::audio::I3dl2ReverbType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the effect parameters. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutReverb</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a80">AudioEffect/AudioEffect.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a40">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af9a1099a74d7eb2226b53e0759ee5ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a1099a74d7eb2226b53e0759ee5ef0">&#9670;&nbsp;</a></span>LoadI3dl2ReverbPreset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::LoadI3dl2ReverbPreset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_parameter_set.html">I3dl2ReverbParameterSet</a> *&#160;</td>
          <td class="paramname"><em>pOutParameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html#a56691f5a002784e036b1a462ef7067bc">I3dl2ReverbType::Preset</a>&#160;</td>
          <td class="paramname"><em>preset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">nn::audio::I3dl2ReverbType</a></code> effect parameters comparable to a preset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutParameter</td><td>The effect parameters to get. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preset</td><td>The type of preset as defined in <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html#a56691f5a002784e036b1a462ef7067bc" title="Enumerated type that indicates the preset parameters that can be specified by I3dl2ReverbType.">nn::audio::I3dl2ReverbType::Preset</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutParameter</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the effect parameters comparable to a preset that have been prepared in <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html#a56691f5a002784e036b1a462ef7067bc" title="Enumerated type that indicates the preset parameters that can be specified by I3dl2ReverbType.">nn::audio::I3dl2ReverbType::Preset</a></code>. By specifying the parameters obtained with this function in <code><a class="el" href="namespacenn_1_1audio.html#a9fba605639e5efcebf031e9fb1f1829a" title="Sets the nn::audio::I3dl2ReverbType effect parameters.">nn::audio::SetI3dl2ReverbParameters()</a></code>, you can achieve an effect similar to <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html#a56691f5a002784e036b1a462ef7067bc" title="Enumerated type that indicates the preset parameters that can be specified by I3dl2ReverbType.">nn::audio::I3dl2ReverbType::Preset</a></code>.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pOutReverb</em></code> while calling this function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a81">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a65">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a41">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aca3b4f1b5b17ad7caa0ca2e8a9ea9f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca3b4f1b5b17ad7caa0ca2e8a9ea9f90">&#9670;&nbsp;</a></span>SetI3dl2ReverbEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetI3dl2ReverbEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether the <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> is enabled or disabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td><code>true</code> to enable, or <code>false</code> to disable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 When a reverb effect is enabled, the effect is applied to the content of the input mix buffers and the resulting data is written to the output mix buffers according to the input/output buffer relationship specified using the <code><a class="el" href="namespacenn_1_1audio.html#a8a31783d96a7f992dc95ebd30a9ad3db" title="Sets the I3dl2ReverbType input/output mix buffer indexes.">nn::audio::SetI3dl2ReverbInputOutput()</a></code> function. When the effect is disabled, the contents of the input mix buffers are output as-is to the output mix buffers without applying the effect.</p>
<p>The values of parameters other than the enabled/disabled state are maintained before and after the <code><a class="el" href="namespacenn_1_1audio.html#aca3b4f1b5b17ad7caa0ca2e8a9ea9f90" title="Sets whether the I3dl2ReverbType is enabled or disabled.">SetI3dl2ReverbEnabled()</a></code> function is called. However, if you specify <code>true</code> when calling the <code><a class="el" href="namespacenn_1_1audio.html#a538fed00cd1c56b19858e73f6d06a59c" title="Sets the ReverbType object to be enabled or disabled.">SetReverbEnabled()</a></code> function, the internal state of <code><em>pReverb</em></code> is cleared. If there is a reverberant sound even when <code>false</code> has been specified, that sound gets cleared.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a82">AudioEffect/AudioEffect.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a42">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3df877ba35284f3a2b973777e9c80c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df877ba35284f3a2b973777e9c80c74">&#9670;&nbsp;</a></span>IsI3dl2ReverbEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::IsI3dl2ReverbEnabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html">I3dl2ReverbType</a> *&#160;</td>
          <td class="paramname"><em>pReverb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pReverb</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_i3dl2_reverb_type.html" title="I3dl2Reverb effect.">I3dl2ReverbType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if enabled. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pReverb</em></code> != <code>nullptr</code>.</li>
<li><code><em>pReverb</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pReverb</em></code> while calling this function. </p>

</div>
</div>
<a id="ad771f7516d8c6eea51938171d9389af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad771f7516d8c6eea51938171d9389af7">&#9670;&nbsp;</a></span>AddBiquadFilter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::AddBiquadFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html">BiquadFilterType</a> *&#160;</td>
          <td class="paramname"><em>pBiquadFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pFinalMix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a <code><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html" title="A BiquadFilter effect.">BiquadFilterType</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#abcc7c4eb06afe0673e8196edc23dd9f0" title="Initializes FinalMixType and adds it to the AudioRendererConfig.">nn::audio::AcquireFinalMix()</a></code> initializes <code><em>pFinalMix</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pBiquadFilter</td><td>An uninitialized <code><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html" title="A BiquadFilter effect.">BiquadFilterType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFinalMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> to which to add <code><em>pBiquadFilter</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html">nn::audio::ResultOutOfResource</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pBiquadFilter</em></code> != <code>nullptr</code>.</li>
<li><code><em>pBiquadFilter</em></code> is uninitialized.</li>
<li><code><em>pFinalMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pFinalMix</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pBiquadFilter</em></code> is initialized.</li>
<li><code><em>pBiquadFilter</em></code> is enabled.</li>
<li>The input/output buffers for <code><em>pBiquadFilter</em></code> are not configured.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Add an effect that performs a <code>BiquadFilter</code> process to <code><em>pFinalMix</em></code> and initializes <code><em>pBiquadFilter</em></code>. Calling this function associates <code><em>pBiquadFilter</em></code> with <code><em>pFinalMix</em></code> and makes it possible to perform effect operations on the mix buffers managed by <code><em>pFinalMix</em></code>. Subsequent operations on <code><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html" title="A BiquadFilter effect.">BiquadFilterType</a></code> are conducted via <code><em>pBiquadFilter</em></code>. For a list of the functions that operate on <code><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html" title="A BiquadFilter effect.">BiquadFilterType</a></code>, see the description for <code><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html" title="A BiquadFilter effect.">BiquadFilterType</a></code>.</p>
<p>For its biquad filter effect processes, <code><em>pBiquadFilter</em></code> can use the mix buffers managed by the <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> specified by <code><em>pFinalMix</em></code>. For more information about the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> and <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> mix buffers, see Mix Buffers in the <a href="../../Package/contents/Pages/Page_89991492.html">Audio Renderer</a> documentation.</p>
<p>Only one instance of each type of effect can be added to a single <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. A single instance of an effect cannot be added to multiple instances of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. The following warning message is displayed if an initialized effect that has already been added to an instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> is added to the same instance or another instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> again. </p><div class="fragment"><div class="line">[<a class="code" href="namespacenn_1_1audio.html">nn::audio</a>] Warning: The passed effect is already initialized. Please confirm <span class="keywordflow">if</span> (address <span class="keywordflow">for</span> effect instance) is a valid effect <span class="keywordtype">object</span>.</div>
</div><!-- fragment --><p> ("address for effect instance" is the address of the instance of the effect that you attempted to add.) If this warning is displayed, check whether the effect instance causing the warning was already removed from <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> by the <code><a class="el" href="namespacenn_1_1audio.html#a2163e3d699edc8244383a94ed760f0be" title="Removes a BiquadFilterType object from FinalMixType.">nn::audio::RemoveBiquadFilter()</a></code> function.</p>
<p>Immediately after addition to <code><em>pFinalMix</em></code>, the input/output mix buffers for <code><em>pBiquadFilter</em></code> are unconnected and <code><em>pBiquadFilter</em></code> is in the enabled state. Use the <code><a class="el" href="namespacenn_1_1audio.html#a3b4e2ea3271f853614264e81fcb8b834" title="Sets the input/output relationship of the mixing process performed by BiquadFilterType.">nn::audio::SetBiquadFilterInputOutput()</a></code> function to specify the indexes of the input/output mix buffers.</p>
<p>If the process for adding the effect fails and the function returns <code><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html" title="A class that represents error Result values (audio: Insufficient resources.).">nn::audio::ResultOutOfResource</a></code>, this usually indicates that the number of effects currently being used exceeds the maximum number of effects specified for <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html" title="The audio renderer parameters.">nn::audio::AudioRendererParameter</a>.<em>effectCount</em></code>. Delete one of the other effects or increase the number specified for <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html" title="The audio renderer parameters.">nn::audio::AudioRendererParameter</a>.<em>effectCount</em></code>.</p>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad771f7516d8c6eea51938171d9389af7" title="Adds a BiquadFilterType object to FinalMixType.">nn::audio::AddBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a2163e3d699edc8244383a94ed760f0be" title="Removes a BiquadFilterType object from FinalMixType.">nn::audio::RemoveBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a7bd3cc176b82c7cd5659c364ab97ab08" title="Adds BufferMixer to FinalMixType.">nn::audio::AddBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a400aff980a26fd295d911adbffd5f8ae" title="Removes BufferMixer from FinalMixType.">nn::audio::RemoveBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad332d3b8805f5157ef98572a99a9f2a0" title="Adds a DelayType object to FinalMixType.">nn::audio::AddDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a47262039889d9d23aeac0d82ed318ac0" title="Removes a DelayType object from FinalMixType.">nn::audio::RemoveDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aa081b9cab7e4ca8d079093c1fc50bb4d" title="Adds a ReverbType object to FinalMixType.">nn::audio::AddReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a8dda67780e46472ca22360376e6eb831" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a88bff95c7242f9d37ae5f631e825648b" title="Adds a I3dl2ReverbType object to FinalMixType.">nn::audio::AddI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a32e1724b072fff4284c19e597ac94d84" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a086c8ae883a8dabacad2c3ff3e995f13" title="Adds an AuxType object to FinalMixType.">nn::audio::AddAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a5133a62d6f97d3054e9ad428ae866102" title="Removes an AuxType object from FinalMixType.">nn::audio::RemoveAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a0bab4b3f6c0c1c7aa0011d2ee4b33919" title="Adds a LightLimiterType object to FinalMixType.">nn::audio::AddLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aacc63377e4f4f87617ff50fc981b170d" title="Removes a LightLimiterType object from FinalMixType.">nn::audio::RemoveLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ab3024a56e39831c3ba5fc8e52bca1a7e" title="Adds a CaptureType object to FinalMixType.">nn::audio::AddCapture()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a3fd8807d5efcb1fae477f690c8a8b48d" title="Removes the CaptureType object from FinalMixType.">nn::audio::RemoveCapture()</a></code></li>
</ul>
<p>Also, do not perform any operations on <code><em>pFinalMix</em></code> while calling any of these functions. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a152">AudioEffect/AudioEffect.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a76c3462ac3e635e3d4be8d6bc760c566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c3462ac3e635e3d4be8d6bc760c566">&#9670;&nbsp;</a></span>AddBiquadFilter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::AddBiquadFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html">BiquadFilterType</a> *&#160;</td>
          <td class="paramname"><em>pBiquadFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pSubMix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a <code><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html" title="A BiquadFilter effect.">BiquadFilterType</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#a24020da05700a26ee46f04f5762c157f" title="Initializes a SubMixType object and adds it to AudioRendererConfig.">nn::audio::AcquireSubMix()</a></code> initializes <code><em>pSubMix</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pBiquadFilter</td><td>An uninitialized <code><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html" title="A BiquadFilter effect.">BiquadFilterType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSubMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> to which the effect is being added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html">nn::audio::ResultOutOfResource</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pBiquadFilter</em></code> != <code>nullptr</code>.</li>
<li><code><em>pBiquadFilter</em></code> is uninitialized.</li>
<li><code><em>pSubMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSubMix</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pBiquadFilter</em></code> is initialized.</li>
<li><code><em>pBiquadFilter</em></code> is enabled.</li>
<li>The input/output buffers for <code><em>pBiquadFilter</em></code> are not configured.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function does the same thing as the <code><a class="el" href="namespacenn_1_1audio.html#ad771f7516d8c6eea51938171d9389af7" title="Adds a BiquadFilterType object to FinalMixType.">nn::audio::AddBiquadFilter</a>(AudioRendererConfig* <em>pOutConfig</em>, BiquadFilterType* <em>pBiquadFilter</em>, FinalMixType* <em>pFinalMix</em>)</code> except when called on an instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>. </p>

</div>
</div>
<a id="a2163e3d699edc8244383a94ed760f0be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2163e3d699edc8244383a94ed760f0be">&#9670;&nbsp;</a></span>RemoveBiquadFilter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::RemoveBiquadFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html">BiquadFilterType</a> *&#160;</td>
          <td class="paramname"><em>pBiquadFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pFinalMix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a <code><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html" title="A BiquadFilter effect.">BiquadFilterType</a></code> object from <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#abcc7c4eb06afe0673e8196edc23dd9f0" title="Initializes FinalMixType and adds it to the AudioRendererConfig.">nn::audio::AcquireFinalMix()</a></code> initializes <code><em>pFinalMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBiquadFilter</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html" title="A BiquadFilter effect.">BiquadFilterType</a></code> object added to <code><em>pFinalMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFinalMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> that added <code><em>pBiquadFilter</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pBiquadFilter</em></code> != <code>nullptr</code>.</li>
<li><code><em>pBiquadFilter</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aeb233d493168659a563a2a875d3514b1">nn::audio::IsBiquadFilterRemovable(pBiquadFilter)</a></code> == <code>true</code>.</li>
<li><code><em>pFinalMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pFinalMix</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pBiquadFilter</em></code> is uninitialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 An effect can only be removed if the audio renderer has completely stopped using that effect. Before you use this function to remove <code>BiquadFilter</code>, call <code><a class="el" href="namespacenn_1_1audio.html#acb9d1c5cea01758a759108877d4b25c8" title="Sets BiquadFilterType as enabled or disabled.">nn::audio::SetBiquadFilterEnabled()</a></code> to disable <code>BiquadFilter</code> and call <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> to notify the audio renderer that it has been disabled. After the notification is sent, it may take up to two audio frames for the audio renderer to completely stop using the effect. Use the <code><a class="el" href="namespacenn_1_1audio.html#aeb233d493168659a563a2a875d3514b1" title="Determines whether the BiquadFilterTyp object can be safely removed.">nn::audio::IsBiquadFilterRemovable()</a></code> function to determine whether the effect can be safely removed.</p>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad771f7516d8c6eea51938171d9389af7" title="Adds a BiquadFilterType object to FinalMixType.">nn::audio::AddBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a2163e3d699edc8244383a94ed760f0be" title="Removes a BiquadFilterType object from FinalMixType.">nn::audio::RemoveBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a7bd3cc176b82c7cd5659c364ab97ab08" title="Adds BufferMixer to FinalMixType.">nn::audio::AddBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a400aff980a26fd295d911adbffd5f8ae" title="Removes BufferMixer from FinalMixType.">nn::audio::RemoveBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad332d3b8805f5157ef98572a99a9f2a0" title="Adds a DelayType object to FinalMixType.">nn::audio::AddDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a47262039889d9d23aeac0d82ed318ac0" title="Removes a DelayType object from FinalMixType.">nn::audio::RemoveDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aa081b9cab7e4ca8d079093c1fc50bb4d" title="Adds a ReverbType object to FinalMixType.">nn::audio::AddReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a8dda67780e46472ca22360376e6eb831" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a88bff95c7242f9d37ae5f631e825648b" title="Adds a I3dl2ReverbType object to FinalMixType.">nn::audio::AddI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a32e1724b072fff4284c19e597ac94d84" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a086c8ae883a8dabacad2c3ff3e995f13" title="Adds an AuxType object to FinalMixType.">nn::audio::AddAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a5133a62d6f97d3054e9ad428ae866102" title="Removes an AuxType object from FinalMixType.">nn::audio::RemoveAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a0bab4b3f6c0c1c7aa0011d2ee4b33919" title="Adds a LightLimiterType object to FinalMixType.">nn::audio::AddLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aacc63377e4f4f87617ff50fc981b170d" title="Removes a LightLimiterType object from FinalMixType.">nn::audio::RemoveLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ab3024a56e39831c3ba5fc8e52bca1a7e" title="Adds a CaptureType object to FinalMixType.">nn::audio::AddCapture()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a3fd8807d5efcb1fae477f690c8a8b48d" title="Removes the CaptureType object from FinalMixType.">nn::audio::RemoveCapture()</a></code></li>
</ul>
<p>Also, do not perform any operations on <code><em>pFinalMix</em></code> while calling any of these functions. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="a3676a4d2cf28de8e4cda2f53c308fb2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3676a4d2cf28de8e4cda2f53c308fb2a">&#9670;&nbsp;</a></span>RemoveBiquadFilter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::RemoveBiquadFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html">BiquadFilterType</a> *&#160;</td>
          <td class="paramname"><em>pBiquadFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pSubMix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a <code><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html" title="A BiquadFilter effect.">BiquadFilterType</a></code> object from <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#a24020da05700a26ee46f04f5762c157f" title="Initializes a SubMixType object and adds it to AudioRendererConfig.">nn::audio::AcquireSubMix()</a></code> initializes <code><em>pSubMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBiquadFilter</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html" title="A BiquadFilter effect.">BiquadFilterType</a></code> object added to <code><em>pSubMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSubMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> that added <code><em>pBiquadFilter</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pBiquadFilter</em></code> != <code>nullptr</code>.</li>
<li><code><em>pBiquadFilter</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aeb233d493168659a563a2a875d3514b1">nn::audio::IsBiquadFilterRemovable(pBiquadFilter)</a></code> == <code>true</code>.</li>
<li><code><em>pSubMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSubMix</em></code> is initialized.</li>
<li><code><em>pBiquadFilter</em></code> has been added to <code><em>pSubMix</em></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pBiquadFilter</em></code> is uninitialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function does the same thing as the <code><a class="el" href="namespacenn_1_1audio.html#a2163e3d699edc8244383a94ed760f0be" title="Removes a BiquadFilterType object from FinalMixType.">nn::audio::RemoveBiquadFilter</a>(AudioRendererConfig* <em>pOutConfig</em>, BiquadFilterType* <em>pBiquadFilter</em>, FinalMixType* <em>pFinalMix</em>)</code> except when called on an instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>. </p>

</div>
</div>
<a id="a881e5c537d7ea1a12be0fa65e0d7cafa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a881e5c537d7ea1a12be0fa65e0d7cafa">&#9670;&nbsp;</a></span>GetBiquadFilterInputOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::GetBiquadFilterInputOutput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html">BiquadFilterType</a> *&#160;</td>
          <td class="paramname"><em>pBiquadFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>outInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>outOutput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the input/output relationship of the mixing process set in <code><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html" title="A BiquadFilter effect.">BiquadFilterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBiquadFilter</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html" title="A BiquadFilter effect.">BiquadFilterType</a></code> object added to the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outInput</td><td>The array from which to get the indexes of the input mix buffers set in <code><em>pBiquadFilter</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outOutput</td><td>The array from which to get the indexes of the output mix buffers set in <code><em>pBiquadFilter</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutCount</td><td>The number of mix buffer indexes obtained in <code><em>outInput</em></code> and <code><em>outOutput</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Length of the <code><em>outInput</em></code> and <code><em>outOutput</em></code> arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pBiquadFilter</em></code> != <code>nullptr</code>.</li>
<li><code><em>pBiquadFilter</em></code> is initialized.</li>
<li><code><em>outInput</em></code> != <code>nullptr</code>.</li>
<li><code><em>outOutput</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutCount</em></code> != <code>nullptr</code>.</li>
<li><code><em>count</em></code> &gt; <code>0</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a3b4e2ea3271f853614264e81fcb8b834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b4e2ea3271f853614264e81fcb8b834">&#9670;&nbsp;</a></span>SetBiquadFilterInputOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetBiquadFilterInputOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html">BiquadFilterType</a> *&#160;</td>
          <td class="paramname"><em>pBiquadFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the input/output relationship of the mixing process performed by <code><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html" title="A BiquadFilter effect.">BiquadFilterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pBiquadFilter</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html" title="A BiquadFilter effect.">BiquadFilterType</a></code> object added to the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The array of indexes of input mix buffers to set in <code><em>pBiquadFilter</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>The array of indexes of output mix buffers to set in <code><em>pBiquadFilter</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of mix buffer indexes stored in <code><em>input</em></code> and <code><em>output</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pBiquadFilter</em></code> != <code>nullptr</code>.</li>
<li><code><em>pBiquadFilter</em></code> is initialized.</li>
<li><code><em>input</em></code> != <code>nullptr</code>.</li>
<li><code><em>output</em></code> != <code>nullptr</code>.</li>
<li><code>0</code> &lt; <code><em>count</em></code> &amp;&amp; <code><em>count</em></code> &lt;= <code><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html#ae2275f286621039affbdfbb30d816062" title="The maximum number of channels that can be set for BiquadFilterType.">nn::audio::BiquadFilterType::ChannelCountMax</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The processing order of channels is undefined. Do not configure settings that depend on a certain processing order. For example, configuring settings like <code>{0, 1}</code> for <code><em>input</em></code> and <code>{ 1, 2 }</code> for <code><em>output</em></code> to realize a multi-stage biquad filter is prohibited. If you want to realize this kind of process, add multiple <code><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html" title="A BiquadFilter effect.">BiquadFilterType</a></code> objects to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> and <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>.</p>
<p>Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a153">AudioEffect/AudioEffect.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac9b01667fb80b99e942315cffd097170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b01667fb80b99e942315cffd097170">&#9670;&nbsp;</a></span>GetBiquadFilterParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1audio_1_1_biquad_filter_parameter.html">BiquadFilterParameter</a> nn::audio::GetBiquadFilterParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html">BiquadFilterType</a> *&#160;</td>
          <td class="paramname"><em>pBiquadFilter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the <code><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html" title="A BiquadFilter effect.">BiquadFilterType</a></code> parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBiquadFilter</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html" title="A BiquadFilter effect.">BiquadFilterType</a></code> object added to the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the parameters. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pBiquadFilter</em></code> != <code>nullptr</code>.</li>
<li><code><em>pBiquadFilter</em></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a14e10457a7df070f7199b648b233f98e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e10457a7df070f7199b648b233f98e">&#9670;&nbsp;</a></span>SetBiquadFilterParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetBiquadFilterParameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html">BiquadFilterType</a> *&#160;</td>
          <td class="paramname"><em>pBiquadFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_biquad_filter_parameter.html">BiquadFilterParameter</a> &amp;&#160;</td>
          <td class="paramname"><em>parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <code><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html" title="A BiquadFilter effect.">BiquadFilterType</a></code> parameter. </p>
<p>This function performs an internal process equivalent to <code><a class="el" href="namespacenn_1_1audio.html#acb9d1c5cea01758a759108877d4b25c8" title="Sets BiquadFilterType as enabled or disabled.">nn::audio::SetBiquadFilterEnabled</a>(<em>parameter.enable</em>)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBiquadFilter</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html" title="A BiquadFilter effect.">BiquadFilterType</a></code> object added to the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter</td><td>Parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pBiquadFilter</em></code> != <code>nullptr</code>.</li>
<li><code><em>pBiquadFilter</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code>GetBiquadFilterParameter(pBiquadFilter)</code> == <code><em>parameter</em></code>.</li>
<li><code>IsBiquadFilterEnabled(pBiquadFilter)</code> == <code><em>parameter</em>.enable</code></li>
</ul>
</dd></dl>
<p>Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a155">AudioEffect/AudioEffect.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a37143a7c7866ddc82e23c22d48f4bfca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37143a7c7866ddc82e23c22d48f4bfca">&#9670;&nbsp;</a></span>IsBiquadFilterEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::IsBiquadFilterEnabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html">BiquadFilterType</a> *&#160;</td>
          <td class="paramname"><em>pBiquadFilter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether <code>BiquadFilter</code> is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBiquadFilter</td><td>BiquadFilter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if enabled, or <code>false</code> otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pBiquadFilter</em></code> != <code>nullptr</code>.</li>
<li><code><em>pBiquadFilter</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a100">AudioEffect/AudioEffect.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="acb9d1c5cea01758a759108877d4b25c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb9d1c5cea01758a759108877d4b25c8">&#9670;&nbsp;</a></span>SetBiquadFilterEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetBiquadFilterEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html">BiquadFilterType</a> *&#160;</td>
          <td class="paramname"><em>pBiquadFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <code><a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html" title="A BiquadFilter effect.">BiquadFilterType</a></code> as enabled or disabled. </p>
<p>If enabled, the biquad filter process is conducted based on the parameters set by functions like <code><a class="el" href="namespacenn_1_1audio.html#a14e10457a7df070f7199b648b233f98e" title="Sets the BiquadFilterType parameter.">nn::audio::SetBiquadFilterParameter()</a></code> and <code><a class="el" href="namespacenn_1_1audio.html#a3b4e2ea3271f853614264e81fcb8b834" title="Sets the input/output relationship of the mixing process performed by BiquadFilterType.">nn::audio::SetBiquadFilterInputOutput()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBiquadFilter</td><td>BiquadFilter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td><code>true</code> to enable, or <code>false</code> to disable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pBiquadFilter</em></code> != <code>nullptr</code>.</li>
<li><code><em>pBiquadFilter</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code>IsBiquadFilterEnabled(<em>pBiquadFilter</em>)</code> == <code>enable</code>.</li>
</ul>
</dd></dl>
<p>If disabled, the data passes through without effect processing.</p>
<p>Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a101">AudioEffect/AudioEffect.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aeb233d493168659a563a2a875d3514b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb233d493168659a563a2a875d3514b1">&#9670;&nbsp;</a></span>IsBiquadFilterRemovable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::IsBiquadFilterRemovable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_biquad_filter_type.html">BiquadFilterType</a> *&#160;</td>
          <td class="paramname"><em>pBiquadFilter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the <code>BiquadFilterTyp</code> object can be safely removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBiquadFilter</td><td>BiquadFilter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if possible. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pBiquadFilter</em></code> != <code>nullptr</code>.</li>
<li><code><em>pBiquadFilter</em></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a953c597ac5ecfb87755ad2233c142002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953c597ac5ecfb87755ad2233c142002">&#9670;&nbsp;</a></span>GetRequiredBufferSizeForCapture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::audio::GetRequiredBufferSizeForCapture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html">AudioRendererParameter</a> *&#160;</td>
          <td class="paramname"><em>pParameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mixBufferFrameCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelCountMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of work buffer required by the renderer to use <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pParameter</td><td>The parameter used when the <code><a class="el" href="namespacenn_1_1audio.html#a855da5a3e7dd33233c653a7dd2db775a" title="Gets the audio renderer.">nn::audio::OpenAudioRenderer()</a></code> function gets the audio renderer of the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> to which <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> is being added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mixBufferFrameCount</td><td>The maximum number of audio frames that <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> will buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCountMax</td><td>The number of channels to store in <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the buffer size in bytes. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pParameter</em></code> != <code>nullptr</code>.</li>
<li><code><em>pParameter</em></code> is initialized.</li>
<li><code><em>mixBufferFrameCount</em></code> <code>1</code>.</li>
<li><code><em>channelCountMax</em></code> &gt; <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> uses a buffer when delivering sample data from the audio renderer to the user. This function returns the buffer size required for that process.</p>
<p>When the buffer size returned by this function is passed to the <code><a class="el" href="namespacenn_1_1audio.html#ab3024a56e39831c3ba5fc8e52bca1a7e" title="Adds a CaptureType object to FinalMixType.">nn::audio::AddCapture()</a></code> function, samples equal in number to (<code><em>mixBufferFrameCount</em></code> * <code><em>channelCountMax </em></code> * <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html" title="The audio renderer parameters.">AudioRendererParameter</a>.<em>sampleCount</em></code>) will be internally buffered. In other words, <code><em>mixBufferFrameCount</em></code> audio frames of samples can be buffered, providing some temporal leeway to the user in getting the samples. On the other hand, when <code><em>mixBufferFrameCount</em></code> is larger, the required buffer size also increases.</p>
<p>The audio renderer writes samples to this buffer in every audio frame, with the number of samples equal to the value set at initialization time for <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html" title="The audio renderer parameters.">AudioRendererParameter</a>.<em>sampleCount</em></code> multiplied by the <code><em>count</em></code> specified by the <code><a class="el" href="namespacenn_1_1audio.html#a521d657d2d1033e0712094701d5a19d3" title="Sets the CaptureType input buffer indexes.">nn::audio::SetCaptureInput()</a></code> function. If the user is late reading the sample data, the data will be lost, so you must periodically call the <code><a class="el" href="namespacenn_1_1audio.html#a11831c5f69d9088ecb36cd6e10ee741b" title="Reads count number of samples from CaptureType.">nn::audio::ReadCaptureBuffer()</a></code> function to get the sample data.</p>
<p>The user must set a value for <code><em>mixBufferFrameCount</em></code> that is appropriate for the required process of getting sample data. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a148">AudioEffect/AudioEffect.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab3024a56e39831c3ba5fc8e52bca1a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3024a56e39831c3ba5fc8e52bca1a7e">&#9670;&nbsp;</a></span>AddCapture() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::AddCapture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_capture_type.html">CaptureType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pFinalMix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#abcc7c4eb06afe0673e8196edc23dd9f0" title="Initializes FinalMixType and adds it to the AudioRendererConfig.">nn::audio::AcquireFinalMix()</a></code> initializes <code><em>pFinalMix</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pEffect</td><td>An uninitialized <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFinalMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> to which the effect is being added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The buffer used to store samples from the audio renderer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size of the buffer, in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html">nn::audio::ResultOutOfResource</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is uninitialized.</li>
<li><code><em>pFinalMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>buffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>buffer</em></code> is aligned to <code><a class="el" href="namespacenn_1_1audio.html#a61833f2e2cf0253e3054188e900315af" title="The alignment size for audio buffers.">nn::audio::BufferAlignSize</a></code>.</li>
<li><code><em>bufferSize</em></code> &gt; <code>0</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pEffect</em></code> is initialized.</li>
<li><code><em>pEffect</em></code> is enabled.</li>
<li>The input buffer for <code><em>pEffect</em></code> is not set.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Add a <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> effect that gets sample data to <code><em>pFinalMix</em></code> and initializes <code><em>pEffect</em></code>. Calling this function associates <code><em>pEffect</em></code> with <code><em>pFinalMix</em></code> and initializes <code><em>pEffect</em></code>, enabling effect operations to be performed on the mix buffers managed by <code><em>pFinalMix</em></code>. Subsequent operations on <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> are performed through <code><em>pEffect</em></code>. For a list of functions that can perform operations on <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code>, see the description for <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code>.</p>
<p>A similar effect exists in the form of <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code>, but unlike that effect, <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> does not provide a feature for writing sample data back to the audio renderer. Because <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> does not have this write-back feature, it does not affect output after effect processing. In other words, the delays to output after effect processing that occur with <code><a class="el" href="structnn_1_1audio_1_1_aux_type.html" title="Effect used to incorporate an effect process that the user can define.">AuxType</a></code> do not occur with <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code>.</p>
<p><code><em>buffer</em></code> is used as the buffer managed internally by <code><em>pEffect</em></code> for exchanging sample data with the audio renderer. The memory region specified for <code><em>buffer</em></code> must be contained within the memory region specified for <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html" title="Structure for representing memory regions used by an audio renderer.">nn::audio::MemoryPoolType</a></code>. Also, the instance of <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html" title="Structure for representing memory regions used by an audio renderer.">nn::audio::MemoryPoolType</a></code> that contains the memory region specified for <code><em>buffer</em></code> must be in the attached state. For more information, see the description of <code><a class="el" href="namespacenn_1_1audio.html#a953c597ac5ecfb87755ad2233c142002" title="Gets the size of work buffer required by the renderer to use CaptureType.">nn::audio::GetRequiredBufferSizeForCapture()</a></code>.</p>
<p>Only one instance of each type of effect can be added to a single <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. A single instance of an effect cannot be added to multiple instances of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. The following warning message is displayed if an initialized effect that has already been added to an instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> is added to the same instance or another instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> again. </p><div class="fragment"><div class="line">[<a class="code" href="namespacenn_1_1audio.html">nn::audio</a>] Warning: The passed effect is already initialized. Please confirm <span class="keywordflow">if</span> (address <span class="keywordflow">for</span> effect instance) is a valid effect <span class="keywordtype">object</span>.</div>
</div><!-- fragment --><p> ("address for effect instance" is the address of the instance of the effect that you attempted to add.) Immediately after the effect is added, <code><em>pEffect</em></code> is enabled but not connected to an input mix buffer. Use the <code><a class="el" href="namespacenn_1_1audio.html#a521d657d2d1033e0712094701d5a19d3" title="Sets the CaptureType input buffer indexes.">nn::audio::SetCaptureInput()</a></code> function to set the index of the input mix buffer.</p>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad771f7516d8c6eea51938171d9389af7" title="Adds a BiquadFilterType object to FinalMixType.">nn::audio::AddBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a2163e3d699edc8244383a94ed760f0be" title="Removes a BiquadFilterType object from FinalMixType.">nn::audio::RemoveBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a7bd3cc176b82c7cd5659c364ab97ab08" title="Adds BufferMixer to FinalMixType.">nn::audio::AddBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a400aff980a26fd295d911adbffd5f8ae" title="Removes BufferMixer from FinalMixType.">nn::audio::RemoveBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad332d3b8805f5157ef98572a99a9f2a0" title="Adds a DelayType object to FinalMixType.">nn::audio::AddDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a47262039889d9d23aeac0d82ed318ac0" title="Removes a DelayType object from FinalMixType.">nn::audio::RemoveDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aa081b9cab7e4ca8d079093c1fc50bb4d" title="Adds a ReverbType object to FinalMixType.">nn::audio::AddReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a8dda67780e46472ca22360376e6eb831" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a88bff95c7242f9d37ae5f631e825648b" title="Adds a I3dl2ReverbType object to FinalMixType.">nn::audio::AddI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a32e1724b072fff4284c19e597ac94d84" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a086c8ae883a8dabacad2c3ff3e995f13" title="Adds an AuxType object to FinalMixType.">nn::audio::AddAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a5133a62d6f97d3054e9ad428ae866102" title="Removes an AuxType object from FinalMixType.">nn::audio::RemoveAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a0bab4b3f6c0c1c7aa0011d2ee4b33919" title="Adds a LightLimiterType object to FinalMixType.">nn::audio::AddLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aacc63377e4f4f87617ff50fc981b170d" title="Removes a LightLimiterType object from FinalMixType.">nn::audio::RemoveLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ab3024a56e39831c3ba5fc8e52bca1a7e" title="Adds a CaptureType object to FinalMixType.">nn::audio::AddCapture()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a3fd8807d5efcb1fae477f690c8a8b48d" title="Removes the CaptureType object from FinalMixType.">nn::audio::RemoveCapture()</a></code></li>
</ul>
<p>Also, do not perform any operations on <code><em>pFinalMix</em></code> while calling any of these functions. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a149">AudioEffect/AudioEffect.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a533a6e60124d6f2294ac1192f11f6278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a533a6e60124d6f2294ac1192f11f6278">&#9670;&nbsp;</a></span>AddCapture() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::AddCapture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_capture_type.html">CaptureType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pSubMix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#a24020da05700a26ee46f04f5762c157f" title="Initializes a SubMixType object and adds it to AudioRendererConfig.">nn::audio::AcquireSubMix()</a></code> initializes <code><em>pSubMix</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pEffect</td><td>An uninitialized <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSubMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> to which the effect is being added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The buffer used to store samples from the audio renderer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size of the buffer, in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html">nn::audio::ResultOutOfResource</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is uninitialized.</li>
<li><code><em>pSubMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>buffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>buffer</em></code> is aligned to <code><a class="el" href="namespacenn_1_1audio.html#a61833f2e2cf0253e3054188e900315af" title="The alignment size for audio buffers.">nn::audio::BufferAlignSize</a></code>.</li>
<li><code><em>bufferSize</em></code> &gt; <code>0</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pEffect</em></code> is initialized.</li>
<li><code><em>pEffect</em></code> is enabled.</li>
<li>The input buffer for <code><em>pEffect</em></code> is not set.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Adds <code><em>pEffect</em></code> to <code><em>pSubMix</em></code> and initializes <code><em>pEffect</em></code>. Except for the fact that the target is <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, the behavior of this function is the same as <code><a class="el" href="namespacenn_1_1audio.html#ab3024a56e39831c3ba5fc8e52bca1a7e" title="Adds a CaptureType object to FinalMixType.">nn::audio::AddCapture</a>(AudioRendererConfig* <em>pOutConfig</em>, CaptureType* <em>pEffect</em>, FinalMixType* <em>pFinalMix</em>, void* <em>buffer</em>, size_t <em>bufferSize</em>)</code>. </p>

</div>
</div>
<a id="a3fd8807d5efcb1fae477f690c8a8b48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd8807d5efcb1fae477f690c8a8b48d">&#9670;&nbsp;</a></span>RemoveCapture() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::RemoveCapture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_capture_type.html">CaptureType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pFinalMix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> object from <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#abcc7c4eb06afe0673e8196edc23dd9f0" title="Initializes FinalMixType and adds it to the AudioRendererConfig.">nn::audio::AcquireFinalMix()</a></code> initializes <code><em>pFinalMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> object added to <code>FinalMix</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFinalMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> to remove <code><em>pEffect</em></code> from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
<li><a class="el" href="namespacenn_1_1audio.html#afa39f2400eb2c5de900782bac69beed2">nn::audio::IsCaptureRemovable</a>"nn::audio::IsCaptureRemovable(pEffect)" == <code>true</code>.</li>
<li><code><em>pFinalMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pFinalMix</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pEffect</em></code> is uninitialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 An effect can only be removed if the audio renderer has completely stopped using that effect. Before you use this function to remove <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code>, call <code><a class="el" href="namespacenn_1_1audio.html#a25ba1a801f4ce78363f7587ff611f192" title="Sets CaptureType as either enabled or disabled.">nn::audio::SetCaptureEnabled()</a></code> to disable the <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> object and call <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> to notify the audio renderer that the object has been disabled. After calling <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code>, use the <code><a class="el" href="namespacenn_1_1audio.html#afa39f2400eb2c5de900782bac69beed2" title="Determines whether the CaptureType object can be safely removed.">nn::audio::IsCaptureRemovable()</a></code> function to determine whether the audio renderer has completely stopped processing the effect and it can be safely removed.</p>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad771f7516d8c6eea51938171d9389af7" title="Adds a BiquadFilterType object to FinalMixType.">nn::audio::AddBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a2163e3d699edc8244383a94ed760f0be" title="Removes a BiquadFilterType object from FinalMixType.">nn::audio::RemoveBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a7bd3cc176b82c7cd5659c364ab97ab08" title="Adds BufferMixer to FinalMixType.">nn::audio::AddBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a400aff980a26fd295d911adbffd5f8ae" title="Removes BufferMixer from FinalMixType.">nn::audio::RemoveBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad332d3b8805f5157ef98572a99a9f2a0" title="Adds a DelayType object to FinalMixType.">nn::audio::AddDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a47262039889d9d23aeac0d82ed318ac0" title="Removes a DelayType object from FinalMixType.">nn::audio::RemoveDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aa081b9cab7e4ca8d079093c1fc50bb4d" title="Adds a ReverbType object to FinalMixType.">nn::audio::AddReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a8dda67780e46472ca22360376e6eb831" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a88bff95c7242f9d37ae5f631e825648b" title="Adds a I3dl2ReverbType object to FinalMixType.">nn::audio::AddI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a32e1724b072fff4284c19e597ac94d84" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a086c8ae883a8dabacad2c3ff3e995f13" title="Adds an AuxType object to FinalMixType.">nn::audio::AddAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a5133a62d6f97d3054e9ad428ae866102" title="Removes an AuxType object from FinalMixType.">nn::audio::RemoveAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a0bab4b3f6c0c1c7aa0011d2ee4b33919" title="Adds a LightLimiterType object to FinalMixType.">nn::audio::AddLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aacc63377e4f4f87617ff50fc981b170d" title="Removes a LightLimiterType object from FinalMixType.">nn::audio::RemoveLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ab3024a56e39831c3ba5fc8e52bca1a7e" title="Adds a CaptureType object to FinalMixType.">nn::audio::AddCapture()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a3fd8807d5efcb1fae477f690c8a8b48d" title="Removes the CaptureType object from FinalMixType.">nn::audio::RemoveCapture()</a></code></li>
</ul>
<p>Also, do not perform any operations on <code><em>pFinalMix</em></code> while calling any of these functions. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="a1b5c8d26319bfa5a5aebd7dd137b66ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5c8d26319bfa5a5aebd7dd137b66ca">&#9670;&nbsp;</a></span>RemoveCapture() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::RemoveCapture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_capture_type.html">CaptureType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pSubMix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> object from <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#a24020da05700a26ee46f04f5762c157f" title="Initializes a SubMixType object and adds it to AudioRendererConfig.">nn::audio::AcquireSubMix()</a></code> initializes <code><em>pSubMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> object added to <code><em>pSubMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSubMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> to remove <code><em>pEffect</em></code> from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
<li><a class="el" href="namespacenn_1_1audio.html#afa39f2400eb2c5de900782bac69beed2">nn::audio::IsCaptureRemovable</a>"nn::audio::IsCaptureRemovable(pEffect)" == <code>true</code>.</li>
<li><code><em>pSubMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSubMix</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pEffect</em></code> is uninitialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 An effect can only be removed if the audio renderer has completely stopped using that effect. Except for the fact that the target is <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, the behavior of this function is the same as <code><a class="el" href="namespacenn_1_1audio.html#a3fd8807d5efcb1fae477f690c8a8b48d" title="Removes the CaptureType object from FinalMixType.">nn::audio::RemoveCapture</a>(AudioRendererConfig* <em>pOutConfig</em>, CaptureType* <em>pEffect</em>, FinalMixType* <em>pFinalMix</em>)</code>. </p>

</div>
</div>
<a id="a30cc12a3a588d65ee5b6ac6b0ef0139f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30cc12a3a588d65ee5b6ac6b0ef0139f">&#9670;&nbsp;</a></span>GetCaptureChannelCountMax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetCaptureChannelCountMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_capture_type.html">CaptureType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum number of channels that can be set for <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the maximum value for the number of channels that can be set. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the maximum number of channels that can be set for <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code>. This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. </p>

</div>
</div>
<a id="aa0ee227d53b2d54410531fce49c31706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0ee227d53b2d54410531fce49c31706">&#9670;&nbsp;</a></span>GetCaptureInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::GetCaptureInput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_capture_type.html">CaptureType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>pOutInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> input buffer indexes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutInput</td><td>The array from which to get the indexes of the input mix buffers set in <code><em>pEffect</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutCount</td><td>The number of mix buffer indexes obtained in <code><em>pOutInput</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The length of the <code><em>pOutInput</em></code> array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
<li><code><em>pOutInput</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutCount</em></code> != <code>nullptr</code>.</li>
<li><code><em>count</em></code> &gt; <code>0</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>Information for the number of indexes specified in <code><em>pOutCount</em></code> is written to <code><em>pOutInput</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the indexes of the input buffers for the <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> effect processing. The indexes of the mix buffers that serve as the input are stored in <code><em>pOutInput</em></code>. <code><em>count</em></code> is the upper limit for the number of indexes stored in <code><em>pOutInput</em></code>. The actual number of indexes stored in <code><em>pOutInput</em></code> is returned in <code><em>pOutCount</em></code>.</p>
<p>This function gets the input buffer indexes that were specified by the <code><a class="el" href="namespacenn_1_1audio.html#a521d657d2d1033e0712094701d5a19d3" title="Sets the CaptureType input buffer indexes.">nn::audio::SetCaptureInput()</a></code> function. If this function is called on <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> in the initial state where <code><a class="el" href="namespacenn_1_1audio.html#a521d657d2d1033e0712094701d5a19d3" title="Sets the CaptureType input buffer indexes.">nn::audio::SetCaptureInput()</a></code> has never been called, <code><em>pOutCount</em></code> returns <code>0</code> and no data is stored in <code><em>pOutInput</em></code>. For more information, see the description of the <code><a class="el" href="namespacenn_1_1audio.html#ab3024a56e39831c3ba5fc8e52bca1a7e" title="Adds a CaptureType object to FinalMixType.">nn::audio::AddCapture()</a></code> function. If the number of channels set for <code><em>pEffect</em></code> exceeds the number set for <code><em>count</em></code>, the <code><em>count</em></code> number of indexes is stored in <code><em>pOutInput</em></code>.</p>
<p>For more information about the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> and <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> mix buffers, see Mix Buffers in the <a href="../../Package/contents/Pages/Page_89991492.html">Audio Renderer</a> documentation.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. </p>

</div>
</div>
<a id="a521d657d2d1033e0712094701d5a19d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521d657d2d1033e0712094701d5a19d3">&#9670;&nbsp;</a></span>SetCaptureInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetCaptureInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_capture_type.html">CaptureType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> input buffer indexes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The array of indexes of input mix buffers to set in <code><em>pEffect</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of mix buffer indexes stored in <code><em>input</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
<li><code><em>input</em></code> != <code>nullptr</code>.</li>
<li><code>0</code> &lt; <code><em>count</em></code>.</li>
<li><code><em>count</em></code> &lt;= (The number of mix buffers held by the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> connected when <code><em>pEffect</em></code> was initialized).</li>
<li><code><em>count</em></code> &lt;= <a class="el" href="namespacenn_1_1audio.html#a30cc12a3a588d65ee5b6ac6b0ef0139f">nn::audio::GetCaptureChannelCountMax(pEffect)</a>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sets the mix buffers specified in the <code><em>input</em></code> array as the input.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a151">AudioEffect/AudioEffect.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a11831c5f69d9088ecb36cd6e10ee741b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11831c5f69d9088ecb36cd6e10ee741b">&#9670;&nbsp;</a></span>ReadCaptureBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::ReadCaptureBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_capture_type.html">CaptureType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>pOutData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads <code><em>count</em></code> number of samples from <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutData</td><td>Buffer used to load the specified number of sample arrays. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of samples to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of samples actually read. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
<li><code><em>pOutData</em></code> != <code>nullptr</code>.</li>
<li><code><em>count</em></code> &gt;= <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Loads sample data from the buffer managed by <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> into <code><em>pOutData</em></code>. Specify a value of (<em>number of channels</em>)  (<em>number of frame samples</em>) units for <code><em>count</em></code>. For example, if one audio frame stores 240 samples, and you are loading sample data for three channels, set <code><em>count</em></code> = (<code>240</code>  <code>3</code>)  (<em>number of required audio frames</em>). Use the <code><a class="el" href="namespacenn_1_1audio.html#a53c1ae605dd4de1a59af6c0d123c5bd5" title="Gets the maximum number of samples that can be stored in the buffer managed by CaptureType.">nn::audio::GetCaptureSampleCount()</a></code> function to get the number of frame samples.</p>
<p>The sample data is stored in <code><em>pOutData</em></code> in 32-bit Q15 format. Data loaded in <code><em>pOutData</em></code> is read with block interleaving. Take the preceding example where three channels of data are loaded to <code><em>pOutData</em></code>. This <code><em>pOutData</em></code> loads the sample data in the order of 240 samples of data for channel 1, 240 samples of data for channel 2, and then 240 samples of data for channel 3.</p>
<p>If the sample data in the buffer is depleted, the <code><a class="el" href="namespacenn_1_1audio.html#a11831c5f69d9088ecb36cd6e10ee741b" title="Reads count number of samples from CaptureType.">nn::audio::ReadCaptureBuffer()</a></code> function returns <code>0</code>. If this happens, the <code><a class="el" href="namespacenn_1_1audio.html#a11831c5f69d9088ecb36cd6e10ee741b" title="Reads count number of samples from CaptureType.">nn::audio::ReadCaptureBuffer()</a></code> function might be reading faster than the audio renderer is passing sample data to the buffer. Conversely, if the <code><a class="el" href="namespacenn_1_1audio.html#a11831c5f69d9088ecb36cd6e10ee741b" title="Reads count number of samples from CaptureType.">nn::audio::ReadCaptureBuffer()</a></code> function reads slower than the audio renderer is passing sample data to the buffer, the writable buffer space might become depleted. If that happens, older sample data will be overwritten first, and recorded sample data will be lost. In either case, we recommend that the user adjust the balance between the read frequency and the amount of delay as needed, using the <code><a class="el" href="namespacenn_1_1audio.html#a953c597ac5ecfb87755ad2233c142002" title="Gets the size of work buffer required by the renderer to use CaptureType.">nn::audio::GetRequiredBufferSizeForCapture()</a></code> function to increase the number of frames set for <code><em>mixBufferFrameCount</em></code>, and changing the interval between calls to <code><a class="el" href="namespacenn_1_1audio.html#a11831c5f69d9088ecb36cd6e10ee741b" title="Reads count number of samples from CaptureType.">nn::audio::ReadCaptureBuffer()</a></code>. (For more information, see the description of the <code><a class="el" href="namespacenn_1_1audio.html#a953c597ac5ecfb87755ad2233c142002" title="Gets the size of work buffer required by the renderer to use CaptureType.">nn::audio::GetRequiredBufferSizeForCapture()</a></code> function.) To get the cumulative number of samples that have been overwritten and lost, use the <code><a class="el" href="namespacenn_1_1audio.html#acd99cd5e9e834b1f37019a4e69b5c988" title="Gets the cumulative number of samples that have been lost from the buffer managed by CaptureType.">GetCaptureLostSampleCount()</a></code> function. For more information, see the function descriptions.</p>
<p>This function can be called at the same time as <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> or <code><a class="el" href="namespacenn_1_1audio.html#ac88d3b7c00c314f03079ef582e3e7a81" title="Executes rendering processing with the audio renderer.">nn::audio::ExecuteAudioRendererRendering()</a></code> without problem. However, this function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a65">AudioEffect/AudioEffect.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a419eabf43313e806b6ca6000d4bd98fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419eabf43313e806b6ca6000d4bd98fe">&#9670;&nbsp;</a></span>GetCaptureSampleRate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetCaptureSampleRate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_capture_type.html">CaptureType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the sample rate of the buffer managed by <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the sample rate. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> is initialized.</li>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the sampling rate set to the instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> to which <code><em>pEffect</em></code> is connected.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. </p>

</div>
</div>
<a id="a53c1ae605dd4de1a59af6c0d123c5bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c1ae605dd4de1a59af6c0d123c5bd5">&#9670;&nbsp;</a></span>GetCaptureSampleCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetCaptureSampleCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_capture_type.html">CaptureType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum number of samples that can be stored in the buffer managed by <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of samples. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> is initialized.</li>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The maximum number of samples that can be stored in the buffer is determined by the <code><em>bufferSize</em></code> set by the <code><a class="el" href="namespacenn_1_1audio.html#ab3024a56e39831c3ba5fc8e52bca1a7e" title="Adds a CaptureType object to FinalMixType.">nn::audio::AddCapture()</a></code> function when <code><em>pEffect</em></code> was initialized. For more information, see the description of <code><a class="el" href="namespacenn_1_1audio.html#a953c597ac5ecfb87755ad2233c142002" title="Gets the size of work buffer required by the renderer to use CaptureType.">nn::audio::GetRequiredBufferSizeForCapture()</a></code>.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. </p>

</div>
</div>
<a id="ad2b7a0112e26b5a4f7eb4a51275b08df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b7a0112e26b5a4f7eb4a51275b08df">&#9670;&nbsp;</a></span>IsCaptureEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::IsCaptureEnabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_capture_type.html">CaptureType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if enabled, or <code>false</code> otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. </p>

</div>
</div>
<a id="a25ba1a801f4ce78363f7587ff611f192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ba1a801f4ce78363f7587ff611f192">&#9670;&nbsp;</a></span>SetCaptureEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetCaptureEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_capture_type.html">CaptureType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> as either enabled or disabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td><code>true</code> to enable, or <code>false</code> to disable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the execution result. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><a class="el" href="namespacenn_1_1audio.html#ad2b7a0112e26b5a4f7eb4a51275b08df">nn::audio::IsCaptureEnabled(pEffect)</a> == <code>true</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function enables and disables the process of getting sample data. In either case, <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> has no effect on the output of the audio renderer.</p>
<p>When <code><em>pEffect</em></code> is disabled, samples that the <code><a class="el" href="namespacenn_1_1audio.html#a11831c5f69d9088ecb36cd6e10ee741b" title="Reads count number of samples from CaptureType.">nn::audio::ReadCaptureBuffer()</a></code> function has not finished reading are destroyed.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a150">AudioEffect/AudioEffect.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="afa39f2400eb2c5de900782bac69beed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa39f2400eb2c5de900782bac69beed2">&#9670;&nbsp;</a></span>IsCaptureRemovable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::IsCaptureRemovable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_capture_type.html">CaptureType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> object can be safely removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if possible. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 An effect can only be removed if the audio renderer has completely stopped using that effect. Call this function before calling <code><a class="el" href="namespacenn_1_1audio.html#a3fd8807d5efcb1fae477f690c8a8b48d" title="Removes the CaptureType object from FinalMixType.">nn::audio::RemoveCapture()</a></code> to confirm that the use of the <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> object targeted for removal has completely stopped. Note the following.</p><ul>
<li>The use of an effect does not stop immediately after it has been disabled by the <code><a class="el" href="namespacenn_1_1audio.html#a25ba1a801f4ce78363f7587ff611f192" title="Sets CaptureType as either enabled or disabled.">nn::audio::SetCaptureEnabled()</a></code> function.</li>
<li>It can take up to two audio frames for the use of the effect to stop after it has been disabled by the <code><a class="el" href="namespacenn_1_1audio.html#a25ba1a801f4ce78363f7587ff611f192" title="Sets CaptureType as either enabled or disabled.">nn::audio::SetCaptureEnabled()</a></code> function and the call to <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> has completed.</li>
<li>Make sure that you do not call <code><a class="el" href="namespacenn_1_1audio.html#a3fd8807d5efcb1fae477f690c8a8b48d" title="Removes the CaptureType object from FinalMixType.">nn::audio::RemoveCapture()</a></code> during this time.</li>
</ul>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="acd99cd5e9e834b1f37019a4e69b5c988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd99cd5e9e834b1f37019a4e69b5c988">&#9670;&nbsp;</a></span>GetCaptureLostSampleCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t nn::audio::GetCaptureLostSampleCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_capture_type.html">CaptureType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the cumulative number of samples that have been lost from the buffer managed by <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cumulative number of lost samples. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 If there is no remaining space when the audio renderer tries to write sample data to the buffer managed by <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code>, the oldest sample data is overwritten and recorded sample data is lost. This function gets the cumulative number of lost samples.</p>
<p>The value returned by this function is updated not when <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> is called, but rather when the audio renderer's rendering process is executed. In addition, the value returned by this function is reset to <code>0</code> by the <code><a class="el" href="namespacenn_1_1audio.html#aceccd794c9eaf4929fcaa37dc896d7cc" title="Resets the cumulative number of samples that have been lost from the buffer managed by CaptureType.">nn::audio::ResetCaptureLostSampleCount()</a></code> function.</p>
<p>The upper limit of the values returned by this function is the <code>std::int32_t</code>-type maximum value <code>std::numeric_limits&lt;std::int32_t&gt;::max()</code>. When this upper limit has been reached, the value does not change until it has been reset to <code>0</code> by the <code><a class="el" href="namespacenn_1_1audio.html#aceccd794c9eaf4929fcaa37dc896d7cc" title="Resets the cumulative number of samples that have been lost from the buffer managed by CaptureType.">nn::audio::ResetCaptureLostSampleCount()</a></code> function.</p>
<p>When <code><a class="el" href="namespacenn_1_1audio.html#ad2b7a0112e26b5a4f7eb4a51275b08df" title="Determines whether CaptureType is enabled.">nn::audio::IsCaptureEnabled()</a></code> is <code>false</code>, the audio renderer does not write sample data to the buffer, so the cumulative number of lost samples does not get updated.</p>
<p>This function can be called at the same time as <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> or <code><a class="el" href="namespacenn_1_1audio.html#ac88d3b7c00c314f03079ef582e3e7a81" title="Executes rendering processing with the audio renderer.">nn::audio::ExecuteAudioRendererRendering()</a></code> without problem. However, this function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a59">AudioEffect/AudioEffect.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aceccd794c9eaf4929fcaa37dc896d7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceccd794c9eaf4929fcaa37dc896d7cc">&#9670;&nbsp;</a></span>ResetCaptureLostSampleCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::ResetCaptureLostSampleCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_capture_type.html">CaptureType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the cumulative number of samples that have been lost from the buffer managed by <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Resets the cumulative number of samples that have been lost from the buffer managed by <code><a class="el" href="structnn_1_1audio_1_1_capture_type.html" title="An effect for incorporating the process of getting sample data.">CaptureType</a></code> to <code>0</code>.</p>
<p>This function can be called at the same time as <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> or <code><a class="el" href="namespacenn_1_1audio.html#ac88d3b7c00c314f03079ef582e3e7a81" title="Executes rendering processing with the audio renderer.">nn::audio::ExecuteAudioRendererRendering()</a></code> without problem. However, this function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a208">AudioEffect/AudioEffect.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a599944de2f532061310662a48f6379ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599944de2f532061310662a48f6379ac">&#9670;&nbsp;</a></span>GetRequiredBufferSizeForLightLimiter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::audio::GetRequiredBufferSizeForLightLimiter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td>
          <td class="paramname"><em>lookAheadTimeMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelCountMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the work buffer size required for the renderer to use <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lookAheadTimeMax</td><td>The maximum look-ahead time that can be set with <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleRate</td><td>The sample rate set in the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> instance to which <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> is added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCountMax</td><td>The maximum number of channels to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the buffer size required to use <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><a class="el" href="classnn_1_1_time_span.html#acce769d0612ece9d5f87d32150d1f706">nn::TimeSpan::FromMicroSeconds(0)</a> &lt;= <code><em>lookAheadTimeMax</em></code> &amp;&amp; <code><em>lookAheadTimeMax</em></code> &lt; <a class="el" href="classnn_1_1_time_span.html#acce769d0612ece9d5f87d32150d1f706">nn::TimeSpan::FromMicroSeconds(std::numeric_limits&lt;int32_t&gt;::max())</a>.</li>
<li>(<code><em>sampleRate</em></code> == <code>32000</code>) || (<code><em>sampleRate</em></code> == <code>48000</code>).</li>
<li>(<code><em>channelCountMax</em></code> == <code>1</code>) || (<code><em>channelCountMax</em></code> == <code>2</code>) || (<code><em>channelCountMax</em></code> == <code>4</code> ) || (<code><em>channelCountMax</em></code> == <code>6</code>).</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 For <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>, the required memory size varies based on the maximum look-ahead time, the sample rate, and the number of channels that are set. By specifying these values, this function calculates the necessary memory size for operation of <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>.</p>
<p>For <code><em>sampleRate</em></code>, specify the sampling rate set for the instance is added by the <code><a class="el" href="namespacenn_1_1audio.html#a0bab4b3f6c0c1c7aa0011d2ee4b33919" title="Adds a LightLimiterType object to FinalMixType.">nn::audio::AddLightLimiter()</a></code> function. Use the <code><a class="el" href="namespacenn_1_1audio.html#a331b58a86c70fe45bf649941db3ca55e" title="Gets the sample rate of the SubMixType object.">nn::audio::GetSubMixSampleRate()</a></code> function to get the sampling rate for <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, and use the <code><a class="el" href="namespacenn_1_1audio.html#a25ee6f076a7eb80a0fc937c42d41e652" title="Gets the sampling rate of the audio renderer processing.">nn::audio::GetAudioRendererSampleRate()</a></code> function to get the sampling rate for <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>.</p>
<p>For <code><em>channelCountMax</em></code>, specify the number of channels supported by <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a142">AudioEffect/AudioEffect.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a0bab4b3f6c0c1c7aa0011d2ee4b33919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bab4b3f6c0c1c7aa0011d2ee4b33919">&#9670;&nbsp;</a></span>AddLightLimiter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::AddLightLimiter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pFinalMix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td>
          <td class="paramname"><em>lookAheadTimeMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelCountMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#abcc7c4eb06afe0673e8196edc23dd9f0" title="Initializes FinalMixType and adds it to the AudioRendererConfig.">nn::audio::AcquireFinalMix()</a></code> initializes <code><em>pFinalMix</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pEffect</td><td>An uninitialized <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the memory to use for <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size of memory specified by <code><em>buffer</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFinalMix</td><td>The <code>FinalMix</code> to which the effect is being added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lookAheadTimeMax</td><td>The maximum value that can be set for the look-ahead time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCountMax</td><td>Value for the maximum number of channels that can be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html">nn::audio::ResultOutOfResource</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is uninitialized.</li>
<li><code><em>buffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>buffer</em></code> is aligned to <code><a class="el" href="namespacenn_1_1audio.html#a61833f2e2cf0253e3054188e900315af" title="The alignment size for audio buffers.">nn::audio::BufferAlignSize</a></code>.</li>
<li><code><em>bufferSize</em></code> &gt;= <a class="el" href="namespacenn_1_1audio.html#a599944de2f532061310662a48f6379ac">nn::audio::GetRequiredBufferSizeForLightLimiter(lookAheadTimeMax, sampleRate, channelCountMax)</a>. (<code><em>sampleRate</em></code> is the sample rate set in <code><em>pFinalMix</em></code>. You can get it using <code><a class="el" href="namespacenn_1_1audio.html#a25ee6f076a7eb80a0fc937c42d41e652" title="Gets the sampling rate of the audio renderer processing.">nn::audio::GetAudioRendererSampleRate()</a></code>.)</li>
<li><code><em>pFinalMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pFinalMix</em></code> is initialized.</li>
<li><a class="el" href="classnn_1_1_time_span.html#acce769d0612ece9d5f87d32150d1f706">nn::TimeSpan::FromMicroSeconds(0)</a> &lt;= <code><em>lookAheadTimeMax</em></code> &amp;&amp; <code><em>lookAheadTimeMax</em></code> &lt; <a class="el" href="classnn_1_1_time_span.html#acce769d0612ece9d5f87d32150d1f706">nn::TimeSpan::FromMicroSeconds(std::numeric_limits&lt;int32_t&gt;::max())</a>.</li>
<li>(<code><em>channelCountMax</em></code> == <code>1</code>) || (<code><em>channelCountMax</em></code> == <code>2</code>) || (<code><em>channelCountMax</em></code> == <code>4</code> ) || (<code><em>channelCountMax</em></code> == <code>6</code>). </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pEffect</em></code> is initialized.</li>
<li><code><em>pEffect</em></code> is enabled.</li>
<li>The input/output buffers for <code><em>pEffect</em></code> are not set.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Adds a <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> effect that performs a light limiter process to <code><em>pFinalMix</em></code>, and initializes <code><em>pEffect</em></code>. Calling this function links <code><em>pEffect</em></code> with <code><em>pFinalMix</em></code> and makes it possible to perform effect operations on the mix buffers managed by <code><em>pFinalMix</em></code>. Subsequent operations on <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> are performed through <code><em>pEffect</em></code>. For a list of functions that perform operations on <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>, see the description of <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>.</p>
<p><code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> requires a work buffer for the effect processing. Allocate a buffer that is at least as large as the value returned by the <code><a class="el" href="namespacenn_1_1audio.html#a599944de2f532061310662a48f6379ac" title="Gets the work buffer size required for the renderer to use LightLimiterType.">nn::audio::GetRequiredBufferSizeForLightLimiter()</a></code> function, and pass that to <code><em>buffer</em></code> and <code><em>bufferSize</em></code>. The memory region specified for <code><em>buffer</em></code> must be contained within the memory region specified for <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html" title="Structure for representing memory regions used by an audio renderer.">nn::audio::MemoryPoolType</a></code>. Also, the instance of <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html" title="Structure for representing memory regions used by an audio renderer.">nn::audio::MemoryPoolType</a></code> that contains the memory region specified for <code><em>buffer</em></code> must be in the attached state.</p>
<p>Only one instance of each type of effect can be added to a single <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. A single instance of an effect cannot be added to multiple instances of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. The following warning message is displayed if an initialized effect that has already been added to an instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> is added to the same instance or another instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> again. </p><div class="fragment"><div class="line">[<a class="code" href="namespacenn_1_1audio.html">nn::audio</a>] Warning: The passed effect is already initialized. Please confirm <span class="keywordflow">if</span> (address <span class="keywordflow">for</span> effect instance) is a valid effect <span class="keywordtype">object</span>.</div>
</div><!-- fragment --><p> ("address for effect instance" is the address of the instance of the effect that you attempted to add.) For <code><em>lookAheadTimeMax</em></code>, specify the maximum look-ahead time that can be set while <code><em>pEffect</em></code> is being used. After the addition, you can use the <code><a class="el" href="namespacenn_1_1audio.html#a11eddcef27393df3870156d106677dfc" title="Sets the look-ahead time of LightLimiterType.">nn::audio::SetLightLimiterLookAheadTime()</a></code> function at any time to change the look-ahead time, providing the time is no greater than <code><em>lookAheadTimeMax</em></code>. However, after changing the delay time setting, you must call the <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> to notify the audio renderer of the change.</p>
<p>For <code><em>channelCountMax</em></code>, specify the number of channels supported by <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>. The number of channels specified here corresponds to the maximum value that can be specified for the <code><em>count</em></code> parameter of the <code><a class="el" href="namespacenn_1_1audio.html#a338f3d39f10cfd43d3a718d1636c1478" title="Sets the LightLimiterType input/output mix buffer indexes.">nn::audio::SetLightLimiterInputOutput()</a></code> function. For more information, see the description of <code><a class="el" href="namespacenn_1_1audio.html#a338f3d39f10cfd43d3a718d1636c1478" title="Sets the LightLimiterType input/output mix buffer indexes.">nn::audio::SetLightLimiterInputOutput()</a></code>.</p>
<p>Immediately after the addition, <code><em>pEffect</em></code> is not connected to the input/output mix buffers and is enabled. Use the <code><a class="el" href="namespacenn_1_1audio.html#a338f3d39f10cfd43d3a718d1636c1478" title="Sets the LightLimiterType input/output mix buffer indexes.">nn::audio::SetLightLimiterInputOutput()</a></code> function to set the indexes of the input/output mix buffers.</p>
<p>If the process for adding the effect fails and the function returns <code><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html" title="A class that represents error Result values (audio: Insufficient resources.).">nn::audio::ResultOutOfResource</a></code>, this usually indicates that the number of effects currently being used exceeds the maximum number of effects specified for <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html" title="The audio renderer parameters.">nn::audio::AudioRendererParameter</a>.<em>effectCount</em></code>. Delete one of the other effects or increase the number specified for <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html" title="The audio renderer parameters.">nn::audio::AudioRendererParameter</a>.<em>effectCount</em></code>.</p>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad771f7516d8c6eea51938171d9389af7" title="Adds a BiquadFilterType object to FinalMixType.">nn::audio::AddBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a2163e3d699edc8244383a94ed760f0be" title="Removes a BiquadFilterType object from FinalMixType.">nn::audio::RemoveBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a7bd3cc176b82c7cd5659c364ab97ab08" title="Adds BufferMixer to FinalMixType.">nn::audio::AddBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a400aff980a26fd295d911adbffd5f8ae" title="Removes BufferMixer from FinalMixType.">nn::audio::RemoveBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad332d3b8805f5157ef98572a99a9f2a0" title="Adds a DelayType object to FinalMixType.">nn::audio::AddDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a47262039889d9d23aeac0d82ed318ac0" title="Removes a DelayType object from FinalMixType.">nn::audio::RemoveDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aa081b9cab7e4ca8d079093c1fc50bb4d" title="Adds a ReverbType object to FinalMixType.">nn::audio::AddReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a8dda67780e46472ca22360376e6eb831" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a88bff95c7242f9d37ae5f631e825648b" title="Adds a I3dl2ReverbType object to FinalMixType.">nn::audio::AddI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a32e1724b072fff4284c19e597ac94d84" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a086c8ae883a8dabacad2c3ff3e995f13" title="Adds an AuxType object to FinalMixType.">nn::audio::AddAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a5133a62d6f97d3054e9ad428ae866102" title="Removes an AuxType object from FinalMixType.">nn::audio::RemoveAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a0bab4b3f6c0c1c7aa0011d2ee4b33919" title="Adds a LightLimiterType object to FinalMixType.">nn::audio::AddLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aacc63377e4f4f87617ff50fc981b170d" title="Removes a LightLimiterType object from FinalMixType.">nn::audio::RemoveLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ab3024a56e39831c3ba5fc8e52bca1a7e" title="Adds a CaptureType object to FinalMixType.">nn::audio::AddCapture()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a3fd8807d5efcb1fae477f690c8a8b48d" title="Removes the CaptureType object from FinalMixType.">nn::audio::RemoveCapture()</a></code></li>
</ul>
<p>Also, do not perform any operations on <code><em>pFinalMix</em></code> while calling any of these functions. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a143">AudioEffect/AudioEffect.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a9893b88646627d0cf1e0a82288135c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9893b88646627d0cf1e0a82288135c6d">&#9670;&nbsp;</a></span>AddLightLimiter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::AddLightLimiter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pSubMix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td>
          <td class="paramname"><em>lookAheadTimeMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelCountMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#a24020da05700a26ee46f04f5762c157f" title="Initializes a SubMixType object and adds it to AudioRendererConfig.">nn::audio::AcquireSubMix()</a></code> initializes <code><em>pSubMix</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pEffect</td><td>An uninitialized <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the memory to use for <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size of memory specified by <code><em>buffer</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSubMix</td><td>The <code>SubMix</code> to which the effect is being added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lookAheadTimeMax</td><td>The maximum value that can be set for the look-ahead time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCountMax</td><td>Value for the maximum number of channels that can be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html">nn::audio::ResultOutOfResource</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is uninitialized.</li>
<li><code><em>buffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>buffer</em></code> is aligned to <code><a class="el" href="namespacenn_1_1audio.html#a61833f2e2cf0253e3054188e900315af" title="The alignment size for audio buffers.">nn::audio::BufferAlignSize</a></code>.</li>
<li><code><em>bufferSize</em></code> &gt;= <a class="el" href="namespacenn_1_1audio.html#a599944de2f532061310662a48f6379ac">nn::audio::GetRequiredBufferSizeForLightLimiter(lookAheadTimeMax, sampleRate, channelCountMax)</a>. (<code><em>sampleRate</em></code> is the sample rate specified for <code><em>pSubMix</em></code>. You can get it using <code><a class="el" href="namespacenn_1_1audio.html#a25ee6f076a7eb80a0fc937c42d41e652" title="Gets the sampling rate of the audio renderer processing.">nn::audio::GetAudioRendererSampleRate()</a></code>.)</li>
<li><code><em>pSubMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSubMix</em></code> is initialized.</li>
<li><a class="el" href="classnn_1_1_time_span.html#acce769d0612ece9d5f87d32150d1f706">nn::TimeSpan::FromMicroSeconds(0)</a> &lt;= <code><em>lookAheadTimeMax</em></code> &amp;&amp; <code><em>lookAheadTimeMax</em></code> &lt; <a class="el" href="classnn_1_1_time_span.html#acce769d0612ece9d5f87d32150d1f706">nn::TimeSpan::FromMicroSeconds(std::numeric_limits&lt;int32_t&gt;::max())</a>.</li>
<li>(<code><em>channelCountMax</em></code> == <code>1</code>) || (<code><em>channelCountMax</em></code> == <code>2</code>) || (<code><em>channelCountMax</em></code> == <code>4</code> ) || (<code><em>channelCountMax</em></code> == <code>6</code>). </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pEffect</em></code> is initialized.</li>
<li><code><em>pEffect</em></code> is enabled.</li>
<li>The input/output buffers for <code><em>pEffect</em></code> are not set.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function operates on <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, but otherwise it works the same as <code><a class="el" href="namespacenn_1_1audio.html#a0bab4b3f6c0c1c7aa0011d2ee4b33919" title="Adds a LightLimiterType object to FinalMixType.">nn::audio::AddLightLimiter</a>(AudioRendererConfig* <em>pOutConfig</em>, LightLimiterType* <em>pEffect</em>, void* <em>buffer</em>, size_t <em>bufferSize</em>, FinalMixType* <em>pFinalMix</em>, <a class="el" href="classnn_1_1_time_span.html" title="This class represents a length of time.">nn::TimeSpan</a> <em>lookAheadTimeMax</em>, int <em>channelCountMax</em></code>. </p>

</div>
</div>
<a id="aacc63377e4f4f87617ff50fc981b170d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc63377e4f4f87617ff50fc981b170d">&#9670;&nbsp;</a></span>RemoveLightLimiter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::audio::RemoveLightLimiter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pFinalMix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> object from <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#abcc7c4eb06afe0673e8196edc23dd9f0" title="Initializes FinalMixType and adds it to the AudioRendererConfig.">nn::audio::AcquireFinalMix()</a></code> initializes <code><em>pFinalMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> object added to <code><em>pFinalMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFinalMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> to remove <code><em>pEffect</em></code> from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the memory used for <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> (the memory passed to <code><em>buffer</em></code> when initialized by <code><a class="el" href="namespacenn_1_1audio.html#a0bab4b3f6c0c1c7aa0011d2ee4b33919" title="Adds a LightLimiterType object to FinalMixType.">nn::audio::AddLightLimiter()</a></code>). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a203121e3dda68edafcc270e0e927870f">nn::audio::IsLightLimiterRemovable</a></code> "nn::audio::IsLightLimiterRemovable(pEffect)" == <code>true</code>.</li>
<li><code><em>pFinalMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pFinalMix</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pEffect</em></code> is uninitialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 An effect can only be removed if the audio renderer has completely stopped using that effect. Before you use this function to remove <code><em>pEffect</em></code>, call <code><a class="el" href="namespacenn_1_1audio.html#a7455f013400526a539368885b542736a" title="Sets whether LightLimiterType is enabled or disabled.">nn::audio::SetLightLimiterEnabled()</a></code> to disable <code><em>pEffect</em></code> and call <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> to notify the audio renderer that it has been disabled. After calling the <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> function, use the <code><a class="el" href="namespacenn_1_1audio.html#a203121e3dda68edafcc270e0e927870f" title="Determines whether the LightLimiterType object can be safely removed.">nn::audio::IsLightLimiterRemovable()</a></code> function to determine whether the audio renderer has completely stopped using the effect and the effect can be safely removed. After calling the <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> function, it may take up to two audio frames for the audio renderer to completely stop using the effect.</p>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad771f7516d8c6eea51938171d9389af7" title="Adds a BiquadFilterType object to FinalMixType.">nn::audio::AddBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a2163e3d699edc8244383a94ed760f0be" title="Removes a BiquadFilterType object from FinalMixType.">nn::audio::RemoveBiquadFilter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a7bd3cc176b82c7cd5659c364ab97ab08" title="Adds BufferMixer to FinalMixType.">nn::audio::AddBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a400aff980a26fd295d911adbffd5f8ae" title="Removes BufferMixer from FinalMixType.">nn::audio::RemoveBufferMixer()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ad332d3b8805f5157ef98572a99a9f2a0" title="Adds a DelayType object to FinalMixType.">nn::audio::AddDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a47262039889d9d23aeac0d82ed318ac0" title="Removes a DelayType object from FinalMixType.">nn::audio::RemoveDelay()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aa081b9cab7e4ca8d079093c1fc50bb4d" title="Adds a ReverbType object to FinalMixType.">nn::audio::AddReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a8dda67780e46472ca22360376e6eb831" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveReverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a88bff95c7242f9d37ae5f631e825648b" title="Adds a I3dl2ReverbType object to FinalMixType.">nn::audio::AddI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a32e1724b072fff4284c19e597ac94d84" title="Removes a ReverbType object from FinalMix.">nn::audio::RemoveI3dl2Reverb()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a086c8ae883a8dabacad2c3ff3e995f13" title="Adds an AuxType object to FinalMixType.">nn::audio::AddAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a5133a62d6f97d3054e9ad428ae866102" title="Removes an AuxType object from FinalMixType.">nn::audio::RemoveAux()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a0bab4b3f6c0c1c7aa0011d2ee4b33919" title="Adds a LightLimiterType object to FinalMixType.">nn::audio::AddLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#aacc63377e4f4f87617ff50fc981b170d" title="Removes a LightLimiterType object from FinalMixType.">nn::audio::RemoveLightLimiter()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ab3024a56e39831c3ba5fc8e52bca1a7e" title="Adds a CaptureType object to FinalMixType.">nn::audio::AddCapture()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a3fd8807d5efcb1fae477f690c8a8b48d" title="Removes the CaptureType object from FinalMixType.">nn::audio::RemoveCapture()</a></code></li>
</ul>
<p>Also, do not perform any operations on <code><em>pFinalMix</em></code> while calling any of these functions. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="abd177fde39dad044d611c844ac326001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd177fde39dad044d611c844ac326001">&#9670;&nbsp;</a></span>RemoveLightLimiter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::audio::RemoveLightLimiter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pSubMix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> object from <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#a24020da05700a26ee46f04f5762c157f" title="Initializes a SubMixType object and adds it to AudioRendererConfig.">nn::audio::AcquireSubMix()</a></code> initializes <code><em>pSubMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> object added to <code><em>pSubMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSubMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> to remove <code><em>pEffect</em></code> from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the memory used for <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> (the memory passed to <code><em>buffer</em></code> when initialized by <code><a class="el" href="namespacenn_1_1audio.html#a0bab4b3f6c0c1c7aa0011d2ee4b33919" title="Adds a LightLimiterType object to FinalMixType.">nn::audio::AddLightLimiter()</a></code>). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a203121e3dda68edafcc270e0e927870f">nn::audio::IsLightLimiterRemovable</a></code> "nn::audio::IsLightLimiterRemovable(pEffect)" == <code>true</code>.</li>
<li><code><em>pSubMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSubMix</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pEffect</em></code> is uninitialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function operates on <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, but otherwise it works the same as <code>RemoveLightLimiter(AudioRendererConfig* <em>pOutConfig</em>, LightLimiterType* <em>pEffect</em>, FinalMixType* <em>pFinalMix</em>)</code>. </p>

</div>
</div>
<a id="a6e6860df74686ab481b40bb8420f118e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6860df74686ab481b40bb8420f118e">&#9670;&nbsp;</a></span>GetLightLimiterInputOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::GetLightLimiterInputOutput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>outInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>outOutput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the indexes of the <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> input/output mix buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outInput</td><td>The array from which to get the indexes of the input mix buffers set in <code><em>pEffect</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outOutput</td><td>The array from which to get the indexes of the output mix buffers set in <code><em>pEffect</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutCount</td><td>The number of mix buffer indexes obtained in <code><em>outInput</em></code> and <code><em>outOutput</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Length of the <code><em>outInput</em></code> and <code><em>outOutput</em></code> arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
<li><code><em>outInput</em></code> != <code>nullptr</code>.</li>
<li><code><em>outOutput</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutCount</em></code> != <code>nullptr</code>.</li>
<li><code><em>count</em></code> &gt; <code>0</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>Information for the number of indexes specified in <code><em>pOutCount</em></code> is written to <code><em>outInput</em></code> and <code><em>outOutput</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the input/output relationship of effect processing by <code><em><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></em></code>. The indices of the source input mix buffers are stored in <code><em>outInput</em></code>, and the indices of the output mix buffers are stored in <code><em>outOutput</em></code>. <code><em>outInput</em></code> and <code><em>outOutput</em></code> can store up to <code><em>count</em></code> indices. The actual number of mix buffer indexes that are stored in <code><em>outInput</em></code> and <code><em>outOutput</em></code> is returned to <code><em>pOutCount</em></code>.</p>
<p>This function gets the input/output relationship specified by the <code><a class="el" href="namespacenn_1_1audio.html#a338f3d39f10cfd43d3a718d1636c1478" title="Sets the LightLimiterType input/output mix buffer indexes.">nn::audio::SetLightLimiterInputOutput()</a></code> function. If this function is called on an instance of <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> in the initial state where <code><a class="el" href="namespacenn_1_1audio.html#a338f3d39f10cfd43d3a718d1636c1478" title="Sets the LightLimiterType input/output mix buffer indexes.">nn::audio::SetLightLimiterInputOutput()</a></code> has never been called, nothing is stored in <code><em>outInput</em></code> and <code><em>outOutput</em></code>, and a value of <code><em>0</em></code> is returned to <code><em>pOutCount</em></code>. Also see the description of the <code><a class="el" href="namespacenn_1_1audio.html#a0bab4b3f6c0c1c7aa0011d2ee4b33919" title="Adds a LightLimiterType object to FinalMixType.">nn::audio::AddLightLimiter()</a></code> function. If the number of channels set for <code><em>pEffect</em></code> is greater than the value specified for <code><em>count</em></code>, <code><em>outInput</em></code> and <code><em>outOutput</em></code> store only <code><em>count</em></code> number of indexes.</p>
<p>For more information about the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> and <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> mix buffers, see Mix Buffers in the <a href="../../Package/contents/Pages/Page_89991492.html">Audio Renderer</a> documentation.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. </p>

</div>
</div>
<a id="a338f3d39f10cfd43d3a718d1636c1478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a338f3d39f10cfd43d3a718d1636c1478">&#9670;&nbsp;</a></span>SetLightLimiterInputOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetLightLimiterInputOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> input/output mix buffer indexes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The array of indexes of input mix buffers to set in <code><em>pEffect</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>The array of indexes of output mix buffers to set in <code><em>pEffect</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of mix buffer indexes stored in <code><em>input</em></code> and <code><em>output</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
<li><code><em>input</em></code> != <code>nullptr</code>.</li>
<li><code><em>output</em></code> != <code>nullptr</code>.</li>
<li><code><em>count</em></code> &lt;= <code><a class="el" href="namespacenn_1_1audio.html#a434871fe5c19c0c8ef28f728227f57d1">nn::audio::GetLightLimiterChannelCountMax</a></code> "nn::audio::GetLightLimiterChannelCountMax(pEffect)".</li>
<li>(<code><em>count</em></code> == <code>1</code>) || (<code><em>count</em></code> == <code>2</code>) || (<code><em>count</em></code> == <code>4</code>) || (<code><em>count</em></code> == <code>6</code>).</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sets the input/output relationship for effect processing by <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>. The mix buffers corresponding to the indices specified for the <code><em>input</em></code> array are set as the input mix buffers, and the mix buffers corresponding to the indices specified for the <code><em>output</em></code> array are set as the output mix buffers. The same mix buffer indices can be specified for both <code><em>input</em></code> and <code><em>output</em></code>.</p>
<p>There are common rules for setting the input/output buffer relationship for each type of effect. For more information, see <code><a class="el" href="namespacenn_1_1audio.html#a70ca2b0217074d7daf6534da7db1de0b" title="Sets the input/output relationship of the mixing process performed by BufferMixer.">nn::audio::SetBufferMixerInputOutput()</a></code>.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a105">AudioEffect/AudioEffect.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af2d53007cb799a8edce033c9ff51fb43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d53007cb799a8edce033c9ff51fb43">&#9670;&nbsp;</a></span>IsLightLimiterEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::IsLightLimiterEnabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if enabled, or <code>false</code> otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. </p>

</div>
</div>
<a id="a7455f013400526a539368885b542736a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7455f013400526a539368885b542736a">&#9670;&nbsp;</a></span>SetLightLimiterEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetLightLimiterEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> is enabled or disabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td><code>true</code> to enable, or <code>false</code> to disable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#af2d53007cb799a8edce033c9ff51fb43">nn::audio::IsLightLimiterEnabled</a></code> "nn::audio::IsLightLimiterEnabled(pEffect)" == <code><em>enable</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 When enabled, the effect processing is performed on the contents of the input mix buffers and written to the output mix buffers according to the input/output relationship specified by the <code><a class="el" href="namespacenn_1_1audio.html#a338f3d39f10cfd43d3a718d1636c1478" title="Sets the LightLimiterType input/output mix buffer indexes.">nn::audio::SetLightLimiterInputOutput()</a></code> function. When the effect is disabled, the contents of the input mix buffers are output as is to the output mix buffers without applying the effect.</p>
<p>Other parameters retain their values after the <code><a class="el" href="namespacenn_1_1audio.html#a7455f013400526a539368885b542736a" title="Sets whether LightLimiterType is enabled or disabled.">SetLightLimiterEnabled()</a></code> function is called, but the internal state of <code><em>pEffect</em></code> is cleared if <code>true</code> has been specified for the <code><em>enable</em></code> parameter.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a92">AudioEffect/AudioEffect.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a203121e3dda68edafcc270e0e927870f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a203121e3dda68edafcc270e0e927870f">&#9670;&nbsp;</a></span>IsLightLimiterRemovable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::IsLightLimiterRemovable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> object can be safely removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if possible. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 An effect can only be removed if the audio renderer has completely stopped using that effect. Before calling the <code><a class="el" href="namespacenn_1_1audio.html#aacc63377e4f4f87617ff50fc981b170d" title="Removes a LightLimiterType object from FinalMixType.">nn::audio::RemoveLightLimiter()</a></code> function, use this function to check whether the instance of <code><em>pEffect</em></code> that you want to remove is no longer being used. Note the following.</p><ul>
<li>The use of an effect does not stop immediately after it has disabled by the <code><a class="el" href="namespacenn_1_1audio.html#a7455f013400526a539368885b542736a" title="Sets whether LightLimiterType is enabled or disabled.">nn::audio::SetLightLimiterEnabled()</a></code> function.</li>
<li>It can take up to two audio frames for the use of the effect to stop after the effect has been disabled by <code><a class="el" href="namespacenn_1_1audio.html#a7455f013400526a539368885b542736a" title="Sets whether LightLimiterType is enabled or disabled.">nn::audio::SetLightLimiterEnabled()</a></code> and the call to <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> has completed.</li>
<li>Do not call the <code><a class="el" href="namespacenn_1_1audio.html#aacc63377e4f4f87617ff50fc981b170d" title="Removes a LightLimiterType object from FinalMixType.">nn::audio::RemoveLightLimiter()</a></code> function during this time.</li>
</ul>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="a126e27bd6735b73018bd1ccc150b95cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a126e27bd6735b73018bd1ccc150b95cc">&#9670;&nbsp;</a></span>GetLightLimiterLookAheadTimeMax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> nn::audio::GetLightLimiterLookAheadTimeMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum look-ahead time that can be set for <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the maximum look-ahead time that can be set. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. </p>

</div>
</div>
<a id="a434871fe5c19c0c8ef28f728227f57d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434871fe5c19c0c8ef28f728227f57d1">&#9670;&nbsp;</a></span>GetLightLimiterChannelCountMax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetLightLimiterChannelCountMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum number of channels that can be set for <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the maximum value for the number of channels that can be set. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a54">AudioEffect/AudioEffect.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a15613bf34c399efa929410a39ff3657a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15613bf34c399efa929410a39ff3657a">&#9670;&nbsp;</a></span>GetLightLimiterAttackTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> nn::audio::GetLightLimiterAttackTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the attack time of <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the attack time. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. </p>

</div>
</div>
<a id="ae19685a79679c2764b27059e0bba9f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae19685a79679c2764b27059e0bba9f61">&#9670;&nbsp;</a></span>SetLightLimiterAttackTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetLightLimiterAttackTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the attack time of <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Attack time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
<li><code><a class="el" href="classnn_1_1_time_span.html#acce769d0612ece9d5f87d32150d1f706">nn::TimeSpan::FromMicroSeconds</a></code> "nn::TimeSpan::FromMicroSeconds(0)" &lt;= <code><em>value</em></code> &amp;&amp; <code><em>value</em></code> &lt; <code><a class="el" href="classnn_1_1_time_span.html#acce769d0612ece9d5f87d32150d1f706">nn::TimeSpan::FromMicroSeconds</a></code> "nn::TimeSpan::FromMicroSeconds(std::numeric_limits&lt;int32_t&gt;::max())". </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a15613bf34c399efa929410a39ff3657a">nn::audio::GetLightLimiterAttackTime</a></code> "nn::audio::GetLightLimiterAttackTime(pEffect)" == <code><em>value</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a93">AudioEffect/AudioEffect.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af09c40a2760271e61692ebe320a69b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af09c40a2760271e61692ebe320a69b20">&#9670;&nbsp;</a></span>GetLightLimiterReleaseTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> nn::audio::GetLightLimiterReleaseTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the release time of <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the release time. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. </p>

</div>
</div>
<a id="a98da6468118408e6f03a2e2c0eae0b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98da6468118408e6f03a2e2c0eae0b88">&#9670;&nbsp;</a></span>SetLightLimiterReleaseTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetLightLimiterReleaseTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the release time of <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Release time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
<li><code><a class="el" href="classnn_1_1_time_span.html#acce769d0612ece9d5f87d32150d1f706">nn::TimeSpan::FromMicroSeconds</a></code> "nn::TimeSpan::FromMicroSeconds(0)" &lt;= <code><em>value</em></code> &amp;&amp; <code><em>value</em></code> &lt; <code><a class="el" href="classnn_1_1_time_span.html#acce769d0612ece9d5f87d32150d1f706">nn::TimeSpan::FromMicroSeconds</a></code> "nn::TimeSpan::FromMicroSeconds(std::numeric_limits&lt;int32_t&gt;::max())". </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#af09c40a2760271e61692ebe320a69b20">nn::audio::GetLightLimiterReleaseTime</a></code> "nn::audio::GetLightLimiterReleaseTime(pEffect)" == <code><em>value</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a94">AudioEffect/AudioEffect.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="afee0394e913f76e1a7b3b57f3da3e214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee0394e913f76e1a7b3b57f3da3e214">&#9670;&nbsp;</a></span>GetLightLimiterLookAheadTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> nn::audio::GetLightLimiterLookAheadTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the look-ahead time of <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the look-ahead time. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. </p>

</div>
</div>
<a id="a11eddcef27393df3870156d106677dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11eddcef27393df3870156d106677dfc">&#9670;&nbsp;</a></span>SetLightLimiterLookAheadTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetLightLimiterLookAheadTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the look-ahead time of <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The look-ahead time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
<li><code><a class="el" href="classnn_1_1_time_span.html#acce769d0612ece9d5f87d32150d1f706">nn::TimeSpan::FromMicroSeconds</a></code> "nn::TimeSpan::FromMicroSeconds(0)" &lt;= <code><em>value</em></code> &amp;&amp; <code><em>value</em></code> &lt;= <code><a class="el" href="namespacenn_1_1audio.html#a126e27bd6735b73018bd1ccc150b95cc">GetLightLimiterLookAheadTimeMax</a></code> "nn::audio::GetLightLimiterLookAheadTimeMax(pEffect)". </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#afee0394e913f76e1a7b3b57f3da3e214">nn::audio::GetLightLimiterLookAheadTime</a></code> "nn::audio::GetLightLimiterLookAheadTime(pEffect)" == <code><em>value</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a95">AudioEffect/AudioEffect.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aa95eb6cd6822e4ef2183dd8bbc9b4d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa95eb6cd6822e4ef2183dd8bbc9b4d60">&#9670;&nbsp;</a></span>GetLightLimiterThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetLightLimiterThreshold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the threshold of <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the threshold. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 For the threshold, <code>1.0f</code> is treated as the full range. This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. </p>

</div>
</div>
<a id="a452de0ded15b4bc2cb43d6d621d26e01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452de0ded15b4bc2cb43d6d621d26e01">&#9670;&nbsp;</a></span>SetLightLimiterThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetLightLimiterThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the threshold of <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The threshold. (<code>1.0f</code> is treated as the full range.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
<li><code>0.0f</code> &lt;= <code><em>value</em></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#aa95eb6cd6822e4ef2183dd8bbc9b4d60">nn::audio::GetLightLimiterThreshold</a></code> "nn::audio::GetLightLimiterThreshold(pEffect)" == <code><em>value</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 For the threshold, <code>1.0f</code> is treated as the full range. This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a96">AudioEffect/AudioEffect.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a538876817582613f83a62ba77aff1719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538876817582613f83a62ba77aff1719">&#9670;&nbsp;</a></span>GetLightLimiterInputGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetLightLimiterInputGain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the input gain of <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the input gain. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. </p>

</div>
</div>
<a id="ab6296f26432d6bc4a46217957edb05a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6296f26432d6bc4a46217957edb05a1">&#9670;&nbsp;</a></span>SetLightLimiterInputGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetLightLimiterInputGain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the input gain of <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The input gain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
<li><code>0.0f</code> &lt;= <code><em>value</em></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><a class="el" href="namespacenn_1_1audio.html#a538876817582613f83a62ba77aff1719">nn::audio::GetLightLimiterInputGain(pEffect)</a> == <code><em>value</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a97">AudioEffect/AudioEffect.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a949f7ef952babb00c818be68f05a7f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949f7ef952babb00c818be68f05a7f37">&#9670;&nbsp;</a></span>GetLightLimiterOutputGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetLightLimiterOutputGain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the output gain of <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the output gain. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. </p>

</div>
</div>
<a id="a01be37deed50b246eb649dfcdd2a9ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01be37deed50b246eb649dfcdd2a9ec5">&#9670;&nbsp;</a></span>SetLightLimiterOutputGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetLightLimiterOutputGain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the output gain of <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Output gain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
<li><code>0.0f</code> &lt;= <code><em>value</em></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><a class="el" href="namespacenn_1_1audio.html#a949f7ef952babb00c818be68f05a7f37">nn::audio::GetLightLimiterOutputGain(pEffect)</a> == <code><em>value</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a98">AudioEffect/AudioEffect.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a7a6abcf1e9b73a69f16a5e20627650ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a6abcf1e9b73a69f16a5e20627650ff">&#9670;&nbsp;</a></span>GetLightLimiterParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1audio_1_1_light_limiter_parameter_set.html">LightLimiterParameterSet</a> nn::audio::GetLightLimiterParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> effect parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the effect parameters. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. </p>

</div>
</div>
<a id="afefcb2450e84e8adcb5a89a61a4e994b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afefcb2450e84e8adcb5a89a61a4e994b">&#9670;&nbsp;</a></span>SetLightLimiterParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetLightLimiterParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_light_limiter_parameter_set.html">LightLimiterParameterSet</a> *&#160;</td>
          <td class="paramname"><em>pParameterSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> effect parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pParameterSet</td><td>The effect parameters to set for <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
<li><code><em>pParameterSet</em></code> != <code>nullptr</code>.</li>
<li><a class="el" href="classnn_1_1_time_span.html#acce769d0612ece9d5f87d32150d1f706">nn::TimeSpan::FromMicroSeconds(0)</a> &lt;= <code><em>pParameterSet</em>-&gt;attackTime</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;attackTime</code> &lt; <a class="el" href="classnn_1_1_time_span.html#acce769d0612ece9d5f87d32150d1f706">nn::TimeSpan::FromMicroSeconds(std::numeric_limits&lt;int32_t&gt;::max())</a>.</li>
<li><a class="el" href="classnn_1_1_time_span.html#acce769d0612ece9d5f87d32150d1f706">nn::TimeSpan::FromMicroSeconds(0)</a> &lt;= <code><em>pParameterSet</em>-&gt;releaseTime</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;releaseTime</code> &lt; <a class="el" href="classnn_1_1_time_span.html#acce769d0612ece9d5f87d32150d1f706">nn::TimeSpan::FromMicroSeconds(std::numeric_limits&lt;int32_t&gt;::max())</a>.</li>
<li><code><a class="el" href="classnn_1_1_time_span.html#acce769d0612ece9d5f87d32150d1f706">nn::TimeSpan::FromMicroSeconds</a></code> "nn::TimeSpan::FromMicroSeconds(0)" &lt;= <code><em>pParameterSet</em>-&gt;lookAheadTime</code> &amp;&amp; <code><em>pParameterSet</em>-&gt;lookAheadTime</code> &lt;= <code><a class="el" href="namespacenn_1_1audio.html#a126e27bd6735b73018bd1ccc150b95cc">GetLightLimiterLookAheadTimeMax</a></code> "nn::audio::GetLightLimiterLookAheadTimeMax(pEffect)".</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;threshold</code>.</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;inputGain</code>.</li>
<li><code>0.0f</code> &lt;= <code><em>pParameterSet</em>-&gt;outputGain</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 For more information about the meanings of the LightLimiter parameters, see <a href="../../Package/contents/Pages/Page_93362777.html">Audio Effects</a>. This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="a7cb96b3d4bba546e8bf632b442584f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb96b3d4bba546e8bf632b442584f92">&#9670;&nbsp;</a></span>IsLightLimiterStatisticsEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::IsLightLimiterStatisticsEnabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> feature for getting statistics is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> feature for getting statistics is enabled or disabled. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The default return value is <code>false</code>. To enable the feature for getting statistics, call the <code><a class="el" href="namespacenn_1_1audio.html#a5c3451da9165fc5da2692df3c98baa91" title="Switches between enabling and disabling the LightLimiterType feature for getting statistics.">SetLightLimiterStatisticsEnabled()</a></code> function.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="a5c3451da9165fc5da2692df3c98baa91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c3451da9165fc5da2692df3c98baa91">&#9670;&nbsp;</a></span>SetLightLimiterStatisticsEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetLightLimiterStatisticsEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isEnabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Switches between enabling and disabling the <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> feature for getting statistics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isEnabled</td><td>Whether the <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> feature for getting statistics is enabled or disabled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The feature for getting statistics is disabled by default. If you want to get statistics, use this function to enable the feature. When the feature is enabled, the audio rendering processing load increases due to the calculating and writing of statistics.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a144">AudioEffect/AudioEffect.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a74ef8174c49997210bf030e78ef37df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ef8174c49997210bf030e78ef37df3">&#9670;&nbsp;</a></span>GetLightLimiterChannelStatistics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::GetLightLimiterChannelStatistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_light_limiter_channel_statistics.html">LightLimiterChannelStatistics</a> *&#160;</td>
          <td class="paramname"><em>pOutStatistics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets statistics for each channel resulting from the <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutStatistics</td><td>The statistics for the specified channel resulting from the <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> processing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>The index of the channel to get information about. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutStatistics</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
<li><code>0</code> &lt;= <code><em>channel</em></code> &lt; <a class="el" href="namespacenn_1_1audio.html#a434871fe5c19c0c8ef28f728227f57d1">nn::audio::GetLightLimiterChannelCountMax(pEffect)</a>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The starting point of the segment of statistics is either the point immediately after the initialization of the effect, or the point when the statistics were last reset. As a result, the statistics includes information about multiple audio frames. To reset the statistics, call the <code><a class="el" href="namespacenn_1_1audio.html#a161f679704285f187cdac5ccf29da45d" title="Resets the statistics resulting from the LightLimiterType processing.">ResetLightLimiterStatistics()</a></code> function.</p>
<p><code><a class="el" href="structnn_1_1audio_1_1_light_limiter_channel_statistics.html#ade51dd33ca84539a60b67fd117fb8182" title="The peak value of the input signal.">LightLimiterChannelStatistics::inputPeak</a></code> represents the peak value of the input signal. In other words, this is the value when amplitude of the input signal processed by <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> is at its maximum absolute value. The full range is treated as <code>1.0f</code>.</p>
<p><code><a class="el" href="structnn_1_1audio_1_1_light_limiter_channel_statistics.html#ade53a0ae4388b5aec4f2f7d4b34bac78" title="The minimum value for the gain control.">LightLimiterChannelStatistics::gainControlMin</a></code> is the minimum value of the ratio of the input signal amplitude to the output signal amplitude. Said another way, it is the ratio of the amplitudes of the input and output signals when the greatest limiting is applied to the signal by <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code>. If limiting is not applied to the signal, the value <code>1.0f</code> is returned. If limiting is applied to the signal, some positive value less than <code>1.0f</code> is returned.</p>
<p>If either <code><a class="el" href="namespacenn_1_1audio.html#af2d53007cb799a8edce033c9ff51fb43" title="Determines whether LightLimiterType is enabled.">IsLightLimiterEnabled()</a></code> or <code><a class="el" href="namespacenn_1_1audio.html#a7cb96b3d4bba546e8bf632b442584f92" title="Determines whether the LightLimiterType feature for getting statistics is enabled.">IsLightLimiterStatisticsEnabled()</a></code> is <code>false</code>, the statistics are not updated.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a55">AudioEffect/AudioEffect.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a161f679704285f187cdac5ccf29da45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a161f679704285f187cdac5ccf29da45d">&#9670;&nbsp;</a></span>ResetLightLimiterStatistics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::ResetLightLimiterStatistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html">LightLimiterType</a> *&#160;</td>
          <td class="paramname"><em>pEffect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the statistics resulting from the <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEffect</td><td>The initialized <code><a class="el" href="structnn_1_1audio_1_1_light_limiter_type.html" title="LightLimiter effect.">LightLimiterType</a></code> added to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pEffect</em></code> != <code>nullptr</code>.</li>
<li><code><em>pEffect</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Resets the value obtained with the <code><a class="el" href="namespacenn_1_1audio.html#a74ef8174c49997210bf030e78ef37df3" title="Gets statistics for each channel resulting from the LightLimiterType processing.">GetLightLimiterChannelStatistics()</a></code> function to the initial value. This function is not thread-safe. Do not perform any operations on <code><em>pEffect</em></code> during the call to this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a206">AudioEffect/AudioEffect.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="abcc7c4eb06afe0673e8196edc23dd9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc7c4eb06afe0673e8196edc23dd9f0">&#9670;&nbsp;</a></span>AcquireFinalMix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::AcquireFinalMix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pOutFinalMix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufferCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> and adds it to the <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when getting the audio renderer that will add <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutFinalMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferCount</td><td>The number of <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> buffers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> is available, or <code>false</code> otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li>The <code>AudioRenderer</code> associated with <code><em>pOutConfig</em></code> is stopped.</li>
<li><code><em>pOutFinalMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>bufferCount</em></code> &gt; <code>0</code> &amp;&amp; <code><em>bufferCount</em></code> &lt;= <code><a class="el" href="namespacenn_1_1audio.html#a2519dd3580c74c1abf2d1ae868304f39" title="The maximum number of mix buffers that can be created for a single instance of SubMix or FinalMix.">nn::audio::MixBufferCountMax</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> manages the remix buffer that stores the data that will become the final output from the audio renderer.</p>
<p>The total number of mix buffers that can be used by a single audio renderer is <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html#a38ecaacde5a6d9de76cad74d059d6974" title="The maximum number of mix buffers used by the audio renderer.">nn::audio::AudioRendererParameter.mixBufferCount</a></code>. This function gets <code><em>bufferCount</em></code> mix buffers of the <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html#a38ecaacde5a6d9de76cad74d059d6974" title="The maximum number of mix buffers used by the audio renderer.">nn::audio::AudioRendererParameter.mixBufferCount</a></code> total mix buffers and initializes them as management targets for <code><em>pOutFinalMix</em></code>. A single audio renderer never manages more than <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html#a38ecaacde5a6d9de76cad74d059d6974" title="The maximum number of mix buffers used by the audio renderer.">nn::audio::AudioRendererParameter.mixBufferCount</a></code> mix buffers. After specifying the required number of mix buffers for <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html#a38ecaacde5a6d9de76cad74d059d6974" title="The maximum number of mix buffers used by the audio renderer.">nn::audio::AudioRendererParameter.mixBufferCount</a></code>, assign them as needed to instances of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> and <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. For more information about mix buffers, see Audio Library in NintendoSDK Documents.</p>
<p>A single <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> can store up to <code><a class="el" href="namespacenn_1_1audio.html#a2519dd3580c74c1abf2d1ae868304f39" title="The maximum number of mix buffers that can be created for a single instance of SubMix or FinalMix.">nn::audio::MixBufferCountMax</a></code> mix buffers.</p>
<p>Only one <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> can be retrieved per <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code>.</p>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code>AcquireFinalMix(AudioRendererConfig* pOutConfig, FinalMixType* <em>pOutFinalMix</em>, int <em>bufferCount</em>)</code></li>
<li><code>ReleaseFinalMix(AudioRendererConfig* <em>pOutConfig</em>, FinalMixType* <em>pFinalMix</em>)</code></li>
<li><code>AcquireSubMix(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pOutSubMix</em>, int <em>sampleRate</em>, int <em>bufferCount</em>)</code></li>
<li><code>ReleaseSubMix(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pSubMix</em>)</code></li>
<li><code>SetSubMixDestination(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pSource</em>, FinalMixType* <em>pDestination</em>)</code></li>
<li><code>SetSubMixDestination(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pSource</em>, SubMixType* <em>pDestination</em>)</code></li>
</ul>
<p>Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a77">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a106">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a129">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a97">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a89">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a31">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a64">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a66">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a75">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a89">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a44">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a85">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#a39">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#a45">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a64">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a9c84c10d2ccb560293d74cc5be46e0dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c84c10d2ccb560293d74cc5be46e0dd">&#9670;&nbsp;</a></span>ReleaseFinalMix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::ReleaseFinalMix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pFinalMix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> object from <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#abcc7c4eb06afe0673e8196edc23dd9f0" title="Initializes FinalMixType and adds it to the AudioRendererConfig.">nn::audio::AcquireFinalMix()</a></code> initializes <code><em>pFinalMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFinalMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li>The <code>AudioRenderer</code> associated with <code><em>pOutConfig</em></code> is stopped.</li>
<li><code><em>pOutFinalMix</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code>AcquireFinalMix(AudioRendererConfig* pOutConfig, FinalMixType* <em>pOutFinalMix</em>, int <em>bufferCount</em>)</code></li>
<li><code>ReleaseFinalMix(AudioRendererConfig* <em>pOutConfig</em>, FinalMixType* <em>pFinalMix</em>)</code></li>
<li><code>AcquireSubMix(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pOutSubMix</em>, int <em>sampleRate</em>, int <em>bufferCount</em>)</code></li>
<li><code>ReleaseSubMix(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pSubMix</em>)</code></li>
<li><code>SetSubMixDestination(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pSource</em>, FinalMixType* <em>pDestination</em>)</code></li>
<li><code>SetSubMixDestination(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pSource</em>, SubMixType* <em>pDestination</em>)</code></li>
</ul>
<p>Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="a7652eae684b0d267e276cf7c01ac12d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7652eae684b0d267e276cf7c01ac12d7">&#9670;&nbsp;</a></span>GetFinalMixBufferCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetFinalMixBufferCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pFinalMix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pFinalMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of buffers. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pFinalMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pFinalMix</em></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab0124555bf745d4472ae4b2db1b9a044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0124555bf745d4472ae4b2db1b9a044">&#9670;&nbsp;</a></span>GetFinalMixVolume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetFinalMixVolume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pFinalMix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the volume of the <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pFinalMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the volume. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pFinalMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pFinalMix</em></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af6d0a1908dd4668211b26270705b9ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d0a1908dd4668211b26270705b9ba1">&#9670;&nbsp;</a></span>SetFinalMixVolume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetFinalMixVolume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pFinalMix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>volume</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the volume for the <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pFinalMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">volume</td><td>Volume. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pFinalMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pFinalMix</em></code> is initialized.</li>
<li><code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html#a6ef82d05668a1319369a43c26051b33d" title="The minimum value that can be set for volume (0.0f).">nn::audio::FinalMixType::GetVolumeMin()</a></code> &lt;= <code><em>volume</em></code> &amp;&amp; <code><em>volume</em></code> &lt;= <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html#a36954025b3af6f4aafed259daf7d9f78" title="The maximum value that can be set for volume (128.0f).">nn::audio::FinalMixType::GetVolumeMax()</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Immediately after initialization, the <code><em>volume</em></code> of the <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> is <code>1.0f</code>.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pFinalMix</em></code> while calling this function. </p><dl class="section note"><dt>Note</dt><dd>Audio cutoff may occur depending on the set volume value. If audio cutoff occurs, verify that the volume is within appropriate values.</dd></dl>
<p>Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="afbf070287eca8aa946ba57e8ae056092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf070287eca8aa946ba57e8ae056092">&#9670;&nbsp;</a></span>GetFinalMixNodeId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1audio.html#a347cdc16fef8e35aad9d8d0cd2e79e38">NodeId</a> nn::audio::GetFinalMixNodeId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pFinalMix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the ID of the <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> in the audio renderer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pFinalMix</td><td><code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>NodeId</code>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pFinalMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pFinalMix</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code>NodeId</code> is a numeric value that uniquely identifies the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_device_sink_type.html" title="Sink to output the rendering results to the audio output device.">DeviceSinkType</a></code>, and <code><a class="el" href="structnn_1_1audio_1_1_circular_buffer_sink_type.html" title="Sink to output the rendering results to memory.">CircularBufferSinkType</a></code> objects registered to the audio renderer. The various <code>NodeId</code> objects are never duplicated within a single audio renderer. A <code>NodeId</code> is assigned for each instance of each added <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_device_sink_type.html" title="Sink to output the rendering results to the audio output device.">DeviceSinkType</a></code>, and <code><a class="el" href="structnn_1_1audio_1_1_circular_buffer_sink_type.html" title="Sink to output the rendering results to memory.">CircularBufferSinkType</a></code>. </p>

</div>
</div>
<a id="a09b00eec5745f59f461c43723ed965f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b00eec5745f59f461c43723ed965f3">&#9670;&nbsp;</a></span>GetFinalMixSampleRate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetFinalMixSampleRate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pFinalMix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the sample rate of the <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pFinalMix</td><td><code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the sample rate. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pFinalMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pFinalMix</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> sample rate is determined when the audio renderer is initialized, and is specified using the <code>nn::audio::AudioRendererParemter.sampleRate</code> value. The sample rate obtained with this function must match this value specified during initialization. </p>

</div>
</div>
<a id="a8e7b32e31ba3ea6f61c00c752c3a90d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7b32e31ba3ea6f61c00c752c3a90d0">&#9670;&nbsp;</a></span>AcquireMemoryPool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::AcquireMemoryPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html">MemoryPoolType</a> *&#160;</td>
          <td class="paramname"><em>pOutPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a memory pool for an audio renderer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td><code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutPool</td><td>Memory pool. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address to the memory managed by the memory pool. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the memory managed by the memory pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the retrieval process succeeds. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pOutPool</em></code> != <code>nullptr</code>.</li>
<li><code><em>address</em></code> != Created internally when <code>nullptr</code> is specified..</li>
<li><code><em>address</em></code> is aligned to <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html#accc6577525e99670d0ff97f76a73068f" title="Alignment required for the buffer for MemoryPoolType.">MemoryPoolType::AddressAlignment</a></code>.</li>
<li><code><em>size</em></code> is aligned to <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html#a467d165cfdefac5aafe85cc003482ace" title="The size granularity required for the buffer for MemoryPoolType.">MemoryPoolType::SizeGranularity</a></code>.</li>
<li>The memory space passed by <code><em>address</em></code> and <code><em>size</em></code> does not include any regions used by other memory pools.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Resource data that is accessed directly by an audio renderer must be contained in the memory region specified for the memory pool. For the list of resource data that needs to be included in this memory pool, see <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html" title="Structure for representing memory regions used by an audio renderer.">nn::audio::MemoryPoolType</a></code>.</p>
<p>When the audio renderer accesses any of these types of memory, this function gets the memory pool and calls the <code><a class="el" href="namespacenn_1_1audio.html#a5f9484edc9f1bae6e41933993fbe09dc" title="Attaches a memory pool to an audio renderer.">nn::audio::RequestAttachMemoryPool()</a></code> to attach the memory pool to the audio renderer. Do not access the memory managed by a memory pool while that memory pool is in the attached state. However, you can use the <code><a class="el" href="namespacenn_1_1audio.html#a2fb36e3fd0639be1a1ff056d8d80dcc5" title="Reads or writes data to a memory region managed by a memory pool.">nn::audio::CopyMemoryPoolData()</a></code> function if you need to work on the data contained in a memory pool while it is still attached. For more information, see <code><a class="el" href="namespacenn_1_1audio.html#a2fb36e3fd0639be1a1ff056d8d80dcc5" title="Reads or writes data to a memory region managed by a memory pool.">nn::audio::CopyMemoryPoolData()</a></code>.</p>
<p>While using a memory pool, the memory region specified using the <code><em>address</em></code> and <code><em>size</em></code> parameters is never overwritten.</p>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a8e7b32e31ba3ea6f61c00c752c3a90d0">nn::audio::AcquireMemoryPool(AudioRendererConfig* pOutConfig, MemoryPoolType* pOutPool, void* address, size_t size)</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a2bf0ab532748ef3c8f6d127f1800ec1b">nn::audio::ReleaseMemoryPool(AudioRendererConfig* pOutConfig, MemoryPoolType* pPool)</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a9d7175ef30c1e7c69de82769447ce241">nn::audio::GetReleasedMemoryPoolCount(const AudioRendererConfig* pOutConfig)</a></code></li>
</ul>
<p>Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a84">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a112">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a133">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a101">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a97">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a40">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a72">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a82">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a82">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a84">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a48">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a89">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#a43">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, and <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#a49">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a2bf0ab532748ef3c8f6d127f1800ec1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf0ab532748ef3c8f6d127f1800ec1b">&#9670;&nbsp;</a></span>ReleaseMemoryPool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::ReleaseMemoryPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html">MemoryPoolType</a> *&#160;</td>
          <td class="paramname"><em>pPool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes a memory pool that was created for an audio renderer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td><code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pPool</td><td>Memory pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pPool</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a84f83d98dfc603829790bb0fbce67549">nn::audio::IsMemoryPoolAttached(pPool)</a></code> == <code>false</code>.</li>
<li><code><em>pPool</em></code> is not currently transitioning to the attached or detached state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Removes the specified memory pool (<code><em>pPool</em></code>) from the audio renderer. Before calling this function, use the <code><a class="el" href="namespacenn_1_1audio.html#a84f83d98dfc603829790bb0fbce67549" title="Determines whether a memory pool is currently attached.">nn::audio::IsMemoryPoolAttached()</a></code> function to check whether the memory pool can be deleted.</p>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a8e7b32e31ba3ea6f61c00c752c3a90d0">nn::audio::AcquireMemoryPool(AudioRendererConfig* pOutConfig, MemoryPoolType* pOutPool, void* address, size_t size)</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a2bf0ab532748ef3c8f6d127f1800ec1b">nn::audio::ReleaseMemoryPool(AudioRendererConfig* pOutConfig, MemoryPoolType* pPool)</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a9d7175ef30c1e7c69de82769447ce241">nn::audio::GetReleasedMemoryPoolCount(const AudioRendererConfig* pOutConfig)</a></code></li>
</ul>
<p>Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a118">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a78">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a127">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#a77">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, and <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#a86">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a5f9484edc9f1bae6e41933993fbe09dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9484edc9f1bae6e41933993fbe09dc">&#9670;&nbsp;</a></span>RequestAttachMemoryPool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::RequestAttachMemoryPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html">MemoryPoolType</a> *&#160;</td>
          <td class="paramname"><em>pPool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attaches a memory pool to an audio renderer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pPool</td><td>Memory pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> on success. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pPool</em></code> != <code>nullptr</code>.</li>
<li><code><em>pPool</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Requests attachment of all of the memory managed by <code><em>pPool</em></code> to the audio renderer.</p>
<p>This function has the following behaviors based on the state of <code><em>pPool</em></code>.</p><ul>
<li>If <code><a class="el" href="namespacenn_1_1audio.html#aec2896bdda770cd160dd31feb7e6dbf1">nn::audio::GetMemoryPoolState(pPool)</a></code> == <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html#ad447b3250f2b84c779d8777c3665fc16acbccc1028ead5dbb94368be402ffbbd0" title="Detached state.">MemoryPoolType::State_Detached</a></code>, this function transitions <code><em>pPool</em></code> to the request attachment state (<code>State_RequestAttach</code>) and returns <code>true</code>. <code><em>pPool</em></code> in the request attach state transitions to the attached state (<code>State_Attached</code>) the next time <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> is called.</li>
<li>If <code><a class="el" href="namespacenn_1_1audio.html#aec2896bdda770cd160dd31feb7e6dbf1">nn::audio::GetMemoryPoolState(pPool)</a></code> == <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html#ad447b3250f2b84c779d8777c3665fc16a4307e462e0c6831f6008d9a851cf533e" title="Request detach state.">MemoryPoolType::State_RequestDetach</a></code>, this function transitions <code><em>pPool</em></code> to the attached state (<code>State_Attached</code>) and returns <code>true</code>. This behavior is equivalent to canceling detachment requests using <code><a class="el" href="namespacenn_1_1audio.html#a1d5341a5f593894f840b218eb1929a3b" title="Detaches a memory pool from an audio renderer.">nn::audio::RequestDetachMemoryPool()</a></code>.</li>
<li>If <code><a class="el" href="namespacenn_1_1audio.html#aec2896bdda770cd160dd31feb7e6dbf1">nn::audio::GetMemoryPoolState(pPool)</a></code> is in another state , this function returns <code>false</code> without performing any operation on <code><em>pPool</em></code>.</li>
</ul>
<p>For more information about each state, see <code><a class="el" href="namespacenn_1_1audio.html#aec2896bdda770cd160dd31feb7e6dbf1" title="Gets the memory pool state.">nn::audio::GetMemoryPoolState()</a></code> and the <a href="../../Package/contents/Pages/Page_124010227.html">Memory Pool</a> documentation.</p>
<p>This function is not thread-safe. Do not manipulate <code><em>pPool</em></code> during calls to this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a85">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a113">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a134">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a102">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a98">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a41">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a73">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a83">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a83">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a85">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a49">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a90">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#a44">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, and <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#a50">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1d5341a5f593894f840b218eb1929a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5341a5f593894f840b218eb1929a3b">&#9670;&nbsp;</a></span>RequestDetachMemoryPool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::RequestDetachMemoryPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html">MemoryPoolType</a> *&#160;</td>
          <td class="paramname"><em>pPool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detaches a memory pool from an audio renderer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pPool</td><td>Memory pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> on success. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pPool</em></code> != <code>nullptr</code>.</li>
<li><code><em>pPool</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Requests detachment of all of the memory managed by <code><em>pPool</em></code> from the audio renderer.</p>
<p>This function has the following behaviors based on the state of <code><em>pPool</em></code>.</p><ul>
<li>If <code><a class="el" href="namespacenn_1_1audio.html#aec2896bdda770cd160dd31feb7e6dbf1">nn::audio::GetMemoryPoolState(pPool)</a></code> == <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html#ad447b3250f2b84c779d8777c3665fc16a7c6dcff365de21d23dbab209afe936fc" title="Attached state.">MemoryPoolType::State_Attached</a></code>, this function transitions <code><em>pPool</em></code> to the request detachment state (<code>State_RequestDetach)</code>) and returns <code>true</code>. <code><em>pPool</em></code> in the request attach state transitions to the detached state (<code>State_Detached</code>) the next time <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> is called.</li>
<li>If <code><a class="el" href="namespacenn_1_1audio.html#aec2896bdda770cd160dd31feb7e6dbf1">nn::audio::GetMemoryPoolState(pPool)</a></code> == <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html#ad447b3250f2b84c779d8777c3665fc16ac6e8b06f176b9ef5658157e8b02bdc13" title="Request attach state.">MemoryPoolType::State_RequestAttach</a></code> this function transitions <code><em>pPool</em></code> to the detached state (<code>State_Detached</code>) and returns <code>true</code>. This behavior is equivalent to canceling attachment requests using <code><a class="el" href="namespacenn_1_1audio.html#a5f9484edc9f1bae6e41933993fbe09dc" title="Attaches a memory pool to an audio renderer.">nn::audio::RequestAttachMemoryPool()</a></code>.</li>
<li>If <code><a class="el" href="namespacenn_1_1audio.html#aec2896bdda770cd160dd31feb7e6dbf1">nn::audio::GetMemoryPoolState(pPool)</a></code> is in another state , this function returns <code>false</code> without performing any operation on <code><em>pPool</em></code>.</li>
</ul>
<p>For more information about each state, see <code><a class="el" href="namespacenn_1_1audio.html#aec2896bdda770cd160dd31feb7e6dbf1" title="Gets the memory pool state.">nn::audio::GetMemoryPoolState()</a></code> and the <a href="../../Package/contents/Pages/Page_124010227.html">Memory Pool</a> documentation.</p>
<p>When <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> is called for memory pools in the request detach state (<code>State_RequestDetach</code>), the system checks whether the data being used is included in the resource data directly referenced by the audio renderer. The memory pool only transitions to the detached state (<code>State_Detached</code>) if the check results indicate that there is no data that is currently being used. For the data considered as "resource data directly referenced by the audio renderer," see the description of <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html" title="Structure for representing memory regions used by an audio renderer.">nn::audio::MemoryPoolType</a></code>. If the resources in the memory pool are being used by the audio renderer, the detachment will not complete, and the memory remains in the request detach state (<code>State_RequestDetach</code>). If detachment does not complete as expected, check that the various data described in "resource data directly referenced by the audio renderer" in the <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html" title="Structure for representing memory regions used by an audio renderer.">nn::audio::MemoryPoolType</a></code> is not included in <code><em>pPool</em></code>, and whether they are being used by the audio renderer.</p>
<p>The request detach state is maintained until detachment is complete. For this reason, after this function has been called <code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> determines whether <code><em>pPool</em></code> can transition to the detached state every time <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> is called, and transitions as soon as possible.</p>
<p>Use the <code><a class="el" href="namespacenn_1_1audio.html#a84f83d98dfc603829790bb0fbce67549" title="Determines whether a memory pool is currently attached.">nn::audio::IsMemoryPoolAttached()</a></code> or <code><a class="el" href="namespacenn_1_1audio.html#aec2896bdda770cd160dd31feb7e6dbf1" title="Gets the memory pool state.">nn::audio::GetMemoryPoolState()</a></code> function to check whether the transition to the detached state is complete.</p>
<p>Memory space held in an attached memory pool can be used for loading files by <code><a class="el" href="namespacenn_1_1fs.html" title="Namespace for the file system library.">nn::fs</a></code> and can be overwritten by <code><a class="el" href="namespacenn_1_1audio.html#a2fb36e3fd0639be1a1ff056d8d80dcc5" title="Reads or writes data to a memory region managed by a memory pool.">nn::audio::CopyMemoryPoolData()</a></code>. However, writing to a region at the same time that is being accessed by the audio renderer can cause noise and unstable behavior. To access the memory space held in a memory pool, either use this function to detach the memory pool beforehand, or avoid accessing memory spaces while they are being used by the audio renderer.</p>
<p>If the audio renderer that added the attached memory pool is destroyed by <code><a class="el" href="namespacenn_1_1audio.html#ac008e23e04fb6c5efbb8796dd2aa9f38" title="Frees the audio renderer.">nn::audio::CloseAudioRenderer()</a></code>, it automatically performs a process internally that is equivalent to detaching the memory pool. As a result, there is no need to explicitly detach or remove the memory pool when the audio renderer is destroyed. Note, however, that each <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html" title="Structure for representing memory regions used by an audio renderer.">MemoryPoolType</a></code> instance loses its association with the audio renderer as soon as the audio renderer is destroyed, so the states will not correctly correspond to the true states. To be specific, if the audio renderer is destroyed while a memory pool is in the attached state, <code><a class="el" href="namespacenn_1_1audio.html#a84f83d98dfc603829790bb0fbce67549" title="Determines whether a memory pool is currently attached.">nn::audio::IsMemoryPoolAttached()</a></code> continues to return <code>true</code> and <code><a class="el" href="namespacenn_1_1audio.html#aec2896bdda770cd160dd31feb7e6dbf1" title="Gets the memory pool state.">nn::audio::GetMemoryPoolState()</a></code> continues to return <code>State_Attached</code>, but the region used by <code><em>pPool</em></code> can be safely reused.</p>
<p>This function is not thread-safe. Do not manipulate <code><em>pPool</em></code> during calls to this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a116">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a76">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a125">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#a75">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, and <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#a84">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a84f83d98dfc603829790bb0fbce67549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f83d98dfc603829790bb0fbce67549">&#9670;&nbsp;</a></span>IsMemoryPoolAttached()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::IsMemoryPoolAttached </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html">MemoryPoolType</a> *&#160;</td>
          <td class="paramname"><em>pPool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether a memory pool is currently attached. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pPool</td><td>Memory pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the memory pool is attached or <code>false</code> if the memory pool is detached. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pPool</em></code> != <code>nullptr</code>.</li>
<li><code><em>pPool</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Returns <code>true</code> when this function is called for memory pools that were attached using the <code><a class="el" href="namespacenn_1_1audio.html#a5f9484edc9f1bae6e41933993fbe09dc" title="Attaches a memory pool to an audio renderer.">nn::audio::RequestAttachMemoryPool()</a></code> function. Be careful because <code>true</code> is returned immediately at the point where calling <code><a class="el" href="namespacenn_1_1audio.html#a5f9484edc9f1bae6e41933993fbe09dc" title="Attaches a memory pool to an audio renderer.">nn::audio::RequestAttachMemoryPool()</a></code> is complete before <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> finishes transitioning to the attached state. Returns <code>false</code> for memory pools that were detached using the <code><a class="el" href="namespacenn_1_1audio.html#a1d5341a5f593894f840b218eb1929a3b" title="Detaches a memory pool from an audio renderer.">nn::audio::RequestDetachMemoryPool()</a></code> function after all processes using the corresponding memory region specified for <code><em>pPool</em></code> are complete. Use this function to check whether a memory pool can be deleted before calling the <code><a class="el" href="namespacenn_1_1audio.html#a2bf0ab532748ef3c8f6d127f1800ec1b" title="Deletes a memory pool that was created for an audio renderer.">nn::audio::ReleaseMemoryPool()</a></code> function.</p>
<p>In addition to this function, you can also get the state of the memory pool from the <code><a class="el" href="namespacenn_1_1audio.html#aec2896bdda770cd160dd31feb7e6dbf1" title="Gets the memory pool state.">nn::audio::GetMemoryPoolState()</a></code> function. Returns <code>true</code> if the memory pool is in the <code>State_RequestAttach</code>, <code>State_Attached</code>, or <code>State_RequestDetach</code> state. For more information about each state, see <code><a class="el" href="namespacenn_1_1audio.html#aec2896bdda770cd160dd31feb7e6dbf1" title="Gets the memory pool state.">nn::audio::GetMemoryPoolState()</a></code> and the <a href="../../Package/contents/Pages/Page_124010227.html">Memory Pool</a> documentation.</p>
<p>This function is not thread-safe. Do not manipulate <code><em>pPool</em></code> during calls to this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a117">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a77">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a126">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#a76">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, and <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#a85">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aec2896bdda770cd160dd31feb7e6dbf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec2896bdda770cd160dd31feb7e6dbf1">&#9670;&nbsp;</a></span>GetMemoryPoolState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html#ad447b3250f2b84c779d8777c3665fc16">MemoryPoolType::State</a> nn::audio::GetMemoryPoolState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html">MemoryPoolType</a> *&#160;</td>
          <td class="paramname"><em>pPool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the memory pool state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pPool</td><td>Memory pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an enumerated type representing the state of the memory pool. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pPool</em></code> != <code>nullptr</code>.</li>
<li><code><em>pPool</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the state of the memory pool specified by <code><a class="el" href="namespacenn_1_1audio.html#a5f9484edc9f1bae6e41933993fbe09dc" title="Attaches a memory pool to an audio renderer.">nn::audio::RequestAttachMemoryPool()</a></code> or <code><a class="el" href="namespacenn_1_1audio.html#a1d5341a5f593894f840b218eb1929a3b" title="Detaches a memory pool from an audio renderer.">nn::audio::RequestDetachMemoryPool()</a></code>. The meaning of each state is as follows.</p>
<ul>
<li><code>State_RequestAttach</code> indicates the state where calling <code><a class="el" href="namespacenn_1_1audio.html#a5f9484edc9f1bae6e41933993fbe09dc" title="Attaches a memory pool to an audio renderer.">nn::audio::RequestAttachMemoryPool()</a></code> is complete and attachment is requested. Memory pools in this state will transition to <code>State_Attached</code> during the next <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code>.</li>
<li><code>State_Attached</code> is the state where attachment is complete.</li>
<li><code>State_RequestAttach</code> indicates the state where calling <code><a class="el" href="namespacenn_1_1audio.html#a5f9484edc9f1bae6e41933993fbe09dc" title="Attaches a memory pool to an audio renderer.">nn::audio::RequestAttachMemoryPool()</a></code> is complete and detachment is requested. Memory pools in this state transition to <code>State_Detached</code> when <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> is next called so long as <code><em>pPool</em></code> is not in use by the audio renderer.</li>
<li><code>State_Detached</code> is the state where detachment is complete. Memory pools are in this state immediately after initialization by <code><a class="el" href="namespacenn_1_1audio.html#a8e7b32e31ba3ea6f61c00c752c3a90d0" title="Gets a memory pool for an audio renderer.">nn::audio::AcquireMemoryPool()</a></code>.</li>
</ul>
<p>For more information about each state, see <a href="../../Package/contents/Pages/Page_124010227.html">Memory Pool</a> documentation.</p>
<p>This function is not thread-safe. Do not manipulate <code><em>pPool</em></code> during calls to this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="a9d7175ef30c1e7c69de82769447ce241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d7175ef30c1e7c69de82769447ce241">&#9670;&nbsp;</a></span>GetReleasedMemoryPoolCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetReleasedMemoryPoolCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of memory pools that can be retrieved. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pConfig</td><td><code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of memory pools. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pConfig</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The number of memory pools is determined by the <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html" title="The audio renderer parameters.">nn::audio::AudioRendererParameter</a></code> settings used when <code><em>pConfig</em></code> is initialized. Although up to the number of memory pools returned by this function can be retrieved, overall performance efficiency increases as the number of memory pools used decreases. If the number of memory pools is still too small, consider reorganizing your resource data.</p>
<p>While this function is being used, <code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially locks access to <code><em>pConfig</em></code>. Note that the following functions, which use the same <code><em>pConfig</em></code>, may become blocked.</p><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a8e7b32e31ba3ea6f61c00c752c3a90d0">nn::audio::AcquireMemoryPool(AudioRendererConfig* pConfig, MemoryPoolType* pOutPool, void* address, size_t size)</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a2bf0ab532748ef3c8f6d127f1800ec1b">nn::audio::ReleaseMemoryPool(AudioRendererConfig* pConfig, MemoryPoolType* pPool)</a></code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a9d7175ef30c1e7c69de82769447ce241">nn::audio::GetReleasedMemoryPoolCount(const AudioRendererConfig* pConfig)</a></code> </li>
</ul>

</div>
</div>
<a id="a847e8128383fe3e162b568bd7accc7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a847e8128383fe3e162b568bd7accc7cc">&#9670;&nbsp;</a></span>GetMemoryPoolAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::audio::GetMemoryPoolAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html">MemoryPoolType</a> *&#160;</td>
          <td class="paramname"><em>pPool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the address of a memory region managed by a memory pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pPool</td><td>Memory pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the address. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pPool</em></code> != <code>nullptr</code>.</li>
<li><code><em>pPool</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not manipulate <code><em>pPool</em></code> during calls to this function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a54">AudioMemoryPool/AudioMemoryPool.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a8b5db33f96169ddfb4032758e2683089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5db33f96169ddfb4032758e2683089">&#9670;&nbsp;</a></span>GetMemoryPoolSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::audio::GetMemoryPoolSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html">MemoryPoolType</a> *&#160;</td>
          <td class="paramname"><em>pPool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of a memory region managed by a memory pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pPool</td><td>Memory pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the size. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pPool</em></code> != <code>nullptr</code>.</li>
<li><code><em>pPool</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not manipulate <code><em>pPool</em></code> during calls to this function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a55">AudioMemoryPool/AudioMemoryPool.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a2fb36e3fd0639be1a1ff056d8d80dcc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb36e3fd0639be1a1ff056d8d80dcc5">&#9670;&nbsp;</a></span>CopyMemoryPoolData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::audio::CopyMemoryPoolData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html">MemoryPoolType</a> *&#160;</td>
          <td class="paramname"><em>pPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads or writes data to a memory region managed by a memory pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pPool</td><td>Memory pool. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>The memory to which to copy the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The memory from which to copy data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the data to copy (in bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code><em>dst</em></code>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pPool</em></code> != <code>nullptr</code>.</li>
<li><code><em>pPool</em></code> is initialized.</li>
<li>One or both of the memory regions specified by <code><em>dst</em></code> and <code><em>src</em></code> are contained within <code><em>pPool</em></code>.</li>
<li><code><em>dst</em></code> != <code>nullptr</code>.</li>
<li><code><em>src</em></code> != <code>nullptr</code>.</li>
<li>The <code><em>dst</em></code> and <code><em>src</em></code> memory regions do not overlap at all.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function provides safe access to memory pools that are in the attached state. This function makes it possible to overwrite the data in a buffer contained in a <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> object returned by the <code><a class="el" href="namespacenn_1_1audio.html#ad4736cbcae273e050d01416a7625b0d8" title="Get the WaveBuffer object that VoiceType has finished playing.">nn::audio::GetReleasedWaveBuffer()</a></code> function, for example, even if the corresponding memory pool is still attached. Even when using this function, however, do not attempt operations on memory regions in attached memory pools that are currently being used by an audio renderer. </p>

</div>
</div>
<a id="a7d1532644fd22daad0fe71d9f409ba72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d1532644fd22daad0fe71d9f409ba72">&#9670;&nbsp;</a></span>SetPerformanceFrameBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::audio::SetPerformanceFrameBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a starting address to output performance information to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> object initialized when you get the audio renderer to get performance information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The memory space to which the audio renderer writes performance information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size of the region specified for <code><em>buffer</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The address that was set for <code><em>buffer</em></code> the last time this function was called. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>config</em></code> is initialized.</li>
<li><code><em>buffer</em></code> is aligned to <code><a class="el" href="namespacenn_1_1audio.html#a61833f2e2cf0253e3054188e900315af" title="The alignment size for audio buffers.">nn::audio::BufferAlignSize</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sets the address of the region specified for <code><em>buffer</em></code>. Audio renderers output performance information to this buffer. If a buffer has already been set and a new region is specified for <code><em>buffer</em></code>, the function returns the address of the region specified for <code><em>buffer</em></code> the last time the function was called.</p>
<p>The audio renderer writes data to the region specified for <code><em>buffer</em></code> during calls to the <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> function. Do not access <code><em>buffer</em></code> during calls to <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code>.</p>
<p>If you specify <code>nullptr</code> for <code><em>buffer</em></code>, no data will be output. By default, <code>nullptr</code> is specified for <code><em>buffer</em></code>, therefore <code><a class="el" href="namespacenn_1_1audio.html#a7d1532644fd22daad0fe71d9f409ba72" title="Sets a starting address to output performance information to.">nn::audio::SetPerformanceFrameBuffer()</a></code> will not output data unless this function specifies some other value than <code>nullptr</code>.</p>
<p>The value returned by this function refers to the starting address of the performance frame. Cast this address to <code><a class="el" href="structnn_1_1audio_1_1_performance_frame_header.html" title="The header for the performance information for a single audio frame of the audio renderer.">nn::audio::PerformanceFrameHeader</a>*</code> to use and parse the performance frame. <code><a class="el" href="classnn_1_1audio_1_1_performance_info.html" title="Class for working with performance information retrieved using the nn::audio::SetPerformanceFrameBuff...">nn::audio::PerformanceInfo</a></code> has been prepared to make this process easier.</p>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a7d1532644fd22daad0fe71d9f409ba72" title="Sets a starting address to output performance information to.">nn::audio::SetPerformanceFrameBuffer</a>(AudioRendererConfig* <em>pOutConfig</em>, void* <em>buffer</em>, size_t <em>bufferSize</em>)</code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a382b31fe7f6db23f10c0380365a64ba9" title="Sets the target VoiceType for which to get detailed performance information.">nn::audio::SetPerformanceDetailTarget</a>(AudioRendererConfig* <em>pOutConfig</em>, const VoiceType* <em>pVoice</em>)</code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a382b31fe7f6db23f10c0380365a64ba9" title="Sets the target VoiceType for which to get detailed performance information.">nn::audio::SetPerformanceDetailTarget</a>(AudioRendererConfig* <em>pOutConfig</em>, const SubMixType* <em>pSubMix</em>)</code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a382b31fe7f6db23f10c0380365a64ba9" title="Sets the target VoiceType for which to get detailed performance information.">nn::audio::SetPerformanceDetailTarget</a>(AudioRendererConfig* <em>pOutConfig</em>, const FinalMixType* <em>pFinalMix</em>)</code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a73533970436167d6e06d131844085916" title="Clears the target for which to get detailed performance information.">nn::audio::ClearPerformanceDetailTarget</a>(AudioRendererConfig* <em>pOutConfig</em>)</code> </li>
</ul>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a138">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af6322903ab06537b41c4330c6eff1b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6322903ab06537b41c4330c6eff1b58">&#9670;&nbsp;</a></span>GetRequiredBufferSizeForPerformanceFrames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::audio::GetRequiredBufferSizeForPerformanceFrames </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html">AudioRendererParameter</a> &amp;&#160;</td>
          <td class="paramname"><em>parameter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the required size for the memory region to which performance information will be written. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter</td><td>The parameter used when getting the audio renderer that will get the performance information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of memory required to output the performance information. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>parameter</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 At the time this is obtained, the audio renderer is holding x frames worth of performance information, where x is the number of frames specified by <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html#adc0048497f26f959223bdffa24ac4a53" title="The maximum number of audio frames for the accumulated performance information.">nn::audio::AudioRendererParameter.performanceFrameCount</a></code>. The performance information being held by the audio renderer is written to the memory region specified by the <code><a class="el" href="namespacenn_1_1audio.html#a7d1532644fd22daad0fe71d9f409ba72" title="Sets a starting address to output performance information to.">nn::audio::SetPerformanceFrameBuffer()</a></code> function. This function calculates and returns the size of the memory region that <code><a class="el" href="namespacenn_1_1audio.html#a7d1532644fd22daad0fe71d9f409ba72" title="Sets a starting address to output performance information to.">nn::audio::SetPerformanceFrameBuffer()</a></code> should have. For <code><em>parameter</em></code>, specify the parameter that was specified when the audio renderer was opened. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a119">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a382b31fe7f6db23f10c0380365a64ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382b31fe7f6db23f10c0380365a64ba9">&#9670;&nbsp;</a></span>SetPerformanceDetailTarget() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetPerformanceDetailTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pVoice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the target <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> for which to get detailed performance information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> object initialized when you get the audio renderer to get performance information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pVoice</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> to set as the target. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>config</em></code> is initialized.</li>
<li><code><em>pVoice</em></code> != <code>nullptr</code>.</li>
<li><code><em>pVoice</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code><a class="el" href="structnn_1_1audio_1_1_performance_detail.html" title="Detailed performance information linked to each VoiceType, SubMixType, and FinalMixType object.">PerformanceDetail</a></code> is not available until a value is specified by this function. Only one instance of the target can be set, regardless of whether the type is <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. The target is replaced by reconfiguring the setting and calling <code><a class="el" href="namespacenn_1_1audio.html#a382b31fe7f6db23f10c0380365a64ba9" title="Sets the target VoiceType for which to get detailed performance information.">nn::audio::SetPerformanceDetailTarget()</a></code> again.</p>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a7d1532644fd22daad0fe71d9f409ba72" title="Sets a starting address to output performance information to.">nn::audio::SetPerformanceFrameBuffer</a>(AudioRendererConfig* <em>pOutConfig</em>, void* <em>buffer</em>, size_t <em>bufferSize</em>)</code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a382b31fe7f6db23f10c0380365a64ba9" title="Sets the target VoiceType for which to get detailed performance information.">nn::audio::SetPerformanceDetailTarget</a>(AudioRendererConfig* <em>pOutConfig</em>, const VoiceType* <em>pVoice</em>)</code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a382b31fe7f6db23f10c0380365a64ba9" title="Sets the target VoiceType for which to get detailed performance information.">nn::audio::SetPerformanceDetailTarget</a>(AudioRendererConfig* <em>pOutConfig</em>, const SubMixType* <em>pSubMix</em>)</code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a382b31fe7f6db23f10c0380365a64ba9" title="Sets the target VoiceType for which to get detailed performance information.">nn::audio::SetPerformanceDetailTarget</a>(AudioRendererConfig* <em>pOutConfig</em>, const FinalMixType* <em>pFinalMix</em>)</code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a73533970436167d6e06d131844085916" title="Clears the target for which to get detailed performance information.">nn::audio::ClearPerformanceDetailTarget</a>(AudioRendererConfig* <em>pOutConfig</em>)</code> </li>
</ul>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a136">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a0bd5a07dc4d1f4ac3def71b01036875f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd5a07dc4d1f4ac3def71b01036875f">&#9670;&nbsp;</a></span>SetPerformanceDetailTarget() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetPerformanceDetailTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pSubMix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the target <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> for which to get detailed performance information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> object initialized when you get the audio renderer to get performance information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSubMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> to set as the target. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>config</em></code> is initialized.</li>
<li><code><em>pSubMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSubMix</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code><a class="el" href="structnn_1_1audio_1_1_performance_detail.html" title="Detailed performance information linked to each VoiceType, SubMixType, and FinalMixType object.">PerformanceDetail</a></code> is not available until a value is specified by this function. Only one instance of the target can be set, regardless of whether the type is <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. The target is replaced by reconfiguring the setting and calling <code><a class="el" href="namespacenn_1_1audio.html#a382b31fe7f6db23f10c0380365a64ba9" title="Sets the target VoiceType for which to get detailed performance information.">nn::audio::SetPerformanceDetailTarget()</a></code> again.</p>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a7d1532644fd22daad0fe71d9f409ba72" title="Sets a starting address to output performance information to.">nn::audio::SetPerformanceFrameBuffer</a>(AudioRendererConfig* <em>pOutConfig</em>, void* <em>buffer</em>, size_t <em>bufferSize</em>)</code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a382b31fe7f6db23f10c0380365a64ba9" title="Sets the target VoiceType for which to get detailed performance information.">nn::audio::SetPerformanceDetailTarget</a>(AudioRendererConfig* <em>pOutConfig</em>, const VoiceType* <em>pVoice</em>)</code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a382b31fe7f6db23f10c0380365a64ba9" title="Sets the target VoiceType for which to get detailed performance information.">nn::audio::SetPerformanceDetailTarget</a>(AudioRendererConfig* <em>pOutConfig</em>, const SubMixType* <em>pSubMix</em>)</code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a382b31fe7f6db23f10c0380365a64ba9" title="Sets the target VoiceType for which to get detailed performance information.">nn::audio::SetPerformanceDetailTarget</a>(AudioRendererConfig* <em>pOutConfig</em>, const FinalMixType* <em>pFinalMix</em>)</code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a73533970436167d6e06d131844085916" title="Clears the target for which to get detailed performance information.">nn::audio::ClearPerformanceDetailTarget</a>(AudioRendererConfig* <em>pOutConfig</em>)</code> </li>
</ul>

</div>
</div>
<a id="a4b030fa567c26a5d943c9617fd99b721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b030fa567c26a5d943c9617fd99b721">&#9670;&nbsp;</a></span>SetPerformanceDetailTarget() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetPerformanceDetailTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pFinalMix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the target <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> for which to get detailed performance information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> object initialized when you get the audio renderer to get performance information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFinalMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> to set as the target. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>config</em></code> is initialized.</li>
<li><code><em>pFinalMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pFinalMix</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code><a class="el" href="structnn_1_1audio_1_1_performance_detail.html" title="Detailed performance information linked to each VoiceType, SubMixType, and FinalMixType object.">PerformanceDetail</a></code> is not available until a value is specified by this function. Only one instance of the target can be set, regardless of whether the type is <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. The target is replaced by reconfiguring the setting and calling <code><a class="el" href="namespacenn_1_1audio.html#a382b31fe7f6db23f10c0380365a64ba9" title="Sets the target VoiceType for which to get detailed performance information.">nn::audio::SetPerformanceDetailTarget()</a></code> again.</p>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a7d1532644fd22daad0fe71d9f409ba72" title="Sets a starting address to output performance information to.">nn::audio::SetPerformanceFrameBuffer</a>(AudioRendererConfig* <em>pOutConfig</em>, void* <em>buffer</em>, size_t <em>bufferSize</em>)</code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a382b31fe7f6db23f10c0380365a64ba9" title="Sets the target VoiceType for which to get detailed performance information.">nn::audio::SetPerformanceDetailTarget</a>(AudioRendererConfig* <em>pOutConfig</em>, const VoiceType* <em>pVoice</em>)</code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a382b31fe7f6db23f10c0380365a64ba9" title="Sets the target VoiceType for which to get detailed performance information.">nn::audio::SetPerformanceDetailTarget</a>(AudioRendererConfig* <em>pOutConfig</em>, const SubMixType* <em>pSubMix</em>)</code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a382b31fe7f6db23f10c0380365a64ba9" title="Sets the target VoiceType for which to get detailed performance information.">nn::audio::SetPerformanceDetailTarget</a>(AudioRendererConfig* <em>pOutConfig</em>, const FinalMixType* <em>pFinalMix</em>)</code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a73533970436167d6e06d131844085916" title="Clears the target for which to get detailed performance information.">nn::audio::ClearPerformanceDetailTarget</a>(AudioRendererConfig* <em>pOutConfig</em>)</code> </li>
</ul>

</div>
</div>
<a id="a73533970436167d6e06d131844085916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73533970436167d6e06d131844085916">&#9670;&nbsp;</a></span>ClearPerformanceDetailTarget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::ClearPerformanceDetailTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the target for which to get detailed performance information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> object initialized when you get the audio renderer to get performance information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>config</em></code> is initialized.</li>
</ul>
</dd></dl>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a7d1532644fd22daad0fe71d9f409ba72" title="Sets a starting address to output performance information to.">nn::audio::SetPerformanceFrameBuffer</a>(AudioRendererConfig* <em>pOutConfig</em>, void* <em>buffer</em>, size_t <em>bufferSize</em>)</code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a382b31fe7f6db23f10c0380365a64ba9" title="Sets the target VoiceType for which to get detailed performance information.">nn::audio::SetPerformanceDetailTarget</a>(AudioRendererConfig* <em>pOutConfig</em>, const VoiceType* <em>pVoice</em>)</code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a382b31fe7f6db23f10c0380365a64ba9" title="Sets the target VoiceType for which to get detailed performance information.">nn::audio::SetPerformanceDetailTarget</a>(AudioRendererConfig* <em>pOutConfig</em>, const SubMixType* <em>pSubMix</em>)</code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a382b31fe7f6db23f10c0380365a64ba9" title="Sets the target VoiceType for which to get detailed performance information.">nn::audio::SetPerformanceDetailTarget</a>(AudioRendererConfig* <em>pOutConfig</em>, const FinalMixType* <em>pFinalMix</em>)</code></li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a73533970436167d6e06d131844085916" title="Clears the target for which to get detailed performance information.">nn::audio::ClearPerformanceDetailTarget</a>(AudioRendererConfig* <em>pOutConfig</em>)</code> </li>
</ul>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a137">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af5822e19aca28543d2ee8787cb0e8577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5822e19aca28543d2ee8787cb0e8577">&#9670;&nbsp;</a></span>GetRequiredBufferSizeForPolyphaseResampler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::audio::GetRequiredBufferSizeForPolyphaseResampler </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inputSampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outputSampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isHighQuality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the size of the buffer required for the polyphase resampler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputSampleRate</td><td>Input sample rate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outputSampleRate</td><td>Output sample rate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCount</td><td>Number of channels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isHighQuality</td><td>The sound quality flag. (Specify <code>true</code> to use a 32 tap filter for internal processing, or <code>false</code> to use a 16 tap filter.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>channelCount</em></code> &gt; <code>0</code>.</li>
<li><code><em>channelCount</em></code> &lt;= <code><a class="el" href="structnn_1_1audio_1_1_polyphase_resampler_type.html#a7d805ad664de2f70f4a7c355373c6488" title="Maximum number of channels.">PolyphaseResamplerType::ChannelCountMax</a></code>.</li>
<li><code><em>inputSampleRate</em></code> &gt; <code>0</code>.</li>
<li><code><em>outputSampleRate</em></code> &gt; <code>0</code>.</li>
<li><code><em>outputSampleRate</em></code> / <code><em>inputSampleRate</em></code> &gt;= <code><a class="el" href="structnn_1_1audio_1_1_polyphase_resampler_type.html#a0efb2f31cbc928f13c26f00caaa49a22" title="Gets the minimum frequency conversion ratio that can be set (1.0f / 16.0f).">PolyphaseResamplerType::GetConversionRatioMin()</a></code>.</li>
<li><code><em>outputSampleRate</em></code> / <code><em>inputSampleRate</em></code> &lt;= <code><a class="el" href="structnn_1_1audio_1_1_polyphase_resampler_type.html#ac98bbd89fbab74ab23679f7fd141a4a3" title="Gets the maximum frequency conversion ratio that can be set (16.0f) .">PolyphaseResamplerType::GetConversionRatioMax()</a></code>. </li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the required buffer size. </dd></dl>

</div>
</div>
<a id="ab76dea35967175b6ed3879955589b37f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab76dea35967175b6ed3879955589b37f">&#9670;&nbsp;</a></span>CalculatePolyphaseResamplerActualOutputSampleRate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double nn::audio::CalculatePolyphaseResamplerActualOutputSampleRate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inputSampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outputSampleRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the actual output sample rate for the polyphase resampler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputSampleRate</td><td>Input sample rate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outputSampleRate</td><td>Output sample rate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>inputSampleRate</em></code> &gt; <code>0</code>.</li>
<li><code><em>outputSampleRate</em></code> &gt; <code>0</code>.</li>
<li><code><em>outputSampleRate</em></code> / <code><em>inputSampleRate</em></code> &gt;= <code><a class="el" href="structnn_1_1audio_1_1_polyphase_resampler_type.html#a0efb2f31cbc928f13c26f00caaa49a22" title="Gets the minimum frequency conversion ratio that can be set (1.0f / 16.0f).">PolyphaseResamplerType::GetConversionRatioMin()</a></code>.</li>
<li><code><em>outputSampleRate</em></code> / <code><em>inputSampleRate</em></code> &lt;= <code><a class="el" href="structnn_1_1audio_1_1_polyphase_resampler_type.html#ac98bbd89fbab74ab23679f7fd141a4a3" title="Gets the maximum frequency conversion ratio that can be set (16.0f) .">PolyphaseResamplerType::GetConversionRatioMax()</a></code>. </li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the actual output sample rate. The result might not be an integer value.</dd></dl>
<p> <b>Details</b> <br  />
 The polyphase resampler works most efficiently when the ratio of input and output sample rates is a rational expression where the denominator and the numerator are both positive integers of 255 or less. If the values for <code><em>inputSampleRate</em></code> and <code><em>outputSampleRate</em></code> do not satisfy this condition, the polyphase resampler converts the output sample rate to the nearest value that satisfies this condition and then performs its process. This function calculates the actual output sample rate based on the input sample rate. </p>

</div>
</div>
<a id="a1600e37d5cf3718ff890321f7c3de4ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1600e37d5cf3718ff890321f7c3de4ee">&#9670;&nbsp;</a></span>GetPolyphaseResamplerOutputSampleCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetPolyphaseResamplerOutputSampleCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_polyphase_resampler_type.html">PolyphaseResamplerType</a> *&#160;</td>
          <td class="paramname"><em>pResampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inputSampleCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the maximum number of output samples that will be obtained from the polyphase resampler process based on the number of input samples. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pResampler</td><td>Pointer to the <code><a class="el" href="structnn_1_1audio_1_1_polyphase_resampler_type.html" title="The structure for managing the resampler.">PolyphaseResamplerType</a></code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputSampleCount</td><td>Number of input samples. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the maximum number of output samples. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pResampler</em></code> != <code>nullptr</code>.</li>
<li><code><em>pResampler</em></code> has been initialized by the <code><a class="el" href="namespacenn_1_1audio.html#a15ccfba53d152b2a7b26b61944f90a39" title="Initializes the polyphase resampler.">nn::audio::InitializePolyphaseResampler()</a></code> function.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function returns the maximum number of output samples for which output buffer space must be allocated. Note that because the system internally allocates a prescribed amount of space as a margin of error, the value returned by this function may not necessarily match the number of samples obtained from the actual process. The actual number of output samples is the value obtained upon calling the <code><a class="el" href="namespacenn_1_1audio.html#af6d4544d97f0e4d2a15603197c96f6b9" title="Uses the polyphase resampler to convert the frequency.">nn::audio::ProcessPolyphaseResamplerBuffer()</a></code> function. </p>

</div>
</div>
<a id="a15ccfba53d152b2a7b26b61944f90a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ccfba53d152b2a7b26b61944f90a39">&#9670;&nbsp;</a></span>InitializePolyphaseResampler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::InitializePolyphaseResampler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_polyphase_resampler_type.html">PolyphaseResamplerType</a> *&#160;</td>
          <td class="paramname"><em>pResampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inputSampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outputSampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isHighQuality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>gain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the polyphase resampler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pResampler</td><td>Pointer to the <code><a class="el" href="structnn_1_1audio_1_1_polyphase_resampler_type.html" title="The structure for managing the resampler.">PolyphaseResamplerType</a></code> structure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>The work buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputSampleRate</td><td>Input sample rate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outputSampleRate</td><td>Output sample rate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCount</td><td>Number of channels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isHighQuality</td><td>The sound quality flag. (Specify <code>true</code> to use a 32 tap filter for internal processing, or <code>false</code> to use a 16 tap filter.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gain</td><td>The gain. (A value in the range of <code>0.0f</code> to <code>1.0f</code>. If the specified value is out of range, it will be clamped internally.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pResampler</em></code> != <code>nullptr</code>.</li>
<li><code><em>buffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>inputSampleRate</em></code> &gt; <code>0</code>.</li>
<li><code><em>outputSampleRate</em></code> &gt; <code>0</code>.</li>
<li><code><em>bufferSize</em></code> &gt;= <code><a class="el" href="namespacenn_1_1audio.html#af5822e19aca28543d2ee8787cb0e8577" title="Determines the size of the buffer required for the polyphase resampler.">GetRequiredBufferSizeForPolyphaseResampler()</a></code>.</li>
<li><code><em>outputSampleRate</em></code> / <code><em>inputSampleRate</em></code> &gt;= <code><a class="el" href="structnn_1_1audio_1_1_polyphase_resampler_type.html#a0efb2f31cbc928f13c26f00caaa49a22" title="Gets the minimum frequency conversion ratio that can be set (1.0f / 16.0f).">PolyphaseResamplerType::GetConversionRatioMin()</a></code>.</li>
<li><code><em>outputSampleRate</em></code> / <code><em>inputSampleRate</em></code> &lt;= <code><a class="el" href="structnn_1_1audio_1_1_polyphase_resampler_type.html#ac98bbd89fbab74ab23679f7fd141a4a3" title="Gets the maximum frequency conversion ratio that can be set (16.0f) .">PolyphaseResamplerType::GetConversionRatioMax()</a></code>.</li>
<li><code><em>channelCount</em></code> &gt; <code>0</code>.</li>
<li><code><em>channelCount</em></code> &lt;= <code><a class="el" href="structnn_1_1audio_1_1_polyphase_resampler_type.html#a7d805ad664de2f70f4a7c355373c6488" title="Maximum number of channels.">PolyphaseResamplerType::ChannelCountMax</a></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pResampler</em></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af6d4544d97f0e4d2a15603197c96f6b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d4544d97f0e4d2a15603197c96f6b9">&#9670;&nbsp;</a></span>ProcessPolyphaseResamplerBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::ProcessPolyphaseResamplerBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_polyphase_resampler_type.html">PolyphaseResamplerType</a> *&#160;</td>
          <td class="paramname"><em>pResampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutputSampleCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>pOutputBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outputBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16_t *&#160;</td>
          <td class="paramname"><em>pInputBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inputSampleCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses the polyphase resampler to convert the frequency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pResampler</td><td>Pointer to the <code><a class="el" href="structnn_1_1audio_1_1_polyphase_resampler_type.html" title="The structure for managing the resampler.">PolyphaseResamplerType</a></code> structure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutputSampleCount</td><td>Number of output samples. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutputBuffer</td><td>Output buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outputBufferSize</td><td>Size of the output buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pInputBuffer</td><td>Input buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputSampleCount</td><td>Number of input samples. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_insufficient_buffer.html">nn::audio::ResultInsufficientBuffer</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutputBuffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>pInputBuffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>pResampler</em></code> != <code>nullptr</code>.</li>
<li><code><em>pResampler</em></code> has been initialized by the <code><a class="el" href="namespacenn_1_1audio.html#a15ccfba53d152b2a7b26b61944f90a39" title="Initializes the polyphase resampler.">nn::audio::InitializePolyphaseResampler()</a></code> function. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>*pOutputSampleCount</em></code> data with changed frequency is written to <code><em>pOutputBuffer</em></code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a170d77cd0820e896556ec2838ddb375b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a170d77cd0820e896556ec2838ddb375b">&#9670;&nbsp;</a></span>GetRequiredBufferSizeForResampler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::audio::GetRequiredBufferSizeForResampler </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the size of the buffer required for the resampler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCount</td><td>Number of channels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>channelCount</em></code> &gt; <code>0</code>.</li>
<li><code><em>channelCount</em></code> &lt;= <code><a class="el" href="structnn_1_1audio_1_1_resampler_type.html#a5765a1bf0920f9e30dcf7a4bba928f6d" title="Maximum number of channels.">ResamplerType::ChannelCountMax</a></code>. </li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the required buffer size. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_out_with_resampler_2_audio_out_with_resampler_8cpp-example.html#a62">AudioOutWithResampler/AudioOutWithResampler.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a9f4af05ca5d0411d406afd8a691829f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4af05ca5d0411d406afd8a691829f9">&#9670;&nbsp;</a></span>GetResamplerOutputSampleCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetResamplerOutputSampleCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_resampler_type.html">ResamplerType</a> *&#160;</td>
          <td class="paramname"><em>pResampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inputSampleCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the maximum number of output samples that will be obtained from the resampler process based on the number of input samples. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pResampler</td><td>Pointer to the <code><a class="el" href="structnn_1_1audio_1_1_resampler_type.html" title="The structure for managing the resampler.">ResamplerType</a></code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputSampleCount</td><td>Number of input samples. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the maximum number of output samples. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pResampler</em></code> != <code>nullptr</code>.</li>
<li><code><em>pResampler</em></code> has been initialized by the <code><a class="el" href="namespacenn_1_1audio.html#a5b0e4d5282ee5a5af26aa605d60a4d7e" title="Initializes the resampler.">nn::audio::InitializeResampler()</a></code> function.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function returns the maximum number of output samples for which output buffer space must be allocated. Note that because the system internally allocates a prescribed amount of space as a margin of error, the value returned by this function may not necessarily match the number of samples obtained from the actual process. The actual number of output samples is the value obtained upon calling the <code><a class="el" href="namespacenn_1_1audio.html#a7a5e45f72831e900530a7d0c7fd01cca" title="Uses the resampler to change the frequency.">nn::audio::ProcessResamplerBuffer()</a></code> function. </p>

</div>
</div>
<a id="a5b0e4d5282ee5a5af26aa605d60a4d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b0e4d5282ee5a5af26aa605d60a4d7e">&#9670;&nbsp;</a></span>InitializeResampler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::InitializeResampler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_resampler_type.html">ResamplerType</a> *&#160;</td>
          <td class="paramname"><em>pResampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inputSampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outputSampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the resampler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pResampler</td><td>Pointer to the <code><a class="el" href="structnn_1_1audio_1_1_resampler_type.html" title="The structure for managing the resampler.">ResamplerType</a></code> structure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Work buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputSampleRate</td><td>Input sample rate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outputSampleRate</td><td>Output sample rate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCount</td><td>Number of channels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pResampler</em></code> != <code>nullptr</code>.</li>
<li><code><em>buffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>inputSampleRate</em></code> &gt; <code>0</code>.</li>
<li><code><em>outputSampleRate</em></code> &gt; <code>0</code>.</li>
<li><code><em>bufferSize</em></code> &gt;= <code><a class="el" href="namespacenn_1_1audio.html#a170d77cd0820e896556ec2838ddb375b">nn::audio::GetRequiredBufferSizeForResampler(&lt;var&gt;channelCount&lt;/var&gt;)</a></code>.</li>
<li><code><em>outputSampleRate</em></code> / <code><em>inputSampleRate</em></code> &gt;= <code><a class="el" href="structnn_1_1audio_1_1_resampler_type.html#aebd7bf1fd50f922ad495a70ce298f804" title="Gets the minimum frequency conversion ratio (1.0f / 8.0f) that can be set.">ResamplerType::GetConvertRatioMin()</a></code>.</li>
<li><code><em>outputSampleRate</em></code> / <code><em>inputSampleRate</em></code> &lt;= <code><a class="el" href="structnn_1_1audio_1_1_resampler_type.html#a666edbf3a2199b0758c4bb52195192ac" title="Gets the maximum frequency conversion ratio (32768.0f) that can be set.">ResamplerType::GetConvertRatioMax()</a></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pResampler</em></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a7a5e45f72831e900530a7d0c7fd01cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a5e45f72831e900530a7d0c7fd01cca">&#9670;&nbsp;</a></span>ProcessResamplerBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::ProcessResamplerBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_resampler_type.html">ResamplerType</a> *&#160;</td>
          <td class="paramname"><em>pResampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutputSampleCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>pOutputBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outputBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16_t *&#160;</td>
          <td class="paramname"><em>pInputBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inputSampleCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses the resampler to change the frequency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pResampler</td><td>Pointer to the <code><a class="el" href="structnn_1_1audio_1_1_resampler_type.html" title="The structure for managing the resampler.">ResamplerType</a></code> structure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutputSampleCount</td><td>Number of output samples. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutputBuffer</td><td>Output buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outputBufferSize</td><td>Size of the output buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pInputBuffer</td><td>Input buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputSampleCount</td><td>Number of input samples. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_insufficient_buffer.html">nn::audio::ResultInsufficientBuffer</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutputBuffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>pInputBuffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>pResampler</em></code> != <code>nullptr</code>.</li>
<li><code><em>pResampler</em></code> has been initialized by the <code><a class="el" href="namespacenn_1_1audio.html#a5b0e4d5282ee5a5af26aa605d60a4d7e" title="Initializes the resampler.">nn::audio::InitializeResampler()</a></code> function. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>*pOutputSampleCount</em></code> data with changed frequency is written to <code><em>pOutputBuffer</em></code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a20de4a3eb5e5c4fba0f3b45e0b9e24c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20de4a3eb5e5c4fba0f3b45e0b9e24c8">&#9670;&nbsp;</a></span>GetSampleByteSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::audio::GetSampleByteSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1">SampleFormat</a>&#160;</td>
          <td class="paramname"><em>sampleFormat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size in bytes of an audio sample represented by the specified sample format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleFormat</td><td>Sample format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the size in bytes of the sample represented by <code><em>sampleFormat</em></code>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>None. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>None. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a83">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a61">AudioOut/AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_2_audio_out_with_resampler_8cpp-example.html#a59">AudioOutWithResampler/AudioOutWithResampler.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a115">AudioSink/AudioSink.cpp</a>, and <a class="el" href="_codec_aac_decoder_2_codec_aac_decoder_8cpp-example.html#a27">CodecAacDecoder/CodecAacDecoder.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae8e93a633168c40c9b716c88c49c5e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e93a633168c40c9b716c88c49c5e47">&#9670;&nbsp;</a></span>AddDeviceSink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::AddDeviceSink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_device_sink_type.html">DeviceSinkType</a> *&#160;</td>
          <td class="paramname"><em>pOutSink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pFinalMix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inputCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a sink for the audio output device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td><code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSink</td><td>Pointer to a <code>Sink</code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFinalMix</td><td>The <code>FinalMix</code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The array of indexes for the mix buffers that serve as input to the <code>Sink</code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputCount</td><td>Number of indices of mix buffers that serve as input for the sink. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the audio output device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html">nn::audio::ResultOutOfResource</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li>The <code>AudioRenderer</code> associated with <code><em>pOutConfig</em></code> is stopped.</li>
<li>The operating mode of the <code>AudioRenderer</code> object linked to <code><em>pOutConfig</em></code> is <code><a class="el" href="namespacenn_1_1audio.html#abfe8ba78d8df1cffa01e726924471e35a794cd663cfcf7d70450fcf317f7ecf45" title="Executes rendering automatically.">nn::audio::AudioRendererExecutionMode_AutoExecution</a></code>.</li>
<li><code><em>pOutSink</em></code> != <code>nullptr</code>.</li>
<li><code><em>pFinalMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>input</em></code> != <code>nullptr</code>.</li>
<li><code>0</code> &lt; <code><em>inputCount</em></code> &amp;&amp; <code><em>inputCount</em></code> &lt;= <code><a class="el" href="namespacenn_1_1audio.html#a2519dd3580c74c1abf2d1ae868304f39" title="The maximum number of mix buffers that can be created for a single instance of SubMix or FinalMix.">nn::audio::MixBufferCountMax</a></code>.</li>
<li><code><em>inputCount</em></code> &lt;= <code><a class="el" href="namespacenn_1_1audio.html#a7652eae684b0d267e276cf7c01ac12d7">nn::audio::GetFinalMixBufferCount(pFinalMix)</a></code>.</li>
<li><code><em>name</em></code> is a valid object.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Used to output the content of mix buffers to audio output devices. The content is output for the mix buffers whose indexes were specified by <code><em>input</em></code>. For <em>N</em> number of audio output device channels:</p><ul>
<li>If <code><em>inputCount</em></code> &gt; <em>N</em>, channels <code>input[0]</code> through <code>input[<em>N</em>  1]</code> are applied to the output.</li>
<li>If <code><em>inputCount</em></code> &lt; <em>N</em>, <code>input[0]</code> through <code>input[<code>inputCount</code>  1]</code> is applied to the output. Output is silent for channels from the <code><em>inputCount</em></code> position onward.</li>
</ul>
<p><code>DeviceSink</code> may perform downmixing depending on the platform. For more information, see Sink in the <a href="../../Package/contents/Pages/Page_89991492.html">Audio Renderer</a> documentation.</p>
<p>Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a108">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a131">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a99">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a91">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a34">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a68">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a70">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a87">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a93">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a46">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a87">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#a41">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#a47">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a66">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a5fa6de7dd4ac31f578bc0ea50d857cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa6de7dd4ac31f578bc0ea50d857cf5">&#9670;&nbsp;</a></span>RemoveDeviceSink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::RemoveDeviceSink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_device_sink_type.html">DeviceSinkType</a> *&#160;</td>
          <td class="paramname"><em>pSink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pFinalMix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finalizes a sink for the audio output device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td><code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pSink</td><td>Pointer to a <code>Sink</code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFinalMix</td><td>The <code>FinalMix</code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li>The <code>AudioRenderer</code> associated with <code><em>pOutConfig</em></code> is stopped.</li>
<li><code><em>pSink</em></code> != <code>nullptr</code>.</li>
<li><code><em>pFinalMix</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="abdc3e7a542ed11a8d218214377c4e511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc3e7a542ed11a8d218214377c4e511">&#9670;&nbsp;</a></span>SetDownMixParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetDownMixParameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_device_sink_type.html">DeviceSinkType</a> *&#160;</td>
          <td class="paramname"><em>pSink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_device_sink_type_1_1_down_mix_parameter.html">DeviceSinkType::DownMixParameter</a> *&#160;</td>
          <td class="paramname"><em>pParameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the parameter to use for downmixing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSink</td><td>The audio output device for which to set the parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pParameter</td><td>The parameter value to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pSink</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSink</em></code> is initialized.</li>
<li><code><em>pParameter</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> has a system default downmixing process. When the number of channels for the audio output devices is set to two-channel or monaural output, this default process downmixes the output from 6 channels to 2 channels for all audio outputs on the platform and for the audio renderer. For more information about the downmixing calculations performed at this time, see <code><a class="el" href="structnn_1_1audio_1_1_device_sink_type.html" title="Sink to output the rendering results to the audio output device.">DeviceSinkType</a></code> in the <a href="../../Package/contents/Pages/Page_89991492.html">Audio Renderer</a> documentation.</p>
<p>But the audio renderer also has a process for application-specific downmixing. When application-specific downmixing is enabled, each audio renderer can downmix using any specified coefficient instead of the system default process. However, this process is specific to each audio renderer, so <code>PerformanceEntryType_Sink</code> for <code><a class="el" href="structnn_1_1audio_1_1_performance_entry.html" title="Performance information for each instance of VoiceType, SubMixType, and FinalMixType.">nn::audio::PerformanceEntry</a></code> takes longer to process.</p>
<p>This function sets the parameter to use for application-specific downmixing. For application-specific downmixing to work, you must enable the process using <code><a class="el" href="namespacenn_1_1audio.html#ae390b4fb4f79f895e18e24c93ac4483b" title="Sets whether to enable application-specific downmixing.">nn::audio::SetDownMixParameterEnabled()</a></code> in addition to setting the parameter using this function. For more information about the relationship between the value specified by <code><em>pParameter</em></code> and the calculation performed for downmixing, see the <code><a class="el" href="structnn_1_1audio_1_1_device_sink_type.html" title="Sink to output the rendering results to the audio output device.">DeviceSinkType</a></code> section in the <a href="../../Package/contents/Pages/Page_89991492.html">Audio Renderer</a> documentation.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pSink</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a120">AudioDevice/AudioDevice.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a654435955efb9603980adb8fd7ad4a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a654435955efb9603980adb8fd7ad4a6a">&#9670;&nbsp;</a></span>GetDownMixParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::GetDownMixParameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_device_sink_type_1_1_down_mix_parameter.html">DeviceSinkType::DownMixParameter</a> *&#160;</td>
          <td class="paramname"><em>pOutParameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_device_sink_type.html">DeviceSinkType</a> *&#160;</td>
          <td class="paramname"><em>pSink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the parameter to use for downmixing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutParameter</td><td>A pointer to the location of the parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSink</td><td>The audio output device for which to set the parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pSink</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSink</em></code> is initialized.</li>
<li><code><em>pParameter</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the parameter set by <code><a class="el" href="namespacenn_1_1audio.html#abdc3e7a542ed11a8d218214377c4e511" title="Sets the parameter to use for downmixing.">nn::audio::SetDownMixParameter()</a></code>. If no value is specified, by default all <code><a class="el" href="structnn_1_1audio_1_1_device_sink_type_1_1_down_mix_parameter.html#a3b55480ebd9479799e6dcf604ac80699" title="The coefficient sequence to use for downmixing.">nn::audio::DeviceSinkType::DownMixParameter::coeff</a>[]</code> take <code>0.0f</code>.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pSink</em></code> while calling this function. </p>

</div>
</div>
<a id="ae390b4fb4f79f895e18e24c93ac4483b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae390b4fb4f79f895e18e24c93ac4483b">&#9670;&nbsp;</a></span>SetDownMixParameterEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetDownMixParameterEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_device_sink_type.html">DeviceSinkType</a> *&#160;</td>
          <td class="paramname"><em>pSink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether to enable application-specific downmixing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSink</td><td>The audio output device to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enabled</td><td>Set this parameter to <code>true</code> to enable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pSink</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSink</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 To enable application-specific downmixing, call this function with <code><em>enabled</em></code> set to <code>true</code>. Setting this parameter to <code>false</code> enables the system default downmixing process. For more information about the different downmixing calculations, see <code><a class="el" href="namespacenn_1_1audio.html#abdc3e7a542ed11a8d218214377c4e511" title="Sets the parameter to use for downmixing.">nn::audio::SetDownMixParameter()</a></code> and <code><a class="el" href="structnn_1_1audio_1_1_device_sink_type.html" title="Sink to output the rendering results to the audio output device.">DeviceSinkType</a></code> in the <a href="../../Package/contents/Pages/Page_89991492.html">Audio Renderer</a> documentation.</p>
<p>The default is <code>false</code>.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pSink</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a121">AudioDevice/AudioDevice.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a07de192db43f64e0af3da756478f8858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07de192db43f64e0af3da756478f8858">&#9670;&nbsp;</a></span>IsDownMixParameterEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::IsDownMixParameterEnabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_device_sink_type.html">DeviceSinkType</a> *&#160;</td>
          <td class="paramname"><em>pSink</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get whether application-specific downmixing is enabled or disabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSink</td><td>The audio output device to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if enabled. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pSink</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSink</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Application-specific downmixing can be enabled and disabled using the <code><a class="el" href="namespacenn_1_1audio.html#ae390b4fb4f79f895e18e24c93ac4483b" title="Sets whether to enable application-specific downmixing.">nn::audio::SetDownMixParameterEnabled()</a></code> function.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pSink</em></code> while calling this function. </p>

</div>
</div>
<a id="af781d15dcac44311d87e69ccab19cf57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af781d15dcac44311d87e69ccab19cf57">&#9670;&nbsp;</a></span>AddCircularBufferSink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::audio::AddCircularBufferSink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_circular_buffer_sink_type.html">CircularBufferSinkType</a> *&#160;</td>
          <td class="paramname"><em>pOutSink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pFinalMix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inputCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1">SampleFormat</a>&#160;</td>
          <td class="paramname"><em>sampleFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes <code>Sink</code> for a circular buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td><code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSink</td><td>Pointer to a <code>Sink</code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFinalMix</td><td>The <code>FinalMix</code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The array of indexes for the mix buffers that serve as input to the <code>Sink</code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputCount</td><td>Number of indices of mix buffers that serve as input for the sink. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Address of the output destination buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the buffer specified for <code><em>buffer</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleFormat</td><td>The sample format of the sample data written to the <code><em>buffer</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1audio_1_1_result_out_of_resource.html">nn::audio::ResultOutOfResource</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pOutSink</em></code> != <code>nullptr</code>.</li>
<li><code><em>pFinalMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>input</em></code> != <code>nullptr</code>.</li>
<li><code>0</code> &lt; <code><em>inputCount</em></code> &amp;&amp; <code><em>inputCount</em></code> &lt;= <code><a class="el" href="namespacenn_1_1audio.html#a2519dd3580c74c1abf2d1ae868304f39" title="The maximum number of mix buffers that can be created for a single instance of SubMix or FinalMix.">nn::audio::MixBufferCountMax</a></code>.</li>
<li><code><em>inputCount</em></code> &lt;= <code><a class="el" href="namespacenn_1_1audio.html#a7652eae684b0d267e276cf7c01ac12d7">nn::audio::GetFinalMixBufferCount(pFinalMix)</a></code>.</li>
<li><code><em>buffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>buffer</em></code> is aligned to <code><a class="el" href="namespacenn_1_1audio.html#a61833f2e2cf0253e3054188e900315af" title="The alignment size for audio buffers.">nn::audio::BufferAlignSize</a></code>.</li>
<li><code><em>sampleFormat</em></code> == <code>SampleFormat_PcmInt16</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The <code>Sink</code> for the circular buffer is used to output the contents of the mix buffers to the specified memory. The array specified for <code><em>input</em></code> is an array of indexes for mix buffers managed by the <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> specified by <code><em>pFinalMix</em></code>. To get the waveforms that are the final output to the audio renderer device associated with <code><em>pOutConfig</em></code>, specify the same array as was specified for the <code><em>input</em></code> parameter of <code><a class="el" href="structnn_1_1audio_1_1_device_sink_type.html" title="Sink to output the rendering results to the audio output device.">nn::audio::DeviceSinkType</a></code>.</p>
<p>The sample data is output to the memory space specified by <code><em>buffer</em></code> and <code><em>size</em></code>. The output sample data will be formatted in the format specified by <code><em>sampleFormat</em></code>. If <code><em>inputCount</em></code> &gt; <code>1</code>, sample data that was block interleaved to the <code><em>buffer</em></code> will be output. For more information, see <code><a class="el" href="namespacenn_1_1audio.html#a38ea8ebfb7f48ae04043e2103d4c8a58" title="Load sample data from the circular buffer Sink.">nn::audio::ReadCircularBufferSink()</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li><code><em>sampleFormat</em></code> only supports <code>SampleFormat_PcmInt16</code> in the current release.</li>
<li>The memory region specified for <code><em>buffer</em></code> must be contained within the memory region specified for <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html" title="Structure for representing memory regions used by an audio renderer.">nn::audio::MemoryPoolType</a></code>.</li>
<li>Also, the instance of <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html" title="Structure for representing memory regions used by an audio renderer.">nn::audio::MemoryPoolType</a></code> that contains the memory region specified for <code><em>buffer</em></code> must be in the attached state.</li>
</ul>
</dd></dl>
<p>Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a87">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, and <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a85">AudioSink/AudioSink.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a474950248dbba54eb5973c722b64acf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474950248dbba54eb5973c722b64acf7">&#9670;&nbsp;</a></span>RemoveCircularBufferSink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::RemoveCircularBufferSink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_circular_buffer_sink_type.html">CircularBufferSinkType</a> *&#160;</td>
          <td class="paramname"><em>pSink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pFinalMix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finalizes a sink for a circular buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td><code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pSink</td><td>Pointer to a <code>Sink</code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFinalMix</td><td>The <code>FinalMix</code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pSink</em></code> != <code>nullptr</code>.</li>
<li><code><em>pFinalMix</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="a691cf6276a2d79af683e204a38426177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691cf6276a2d79af683e204a38426177">&#9670;&nbsp;</a></span>GetRequiredBufferSizeForCircularBufferSink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::audio::GetRequiredBufferSizeForCircularBufferSink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html">AudioRendererParameter</a> *&#160;</td>
          <td class="paramname"><em>pParameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inputCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frameCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1">SampleFormat</a>&#160;</td>
          <td class="paramname"><em>sampleFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the buffer size required for the circular buffer <code>Sink</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pParameter</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html" title="The audio renderer parameters.">AudioRendererParameter</a></code> object that is specified when you get the audio renderer to which the circular buffer <code>Sink</code> is added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputCount</td><td>The number of indexes for the mixed buffer that is used as input to the circular buffer <code>Sink</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frameCount</td><td>The number of audio frames maintained by the circular buffer <code>Sink</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleFormat</td><td>The sample format output by the circular buffer <code>Sink</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the buffer size required for the circular buffer <code>Sink</code> for the specified settings. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pParameter</em></code> != <code>nullptr</code>.</li>
<li><code>0</code> &lt; <code><em>inputCount</em></code> &amp;&amp; <code><em>inputCount</em></code> &lt;= <code><a class="el" href="namespacenn_1_1audio.html#a2519dd3580c74c1abf2d1ae868304f39" title="The maximum number of mix buffers that can be created for a single instance of SubMix or FinalMix.">nn::audio::MixBufferCountMax</a></code>.</li>
<li><code>0</code> &lt; <code><em>frameCount</em></code>.</li>
<li><code><em>sampleFormat</em></code> == <code>SampleFormat_PcmInt16</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code><em>inputCount</em></code> specifies the number of mixed buffers for specifying input for the circular buffer <code>Sink</code>. (This number corresponds to the value specified for the <code><em>inputCount</em></code> parameter of <code><a class="el" href="namespacenn_1_1audio.html#af781d15dcac44311d87e69ccab19cf57" title="Initializes Sink for a circular buffer.">nn::audio::AddCircularBufferSink()</a></code>.) <code><em>frameCount</em></code> specifies the length of buffers stored in the circular buffer <code>Sink</code> as a number of audio frames. The length of one audio frame is equivalent to the number of samples specified in <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html#a1c8b7223c7e2ce641691f4e4f93000dd" title="The number of samples maintained by one mix buffer.">AudioRendererParameter.sampleCount</a></code>. <code><em>sampleFormat</em></code> specifies the format of the sample output by the circular buffer <code>Sink</code>. (<code><em>sampleFormat</em></code> only supports <code>SampleFormat_PcmInt16</code> in the current release.) </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a78">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, and <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a76">AudioSink/AudioSink.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a38ea8ebfb7f48ae04043e2103d4c8a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ea8ebfb7f48ae04043e2103d4c8a58">&#9670;&nbsp;</a></span>ReadCircularBufferSink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::audio::ReadCircularBufferSink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_circular_buffer_sink_type.html">CircularBufferSinkType</a> *&#160;</td>
          <td class="paramname"><em>pSink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pOutBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load sample data from the circular buffer <code>Sink</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSink</td><td><code><em>pSink</em></code> with audio renderer added. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutBuffer</td><td>Loading destination buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of the buffer specified in <code><em>pOutBuffer</em></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the size of the sample data that was read by <code><em>pOutBuffer</em></code>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pSink</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSink</em></code> is initialized.</li>
<li><code><em>pOutBuffer</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Load the sample data stored in <code><em>pSink</em></code> to <code><em>pOutBuffer</em></code>. The circular buffer <code>Sink</code> controls each of the "positions that have already been written by the audio buffer" and the "positions loaded by this function." This function loads sample data that has not completed loading to <code><em>pOutBuffer</em></code> while it references these positions, using <code><em>bufferSize</em></code> as the maximum. If the data already written to <code><em>pSink</em></code> is smaller than <code><em>bufferSize</em></code>, only data already written will be loaded to <code><em>pOutBuffer</em></code>. In any case, the size of the sample data that was actually loaded to <code>pOutBuffer</code> will be the return value.</p>
<p>The data loaded to <code><em>pOutBuffer</em></code> will be the sample format specified by <code><em>sampleFormat</em></code> when <code><em>pSink</em></code> is initialized by <code><a class="el" href="namespacenn_1_1audio.html#af781d15dcac44311d87e69ccab19cf57" title="Initializes Sink for a circular buffer.">nn::audio::AddCircularBufferSink()</a></code>. In addition, the sample data will be block interleaved for each mix buffer. In other words, the number of samples for one audio frame will be stored for each mix buffer specified as an index by <code><a class="el" href="namespacenn_1_1audio.html#af781d15dcac44311d87e69ccab19cf57" title="Initializes Sink for a circular buffer.">nn::audio::AddCircularBufferSink()</a></code>.</p>
<p>For example, for an audio renderer obtained by specifying <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html" title="The audio renderer parameters.">AudioRendererParameter</a>.<em>sampleCount</em></code> = <code>240</code>, if <code><em>pSink</em></code> was initialized by <code><a class="el" href="namespacenn_1_1audio.html#af781d15dcac44311d87e69ccab19cf57" title="Initializes Sink for a circular buffer.">nn::audio::AddCircularBufferSink()</a></code> with <code><em>index</em>[]</code> = <code>{0, 1, 2}</code> and <code><em>sampleFormat</em></code> = <code>SampleFormat_PcmInt16</code>, the sample data stored in <code><em>pOutBuffer</em></code> is stored in the following order: (240 samples of 16-bit signed integer PCM sample data for <code>FinalMix</code> mix buffer index 0), (240 samples of 16-bit signed integer PCM sample data for <code>FinalMixM</code> mix buffer index 1), and (240 samples of 16-bit signed integer PCM sample data for <code>FinalMix</code> mix buffer index 2).</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pSink</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a148">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, and <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a114">AudioSink/AudioSink.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a4f5a02f991e12a4b638dd2a94ada088f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f5a02f991e12a4b638dd2a94ada088f">&#9670;&nbsp;</a></span>GetSinkNodeId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1audio.html#a347cdc16fef8e35aad9d8d0cd2e79e38">NodeId</a> nn::audio::GetSinkNodeId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_device_sink_type.html">DeviceSinkType</a> *&#160;</td>
          <td class="paramname"><em>pSink</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the ID of the <code><a class="el" href="structnn_1_1audio_1_1_device_sink_type.html" title="Sink to output the rendering results to the audio output device.">DeviceSinkType</a></code> in the audio renderer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSink</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_device_sink_type.html" title="Sink to output the rendering results to the audio output device.">DeviceSinkType</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>NodeId</code>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pSink</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSink</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code>NodeId</code> is a numeric value that uniquely identifies the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_device_sink_type.html" title="Sink to output the rendering results to the audio output device.">DeviceSinkType</a></code>, and <code><a class="el" href="structnn_1_1audio_1_1_circular_buffer_sink_type.html" title="Sink to output the rendering results to memory.">CircularBufferSinkType</a></code> objects registered to the audio renderer. The various <code>NodeId</code> objects are never duplicated within a single audio renderer. A <code>NodeId</code> is assigned for each instance of each added <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_device_sink_type.html" title="Sink to output the rendering results to the audio output device.">DeviceSinkType</a></code>, and <code><a class="el" href="structnn_1_1audio_1_1_circular_buffer_sink_type.html" title="Sink to output the rendering results to memory.">CircularBufferSinkType</a></code>. </p>

</div>
</div>
<a id="aa47406b72adf5bef0659eda4247fa6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47406b72adf5bef0659eda4247fa6d6">&#9670;&nbsp;</a></span>GetSinkNodeId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1audio.html#a347cdc16fef8e35aad9d8d0cd2e79e38">NodeId</a> nn::audio::GetSinkNodeId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_circular_buffer_sink_type.html">CircularBufferSinkType</a> *&#160;</td>
          <td class="paramname"><em>pSink</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the ID of the <code><a class="el" href="structnn_1_1audio_1_1_circular_buffer_sink_type.html" title="Sink to output the rendering results to memory.">CircularBufferSinkType</a></code> object in the audio renderer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSink</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_circular_buffer_sink_type.html" title="Sink to output the rendering results to memory.">CircularBufferSinkType</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>NodeId</code>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pSink</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSink</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code>NodeId</code> is a numeric value that uniquely identifies the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_device_sink_type.html" title="Sink to output the rendering results to the audio output device.">DeviceSinkType</a></code>, and <code><a class="el" href="structnn_1_1audio_1_1_circular_buffer_sink_type.html" title="Sink to output the rendering results to memory.">CircularBufferSinkType</a></code> objects registered to the audio renderer. The various <code>NodeId</code> objects are never duplicated within a single audio renderer. A <code>NodeId</code> is assigned for each instance of each added <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_device_sink_type.html" title="Sink to output the rendering results to the audio output device.">DeviceSinkType</a></code>, and <code><a class="el" href="structnn_1_1audio_1_1_circular_buffer_sink_type.html" title="Sink to output the rendering results to memory.">CircularBufferSinkType</a></code>. </p>

</div>
</div>
<a id="a2d3b900b04b3704eab4aad529cc4cb37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3b900b04b3704eab4aad529cc4cb37">&#9670;&nbsp;</a></span>AcquireSplitter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::AcquireSplitter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_splitter_type.html">SplitterType</a> *&#160;</td>
          <td class="paramname"><em>pOutSplitter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourceChannelCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destinationCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code> object and adds it to <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when getting the audio renderer that will add <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSplitter</td><td>Pointer to an uninitialized <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleRate</td><td>Sampling rate specified for <code><em>pOutSplitter</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceChannelCount</td><td>The number of channels specified to <code><em>pOutSplitter</em></code> from the input source <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> / <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destinationCount</td><td>The total number of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> and <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> objects used for <code><em>pOutSplitter</em></code> output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the <code>Splitter</code> is available, or <code>false</code> if not. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pOutSplitter</em></code> != <code>nullptr</code>.</li>
<li><code><em>sampleRate</em></code> &gt; <code>0</code>.</li>
<li><code><em>sourceChannelCount</em></code> &gt;= <code>1</code>.</li>
<li><code><em>destinationCount</em></code> &gt;= <code>1</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pOutSplitter</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code> provides a feature to distribute sample data from the input source to multiple output destinations. Use <code><em>sampleRate</em></code> to specify the sample rate of the sample data distributed by <code><em>pOutSplitter</em></code>. This distribution process does not perform sample rate conversion. For that reason, the sample rate of the output destination specified by <code><a class="el" href="namespacenn_1_1audio.html#a364d3e39d547f60de643b7ad37011495" title="Specifies the SubMix as one output destination for SplitterType.">nn::audio::SetSplitterDestination()</a></code> must be identical to the sample rate specified by the <code><em>sampleRate</em></code> function.</p>
<p>The number of <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> channels or <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> mix buffers that are used as the input source for <code><em>pOutSplitter</em></code> is specified in <code><em>sourceChannelCount</em></code>.</p>
<p><code><em>destinationCount</em></code> specifies the total number of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> and <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> objects connected to <code><em>pOutSplitter</em></code>. <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code> can have up to the number of output destinations specified in <code><em>destinationCount</em></code>, and maintain individual mix volumes for each output destination. The various output destinations are identified by the index specified by <code><em>destinationIndex</em></code> in <code><a class="el" href="namespacenn_1_1audio.html#a364d3e39d547f60de643b7ad37011495" title="Specifies the SubMix as one output destination for SplitterType.">nn::audio::SetSplitterDestination()</a></code>, and this <code><em>destinationIndex</em></code> is defined by <code><em>destinationCount</em></code> as <code>0</code> &lt;= <code><em>destinationIndex</em></code> &lt; <code><em>destinationCount</em></code>.</p>
<p>The total number of <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code> objects that can be added is the number specified by <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html#ab0b24f2d4da9d78029ba1c78284da852" title="The maximum number of SplitterType instances used by the audio renderer.">nn::audio::AudioRendererParameter.splitterCount</a></code> when the audio renderer is initialized. In addition, the total number of channels that can be output from all <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code> objects is the number specified by the <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html#a789ae893e39d5c8112505e5bcbe1918e" title="The total number of channels to output from SplitterType.">nn::audio::AudioRendererParameter.splitterSendChannelCount</a></code> function. When this function adds one <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code> object, (<code><em>sourceChannelCount</em></code> * <code><em>destinationCount</em></code>) channels are used.</p>
<p>If this function returns false, there may be an insufficient number of <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html#ab0b24f2d4da9d78029ba1c78284da852" title="The maximum number of SplitterType instances used by the audio renderer.">nn::audio::AudioRendererParameter.splitterCount</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html#a789ae893e39d5c8112505e5bcbe1918e" title="The total number of channels to output from SplitterType.">nn::audio::AudioRendererParameter.splitterSendChannelCount</a></code>.</p>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code>AcquireSplitter(AudioRendererConfig* <em>pOutConfig</em>, SplitterType* <em>pOutSplitter</em>, int <em>sampleRate</em>, int <em>sourceChannelCount</em>, int <em>destinationCount</em>)</code></li>
<li><code>ReleaseSplitter(AudioRendererConfig* <em>pOutConfig</em>, SplitterType* <em>pOutSplitter</em>)</code></li>
<li><code>SetSplitterDestination(AudioRendererConfig* <em>pOutConfig</em>, SplitterType* <em>pOutSource</em>, int <em>destinationIndex</em>, SubMixType* <em>pDestination</em>)</code></li>
<li><code>SetSplitterDestination(AudioRendererConfig* <em>pOutConfig</em>, SplitterType* <em>pOutSource</em>, int <em>destinationIndex</em>, FinalMixType* <em>pDestination</em>)</code></li>
<li><code>ClearSplitterDestination(AudioRendererConfig* <em>pOutConfig</em>, SplitterType* <em>pOutSource</em>, int <em>destinationIndex</em>)</code></li>
</ul>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pOutConfig</em></code> or <code><em>pOutSplitter</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a129">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a9ad46c1c8a8f652e4223ac091cea7f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad46c1c8a8f652e4223ac091cea7f8c">&#9670;&nbsp;</a></span>ReleaseSplitter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::ReleaseSplitter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_splitter_type.html">SplitterType</a> *&#160;</td>
          <td class="paramname"><em>pOutSplitter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> from <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td><code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when adding <code><em>pOutSplitter</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSplitter</td><td><code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code> to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pOutSplitter</em></code> != <code>nullptr</code>.</li>
<li><code><code>pOutSplitter</code></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code>AcquireSplitter(AudioRendererConfig* <em>pOutConfig</em>, SplitterType* <em>pOutSplitter</em>, int <em>sampleRate</em>, int <em>sourceChannelCount</em>, int <em>destinationCount</em>)</code></li>
<li><code>ReleaseSplitter(AudioRendererConfig* <em>pOutConfig</em>, SplitterType* <em>pOutSplitter</em>)</code></li>
<li><code>SetSplitterDestination(AudioRendererConfig* <em>pOutConfig</em>, SplitterType* <em>pOutSource</em>, int <em>destinationIndex</em>, SubMixType* <em>pDestination</em>)</code></li>
<li><code>SetSplitterDestination(AudioRendererConfig* <em>pOutConfig</em>, SplitterType* <em>pOutSource</em>, int <em>destinationIndex</em>, FinalMixType* <em>pDestination</em>)</code></li>
<li><code>ClearSplitterDestination(AudioRendererConfig* <em>pOutConfig</em>, SplitterType* <em>pOutSource</em>, int <em>destinationIndex</em>)</code></li>
</ul>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pOutConfig</em></code> or <code><em>pOutSplitter</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a156">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a364d3e39d547f60de643b7ad37011495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a364d3e39d547f60de643b7ad37011495">&#9670;&nbsp;</a></span>SetSplitterDestination() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetSplitterDestination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_splitter_type.html">SplitterType</a> *&#160;</td>
          <td class="paramname"><em>pOutSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destinationIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pDestination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies the <code>SubMix</code> as one output destination for <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td><code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when adding <code><em>pOutSplitter</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSource</td><td><code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code> that specifies the output destinations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destinationIndex</td><td><code><em>pOutSource</em></code> output destination index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pDestination</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> specified as the output destination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code>0</code> &lt;= <code><em>destinationIndex</em></code> &lt; <code><a class="el" href="namespacenn_1_1audio.html#ab996d1af1b2b5590d8afbdb205277044">nn::audio::GetSplitterDestinationCount(pOutSource)</a></code>.</li>
<li><code><em>pOutSource</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutSource</em></code> is initialized.</li>
<li><code><em>pDestination</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDestination</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a8be6d0e347070786c6a7805986982fc3">nn::audio::GetSplitterSampleRate(pOutSource)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#a331b58a86c70fe45bf649941db3ca55e">nn::audio::GetSubMixSampleRate(pDestination)</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code> can have a number of output destinations equivalent to the value specified by the <code><em>destinationCount</em></code> parameter in the <code><a class="el" href="namespacenn_1_1audio.html#a2d3b900b04b3704eab4aad529cc4cb37" title="Initializes a SplitterType object and adds it to AudioRendererConfig.">nn::audio::AcquireSplitter()</a></code> function. This function specifies <code><em>pDestination</em></code> as the <code><em>destinationIndex</em></code> number output destination of the <code><em>pOutSource</em></code>. <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code> does not perform sample rate conversion. For this reason, the sample rate of the output destination specified for <code><em>pDestination</em></code> must be identical to the sample rate obtained with <code><a class="el" href="namespacenn_1_1audio.html#a8be6d0e347070786c6a7805986982fc3">nn::audio::GetSplitterSampleRate(pOutSource)</a></code>.</p>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code>AcquireSplitter(AudioRendererConfig* <em>pOutConfig</em>, SplitterType* <em>pOutSplitter</em>, int <em>sampleRate</em>, int <em>sourceChannelCount</em>, int <em>destinationCount</em>)</code></li>
<li><code>ReleaseSplitter(AudioRendererConfig* <em>pOutConfig</em>, SplitterType* <em>pOutSplitter</em>)</code></li>
<li><code>SetSplitterDestination(AudioRendererConfig* <em>pOutConfig</em>, SplitterType* <em>pOutSource</em>, int <em>destinationIndex</em>, SubMixType* <em>pDestination</em>)</code></li>
<li><code>SetSplitterDestination(AudioRendererConfig* <em>pOutConfig</em>, SplitterType* <em>pOutSource</em>, int <em>destinationIndex</em>, FinalMixType* <em>pDestination</em>)</code></li>
<li><code>ClearSplitterDestination(AudioRendererConfig* <em>pOutConfig</em>, SplitterType* <em>pOutSource</em>, int <em>destinationIndex</em>)</code></li>
</ul>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pOutConfig</em></code> or <code><em>pOutSplitter</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a130">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a046c9026c45c15030effcbc167a268fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a046c9026c45c15030effcbc167a268fa">&#9670;&nbsp;</a></span>SetSplitterDestination() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetSplitterDestination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_splitter_type.html">SplitterType</a> *&#160;</td>
          <td class="paramname"><em>pOutSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destinationIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pDestination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies <code>FinalMixMix</code> as one output destination for <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td><code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when adding <code><em>pOutSplitter</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSource</td><td><code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code> that specifies the output destinations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destinationIndex</td><td><code><em>pOutSource</em></code> output destination index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pDestination</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> specified as the output destination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pOutSource</em></code> is initialized.</li>
<li><code><em>pOutSource</em></code> != <code>nullptr</code>.</li>
<li><code>0</code> &lt;= <code><em>destinationIndex</em></code> &lt; <code><a class="el" href="namespacenn_1_1audio.html#ab996d1af1b2b5590d8afbdb205277044">nn::audio::GetSplitterDestinationCount(pOutSource)</a></code>.</li>
<li><code><em>pDestination</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDestination</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a8be6d0e347070786c6a7805986982fc3">nn::audio::GetSplitterSampleRate(pOutSource)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#a09b00eec5745f59f461c43723ed965f3">nn::audio::GetFinalMixSampleRate(pDestination)</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The features of this function are identical to <code><a class="el" href="namespacenn_1_1audio.html#a364d3e39d547f60de643b7ad37011495" title="Specifies the SubMix as one output destination for SplitterType.">nn::audio::SetSplitterDestination</a>(AudioRendererConfig* <em>pOutConfig</em>, SplitterType* <em>pOutSource</em>, int <em>destinationIndex</em>, SubMixType* <em>pDestination</em>)</code> except for the fact that the <code><em>pDestination</em></code> type is <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">nn::audio::FinalMixType</a></code>. For more information, see the API Reference. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="a32840807391ce6907daefb6092f02654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32840807391ce6907daefb6092f02654">&#9670;&nbsp;</a></span>ClearSplitterDestination()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::ClearSplitterDestination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_splitter_type.html">SplitterType</a> *&#160;</td>
          <td class="paramname"><em>pOutSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destinationIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the output destination specified for <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td><code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when adding <code><em>pOutSplitter</em></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSource</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destinationIndex</td><td><code><em>pOutSource</em></code> output destination index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pOutSplitter</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutSplitter</em></code> is initialized.</li>
<li><code>0</code> &lt;= <code><em>destinationIndex</em></code> &lt; <code><a class="el" href="namespacenn_1_1audio.html#ab996d1af1b2b5590d8afbdb205277044">nn::audio::GetSplitterDestinationCount(pOutSource)</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 For the operations on <code><em>pOutConfig</em></code> this function is thread-safe, but for the operations on <code><em>pOutSource</em></code> it is not thread-safe. Do not perform any operations on <code><em>pSource</em></code> while calling this function.</p>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code>AcquireFinalMix(AudioRendererConfig* pOutConfig, FinalMixType* <em>pOutFinalMix</em>, int <em>bufferCount</em>)</code></li>
<li><code>ReleaseFinalMix(AudioRendererConfig* <em>pOutConfig</em>, FinalMixType* <em>pFinalMix</em>)</code></li>
<li><code>AcquireSubMix(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pOutSubMix</em>, int <em>sampleRate</em>, int <em>bufferCount</em>)</code></li>
<li><code>ReleaseSubMix(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pSubMix</em>)</code></li>
<li><code>SetSubMixDestination(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pSource</em>, FinalMixType* <em>pDestination</em>)</code></li>
<li><code>SetSubMixDestination(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pSource</em>, SubMixType* <em>pDestination</em>)</code></li>
<li><code>ClearSubMixDestination(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pSource</em>)</code></li>
</ul>
<p>Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. For more information, see <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code>. </p>

</div>
</div>
<a id="a0d211a6bf9009d4067c320541c625bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d211a6bf9009d4067c320541c625bd2">&#9670;&nbsp;</a></span>SetSplitterMixVolume() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetSplitterMixVolume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_splitter_type.html">SplitterType</a> *&#160;</td>
          <td class="paramname"><em>pOutSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destinationIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pDestination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourceChannelIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destinationChannelIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the mix volume for the output destinations from <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSource</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code> that sets the volume. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destinationIndex</td><td>Output destination index that <code><em>pDestination</em></code> is connected to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pDestination</td><td><code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> set as the output destination. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">volume</td><td>Volume to configure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceChannelIndex</td><td>The number of <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> channels or <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> mix buffer index for the input source. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destinationChannelIndex</td><td>The index of the output destination <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> mix buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutSource</em></code> is initialized.</li>
<li><code><em>pOutSource</em></code> != <code>nullptr</code>.</li>
<li><code>0</code> &lt;= <code><em>destinationIndex</em></code> &lt; <code><a class="el" href="namespacenn_1_1audio.html#ab996d1af1b2b5590d8afbdb205277044">nn::audio::GetSplitterDestinationCount(pOutSource)</a></code>.</li>
<li>The number <code><em>destinationIndex</em></code> output destination of <code><em>pOutSource</em></code> is connected to <code><em>pDestination</em></code>.</li>
<li><code><em>pDestination</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDestination</em></code> is initialized.</li>
<li><code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html#ac601862eaae31a65e14beed358bc74ca" title="The minimum value that can be set for the volume (-128.0f).">nn::audio::SplitterType::GetVolumeMin()</a></code> &lt;= <code><em>volume</em></code> &amp;&amp; <code><em>volume</em></code> &lt;= <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html#a14cdda2afc890e9eed05dbe16937a036" title="The maximum value that can be set for the mix volume (128.0f).">nn::audio::SplitterType::GetVolumeMax</a></code>.</li>
<li><code>0</code> &lt;= <code><em>sourceChannelIndex</em></code> &amp;&amp; <code><em>souceChannelIndex</em></code> &lt;= <code><a class="el" href="namespacenn_1_1audio.html#a7bfc327793ff4c5abbd780033c1f93ae">nn::audio::GetSplitterSourceChannelCount(pOutSouce)</a></code>.</li>
<li><code>0</code> &lt;= <code><em>destinationChannelIndex</em></code> &amp;&amp; <code><em>destinationChannelIndex</em></code> &lt;= <code><a class="el" href="namespacenn_1_1audio.html#ad76ce2e4c558f038dab51a3a30c068e4">nn::audio::GetSubMixBufferCount(pDestination)</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The default value for all mix volume is <code>0.0f</code>.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pOutSource</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p><dl class="section note"><dt>Note</dt><dd>Audio cutoff may occur depending on the set volume value. If audio cutoff occurs, verify that the volume is within appropriate values. If a negative volume value is set, the phase of the waveform is inverted. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a132">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af0f501358997f8809b249a64ecb74e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f501358997f8809b249a64ecb74e05">&#9670;&nbsp;</a></span>SetSplitterMixVolume() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetSplitterMixVolume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_splitter_type.html">SplitterType</a> *&#160;</td>
          <td class="paramname"><em>pOutSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destinationIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pDestination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourceChannelIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destinationChannelIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the mix volume for the output destinations from <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSource</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code> that sets the volume. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destinationIndex</td><td>Output destination index that <code><em>pDestination</em></code> is connected to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pDestination</td><td><code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> set as the output destination. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">volume</td><td>Volume to configure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceChannelIndex</td><td>The number of <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> channels or <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> mix buffer index for the input source. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destinationChannelIndex</td><td>The index of the output destination <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> mix buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutSource</em></code> is initialized.</li>
<li><code><em>pOutSource</em></code> != <code>nullptr</code>.</li>
<li><code>0</code> &lt;= <code><em>destinationIndex</em></code> &lt; <code><a class="el" href="namespacenn_1_1audio.html#ab996d1af1b2b5590d8afbdb205277044">nn::audio::GetSplitterDestinationCount(pOutSource)</a></code>.</li>
<li>The number <code><em>destinationIndex</em></code> output destination of <code><em>pOutSource</em></code> is connected to <code><em>pDestination</em></code>.</li>
<li><code><em>pDestination</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDestination</em></code> is initialized.</li>
<li><code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html#ac601862eaae31a65e14beed358bc74ca" title="The minimum value that can be set for the volume (-128.0f).">nn::audio::SplitterType::GetVolumeMin()</a></code> &lt;= <code><em>volume</em></code> &amp;&amp; <code><em>volume</em></code> &lt;= <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html#a14cdda2afc890e9eed05dbe16937a036" title="The maximum value that can be set for the mix volume (128.0f).">nn::audio::SplitterType::GetVolumeMax()</a></code>.</li>
<li><code>0</code> &lt;= <code><em>sourceChannelIndex</em></code> &amp;&amp; <code><em>souceChannelIndex</em></code> &lt;= <code><a class="el" href="namespacenn_1_1audio.html#a7bfc327793ff4c5abbd780033c1f93ae">nn::audio::GetSplitterSourceChannelCount(pOutSouce)</a></code>.</li>
<li><code>0</code> &lt;= <code><em>destinationChannelIndex</em></code> &amp;&amp; <code><em>destinationChannelIndex</em></code> &lt;= <code><a class="el" href="namespacenn_1_1audio.html#a7652eae684b0d267e276cf7c01ac12d7">nn::audio::GetFinalMixBufferCount(pDestination)</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The features of this function are identical to <code><a class="el" href="namespacenn_1_1audio.html#a0d211a6bf9009d4067c320541c625bd2" title="Sets the mix volume for the output destinations from SplitterType.">nn::audio::SetSplitterMixVolume</a>(SplitterType* <em>pOutSource</em>, int <em>destinationIndex</em>, SubMixType* <em>pDestination</em>, float <em>volume</em>, int <em>sourceChannelIndex</em>, int <em>destinationChannelIndex</em>)</code> except for the fact that the <code><em>pDestination</em></code> type is <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">nn::audio::FinalMixType</a></code>. For more information, see the API Reference. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="ad82155de4e1539ef1356f504f97d8993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad82155de4e1539ef1356f504f97d8993">&#9670;&nbsp;</a></span>GetSplitterMixVolume() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetSplitterMixVolume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_splitter_type.html">SplitterType</a> *&#160;</td>
          <td class="paramname"><em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destinationIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pDestination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourceChannelIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destinationChannelIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the mix volume for the output destinations from <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSource</td><td><code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code> that gets the volume. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destinationIndex</td><td>Output destination index that <code><em>pDestination</em></code> is connected to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pDestination</td><td><code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> set as the output destination. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceChannelIndex</td><td>The number of <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> channels or <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> mix buffer index for the input source. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destinationChannelIndex</td><td>The index of the output destination <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> mix buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the mix volume. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pSource</em></code> is initialized.</li>
<li><code><em>pSource</em></code> != <code>nullptr</code>.</li>
<li><code>0</code> &lt;= <code><em>destinationIndex</em></code> &lt; <code><a class="el" href="namespacenn_1_1audio.html#ab996d1af1b2b5590d8afbdb205277044">nn::audio::GetSplitterDestinationCount(pSource)</a></code>.</li>
<li>The number <code><em>destinationIndex</em></code> output destination of <code><em>pSource</em></code> is connected to <code><em>pDestination</em></code>.</li>
<li><code><em>pDestination</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDestination</em></code> is initialized.</li>
<li><code>0</code> &lt;= <code><em>sourceChannelIndex</em></code> &amp;&amp; <code><em>souceChannelIndex</em></code> &lt;= <code><a class="el" href="namespacenn_1_1audio.html#a7bfc327793ff4c5abbd780033c1f93ae">nn::audio::GetSplitterSourceChannelCount(pSouce)</a></code>.</li>
<li><code>0</code> &lt;= <code><em>destinationChannelIndex</em></code> &amp;&amp; <code><em>destinationChannelIndex</em></code> &lt;= <code><a class="el" href="namespacenn_1_1audio.html#a7652eae684b0d267e276cf7c01ac12d7">nn::audio::GetFinalMixBufferCount(pDestination)</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the mix volume set by <code><a class="el" href="namespacenn_1_1audio.html#a0d211a6bf9009d4067c320541c625bd2">nn::audio::SetSplitterMixVolume(SplitterType* pSource, int destinationIndex, SubMixType* pDestination, float volume, int sourceChannelIndex, int destinationChannelIndex)</a></code>.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pSplitter</em></code> while calling this function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a155">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a403ec19365da9d1bc92ebd379d7e5e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a403ec19365da9d1bc92ebd379d7e5e55">&#9670;&nbsp;</a></span>GetSplitterMixVolume() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetSplitterMixVolume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_splitter_type.html">SplitterType</a> *&#160;</td>
          <td class="paramname"><em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destinationIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pDestination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourceChannelIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destinationChannelIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the mix volume for the output destinations from <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSource</td><td><code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code> that gets the volume. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destinationIndex</td><td>Output destination index that <code><em>pDestination</em></code> is connected to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pDestination</td><td><code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> set as the output destination. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceChannelIndex</td><td>The number of <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> channels or <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> mix buffer index for the input source. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destinationChannelIndex</td><td>The index of the output destination <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> mix buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the mix volume. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pSource</em></code> is initialized.</li>
<li><code><em>pSource</em></code> != <code>nullptr</code>.</li>
<li><code>0</code> &lt;= <code><em>destinationIndex</em></code> &lt; <code><a class="el" href="namespacenn_1_1audio.html#ab996d1af1b2b5590d8afbdb205277044">nn::audio::GetSplitterDestinationCount(pSource)</a></code>.</li>
<li>The number <code><em>destinationIndex</em></code> output destination of <code><em>pSource</em></code> is connected to <code><em>pDestination</em></code>.</li>
<li><code><em>pDestination</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDestination</em></code> is initialized.</li>
<li><code>0</code> &lt;= <code><em>sourceChannelIndex</em></code> &amp;&amp; <code><em>souceChannelIndex</em></code> &lt;= <code><a class="el" href="namespacenn_1_1audio.html#a7bfc327793ff4c5abbd780033c1f93ae">nn::audio::GetSplitterSourceChannelCount(pSouce)</a></code>.</li>
<li><code>0</code> &lt;= <code><em>destinationChannelIndex</em></code> &amp;&amp; <code><em>destinationChannelIndex</em></code> &lt;= <code><a class="el" href="namespacenn_1_1audio.html#a7652eae684b0d267e276cf7c01ac12d7">nn::audio::GetFinalMixBufferCount(pDestination)</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 With the exception that <code><em>pDestination</em></code> is type <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">nn::audio::FinalMixType</a></code>, this function works the same as <code><a class="el" href="namespacenn_1_1audio.html#ad82155de4e1539ef1356f504f97d8993">nn::audio::GetSplitterMixVolume(const SplitterType* pSource, int destinationIndex, const SubMixType* pDestination, int sourceChannelIndex, int destinationChannelIndex)</a></code>. For more information, see the API Reference. </p>

</div>
</div>
<a id="a7bfc327793ff4c5abbd780033c1f93ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bfc327793ff4c5abbd780033c1f93ae">&#9670;&nbsp;</a></span>GetSplitterSourceChannelCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetSplitterSourceChannelCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_splitter_type.html">SplitterType</a> *&#160;</td>
          <td class="paramname"><em>pSource</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of input channels for <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSource</td><td><code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code> that gets the number of channels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of channels. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pSource</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSource</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the number of input channels from the input source specified for <code><em>pSource</em></code>. This value is identical to the value specified in the <code><em>sourceChannelCount</em></code> parameter of <code><a class="el" href="namespacenn_1_1audio.html#a2d3b900b04b3704eab4aad529cc4cb37" title="Initializes a SplitterType object and adds it to AudioRendererConfig.">nn::audio::AcquireSplitter()</a></code>. For <code><a class="el" href="namespacenn_1_1audio.html#a0d211a6bf9009d4067c320541c625bd2" title="Sets the mix volume for the output destinations from SplitterType.">nn::audio::SetSplitterMixVolume()</a></code> and <code><a class="el" href="namespacenn_1_1audio.html#ad82155de4e1539ef1356f504f97d8993" title="Gets the mix volume for the output destinations from SplitterType.">nn::audio::GetSplitterMixVolume()</a></code>, the value specified for the value specified for the <code><em>destinationIndex</em></code> parameter must be smaller than the value obtained with this function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a131">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab996d1af1b2b5590d8afbdb205277044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab996d1af1b2b5590d8afbdb205277044">&#9670;&nbsp;</a></span>GetSplitterDestinationCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetSplitterDestinationCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_splitter_type.html">SplitterType</a> *&#160;</td>
          <td class="paramname"><em>pSource</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of output destinations from <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSource</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code> that gets the number of output destinations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of output destinations. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pSource</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSource</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Returns the number of output destinations from <code><em>pSource</em></code>. This value is identical to the value specified in the <code><em>destinationCount</em></code> parameter of <code><a class="el" href="namespacenn_1_1audio.html#a2d3b900b04b3704eab4aad529cc4cb37" title="Initializes a SplitterType object and adds it to AudioRendererConfig.">nn::audio::AcquireSplitter()</a></code>. For <code><a class="el" href="namespacenn_1_1audio.html#a364d3e39d547f60de643b7ad37011495" title="Specifies the SubMix as one output destination for SplitterType.">nn::audio::SetSplitterDestination()</a></code>, <code><a class="el" href="namespacenn_1_1audio.html#a0d211a6bf9009d4067c320541c625bd2" title="Sets the mix volume for the output destinations from SplitterType.">nn::audio::SetSplitterMixVolume()</a></code>, and <code><a class="el" href="namespacenn_1_1audio.html#ad82155de4e1539ef1356f504f97d8993" title="Gets the mix volume for the output destinations from SplitterType.">nn::audio::GetSplitterMixVolume()</a></code>, the value specified for the value specified for the <code><em>destinationIndex</em></code> parameter must be smaller than the value obtained with this function. </p>

</div>
</div>
<a id="a8be6d0e347070786c6a7805986982fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be6d0e347070786c6a7805986982fc3">&#9670;&nbsp;</a></span>GetSplitterSampleRate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetSplitterSampleRate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_splitter_type.html">SplitterType</a> *&#160;</td>
          <td class="paramname"><em>pSource</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the sample rate specified by <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSource</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code> that gets the sample rate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the sample rate. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pSource</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSource</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the sample rate specified for <code><em>pSource</em></code>. This value is identical to the value specified in the <code><em>sampleRate</em></code> parameter of <code><a class="el" href="namespacenn_1_1audio.html#a2d3b900b04b3704eab4aad529cc4cb37" title="Initializes a SplitterType object and adds it to AudioRendererConfig.">nn::audio::AcquireSplitter()</a></code>. The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> specified as the output destination for <a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a> must have the same sample rate as the value obtained by this function. </p>

</div>
</div>
<a id="a24020da05700a26ee46f04f5762c157f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24020da05700a26ee46f04f5762c157f">&#9670;&nbsp;</a></span>AcquireSubMix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::AcquireSubMix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pOutSubMix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufferCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> object and adds it to <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when getting the audio renderer that will add <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSubMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleRate</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> sample rate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferCount</td><td>The number of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> mix buffers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> is available, or <code>false</code> if not. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pOutSubMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>sampleRate</em></code> == <code>32000</code> || <code><em>sampleRate</em></code> == <code>48000</code>.</li>
<li><code>0</code> &lt; <code><em>bufferCount</em></code> &amp;&amp; <code><em>bufferCount</em></code> &lt;= <code><a class="el" href="namespacenn_1_1audio.html#a2519dd3580c74c1abf2d1ae868304f39" title="The maximum number of mix buffers that can be created for a single instance of SubMix or FinalMix.">nn::audio::MixBufferCountMax</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> gets the output from an instance of <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> or another instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> and applies a mix process to that output.</p>
<p>The total number of mix buffers that can be used by a single audio renderer is <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html#a38ecaacde5a6d9de76cad74d059d6974" title="The maximum number of mix buffers used by the audio renderer.">nn::audio::AudioRendererParameter.mixBufferCount</a></code>. This function gets <code><em>bufferCount</em></code> mix buffers of the <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html#a38ecaacde5a6d9de76cad74d059d6974" title="The maximum number of mix buffers used by the audio renderer.">nn::audio::AudioRendererParameter.mixBufferCount</a></code> total mix buffers and initializes them as management targets for <code><em>pOutSubMix</em></code>. A single audio renderer never manages more than <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html#a38ecaacde5a6d9de76cad74d059d6974" title="The maximum number of mix buffers used by the audio renderer.">nn::audio::AudioRendererParameter.mixBufferCount</a></code> mix buffers. After specifying the required number of mix buffers for <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html#a38ecaacde5a6d9de76cad74d059d6974" title="The maximum number of mix buffers used by the audio renderer.">nn::audio::AudioRendererParameter.mixBufferCount</a></code>, assign them as needed to instances of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> and <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>. For more information about mix buffers, see Audio Library in NintendoSDK Documents.</p>
<p>A single <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> can store up to <code><a class="el" href="namespacenn_1_1audio.html#a2519dd3580c74c1abf2d1ae868304f39" title="The maximum number of mix buffers that can be created for a single instance of SubMix or FinalMix.">nn::audio::MixBufferCountMax</a></code> mix buffers.</p>
<p>If this function returns <code>false</code>, one of the following two things has occurred.</p><ul>
<li>The audio renderer does not have enough mix buffers available. Increase the value specified for <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html#a38ecaacde5a6d9de76cad74d059d6974" title="The maximum number of mix buffers used by the audio renderer.">nn::audio::AudioRendererParameter.mixBufferCount</a></code>.</li>
<li>The number of instances of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> obtained exceeds the number specified during initialization. Try increasing the value specified for <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html" title="The audio renderer parameters.">nn::audio::AudioRendererParameter</a>.<em>subMixCount</em></code>.</li>
</ul>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code>AcquireFinalMix(AudioRendererConfig* pOutConfig, FinalMixType* <em>pOutFinalMix</em>, int <em>bufferCount</em>)</code></li>
<li><code>ReleaseFinalMix(AudioRendererConfig* <em>pOutConfig</em>, FinalMixType* <em>pFinalMix</em>)</code></li>
<li><code>AcquireSubMix(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pOutSubMix</em>, int <em>sampleRate</em>, int <em>bufferCount</em>)</code></li>
<li><code>ReleaseSubMix(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pSubMix</em>)</code></li>
<li><code>SetSubMixDestination(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pSource</em>, FinalMixType* <em>pDestination</em>)</code></li>
<li><code>SetSubMixDestination(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pSource</em>, SubMixType* <em>pDestination</em>)</code></li>
<li><code>ClearSubMixDestination(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pOutSource</em>)</code></li>
</ul>
<p>Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a66">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a68">AudioRenderer/AudioRenderer.cpp</a>, and <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a90">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af26df5e585272dfe727f08516f9b3751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26df5e585272dfe727f08516f9b3751">&#9670;&nbsp;</a></span>ReleaseSubMix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::ReleaseSubMix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pSubMix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> object from <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#a24020da05700a26ee46f04f5762c157f" title="Initializes a SubMixType object and adds it to AudioRendererConfig.">nn::audio::AcquireSubMix()</a></code> initializes <code><em>pSubMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSubMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pOutSubMix</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code>AcquireFinalMix(AudioRendererConfig* pOutConfig, FinalMixType* <em>pOutFinalMix</em>, int <em>bufferCount</em>)</code></li>
<li><code>ReleaseFinalMix(AudioRendererConfig* <em>pOutConfig</em>, FinalMixType* <em>pFinalMix</em>)</code></li>
<li><code>AcquireSubMix(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pOutSubMix</em>, int <em>sampleRate</em>, int <em>bufferCount</em>)</code></li>
<li><code>ReleaseSubMix(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pSubMix</em>)</code></li>
<li><code>SetSubMixDestination(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pSource</em>, FinalMixType* <em>pDestination</em>)</code></li>
<li><code>SetSubMixDestination(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pSource</em>, SubMixType* <em>pDestination</em>)</code></li>
<li><code>ClearSubMixDestination(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pOutSource</em>)</code></li>
</ul>
<p>Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="a421895cf9e6a2f604a3a2d01b1e98459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421895cf9e6a2f604a3a2d01b1e98459">&#9670;&nbsp;</a></span>SetSubMixDestination() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::SetSubMixDestination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pDestination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> to which <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> will be output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#a24020da05700a26ee46f04f5762c157f" title="Initializes a SubMixType object and adds it to AudioRendererConfig.">nn::audio::AcquireSubMix()</a></code> initializes <code><em>pSubMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSource</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> that is the input source. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pDestination</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> that is the output destination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pSource</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSource</em></code> is initialized.</li>
<li><code><em>pDestination</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDestination</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Connects the instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> specified for <code><em>pSource</em></code> to the instance of <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> specified for <code><em>pDestination</em></code>. After this connection is configured, any mix buffer managed by <code><em>pSource</em></code> can be mixed into a mix buffer managed by <code><em>pDestination</em></code>. Use the <code><a class="el" href="namespacenn_1_1audio.html#ab363a04dff4cc4c22ae44049aae1a391" title="Sets the mix volume for the SubMixType object.">nn::audio::SetSubMixMixVolume()</a></code> function to specify the <code><em>pDestination</em></code> mix buffer into which to mix the <code><em>pSource</em></code> mix buffer. Use the <code><a class="el" href="namespacenn_1_1audio.html#ad9f337a0ec64598348a3f4a7dd9e9951" title="Sets the volume for the SubMixType object.">nn::audio::SetSubMixVolume()</a></code> function to specify a volume value to apply to all mix volumes from <code><em>pSource</em></code>.</p>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code>AcquireFinalMix(AudioRendererConfig* pOutConfig, FinalMixType* <em>pOutFinalMix</em>, int <em>bufferCount</em>)</code></li>
<li><code>ReleaseFinalMix(AudioRendererConfig* <em>pOutConfig</em>, FinalMixType* <em>pFinalMix</em>)</code></li>
<li><code>AcquireSubMix(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pOutSubMix</em>, int <em>sampleRate</em>, int <em>bufferCount</em>)</code></li>
<li><code>ReleaseSubMix(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pSubMix</em>)</code></li>
<li><code>SetSubMixDestination(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pSource</em>, FinalMixType* <em>pDestination</em>)</code></li>
<li><code>SetSubMixDestination(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pSource</em>, SubMixType* <em>pDestination</em>)</code></li>
<li><code>ClearSubMixDestination(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pOutSource</em>)</code></li>
</ul>
<p>In the current release, the sampling rate of the instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> specified for <code><em>pSource</em></code> must be the same as the instance of <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> specified for <code><em>pDestination</em></code>. This restriction will be removed in a future release.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pSubMix</em></code> while calling this function. Also, calling this function at the same time as <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a69">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a71">AudioRenderer/AudioRenderer.cpp</a>, and <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a91">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a176c68fa47a377bc07eee5f194bdb6ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176c68fa47a377bc07eee5f194bdb6ea">&#9670;&nbsp;</a></span>SetSubMixDestination() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::SetSubMixDestination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pDestination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> to which <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> will be output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#a24020da05700a26ee46f04f5762c157f" title="Initializes a SubMixType object and adds it to AudioRendererConfig.">nn::audio::AcquireSubMix()</a></code> initializes <code><em>pSubMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSource</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> that is the input source. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pDestination</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> that is the output destination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pSource</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSource</em></code> is initialized.</li>
<li><code><em>pDestination</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDestination</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Except when <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> is specified for <code><em>pDestination</em></code>, this function works the same as <code><a class="el" href="namespacenn_1_1audio.html#a421895cf9e6a2f604a3a2d01b1e98459" title="Sets the FinalMixType to which SubMixType will be output.">nn::audio::SetSubMixDestination</a>(AudioRendererConfig* <em>pOutConfig,</em> SubMixType* <em>pSource</em>, FinalMixType* <em>pDestination</em>)</code>. </p>

</div>
</div>
<a id="a060b75a1633eb0304db850b7272ec0da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060b75a1633eb0304db850b7272ec0da">&#9670;&nbsp;</a></span>SetSubMixDestination() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetSubMixDestination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_splitter_type.html">SplitterType</a> *&#160;</td>
          <td class="paramname"><em>pDestination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies the <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code> to which <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> will be output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#a24020da05700a26ee46f04f5762c157f" title="Initializes a SubMixType object and adds it to AudioRendererConfig.">nn::audio::AcquireSubMix()</a></code> initializes <code><em>pSubMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSource</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> that is the input source. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pDestination</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code> that is the output destination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pSource</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSource</em></code> is initialized.</li>
<li><code><em>pDestination</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDestination</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Specify the <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code> as the output destination to output the sample data stored by <code><em>pSource</em></code> to multiple <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> and <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> objects. Note that because the <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code> does not perform sample rate conversion, output is only possible to <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> and <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> objects that have the same sample rate. </p>

</div>
</div>
<a id="a72df4d42c85ba2a3c5f4e60cf3f7ef8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72df4d42c85ba2a3c5f4e60cf3f7ef8c">&#9670;&nbsp;</a></span>ClearSubMixDestination()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::ClearSubMixDestination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pSource</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the output destination specified for <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#a24020da05700a26ee46f04f5762c157f" title="Initializes a SubMixType object and adds it to AudioRendererConfig.">nn::audio::AcquireSubMix()</a></code> initializes <code><em>pSubMix</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSource</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pSource</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSource</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 For the operations on <code><em>pOutConfig</em></code> this function is thread-safe, but for the operations on <code><em>pSource</em></code> it is not thread-safe. Do not perform any operations on <code><em>pSource</em></code> while calling this function.</p>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code>AcquireFinalMix(AudioRendererConfig* pOutConfig, FinalMixType* <em>pOutFinalMix</em>, int <em>bufferCount</em>)</code></li>
<li><code>ReleaseFinalMix(AudioRendererConfig* <em>pOutConfig</em>, FinalMixType* <em>pFinalMix</em>)</code></li>
<li><code>AcquireSubMix(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pOutSubMix</em>, int <em>sampleRate</em>, int <em>bufferCount</em>)</code></li>
<li><code>ReleaseSubMix(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pSubMix</em>)</code></li>
<li><code>SetSubMixDestination(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pSource</em>, FinalMixType* <em>pDestination</em>)</code></li>
<li><code>SetSubMixDestination(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pSource</em>, SubMixType* <em>pDestination</em>)</code></li>
<li><code>ClearSubMixDestination(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pSource</em>)</code></li>
</ul>
<p>Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. For more information, see <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code>. </p>

</div>
</div>
<a id="a331b58a86c70fe45bf649941db3ca55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331b58a86c70fe45bf649941db3ca55e">&#9670;&nbsp;</a></span>GetSubMixSampleRate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetSubMixSampleRate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pSubMix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the sample rate of the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSubMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the sample rate. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pSubMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSubMix</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Returns the sampling rate specified for <code><em>sampleRate</em></code> in the <code><a class="el" href="namespacenn_1_1audio.html#a24020da05700a26ee46f04f5762c157f" title="Initializes a SubMixType object and adds it to AudioRendererConfig.">nn::audio::AcquireSubMix()</a></code> function.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pSubMix</em></code> while calling this function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a99">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad76ce2e4c558f038dab51a3a30c068e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad76ce2e4c558f038dab51a3a30c068e4">&#9670;&nbsp;</a></span>GetSubMixBufferCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetSubMixBufferCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pSubMix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of mix buffers of the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSubMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of mix buffers. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pSubMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSubMix</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Returns the number of mix buffers specified for <code><em>bufferCount</em></code> in the <code><a class="el" href="namespacenn_1_1audio.html#a24020da05700a26ee46f04f5762c157f" title="Initializes a SubMixType object and adds it to AudioRendererConfig.">nn::audio::AcquireSubMix()</a></code> function.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pSubMix</em></code> while calling this function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a100">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a6050ccd7effd6dc69eb160afeb23c348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6050ccd7effd6dc69eb160afeb23c348">&#9670;&nbsp;</a></span>GetSubMixVolume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetSubMixVolume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pSubMix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the volume of the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSubMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the volume. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pSubMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSubMix</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the volume set using the <code><a class="el" href="namespacenn_1_1audio.html#ad9f337a0ec64598348a3f4a7dd9e9951" title="Sets the volume for the SubMixType object.">nn::audio::SetSubMixVolume()</a></code> function.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pSubMix</em></code> while calling this function. </p>

</div>
</div>
<a id="ad9f337a0ec64598348a3f4a7dd9e9951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f337a0ec64598348a3f4a7dd9e9951">&#9670;&nbsp;</a></span>SetSubMixVolume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetSubMixVolume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pSubMix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>volume</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the volume for the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSubMix</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">volume</td><td>Volume. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pSubMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSubMix</em></code> is initialized.</li>
<li><code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html#a6963ac73ffdc2e27d9d7aab45f120f1d" title="Gets the minimum value that can be set for volume and mix volume (-128.0f).">nn::audio::SubMixType::GetVolumeMin()</a></code> &lt;= <code><em>volume</em></code> &amp;&amp; <code><em>volume</em></code> &lt;= <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html#a573c348afb9923ed650e40b1ebdcdae5" title="Gets the maximum value that can be set for volume and mix volume (128.0f).">nn::audio::SubMixType::GetVolumeMax()</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The volume specified in this function is applied to the output of all instances of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> and <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> connected to <code><em>pSubMix</em></code>. Use the <code><a class="el" href="namespacenn_1_1audio.html#ab363a04dff4cc4c22ae44049aae1a391" title="Sets the mix volume for the SubMixType object.">nn::audio::SetSubMixMixVolume()</a></code> function to set the volume for individual mix buffers.</p>
<p>This function can be called at any time, including when the audio renderer is running.</p>
<p><code>SubMix</code> has a <code><em>volume</em></code> value of <code>1.0f</code> immediately after initialization.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pSubMix</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p><dl class="section note"><dt>Note</dt><dd>Audio cutoff may occur depending on the set volume value. If audio cutoff occurs, verify that the volume is within appropriate values. If a negative volume value is set, the phase of the waveform is inverted. </dd></dl>

</div>
</div>
<a id="ab363a04dff4cc4c22ae44049aae1a391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab363a04dff4cc4c22ae44049aae1a391">&#9670;&nbsp;</a></span>SetSubMixMixVolume() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetSubMixMixVolume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pDestination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destinationIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the mix volume for the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSource</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> that is the input source. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pDestination</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> that is the output destination. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">volume</td><td>Mix volume </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceIndex</td><td>The mix buffer index for the input. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destinationIndex</td><td>The mix buffer index for the output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pSource</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSource</em></code> is initialized.</li>
<li><code><em>pDestination</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDestination</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a421895cf9e6a2f604a3a2d01b1e98459">nn::audio::SetSubMixDestination(pSource, pDestination)</a></code> has been run for <code><em>pSource</em></code> and <code><em>pDestination</em></code>.</li>
<li><code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html#a6963ac73ffdc2e27d9d7aab45f120f1d" title="Gets the minimum value that can be set for volume and mix volume (-128.0f).">nn::audio::SubMixType::GetVolumeMin()</a></code> &lt;= <code><em>volume</em></code> &amp;&amp; <code><em>volume</em></code> &lt;= <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html#a573c348afb9923ed650e40b1ebdcdae5" title="Gets the maximum value that can be set for volume and mix volume (128.0f).">nn::audio::SubMixType::GetVolumeMax()</a></code>.</li>
<li><code>0</code> &lt;= <code><em>sourceIndex</em></code> &amp;&amp; <code><em>sourceIndex</em></code> &lt; <code><a class="el" href="namespacenn_1_1audio.html#ad76ce2e4c558f038dab51a3a30c068e4">nn::audio::GetSubMixBufferCount(pSource)</a></code>.</li>
<li><code>0</code> &lt;= <code><em>destinationIndex</em></code> &amp;&amp; <code><em>destinationIndex</em></code> &lt; <code><a class="el" href="namespacenn_1_1audio.html#a7652eae684b0d267e276cf7c01ac12d7">nn::audio::GetFinalMixBufferCount(pDestination)</a></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a11d86aacbe9bfa18a76f8792219ff21a">nn::audio::GetSubMixMixVolume(pSource, pDestination, sourceIndex, destinationIndex)</a></code> == <code><em>volume</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sets the volume specified for <code><em>volume</em></code> when mixing the contents of the mix buffer of index <code><em>sourceIndex</em></code> in the instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> specified for <code><em>pSource</em></code> to the mix buffer of index <code><em>destinationIndex</em></code> in the instance of <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> specified for <code><em>pDestination</em></code>.</p>
<p>This function can be called at any time, including when the audio renderer is running.</p>
<p>Before calling this function, <code><em>pSource</em></code> and <code><em>pDestination</em></code> must be connected using the <code><a class="el" href="namespacenn_1_1audio.html#a421895cf9e6a2f604a3a2d01b1e98459" title="Sets the FinalMixType to which SubMixType will be output.">nn::audio::SetSubMixDestination()</a></code> function.</p>
<p>The mix volume values immediately after calling <code><a class="el" href="namespacenn_1_1audio.html#a421895cf9e6a2f604a3a2d01b1e98459" title="Sets the FinalMixType to which SubMixType will be output.">nn::audio::SetSubMixDestination()</a></code> are all <code>0.0f</code>.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pSource</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. </p><dl class="section note"><dt>Note</dt><dd>Audio cutoff may occur depending on the set volume value. If audio cutoff occurs, verify that the volume is within appropriate values. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a70">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a72">AudioRenderer/AudioRenderer.cpp</a>, and <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a92">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a11d86aacbe9bfa18a76f8792219ff21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d86aacbe9bfa18a76f8792219ff21a">&#9670;&nbsp;</a></span>GetSubMixMixVolume() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetSubMixMixVolume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pDestination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destinationIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the mix volume of the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSource</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> that is the input source. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pDestination</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> that is the output destination. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceIndex</td><td>The mix buffer index for the input. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destinationIndex</td><td>The mix buffer index for the output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the mix volume for the specified <code><em>sourceIndex</em></code> and <code><em>destinationIndex</em></code>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pSource</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSource</em></code> is initialized.</li>
<li><code><em>pDestination</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDestination</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a421895cf9e6a2f604a3a2d01b1e98459">nn::audio::SetSubMixDestination(pSource, pDestination)</a></code> has been run for <code><em>pSource</em></code> and <code><em>pDestination</em></code>.</li>
<li><code>0</code> &lt;= <code><em>sourceIndex</em></code> &amp;&amp; <code><em>sourceIndex</em></code> &lt; <code><a class="el" href="namespacenn_1_1audio.html#ad76ce2e4c558f038dab51a3a30c068e4">nn::audio::GetSubMixBufferCount(pSource)</a></code>.</li>
<li><code>0</code> &lt;= <code><em>destinationIndex</em></code> &amp;&amp; <code><em>destinationIndex</em></code> &lt; <code><a class="el" href="namespacenn_1_1audio.html#a7652eae684b0d267e276cf7c01ac12d7">nn::audio::GetFinalMixBufferCount(pDestination)</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the mix volume set for each mix buffer using the <code><a class="el" href="namespacenn_1_1audio.html#ab363a04dff4cc4c22ae44049aae1a391" title="Sets the mix volume for the SubMixType object.">nn::audio::SetSubMixMixVolume()</a></code> function. For more information about <code><em>sourceIndex</em></code> and <code><em>destinationIndex</em></code>, see <code><a class="el" href="namespacenn_1_1audio.html#ab363a04dff4cc4c22ae44049aae1a391" title="Sets the mix volume for the SubMixType object.">nn::audio::SetSubMixMixVolume()</a></code>.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pSubMix</em></code> while calling this function. </p>

</div>
</div>
<a id="ae389d0e44e6932bb820729f20b80941f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae389d0e44e6932bb820729f20b80941f">&#9670;&nbsp;</a></span>SetSubMixMixVolume() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetSubMixMixVolume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pDestination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destinationIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the mix volume for the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSource</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> that is the input source. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pDestination</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> that is the output destination. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">volume</td><td>Mix volume </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceIndex</td><td>The mix buffer index for the input. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destinationIndex</td><td>The mix buffer index for the output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pSource</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSource</em></code> is initialized.</li>
<li><code><em>pDestination</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDestination</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a421895cf9e6a2f604a3a2d01b1e98459">nn::audio::SetSubMixDestination(pSource, pDestination)</a></code> has been run for <code><em>pSource</em></code> and <code><em>pDestination</em></code>.</li>
<li><code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html#a6963ac73ffdc2e27d9d7aab45f120f1d" title="Gets the minimum value that can be set for volume and mix volume (-128.0f).">nn::audio::SubMixType::GetVolumeMin()</a></code> &lt;= <code><em>volume</em></code> &amp;&amp; <code><em>volume</em></code> &lt;= <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html#a573c348afb9923ed650e40b1ebdcdae5">nn::audio::SubMixType::GetVolumeMax()</a></code>.</li>
<li><code>0</code> &lt;= <code><em>sourceIndex</em></code> &amp;&amp; <code><em>sourceIndex</em></code> &lt; <code><a class="el" href="namespacenn_1_1audio.html#ad76ce2e4c558f038dab51a3a30c068e4">nn::audio::GetSubMixBufferCount(pSource)</a></code>.</li>
<li><code>0</code> &lt;= <code><em>destinationIndex</em></code> &amp;&amp; <code><em>destinationIndex</em></code> &lt; <code><a class="el" href="namespacenn_1_1audio.html#ad76ce2e4c558f038dab51a3a30c068e4">nn::audio::GetSubMixBufferCount(pDestination)</a></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a11d86aacbe9bfa18a76f8792219ff21a">nn::audio::GetSubMixMixVolume(pSource, pDestination, sourceIndex, destinationIndex)</a></code> == <code><em>volume</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function does the same thing as the <code><a class="el" href="namespacenn_1_1audio.html#ab363a04dff4cc4c22ae44049aae1a391" title="Sets the mix volume for the SubMixType object.">nn::audio::SetSubMixMixVolume(SubMixType* pSource, FinalMixType* pDestination, float volume, int sourceIndex, int destinationIndex)</a></code> function except when an instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> is specified for <code><em>pDestination</em></code>. </p>

</div>
</div>
<a id="a908367c4ffa5997478e7eb4a37928bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a908367c4ffa5997478e7eb4a37928bd5">&#9670;&nbsp;</a></span>GetSubMixMixVolume() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetSubMixMixVolume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pDestination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destinationIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the mix volume of the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSource</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> that is the input source. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pDestination</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> that is the output destination. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceIndex</td><td>The mix buffer index for the input. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destinationIndex</td><td>The mix buffer index for the output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the mix volume for the specified <code><em>sourceIndex</em></code> and <code><em>destinationIndex</em></code>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pSource</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSource</em></code> is initialized.</li>
<li><code><em>pDestination</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDestination</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a421895cf9e6a2f604a3a2d01b1e98459">nn::audio::SetSubMixDestination(pSource, pDestination)</a></code> has been run for <code><em>pSource</em></code> and <code><em>pDestination</em></code>.</li>
<li><code>0</code> &lt;= <code><em>sourceIndex</em></code> &amp;&amp; <code><em>sourceIndex</em></code> &lt; <code><a class="el" href="namespacenn_1_1audio.html#ad76ce2e4c558f038dab51a3a30c068e4">nn::audio::GetSubMixBufferCount(pSource)</a></code>.</li>
<li><code>0</code> &lt;= <code><em>destinationIndex</em></code> &amp;&amp; <code><em>destinationIndex</em></code> &lt; <code><a class="el" href="namespacenn_1_1audio.html#ad76ce2e4c558f038dab51a3a30c068e4">nn::audio::GetSubMixBufferCount(pDestination)</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function does the same thing as the <code><a class="el" href="namespacenn_1_1audio.html#ab363a04dff4cc4c22ae44049aae1a391" title="Sets the mix volume for the SubMixType object.">nn::audio::SetSubMixMixVolume(SubMixType* pSource, FinalMixType* pDestination, float volume, int sourceIndex, int destinationIndex)</a></code> function except when an instance of <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> is specified for <code><em>pDestination</em></code>. </p>

</div>
</div>
<a id="a0746343c5cb001974880a196f781b600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0746343c5cb001974880a196f781b600">&#9670;&nbsp;</a></span>GetSubMixNodeId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1audio.html#a347cdc16fef8e35aad9d8d0cd2e79e38">NodeId</a> nn::audio::GetSubMixNodeId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pSubMix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the ID of the <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> object in the audio renderer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSubMix</td><td><code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>NodeId</code>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pSubMix</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSubMix</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code>NodeId</code> is a numeric value that uniquely identifies the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_device_sink_type.html" title="Sink to output the rendering results to the audio output device.">DeviceSinkType</a></code>, and <code><a class="el" href="structnn_1_1audio_1_1_circular_buffer_sink_type.html" title="Sink to output the rendering results to memory.">CircularBufferSinkType</a></code> objects registered to the audio renderer. The various <code>NodeId</code> objects are never duplicated within a single audio renderer. A <code>NodeId</code> is assigned for each instance of each added <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_device_sink_type.html" title="Sink to output the rendering results to the audio output device.">DeviceSinkType</a></code>, and <code><a class="el" href="structnn_1_1audio_1_1_circular_buffer_sink_type.html" title="Sink to output the rendering results to memory.">CircularBufferSinkType</a></code>. </p>

</div>
</div>
<a id="a3cc31617500698ba14f0d1d5e20b7668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc31617500698ba14f0d1d5e20b7668">&#9670;&nbsp;</a></span>AcquireVoiceSlot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::AcquireVoiceSlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pOutVoice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1">SampleFormat</a>&#160;</td>
          <td class="paramname"><em>sampleFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pParameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_voice_type_1_1_behavior_options.html">VoiceType::BehaviorOptions</a> *&#160;</td>
          <td class="paramname"><em>pBehaviorOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> with options that specify its behavior and adds it to <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when getting the audio renderer that will add <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutVoice</td><td>Pointer to an uninitialized <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleRate</td><td>Sampling rate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCount</td><td>Number of channels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleFormat</td><td>Sampling format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td>Priority. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pParameter</td><td>Additional parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the additional parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBehaviorOptions</td><td>Options specifying the behavior of <code>Voice</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> is available, or <code>false</code> otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pOutVoice</em></code> != <code>nullptr</code>.</li>
<li><code><em>sampleRate</em></code> &gt; <code>0</code>.</li>
<li><code><em>channelCount</em></code> &gt;= <code>1</code> &amp;&amp; <code><em>channelCount</em></code> &lt;= <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html#aec95997a21a52e2bd52085236ef94a98" title="The maximum number of channels that can be set for VoiceType.">nn::audio::VoiceType::ChannelCountMax</a></code>.</li>
<li><code><em>sampleFormat</em></code> == <code><a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1a28ddfdb7464233b0bd4fa406aff3e31a" title="16-bit signed integer PCM format.">nn::audio::SampleFormat_PcmInt16</a></code> || <code><em>sampleFormat</em></code> == <code><a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1a9f815cfc16990e6afc2f53500516e1d5" title="Single-precision floating point PCM format.">nn::audio::SampleFormat_PcmFloat</a></code> || <code><em>sampleFormat</em></code> == <code><a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1ab78e0cfd4dc7851b77c0b4ad3c355a72" title="ADPCM format.">nn::audio::SampleFormat_Adpcm</a></code>.</li>
<li><code><a class="el" href="structnn_1_1audio_1_1_voice_type.html#a564e9b6aee6dcb119664adc4b9f22149" title="Highest priority.">nn::audio::VoiceType::PriorityHighest</a></code> &lt;= <code><em>priority</em></code> &amp;&amp; <code><em>priority</em></code> &lt;= <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html#a4270b7e2b90f9ab75208774a539641a9" title="Lowest priority.">nn::audio::VoiceType::PriorityLowest</a></code>.</li>
<li>When <code><em>pParameter</em></code> != <code>nullptr</code>, <code><em>pParameter</em></code> is aligned to <code><a class="el" href="namespacenn_1_1audio.html#a61833f2e2cf0253e3054188e900315af" title="The alignment size for audio buffers.">nn::audio::BufferAlignSize</a></code>.</li>
<li>When <code><em>pParameter</em></code> != <code>nullptr</code>, <code><em>size</em></code> &gt; <code>0</code>.</li>
<li><code><em>pBehaviorOptions</em></code> != <code>nullptr</code>.</li>
<li>If <code><em>pBehaviorOptions</em>-&gt;isPitchAndSrcSkipped</code> == <code>true</code>, <code><em>sampleRate</em></code> == <code><a class="el" href="namespacenn_1_1audio.html#a25ee6f076a7eb80a0fc937c42d41e652">nn::audio::GetAudioRendererSampleRate(handle)</a></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pOutVoice</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 After this function has been called, perform all subsequent operations on <code><em>pOutVoice</em></code> using the functions listed in the description of <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>. Set the output destination for <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> using the <code><a class="el" href="namespacenn_1_1audio.html#a82bfb03f43f4a2680f5ad7eff0967545" title="Sets the FinalMix that is the output destination of the VoiceType.">nn::audio::SetVoiceDestination()</a></code> function, and set the mix volume using the <code><a class="el" href="namespacenn_1_1audio.html#a9a74d5457b16f38d3271eb452dcec395" title="Sets the mix volume for the VoiceType object.">nn::audio::SetVoiceMixVolume()</a></code> function.</p>
<p>The following parameters must be specified when initializing <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>. These parameters cannot be changed after the function is called.</p><ul>
<li>Number of channels.</li>
<li>Sampling rate.</li>
<li>Sampling format.</li>
<li>Additional parameters and their sizes.</li>
</ul>
<p>For the number of channels, the sampling rate, and the sample format, specify the sampling rate required for the input waveforms specified to <code><em>pOutVoice</em></code> by the <code><a class="el" href="namespacenn_1_1audio.html#aa58886eeb3fac72d6e84dcad5d2704df" title="Adds a WaveBuffer object to VoiceType.">nn::audio::AppendWaveBuffer()</a></code> function. If the sampling rate set for the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> connection destination is different from the sampling rate set for <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>, the sampling rate is converted automatically during rendering.</p>
<p>In this function, the number of voice units corresponding to the channel count is used. For example, if a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object with six channels has been allocated, six voice units are used.</p>
<p>For the priority, specify a value between <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html#a564e9b6aee6dcb119664adc4b9f22149" title="Highest priority.">VoiceType::PriorityHighest</a></code> and <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html#a4270b7e2b90f9ab75208774a539641a9" title="Lowest priority.">VoiceType::PriorityLowest</a></code>. The lower the value, the higher the priority.</p>
<p>Additional parameters are needed when specifying <code>SampleFormat_Adpcm</code> for <code><em>sampleFormat</em></code>. If specifying another format, specify either <code>nullptr</code> or <code>0</code></p>
<p>The memory region specified for <code><em>pParameter</em></code> must be contained within the memory region specified for <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html" title="Structure for representing memory regions used by an audio renderer.">nn::audio::MemoryPoolType</a></code>. For more information, see <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html" title="Structure for representing memory regions used by an audio renderer.">nn::audio::MemoryPoolType</a></code> and <code><a class="el" href="namespacenn_1_1audio.html#a8e7b32e31ba3ea6f61c00c752c3a90d0" title="Gets a memory pool for an audio renderer.">nn::audio::AcquireMemoryPool()</a></code>.</p>
<p><code><em>pBehaviorOptions</em></code> are the options that specify the behavior of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object being initialized. If <code><a class="el" href="structnn_1_1audio_1_1_voice_type_1_1_behavior_options.html#a3544d98af8eb892d302d22b78f1d9a06" title="Clears the count to 0 when the number of samples obtained by the nn::audio::GetVoicePlayedSampleCount...">VoiceType::BehaviorOptions::isPlayedSampleCountResetAtLoopPoint</a></code> is set to <code>true</code>, the number of samples obtained by <code><a class="el" href="namespacenn_1_1audio.html#a6913685f14bb0b350eabb2517eb11dd4" title="Gets the number of samples that have been played by the VoiceType object.">nn::audio::GetVoicePlayedSampleCount()</a></code> gets reset to <code>0</code> when the audio loops. If <code><a class="el" href="structnn_1_1audio_1_1_voice_type_1_1_behavior_options.html#a670acd63d62ddcf4e79eb618e225a000" title="Skips pitch conversion and sampling rate conversion (SRC).">VoiceType::BehaviorOptions::isPitchAndSrcSkipped</a></code> is set to <code>true</code>, the pitch conversion and sampling rate conversion (SRC) processes are skipped. Note that <code><a class="el" href="namespacenn_1_1audio.html#aabd2853027ae5ab1516dbf53dd6fb6d9" title="Sets the pitch for the VoiceType object.">nn::audio::SetVoicePitch()</a></code> can no longer be used to configure pitch settings after these processes are skipped. Because sampling rate conversion will be skipped, the sampling rate specified for the parameter must be the same as the sampling rate set for the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> connection destination.</p>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code>AcquireVoiceSlot(AudioRendererConfig* <em>pOutConfig</em>, VoiceType* <em>pOutVoice</em>, int <em>sampleRate</em>, int <em>channelCount</em>, SampleFormat <em>sampleFormat</em>, int <em>priority</em>, const void* <em>pParameter</em>, size_t <em>size</em>)</code></li>
<li><code>ReleaseVoiceSlot(AudioRendererConfig* <em>pOutConfig</em>, VoiceType* <em>pVoice</em>)</code></li>
<li><code>SetVoiceDestination(AudioRendererConfig* <em>pOutConfig</em>, VoiceType* <em>pSource</em>, FinalMixType* <em>pDestination</em>)</code></li>
<li><code>SetVoiceDestination(AudioRendererConfig* <em>pOutConfig</em>, VoiceType* <em>pSource</em>, SubMixType* <em>pDestination</em>)</code></li>
<li><code>SetVoiceDestination(AudioRendererConfig* <em>pOutConfig</em>, VoiceType* <em>pSource</em>, SplitterType* <em>pDestination</em>)</code></li>
<li><code>ClearVoiceDestination(AudioRendererConfig* <em>pOutConfig</em>, VoiceType* <em>pSource</em>)</code></li>
</ul>
<p>Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a92">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a69">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a165">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a127">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a100">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a42">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a96">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a84">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a93">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a135">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a51">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a94">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#a46">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#a52">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a82">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="adb1e63f9649eb722402faa1d16e0b23e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb1e63f9649eb722402faa1d16e0b23e">&#9670;&nbsp;</a></span>AcquireVoiceSlot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::AcquireVoiceSlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pOutVoice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1">SampleFormat</a>&#160;</td>
          <td class="paramname"><em>sampleFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pParameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object and adds it to <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when getting the audio renderer that will add <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutVoice</td><td>Pointer to an uninitialized <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleRate</td><td>Sampling rate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCount</td><td>Number of channels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleFormat</td><td>Sampling format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td>Priority. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pParameter</td><td>Additional parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the additional parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> is available, or <code>false</code> otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pOutVoice</em></code> != <code>nullptr</code>.</li>
<li><code><em>sampleRate</em></code> &gt; <code>0</code>.</li>
<li><code><em>channelCount</em></code> &gt;= <code>1</code> &amp;&amp; <code><em>channelCount</em></code> &lt;= <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html#aec95997a21a52e2bd52085236ef94a98" title="The maximum number of channels that can be set for VoiceType.">nn::audio::VoiceType::ChannelCountMax</a></code>.</li>
<li><code><em>sampleFormat</em></code> == <code><a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1a28ddfdb7464233b0bd4fa406aff3e31a" title="16-bit signed integer PCM format.">nn::audio::SampleFormat_PcmInt16</a></code> || <code><em>sampleFormat</em></code> == <code><a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1a9f815cfc16990e6afc2f53500516e1d5" title="Single-precision floating point PCM format.">nn::audio::SampleFormat_PcmFloat</a></code> || <code><em>sampleFormat</em></code> == <code><a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1ab78e0cfd4dc7851b77c0b4ad3c355a72" title="ADPCM format.">nn::audio::SampleFormat_Adpcm</a></code>.</li>
<li><code><a class="el" href="structnn_1_1audio_1_1_voice_type.html#a564e9b6aee6dcb119664adc4b9f22149" title="Highest priority.">nn::audio::VoiceType::PriorityHighest</a></code> &lt;= <code><em>priority</em></code> &amp;&amp; <code><em>priority</em></code> &lt;= <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html#a4270b7e2b90f9ab75208774a539641a9" title="Lowest priority.">nn::audio::VoiceType::PriorityLowest</a></code>.</li>
<li>When <code><em>pParameter</em></code> != <code>nullptr</code>, <code><em>pParameter</em></code> is aligned to <code><a class="el" href="namespacenn_1_1audio.html#a61833f2e2cf0253e3054188e900315af" title="The alignment size for audio buffers.">nn::audio::BufferAlignSize</a></code>.</li>
<li>When <code><em>pParameter</em></code> != <code>nullptr</code>, <code><em>size</em></code> &gt; <code>0</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pOutVoice</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function initializes <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> to act with the default behavior. Otherwise, it works the same as <code><a class="el" href="namespacenn_1_1audio.html#a3cc31617500698ba14f0d1d5e20b7668" title="Initializes VoiceType with options that specify its behavior and adds it to AudioRendererConfig.">nn::audio::AcquireVoiceSlot</a>(AudioRendererConfig* <em>pOutConfig</em>, VoiceType* <em>pOutVoice</em>, int <em>sampleRate</em>, int <em>channelCount</em>, SampleFormat <em>sampleFormat</em>, int <em>priority</em>, const void* <em>pParameter</em>, size_t <em>size</em>, const <a class="el" href="structnn_1_1audio_1_1_voice_type_1_1_behavior_options.html" title="The group of options for specifying the behavior of VoiceType.">VoiceType::BehaviorOptions</a>* <em>pBehaviorOptions</em>)</code>. The default behavior is equivalent to setting all of the options in<code><em>pBehaviorOptions</em></code> to <code>false</code> in the preceding function.</p>
<p>Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="a88951e64989eabeb6ca689fb07932b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88951e64989eabeb6ca689fb07932b68">&#9670;&nbsp;</a></span>ReleaseVoiceSlot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::ReleaseVoiceSlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pVoice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object from <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when getting the audio renderer that will release <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pVoice</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pVoice</em></code> != <code>nullptr</code>.</li>
<li><code><em>pVoice</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code>AcquireVoiceSlot(AudioRendererConfig* <em>pOutConfig</em>, VoiceType* <em>pOutVoice</em>, int <em>sampleRate</em>, int <em>channelCount</em>, SampleFormat <em>sampleFormat</em>, int <em>priority</em>, const void* <em>pParameter</em>, size_t <em>size</em>)</code></li>
<li><code>ReleaseVoiceSlot(AudioRendererConfig* <em>pOutConfig</em>, VoiceType* <em>pVoice</em>)</code></li>
<li><code>SetVoiceDestination(AudioRendererConfig* <em>pOutConfig</em>, VoiceType* <em>pSource</em>, FinalMixType* <em>pDestination</em>)</code></li>
<li><code>SetVoiceDestination(AudioRendererConfig* <em>pOutConfig</em>, VoiceType* <em>pSource</em>, SubMixType* <em>pDestination</em>)</code></li>
<li><code>ClearVoiceDestination(AudioRendererConfig* <em>pOutConfig</em>, VoiceType* <em>pOutVoice</em>)</code></li>
</ul>
<p>Also, do not perform any operations on <code><em>pVoice</em></code> while calling any of these functions. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="a6457f605759151613511c5ae0b6a231b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6457f605759151613511c5ae0b6a231b">&#9670;&nbsp;</a></span>IsVoiceValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::IsVoiceValid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pVoice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> is valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pVoice</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if enabled, or <code>false</code> otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pVoice</em></code> != <code>nullptr</code>.</li>
<li><code><em>pVoice</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function checks whether a voice drop has occurred in <code><em>pVoice</em></code>. It returns <code>false</code> if called on a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> that has not been initialized correctly.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pVoice</em></code> while calling this function. </p>

</div>
</div>
<a id="aa85cbaceb0aaf8e8169c6bc0fbb72b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa85cbaceb0aaf8e8169c6bc0fbb72b51">&#9670;&nbsp;</a></span>IsVoiceDroppedFlagOn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::IsVoiceDroppedFlagOn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pVoice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of voice drop flags for <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pVoice</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> when the voice drop flag is turned on, or <code>false</code> otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pVoice</em></code> != <code>nullptr</code>.</li>
<li><code><em>pVoice</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function checks whether a voice drop has occurred in <code><em>pVoice</em></code>. The voice-drop feature is a feature for automatically skipping <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> rendering so noise is not generated due to a slowdown in processing when audio rendering puts a heavy load on the system. The audio renderer automatically selects which <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> to target for voice drops based on the priority specified for each <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object. If objects have the same priority, the selection is made based on last-note priority. In other words, the selection is designed so <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> objects set with a new priority are not dropped whenever possible.</p>
<p>The voice-dropped flag is set for a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object that has been dropped by the audio renderer. While this voice-dropped flag remains set, the audio renderer will continue to skip the rendering of this <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>. The playback of this <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object does not advance while rendering is being skipped. Accordingly, functions like <code><a class="el" href="namespacenn_1_1audio.html#a6913685f14bb0b350eabb2517eb11dd4" title="Gets the number of samples that have been played by the VoiceType object.">nn::audio::GetVoicePlayedSampleCount()</a></code> will continue to return the same value. A <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object set with the voice-dropped flag can be handled the same way as a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object that is paused (in the <code>PlayState_Pause</code> state). Accordingly, it can be destroyed quickly by the <code><a class="el" href="namespacenn_1_1audio.html#a88951e64989eabeb6ca689fb07932b68" title="Releases a VoiceType object from AudioRendererConfig.">nn::audio::ReleaseVoiceSlot()</a></code> function, just like a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object in the paused state.</p>
<p>In addition, by changing the play state to stopped (<code>PlayState_Stop</code>), all of the <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> objects registered to the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> can be taken away using the <code><a class="el" href="namespacenn_1_1audio.html#ad4736cbcae273e050d01416a7625b0d8" title="Get the WaveBuffer object that VoiceType has finished playing.">nn::audio::GetReleasedWaveBuffer()</a></code> function. However, because the rendering of this <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object is being skipped, unlike a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object in the paused state, the playback of this object cannot be resumed by using the <code><a class="el" href="namespacenn_1_1audio.html#a04a09b692d969f08155cf7f0f57d9ace" title="Sets the play state for the VoiceType object.">nn::audio::SetVoicePlayState()</a></code> function to specify the play state (<code>PlayState_Play</code>).</p>
<p>When the voice-dropped flag is cleared, the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> can once again be used for rendering by the audio renderer. The voice-dropped flag will not be disabled automatically. If you want to disable the flag, you need to call the function again and explicitly remove it. To disable the voice-dropped flag, use the <code><a class="el" href="namespacenn_1_1audio.html#a6dec0528f1287ebf549b3e84b18fb18f" title="Sets the VoiceType voice drop flag to off.">nn::audio::ResetVoiceDroppedFlag()</a></code> function.</p>
<p><code><em>pVoice</em></code> will return <code>false</code> immediately after initialization by the <code><a class="el" href="namespacenn_1_1audio.html#a3cc31617500698ba14f0d1d5e20b7668" title="Initializes VoiceType with options that specify its behavior and adds it to AudioRendererConfig.">nn::audio::AcquireVoiceSlot()</a></code> function. After that, <code><em>pVoice</em></code> returns <code>true</code> when a voice drop is generated during playback and the voice-dropped flag is set.</p>
<p>The voice-drop feature can be enabled or disabled for each separate audio renderer. For more information, see <code><a class="el" href="namespacenn_1_1audio.html#a9eaff763648679c45d3360d717e28618" title="Initializes the audio renderer parameters.">nn::audio::InitializeAudioRendererParameter</a></code> and <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_parameter.html" title="The audio renderer parameters.">nn::audio::AudioRendererParameter</a></code>. </p><dl class="section note"><dt>Note</dt><dd><code><a class="el" href="namespacenn_1_1audio.html#a9eaff763648679c45d3360d717e28618" title="Initializes the audio renderer parameters.">nn::audio::InitializeAudioRendererParameter</a></code> creates a parameter that disables the voice-drop feature. Accordingly, to use the voice-drop feature, you must explicitly enable it after calling <code><a class="el" href="namespacenn_1_1audio.html#a9eaff763648679c45d3360d717e28618" title="Initializes the audio renderer parameters.">nn::audio::InitializeAudioRendererParameter</a></code>.</dd></dl>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pVoice</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="a6dec0528f1287ebf549b3e84b18fb18f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dec0528f1287ebf549b3e84b18fb18f">&#9670;&nbsp;</a></span>ResetVoiceDroppedFlag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::ResetVoiceDroppedFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pVoice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> voice drop flag to off. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pVoice</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pVoice</em></code> != <code>nullptr</code>.</li>
<li><code><em>pVoice</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code>IsVoiceDroppedFlagOn(<em>pVoice</em>)</code> == <code>false</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function clears the voice-dropped flag for <code><em>pVoice</em></code>. A <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object in the voice-dropped state will not be used for audio rendering until it is released from this state. The <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object whose voice-dropped flag has been cleared by this function will once again be used for rendering by the audio renderer. For more information about the voice-drop feature, see <code><a class="el" href="namespacenn_1_1audio.html#aa85cbaceb0aaf8e8169c6bc0fbb72b51" title="Gets the number of voice drop flags for VoiceType.">nn::audio::IsVoiceDroppedFlagOn()</a></code>.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pVoice</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="a82bfb03f43f4a2680f5ad7eff0967545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82bfb03f43f4a2680f5ad7eff0967545">&#9670;&nbsp;</a></span>SetVoiceDestination() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetVoiceDestination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pDestination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <code>FinalMix</code> that is the output destination of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#a3cc31617500698ba14f0d1d5e20b7668" title="Initializes VoiceType with options that specify its behavior and adds it to AudioRendererConfig.">nn::audio::AcquireVoiceSlot()</a></code> initializes <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSource</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> that is the input source. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pDestination</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code> that is the output destination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pSource</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSource</em></code> is initialized.</li>
<li><code><em>pDestination</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDestination</em></code> is initialized.</li>
<li>If <code><a class="el" href="namespacenn_1_1audio.html#ab628a73a812066c3644a75cc2631dfd9">nn::audio::GetVoiceBehaviorOptions(pVoice)</a>.isPitchAndSrcSkipped</code> == <code>true</code>, <code><a class="el" href="namespacenn_1_1audio.html#adad2134ecc8dc166e2eddce11ba7ca9e">GetVoiceSampleRate(pSource)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#a09b00eec5745f59f461c43723ed965f3">GetFinalMixSampleRate(pDestination)</a></code>. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a94">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a114">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a169">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a131">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a106">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a45">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a99">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a87">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a97">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a140">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a54">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a97">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#a49">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#a55">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a86">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae312c1ecdae8d3cd1ff0a83fa50b6aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae312c1ecdae8d3cd1ff0a83fa50b6aca">&#9670;&nbsp;</a></span>SetVoiceDestination() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetVoiceDestination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pDestination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <code>SubMix</code> that is the output destination of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#a3cc31617500698ba14f0d1d5e20b7668" title="Initializes VoiceType with options that specify its behavior and adds it to AudioRendererConfig.">nn::audio::AcquireVoiceSlot()</a></code> initializes <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSource</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> that is the input source. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pDestination</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code> that is the output destination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pSource</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSource</em></code> is initialized.</li>
<li><code><em>pDestination</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDestination</em></code> is initialized.</li>
<li>If <code><a class="el" href="namespacenn_1_1audio.html#ab628a73a812066c3644a75cc2631dfd9">nn::audio::GetVoiceBehaviorOptions(pVoice)</a>.isPitchAndSrcSkipped</code> == <code>true</code>, <code><a class="el" href="namespacenn_1_1audio.html#adad2134ecc8dc166e2eddce11ba7ca9e">GetVoiceSampleRate(pSource)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#a331b58a86c70fe45bf649941db3ca55e">GetSubMixSampleRate(pDestination)</a></code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0d2308d4a669dcf38a4b4e260138e051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d2308d4a669dcf38a4b4e260138e051">&#9670;&nbsp;</a></span>SetVoiceDestination() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetVoiceDestination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_splitter_type.html">SplitterType</a> *&#160;</td>
          <td class="paramname"><em>pDestination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code> that is the output destination of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#a3cc31617500698ba14f0d1d5e20b7668" title="Initializes VoiceType with options that specify its behavior and adds it to AudioRendererConfig.">nn::audio::AcquireVoiceSlot()</a></code> initializes <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSource</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> that is the input source. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pDestination</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_splitter_type.html" title="This structure provides a feature to distribute the sample data of the VoiceType / SubMixType input s...">SplitterType</a></code> that is the output destination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pSource</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSource</em></code> is initialized.</li>
<li><code><em>pDestination</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDestination</em></code> is initialized.</li>
<li>If <code>true</code> is specified for <code><a class="el" href="structnn_1_1audio_1_1_voice_type_1_1_behavior_options.html#a670acd63d62ddcf4e79eb618e225a000" title="Skips pitch conversion and sampling rate conversion (SRC).">VoiceType::BehaviorOptions::isPitchAndSrcSkipped</a></code> in <code><a class="el" href="namespacenn_1_1audio.html#a3cc31617500698ba14f0d1d5e20b7668" title="Initializes VoiceType with options that specify its behavior and adds it to AudioRendererConfig.">AcquireVoiceSlot()</a></code>, that <code><a class="el" href="namespacenn_1_1audio.html#adad2134ecc8dc166e2eddce11ba7ca9e">GetVoiceSampleRate(pSource)</a></code> == <code><a class="el" href="namespacenn_1_1audio.html#a8be6d0e347070786c6a7805986982fc3">GetSplitterSampleRate(pDestination)</a></code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a362d4c2d8e84a10893cd11211851dc08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a362d4c2d8e84a10893cd11211851dc08">&#9670;&nbsp;</a></span>ClearVoiceDestination()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::ClearVoiceDestination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html">AudioRendererConfig</a> *&#160;</td>
          <td class="paramname"><em>pOutConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pSource</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the output destination specified for <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConfig</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_audio_renderer_config.html" title="Structure that manages audio renderer settings.">AudioRendererConfig</a></code> used when <code><a class="el" href="namespacenn_1_1audio.html#a3cc31617500698ba14f0d1d5e20b7668" title="Initializes VoiceType with options that specify its behavior and adds it to AudioRendererConfig.">nn::audio::AcquireVoiceSlot()</a></code> initializes <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSource</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutConfig</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutConfig</em></code> is initialized.</li>
<li><code><em>pOutVoice</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutVoice</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 For the operations on <code><em>pOutConfig</em></code> this function is thread-safe, but for the operations on <code><em>pSource</em></code> it is not thread-safe. Do not perform any operations on <code><em>pSource</em></code> while calling this function.</p>
<p><code><a class="el" href="namespacenn_1_1audio.html" title="Namespace for the audio library.">nn::audio</a></code> partially blocks access to <code><em>pOutConfig</em></code> while this function is in use. Note that the following functions, which use the same <code><em>pOutConfig</em></code>, may be blocked.</p><ul>
<li><code>AcquireFinalMix(AudioRendererConfig* pOutConfig, FinalMixType* <em>pOutFinalMix</em>, int <em>bufferCount</em>)</code></li>
<li><code>ReleaseFinalMix(AudioRendererConfig* <em>pOutConfig</em>, FinalMixType* <em>pFinalMix</em>)</code></li>
<li><code>AcquireSubMix(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pOutSubMix</em>, int <em>sampleRate</em>, int <em>bufferCount</em>)</code></li>
<li><code>ReleaseSubMix(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pSubMix</em>)</code></li>
<li><code>SetSubMixDestination(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pSource</em>, FinalMixType* <em>pDestination</em>)</code></li>
<li><code>SetSubMixDestination(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pSource</em>, SubMixType* <em>pDestination</em>)</code></li>
<li><code>ClearSubMixDestination(AudioRendererConfig* <em>pOutConfig</em>, SubMixType* <em>pSource</em>)</code></li>
</ul>
<p>Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code> is prohibited. For more information, see <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">RequestUpdateAudioRenderer()</a></code>. </p>

</div>
</div>
<a id="adad2134ecc8dc166e2eddce11ba7ca9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad2134ecc8dc166e2eddce11ba7ca9e">&#9670;&nbsp;</a></span>GetVoiceSampleRate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetVoiceSampleRate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pVoice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the sample rate of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pVoice</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the sample rate. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pVoice</em></code> != <code>nullptr</code>.</li>
<li><code><em>pVoice</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the sampling rate specified when <code><em>pVoice</em></code> was initialized using the <code><a class="el" href="namespacenn_1_1audio.html#a3cc31617500698ba14f0d1d5e20b7668" title="Initializes VoiceType with options that specify its behavior and adds it to AudioRendererConfig.">nn::audio::AcquireVoiceSlot()</a></code> function.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pVoice</em></code> while calling this function. </p>

</div>
</div>
<a id="a6da2095b63c0acec0795bb420d47019b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da2095b63c0acec0795bb420d47019b">&#9670;&nbsp;</a></span>GetVoiceChannelCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetVoiceChannelCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pVoice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of channels of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pVoice</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of channels. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pVoice</em></code> != <code>nullptr</code>.</li>
<li><code><em>pVoice</em></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a345a0ad833ebf792efac5e4cad96f8b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a345a0ad833ebf792efac5e4cad96f8b7">&#9670;&nbsp;</a></span>GetVoiceSampleFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1">SampleFormat</a> nn::audio::GetVoiceSampleFormat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pVoice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the sample format of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pVoice</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the sample format. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pVoice</em></code> != <code>nullptr</code>.</li>
<li><code><em>pVoice</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the sample format specified when <code><em>pVoice</em></code> was initialized using the <code><a class="el" href="namespacenn_1_1audio.html#a3cc31617500698ba14f0d1d5e20b7668" title="Initializes VoiceType with options that specify its behavior and adds it to AudioRendererConfig.">nn::audio::AcquireVoiceSlot()</a></code> function.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pVoice</em></code> while calling this function. </p>

</div>
</div>
<a id="adfcc54fa62e17bfafb7d1db80b5783d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfcc54fa62e17bfafb7d1db80b5783d1">&#9670;&nbsp;</a></span>SetVoicePriority()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetVoicePriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pVoice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the priority of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pVoice</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td>Priority. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pVoice</em></code> != <code>nullptr</code>.</li>
<li><code><em>pVoice</em></code> is initialized.</li>
<li>(<code><a class="el" href="structnn_1_1audio_1_1_voice_type.html#a564e9b6aee6dcb119664adc4b9f22149" title="Highest priority.">nn::audio::VoiceType::PriorityHighest</a></code> &lt;= <code><em>priority</em></code> &amp;&amp; <code><em>priority</em></code> &lt;= <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html#a4270b7e2b90f9ab75208774a539641a9" title="Lowest priority.">nn::audio::VoiceType::PriorityLowest</a></code>) </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#ae2bdbb3eb75d94e61b38739dff4b0044">GetVoicePriority(pVoice)</a></code> == <code><em>priority</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 For the priority, specify a value between <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html#a564e9b6aee6dcb119664adc4b9f22149" title="Highest priority.">VoiceType::PriorityHighest</a></code> and <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html#a4270b7e2b90f9ab75208774a539641a9" title="Lowest priority.">VoiceType::PriorityLowest</a></code>. The lower the value, the higher the priority.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pVoice</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="ae2bdbb3eb75d94e61b38739dff4b0044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2bdbb3eb75d94e61b38739dff4b0044">&#9670;&nbsp;</a></span>GetVoicePriority()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetVoicePriority </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pVoice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the priority of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pVoice</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the priority. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pVoice</em></code> != <code>nullptr</code>.</li>
<li><code><em>pVoice</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The priority is specified to some value between <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html#a564e9b6aee6dcb119664adc4b9f22149" title="Highest priority.">VoiceType::PriorityHighest</a></code> and <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html#a4270b7e2b90f9ab75208774a539641a9" title="Lowest priority.">VoiceType::PriorityLowest</a></code> by the functions <code><a class="el" href="namespacenn_1_1audio.html#a3cc31617500698ba14f0d1d5e20b7668" title="Initializes VoiceType with options that specify its behavior and adds it to AudioRendererConfig.">nn::audio::AcquireVoiceSlot()</a></code> and <code><a class="el" href="namespacenn_1_1audio.html#adfcc54fa62e17bfafb7d1db80b5783d1" title="Sets the priority of the VoiceType.">nn::audio::SetVoicePriority()</a></code>. The lower the value, the higher the priority.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pVoice</em></code> while calling this function. </p>

</div>
</div>
<a id="a04a09b692d969f08155cf7f0f57d9ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04a09b692d969f08155cf7f0f57d9ace">&#9670;&nbsp;</a></span>SetVoicePlayState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetVoicePlayState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pVoice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_voice_type.html#a8a74fe64f7b887248f696c25b76baf31">VoiceType::PlayState</a>&#160;</td>
          <td class="paramname"><em>playState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the play state for the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pVoice</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">playState</td><td>The playback state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pVoice</em></code> != <code>nullptr</code>.</li>
<li><code><em>pVoice</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a826e9a8d1f5cdc8874069d0c05a3fcbc">GetVoicePlayState(pVoice)</a></code> == <code><em>state</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Changes the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> playback state.</p>
<p>This state set using this function goes into effect after the next call to the <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> function.</p>
<p>The meanings for each of the <code><em>playState</em></code> values are as follows. <code>PlayState_Play</code> sets <code><em>pVoice</em></code> to the playback state. <code>PlayState_Stop</code> sets <code><em>pVoice</em></code> to the stopped state. When entering the stopped state, all added <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> instances are treated as played back. In addition, the value available with <code><a class="el" href="namespacenn_1_1audio.html#a6913685f14bb0b350eabb2517eb11dd4" title="Gets the number of samples that have been played by the VoiceType object.">nn::audio::GetVoicePlayedSampleCount()</a></code> is reset to <code>0</code>. The <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> objects that have have played back can be obtained using <code><a class="el" href="namespacenn_1_1audio.html#ad4736cbcae273e050d01416a7625b0d8" title="Get the WaveBuffer object that VoiceType has finished playing.">nn::audio::GetReleasedWaveBuffer()</a></code>. Note that at most two audio frames must have passed before <code><a class="el" href="namespacenn_1_1audio.html#ad4736cbcae273e050d01416a7625b0d8" title="Get the WaveBuffer object that VoiceType has finished playing.">nn::audio::GetReleasedWaveBuffer()</a></code> can be used to get anything. <code>PlayState_Pause</code> sets <code><em>pVoice</em></code> to the paused state. In contrast with using the <code>PlayState_Stop</code> setting, there is no effect on the state of added <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> objects or the value from <code><a class="el" href="namespacenn_1_1audio.html#a6913685f14bb0b350eabb2517eb11dd4" title="Gets the number of samples that have been played by the VoiceType object.">nn::audio::GetVoicePlayedSampleCount()</a></code>. Note that it might take an audio frame of time until Audio Renderer playback is completely paused, and during that interval, the values available from <code><a class="el" href="namespacenn_1_1audio.html#abf59c1474e52088399a523222992453d" title="Gets the number of playable WaveBuffer objects that have been registered to VoiceType.">nn::audio::GetWaveBufferCount()</a></code> and <code><a class="el" href="namespacenn_1_1audio.html#a6913685f14bb0b350eabb2517eb11dd4" title="Gets the number of samples that have been played by the VoiceType object.">GetVoicePlayedSampleCount()</a></code> might change. Setting to <code>PlayState_Play</code> once more after setting to <code>PlayState_Pause</code> resumes playback.</p>
<p>The behavior for any individual <code><em>playState</em></code> is not affected by whether the output destination is specified. This is true even for <code>PlayState_Play</code>.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pVoice</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a102">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a72">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a182">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a144">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a107">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a53">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a109">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a95">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a110">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a138">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a55">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a98">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#a50">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#a56">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a99">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a826e9a8d1f5cdc8874069d0c05a3fcbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a826e9a8d1f5cdc8874069d0c05a3fcbc">&#9670;&nbsp;</a></span>GetVoicePlayState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1audio_1_1_voice_type.html#a8a74fe64f7b887248f696c25b76baf31">VoiceType::PlayState</a> nn::audio::GetVoicePlayState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pVoice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the play state of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pVoice</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the playback state. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pVoice</em></code> != <code>nullptr</code>.</li>
<li><code><em>pVoice</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function returns <code>VoiceType::PlayState_Stop</code> immediately after <code><a class="el" href="namespacenn_1_1audio.html#a3cc31617500698ba14f0d1d5e20b7668" title="Initializes VoiceType with options that specify its behavior and adds it to AudioRendererConfig.">nn::audio::AcquireVoiceSlot()</a></code> is called. For more information about the behaviors configured using <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html#a8a74fe64f7b887248f696c25b76baf31" title="Enumerated type representing the play state.">VoiceType::PlayState</a></code>, see <code><a class="el" href="namespacenn_1_1audio.html#a826e9a8d1f5cdc8874069d0c05a3fcbc" title="Gets the play state of the VoiceType object.">nn::audio::GetVoicePlayState()</a></code>.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pVoice</em></code> while calling this function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a112">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a141">AudioRenderer/AudioRenderer.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a113">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a43dee40c156799c2e3e43da4e1b86cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43dee40c156799c2e3e43da4e1b86cd0">&#9670;&nbsp;</a></span>SetVoiceSrcQuality()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetVoiceSrcQuality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pVoice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_voice_type.html#a08afa9ca6e321c4a460ee9f50bc247d4">VoiceType::SrcQuality</a>&#160;</td>
          <td class="paramname"><em>srcQuality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the quality of the <a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a> sample rate conversion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pVoice</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcQuality</td><td>Sample rate conversion quality. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pVoice</em></code> != <code>nullptr</code>.</li>
<li><code><em>pVoice</em></code> is initialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><a class="el" href="namespacenn_1_1audio.html#af1e571f41a87a871569578709b42cbc3">GetVoiceSrcQuality(pVoice)</a> == srcQuality.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 If this function is called and the settings are changed during playback, noise may occur. We recommend changing the settings either before playback begins or while it is stopped. </p>

</div>
</div>
<a id="af1e571f41a87a871569578709b42cbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e571f41a87a871569578709b42cbc3">&#9670;&nbsp;</a></span>GetVoiceSrcQuality()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1audio_1_1_voice_type.html#a08afa9ca6e321c4a460ee9f50bc247d4">VoiceType::SrcQuality</a> nn::audio::GetVoiceSrcQuality </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pVoice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the quality of the <a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a> sample rate conversion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pVoice</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the sample rate conversion quality. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pVoice</em></code> != <code>nullptr</code>.</li>
<li><code><em>pVoice</em></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aabd2853027ae5ab1516dbf53dd6fb6d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd2853027ae5ab1516dbf53dd6fb6d9">&#9670;&nbsp;</a></span>SetVoicePitch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetVoicePitch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pVoice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pitch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the pitch for the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pVoice</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pitch</td><td>Pitch </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pVoice</em></code> != <code>nullptr</code>.</li>
<li><code><em>pVoice</em></code> is initialized.</li>
<li><code><a class="el" href="structnn_1_1audio_1_1_voice_type.html#a81b579faf5eab1cf5296058a0ec935bd" title="The minimum value that can be set for pitch (1.0f / 16.0f).">nn::audio::VoiceType::GetPitchMin()</a></code> &lt;= <code><em>pitch</em></code> &amp;&amp; <code><em>pitch</em></code> &lt;= <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html#a19835624f119d589d36d446726786808" title="The maximum value that can be set for pitch (16.0f).">nn::audio::VoiceType::GetPitchMax()</a></code>.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#ab628a73a812066c3644a75cc2631dfd9">nn::audio::GetVoiceBehaviorOptions(pVoice)</a>.isPitchAndSrcSkipped</code> == <code>false</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#aaa9a327d0d3ccacdfd7aa80ad2fbad81">GetVoicePitch(pVoice)</a></code> == <code><em>pitch</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pVoice</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a147">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, and <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a147">AudioRenderer/AudioRenderer.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aaa9a327d0d3ccacdfd7aa80ad2fbad81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa9a327d0d3ccacdfd7aa80ad2fbad81">&#9670;&nbsp;</a></span>GetVoicePitch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetVoicePitch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pVoice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the pitch of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pVoice</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the pitch. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pVoice</em></code> != <code>nullptr</code>.</li>
<li><code><em>pVoice</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function returns <code>1.0</code> immediately after <code><a class="el" href="namespacenn_1_1audio.html#a3cc31617500698ba14f0d1d5e20b7668" title="Initializes VoiceType with options that specify its behavior and adds it to AudioRendererConfig.">nn::audio::AcquireVoiceSlot()</a></code> is called.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pVoice</em></code> while calling this function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a144">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, and <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a144">AudioRenderer/AudioRenderer.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab682fee631b9558bea96e8c8d554e750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab682fee631b9558bea96e8c8d554e750">&#9670;&nbsp;</a></span>SetVoiceVolume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetVoiceVolume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pVoice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>volume</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the volume for the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pVoice</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">volume</td><td>Volume. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pVoice</em></code> != <code>nullptr</code>.</li>
<li><code><em>pVoice</em></code> is initialized.</li>
<li><code><a class="el" href="structnn_1_1audio_1_1_voice_type.html#a1a337fe56fabc84b42816087c9edcdb4" title="Gets the minimum value that can be set for volume and mix volume (-128.0f).">nn::audio::VoiceType::GetVolumeMin()</a></code> &lt;= <code><em>volume</em></code> &amp;&amp; <code><em>volume</em></code> &lt;= <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html#a8087b32e4c4af30cb788e4ac00653118" title="Gets the maximum value that can be set for volume and mix volume (128.0f).">nn::audio::VoiceType::GetVolumeMax()</a></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#ae1411aeea222ca74dd86380a9b54b748">GetVoiceVolume(pVoice)</a></code> == <code><em>volume</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pVoice</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> is prohibited. </p><dl class="section note"><dt>Note</dt><dd>Audio cutoff may occur depending on the set volume value. If audio cutoff occurs, verify that the volume is within appropriate values. If a negative volume value is set, the phase of the waveform is inverted. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a143">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a139">AudioRenderer/AudioRenderer.cpp</a>, and <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a139">AudioSplitter/AudioSplitter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae1411aeea222ca74dd86380a9b54b748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1411aeea222ca74dd86380a9b54b748">&#9670;&nbsp;</a></span>GetVoiceVolume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetVoiceVolume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pVoice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the volume of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pVoice</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the volume. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pVoice</em></code> != <code>nullptr</code>.</li>
<li><code><em>pVoice</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function returns <code>1.0</code> immediately after <code><a class="el" href="namespacenn_1_1audio.html#a3cc31617500698ba14f0d1d5e20b7668" title="Initializes VoiceType with options that specify its behavior and adds it to AudioRendererConfig.">nn::audio::AcquireVoiceSlot()</a></code> is called.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pVoice</em></code> while calling this function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a141">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, and <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a137">AudioRenderer/AudioRenderer.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a9a74d5457b16f38d3271eb452dcec395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a74d5457b16f38d3271eb452dcec395">&#9670;&nbsp;</a></span>SetVoiceMixVolume() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetVoiceMixVolume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pDestination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destinationIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the mix volume for the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSource</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> that is the input source. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pDestination</td><td>The <code>FinalMix</code> that is the output destination. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">volume</td><td>Mix volume. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceIndex</td><td>The channel number on the input side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destinationIndex</td><td>The mix buffer index for the output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pSource</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSource</em></code> is initialized.</li>
<li><code><em>pDestination</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDestination</em></code> is initialized.</li>
<li><code><a class="el" href="structnn_1_1audio_1_1_voice_type.html#a1a337fe56fabc84b42816087c9edcdb4" title="Gets the minimum value that can be set for volume and mix volume (-128.0f).">nn::audio::VoiceType::GetVolumeMin()</a></code> &lt;= <code><em>volume</em></code> &amp;&amp; <code><em>volume</em></code> &lt;= <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html#a8087b32e4c4af30cb788e4ac00653118" title="Gets the maximum value that can be set for volume and mix volume (128.0f).">nn::audio::VoiceType::GetVolumeMax()</a></code>.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a82bfb03f43f4a2680f5ad7eff0967545">nn::audio::SetVoiceDestination(pSource, pDestination)</a></code> has been run for <code><em>pSource</em></code> and <code><em>pDestination</em></code>.</li>
<li><code>0</code> &lt;= <code><em>sourceIndex</em></code> &amp;&amp; <code><em>sourceIndex</em></code> &lt; <code><a class="el" href="namespacenn_1_1audio.html#a6da2095b63c0acec0795bb420d47019b">nn::audio::GetVoiceChannelCount(pSource)</a></code>.</li>
<li><code>0</code> &lt;= <code><em>destinationIndex</em></code> &amp;&amp; <code><em>destinationIndex</em></code> &lt; <code><a class="el" href="namespacenn_1_1audio.html#a7652eae684b0d267e276cf7c01ac12d7">nn::audio::GetFinalMixBufferCount(pDestination)</a></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a87b36760a203ccd45174210b0fd21818">nn::audio::GetVoiceMixVolume(pSource, pDestination, sourceIndex, destinationIndex)</a></code> == <code><em>volume</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is not thread-safe. Do not perform any operations on <code><em>pVoice</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> is prohibited. </p><dl class="section note"><dt>Note</dt><dd>Audio cutoff may occur depending on the set volume value. If audio cutoff occurs, verify that the volume is within appropriate values. If a negative volume value is set, the phase of the waveform is inverted. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a103">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a115">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a183">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a145">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a108">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a54">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a110">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a96">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a111">AudioSink/AudioSink.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a56">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a99">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#a51">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#a57">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a100">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a87b36760a203ccd45174210b0fd21818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b36760a203ccd45174210b0fd21818">&#9670;&nbsp;</a></span>GetVoiceMixVolume() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetVoiceMixVolume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_final_mix_type.html">FinalMixType</a> *&#160;</td>
          <td class="paramname"><em>pDestination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destinationIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the mix volume of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSource</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> that is the input source. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pDestination</td><td>The <code>FinalMix</code> that is the output destination. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceIndex</td><td>The channel number on the input side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destinationIndex</td><td>The mix buffer index for the output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the mix volume for the specified <code><em>sourceIndex</em></code> and <code><em>destinationIndex</em></code>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pSource</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSource</em></code> is initialized.</li>
<li><code><em>pDestination</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDestination</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a82bfb03f43f4a2680f5ad7eff0967545">nn::audio::SetVoiceDestination(pSource, pDestination)</a></code> has been run for <code><em>pSource</em></code> and <code><em>pDestination</em></code>.</li>
<li><code>0</code> &lt;= <code><em>sourceIndex</em></code> &amp;&amp; <code><em>sourceIndex</em></code> &lt; <code><a class="el" href="namespacenn_1_1audio.html#a6da2095b63c0acec0795bb420d47019b">nn::audio::GetVoiceChannelCount(pSource)</a></code>.</li>
<li><code>0</code> &lt;= <code><em>destinationIndex</em></code> &amp;&amp; <code><em>destinationIndex</em></code> &lt; <code><a class="el" href="namespacenn_1_1audio.html#a7652eae684b0d267e276cf7c01ac12d7">nn::audio::GetFinalMixBufferCount(pDestination)</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The mix volume values immediately after calling <code><a class="el" href="namespacenn_1_1audio.html#a82bfb03f43f4a2680f5ad7eff0967545" title="Sets the FinalMix that is the output destination of the VoiceType.">nn::audio::SetVoiceDestination()</a></code> are all <code>0.0f</code>.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pVoice</em></code> while calling this function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a143">AudioRenderer/AudioRenderer.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a99ee35342e3a63683009e7d893db67b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ee35342e3a63683009e7d893db67b3">&#9670;&nbsp;</a></span>SetVoiceMixVolume() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetVoiceMixVolume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pDestination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destinationIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the mix volume for the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSource</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> that is the input source. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pDestination</td><td>The <code>SubMix</code> that is the output destination. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">volume</td><td>Mix volume. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceIndex</td><td>The channel number on the input side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destinationIndex</td><td>The mix buffer index for the output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pSource</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSource</em></code> is initialized.</li>
<li><code><em>pDestination</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDestination</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a421895cf9e6a2f604a3a2d01b1e98459">nn::audio::SetSubMixDestination(pSource, pDestination)</a></code> has been run for <code><em>pSource</em></code> and <code><em>pDestination</em></code>.</li>
<li><code><a class="el" href="structnn_1_1audio_1_1_voice_type.html#a1a337fe56fabc84b42816087c9edcdb4" title="Gets the minimum value that can be set for volume and mix volume (-128.0f).">nn::audio::VoiceType::GetVolumeMin()</a></code> &lt;= <code><em>volume</em></code> &amp;&amp; <code><em>volume</em></code> &lt;= <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html#a8087b32e4c4af30cb788e4ac00653118" title="Gets the maximum value that can be set for volume and mix volume (128.0f).">nn::audio::VoiceType::GetVolumeMax()</a></code>.</li>
<li><code>0</code> &lt;= <code><em>sourceIndex</em></code> &amp;&amp; <code><em>sourceIndex</em></code> &lt; <code><a class="el" href="namespacenn_1_1audio.html#a6da2095b63c0acec0795bb420d47019b">nn::audio::GetVoiceChannelCount(pSource)</a></code>.</li>
<li><code>0</code> &lt;= <code><em>destinationIndex</em></code> &amp;&amp; <code><em>destinationIndex</em></code> &lt; <code><a class="el" href="namespacenn_1_1audio.html#ad76ce2e4c558f038dab51a3a30c068e4">nn::audio::GetSubMixBufferCount(pDestination)</a></code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1audio.html#a87b36760a203ccd45174210b0fd21818">nn::audio::GetVoiceMixVolume(pSource, pDestination, sourceIndex, destinationIndex)</a></code> == <code><em>volume</em></code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4148242de491539dc39802da024bb2fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4148242de491539dc39802da024bb2fa">&#9670;&nbsp;</a></span>GetVoiceMixVolume() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float nn::audio::GetVoiceMixVolume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html">SubMixType</a> *&#160;</td>
          <td class="paramname"><em>pDestination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destinationIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the mix volume of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSource</td><td>The <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> that is the input source. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pDestination</td><td>The <code>SubMix</code> that is the output destination. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceIndex</td><td>The channel number on the input side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destinationIndex</td><td>The mix buffer index for the output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the mix volume for the specified <code><em>sourceIndex</em></code> and <code><em>destinationIndex</em></code>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pSource</em></code> != <code>nullptr</code>.</li>
<li><code><em>pSource</em></code> is initialized.</li>
<li><code><em>pDestination</em></code> != <code>nullptr</code>.</li>
<li><code><em>pDestination</em></code> is initialized.</li>
<li><code><a class="el" href="namespacenn_1_1audio.html#a421895cf9e6a2f604a3a2d01b1e98459">nn::audio::SetSubMixDestination(pSource, pDestination)</a></code> has been run for <code><em>pSource</em></code> and <code><em>pDestination</em></code>.</li>
<li><code>0</code> &lt;= <code><em>sourceIndex</em></code> &amp;&amp; <code><em>sourceIndex</em></code> &lt; <code><a class="el" href="namespacenn_1_1audio.html#a6da2095b63c0acec0795bb420d47019b">nn::audio::GetVoiceChannelCount(pSource)</a></code>.</li>
<li><code>0</code> &lt;= <code><em>destinationIndex</em></code> &amp;&amp; <code><em>destinationIndex</em></code> &lt; <code><a class="el" href="namespacenn_1_1audio.html#ad76ce2e4c558f038dab51a3a30c068e4">nn::audio::GetSubMixBufferCount(pDestination)</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The mix volume values immediately after calling <code><a class="el" href="namespacenn_1_1audio.html#a82bfb03f43f4a2680f5ad7eff0967545" title="Sets the FinalMix that is the output destination of the VoiceType.">nn::audio::SetVoiceDestination()</a></code> are all <code>0.0f</code>.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pVoice</em></code> while calling this function. </p>

</div>
</div>
<a id="a7e4277ca190567127f0a18b0b5f4755f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e4277ca190567127f0a18b0b5f4755f">&#9670;&nbsp;</a></span>SetVoiceBiquadFilterParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::SetVoiceBiquadFilterParameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pVoice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>filterIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_biquad_filter_parameter.html">BiquadFilterParameter</a> &amp;&#160;</td>
          <td class="paramname"><em>parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the biquad filter parameter for the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pVoice</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filterIndex</td><td>The index for the biquad filter whose parameter is being changed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter</td><td>Parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pVoice</em></code> != <code>nullptr</code>.</li>
<li><code><em>pVoice</em></code> is initialized.</li>
<li>(<code><em>filterIndex</em></code> == <code>0</code>) || (<code><em>filterIndex</em></code> == <code>1</code>).</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 A two-stage biquad filter is prepared for each <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object. You can specify which one to configure using <code><em>filterIndex</em></code>. Filtering is applied in order of <code>0</code>, <code>1</code> for <code><em>filterIndex</em></code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a112">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, and <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a107">AudioRenderer/AudioRenderer.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a880d8f048e8f06959e08fb611f3647ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880d8f048e8f06959e08fb611f3647ec">&#9670;&nbsp;</a></span>GetVoiceBiquadFilterParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1audio_1_1_biquad_filter_parameter.html">BiquadFilterParameter</a> nn::audio::GetVoiceBiquadFilterParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pVoice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>filterIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the biquad filter parameter of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pVoice</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filterIndex</td><td>The index for the biquad filter whose parameter is being obtained. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the parameters. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pVoice</em></code> != <code>nullptr</code>.</li>
<li><code><em>pVoice</em></code> is initialized.</li>
<li>(<code><em>filterIndex</em></code> == <code>0</code>) || (<code><em>filterIndex</em></code> == <code>1</code>). </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a140">AudioRenderer/AudioRenderer.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aa58886eeb3fac72d6e84dcad5d2704df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa58886eeb3fac72d6e84dcad5d2704df">&#9670;&nbsp;</a></span>AppendWaveBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::AppendWaveBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pVoice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_wave_buffer.html">WaveBuffer</a> *&#160;</td>
          <td class="paramname"><em>pWaveBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pVoice</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pWaveBuffer</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if successful, or <code>false</code> otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pVoice</em></code> != <code>nullptr</code>.</li>
<li><code><em>pVoice</em></code> is initialized.</li>
<li><code><em>pWaveBuffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>pWaveBuffer</em>-&gt;buffer</code> != <code>nullptr</code></li>
<li><code><em>pWaveBuffer</em>-&gt;buffer</code> is aligned to <code><a class="el" href="namespacenn_1_1audio.html#a61833f2e2cf0253e3054188e900315af" title="The alignment size for audio buffers.">nn::audio::BufferAlignSize</a></code>.</li>
<li><code><em>pWaveBuffer</em>-&gt;startSampleOffset</code> &gt;= <code>0</code>.</li>
<li><code><em>pWaveBuffer</em>-&gt;endSampleOffset</code> &gt;= <code>0</code>.</li>
<li><code><em>pWaveBuffer</em>-&gt;endSampleOffset</code> &gt;= <code><em>pWaveBuffer</em>-&gt;startSampleOffset</code>.</li>
<li>The sample in the range of [<code><em>pWaveBuffer</em>-&gt;startSampleOffset</code>, <code><em>pWaveBuffer</em>-&gt;endSampleOffset</code>) is in the range of the memory region specified by <code><em>pWaveBuffer</em>-&gt;buffer</code> and <code><em>pWaveBuffer</em>-&gt;size</code>.</li>
<li><code><em>pWaveBuffer</em>-&gt;buffer</code> refers to the start of the ADPCM frame when <code><a class="el" href="namespacenn_1_1audio.html#a345a0ad833ebf792efac5e4cad96f8b7">nn::audio::GetVoiceSampleFormat</a>"nn::audio::GetVoiceSampleFormat(pVoice)"</code> == <code><a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1ab78e0cfd4dc7851b77c0b4ad3c355a72" title="ADPCM format.">nn::audio::SampleFormat_Adpcm</a></code>.</li>
<li><code><em>pWaveBuffer</em>-&gt;pContext</code> is <code>nullptr</code> or aligned to <code><a class="el" href="namespacenn_1_1audio.html#a61833f2e2cf0253e3054188e900315af" title="The alignment size for audio buffers.">nn::audio::BufferAlignSize</a></code> when <code><a class="el" href="namespacenn_1_1audio.html#a345a0ad833ebf792efac5e4cad96f8b7">nn::audio::GetVoiceSampleFormat</a>"nn::audio::GetVoiceSampleFormat(pVoice)"</code> == <code><a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1ab78e0cfd4dc7851b77c0b4ad3c355a72" title="ADPCM format.">nn::audio::SampleFormat_Adpcm</a></code>.</li>
<li><code><em>pWaveBuffer</em>-&gt;contextSize</code> &gt; <code>0</code> when <code><a class="el" href="namespacenn_1_1audio.html#a345a0ad833ebf792efac5e4cad96f8b7">nn::audio::GetVoiceSampleFormat</a>"nn::audio::GetVoiceSampleFormat(pVoice)"</code> == <code><a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1ab78e0cfd4dc7851b77c0b4ad3c355a72" title="ADPCM format.">nn::audio::SampleFormat_Adpcm</a></code> and <code><em>pWaveBuffer</em>-&gt;pContext</code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 You can use this function to add multiple <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> objects. The behavior of this function is the same as when specifying an instance where <code><em>pMemberOptions</em>-&gt;isLoopInfoEnabled</code> == <code>false</code> in the <code><em>pMemberOptions</em></code> argument of <code><a class="el" href="namespacenn_1_1audio.html#aa58886eeb3fac72d6e84dcad5d2704df" title="Adds a WaveBuffer object to VoiceType.">nn::audio::AppendWaveBuffer</a>(VoiceType* <em>pVoice</em>, const WaveBuffer* <em>pWaveBuffer</em>, const <a class="el" href="structnn_1_1audio_1_1_wave_buffer_1_1_member_options.html" title="The option to specify enabled or disabled for each WaveBuffer structure member.">WaveBuffer::MemberOptions</a>* <em>pMemberOptions</em>)</code>. Playback happens continuously in the order in which they were added. If looped playback is specified for a <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code>, any <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> added subsequently is not played back.</p>
<p>Up to <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html#a1c60d07e5bdd8967c813e818af35b0aa" title="The maximum number of WaveBuffer objects that can be added to a VoiceType.">VoiceType::WaveBufferCountMax</a></code> instances of <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> can be added at the same time. If you want to add more than this number of <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> objects, you must wait for registered <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> objects to finish playing, and then call the <code><a class="el" href="namespacenn_1_1audio.html#ad4736cbcae273e050d01416a7625b0d8" title="Get the WaveBuffer object that VoiceType has finished playing.">nn::audio::GetReleasedWaveBuffer()</a></code> function.</p>
<p>The memory region specified for <code><em>pWaveBuffer</em>-&gt;buffer</code> and <code><em>pWaveBuffer</em>-&gt;<em>pContext</em></code> must be contained within the memory region specified for <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html" title="Structure for representing memory regions used by an audio renderer.">nn::audio::MemoryPoolType</a></code>, and that <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html" title="Structure for representing memory regions used by an audio renderer.">nn::audio::MemoryPoolType</a></code> must be attached. For more information, see the description for <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html" title="Structure for representing memory regions used by an audio renderer.">nn::audio::MemoryPoolType</a></code>.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pVoice</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a101">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a81">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a181">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a143">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a109">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a52">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a108">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a94">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a109">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a149">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a67">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a110">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#a62">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#a74">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a98">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a4c1b5be7d8f4137107b0f09d7813a76e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c1b5be7d8f4137107b0f09d7813a76e">&#9670;&nbsp;</a></span>AppendWaveBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::audio::AppendWaveBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pVoice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_wave_buffer.html">WaveBuffer</a> *&#160;</td>
          <td class="paramname"><em>pWaveBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_wave_buffer_1_1_member_options.html">WaveBuffer::MemberOptions</a> *&#160;</td>
          <td class="paramname"><em>pMemberOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> object to <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pVoice</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pWaveBuffer</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pMemberOptions</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer_1_1_member_options.html" title="The option to specify enabled or disabled for each WaveBuffer structure member.">WaveBuffer::MemberOptions</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if successful, or <code>false</code> otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pVoice</em></code> != <code>nullptr</code>.</li>
<li><code><em>pVoice</em></code> is initialized.</li>
<li><code><em>pWaveBuffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>pMemberOptions</em></code> != <code>nullptr</code>.</li>
<li><code><em>pWaveBuffer</em>-&gt;buffer</code> != <code>nullptr</code></li>
<li><code><em>pWaveBuffer</em>-&gt;buffer</code> is aligned to <code><a class="el" href="namespacenn_1_1audio.html#a61833f2e2cf0253e3054188e900315af" title="The alignment size for audio buffers.">nn::audio::BufferAlignSize</a></code>.</li>
<li><code><em>pWaveBuffer</em>-&gt;startSampleOffset</code> &gt;= <code>0</code>.</li>
<li><code><em>pWaveBuffer</em>-&gt;endSampleOffset</code> &gt;= <code>0</code>.</li>
<li><code><em>pWaveBuffer</em>-&gt;endSampleOffset</code> &gt;= <code><em>pWaveBuffer</em>-&gt;startSampleOffset</code>.</li>
<li>The sample in the range of [<code><em>pWaveBuffer</em>-&gt;startSampleOffset</code>, <code><em>pWaveBuffer</em>-&gt;endSampleOffset</code>) is in the range of the memory region specified by <code><em>pWaveBuffer</em>-&gt;buffer</code> and <code><em>pWaveBuffer</em>-&gt;size</code>.</li>
<li><code><em>pWaveBuffer</em>-&gt;buffer</code> refers to the start of the ADPCM frame when <code><a class="el" href="namespacenn_1_1audio.html#a345a0ad833ebf792efac5e4cad96f8b7">nn::audio::GetVoiceSampleFormat</a>"nn::audio::GetVoiceSampleFormat(pVoice)"</code> == <code><a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1ab78e0cfd4dc7851b77c0b4ad3c355a72" title="ADPCM format.">nn::audio::SampleFormat_Adpcm</a></code>.</li>
<li><code><em>pWaveBuffer</em>-&gt;pContext</code> is <code>nullptr</code> or aligned to <code><a class="el" href="namespacenn_1_1audio.html#a61833f2e2cf0253e3054188e900315af" title="The alignment size for audio buffers.">nn::audio::BufferAlignSize</a></code> when <code><a class="el" href="namespacenn_1_1audio.html#a345a0ad833ebf792efac5e4cad96f8b7">nn::audio::GetVoiceSampleFormat</a>"nn::audio::GetVoiceSampleFormat(pVoice)"</code> == <code><a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1ab78e0cfd4dc7851b77c0b4ad3c355a72" title="ADPCM format.">nn::audio::SampleFormat_Adpcm</a></code>.</li>
<li><code><em>pWaveBuffer</em>-&gt;contextSize</code> &gt; <code>0</code> when <code><a class="el" href="namespacenn_1_1audio.html#a345a0ad833ebf792efac5e4cad96f8b7">nn::audio::GetVoiceSampleFormat</a>"nn::audio::GetVoiceSampleFormat(pVoice)"</code> == <code><a class="el" href="namespacenn_1_1audio.html#a2edc363ab06840fc2eaf2acb551bf0c1ab78e0cfd4dc7851b77c0b4ad3c355a72" title="ADPCM format.">nn::audio::SampleFormat_Adpcm</a></code> and <code><em>pWaveBuffer</em>-&gt;pContext</code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<p>However, if <code><em>pMemberOptions</em>-&gt;isLoopInfoEnabled</code> == <code>true</code>, the following preconditions are added. </p><dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pWaveBuffer</em>-&gt;loopEndSampleOffset</code> &gt;= <code>0</code>.</li>
<li><code><em>pWaveBuffer</em>-&gt;loopEndSampleOffset</code> &gt;= <code><em>pWaveBuffer</em>-&gt;loopStartSampleOffset</code>.</li>
<li>The sample in the range of [<code><em>pWaveBuffer</em>-&gt;loopStartSampleOffset</code>, <code><em>pWaveBuffer</em>-&gt;loopEndSampleOffset</code>) is in the range of the memory region specified by <code><em>pWaveBuffer</em>-&gt;buffer</code> and <code><em>pWaveBuffer</em>-&gt;size</code>.</li>
<li><code><em>pWaveBuffer</em>-&gt;loopCount</code> &gt;= <code>0</code> || <code><em>pWaveBuffer</em>-&gt;loopCount</code> == <code>LoopCountForever</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 You can use this function to add multiple <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> objects. Playback happens continuously in the order in which they were added. If infinite is specified for the loop count of the added <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code>, any <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> added subsequently is not played back. The parameter for loop playback of the added <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> changes based on the instance settings specified in the <code><em>pMemberOptions</em></code> argument. For more information, see <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">nn::audio::WaveBuffer</a></code>.</p>
<p>Up to <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html#a1c60d07e5bdd8967c813e818af35b0aa" title="The maximum number of WaveBuffer objects that can be added to a VoiceType.">VoiceType::WaveBufferCountMax</a></code> instances of <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> can be added at the same time. If you want to add more than this number of <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> objects, you must wait for registered <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> objects to finish playing, and then call the <code><a class="el" href="namespacenn_1_1audio.html#ad4736cbcae273e050d01416a7625b0d8" title="Get the WaveBuffer object that VoiceType has finished playing.">nn::audio::GetReleasedWaveBuffer()</a></code> function.</p>
<p>The memory region specified for <code><em>pWaveBuffer</em>-&gt;buffer</code> and <code><em>pWaveBuffer</em>-&gt;<em>pContext</em></code> must be contained within the memory region specified for <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html" title="Structure for representing memory regions used by an audio renderer.">nn::audio::MemoryPoolType</a></code>, and that <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html" title="Structure for representing memory regions used by an audio renderer.">nn::audio::MemoryPoolType</a></code> must be attached. For more information, see the description for <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html" title="Structure for representing memory regions used by an audio renderer.">nn::audio::MemoryPoolType</a></code>.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pVoice</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="ad4736cbcae273e050d01416a7625b0d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4736cbcae273e050d01416a7625b0d8">&#9670;&nbsp;</a></span>GetReleasedWaveBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structnn_1_1audio_1_1_wave_buffer.html">WaveBuffer</a> * nn::audio::GetReleasedWaveBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pVoice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a> object that <a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a> has finished playing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pVoice</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to a <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> that has finished playing. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pVoice</em></code> != <code>nullptr</code>.</li>
<li><code><em>pVoice</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 If multiple <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> objects have finished playing, the one on which <code><a class="el" href="namespacenn_1_1audio.html#aa58886eeb3fac72d6e84dcad5d2704df" title="Adds a WaveBuffer object to VoiceType.">nn::audio::AppendWaveBuffer()</a></code> was first called is returned. You can get all of the <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> objects that have finished playing by calling this function repeatedly. Returns <code>nullptr</code> if none have finished playing. Returns <code>nullptr</code> if no <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> objects have been added to <code><em>pVoice</em></code>.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pVoice</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> is prohibited. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a140">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a129">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a205">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a166">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a113">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a56">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a133">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a136">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a113">AudioSink/AudioSink.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a72">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a121">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#a71">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#a82">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a112">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="abf59c1474e52088399a523222992453d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf59c1474e52088399a523222992453d">&#9670;&nbsp;</a></span>GetWaveBufferCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetWaveBufferCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pVoice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of playable <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> objects that have been registered to <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pVoice</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the count of playable <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> instances. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pVoice</em></code> != <code>nullptr</code>.</li>
<li><code><em>pVoice</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the number of playable <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> objects that have been registered to <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pVoice</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="a6913685f14bb0b350eabb2517eb11dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6913685f14bb0b350eabb2517eb11dd4">&#9670;&nbsp;</a></span>GetVoicePlayedSampleCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t nn::audio::GetVoicePlayedSampleCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pVoice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of samples that have been played by the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pVoice</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of samples that have played. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pVoice</em></code> != <code>nullptr</code>.</li>
<li><code><em>pVoice</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Returns the number of samples of output waveforms played back after calling <code><a class="el" href="namespacenn_1_1audio.html#a3cc31617500698ba14f0d1d5e20b7668" title="Initializes VoiceType with options that specify its behavior and adds it to AudioRendererConfig.">nn::audio::AcquireVoiceSlot()</a></code>. The number of samples increases monotonously. Not rewound in cases of looped playback or when playback spans more than one <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code>. However, if <code>true</code> is specified for the <code>isEndOfStream</code> object of the <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> added to <code><em>pVoice</em></code>, the sample number rolls back to 0 when that <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> finishes playing.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pVoice</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="ad3bf0c7c1c51313ae9b05a0a3f3720f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3bf0c7c1c51313ae9b05a0a3f3720f7">&#9670;&nbsp;</a></span>GetVoiceNodeId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nn::audio::GetVoiceNodeId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pVoice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the ID of the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> in the audio renderer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pVoice</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>NodeId</code>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pVoice</em></code> != <code>nullptr</code>.</li>
<li><code><em>pVoice</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code>NodeId</code> is a numeric value that uniquely identifies the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_device_sink_type.html" title="Sink to output the rendering results to the audio output device.">DeviceSinkType</a></code>, and <code><a class="el" href="structnn_1_1audio_1_1_circular_buffer_sink_type.html" title="Sink to output the rendering results to memory.">CircularBufferSinkType</a></code> objects registered to the audio renderer. The various <code>NodeId</code> objects are never duplicated within a single audio renderer. A <code>NodeId</code> is assigned to each instance of an added <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>, <code><a class="el" href="structnn_1_1audio_1_1_sub_mix_type.html" title="Structure representing SubMix.">SubMixType</a></code>, or <code><a class="el" href="structnn_1_1audio_1_1_final_mix_type.html" title="Structure representing FinalMix.">FinalMixType</a></code>.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pVoice</em></code> while calling this function. Calling this function simultaneously with <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> is prohibited. </p>

</div>
</div>
<a id="afb313288140d4236cd42e19aca3f98e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb313288140d4236cd42e19aca3f98e6">&#9670;&nbsp;</a></span>FlushWaveBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nn::audio::FlushWaveBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pVoice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> objects registered to <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> as finished being played. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pVoice</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pVoice</em></code> != <code>nullptr</code>.</li>
<li><code><em>pVoice</em></code> is initialized.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sets all <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> objects registered to <code><em>pVoice</em></code> as finished being played.</p>
<p>This state set using this function goes into effect after the next call to the <code><a class="el" href="namespacenn_1_1audio.html#ac555128156197608dfaeeb5e824780a6" title="Updates the parameters for Voice objects bound to the audio renderer.">nn::audio::RequestUpdateAudioRenderer()</a></code> function.</p>
<p>Note that although you can get played <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> objects using <code><a class="el" href="namespacenn_1_1audio.html#ad4736cbcae273e050d01416a7625b0d8" title="Get the WaveBuffer object that VoiceType has finished playing.">nn::audio::GetReleasedWaveBuffer()</a></code>, as many as two audio frames can elapse before this function can get those objects.</p>
<p>This function is not thread-safe. Do not perform any operations on <code><em>pVoice</em></code> while calling this function. </p>

</div>
</div>
<a id="ab628a73a812066c3644a75cc2631dfd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab628a73a812066c3644a75cc2631dfd9">&#9670;&nbsp;</a></span>GetVoiceBehaviorOptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1audio_1_1_voice_type_1_1_behavior_options.html">VoiceType::BehaviorOptions</a> nn::audio::GetVoiceBehaviorOptions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1audio_1_1_voice_type.html">VoiceType</a> *&#160;</td>
          <td class="paramname"><em>pVoice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a group of options indicating the behavior configured for a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pVoice</td><td>Pointer to a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a group of options indicating behavior. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pVoice</em></code> != <code>nullptr</code>.</li>
<li><code><em>pVoice</em></code> is initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a256ee73aed3239d2e3f9455f0502cca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256ee73aed3239d2e3f9455f0502cca1">&#9670;&nbsp;</a></span>AudioCoprocessorFrameTimeLimit</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::int32_t nn::audio::AudioCoprocessorFrameTimeLimit = 4000</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The audio coprocessor is the maximum amount of time, in microseconds, available for processing of one audio frame. </p>
<p> <b>Details</b> <br  />
 If the audio renderer continues to perform rendering after exceeding this period, there will not be enough time to provide waveforms to the audio output device, and audio skipping may occur. When running multiple audio renderers simultaneously, audio skipping may occur if the total value of the processing times of each audio renderer exceeds this period.</p>
<p>You can use <code><a class="el" href="structnn_1_1audio_1_1_performance_frame_header.html#a24dcf23b3f76fe11d86dab058ececc45" title="The processing time that was required for the audio frame corresponding to this PerformanceFrame (in ...">nn::audio::PerformanceFrameHeader::totalProcessingTime</a></code> to get the time it took for the audio renderer to process an audio frame.</p>
<div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
<ul>
<li>On the Switch platform, because the application and system both use the DSP (audio coprocessor) simultaneously, the DSP resources allocated to each of them are both managed. For more information, see <a href="../../Package/contents/Pages/Page_912051027.html#Anchor_912051027_DspResourceLimitations">DSP Resource Limitations</a>.</li>
</ul>
</div><div class="platform_section" data-platform="NX"></div><div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
<ul>
<li>In the Windows environment, there are no restrictions on the amount of time available for processing of one audio frame.</li>
</ul>
</div><div class="platform_section" data-platform="Windows"></div> 
</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
