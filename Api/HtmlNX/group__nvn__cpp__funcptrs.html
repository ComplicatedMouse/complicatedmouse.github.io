<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>API Function Pointer Types | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">API Function Pointer Types<div class="ingroups"><a class="el" href="group__nvn__cpp__interface.html">NVN C++ API Bindings</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>C++ Interface function pointer data types.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga6073750719730281ec9203011b6db9c8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__nvn__cpp__funcptrs.html#gadea6f5a69c8fd9e20a3c0b4cedde14c4">GenericFuncPtrFunc</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__cpp__funcptrs.html#ga6073750719730281ec9203011b6db9c8">nvn::BootstrapLoaderFunc</a>) (const char *name)</td></tr>
<tr class="memdesc:ga6073750719730281ec9203011b6db9c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer type used to retreive main API entry points such as nvnDeviceInitialize and nvnDeviceGetProcAddress.  <a href="group__nvn__cpp__funcptrs.html#ga6073750719730281ec9203011b6db9c8">More...</a><br /></td></tr>
<tr class="separator:ga6073750719730281ec9203011b6db9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b2c74544158547abb83cc4753f3a5cf"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__cpp__funcptrs.html#ga6b2c74544158547abb83cc4753f3a5cf">nvn::CommandBufferMemoryCallbackFunc</a>) (<a class="el" href="classnvn_1_1_command_buffer.html">CommandBuffer</a> *cmdBuf, <a class="el" href="structnvn_1_1_command_buffer_memory_event.html#ae205102e87335273e0529a0747921686">CommandBufferMemoryEvent::Enum</a> event, size_t minSize, void *callbackData)</td></tr>
<tr class="memdesc:ga6b2c74544158547abb83cc4753f3a5cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer called when we have run out of memory in a command buffer.  <a href="group__nvn__cpp__funcptrs.html#ga6b2c74544158547abb83cc4753f3a5cf">More...</a><br /></td></tr>
<tr class="separator:ga6b2c74544158547abb83cc4753f3a5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac29ab0f1c39a8a2e75f59f0726263ab2"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__cpp__funcptrs.html#gac29ab0f1c39a8a2e75f59f0726263ab2">nvn::DebugCallbackFunc</a>) (<a class="el" href="structnvn_1_1_debug_callback_source.html#acbee107d7c1abfc8169aeb8d96073788">DebugCallbackSource::Enum</a> source, <a class="el" href="structnvn_1_1_debug_callback_type.html#a801d0de4144816fffb266672cf30f299">DebugCallbackType::Enum</a> type, int id, <a class="el" href="structnvn_1_1_debug_callback_severity.html#af3a776a17511243cd7bcd936df710278">DebugCallbackSeverity::Enum</a> severity, const char *message, void *userParam)</td></tr>
<tr class="memdesc:gac29ab0f1c39a8a2e75f59f0726263ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer type used to specify a function to call for debug callbacks.  <a href="group__nvn__cpp__funcptrs.html#gac29ab0f1c39a8a2e75f59f0726263ab2">More...</a><br /></td></tr>
<tr class="separator:gac29ab0f1c39a8a2e75f59f0726263ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadea6f5a69c8fd9e20a3c0b4cedde14c4"><td class="memItemLeft" align="right" valign="top"><a id="gadea6f5a69c8fd9e20a3c0b4cedde14c4"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__cpp__funcptrs.html#gadea6f5a69c8fd9e20a3c0b4cedde14c4">nvn::GenericFuncPtrFunc</a>) ()</td></tr>
<tr class="memdesc:gadea6f5a69c8fd9e20a3c0b4cedde14c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic function pointer type returned when querying API entry points. <br /></td></tr>
<tr class="separator:gadea6f5a69c8fd9e20a3c0b4cedde14c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3f7074f3a5a6d8b34415290dde28b04"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__cpp__funcptrs.html#gab3f7074f3a5a6d8b34415290dde28b04">nvn::InstallGlobalDebugCallbackFunc</a>) (const <a class="el" href="group__nvn__cpp__funcptrs.html#gac29ab0f1c39a8a2e75f59f0726263ab2">DebugCallbackFunc</a> callback, void *callbackData)</td></tr>
<tr class="memdesc:gab3f7074f3a5a6d8b34415290dde28b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer to a function that installs a global debug callback.  <a href="group__nvn__cpp__funcptrs.html#gab3f7074f3a5a6d8b34415290dde28b04">More...</a><br /></td></tr>
<tr class="separator:gab3f7074f3a5a6d8b34415290dde28b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e02e3cb3d0921116b9c1a54fc99fa3b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__cpp__funcptrs.html#ga1e02e3cb3d0921116b9c1a54fc99fa3b">nvn::WalkDebugDatabaseCallbackFunc</a>) (void *object, void *userParam)</td></tr>
<tr class="memdesc:ga1e02e3cb3d0921116b9c1a54fc99fa3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer to be triggered for every object in the debug layer object database during a walk.  <a href="group__nvn__cpp__funcptrs.html#ga1e02e3cb3d0921116b9c1a54fc99fa3b">More...</a><br /></td></tr>
<tr class="separator:ga1e02e3cb3d0921116b9c1a54fc99fa3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>C++ Interface function pointer data types. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga6073750719730281ec9203011b6db9c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6073750719730281ec9203011b6db9c8">&#9670;&nbsp;</a></span>BootstrapLoaderFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__nvn__cpp__funcptrs.html#gadea6f5a69c8fd9e20a3c0b4cedde14c4">GenericFuncPtrFunc</a>(* nvn::BootstrapLoaderFunc) (const char *name)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function pointer type used to retreive main API entry points such as nvnDeviceInitialize and nvnDeviceGetProcAddress. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the C entry point to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac29ab0f1c39a8a2e75f59f0726263ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac29ab0f1c39a8a2e75f59f0726263ab2">&#9670;&nbsp;</a></span>DebugCallbackFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* nvn::DebugCallbackFunc) (<a class="el" href="structnvn_1_1_debug_callback_source.html#acbee107d7c1abfc8169aeb8d96073788">DebugCallbackSource::Enum</a> source, <a class="el" href="structnvn_1_1_debug_callback_type.html#a801d0de4144816fffb266672cf30f299">DebugCallbackType::Enum</a> type, int id, <a class="el" href="structnvn_1_1_debug_callback_severity.html#af3a776a17511243cd7bcd936df710278">DebugCallbackSeverity::Enum</a> severity, const char *message, void *userParam)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function pointer type used to specify a function to call for debug callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">source</td><td>Value passed to the callback to indicate the source of the callback.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">type</td><td>Value passed to the callback to indicate the reason for the callback.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">id</td><td>Value passed to the callback providing an 'error code' for the callback. Specifies an implementation-specific identifier number providing more info on the callback. For errors, this is an error code.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">severity</td><td>Value passed to the callback to indicate the severity of the callback.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">message</td><td>Text string passed to the callback with more information on the callback.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">userParam</td><td>Value passed to the callback holding a 'user pointer' specified when the callback was registered. Can be used by application code to specify a pointer to a data structure that should be used by the callback function. For example, if the callback logs messages to a file, userParam could be a file descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_graphics_context_8cpp-example.html#a19">NvnSimple/NvnSimpleSharedLib/GraphicsContext.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga6b2c74544158547abb83cc4753f3a5cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b2c74544158547abb83cc4753f3a5cf">&#9670;&nbsp;</a></span>CommandBufferMemoryCallbackFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* nvn::CommandBufferMemoryCallbackFunc) (<a class="el" href="classnvn_1_1_command_buffer.html">CommandBuffer</a> *cmdBuf, <a class="el" href="structnvn_1_1_command_buffer_memory_event.html#ae205102e87335273e0529a0747921686">CommandBufferMemoryEvent::Enum</a> event, size_t minSize, void *callbackData)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function pointer called when we have run out of memory in a command buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">cmdBuf</td><td>Command buffer that has run out of memory.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">event</td><td>Type of out-of-memory event triggering the callback.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">minSize</td><td>Minimum size of required memory in bytes. When running out of memory during regular command set construction it is recommended for applications to provide at least the minimum amount of memory, given by the device properties <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da7979a293e47d4690567f1b0227eea8ea" title="Minimum size (in bytes) recommended for command data in a command builder.">DeviceInfo::COMMAND_BUFFER_MIN_COMMAND_SIZE</a> and <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da25b4e62d82e860cf2fab06c81fc09ff7" title="Minimum size (in bytes) recommended for control data in a command builder.">DeviceInfo::COMMAND_BUFFER_MIN_CONTROL_SIZE</a>. When building command sets from other command sets using <a class="el" href="classnvn_1_1_command_buffer.html#a5d1d30a924b48b7691a509f28783ae55" title="Insert copies of previously recorded command sets into the command set under construction.">CommandBuffer::CopyCommands</a>, this parameter will specify the minimum amount of size required to copy all or portions of the command set being copied. Applications can reduce the frequency of out-of-memory callbacks by providing memory blocks larger than the minimum required size.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">callbackData</td><td>Generic pointer registered as the callback data for the command buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1e02e3cb3d0921116b9c1a54fc99fa3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e02e3cb3d0921116b9c1a54fc99fa3b">&#9670;&nbsp;</a></span>WalkDebugDatabaseCallbackFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* nvn::WalkDebugDatabaseCallbackFunc) (void *object, void *userParam)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function pointer to be triggered for every object in the debug layer object database during a walk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">object</td><td>Pointer to the API object. Type of the object is given as parameter into Device::WalkDebugDatabasePointer</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">userParam</td><td>Generic user pointer passed into Device::WalkDebugDatabasePointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab3f7074f3a5a6d8b34415290dde28b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3f7074f3a5a6d8b34415290dde28b04">&#9670;&nbsp;</a></span>InstallGlobalDebugCallbackFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* nvn::InstallGlobalDebugCallbackFunc) (const <a class="el" href="group__nvn__cpp__funcptrs.html#gac29ab0f1c39a8a2e75f59f0726263ab2">DebugCallbackFunc</a> callback, void *callbackData)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function pointer to a function that installs a global debug callback. </p>
<p>This command installs a global debug callback function that will be called when errors are detected during NVN initialization or when errors are detected by the NVN debug layer (if enabled). The global callback is the only way for applications to receive notifications of NVN initialization errors because a device must be successfully initialized before calling nvnDeviceInstallDebugCallback. When the debug layer detects errors after initialization, it calls the global callback (if installed) as well as any callbacks installed by nvnDeviceInstallDebugCallback.</p>
<p>NVN supports only a single global callback. When this function is called, any previously installed global callback (if any) is uninstalled. If callback is set to NULL, no global callback will be installed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">callback</td><td>Pointer to a callback function to call.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">callbackData</td><td>Pointer to arbitrary data to pass in each call to the callback function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
