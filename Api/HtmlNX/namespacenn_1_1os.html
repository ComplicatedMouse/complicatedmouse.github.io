<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nn::os Namespace Reference | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenn.html">nn</a></li><li class="navelem"><a class="el" href="namespacenn_1_1os.html">os</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">nn::os Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is the namespace for the operating system library.  
<a href="namespacenn_1_1os.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_barrier.html">Barrier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for handling barriers.  <a href="classnn_1_1os_1_1_barrier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_barrier_type.html">BarrierType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure defines a barrier object.  <a href="structnn_1_1os_1_1_barrier_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_busy_mutex.html">BusyMutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class for handling busy mutex objects.  <a href="classnn_1_1os_1_1_busy_mutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_busy_mutex_type.html">BusyMutexType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure that define a busy mutex object.  <a href="structnn_1_1os_1_1_busy_mutex_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_condition_variable.html">ConditionVariable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for handling condition variables.  <a href="classnn_1_1os_1_1_condition_variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_condition_variable_type.html">ConditionVariableType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure defines a condition variable object.  <a href="structnn_1_1os_1_1_condition_variable_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_event.html">Event</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for handling events.  <a href="classnn_1_1os_1_1_event.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure defines an event object.  <a href="structnn_1_1os_1_1_event_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_fiber_type.html">FiberType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure defines a fiber object.  <a href="structnn_1_1os_1_1_fiber_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_light_event.html">LightEvent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for handling lightweight events.  <a href="classnn_1_1os_1_1_light_event.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_light_event_type.html">LightEventType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure defines a lightweight event object.  <a href="structnn_1_1os_1_1_light_event_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_light_message_queue.html">LightMessageQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for handling light message queues.  <a href="classnn_1_1os_1_1_light_message_queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html">LightMessageQueueType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure defines a light message queue object.  <a href="structnn_1_1os_1_1_light_message_queue_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_light_semaphore.html">LightSemaphore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for handling light semaphores.  <a href="classnn_1_1os_1_1_light_semaphore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html">LightSemaphoreType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure defines a light semaphore object.  <a href="structnn_1_1os_1_1_light_semaphore_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_memory_info.html">MemoryInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure for storing the obtained memory information.  <a href="structnn_1_1os_1_1_memory_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_message_queue.html">MessageQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for handling message queues.  <a href="classnn_1_1os_1_1_message_queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure defines a message queue object.  <a href="structnn_1_1os_1_1_message_queue_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure defines a multiwait object holder.  <a href="structnn_1_1os_1_1_multi_wait_holder_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure defines a multiwait object.  <a href="structnn_1_1os_1_1_multi_wait_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_mutex.html">Mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for handling mutexes.  <a href="classnn_1_1os_1_1_mutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure defines a mutex object.  <a href="structnn_1_1os_1_1_mutex_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_reader_writer_lock.html">ReaderWriterLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for handling readers-writer locks.  <a href="classnn_1_1os_1_1_reader_writer_lock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure for defining a readers-writer lock object.  <a href="structnn_1_1os_1_1_reader_writer_lock_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_access_violation.html">ResultAccessViolation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>os</code>: Illegal access detected.).  <a href="classnn_1_1os_1_1_result_access_violation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_bad_request.html">ResultBadRequest</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>os</code>: Invalid request code.).  <a href="classnn_1_1os_1_1_result_bad_request.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_busy.html">ResultBusy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>os</code>: Resource is in use.).  <a href="classnn_1_1os_1_1_result_busy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_deadlock.html">ResultDeadlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>os</code>: Deadlock.).  <a href="classnn_1_1os_1_1_result_deadlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_internal_error.html">ResultInternalError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>os</code>: Internal error.).  <a href="classnn_1_1os_1_1_result_internal_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_invalid_address.html">ResultInvalidAddress</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>os</code>: Invalid address.).  <a href="classnn_1_1os_1_1_result_invalid_address.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_invalid_parameter.html">ResultInvalidParameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>os</code>: Invalid argument (parameter).).  <a href="classnn_1_1os_1_1_result_invalid_parameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_no_permission.html">ResultNoPermission</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>os</code>: Unauthorized operation.).  <a href="classnn_1_1os_1_1_result_no_permission.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_not_implemented.html">ResultNotImplemented</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>os</code>: Function not implemented.).  <a href="classnn_1_1os_1_1_result_not_implemented.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_not_supported.html">ResultNotSupported</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>os</code>: Not implemented.).  <a href="classnn_1_1os_1_1_result_not_supported.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_out_of_memory.html">ResultOutOfMemory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>os</code>: Insufficient free memory.).  <a href="classnn_1_1os_1_1_result_out_of_memory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_out_of_resource.html">ResultOutOfResource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>os</code>: Insufficient free resources.).  <a href="classnn_1_1os_1_1_result_out_of_resource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_out_of_virtual_address_space.html">ResultOutOfVirtualAddressSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>os</code>: Insufficient virtual address space.).  <a href="classnn_1_1os_1_1_result_out_of_virtual_address_space.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_overflow.html">ResultOverflow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>os</code>: Maximum value exceeded.).  <a href="classnn_1_1os_1_1_result_overflow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_resource_limit.html">ResultResourceLimit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>os</code>: Reached the upper limit on resources to be used.).  <a href="classnn_1_1os_1_1_result_resource_limit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_timedout.html">ResultTimedout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>os</code>: Operation timed out.).  <a href="classnn_1_1os_1_1_result_timedout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_semaphore.html">Semaphore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for handling semaphores.  <a href="classnn_1_1os_1_1_semaphore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure defines a semaphore object.  <a href="structnn_1_1os_1_1_semaphore_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_system_event.html">SystemEvent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for handling system events.  <a href="classnn_1_1os_1_1_system_event.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_system_event_type.html">SystemEventType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure defines a system event object.  <a href="structnn_1_1os_1_1_system_event_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_thread_local_storage.html">ThreadLocalStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for handling thread-local storage.  <a href="classnn_1_1os_1_1_thread_local_storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure defines a thread object.  <a href="structnn_1_1os_1_1_thread_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_tick.html">Tick</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for handling system ticks.  <a href="classnn_1_1os_1_1_tick.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_timer_event.html">TimerEvent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for handling timer events.  <a href="classnn_1_1os_1_1_timer_event.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure defines a timer event object.  <a href="structnn_1_1os_1_1_timer_event_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_tls_slot.html">TlsSlot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This type represents a TLS slot number.  <a href="structnn_1_1os_1_1_tls_slot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_user_exception_info.html">UserExceptionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure that stores the exception information.  <a href="structnn_1_1os_1_1_user_exception_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_user_exception_info_detail.html">UserExceptionInfoDetail</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure that stores the exception information.  <a href="structnn_1_1os_1_1_user_exception_info_detail.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_user_exception_info_detail_aarch32_status32.html">UserExceptionInfoDetailAarch32Status32</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure that stores detailed information about exceptions in the ARMv7A operating environment.  <a href="structnn_1_1os_1_1_user_exception_info_detail_aarch32_status32.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_user_exception_info_detail_aarch32_status64.html">UserExceptionInfoDetailAarch32Status64</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure that stores detailed information about exceptions in the ARMv8-A, AArch32 operating environments.  <a href="structnn_1_1os_1_1_user_exception_info_detail_aarch32_status64.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_user_exception_info_detail_aarch64.html">UserExceptionInfoDetailAarch64</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure that stores detailed information about exceptions in the ARMv8-A, AArch64 operating environment.  <a href="structnn_1_1os_1_1_user_exception_info_detail_aarch64.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_user_exception_info_detail_win32.html">UserExceptionInfoDetailWin32</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure that stores detailed information about exceptions in the Windows environment.  <a href="structnn_1_1os_1_1_user_exception_info_detail_win32.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_virtual_address_memory_resource_usage.html">VirtualAddressMemoryResourceUsage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to store the amount of virtual address memory management resources consumed.  <a href="structnn_1_1os_1_1_virtual_address_memory_resource_usage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a00a0fffd9172c3779939c06927973bed"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structnn_1_1os_1_1_fiber_type.html">FiberType</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a00a0fffd9172c3779939c06927973bed">FiberFunction</a>) (void *argument)</td></tr>
<tr class="memdesc:a00a0fffd9172c3779939c06927973bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">This type represents the entry point of a fiber function.  <a href="namespacenn_1_1os.html#a00a0fffd9172c3779939c06927973bed">More...</a><br /></td></tr>
<tr class="separator:a00a0fffd9172c3779939c06927973bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b48561ef817ac28bde556d321a382e"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a84b48561ef817ac28bde556d321a382e">NativeHandle</a></td></tr>
<tr class="memdesc:a84b48561ef817ac28bde556d321a382e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type representing handles that are managed by the system.  <a href="namespacenn_1_1os.html#a84b48561ef817ac28bde556d321a382e">More...</a><br /></td></tr>
<tr class="separator:a84b48561ef817ac28bde556d321a382e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec974a5d224f7c62cfa9af4af3c954a"><td class="memItemLeft" align="right" valign="top"><a id="abec974a5d224f7c62cfa9af4af3c954a"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#abec974a5d224f7c62cfa9af4af3c954a">ThreadFunction</a>) (void *)</td></tr>
<tr class="memdesc:abec974a5d224f7c62cfa9af4af3c954a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This type represents the entry point of a thread function. <br /></td></tr>
<tr class="separator:abec974a5d224f7c62cfa9af4af3c954a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ce3817621fa1ea9b26c4f55c3bb284"><td class="memItemLeft" align="right" valign="top"><a id="a34ce3817621fa1ea9b26c4f55c3bb284"></a>
typedef nn::Bit64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a34ce3817621fa1ea9b26c4f55c3bb284">ThreadId</a></td></tr>
<tr class="memdesc:a34ce3817621fa1ea9b26c4f55c3bb284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type that represents the thread identifier. <br /></td></tr>
<tr class="separator:a34ce3817621fa1ea9b26c4f55c3bb284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af369e7c06c6548eebe7abda706ec54f3"><td class="memItemLeft" align="right" valign="top"><a id="af369e7c06c6548eebe7abda706ec54f3"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#af369e7c06c6548eebe7abda706ec54f3">TlsDestructor</a>) (uintptr_t value)</td></tr>
<tr class="memdesc:af369e7c06c6548eebe7abda706ec54f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This type represents a TLS destructor function. <br /></td></tr>
<tr class="separator:af369e7c06c6548eebe7abda706ec54f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff433bbe881d0fcb8fbb47fe3e299173"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#aff433bbe881d0fcb8fbb47fe3e299173">UserExceptionHandler</a>) (<a class="el" href="structnn_1_1os_1_1_user_exception_info.html">UserExceptionInfo</a> *info)</td></tr>
<tr class="memdesc:aff433bbe881d0fcb8fbb47fe3e299173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type representing a user exception handler function.  <a href="namespacenn_1_1os.html#aff433bbe881d0fcb8fbb47fe3e299173">More...</a><br /></td></tr>
<tr class="separator:aff433bbe881d0fcb8fbb47fe3e299173"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae1fe4fe10826c19cf2c66e534962180a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ae1fe4fe10826c19cf2c66e534962180a">ConditionVariableStatus</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1os.html#ae1fe4fe10826c19cf2c66e534962180aa4cad80372ca8b9c68ee8d1a34e806d24">ConditionVariableStatus_Timeout</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1os.html#ae1fe4fe10826c19cf2c66e534962180aa2f5f309e61d650e34b30f0308c17818c">ConditionVariableStatus_NoTimeout</a> = 1
<br />
 }</td></tr>
<tr class="memdesc:ae1fe4fe10826c19cf2c66e534962180a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The enumerated type representing the return values related to the feature for waiting for a condition variable with a time limit.  <a href="namespacenn_1_1os.html#ae1fe4fe10826c19cf2c66e534962180a">More...</a><br /></td></tr>
<tr class="separator:ae1fe4fe10826c19cf2c66e534962180a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ab71d44973a4135958c420e5682452"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452">EventClearMode</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a8b702480f5120eeeb01e7102227285da">EventClearMode_ManualClear</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a31f6133098296b3ddb7e14da3dc695cc">EventClearMode_AutoClear</a> = 1
<br />
 }</td></tr>
<tr class="memdesc:a11ab71d44973a4135958c420e5682452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates the clear modes of an event.  <a href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452">More...</a><br /></td></tr>
<tr class="separator:a11ab71d44973a4135958c420e5682452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b515dc6753642a34364d91b5813104"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a39b515dc6753642a34364d91b5813104">FiberFlag</a> { <a class="el" href="namespacenn_1_1os.html#a39b515dc6753642a34364d91b5813104ac2bbce12f37e3e01eb6a244e2ada14c7">FiberFlag_NoStackGuard</a> = 0x1
 }</td></tr>
<tr class="memdesc:a39b515dc6753642a34364d91b5813104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates the flags associated with fibers.  <a href="namespacenn_1_1os.html#a39b515dc6753642a34364d91b5813104">More...</a><br /></td></tr>
<tr class="separator:a39b515dc6753642a34364d91b5813104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883ab0b53c72a07619d9e83de4836b9a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a883ab0b53c72a07619d9e83de4836b9a">MemoryPermission</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1os.html#a883ab0b53c72a07619d9e83de4836b9aaf6942de46447bc0df8294a749a329d08">MemoryPermission_None</a> = 0x0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1os.html#a883ab0b53c72a07619d9e83de4836b9aad0057f9250371335c5b9292ff44e1750">MemoryPermission_ReadOnly</a> = 0x1
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1os.html#a883ab0b53c72a07619d9e83de4836b9aa699f0e08f6eddbe0264cf6664a2a1a4b">MemoryPermission_WriteOnly</a> = 0x2
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1os.html#a883ab0b53c72a07619d9e83de4836b9aa57ead1592d9473ac1c22f0b4f75ed2c0">MemoryPermission_ReadWrite</a> = 0x3
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1os.html#a883ab0b53c72a07619d9e83de4836b9aaedf7a33c0731cc16d736b3b74347a2c2">MemoryPermission_ReadExecute</a> = 0x5
<br />
 }</td></tr>
<tr class="memdesc:a883ab0b53c72a07619d9e83de4836b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This enumerated type represents memory access permissions.  <a href="namespacenn_1_1os.html#a883ab0b53c72a07619d9e83de4836b9a">More...</a><br /></td></tr>
<tr class="separator:a883ab0b53c72a07619d9e83de4836b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3271c9fc6c46cffdb076b966f15a80bc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a3271c9fc6c46cffdb076b966f15a80bc">MessageQueueWaitType</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1os.html#a3271c9fc6c46cffdb076b966f15a80bca0fa8f18b62354b68a7838af2bf4e6f01">MessageQueueWaitType_WaitForNotFull</a> = 1
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1os.html#a3271c9fc6c46cffdb076b966f15a80bca40a79a4dabe0233dd5c21d7c4a718eea">MessageQueueWaitType_WaitForNotEmpty</a> = 2
<br />
 }</td></tr>
<tr class="memdesc:a3271c9fc6c46cffdb076b966f15a80bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates the message queue wait types of a multiwait object.  <a href="namespacenn_1_1os.html#a3271c9fc6c46cffdb076b966f15a80bc">More...</a><br /></td></tr>
<tr class="separator:a3271c9fc6c46cffdb076b966f15a80bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02aa5878802b6b43d6f12dacb05a5460"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a02aa5878802b6b43d6f12dacb05a5460">UserExceptionType</a> { <br />
 }</td></tr>
<tr class="memdesc:a02aa5878802b6b43d6f12dacb05a5460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated types defining the kinds of exceptions.  <a href="namespacenn_1_1os.html#a02aa5878802b6b43d6f12dacb05a5460">More...</a><br /></td></tr>
<tr class="separator:a02aa5878802b6b43d6f12dacb05a5460"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions Related to Command-Line Arguments</div></td></tr>
<tr class="memitem:acf2fa6b7b7074a51d0b2de1664cc7bb5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#acf2fa6b7b7074a51d0b2de1664cc7bb5">GetHostArgc</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acf2fa6b7b7074a51d0b2de1664cc7bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of host-specified command-line arguments (<code>argc</code>).  <a href="namespacenn_1_1os.html#acf2fa6b7b7074a51d0b2de1664cc7bb5">More...</a><br /></td></tr>
<tr class="separator:acf2fa6b7b7074a51d0b2de1664cc7bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd77e6bf19be140867869cc759fa492c"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#abd77e6bf19be140867869cc759fa492c">GetHostArgv</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:abd77e6bf19be140867869cc759fa492c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the array of pointers (<code>argc</code>) to the strings for the host-specified command-line arguments.  <a href="namespacenn_1_1os.html#abd77e6bf19be140867869cc759fa492c">More...</a><br /></td></tr>
<tr class="separator:abd77e6bf19be140867869cc759fa492c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Barrier API Resources</div></td></tr>
<tr class="memitem:a063c2e1620b936cdc599de617a458516"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a063c2e1620b936cdc599de617a458516">InitializeBarrier</a> (<a class="el" href="structnn_1_1os_1_1_barrier_type.html">BarrierType</a> *barrier, int numThreads) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a063c2e1620b936cdc599de617a458516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a <code><a class="el" href="structnn_1_1os_1_1_barrier_type.html" title="This structure defines a barrier object.">BarrierType</a></code> object.  <a href="namespacenn_1_1os.html#a063c2e1620b936cdc599de617a458516">More...</a><br /></td></tr>
<tr class="separator:a063c2e1620b936cdc599de617a458516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062ceb897c5cd9b7bd4d779bf5e17c0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a062ceb897c5cd9b7bd4d779bf5e17c0b">FinalizeBarrier</a> (<a class="el" href="structnn_1_1os_1_1_barrier_type.html">BarrierType</a> *barrier) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a062ceb897c5cd9b7bd4d779bf5e17c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes a <code><a class="el" href="structnn_1_1os_1_1_barrier_type.html" title="This structure defines a barrier object.">BarrierType</a></code> object.  <a href="namespacenn_1_1os.html#a062ceb897c5cd9b7bd4d779bf5e17c0b">More...</a><br /></td></tr>
<tr class="separator:a062ceb897c5cd9b7bd4d779bf5e17c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fc159f1fb100df1371bbaf63e1ba14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a41fc159f1fb100df1371bbaf63e1ba14">AwaitBarrier</a> (<a class="el" href="structnn_1_1os_1_1_barrier_type.html">BarrierType</a> *barrier) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a41fc159f1fb100df1371bbaf63e1ba14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for a <code><a class="el" href="structnn_1_1os_1_1_barrier_type.html" title="This structure defines a barrier object.">BarrierType</a></code> object.  <a href="namespacenn_1_1os.html#a41fc159f1fb100df1371bbaf63e1ba14">More...</a><br /></td></tr>
<tr class="separator:a41fc159f1fb100df1371bbaf63e1ba14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Busy Mutex API Resources</div></td></tr>
<tr class="memitem:ae3c90ec0fd947f75d07e4411cbd4cfdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ae3c90ec0fd947f75d07e4411cbd4cfdb">InitializeBusyMutex</a> (<a class="el" href="structnn_1_1os_1_1_busy_mutex_type.html">BusyMutexType</a> *mutex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae3c90ec0fd947f75d07e4411cbd4cfdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a <code><a class="el" href="structnn_1_1os_1_1_busy_mutex_type.html" title="The structure that define a busy mutex object.">BusyMutexType</a></code> object.  <a href="namespacenn_1_1os.html#ae3c90ec0fd947f75d07e4411cbd4cfdb">More...</a><br /></td></tr>
<tr class="separator:ae3c90ec0fd947f75d07e4411cbd4cfdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc5df299ac9ed31c86d87108101dca1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#acbc5df299ac9ed31c86d87108101dca1">FinalizeBusyMutex</a> (<a class="el" href="structnn_1_1os_1_1_busy_mutex_type.html">BusyMutexType</a> *mutex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acbc5df299ac9ed31c86d87108101dca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a <code><a class="el" href="structnn_1_1os_1_1_busy_mutex_type.html" title="The structure that define a busy mutex object.">BusyMutexType</a></code> object.  <a href="namespacenn_1_1os.html#acbc5df299ac9ed31c86d87108101dca1">More...</a><br /></td></tr>
<tr class="separator:acbc5df299ac9ed31c86d87108101dca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad902011901e60f940cb26ffb62989688"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ad902011901e60f940cb26ffb62989688">LockBusyMutex</a> (<a class="el" href="structnn_1_1os_1_1_busy_mutex_type.html">BusyMutexType</a> *mutex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad902011901e60f940cb26ffb62989688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks a <code><a class="el" href="structnn_1_1os_1_1_busy_mutex_type.html" title="The structure that define a busy mutex object.">BusyMutexType</a></code> object.  <a href="namespacenn_1_1os.html#ad902011901e60f940cb26ffb62989688">More...</a><br /></td></tr>
<tr class="separator:ad902011901e60f940cb26ffb62989688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13af259dc4589bac99195d45db41a1cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a13af259dc4589bac99195d45db41a1cb">TryLockBusyMutex</a> (<a class="el" href="structnn_1_1os_1_1_busy_mutex_type.html">BusyMutexType</a> *mutex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a13af259dc4589bac99195d45db41a1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to lock a <code><a class="el" href="structnn_1_1os_1_1_busy_mutex_type.html" title="The structure that define a busy mutex object.">BusyMutexType</a></code> object.  <a href="namespacenn_1_1os.html#a13af259dc4589bac99195d45db41a1cb">More...</a><br /></td></tr>
<tr class="separator:a13af259dc4589bac99195d45db41a1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d95eddeda268be15a448814cfaf2c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a44d95eddeda268be15a448814cfaf2c8">UnlockBusyMutex</a> (<a class="el" href="structnn_1_1os_1_1_busy_mutex_type.html">BusyMutexType</a> *mutex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a44d95eddeda268be15a448814cfaf2c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks a <code><a class="el" href="structnn_1_1os_1_1_busy_mutex_type.html" title="The structure that define a busy mutex object.">BusyMutexType</a></code> object.  <a href="namespacenn_1_1os.html#a44d95eddeda268be15a448814cfaf2c8">More...</a><br /></td></tr>
<tr class="separator:a44d95eddeda268be15a448814cfaf2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cache Operation API Resources</div></td></tr>
<tr class="memitem:a0fc3b750c03200539a98c98f7acca022"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a0fc3b750c03200539a98c98f7acca022">FlushDataCache</a> (const void *addr, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0fc3b750c03200539a98c98f7acca022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the data stored in data cache to memory and then invalidates the pertinent cache line.  <a href="namespacenn_1_1os.html#a0fc3b750c03200539a98c98f7acca022">More...</a><br /></td></tr>
<tr class="separator:a0fc3b750c03200539a98c98f7acca022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Condition Variable API Resources</div></td></tr>
<tr class="memitem:a1ea1d7b36ec1844ed9e05729e832f6c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a1ea1d7b36ec1844ed9e05729e832f6c3">InitializeConditionVariable</a> (<a class="el" href="structnn_1_1os_1_1_condition_variable_type.html">ConditionVariableType</a> *conditionVariable) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1ea1d7b36ec1844ed9e05729e832f6c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a <code><a class="el" href="structnn_1_1os_1_1_condition_variable_type.html" title="This structure defines a condition variable object.">ConditionVariableType</a></code> object.  <a href="namespacenn_1_1os.html#a1ea1d7b36ec1844ed9e05729e832f6c3">More...</a><br /></td></tr>
<tr class="separator:a1ea1d7b36ec1844ed9e05729e832f6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817379cd29b11b49b185d0dc6afdc5c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a817379cd29b11b49b185d0dc6afdc5c6">FinalizeConditionVariable</a> (<a class="el" href="structnn_1_1os_1_1_condition_variable_type.html">ConditionVariableType</a> *conditionVariable) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a817379cd29b11b49b185d0dc6afdc5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes a <code><a class="el" href="structnn_1_1os_1_1_condition_variable_type.html" title="This structure defines a condition variable object.">ConditionVariableType</a></code> object.  <a href="namespacenn_1_1os.html#a817379cd29b11b49b185d0dc6afdc5c6">More...</a><br /></td></tr>
<tr class="separator:a817379cd29b11b49b185d0dc6afdc5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae609d8150763b000d77f75d27fd44ac2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ae609d8150763b000d77f75d27fd44ac2">SignalConditionVariable</a> (<a class="el" href="structnn_1_1os_1_1_condition_variable_type.html">ConditionVariableType</a> *conditionVariable) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae609d8150763b000d77f75d27fd44ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals a <code><a class="el" href="structnn_1_1os_1_1_condition_variable_type.html" title="This structure defines a condition variable object.">ConditionVariableType</a></code> object.  <a href="namespacenn_1_1os.html#ae609d8150763b000d77f75d27fd44ac2">More...</a><br /></td></tr>
<tr class="separator:ae609d8150763b000d77f75d27fd44ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1588e76fa05096006c0dcba27f9c95bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a1588e76fa05096006c0dcba27f9c95bf">BroadcastConditionVariable</a> (<a class="el" href="structnn_1_1os_1_1_condition_variable_type.html">ConditionVariableType</a> *conditionVariable) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1588e76fa05096006c0dcba27f9c95bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts to a <code><a class="el" href="structnn_1_1os_1_1_condition_variable_type.html" title="This structure defines a condition variable object.">ConditionVariableType</a></code> object.  <a href="namespacenn_1_1os.html#a1588e76fa05096006c0dcba27f9c95bf">More...</a><br /></td></tr>
<tr class="separator:a1588e76fa05096006c0dcba27f9c95bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a1e2e570d09ebd7cdbaa9da2d7b187"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a69a1e2e570d09ebd7cdbaa9da2d7b187">WaitConditionVariable</a> (<a class="el" href="structnn_1_1os_1_1_condition_variable_type.html">ConditionVariableType</a> *conditionVariable, <a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *mutex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a69a1e2e570d09ebd7cdbaa9da2d7b187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks a <code><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="This structure defines a mutex object.">MutexType</a></code> object and waits for a condition variable atomically.  <a href="namespacenn_1_1os.html#a69a1e2e570d09ebd7cdbaa9da2d7b187">More...</a><br /></td></tr>
<tr class="separator:a69a1e2e570d09ebd7cdbaa9da2d7b187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2643c34ccfd738890fdd0c546b61c7a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1os.html#ae1fe4fe10826c19cf2c66e534962180a">ConditionVariableStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a2643c34ccfd738890fdd0c546b61c7a8">TimedWaitConditionVariable</a> (<a class="el" href="structnn_1_1os_1_1_condition_variable_type.html">ConditionVariableType</a> *conditionVariable, <a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *mutex, <a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> timeout) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2643c34ccfd738890fdd0c546b61c7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks a <code><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="This structure defines a mutex object.">MutexType</a></code> object and waits for a condition variable atomically.  <a href="namespacenn_1_1os.html#a2643c34ccfd738890fdd0c546b61c7a8">More...</a><br /></td></tr>
<tr class="separator:a2643c34ccfd738890fdd0c546b61c7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">os Library Debug API</div></td></tr>
<tr class="memitem:a036a9dca8974a28f03c6e8f3688efb12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a036a9dca8974a28f03c6e8f3688efb12">GetCurrentStackInfo</a> (uintptr_t *outStack, size_t *outStackSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a036a9dca8974a28f03c6e8f3688efb12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the stack data used in the current context.  <a href="namespacenn_1_1os.html#a036a9dca8974a28f03c6e8f3688efb12">More...</a><br /></td></tr>
<tr class="separator:a036a9dca8974a28f03c6e8f3688efb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f2a489da0a124ebdc8130595c70b94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a79f2a489da0a124ebdc8130595c70b94">QueryMemoryInfo</a> (<a class="el" href="structnn_1_1os_1_1_memory_info.html">MemoryInfo</a> *info) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a79f2a489da0a124ebdc8130595c70b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets information including the amount of memory currently being used by this program.  <a href="namespacenn_1_1os.html#a79f2a489da0a124ebdc8130595c70b94">More...</a><br /></td></tr>
<tr class="separator:a79f2a489da0a124ebdc8130595c70b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54cfc2e44df793d57fdd057a94578bf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1os_1_1_tick.html">Tick</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a54cfc2e44df793d57fdd057a94578bf8">GetIdleTickCount</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a54cfc2e44df793d57fdd057a94578bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the accumulated tick count during an idle segment on the local core.  <a href="namespacenn_1_1os.html#a54cfc2e44df793d57fdd057a94578bf8">More...</a><br /></td></tr>
<tr class="separator:a54cfc2e44df793d57fdd057a94578bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07456130a8d16c6f83beee9adae8dad2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a07456130a8d16c6f83beee9adae8dad2">GetFreeThreadCount</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a07456130a8d16c6f83beee9adae8dad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of threads that can be generated.  <a href="namespacenn_1_1os.html#a07456130a8d16c6f83beee9adae8dad2">More...</a><br /></td></tr>
<tr class="separator:a07456130a8d16c6f83beee9adae8dad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Default User Exception Handler</div></td></tr>
<tr class="memitem:aa9f112844be928c69600e987eb45980f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#aa9f112844be928c69600e987eb45980f">DefaultUserExceptionHandler</a> (<a class="el" href="structnn_1_1os_1_1_user_exception_info.html">nn::os::UserExceptionInfo</a> *info) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa9f112844be928c69600e987eb45980f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default user exception handler.  <a href="namespacenn_1_1os.html#aa9f112844be928c69600e987eb45980f">More...</a><br /></td></tr>
<tr class="separator:aa9f112844be928c69600e987eb45980f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">API for User-Defined Data to Include in Crash Reports</div></td></tr>
<tr class="memitem:a25125eea675c69bc6912e1140d4df148"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a25125eea675c69bc6912e1140d4df148">SetDyingMessageRegion</a> (uintptr_t address, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a25125eea675c69bc6912e1140d4df148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a memory region for storing user-defined data (dying messages) to include in crash reports.  <a href="namespacenn_1_1os.html#a25125eea675c69bc6912e1140d4df148">More...</a><br /></td></tr>
<tr class="separator:a25125eea675c69bc6912e1140d4df148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Event API Resources</div></td></tr>
<tr class="memitem:af07abef747ac6b51112b9e800ba9632c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#af07abef747ac6b51112b9e800ba9632c">InitializeEvent</a> (<a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *event, bool initiallySignaled, <a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452">EventClearMode</a> clearMode) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af07abef747ac6b51112b9e800ba9632c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an <code><a class="el" href="structnn_1_1os_1_1_event_type.html" title="This structure defines an event object.">EventType</a></code> object.  <a href="namespacenn_1_1os.html#af07abef747ac6b51112b9e800ba9632c">More...</a><br /></td></tr>
<tr class="separator:af07abef747ac6b51112b9e800ba9632c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae3d14bd5e37dd1feee56bbf1717e37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#adae3d14bd5e37dd1feee56bbf1717e37">FinalizeEvent</a> (<a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:adae3d14bd5e37dd1feee56bbf1717e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes an <code><a class="el" href="structnn_1_1os_1_1_event_type.html" title="This structure defines an event object.">EventType</a></code> object.  <a href="namespacenn_1_1os.html#adae3d14bd5e37dd1feee56bbf1717e37">More...</a><br /></td></tr>
<tr class="separator:adae3d14bd5e37dd1feee56bbf1717e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b959a51c1d28b76894597695fd3d081"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a9b959a51c1d28b76894597695fd3d081">SignalEvent</a> (<a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9b959a51c1d28b76894597695fd3d081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts an <code><a class="el" href="structnn_1_1os_1_1_event_type.html" title="This structure defines an event object.">EventType</a></code> object in a signaled state.  <a href="namespacenn_1_1os.html#a9b959a51c1d28b76894597695fd3d081">More...</a><br /></td></tr>
<tr class="separator:a9b959a51c1d28b76894597695fd3d081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabdcb2de0b5dbdd64a0ec3d7e65c72f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#aabdcb2de0b5dbdd64a0ec3d7e65c72f4">WaitEvent</a> (<a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aabdcb2de0b5dbdd64a0ec3d7e65c72f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for an <code><a class="el" href="structnn_1_1os_1_1_event_type.html" title="This structure defines an event object.">EventType</a></code> object to enter a signaled state.  <a href="namespacenn_1_1os.html#aabdcb2de0b5dbdd64a0ec3d7e65c72f4">More...</a><br /></td></tr>
<tr class="separator:aabdcb2de0b5dbdd64a0ec3d7e65c72f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679439764fa7d9544094a0246ab6eebb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a679439764fa7d9544094a0246ab6eebb">TryWaitEvent</a> (<a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a679439764fa7d9544094a0246ab6eebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polls the signaled state of an <code><a class="el" href="structnn_1_1os_1_1_event_type.html" title="This structure defines an event object.">EventType</a></code> object.  <a href="namespacenn_1_1os.html#a679439764fa7d9544094a0246ab6eebb">More...</a><br /></td></tr>
<tr class="separator:a679439764fa7d9544094a0246ab6eebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fba39baba3e475cae08127a632cab07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a9fba39baba3e475cae08127a632cab07">TimedWaitEvent</a> (<a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *event, <a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> timeout) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9fba39baba3e475cae08127a632cab07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for an <code><a class="el" href="structnn_1_1os_1_1_event_type.html" title="This structure defines an event object.">EventType</a></code> object to enter a signaled state.  <a href="namespacenn_1_1os.html#a9fba39baba3e475cae08127a632cab07">More...</a><br /></td></tr>
<tr class="separator:a9fba39baba3e475cae08127a632cab07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46abbb4e59711874cfec72fe97b58e36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a46abbb4e59711874cfec72fe97b58e36">ClearEvent</a> (<a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a46abbb4e59711874cfec72fe97b58e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts an <code><a class="el" href="structnn_1_1os_1_1_event_type.html" title="This structure defines an event object.">EventType</a></code> object in a cleared state.  <a href="namespacenn_1_1os.html#a46abbb4e59711874cfec72fe97b58e36">More...</a><br /></td></tr>
<tr class="separator:a46abbb4e59711874cfec72fe97b58e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">API Resources for Multiwait Operations</div></td></tr>
<tr class="memitem:a4f8d998425d067cb5fec2604ae7845dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a4f8d998425d067cb5fec2604ae7845dc">InitializeMultiWaitHolder</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *multiWaitHolder, <a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4f8d998425d067cb5fec2604ae7845dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a <code>multiWaitHolder</code> object and binds it to an event.  <a href="namespacenn_1_1os.html#a4f8d998425d067cb5fec2604ae7845dc">More...</a><br /></td></tr>
<tr class="separator:a4f8d998425d067cb5fec2604ae7845dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241484ed12a060d60eeb234db88484d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a241484ed12a060d60eeb234db88484d0">InitializeMultiWaitHolder</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *multiWaitHolder, <a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue, <a class="el" href="namespacenn_1_1os.html#a3271c9fc6c46cffdb076b966f15a80bc">MessageQueueWaitType</a> waitType) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a241484ed12a060d60eeb234db88484d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a <code>MultiWaitHolder</code> object and binds it to a message queue.  <a href="namespacenn_1_1os.html#a241484ed12a060d60eeb234db88484d0">More...</a><br /></td></tr>
<tr class="separator:a241484ed12a060d60eeb234db88484d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e6662e7fdf9f78bcae79ba94d64a93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a48e6662e7fdf9f78bcae79ba94d64a93">InitializeMultiWait</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *multiWait) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a48e6662e7fdf9f78bcae79ba94d64a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the <code><em>multiWait</em></code> object header.  <a href="namespacenn_1_1os.html#a48e6662e7fdf9f78bcae79ba94d64a93">More...</a><br /></td></tr>
<tr class="separator:a48e6662e7fdf9f78bcae79ba94d64a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60873f9b623e014948a9ea53a611da4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a60873f9b623e014948a9ea53a611da4c">FinalizeMultiWait</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *multiWait) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a60873f9b623e014948a9ea53a611da4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes the <code><em>multiWait</em></code> object header.  <a href="namespacenn_1_1os.html#a60873f9b623e014948a9ea53a611da4c">More...</a><br /></td></tr>
<tr class="separator:a60873f9b623e014948a9ea53a611da4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b837eb53fa2c8a9610cec2b69666fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ab9b837eb53fa2c8a9610cec2b69666fd">WaitAny</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *multiWait) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab9b837eb53fa2c8a9610cec2b69666fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for any of the <code><em>multiWaitHolder</em></code> objects in the <code><em>multiWait</em></code> list.  <a href="namespacenn_1_1os.html#ab9b837eb53fa2c8a9610cec2b69666fd">More...</a><br /></td></tr>
<tr class="separator:ab9b837eb53fa2c8a9610cec2b69666fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add056696d279031175e9053145c82677"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#add056696d279031175e9053145c82677">TryWaitAny</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *multiWait) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:add056696d279031175e9053145c82677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polls for any of the <code>multiWaitHolder</code> objects in the <code><em>multiWait</em></code> list.  <a href="namespacenn_1_1os.html#add056696d279031175e9053145c82677">More...</a><br /></td></tr>
<tr class="separator:add056696d279031175e9053145c82677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a76f1be743cfc8791d2a139c7409470"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a6a76f1be743cfc8791d2a139c7409470">TimedWaitAny</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *multiWait, <a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> timeout) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6a76f1be743cfc8791d2a139c7409470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for any of the <code><em>multiWaitHolder</em></code> objects in the <code><em>multiWait</em></code> list.  <a href="namespacenn_1_1os.html#a6a76f1be743cfc8791d2a139c7409470">More...</a><br /></td></tr>
<tr class="separator:a6a76f1be743cfc8791d2a139c7409470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de358e6bfa261b74c399b5b59c0da1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a2de358e6bfa261b74c399b5b59c0da1d">FinalizeMultiWaitHolder</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *multiWaitHolder) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2de358e6bfa261b74c399b5b59c0da1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes a <code><em>multiWaitHolder</em></code> object.  <a href="namespacenn_1_1os.html#a2de358e6bfa261b74c399b5b59c0da1d">More...</a><br /></td></tr>
<tr class="separator:a2de358e6bfa261b74c399b5b59c0da1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd9b25e14bee063959eb9e7f62a4aa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a7cd9b25e14bee063959eb9e7f62a4aa8">LinkMultiWaitHolder</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *multiWait, <a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *multiWaitHolder) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7cd9b25e14bee063959eb9e7f62a4aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Links a <code><em>multiWaitHolder</em></code> object to a <code><em>multiWait</em></code> object header.  <a href="namespacenn_1_1os.html#a7cd9b25e14bee063959eb9e7f62a4aa8">More...</a><br /></td></tr>
<tr class="separator:a7cd9b25e14bee063959eb9e7f62a4aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c9c7bbc51249b69dc2361957fd650b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a07c9c7bbc51249b69dc2361957fd650b">UnlinkMultiWaitHolder</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *multiWaitHolder) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a07c9c7bbc51249b69dc2361957fd650b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlinks the <code><em>multiWaitHolder</em></code> object from the <code><em>multiWait</em></code> header.  <a href="namespacenn_1_1os.html#a07c9c7bbc51249b69dc2361957fd650b">More...</a><br /></td></tr>
<tr class="separator:a07c9c7bbc51249b69dc2361957fd650b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bdfded3152755dfd1fadb8eeea4565e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a7bdfded3152755dfd1fadb8eeea4565e">UnlinkAllMultiWaitHolder</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *multiWait) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7bdfded3152755dfd1fadb8eeea4565e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlinks all <code><em>multiWaitHolder</em></code> objects linked to the <code><em>multiWait</em></code> header.  <a href="namespacenn_1_1os.html#a7bdfded3152755dfd1fadb8eeea4565e">More...</a><br /></td></tr>
<tr class="separator:a7bdfded3152755dfd1fadb8eeea4565e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8fb5f6b288f3b208f0d4750d0ba079d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ab8fb5f6b288f3b208f0d4750d0ba079d">MoveAllMultiWaitHolder</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *dstMultiWait, <a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *srcMultiWait) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab8fb5f6b288f3b208f0d4750d0ba079d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlinks all <code><em>multiWaitHolder</em></code> objects linked to the <code><em>srcMultiWait</em></code> header and links them to <code><em>dstMultiWait</em></code>.  <a href="namespacenn_1_1os.html#ab8fb5f6b288f3b208f0d4750d0ba079d">More...</a><br /></td></tr>
<tr class="separator:ab8fb5f6b288f3b208f0d4750d0ba079d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05af1a7e142f1ece42a53fe41085f53b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a05af1a7e142f1ece42a53fe41085f53b">SetMultiWaitHolderUserData</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *multiWaitHolder, uintptr_t userData) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a05af1a7e142f1ece42a53fe41085f53b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a user data value in the <code>multiWaitHolder</code> object.  <a href="namespacenn_1_1os.html#a05af1a7e142f1ece42a53fe41085f53b">More...</a><br /></td></tr>
<tr class="separator:a05af1a7e142f1ece42a53fe41085f53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8c73312415fc00c72808fcc00fea33"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a9e8c73312415fc00c72808fcc00fea33">GetMultiWaitHolderUserData</a> (const <a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *multiWaitHolder) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9e8c73312415fc00c72808fcc00fea33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the user data set in a <code><em>multiWaitHolder</em></code> object.  <a href="namespacenn_1_1os.html#a9e8c73312415fc00c72808fcc00fea33">More...</a><br /></td></tr>
<tr class="separator:a9e8c73312415fc00c72808fcc00fea33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0b40464c9936df7d8cb77dadffcbd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a0e0b40464c9936df7d8cb77dadffcbd9">InitializeMultiWaitHolder</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *multiWaitHolder, <a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *semaphore) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0e0b40464c9936df7d8cb77dadffcbd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a <code>MultiWaitHolder</code> object and associates it to a semaphore.  <a href="namespacenn_1_1os.html#a0e0b40464c9936df7d8cb77dadffcbd9">More...</a><br /></td></tr>
<tr class="separator:a0e0b40464c9936df7d8cb77dadffcbd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b03654db54c77da2e8a8c185257d250"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a4b03654db54c77da2e8a8c185257d250">InitializeMultiWaitHolder</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *multiWaitHolder, <a class="el" href="structnn_1_1os_1_1_system_event_type.html">SystemEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4b03654db54c77da2e8a8c185257d250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the <code><em>multiWaitHolder</em></code> object and binds it to a <code><a class="el" href="structnn_1_1os_1_1_system_event_type.html" title="This structure defines a system event object.">SystemEventType</a></code> object.  <a href="namespacenn_1_1os.html#a4b03654db54c77da2e8a8c185257d250">More...</a><br /></td></tr>
<tr class="separator:a4b03654db54c77da2e8a8c185257d250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d36b7ef64f2c1e82f03d895fdd5609"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a72d36b7ef64f2c1e82f03d895fdd5609">InitializeMultiWaitHolder</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *multiWaitHolder, <a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *thread) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a72d36b7ef64f2c1e82f03d895fdd5609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a <code>MultiWaitHolder</code> object and binds it to a thread.  <a href="namespacenn_1_1os.html#a72d36b7ef64f2c1e82f03d895fdd5609">More...</a><br /></td></tr>
<tr class="separator:a72d36b7ef64f2c1e82f03d895fdd5609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4083f1b95f58372c092726cfd9800054"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a4083f1b95f58372c092726cfd9800054">InitializeMultiWaitHolder</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *multiWaitHolder, <a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *timerEvent) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4083f1b95f58372c092726cfd9800054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a <code>multiWaitHolder</code> object and binds it to a timer event.  <a href="namespacenn_1_1os.html#a4083f1b95f58372c092726cfd9800054">More...</a><br /></td></tr>
<tr class="separator:a4083f1b95f58372c092726cfd9800054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Fiber API Resources</div></td></tr>
<tr class="memitem:a9f0b5787e55da6b3b0e089d6b3ee6816"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a9f0b5787e55da6b3b0e089d6b3ee6816">InitializeFiber</a> (<a class="el" href="structnn_1_1os_1_1_fiber_type.html">FiberType</a> *fiber, <a class="el" href="namespacenn_1_1os.html#a00a0fffd9172c3779939c06927973bed">FiberFunction</a> function, void *argument, void *stack, size_t stackSize, int fiberFlag) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9f0b5787e55da6b3b0e089d6b3ee6816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a fiber object.  <a href="namespacenn_1_1os.html#a9f0b5787e55da6b3b0e089d6b3ee6816">More...</a><br /></td></tr>
<tr class="separator:a9f0b5787e55da6b3b0e089d6b3ee6816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54bbd489d9e733f72e8555d7ff940cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#af54bbd489d9e733f72e8555d7ff940cf">FinalizeFiber</a> (<a class="el" href="structnn_1_1os_1_1_fiber_type.html">FiberType</a> *fiber) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af54bbd489d9e733f72e8555d7ff940cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a fiber object.  <a href="namespacenn_1_1os.html#af54bbd489d9e733f72e8555d7ff940cf">More...</a><br /></td></tr>
<tr class="separator:af54bbd489d9e733f72e8555d7ff940cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba39dbca8b416903a5e2947927ed3e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a3ba39dbca8b416903a5e2947927ed3e0">SwitchToFiber</a> (<a class="el" href="structnn_1_1os_1_1_fiber_type.html">FiberType</a> *fiber) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3ba39dbca8b416903a5e2947927ed3e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts or resumes execution of a fiber.  <a href="namespacenn_1_1os.html#a3ba39dbca8b416903a5e2947927ed3e0">More...</a><br /></td></tr>
<tr class="separator:a3ba39dbca8b416903a5e2947927ed3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bacafa4afccd548bb410d0f2fb3762e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1os_1_1_fiber_type.html">FiberType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a5bacafa4afccd548bb410d0f2fb3762e">GetCurrentFiber</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5bacafa4afccd548bb410d0f2fb3762e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <code><a class="el" href="structnn_1_1os_1_1_fiber_type.html" title="This structure defines a fiber object.">FiberType</a></code> object for the current fiber.  <a href="namespacenn_1_1os.html#a5bacafa4afccd548bb410d0f2fb3762e">More...</a><br /></td></tr>
<tr class="separator:a5bacafa4afccd548bb410d0f2fb3762e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Debugging Functions of the &lt;tt&gt;os&lt;/tt&gt; Library (Cannot Be Used in Retail Devices)</div></td></tr>
<tr class="memitem:a20238ce26424ba34876552fb2d53165a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a20238ce26424ba34876552fb2d53165a">IsMemoryLocked</a> (void *address, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a20238ce26424ba34876552fb2d53165a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified memory area is locked.  <a href="namespacenn_1_1os.html#a20238ce26424ba34876552fb2d53165a">More...</a><br /></td></tr>
<tr class="separator:a20238ce26424ba34876552fb2d53165a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2789b550619d98db2c52198839d35c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ac2789b550619d98db2c52198839d35c0">IsMemoryLocked</a> (uintptr_t address, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac2789b550619d98db2c52198839d35c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified memory area is locked.  <a href="namespacenn_1_1os.html#ac2789b550619d98db2c52198839d35c0">More...</a><br /></td></tr>
<tr class="separator:ac2789b550619d98db2c52198839d35c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e18c280ac1b7dacdd0a0ea0410517d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1os_1_1_tick.html">Tick</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a47e18c280ac1b7dacdd0a0ea0410517d">GetThreadTickCount</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a47e18c280ac1b7dacdd0a0ea0410517d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current thread's cumulative execution time.  <a href="namespacenn_1_1os.html#a47e18c280ac1b7dacdd0a0ea0410517d">More...</a><br /></td></tr>
<tr class="separator:a47e18c280ac1b7dacdd0a0ea0410517d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Lightweight Event API Resources</div></td></tr>
<tr class="memitem:af5900620f2a25ffdd500d7fbcba5fe26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#af5900620f2a25ffdd500d7fbcba5fe26">InitializeLightEvent</a> (<a class="el" href="structnn_1_1os_1_1_light_event_type.html">LightEventType</a> *event, bool initiallySignaled, <a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452">EventClearMode</a> clearMode) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af5900620f2a25ffdd500d7fbcba5fe26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a <code><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="This structure defines a lightweight event object.">LightEventType</a></code> object.  <a href="namespacenn_1_1os.html#af5900620f2a25ffdd500d7fbcba5fe26">More...</a><br /></td></tr>
<tr class="separator:af5900620f2a25ffdd500d7fbcba5fe26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b4a0191e818ad124b28b818349f072"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a88b4a0191e818ad124b28b818349f072">FinalizeLightEvent</a> (<a class="el" href="structnn_1_1os_1_1_light_event_type.html">LightEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a88b4a0191e818ad124b28b818349f072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes a <code><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="This structure defines a lightweight event object.">LightEventType</a></code> object.  <a href="namespacenn_1_1os.html#a88b4a0191e818ad124b28b818349f072">More...</a><br /></td></tr>
<tr class="separator:a88b4a0191e818ad124b28b818349f072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e40a45392d6eb98e2ca635bc0c3506"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a07e40a45392d6eb98e2ca635bc0c3506">SignalLightEvent</a> (<a class="el" href="structnn_1_1os_1_1_light_event_type.html">LightEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a07e40a45392d6eb98e2ca635bc0c3506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="This structure defines a lightweight event object.">LightEventType</a></code> to a signaled state.  <a href="namespacenn_1_1os.html#a07e40a45392d6eb98e2ca635bc0c3506">More...</a><br /></td></tr>
<tr class="separator:a07e40a45392d6eb98e2ca635bc0c3506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148036d27d59d8b674c3f1b7579aa5c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a148036d27d59d8b674c3f1b7579aa5c9">WaitLightEvent</a> (<a class="el" href="structnn_1_1os_1_1_light_event_type.html">LightEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a148036d27d59d8b674c3f1b7579aa5c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for an <code><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="This structure defines a lightweight event object.">LightEventType</a></code> object to enter a signaled state.  <a href="namespacenn_1_1os.html#a148036d27d59d8b674c3f1b7579aa5c9">More...</a><br /></td></tr>
<tr class="separator:a148036d27d59d8b674c3f1b7579aa5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d2d9367d6312b284cd9e205a69adab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ae1d2d9367d6312b284cd9e205a69adab">TryWaitLightEvent</a> (<a class="el" href="structnn_1_1os_1_1_light_event_type.html">LightEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae1d2d9367d6312b284cd9e205a69adab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polls the signaled state of a <code><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="This structure defines a lightweight event object.">LightEventType</a></code> object.  <a href="namespacenn_1_1os.html#ae1d2d9367d6312b284cd9e205a69adab">More...</a><br /></td></tr>
<tr class="separator:ae1d2d9367d6312b284cd9e205a69adab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aeea3ec3d35c57cd757b4a3d2ff7273"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a6aeea3ec3d35c57cd757b4a3d2ff7273">TimedWaitLightEvent</a> (<a class="el" href="structnn_1_1os_1_1_light_event_type.html">LightEventType</a> *event, <a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> timeout) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6aeea3ec3d35c57cd757b4a3d2ff7273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for a <code><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="This structure defines a lightweight event object.">LightEventType</a></code> object to enter a signaled state, with a timeout.  <a href="namespacenn_1_1os.html#a6aeea3ec3d35c57cd757b4a3d2ff7273">More...</a><br /></td></tr>
<tr class="separator:a6aeea3ec3d35c57cd757b4a3d2ff7273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab236036e46ae861732a4c6418b63ec01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ab236036e46ae861732a4c6418b63ec01">ClearLightEvent</a> (<a class="el" href="structnn_1_1os_1_1_light_event_type.html">LightEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab236036e46ae861732a4c6418b63ec01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts a <code><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="This structure defines a lightweight event object.">LightEventType</a></code> object in a cleared state.  <a href="namespacenn_1_1os.html#ab236036e46ae861732a4c6418b63ec01">More...</a><br /></td></tr>
<tr class="separator:ab236036e46ae861732a4c6418b63ec01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Light Message Queue API Resources</div></td></tr>
<tr class="memitem:a3b9261137505f66b2d185aafeed5c9dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a3b9261137505f66b2d185aafeed5c9dc">InitializeLightMessageQueue</a> (<a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html">LightMessageQueueType</a> *messageQueue, uintptr_t *buffer, size_t count) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3b9261137505f66b2d185aafeed5c9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a light message queue object.  <a href="namespacenn_1_1os.html#a3b9261137505f66b2d185aafeed5c9dc">More...</a><br /></td></tr>
<tr class="separator:a3b9261137505f66b2d185aafeed5c9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf0c1a8c8136bc6a3aedf792009f1a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a6bf0c1a8c8136bc6a3aedf792009f1a4">FinalizeLightMessageQueue</a> (<a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html">LightMessageQueueType</a> *messageQueue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6bf0c1a8c8136bc6a3aedf792009f1a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes a light message queue object.  <a href="namespacenn_1_1os.html#a6bf0c1a8c8136bc6a3aedf792009f1a4">More...</a><br /></td></tr>
<tr class="separator:a6bf0c1a8c8136bc6a3aedf792009f1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec37a4b03c00777cb0840d4f5becf0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a2ec37a4b03c00777cb0840d4f5becf0e">SendLightMessageQueue</a> (<a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html">LightMessageQueueType</a> *messageQueue, uintptr_t data) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2ec37a4b03c00777cb0840d4f5becf0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends one piece of data to the back of the light message queue.  <a href="namespacenn_1_1os.html#a2ec37a4b03c00777cb0840d4f5becf0e">More...</a><br /></td></tr>
<tr class="separator:a2ec37a4b03c00777cb0840d4f5becf0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f71a4b08b8492646bad8aed17d296b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a78f71a4b08b8492646bad8aed17d296b">TrySendLightMessageQueue</a> (<a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html">LightMessageQueueType</a> *messageQueue, uintptr_t data) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a78f71a4b08b8492646bad8aed17d296b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends one piece of data to the back of the light message queue.  <a href="namespacenn_1_1os.html#a78f71a4b08b8492646bad8aed17d296b">More...</a><br /></td></tr>
<tr class="separator:a78f71a4b08b8492646bad8aed17d296b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431668e7d0b3605da365a406becace2b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a431668e7d0b3605da365a406becace2b">TimedSendLightMessageQueue</a> (<a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html">LightMessageQueueType</a> *messageQueue, uintptr_t data, <a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> timeout) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a431668e7d0b3605da365a406becace2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends one piece of data to the back of the light message queue.  <a href="namespacenn_1_1os.html#a431668e7d0b3605da365a406becace2b">More...</a><br /></td></tr>
<tr class="separator:a431668e7d0b3605da365a406becace2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae544b7a419a19f766d0d5fc22dbb89a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ae544b7a419a19f766d0d5fc22dbb89a9">JamLightMessageQueue</a> (<a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html">LightMessageQueueType</a> *messageQueue, uintptr_t data) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae544b7a419a19f766d0d5fc22dbb89a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends one piece of data to the front of the light message queue.  <a href="namespacenn_1_1os.html#ae544b7a419a19f766d0d5fc22dbb89a9">More...</a><br /></td></tr>
<tr class="separator:ae544b7a419a19f766d0d5fc22dbb89a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3715853cab09866f3a6ee79e7988a145"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a3715853cab09866f3a6ee79e7988a145">TryJamLightMessageQueue</a> (<a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html">LightMessageQueueType</a> *messageQueue, uintptr_t data) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3715853cab09866f3a6ee79e7988a145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends one piece of data to the front of the light message queue.  <a href="namespacenn_1_1os.html#a3715853cab09866f3a6ee79e7988a145">More...</a><br /></td></tr>
<tr class="separator:a3715853cab09866f3a6ee79e7988a145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75336eea6700c67ec9a53fb3214e71b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ac75336eea6700c67ec9a53fb3214e71b">TimedJamLightMessageQueue</a> (<a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html">LightMessageQueueType</a> *messageQueue, uintptr_t data, <a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> timeout) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac75336eea6700c67ec9a53fb3214e71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends one piece of data to the front of the light message queue.  <a href="namespacenn_1_1os.html#ac75336eea6700c67ec9a53fb3214e71b">More...</a><br /></td></tr>
<tr class="separator:ac75336eea6700c67ec9a53fb3214e71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20eb39483646e5dd69388d01985e0307"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a20eb39483646e5dd69388d01985e0307">ReceiveLightMessageQueue</a> (uintptr_t *outData, <a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html">LightMessageQueueType</a> *messageQueue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a20eb39483646e5dd69388d01985e0307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives one piece of data from the front of the light message queue.  <a href="namespacenn_1_1os.html#a20eb39483646e5dd69388d01985e0307">More...</a><br /></td></tr>
<tr class="separator:a20eb39483646e5dd69388d01985e0307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4faba929a7270dce159e1e8b0e52477a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a4faba929a7270dce159e1e8b0e52477a">TryReceiveLightMessageQueue</a> (uintptr_t *outData, <a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html">LightMessageQueueType</a> *messageQueue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4faba929a7270dce159e1e8b0e52477a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives one piece of data from the front of the light message queue.  <a href="namespacenn_1_1os.html#a4faba929a7270dce159e1e8b0e52477a">More...</a><br /></td></tr>
<tr class="separator:a4faba929a7270dce159e1e8b0e52477a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e96e17480064f66c6aff10c3ef989b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a0e96e17480064f66c6aff10c3ef989b6">TimedReceiveLightMessageQueue</a> (uintptr_t *outData, <a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html">LightMessageQueueType</a> *messageQueue, <a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> timeout) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0e96e17480064f66c6aff10c3ef989b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives one piece of data from the front of the light message queue.  <a href="namespacenn_1_1os.html#a0e96e17480064f66c6aff10c3ef989b6">More...</a><br /></td></tr>
<tr class="separator:a0e96e17480064f66c6aff10c3ef989b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d34d548b81497f306cd26ebff16ab54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a1d34d548b81497f306cd26ebff16ab54">PeekLightMessageQueue</a> (uintptr_t *outData, const <a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html">LightMessageQueueType</a> *messageQueue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1d34d548b81497f306cd26ebff16ab54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the first data item in a light message queue.  <a href="namespacenn_1_1os.html#a1d34d548b81497f306cd26ebff16ab54">More...</a><br /></td></tr>
<tr class="separator:a1d34d548b81497f306cd26ebff16ab54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ecfcd68491819e5ede0dcae313cace"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a60ecfcd68491819e5ede0dcae313cace">TryPeekLightMessageQueue</a> (uintptr_t *outData, const <a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html">LightMessageQueueType</a> *messageQueue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a60ecfcd68491819e5ede0dcae313cace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the first data item in a light message queue.  <a href="namespacenn_1_1os.html#a60ecfcd68491819e5ede0dcae313cace">More...</a><br /></td></tr>
<tr class="separator:a60ecfcd68491819e5ede0dcae313cace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0346a384e4e057f6162bad8da416ba98"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a0346a384e4e057f6162bad8da416ba98">TimedPeekLightMessageQueue</a> (uintptr_t *outData, const <a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html">LightMessageQueueType</a> *messageQueue, <a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> timeout) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0346a384e4e057f6162bad8da416ba98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the first data item in a light message queue.  <a href="namespacenn_1_1os.html#a0346a384e4e057f6162bad8da416ba98">More...</a><br /></td></tr>
<tr class="separator:a0346a384e4e057f6162bad8da416ba98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Light Semaphore API Resources</div></td></tr>
<tr class="memitem:a5ab8dff3311a08d0718855bff6d2c297"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a5ab8dff3311a08d0718855bff6d2c297">InitializeLightSemaphore</a> (<a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html">LightSemaphoreType</a> *semaphore, int initialCount, int maxCount) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5ab8dff3311a08d0718855bff6d2c297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a <code><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html" title="This structure defines a light semaphore object.">LightSemaphoreType</a></code> object.  <a href="namespacenn_1_1os.html#a5ab8dff3311a08d0718855bff6d2c297">More...</a><br /></td></tr>
<tr class="separator:a5ab8dff3311a08d0718855bff6d2c297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45176bf824434fe4269db3e4d9532701"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a45176bf824434fe4269db3e4d9532701">FinalizeLightSemaphore</a> (<a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html">LightSemaphoreType</a> *semaphore) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a45176bf824434fe4269db3e4d9532701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes a <code><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html" title="This structure defines a light semaphore object.">LightSemaphoreType</a></code> object.  <a href="namespacenn_1_1os.html#a45176bf824434fe4269db3e4d9532701">More...</a><br /></td></tr>
<tr class="separator:a45176bf824434fe4269db3e4d9532701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ae7374f92f8bb82cd77dce0354d5d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a14ae7374f92f8bb82cd77dce0354d5d5">AcquireLightSemaphore</a> (<a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html">LightSemaphoreType</a> *semaphore) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a14ae7374f92f8bb82cd77dce0354d5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <code><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html" title="This structure defines a light semaphore object.">LightSemaphoreType</a></code> object (P operation).  <a href="namespacenn_1_1os.html#a14ae7374f92f8bb82cd77dce0354d5d5">More...</a><br /></td></tr>
<tr class="separator:a14ae7374f92f8bb82cd77dce0354d5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91955b6e49515c4f50e2d2778d442c1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a91955b6e49515c4f50e2d2778d442c1b">TryAcquireLightSemaphore</a> (<a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html">LightSemaphoreType</a> *semaphore) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a91955b6e49515c4f50e2d2778d442c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to get a <code><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html" title="This structure defines a light semaphore object.">LightSemaphoreType</a></code> object (P operation).  <a href="namespacenn_1_1os.html#a91955b6e49515c4f50e2d2778d442c1b">More...</a><br /></td></tr>
<tr class="separator:a91955b6e49515c4f50e2d2778d442c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcdacde38f33f90323d5595c5ec2b180"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#abcdacde38f33f90323d5595c5ec2b180">TimedAcquireLightSemaphore</a> (<a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html">LightSemaphoreType</a> *semaphore, <a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> timeout) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:abcdacde38f33f90323d5595c5ec2b180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to get a <code><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html" title="This structure defines a light semaphore object.">LightSemaphoreType</a></code> object with a timeout (P operation).  <a href="namespacenn_1_1os.html#abcdacde38f33f90323d5595c5ec2b180">More...</a><br /></td></tr>
<tr class="separator:abcdacde38f33f90323d5595c5ec2b180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ceaceb7088707e07f3be60222ae4e4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a3ceaceb7088707e07f3be60222ae4e4b">ReleaseLightSemaphore</a> (<a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html">LightSemaphoreType</a> *semaphore) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3ceaceb7088707e07f3be60222ae4e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases only one count of an <code><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html" title="This structure defines a light semaphore object.">LightSemaphoreType</a></code> object (V operation).  <a href="namespacenn_1_1os.html#a3ceaceb7088707e07f3be60222ae4e4b">More...</a><br /></td></tr>
<tr class="separator:a3ceaceb7088707e07f3be60222ae4e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2090b620e107723237bc81eb23e11e63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a2090b620e107723237bc81eb23e11e63">ReleaseLightSemaphore</a> (<a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html">LightSemaphoreType</a> *semaphore, int count) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2090b620e107723237bc81eb23e11e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases multiple counts of a <code><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html" title="This structure defines a light semaphore object.">LightSemaphoreType</a></code> object (V operation).  <a href="namespacenn_1_1os.html#a2090b620e107723237bc81eb23e11e63">More...</a><br /></td></tr>
<tr class="separator:a2090b620e107723237bc81eb23e11e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46089352b69aa5a45a0369e4c5b315f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a46089352b69aa5a45a0369e4c5b315f6">GetCurrentLightSemaphoreCount</a> (const <a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html">LightSemaphoreType</a> *semaphore) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a46089352b69aa5a45a0369e4c5b315f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current counter value of a <code><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html" title="This structure defines a light semaphore object.">LightSemaphoreType</a></code> object.  <a href="namespacenn_1_1os.html#a46089352b69aa5a45a0369e4c5b315f6">More...</a><br /></td></tr>
<tr class="separator:a46089352b69aa5a45a0369e4c5b315f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Initializing the Compiler Thread Local Implementation Memory Allocator</div></td></tr>
<tr class="memitem:a347a69381452967e4a51b3c18aae7807"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a347a69381452967e4a51b3c18aae7807">SetMemoryAllocatorForThreadLocal</a> (<a class="el" href="namespacenn.html#ae292809a1837a548ce8e91c92dd5fac8">nn::AlignedAllocateFunction</a> allocator, <a class="el" href="namespacenn.html#ac4bc1dec66991644b7abd9f9cd9d0ca6">nn::DeallocateFunction</a> deallocator) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a347a69381452967e4a51b3c18aae7807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the compiler thread local implementation memory allocator and memory deallocator.  <a href="namespacenn_1_1os.html#a347a69381452967e4a51b3c18aae7807">More...</a><br /></td></tr>
<tr class="separator:a347a69381452967e4a51b3c18aae7807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Memory Fence API Resources</div></td></tr>
<tr class="memitem:a0b9900ac6f5ffc3cceeaf9e4d4628fd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a0b9900ac6f5ffc3cceeaf9e4d4628fd6">FenceMemoryStoreStore</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0b9900ac6f5ffc3cceeaf9e4d4628fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a <code>Store-Store</code> memory fence.  <a href="namespacenn_1_1os.html#a0b9900ac6f5ffc3cceeaf9e4d4628fd6">More...</a><br /></td></tr>
<tr class="separator:a0b9900ac6f5ffc3cceeaf9e4d4628fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89bc7c5ef7a7884fa2cdb771d1050045"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a89bc7c5ef7a7884fa2cdb771d1050045">FenceMemoryStoreLoad</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a89bc7c5ef7a7884fa2cdb771d1050045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a <code>Store-Load</code> memory fence.  <a href="namespacenn_1_1os.html#a89bc7c5ef7a7884fa2cdb771d1050045">More...</a><br /></td></tr>
<tr class="separator:a89bc7c5ef7a7884fa2cdb771d1050045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecf770755dd217ffff4479db6102863"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a8ecf770755dd217ffff4479db6102863">FenceMemoryStoreAny</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8ecf770755dd217ffff4479db6102863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a <code>Store-Any</code> memory fence.  <a href="namespacenn_1_1os.html#a8ecf770755dd217ffff4479db6102863">More...</a><br /></td></tr>
<tr class="separator:a8ecf770755dd217ffff4479db6102863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d20e99e9c3b0e699b51a13acd3ead6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a36d20e99e9c3b0e699b51a13acd3ead6">FenceMemoryLoadStore</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a36d20e99e9c3b0e699b51a13acd3ead6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a <code>Load-Store</code> memory fence.  <a href="namespacenn_1_1os.html#a36d20e99e9c3b0e699b51a13acd3ead6">More...</a><br /></td></tr>
<tr class="separator:a36d20e99e9c3b0e699b51a13acd3ead6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24612da5b069435fc5f1d8f8720adadf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a24612da5b069435fc5f1d8f8720adadf">FenceMemoryLoadLoad</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a24612da5b069435fc5f1d8f8720adadf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a <code>Load-Load</code> memory fence.  <a href="namespacenn_1_1os.html#a24612da5b069435fc5f1d8f8720adadf">More...</a><br /></td></tr>
<tr class="separator:a24612da5b069435fc5f1d8f8720adadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367aa8b77b2ae4d88e358810ef54b973"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a367aa8b77b2ae4d88e358810ef54b973">FenceMemoryLoadAny</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a367aa8b77b2ae4d88e358810ef54b973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a <code>Load-Any</code> memory fence.  <a href="namespacenn_1_1os.html#a367aa8b77b2ae4d88e358810ef54b973">More...</a><br /></td></tr>
<tr class="separator:a367aa8b77b2ae4d88e358810ef54b973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebc9c7ff99fc0e1b04a693daeebda8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#acebc9c7ff99fc0e1b04a693daeebda8f">FenceMemoryAnyStore</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acebc9c7ff99fc0e1b04a693daeebda8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a <code>Any-Store</code> memory fence.  <a href="namespacenn_1_1os.html#acebc9c7ff99fc0e1b04a693daeebda8f">More...</a><br /></td></tr>
<tr class="separator:acebc9c7ff99fc0e1b04a693daeebda8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfb421bf54c835b5b731db28d171cf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a7bfb421bf54c835b5b731db28d171cf9">FenceMemoryAnyLoad</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7bfb421bf54c835b5b731db28d171cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a <code>Any-Load</code> memory fence.  <a href="namespacenn_1_1os.html#a7bfb421bf54c835b5b731db28d171cf9">More...</a><br /></td></tr>
<tr class="separator:a7bfb421bf54c835b5b731db28d171cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf5cd70de75b033bb8ae4eac87f8fe2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#addf5cd70de75b033bb8ae4eac87f8fe2">FenceMemoryAnyAny</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:addf5cd70de75b033bb8ae4eac87f8fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a <code>Any-Any</code> memory fence.  <a href="namespacenn_1_1os.html#addf5cd70de75b033bb8ae4eac87f8fe2">More...</a><br /></td></tr>
<tr class="separator:addf5cd70de75b033bb8ae4eac87f8fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Memory Management API Resources</div></td></tr>
<tr class="memitem:a2be8bac50d8d37a91f866d9e0c55886e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a2be8bac50d8d37a91f866d9e0c55886e">SetMemoryHeapSize</a> (size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2be8bac50d8d37a91f866d9e0c55886e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the size of the memory heap region.  <a href="namespacenn_1_1os.html#a2be8bac50d8d37a91f866d9e0c55886e">More...</a><br /></td></tr>
<tr class="separator:a2be8bac50d8d37a91f866d9e0c55886e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875bf6b3129f06654e641513c63017dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a875bf6b3129f06654e641513c63017dd">AllocateMemoryBlock</a> (uintptr_t *address, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a875bf6b3129f06654e641513c63017dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a memory block from the memory heap.  <a href="namespacenn_1_1os.html#a875bf6b3129f06654e641513c63017dd">More...</a><br /></td></tr>
<tr class="separator:a875bf6b3129f06654e641513c63017dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fa47e171856fb202b60e6b2a1de719"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a20fa47e171856fb202b60e6b2a1de719">FreeMemoryBlock</a> (uintptr_t address, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a20fa47e171856fb202b60e6b2a1de719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a memory block back to the memory heap region.  <a href="namespacenn_1_1os.html#a20fa47e171856fb202b60e6b2a1de719">More...</a><br /></td></tr>
<tr class="separator:a20fa47e171856fb202b60e6b2a1de719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">API Resources for Memory Access Permissions</div></td></tr>
<tr class="memitem:ae3d0ddd1807c032d7ab0e0fda9739bef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ae3d0ddd1807c032d7ab0e0fda9739bef">SetMemoryPermission</a> (uintptr_t address, size_t size, <a class="el" href="namespacenn_1_1os.html#a883ab0b53c72a07619d9e83de4836b9a">MemoryPermission</a> permission) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae3d0ddd1807c032d7ab0e0fda9739bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the access permission for the specified region of memory.  <a href="namespacenn_1_1os.html#ae3d0ddd1807c032d7ab0e0fda9739bef">More...</a><br /></td></tr>
<tr class="separator:ae3d0ddd1807c032d7ab0e0fda9739bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Message Queue API Resources</div></td></tr>
<tr class="memitem:ab7baa013ea5d9d4f9e84eb5d1afcec49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ab7baa013ea5d9d4f9e84eb5d1afcec49">InitializeMessageQueue</a> (<a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue, uintptr_t *buffer, size_t count) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab7baa013ea5d9d4f9e84eb5d1afcec49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a message queue object.  <a href="namespacenn_1_1os.html#ab7baa013ea5d9d4f9e84eb5d1afcec49">More...</a><br /></td></tr>
<tr class="separator:ab7baa013ea5d9d4f9e84eb5d1afcec49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c98095075b7ef0570c1a449545e392"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#af9c98095075b7ef0570c1a449545e392">FinalizeMessageQueue</a> (<a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af9c98095075b7ef0570c1a449545e392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes a message queue object.  <a href="namespacenn_1_1os.html#af9c98095075b7ef0570c1a449545e392">More...</a><br /></td></tr>
<tr class="separator:af9c98095075b7ef0570c1a449545e392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec9c0c3cacf43c7aa82f323da656af5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#afec9c0c3cacf43c7aa82f323da656af5">SendMessageQueue</a> (<a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue, uintptr_t data) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:afec9c0c3cacf43c7aa82f323da656af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends one piece of data to the end of the message queue.  <a href="namespacenn_1_1os.html#afec9c0c3cacf43c7aa82f323da656af5">More...</a><br /></td></tr>
<tr class="separator:afec9c0c3cacf43c7aa82f323da656af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78cd82954aa87f10f881a7e34fad596b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a78cd82954aa87f10f881a7e34fad596b">TrySendMessageQueue</a> (<a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue, uintptr_t data) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a78cd82954aa87f10f881a7e34fad596b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends one piece of data to the end of the message queue.  <a href="namespacenn_1_1os.html#a78cd82954aa87f10f881a7e34fad596b">More...</a><br /></td></tr>
<tr class="separator:a78cd82954aa87f10f881a7e34fad596b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e14ae7d5a67147af209a1029991095"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ad5e14ae7d5a67147af209a1029991095">TimedSendMessageQueue</a> (<a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue, uintptr_t data, <a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> timeout) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad5e14ae7d5a67147af209a1029991095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends one piece of data to the end of the message queue.  <a href="namespacenn_1_1os.html#ad5e14ae7d5a67147af209a1029991095">More...</a><br /></td></tr>
<tr class="separator:ad5e14ae7d5a67147af209a1029991095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a47bc9d914dbdf48011deeb859cb877"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a7a47bc9d914dbdf48011deeb859cb877">JamMessageQueue</a> (<a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue, uintptr_t data) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7a47bc9d914dbdf48011deeb859cb877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends one piece of data to the beginning of the message queue.  <a href="namespacenn_1_1os.html#a7a47bc9d914dbdf48011deeb859cb877">More...</a><br /></td></tr>
<tr class="separator:a7a47bc9d914dbdf48011deeb859cb877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6fd916fb5a94b34c37d2b8faa43ce3c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#aa6fd916fb5a94b34c37d2b8faa43ce3c">TryJamMessageQueue</a> (<a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue, uintptr_t data) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa6fd916fb5a94b34c37d2b8faa43ce3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends one piece of data to the beginning of the message queue.  <a href="namespacenn_1_1os.html#aa6fd916fb5a94b34c37d2b8faa43ce3c">More...</a><br /></td></tr>
<tr class="separator:aa6fd916fb5a94b34c37d2b8faa43ce3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cfd66c4587832586ee7a50e5fd90b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ad4cfd66c4587832586ee7a50e5fd90b0">TimedJamMessageQueue</a> (<a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue, uintptr_t data, <a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> timeout) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad4cfd66c4587832586ee7a50e5fd90b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends one piece of data to the beginning of the message queue.  <a href="namespacenn_1_1os.html#ad4cfd66c4587832586ee7a50e5fd90b0">More...</a><br /></td></tr>
<tr class="separator:ad4cfd66c4587832586ee7a50e5fd90b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7ad0de1da8fdeeeb01e7de7494dc87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ace7ad0de1da8fdeeeb01e7de7494dc87">ReceiveMessageQueue</a> (uintptr_t *outData, <a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ace7ad0de1da8fdeeeb01e7de7494dc87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives one piece of data from the beginning of the message queue.  <a href="namespacenn_1_1os.html#ace7ad0de1da8fdeeeb01e7de7494dc87">More...</a><br /></td></tr>
<tr class="separator:ace7ad0de1da8fdeeeb01e7de7494dc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921571e9781d3e6fbf60ca8ee4a1825d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a921571e9781d3e6fbf60ca8ee4a1825d">TryReceiveMessageQueue</a> (uintptr_t *outData, <a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a921571e9781d3e6fbf60ca8ee4a1825d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives one piece of data from the beginning of the message queue.  <a href="namespacenn_1_1os.html#a921571e9781d3e6fbf60ca8ee4a1825d">More...</a><br /></td></tr>
<tr class="separator:a921571e9781d3e6fbf60ca8ee4a1825d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0838f36e8391d50f81549950611aeb4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ae0838f36e8391d50f81549950611aeb4">TimedReceiveMessageQueue</a> (uintptr_t *outData, <a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue, <a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> timeout) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae0838f36e8391d50f81549950611aeb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives one piece of data from the beginning of the message queue.  <a href="namespacenn_1_1os.html#ae0838f36e8391d50f81549950611aeb4">More...</a><br /></td></tr>
<tr class="separator:ae0838f36e8391d50f81549950611aeb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fab6d997fb47451e6c9cd47ef754e99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a7fab6d997fb47451e6c9cd47ef754e99">PeekMessageQueue</a> (uintptr_t *outData, const <a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7fab6d997fb47451e6c9cd47ef754e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the first data item in a message queue.  <a href="namespacenn_1_1os.html#a7fab6d997fb47451e6c9cd47ef754e99">More...</a><br /></td></tr>
<tr class="separator:a7fab6d997fb47451e6c9cd47ef754e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f08aef79a422888383a8ab1d5786fe3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a6f08aef79a422888383a8ab1d5786fe3">TryPeekMessageQueue</a> (uintptr_t *outData, const <a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6f08aef79a422888383a8ab1d5786fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the first data item in a message queue.  <a href="namespacenn_1_1os.html#a6f08aef79a422888383a8ab1d5786fe3">More...</a><br /></td></tr>
<tr class="separator:a6f08aef79a422888383a8ab1d5786fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc5fb4ad2ef7a5dfff029e0128efa55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a0dc5fb4ad2ef7a5dfff029e0128efa55">TimedPeekMessageQueue</a> (uintptr_t *outData, const <a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue, <a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> timeout) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0dc5fb4ad2ef7a5dfff029e0128efa55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the first data item in a message queue.  <a href="namespacenn_1_1os.html#a0dc5fb4ad2ef7a5dfff029e0128efa55">More...</a><br /></td></tr>
<tr class="separator:a0dc5fb4ad2ef7a5dfff029e0128efa55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Multiwait Utility API</div></td></tr>
<tr class="memitem:a22c4b696270b511328e43c40e30a53f6"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a22c4b696270b511328e43c40e30a53f6"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a22c4b696270b511328e43c40e30a53f6">WaitAny</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *pMultiWait, Args &amp;&amp;... args) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a22c4b696270b511328e43c40e30a53f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts a <code>multiWaitHolder</code> object in a <code>multiWait</code> list on standby, or puts multiple specified objects on standby (for objects that support standby).  <a href="namespacenn_1_1os.html#a22c4b696270b511328e43c40e30a53f6">More...</a><br /></td></tr>
<tr class="separator:a22c4b696270b511328e43c40e30a53f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c212b9d05d000b8d34dabf2b65ec367"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a3c212b9d05d000b8d34dabf2b65ec367"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a3c212b9d05d000b8d34dabf2b65ec367">WaitAny</a> (Args &amp;&amp;... args) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3c212b9d05d000b8d34dabf2b65ec367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts multiple specified objects on standby (for objects that support standby).  <a href="namespacenn_1_1os.html#a3c212b9d05d000b8d34dabf2b65ec367">More...</a><br /></td></tr>
<tr class="separator:a3c212b9d05d000b8d34dabf2b65ec367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fab21890e314a0c21f95cad61bfb8ef"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a8fab21890e314a0c21f95cad61bfb8ef"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a8fab21890e314a0c21f95cad61bfb8ef">TryWaitAny</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *pMultiWait, Args &amp;&amp;... args) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8fab21890e314a0c21f95cad61bfb8ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polls a <code>multiWaitHolder</code> object in a <code>multiWait</code> list, or polls multiple specified objects (for objects that support standby).  <a href="namespacenn_1_1os.html#a8fab21890e314a0c21f95cad61bfb8ef">More...</a><br /></td></tr>
<tr class="separator:a8fab21890e314a0c21f95cad61bfb8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8351902f4ee90954cb0332ae741bb925"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a8351902f4ee90954cb0332ae741bb925"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a8351902f4ee90954cb0332ae741bb925">TryWaitAny</a> (Args &amp;&amp;... args) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8351902f4ee90954cb0332ae741bb925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polls multiple specified objects (for objects that support standby).  <a href="namespacenn_1_1os.html#a8351902f4ee90954cb0332ae741bb925">More...</a><br /></td></tr>
<tr class="separator:a8351902f4ee90954cb0332ae741bb925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcae3cbfea9890fd7b1ace389192094c"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:adcae3cbfea9890fd7b1ace389192094c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#adcae3cbfea9890fd7b1ace389192094c">TimedWaitAny</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *pMultiWait, <a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> timeout, Args &amp;&amp;... args) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:adcae3cbfea9890fd7b1ace389192094c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts a <code>multiWaitHolder</code> object in a <code>multiWait</code> list on standby with a timeout, or puts multiple specified objects on standby with a timeout (for objects that support standby).  <a href="namespacenn_1_1os.html#adcae3cbfea9890fd7b1ace389192094c">More...</a><br /></td></tr>
<tr class="separator:adcae3cbfea9890fd7b1ace389192094c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab095940b13b3c3b338c3b5c76ffb7b24"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ab095940b13b3c3b338c3b5c76ffb7b24"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ab095940b13b3c3b338c3b5c76ffb7b24">TimedWaitAny</a> (<a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> timeout, Args &amp;&amp;... args) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab095940b13b3c3b338c3b5c76ffb7b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts multiple specified objects on standby with a timeout (for objects that support standby).  <a href="namespacenn_1_1os.html#ab095940b13b3c3b338c3b5c76ffb7b24">More...</a><br /></td></tr>
<tr class="separator:ab095940b13b3c3b338c3b5c76ffb7b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a434b3b646d4fafdc951f63fa3a4689"><td class="memItemLeft" align="right" valign="top">detail::MessageQueueWaitMultiWaitHelper&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a0a434b3b646d4fafdc951f63fa3a4689">operator&amp;</a> (<a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue, <a class="el" href="namespacenn_1_1os.html#a3271c9fc6c46cffdb076b966f15a80bc">MessageQueueWaitType</a> waitType) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0a434b3b646d4fafdc951f63fa3a4689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for specifying a message queue for the multiwait utility.  <a href="namespacenn_1_1os.html#a0a434b3b646d4fafdc951f63fa3a4689">More...</a><br /></td></tr>
<tr class="separator:a0a434b3b646d4fafdc951f63fa3a4689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mutex API Resources</div></td></tr>
<tr class="memitem:a8d0a550df15490a884932a062dc26533"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a8d0a550df15490a884932a062dc26533">InitializeMutex</a> (<a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *mutex, bool recursive, int lockLevel) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8d0a550df15490a884932a062dc26533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a <code><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="This structure defines a mutex object.">MutexType</a></code> object.  <a href="namespacenn_1_1os.html#a8d0a550df15490a884932a062dc26533">More...</a><br /></td></tr>
<tr class="separator:a8d0a550df15490a884932a062dc26533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce43d38754bf3049ab8d60b9d9e0046"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a8ce43d38754bf3049ab8d60b9d9e0046">FinalizeMutex</a> (<a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *mutex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8ce43d38754bf3049ab8d60b9d9e0046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes a <code><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="This structure defines a mutex object.">MutexType</a></code> object.  <a href="namespacenn_1_1os.html#a8ce43d38754bf3049ab8d60b9d9e0046">More...</a><br /></td></tr>
<tr class="separator:a8ce43d38754bf3049ab8d60b9d9e0046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4678856d87c3faea21f47ced342bb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a8d4678856d87c3faea21f47ced342bb6">LockMutex</a> (<a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *mutex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8d4678856d87c3faea21f47ced342bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks a <code><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="This structure defines a mutex object.">MutexType</a></code> object.  <a href="namespacenn_1_1os.html#a8d4678856d87c3faea21f47ced342bb6">More...</a><br /></td></tr>
<tr class="separator:a8d4678856d87c3faea21f47ced342bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32963cc501eefcb10a0ebb993080b9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#af32963cc501eefcb10a0ebb993080b9f">TryLockMutex</a> (<a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *mutex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af32963cc501eefcb10a0ebb993080b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to get a lock with a <code><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="This structure defines a mutex object.">MutexType</a></code> object.  <a href="namespacenn_1_1os.html#af32963cc501eefcb10a0ebb993080b9f">More...</a><br /></td></tr>
<tr class="separator:af32963cc501eefcb10a0ebb993080b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa661a7036a18c378a694ad67941cd75e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#aa661a7036a18c378a694ad67941cd75e">UnlockMutex</a> (<a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *mutex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa661a7036a18c378a694ad67941cd75e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks a <code><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="This structure defines a mutex object.">MutexType</a></code> object.  <a href="namespacenn_1_1os.html#aa661a7036a18c378a694ad67941cd75e">More...</a><br /></td></tr>
<tr class="separator:aa661a7036a18c378a694ad67941cd75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2107dd611741af2a44adf2dad29c74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a3a2107dd611741af2a44adf2dad29c74">IsMutexLockedByCurrentThread</a> (const <a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *mutex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3a2107dd611741af2a44adf2dad29c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a <code><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="This structure defines a mutex object.">MutexType</a></code> object has been locked by the current thread.  <a href="namespacenn_1_1os.html#a3a2107dd611741af2a44adf2dad29c74">More...</a><br /></td></tr>
<tr class="separator:a3a2107dd611741af2a44adf2dad29c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Common API Resources Related to Handles</div></td></tr>
<tr class="memitem:a84abb8d61f9ab227f76ae7b54dcce5d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a84abb8d61f9ab227f76ae7b54dcce5d4">CloseNativeHandle</a> (<a class="el" href="namespacenn_1_1os.html#a84b48561ef817ac28bde556d321a382e">NativeHandle</a> handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a84abb8d61f9ab227f76ae7b54dcce5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the specified handle.  <a href="namespacenn_1_1os.html#a84abb8d61f9ab227f76ae7b54dcce5d4">More...</a><br /></td></tr>
<tr class="separator:a84abb8d61f9ab227f76ae7b54dcce5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Generating Random Numbers</div></td></tr>
<tr class="memitem:a1771e01a3ebd2fb3dc464756f7208276"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a1771e01a3ebd2fb3dc464756f7208276">GenerateRandomBytes</a> (void *pOutBuffer, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1771e01a3ebd2fb3dc464756f7208276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random byte string.  <a href="namespacenn_1_1os.html#a1771e01a3ebd2fb3dc464756f7208276">More...</a><br /></td></tr>
<tr class="separator:a1771e01a3ebd2fb3dc464756f7208276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">API for Readers-Writer Locks</div></td></tr>
<tr class="memitem:a659d0526afb3df351ed0a95ddc0776fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a659d0526afb3df351ed0a95ddc0776fa">InitializeReaderWriterLock</a> (<a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *rwlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a659d0526afb3df351ed0a95ddc0776fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a <code><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="The structure for defining a readers-writer lock object.">ReaderWriterLockType</a></code> object.  <a href="namespacenn_1_1os.html#a659d0526afb3df351ed0a95ddc0776fa">More...</a><br /></td></tr>
<tr class="separator:a659d0526afb3df351ed0a95ddc0776fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b179b4351145d32ec583bc5a52452bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a6b179b4351145d32ec583bc5a52452bb">FinalizeReaderWriterLock</a> (<a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *rwlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6b179b4351145d32ec583bc5a52452bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a <code><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="The structure for defining a readers-writer lock object.">ReaderWriterLockType</a></code> object.  <a href="namespacenn_1_1os.html#a6b179b4351145d32ec583bc5a52452bb">More...</a><br /></td></tr>
<tr class="separator:a6b179b4351145d32ec583bc5a52452bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa888b2694902212ebc056ccaa4354b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a6fa888b2694902212ebc056ccaa4354b">AcquireReadLock</a> (<a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *rwlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6fa888b2694902212ebc056ccaa4354b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a readers lock.  <a href="namespacenn_1_1os.html#a6fa888b2694902212ebc056ccaa4354b">More...</a><br /></td></tr>
<tr class="separator:a6fa888b2694902212ebc056ccaa4354b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ce54963ebf2636dd1c78a0d16125a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ac0ce54963ebf2636dd1c78a0d16125a8">TryAcquireReadLock</a> (<a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *rwlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac0ce54963ebf2636dd1c78a0d16125a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to acquire a readers lock.  <a href="namespacenn_1_1os.html#ac0ce54963ebf2636dd1c78a0d16125a8">More...</a><br /></td></tr>
<tr class="separator:ac0ce54963ebf2636dd1c78a0d16125a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8f51bbfa3341c9678758b191896a05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a4d8f51bbfa3341c9678758b191896a05">ReleaseReadLock</a> (<a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *rwlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4d8f51bbfa3341c9678758b191896a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a single readers lock.  <a href="namespacenn_1_1os.html#a4d8f51bbfa3341c9678758b191896a05">More...</a><br /></td></tr>
<tr class="separator:a4d8f51bbfa3341c9678758b191896a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d3e3f946b214bcbf85e4aebb61699f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a97d3e3f946b214bcbf85e4aebb61699f">AcquireWriteLock</a> (<a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *rwlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a97d3e3f946b214bcbf85e4aebb61699f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires a writer lock.  <a href="namespacenn_1_1os.html#a97d3e3f946b214bcbf85e4aebb61699f">More...</a><br /></td></tr>
<tr class="separator:a97d3e3f946b214bcbf85e4aebb61699f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad042341aecc3ba00473ab85466fa76a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ad042341aecc3ba00473ab85466fa76a8">TryAcquireWriteLock</a> (<a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *rwlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad042341aecc3ba00473ab85466fa76a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to acquire a writer lock.  <a href="namespacenn_1_1os.html#ad042341aecc3ba00473ab85466fa76a8">More...</a><br /></td></tr>
<tr class="separator:ad042341aecc3ba00473ab85466fa76a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30220320ff7ba5af52183fd5fbe1312"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ae30220320ff7ba5af52183fd5fbe1312">ReleaseWriteLock</a> (<a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *rwlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae30220320ff7ba5af52183fd5fbe1312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a single writer lock.  <a href="namespacenn_1_1os.html#ae30220320ff7ba5af52183fd5fbe1312">More...</a><br /></td></tr>
<tr class="separator:ae30220320ff7ba5af52183fd5fbe1312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434e0c862bf65234e1eee8756edbabf4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a434e0c862bf65234e1eee8756edbabf4">IsReadLockHeld</a> (const <a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *rwlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a434e0c862bf65234e1eee8756edbabf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any threads currently have readers locks.  <a href="namespacenn_1_1os.html#a434e0c862bf65234e1eee8756edbabf4">More...</a><br /></td></tr>
<tr class="separator:a434e0c862bf65234e1eee8756edbabf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6658b045d8ca185b5108ddb802f2440e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a6658b045d8ca185b5108ddb802f2440e">IsWriteLockHeldByCurrentThread</a> (const <a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *rwlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6658b045d8ca185b5108ddb802f2440e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the current thread has acquired a writer lock.  <a href="namespacenn_1_1os.html#a6658b045d8ca185b5108ddb802f2440e">More...</a><br /></td></tr>
<tr class="separator:a6658b045d8ca185b5108ddb802f2440e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3bf890340f587ab633cd1804a93e0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ace3bf890340f587ab633cd1804a93e0b">IsReaderWriterLockOwnerThread</a> (const <a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *rwlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ace3bf890340f587ab633cd1804a93e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the current thread is the lock owner.  <a href="namespacenn_1_1os.html#ace3bf890340f587ab633cd1804a93e0b">More...</a><br /></td></tr>
<tr class="separator:ace3bf890340f587ab633cd1804a93e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Semaphore API Resources</div></td></tr>
<tr class="memitem:af76bc96a9333f18ed5d7bead209eb4f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#af76bc96a9333f18ed5d7bead209eb4f3">InitializeSemaphore</a> (<a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *semaphore, int initialCount, int maxCount) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af76bc96a9333f18ed5d7bead209eb4f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a <code><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="This structure defines a semaphore object.">SemaphoreType</a></code> object.  <a href="namespacenn_1_1os.html#af76bc96a9333f18ed5d7bead209eb4f3">More...</a><br /></td></tr>
<tr class="separator:af76bc96a9333f18ed5d7bead209eb4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201a00464d5606e40bef1798cba2ace8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a201a00464d5606e40bef1798cba2ace8">FinalizeSemaphore</a> (<a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *semaphore) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a201a00464d5606e40bef1798cba2ace8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes a <code><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="This structure defines a semaphore object.">SemaphoreType</a></code> object.  <a href="namespacenn_1_1os.html#a201a00464d5606e40bef1798cba2ace8">More...</a><br /></td></tr>
<tr class="separator:a201a00464d5606e40bef1798cba2ace8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e1d42bdb0279e887dc1caef45fcff1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ac9e1d42bdb0279e887dc1caef45fcff1">AcquireSemaphore</a> (<a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *semaphore) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac9e1d42bdb0279e887dc1caef45fcff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires a <code><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="This structure defines a semaphore object.">SemaphoreType</a></code> object (<em>P</em> operation).  <a href="namespacenn_1_1os.html#ac9e1d42bdb0279e887dc1caef45fcff1">More...</a><br /></td></tr>
<tr class="separator:ac9e1d42bdb0279e887dc1caef45fcff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5fa41594b3b3072d78735f366bdb7ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#af5fa41594b3b3072d78735f366bdb7ce">TryAcquireSemaphore</a> (<a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *semaphore) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af5fa41594b3b3072d78735f366bdb7ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to acquire a <code><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="This structure defines a semaphore object.">SemaphoreType</a></code> object (<em>P</em> operation).  <a href="namespacenn_1_1os.html#af5fa41594b3b3072d78735f366bdb7ce">More...</a><br /></td></tr>
<tr class="separator:af5fa41594b3b3072d78735f366bdb7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c8209e58cabbf5ab5173867dcad732"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a54c8209e58cabbf5ab5173867dcad732">TimedAcquireSemaphore</a> (<a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *semaphore, <a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> timeout) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a54c8209e58cabbf5ab5173867dcad732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to acquire a <code><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="This structure defines a semaphore object.">SemaphoreType</a></code> object with a timeout (<em>P</em> operation).  <a href="namespacenn_1_1os.html#a54c8209e58cabbf5ab5173867dcad732">More...</a><br /></td></tr>
<tr class="separator:a54c8209e58cabbf5ab5173867dcad732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2cbceb4266858d27387ff2cb29a5ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#acf2cbceb4266858d27387ff2cb29a5ae">ReleaseSemaphore</a> (<a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *semaphore) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acf2cbceb4266858d27387ff2cb29a5ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases only one count of a <code><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="This structure defines a semaphore object.">SemaphoreType</a></code> object (<em>V</em> operation).  <a href="namespacenn_1_1os.html#acf2cbceb4266858d27387ff2cb29a5ae">More...</a><br /></td></tr>
<tr class="separator:acf2cbceb4266858d27387ff2cb29a5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40039d059051bc9970e072417ac9576d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a40039d059051bc9970e072417ac9576d">ReleaseSemaphore</a> (<a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *semaphore, int count) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a40039d059051bc9970e072417ac9576d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases multiple counts of a <code><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="This structure defines a semaphore object.">SemaphoreType</a></code> object (<em>V</em> operation).  <a href="namespacenn_1_1os.html#a40039d059051bc9970e072417ac9576d">More...</a><br /></td></tr>
<tr class="separator:a40039d059051bc9970e072417ac9576d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a315a7f4822cee3e62e9912737edfa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#aa6a315a7f4822cee3e62e9912737edfa">GetCurrentSemaphoreCount</a> (const <a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *semaphore) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa6a315a7f4822cee3e62e9912737edfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current counter value of a <code><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="This structure defines a semaphore object.">SemaphoreType</a></code> object.  <a href="namespacenn_1_1os.html#aa6a315a7f4822cee3e62e9912737edfa">More...</a><br /></td></tr>
<tr class="separator:aa6a315a7f4822cee3e62e9912737edfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">System Event API Resources</div></td></tr>
<tr class="memitem:a3d924bc362ec80648323428be5182338"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a3d924bc362ec80648323428be5182338">DestroySystemEvent</a> (<a class="el" href="structnn_1_1os_1_1_system_event_type.html">SystemEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3d924bc362ec80648323428be5182338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a <code><a class="el" href="structnn_1_1os_1_1_system_event_type.html" title="This structure defines a system event object.">SystemEventType</a></code> object.  <a href="namespacenn_1_1os.html#a3d924bc362ec80648323428be5182338">More...</a><br /></td></tr>
<tr class="separator:a3d924bc362ec80648323428be5182338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa689721442ec303678047dd75c957bea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#aa689721442ec303678047dd75c957bea">WaitSystemEvent</a> (<a class="el" href="structnn_1_1os_1_1_system_event_type.html">SystemEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa689721442ec303678047dd75c957bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for a system event to enter a signaled state.  <a href="namespacenn_1_1os.html#aa689721442ec303678047dd75c957bea">More...</a><br /></td></tr>
<tr class="separator:aa689721442ec303678047dd75c957bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0367a830f313d114698a17311e7274c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a0367a830f313d114698a17311e7274c5">TryWaitSystemEvent</a> (<a class="el" href="structnn_1_1os_1_1_system_event_type.html">SystemEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0367a830f313d114698a17311e7274c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polls whether system events are in the signaled state.  <a href="namespacenn_1_1os.html#a0367a830f313d114698a17311e7274c5">More...</a><br /></td></tr>
<tr class="separator:a0367a830f313d114698a17311e7274c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25710360462b312201c3685e238f46e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#af25710360462b312201c3685e238f46e">TimedWaitSystemEvent</a> (<a class="el" href="structnn_1_1os_1_1_system_event_type.html">SystemEventType</a> *event, <a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> timeout) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af25710360462b312201c3685e238f46e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for a system event to enter a signaled state.  <a href="namespacenn_1_1os.html#af25710360462b312201c3685e238f46e">More...</a><br /></td></tr>
<tr class="separator:af25710360462b312201c3685e238f46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70789090416cc882f4aa2c786092e49a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a70789090416cc882f4aa2c786092e49a">ClearSystemEvent</a> (<a class="el" href="structnn_1_1os_1_1_system_event_type.html">SystemEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a70789090416cc882f4aa2c786092e49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the system event to the nonsignaled state.  <a href="namespacenn_1_1os.html#a70789090416cc882f4aa2c786092e49a">More...</a><br /></td></tr>
<tr class="separator:a70789090416cc882f4aa2c786092e49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Thread API Resources</div></td></tr>
<tr class="memitem:a75f43e1d3c194c0d2173ef5d95785933"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a75f43e1d3c194c0d2173ef5d95785933">CreateThread</a> (<a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *thread, <a class="el" href="namespacenn_1_1os.html#abec974a5d224f7c62cfa9af4af3c954a">ThreadFunction</a> function, void *argument, void *stack, size_t stackSize, int priority, int idealCoreNumber) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a75f43e1d3c194c0d2173ef5d95785933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a thread.  <a href="namespacenn_1_1os.html#a75f43e1d3c194c0d2173ef5d95785933">More...</a><br /></td></tr>
<tr class="separator:a75f43e1d3c194c0d2173ef5d95785933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7db66d31e254873b613d4eadd0d716"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a1e7db66d31e254873b613d4eadd0d716">CreateThread</a> (<a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *thread, <a class="el" href="namespacenn_1_1os.html#abec974a5d224f7c62cfa9af4af3c954a">ThreadFunction</a> function, void *argument, void *stack, size_t stackSize, int priority) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1e7db66d31e254873b613d4eadd0d716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a thread.  <a href="namespacenn_1_1os.html#a1e7db66d31e254873b613d4eadd0d716">More...</a><br /></td></tr>
<tr class="separator:a1e7db66d31e254873b613d4eadd0d716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbfcfb82583a9e34431e8c11d2411dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a9dbfcfb82583a9e34431e8c11d2411dd">DestroyThread</a> (<a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *thread) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9dbfcfb82583a9e34431e8c11d2411dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a thread.  <a href="namespacenn_1_1os.html#a9dbfcfb82583a9e34431e8c11d2411dd">More...</a><br /></td></tr>
<tr class="separator:a9dbfcfb82583a9e34431e8c11d2411dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18eec7c4c4c298f7abaa9ef41d6de76b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a18eec7c4c4c298f7abaa9ef41d6de76b">StartThread</a> (<a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *thread) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a18eec7c4c4c298f7abaa9ef41d6de76b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts execution on a thread.  <a href="namespacenn_1_1os.html#a18eec7c4c4c298f7abaa9ef41d6de76b">More...</a><br /></td></tr>
<tr class="separator:a18eec7c4c4c298f7abaa9ef41d6de76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad106866a5b13bc3d430104333966b479"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ad106866a5b13bc3d430104333966b479">GetCurrentThread</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad106866a5b13bc3d430104333966b479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <code><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="This structure defines a thread object.">ThreadType</a></code> object for the current thread.  <a href="namespacenn_1_1os.html#ad106866a5b13bc3d430104333966b479">More...</a><br /></td></tr>
<tr class="separator:ad106866a5b13bc3d430104333966b479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182856f23709b02b6022cc1b1765f69e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a182856f23709b02b6022cc1b1765f69e">TryWaitThread</a> (<a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *thread) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a182856f23709b02b6022cc1b1765f69e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polls to determine whether the target thread has ended.  <a href="namespacenn_1_1os.html#a182856f23709b02b6022cc1b1765f69e">More...</a><br /></td></tr>
<tr class="separator:a182856f23709b02b6022cc1b1765f69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8070c91be85c5ccb36b56e9ff3a75b26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a8070c91be85c5ccb36b56e9ff3a75b26">WaitThread</a> (<a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *thread) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8070c91be85c5ccb36b56e9ff3a75b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the specified thread to stop.  <a href="namespacenn_1_1os.html#a8070c91be85c5ccb36b56e9ff3a75b26">More...</a><br /></td></tr>
<tr class="separator:a8070c91be85c5ccb36b56e9ff3a75b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd5e5e72c058eb7d1b5f0ebfbb2cf6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a8bd5e5e72c058eb7d1b5f0ebfbb2cf6f">YieldThread</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8bd5e5e72c058eb7d1b5f0ebfbb2cf6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an opportunity to execute to another thread of the same priority.  <a href="namespacenn_1_1os.html#a8bd5e5e72c058eb7d1b5f0ebfbb2cf6f">More...</a><br /></td></tr>
<tr class="separator:a8bd5e5e72c058eb7d1b5f0ebfbb2cf6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b335e87af44c60a0d6dca75f11c9d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a96b335e87af44c60a0d6dca75f11c9d2">SleepThread</a> (<a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> time) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a96b335e87af44c60a0d6dca75f11c9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the current thread to sleep for the specified amount of time.  <a href="namespacenn_1_1os.html#a96b335e87af44c60a0d6dca75f11c9d2">More...</a><br /></td></tr>
<tr class="separator:a96b335e87af44c60a0d6dca75f11c9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7eb0e6eae11777e92308cdee62e6cb2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ac7eb0e6eae11777e92308cdee62e6cb2">ChangeThreadPriority</a> (<a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *thread, int priority) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac7eb0e6eae11777e92308cdee62e6cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the priority of the specified thread.  <a href="namespacenn_1_1os.html#ac7eb0e6eae11777e92308cdee62e6cb2">More...</a><br /></td></tr>
<tr class="separator:ac7eb0e6eae11777e92308cdee62e6cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912a6d5e17c206344f177bc192cb1e50"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a912a6d5e17c206344f177bc192cb1e50">GetThreadPriority</a> (const <a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *thread) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a912a6d5e17c206344f177bc192cb1e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the original priority of the specified thread.  <a href="namespacenn_1_1os.html#a912a6d5e17c206344f177bc192cb1e50">More...</a><br /></td></tr>
<tr class="separator:a912a6d5e17c206344f177bc192cb1e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6b2e5e1968e008dde27d6c4762b33d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a9b6b2e5e1968e008dde27d6c4762b33d">GetThreadCurrentPriority</a> (const <a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *thread) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9b6b2e5e1968e008dde27d6c4762b33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current priority of the specified thread.  <a href="namespacenn_1_1os.html#a9b6b2e5e1968e008dde27d6c4762b33d">More...</a><br /></td></tr>
<tr class="separator:a9b6b2e5e1968e008dde27d6c4762b33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cbcb85bd308694ec37eff49be93cf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a05cbcb85bd308694ec37eff49be93cf1">SetThreadName</a> (<a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *thread, const char *threadName) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a05cbcb85bd308694ec37eff49be93cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name of the specified thread.  <a href="namespacenn_1_1os.html#a05cbcb85bd308694ec37eff49be93cf1">More...</a><br /></td></tr>
<tr class="separator:a05cbcb85bd308694ec37eff49be93cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f2d7d33024e710d09a2b6d01b15522"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a90f2d7d33024e710d09a2b6d01b15522">SetThreadNamePointer</a> (<a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *thread, const char *threadName) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a90f2d7d33024e710d09a2b6d01b15522"><td class="mdescLeft">&#160;</td><td class="mdescRight">The address where the name of the target thread is stored.  <a href="namespacenn_1_1os.html#a90f2d7d33024e710d09a2b6d01b15522">More...</a><br /></td></tr>
<tr class="separator:a90f2d7d33024e710d09a2b6d01b15522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2941b0122ed1f1af2d7007af285d83b5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a2941b0122ed1f1af2d7007af285d83b5">GetThreadNamePointer</a> (const <a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *thread) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2941b0122ed1f1af2d7007af285d83b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the address where the name of the target thread is stored.  <a href="namespacenn_1_1os.html#a2941b0122ed1f1af2d7007af285d83b5">More...</a><br /></td></tr>
<tr class="separator:a2941b0122ed1f1af2d7007af285d83b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500af81132a0e2b26db7289bbd19942e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a500af81132a0e2b26db7289bbd19942e">GetCurrentProcessorNumber</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a500af81132a0e2b26db7289bbd19942e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the core number on which the current thread is running.  <a href="namespacenn_1_1os.html#a500af81132a0e2b26db7289bbd19942e">More...</a><br /></td></tr>
<tr class="separator:a500af81132a0e2b26db7289bbd19942e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b94c321b41c4fb4d0a4e87473297c48"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a4b94c321b41c4fb4d0a4e87473297c48">GetCurrentCoreNumber</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4b94c321b41c4fb4d0a4e87473297c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the core number on which the current thread is running.  <a href="namespacenn_1_1os.html#a4b94c321b41c4fb4d0a4e87473297c48">More...</a><br /></td></tr>
<tr class="separator:a4b94c321b41c4fb4d0a4e87473297c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50b86561c15ee3e8195c83fddc8e732"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ac50b86561c15ee3e8195c83fddc8e732">SetThreadCoreMask</a> (<a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *thread, int idealCore, Bit64 affinityMask) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac50b86561c15ee3e8195c83fddc8e732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the target thread core assignment.  <a href="namespacenn_1_1os.html#ac50b86561c15ee3e8195c83fddc8e732">More...</a><br /></td></tr>
<tr class="separator:ac50b86561c15ee3e8195c83fddc8e732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39edb8f3e676c4bab13047a5ad1894f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a39edb8f3e676c4bab13047a5ad1894f8">GetThreadCoreMask</a> (int *pOutIdealCore, Bit64 *pOutAffinityMask, const <a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *thread) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a39edb8f3e676c4bab13047a5ad1894f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the target thread core assignment.  <a href="namespacenn_1_1os.html#a39edb8f3e676c4bab13047a5ad1894f8">More...</a><br /></td></tr>
<tr class="separator:a39edb8f3e676c4bab13047a5ad1894f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91345e6e4543ab561f49480b89ae9a65"><td class="memItemLeft" align="right" valign="top">nn::Bit64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a91345e6e4543ab561f49480b89ae9a65">GetThreadAvailableCoreMask</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a91345e6e4543ab561f49480b89ae9a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets assignable cores.  <a href="namespacenn_1_1os.html#a91345e6e4543ab561f49480b89ae9a65">More...</a><br /></td></tr>
<tr class="separator:a91345e6e4543ab561f49480b89ae9a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcae078c4e6e1d1746ff8bd0eb7f7d85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1os.html#a34ce3817621fa1ea9b26c4f55c3bb284">ThreadId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#adcae078c4e6e1d1746ff8bd0eb7f7d85">GetThreadId</a> (const <a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *thread) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:adcae078c4e6e1d1746ff8bd0eb7f7d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the thread identifier for the target thread.  <a href="namespacenn_1_1os.html#adcae078c4e6e1d1746ff8bd0eb7f7d85">More...</a><br /></td></tr>
<tr class="separator:adcae078c4e6e1d1746ff8bd0eb7f7d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Thread Local Storage API Resources</div></td></tr>
<tr class="memitem:a2a67ebeb78e5d624b45ec27d66bdf0b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a2a67ebeb78e5d624b45ec27d66bdf0b2">AllocateTlsSlot</a> (<a class="el" href="structnn_1_1os_1_1_tls_slot.html">TlsSlot</a> *outTlsSlot, <a class="el" href="namespacenn_1_1os.html#af369e7c06c6548eebe7abda706ec54f3">TlsDestructor</a> function) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2a67ebeb78e5d624b45ec27d66bdf0b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an empty TLS slot.  <a href="namespacenn_1_1os.html#a2a67ebeb78e5d624b45ec27d66bdf0b2">More...</a><br /></td></tr>
<tr class="separator:a2a67ebeb78e5d624b45ec27d66bdf0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afded66e76230ba96acc86ba3d48d76c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#afded66e76230ba96acc86ba3d48d76c4">FreeTlsSlot</a> (<a class="el" href="structnn_1_1os_1_1_tls_slot.html">TlsSlot</a> tlsSlot) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:afded66e76230ba96acc86ba3d48d76c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a TLS slot.  <a href="namespacenn_1_1os.html#afded66e76230ba96acc86ba3d48d76c4">More...</a><br /></td></tr>
<tr class="separator:afded66e76230ba96acc86ba3d48d76c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452445507fba4dc49cb9cfb77b4c88c1"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a452445507fba4dc49cb9cfb77b4c88c1">GetTlsValue</a> (<a class="el" href="structnn_1_1os_1_1_tls_slot.html">TlsSlot</a> tlsSlot) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a452445507fba4dc49cb9cfb77b4c88c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value from the specified TLS slot.  <a href="namespacenn_1_1os.html#a452445507fba4dc49cb9cfb77b4c88c1">More...</a><br /></td></tr>
<tr class="separator:a452445507fba4dc49cb9cfb77b4c88c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f54d6581f3380bc9b6b7d92c9855acd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a8f54d6581f3380bc9b6b7d92c9855acd">SetTlsValue</a> (<a class="el" href="structnn_1_1os_1_1_tls_slot.html">TlsSlot</a> tlsSlot, uintptr_t value) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8f54d6581f3380bc9b6b7d92c9855acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a value in the specified TLS slot.  <a href="namespacenn_1_1os.html#a8f54d6581f3380bc9b6b7d92c9855acd">More...</a><br /></td></tr>
<tr class="separator:a8f54d6581f3380bc9b6b7d92c9855acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0db5a1ab770f99f96e327aeb5c653ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#aa0db5a1ab770f99f96e327aeb5c653ce">GetUsedTlsSlotCount</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa0db5a1ab770f99f96e327aeb5c653ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of allocated TLS slots.  <a href="namespacenn_1_1os.html#aa0db5a1ab770f99f96e327aeb5c653ce">More...</a><br /></td></tr>
<tr class="separator:aa0db5a1ab770f99f96e327aeb5c653ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Time Management API Resources</div></td></tr>
<tr class="memitem:a79e29821bfb2b0c3a5c222488e90cc89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1os_1_1_tick.html">Tick</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a79e29821bfb2b0c3a5c222488e90cc89">GetSystemTick</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a79e29821bfb2b0c3a5c222488e90cc89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the system tick value.  <a href="namespacenn_1_1os.html#a79e29821bfb2b0c3a5c222488e90cc89">More...</a><br /></td></tr>
<tr class="separator:a79e29821bfb2b0c3a5c222488e90cc89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0439628669fdcc2c6a94a852b2a6ea3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1os_1_1_tick.html">Tick</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ac0439628669fdcc2c6a94a852b2a6ea3">GetSystemTickOrdered</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac0439628669fdcc2c6a94a852b2a6ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the system tick value.  <a href="namespacenn_1_1os.html#ac0439628669fdcc2c6a94a852b2a6ea3">More...</a><br /></td></tr>
<tr class="separator:ac0439628669fdcc2c6a94a852b2a6ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64f2523f9e13afef5de6197898afa27"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#aa64f2523f9e13afef5de6197898afa27">GetSystemTickFrequency</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa64f2523f9e13afef5de6197898afa27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the frequency of the system tick value.  <a href="namespacenn_1_1os.html#aa64f2523f9e13afef5de6197898afa27">More...</a><br /></td></tr>
<tr class="separator:aa64f2523f9e13afef5de6197898afa27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53032bee4cfe0f01916e8149c393adad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a53032bee4cfe0f01916e8149c393adad">ConvertToTimeSpan</a> (<a class="el" href="classnn_1_1os_1_1_tick.html">Tick</a> tick) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a53032bee4cfe0f01916e8149c393adad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the system ticks and returns them as an <code><a class="el" href="classnn_1_1_time_span.html" title="This class represents a length of time.">nn::TimeSpan</a></code> representation of time.  <a href="namespacenn_1_1os.html#a53032bee4cfe0f01916e8149c393adad">More...</a><br /></td></tr>
<tr class="separator:a53032bee4cfe0f01916e8149c393adad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9b3542885a746dca530490408f78c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1os_1_1_tick.html">Tick</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a8c9b3542885a746dca530490408f78c1">ConvertToTick</a> (<a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> timeSpan) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8c9b3542885a746dca530490408f78c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an <code><a class="el" href="classnn_1_1_time_span.html" title="This class represents a length of time.">nn::TimeSpan</a></code> representation of time and returns it as a system tick.  <a href="namespacenn_1_1os.html#a8c9b3542885a746dca530490408f78c1">More...</a><br /></td></tr>
<tr class="separator:a8c9b3542885a746dca530490408f78c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Timer Event API Resources</div></td></tr>
<tr class="memitem:a9fdcd9b26aa9e78c2c17f6b9c02c0314"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a9fdcd9b26aa9e78c2c17f6b9c02c0314">InitializeTimerEvent</a> (<a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *event, <a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452">EventClearMode</a> clearMode) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9fdcd9b26aa9e78c2c17f6b9c02c0314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a <code><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="This structure defines a timer event object.">TimerEventType</a></code> object.  <a href="namespacenn_1_1os.html#a9fdcd9b26aa9e78c2c17f6b9c02c0314">More...</a><br /></td></tr>
<tr class="separator:a9fdcd9b26aa9e78c2c17f6b9c02c0314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1752ba511e60ce027c4af0f6d5e3ebe9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a1752ba511e60ce027c4af0f6d5e3ebe9">FinalizeTimerEvent</a> (<a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1752ba511e60ce027c4af0f6d5e3ebe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a <code><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="This structure defines a timer event object.">TimerEventType</a></code> object.  <a href="namespacenn_1_1os.html#a1752ba511e60ce027c4af0f6d5e3ebe9">More...</a><br /></td></tr>
<tr class="separator:a1752ba511e60ce027c4af0f6d5e3ebe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3ec8d6c3a7f4410dc6f9c4dec0f88d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a9b3ec8d6c3a7f4410dc6f9c4dec0f88d">StartOneShotTimerEvent</a> (<a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *event, <a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> first) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9b3ec8d6c3a7f4410dc6f9c4dec0f88d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the <code><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="This structure defines a timer event object.">TimerEventType</a></code> object's one-shot timer.  <a href="namespacenn_1_1os.html#a9b3ec8d6c3a7f4410dc6f9c4dec0f88d">More...</a><br /></td></tr>
<tr class="separator:a9b3ec8d6c3a7f4410dc6f9c4dec0f88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac869e53e9d805c3a5781d6493fad6ccd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ac869e53e9d805c3a5781d6493fad6ccd">StartPeriodicTimerEvent</a> (<a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *event, <a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> first, <a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> interval) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac869e53e9d805c3a5781d6493fad6ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the <code><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="This structure defines a timer event object.">TimerEventType</a></code> object's periodic timer.  <a href="namespacenn_1_1os.html#ac869e53e9d805c3a5781d6493fad6ccd">More...</a><br /></td></tr>
<tr class="separator:ac869e53e9d805c3a5781d6493fad6ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa23680b72e19fd5cb974ef44325695"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a6aa23680b72e19fd5cb974ef44325695">StopTimerEvent</a> (<a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6aa23680b72e19fd5cb974ef44325695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the <code><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="This structure defines a timer event object.">TimerEventType</a></code> object's timer.  <a href="namespacenn_1_1os.html#a6aa23680b72e19fd5cb974ef44325695">More...</a><br /></td></tr>
<tr class="separator:a6aa23680b72e19fd5cb974ef44325695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bdecafeed401cb6b8accdb15178ad66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a3bdecafeed401cb6b8accdb15178ad66">WaitTimerEvent</a> (<a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3bdecafeed401cb6b8accdb15178ad66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for a <code><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="This structure defines a timer event object.">TimerEventType</a></code> object to enter a signaled state.  <a href="namespacenn_1_1os.html#a3bdecafeed401cb6b8accdb15178ad66">More...</a><br /></td></tr>
<tr class="separator:a3bdecafeed401cb6b8accdb15178ad66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa431fe82cc23064bbad8cacf102756fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#aa431fe82cc23064bbad8cacf102756fd">TryWaitTimerEvent</a> (<a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa431fe82cc23064bbad8cacf102756fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polls whether a <code><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="This structure defines a timer event object.">TimerEventType</a></code> object is in a signaled state.  <a href="namespacenn_1_1os.html#aa431fe82cc23064bbad8cacf102756fd">More...</a><br /></td></tr>
<tr class="separator:aa431fe82cc23064bbad8cacf102756fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad526c59d6481d5fcf0e130d71c7f1252"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ad526c59d6481d5fcf0e130d71c7f1252">SignalTimerEvent</a> (<a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad526c59d6481d5fcf0e130d71c7f1252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immediately sets a <code><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="This structure defines a timer event object.">TimerEventType</a></code> object to the signaled state.  <a href="namespacenn_1_1os.html#ad526c59d6481d5fcf0e130d71c7f1252">More...</a><br /></td></tr>
<tr class="separator:ad526c59d6481d5fcf0e130d71c7f1252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2612c1c11f55172e23bf13d0b8a4e5b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a2612c1c11f55172e23bf13d0b8a4e5b2">ClearTimerEvent</a> (<a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2612c1c11f55172e23bf13d0b8a4e5b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears a <code><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="This structure defines a timer event object.">TimerEventType</a></code> object to the non-signaled state.  <a href="namespacenn_1_1os.html#a2612c1c11f55172e23bf13d0b8a4e5b2">More...</a><br /></td></tr>
<tr class="separator:a2612c1c11f55172e23bf13d0b8a4e5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">API For User Exception Handlers</div></td></tr>
<tr class="memitem:a80a1e659aaba155ff9552f48604aec54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a80a1e659aaba155ff9552f48604aec54">SetUserExceptionHandler</a> (<a class="el" href="namespacenn_1_1os.html#aff433bbe881d0fcb8fbb47fe3e299173">UserExceptionHandler</a> pHandler, void *stack, size_t stackSize, <a class="el" href="structnn_1_1os_1_1_user_exception_info.html">UserExceptionInfo</a> *pExceptionInfo) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a80a1e659aaba155ff9552f48604aec54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the user exception handler.  <a href="namespacenn_1_1os.html#a80a1e659aaba155ff9552f48604aec54">More...</a><br /></td></tr>
<tr class="separator:a80a1e659aaba155ff9552f48604aec54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52dba2921df0ef2adf203a4b9829a6d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a52dba2921df0ef2adf203a4b9829a6d6">EnableUserExceptionHandlerOnDebugging</a> (bool isEnabled) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a52dba2921df0ef2adf203a4b9829a6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether to enable the user exception handler even when connected to the debugger.  <a href="namespacenn_1_1os.html#a52dba2921df0ef2adf203a4b9829a6d6">More...</a><br /></td></tr>
<tr class="separator:a52dba2921df0ef2adf203a4b9829a6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Virtual Address Memory Management API Resources</div></td></tr>
<tr class="memitem:a11dca1988a4d23dc773f216847a56ecd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a11dca1988a4d23dc773f216847a56ecd">AllocateAddressRegion</a> (uintptr_t *pOutAddress, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a11dca1988a4d23dc773f216847a56ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an address area from the virtual address space.  <a href="namespacenn_1_1os.html#a11dca1988a4d23dc773f216847a56ecd">More...</a><br /></td></tr>
<tr class="separator:a11dca1988a4d23dc773f216847a56ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822e071b5061ef30ce2202d67fad8dd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a822e071b5061ef30ce2202d67fad8dd0">FreeAddressRegion</a> (uintptr_t address) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a822e071b5061ef30ce2202d67fad8dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the address area.  <a href="namespacenn_1_1os.html#a822e071b5061ef30ce2202d67fad8dd0">More...</a><br /></td></tr>
<tr class="separator:a822e071b5061ef30ce2202d67fad8dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2aecae3365f9881e63f3c9a77be239"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#afc2aecae3365f9881e63f3c9a77be239">AllocateMemoryPages</a> (uintptr_t address, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:afc2aecae3365f9881e63f3c9a77be239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Physical memory is assigned to the specified area.  <a href="namespacenn_1_1os.html#afc2aecae3365f9881e63f3c9a77be239">More...</a><br /></td></tr>
<tr class="separator:afc2aecae3365f9881e63f3c9a77be239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadde176efe5d5ec8352539a4c41cc468"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#aadde176efe5d5ec8352539a4c41cc468">FreeMemoryPages</a> (uintptr_t address, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aadde176efe5d5ec8352539a4c41cc468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases memory assigned to the specified area.  <a href="namespacenn_1_1os.html#aadde176efe5d5ec8352539a4c41cc468">More...</a><br /></td></tr>
<tr class="separator:aadde176efe5d5ec8352539a4c41cc468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b13b1f8e6e4fa352192eb9d121ff49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1os_1_1_virtual_address_memory_resource_usage.html">VirtualAddressMemoryResourceUsage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a49b13b1f8e6e4fa352192eb9d121ff49">GetVirtualAddressMemoryResourceUsage</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a49b13b1f8e6e4fa352192eb9d121ff49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the amount of resources consumed for virtual address memory management.  <a href="namespacenn_1_1os.html#a49b13b1f8e6e4fa352192eb9d121ff49">More...</a><br /></td></tr>
<tr class="separator:a49b13b1f8e6e4fa352192eb9d121ff49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e6556970df605db16e5548b9fd188c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c">IsVirtualAddressMemoryEnabled</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab9e6556970df605db16e5548b9fd188c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether virtual address memory management is available.  <a href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c">More...</a><br /></td></tr>
<tr class="separator:ab9e6556970df605db16e5548b9fd188c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a82acf7f7f39eb127ebffdef2c748c5e6"><td class="memItemLeft" align="right" valign="top"><a id="a82acf7f7f39eb127ebffdef2c748c5e6"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a82acf7f7f39eb127ebffdef2c748c5e6">AddressRegionAlignment</a> = 64 * 1024</td></tr>
<tr class="memdesc:a82acf7f7f39eb127ebffdef2c748c5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants that indicate the alignment restrictions for the starting address of the address area. <br /></td></tr>
<tr class="separator:a82acf7f7f39eb127ebffdef2c748c5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c212d3f3bc25e8ce9502a178b3e02e3"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a5c212d3f3bc25e8ce9502a178b3e02e3">CacheLineSize</a></td></tr>
<tr class="memdesc:a5c212d3f3bc25e8ce9502a178b3e02e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constant representing the cache line size, in bytes.  <a href="namespacenn_1_1os.html#a5c212d3f3bc25e8ce9502a178b3e02e3">More...</a><br /></td></tr>
<tr class="separator:a5c212d3f3bc25e8ce9502a178b3e02e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5985811d04e64c0823ed758fd420591d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a5985811d04e64c0823ed758fd420591d">DefaultThreadPriority</a> = (ThreadPriorityRangeSize / 2)</td></tr>
<tr class="memdesc:a5985811d04e64c0823ed758fd420591d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant indicating the default value of thread priority.  <a href="namespacenn_1_1os.html#a5985811d04e64c0823ed758fd420591d">More...</a><br /></td></tr>
<tr class="separator:a5985811d04e64c0823ed758fd420591d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8818e7de49601e4f83bd6d3ee822449"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ab8818e7de49601e4f83bd6d3ee822449">FiberStackAlignment</a> = 16</td></tr>
<tr class="memdesc:ab8818e7de49601e4f83bd6d3ee822449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant indicating the alignment rules for the fiber stack space.  <a href="namespacenn_1_1os.html#ab8818e7de49601e4f83bd6d3ee822449">More...</a><br /></td></tr>
<tr class="separator:ab8818e7de49601e4f83bd6d3ee822449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b2d95cc4315e16021578c2ba43208d"><td class="memItemLeft" align="right" valign="top"><a id="a09b2d95cc4315e16021578c2ba43208d"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a09b2d95cc4315e16021578c2ba43208d">GuardedStackAlignment</a> = 4096</td></tr>
<tr class="memdesc:a09b2d95cc4315e16021578c2ba43208d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant indicating the alignment rules for a guarded stack space. <br /></td></tr>
<tr class="separator:a09b2d95cc4315e16021578c2ba43208d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88f7888a125e3cf4d07f28cf9acb95a"><td class="memItemLeft" align="right" valign="top"><a id="ae88f7888a125e3cf4d07f28cf9acb95a"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ae88f7888a125e3cf4d07f28cf9acb95a">HandlerStackAlignment</a> = 16</td></tr>
<tr class="memdesc:ae88f7888a125e3cf4d07f28cf9acb95a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant representing a stack alignment restriction for a user exception handler. <br /></td></tr>
<tr class="separator:ae88f7888a125e3cf4d07f28cf9acb95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ca06939bae41f0ab89eda5be97d4fa"><td class="memItemLeft" align="right" valign="top"><a id="ac0ca06939bae41f0ab89eda5be97d4fa"></a>
void *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ac0ca06939bae41f0ab89eda5be97d4fa">HandlerStackUsesThreadStack</a> = reinterpret_cast&lt;void*&gt;(HandlerStackUsesThreadStackValue)</td></tr>
<tr class="memdesc:ac0ca06939bae41f0ab89eda5be97d4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant that specifies a thread stack as a user exception handler stack. <br /></td></tr>
<tr class="separator:ac0ca06939bae41f0ab89eda5be97d4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ed3b4dddf9ebfb69bc33167369b816"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a44ed3b4dddf9ebfb69bc33167369b816">HighestThreadPriority</a> = 0</td></tr>
<tr class="memdesc:a44ed3b4dddf9ebfb69bc33167369b816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant indicating the highest thread priority.  <a href="namespacenn_1_1os.html#a44ed3b4dddf9ebfb69bc33167369b816">More...</a><br /></td></tr>
<tr class="separator:a44ed3b4dddf9ebfb69bc33167369b816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333a7029b85a51321a4c79176e91eab3"><td class="memItemLeft" align="right" valign="top"><a id="a333a7029b85a51321a4c79176e91eab3"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a333a7029b85a51321a4c79176e91eab3">IdealCoreDontCare</a> = -1</td></tr>
<tr class="memdesc:a333a7029b85a51321a4c79176e91eab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets without a preferred core number. <br /></td></tr>
<tr class="separator:a333a7029b85a51321a4c79176e91eab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418170f89de31518fdc59c699d78a1b1"><td class="memItemLeft" align="right" valign="top"><a id="a418170f89de31518fdc59c699d78a1b1"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a418170f89de31518fdc59c699d78a1b1">IdealCoreNoUpdate</a> = -3</td></tr>
<tr class="memdesc:a418170f89de31518fdc59c699d78a1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does not update the preferred core number. <br /></td></tr>
<tr class="separator:a418170f89de31518fdc59c699d78a1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3959f30f2583f83a37ec382f091fd9fa"><td class="memItemLeft" align="right" valign="top"><a id="a3959f30f2583f83a37ec382f091fd9fa"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a3959f30f2583f83a37ec382f091fd9fa">IdealCoreUseDefaultValue</a> = -2</td></tr>
<tr class="memdesc:a3959f30f2583f83a37ec382f091fd9fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only operates on the preferred core set in this program. <br /></td></tr>
<tr class="separator:a3959f30f2583f83a37ec382f091fd9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8beb482b6d0aef56dc4877498abc9756"><td class="memItemLeft" align="right" valign="top"><a id="a8beb482b6d0aef56dc4877498abc9756"></a>
const <a class="el" href="namespacenn_1_1os.html#a84b48561ef817ac28bde556d321a382e">NativeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a8beb482b6d0aef56dc4877498abc9756">InvalidNativeHandle</a> = 0</td></tr>
<tr class="memdesc:a8beb482b6d0aef56dc4877498abc9756"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constant representing invalid handles. <br /></td></tr>
<tr class="separator:a8beb482b6d0aef56dc4877498abc9756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88510f5f630a16612aa8d479c10b56de"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a88510f5f630a16612aa8d479c10b56de">LowestThreadPriority</a> = (ThreadPriorityRangeSize - 1)</td></tr>
<tr class="memdesc:a88510f5f630a16612aa8d479c10b56de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant indicating the lowest thread priority.  <a href="namespacenn_1_1os.html#a88510f5f630a16612aa8d479c10b56de">More...</a><br /></td></tr>
<tr class="separator:a88510f5f630a16612aa8d479c10b56de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade84ad9f438e76820510ca0623c5a823"><td class="memItemLeft" align="right" valign="top"><a id="ade84ad9f438e76820510ca0623c5a823"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ade84ad9f438e76820510ca0623c5a823">MemoryBlockUnitSize</a> = 2 * 1024 * 1024</td></tr>
<tr class="memdesc:ade84ad9f438e76820510ca0623c5a823"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constant stores the minimum unit of a memory block. <br /></td></tr>
<tr class="separator:ade84ad9f438e76820510ca0623c5a823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed47f05ce9175eb46876c1ddd0512c7"><td class="memItemLeft" align="right" valign="top"><a id="aeed47f05ce9175eb46876c1ddd0512c7"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#aeed47f05ce9175eb46876c1ddd0512c7">MemoryHeapUnitSize</a> = 2 * 1024 * 1024</td></tr>
<tr class="memdesc:aeed47f05ce9175eb46876c1ddd0512c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constant stores the minimum unit of a memory heap region. <br /></td></tr>
<tr class="separator:aeed47f05ce9175eb46876c1ddd0512c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac880b46610757e748d5bd79211af4236"><td class="memItemLeft" align="right" valign="top"><a id="ac880b46610757e748d5bd79211af4236"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ac880b46610757e748d5bd79211af4236">MemoryPageSize</a> = 4 * 1024</td></tr>
<tr class="memdesc:ac880b46610757e748d5bd79211af4236"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constant stores the minimum unit for memory operations. <br /></td></tr>
<tr class="separator:ac880b46610757e748d5bd79211af4236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6aa9ce2dde219059e2a4b798ab7745"><td class="memItemLeft" align="right" valign="top"><a id="a0f6aa9ce2dde219059e2a4b798ab7745"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a0f6aa9ce2dde219059e2a4b798ab7745">MutexLockLevelInitial</a> = 0</td></tr>
<tr class="memdesc:a0f6aa9ce2dde219059e2a4b798ab7745"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constant represents the initial value of the mutex lock level for the current thread. <br /></td></tr>
<tr class="separator:a0f6aa9ce2dde219059e2a4b798ab7745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b0e2596b8091c49374130b049168f6"><td class="memItemLeft" align="right" valign="top"><a id="a20b0e2596b8091c49374130b049168f6"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a20b0e2596b8091c49374130b049168f6">MutexLockLevelMax</a> = 31</td></tr>
<tr class="memdesc:a20b0e2596b8091c49374130b049168f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constant represents the maximum value of a mutex lock level. <br /></td></tr>
<tr class="separator:a20b0e2596b8091c49374130b049168f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb8cce9509759efcb7b1080b20ca960"><td class="memItemLeft" align="right" valign="top"><a id="aafb8cce9509759efcb7b1080b20ca960"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#aafb8cce9509759efcb7b1080b20ca960">MutexLockLevelMin</a> = 1</td></tr>
<tr class="memdesc:aafb8cce9509759efcb7b1080b20ca960"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constant represents the minimum value of a mutex lock level. <br /></td></tr>
<tr class="separator:aafb8cce9509759efcb7b1080b20ca960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e36be94a982f77ee0ff4ecd1f2c1af"><td class="memItemLeft" align="right" valign="top"><a id="ae7e36be94a982f77ee0ff4ecd1f2c1af"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ae7e36be94a982f77ee0ff4ecd1f2c1af">MutexRecursiveLockCountMax</a> = 65535</td></tr>
<tr class="memdesc:ae7e36be94a982f77ee0ff4ecd1f2c1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constant represents the maximum recursive lock count for a mutex. <br /></td></tr>
<tr class="separator:ae7e36be94a982f77ee0ff4ecd1f2c1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb4af12ad2e9b3e32f1e72d3a313f32"><td class="memItemLeft" align="right" valign="top"><a id="a3cb4af12ad2e9b3e32f1e72d3a313f32"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a3cb4af12ad2e9b3e32f1e72d3a313f32">ReaderWriterLockCountMax</a> = (1 &lt;&lt; 15) - 1</td></tr>
<tr class="memdesc:a3cb4af12ad2e9b3e32f1e72d3a313f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant representing the maximum count for readers-writer locks. <br /></td></tr>
<tr class="separator:a3cb4af12ad2e9b3e32f1e72d3a313f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa3807e422796d3f349b4d2dbb1d656"><td class="memItemLeft" align="right" valign="top"><a id="a7aa3807e422796d3f349b4d2dbb1d656"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a7aa3807e422796d3f349b4d2dbb1d656">SdkTlsSlotCountMax</a> = 16</td></tr>
<tr class="memdesc:a7aa3807e422796d3f349b4d2dbb1d656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant indicating the total number of SDK TLS slots. <br /></td></tr>
<tr class="separator:a7aa3807e422796d3f349b4d2dbb1d656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895eb281cfb4500d6ac462cec6631613"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a895eb281cfb4500d6ac462cec6631613">StackRegionAlignment</a> = <a class="el" href="namespacenn_1_1os.html#a8b116319f3d483f3805c193661f22150">ThreadStackAlignment</a></td></tr>
<tr class="memdesc:a895eb281cfb4500d6ac462cec6631613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant indicating the alignment rules for the stack space.  <a href="namespacenn_1_1os.html#a895eb281cfb4500d6ac462cec6631613">More...</a><br /></td></tr>
<tr class="separator:a895eb281cfb4500d6ac462cec6631613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793a3781900c43f3d8afda6e02ec1b58"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a793a3781900c43f3d8afda6e02ec1b58">ThreadNameLengthMax</a> = 32</td></tr>
<tr class="memdesc:a793a3781900c43f3d8afda6e02ec1b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant indicating the maximum length of a thread name.  <a href="namespacenn_1_1os.html#a793a3781900c43f3d8afda6e02ec1b58">More...</a><br /></td></tr>
<tr class="separator:a793a3781900c43f3d8afda6e02ec1b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b116319f3d483f3805c193661f22150"><td class="memItemLeft" align="right" valign="top"><a id="a8b116319f3d483f3805c193661f22150"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a8b116319f3d483f3805c193661f22150">ThreadStackAlignment</a> = 4096</td></tr>
<tr class="memdesc:a8b116319f3d483f3805c193661f22150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant indicating the alignment rules for a thread stack space. <br /></td></tr>
<tr class="separator:a8b116319f3d483f3805c193661f22150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59fab4470b957077f8605c71502c9f2f"><td class="memItemLeft" align="right" valign="top"><a id="a59fab4470b957077f8605c71502c9f2f"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a59fab4470b957077f8605c71502c9f2f">TlsSlotCountMax</a> = 16</td></tr>
<tr class="memdesc:a59fab4470b957077f8605c71502c9f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant indicating the total number of TLS slots. <br /></td></tr>
<tr class="separator:a59fab4470b957077f8605c71502c9f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b6dc109705a61e232eb0087fbb8720"><td class="memItemLeft" align="right" valign="top"><a id="a74b6dc109705a61e232eb0087fbb8720"></a>
<a class="el" href="structnn_1_1os_1_1_user_exception_info.html">UserExceptionInfo</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a74b6dc109705a61e232eb0087fbb8720">UserExceptionInfoUsesHandlerStack</a> = reinterpret_cast&lt;<a class="el" href="structnn_1_1os_1_1_user_exception_info.html">UserExceptionInfo</a>*&gt;(static_cast&lt;const intptr_t&gt;(UserExceptionInfoUsesHandlerStackValue))</td></tr>
<tr class="memdesc:a74b6dc109705a61e232eb0087fbb8720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant that specifies an exception handler stack as a region storing exception information. <br /></td></tr>
<tr class="separator:a74b6dc109705a61e232eb0087fbb8720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95b1a34cff3839ca8d8af43ff4512cd"><td class="memItemLeft" align="right" valign="top"><a id="ae95b1a34cff3839ca8d8af43ff4512cd"></a>
<a class="el" href="structnn_1_1os_1_1_user_exception_info.html">UserExceptionInfo</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ae95b1a34cff3839ca8d8af43ff4512cd">UserExceptionInfoUsesThreadStack</a> = reinterpret_cast&lt;<a class="el" href="structnn_1_1os_1_1_user_exception_info.html">UserExceptionInfo</a>*&gt;(static_cast&lt;const intptr_t&gt;(UserExceptionInfoUsesThreadStackValue))</td></tr>
<tr class="memdesc:ae95b1a34cff3839ca8d8af43ff4512cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant that specifies a thread stack as a region storing exception information. <br /></td></tr>
<tr class="separator:ae95b1a34cff3839ca8d8af43ff4512cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the namespace for the operating system library. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a00a0fffd9172c3779939c06927973bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a0fffd9172c3779939c06927973bed">&#9670;&nbsp;</a></span>FiberFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structnn_1_1os_1_1_fiber_type.html">FiberType</a>*(* nn::os::FiberFunction) (void *argument)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This type represents the entry point of a fiber function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">argument</td><td>Arguments to be received by the fiber function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the <code><a class="el" href="structnn_1_1os_1_1_fiber_type.html" title="This structure defines a fiber object.">FiberType</a></code> object that points to the fiber that execution will jump to.</dd></dl>
<p> <b>Details</b> <br  />
 This type represents the entry point of a fiber function.</p>
<p>When returning from the fiber function, return a <code><a class="el" href="structnn_1_1os_1_1_fiber_type.html" title="This structure defines a fiber object.">FiberType</a></code> pointer that points to the fiber that execution will jump to. If a return value of <code>NULL</code> is specified, control returns to the point where <code><a class="el" href="namespacenn_1_1os.html#a3ba39dbca8b416903a5e2947927ed3e0" title="Starts or resumes execution of a fiber.">SwitchToFiber()</a></code> was called in the original thread. For more information, see the reference for <code><a class="el" href="namespacenn_1_1os.html#a9f0b5787e55da6b3b0e089d6b3ee6816" title="Initializes a fiber object.">InitializeFiber()</a></code>. </p>

</div>
</div>
<a id="a84b48561ef817ac28bde556d321a382e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b48561ef817ac28bde556d321a382e">&#9670;&nbsp;</a></span>NativeHandle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="namespacenn_1_1os.html#a84b48561ef817ac28bde556d321a382e">nn::os::NativeHandle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type representing handles that are managed by the system. </p>
<p> <b>Details</b> <br  />
 Data type used to handle the handle managed by the system. This feature is usually only used by a subset of SDK developers.</p>
<div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
 <code>typedef</code> as <code>void*</code> instead of <code>uint32_t</code> in a Windows environment.</div><div class="platform_section" data-platform="Windows"></div><p> Directly altering values is prohibited. Use through the following function.</p>
<ul>
<li><code><a class="el" href="namespacenn_1_1os.html#a84abb8d61f9ab227f76ae7b54dcce5d4">CloseNativeHandle()</a></code></li>
</ul>
<p>To use this function, include <code><a class="el" href="os___native_handle_types_8h.html" title="Declarations of types and constants for handles.">nn/os/os_NativeHandleTypes.h</a></code>. </p>

</div>
</div>
<a id="aff433bbe881d0fcb8fbb47fe3e299173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff433bbe881d0fcb8fbb47fe3e299173">&#9670;&nbsp;</a></span>UserExceptionHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* nn::os::UserExceptionHandler) (<a class="el" href="structnn_1_1os_1_1_user_exception_info.html">UserExceptionInfo</a> *info)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type representing a user exception handler function. </p>
<p> <b>Details</b> <br  />
 Type representing an exception handler function. The <code><em>info</em></code> parameter takes information about the exception that occurred.</p>
<p>The systems stops (with a <code>panic</code>) if the process returns from the exception handler. For information about exception handlers, see the <code><a class="el" href="namespacenn_1_1os.html#a80a1e659aaba155ff9552f48604aec54" title="Sets the user exception handler.">SetUserExceptionHandler()</a></code> function. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ae1fe4fe10826c19cf2c66e534962180a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1fe4fe10826c19cf2c66e534962180a">&#9670;&nbsp;</a></span>ConditionVariableStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1os.html#ae1fe4fe10826c19cf2c66e534962180a">nn::os::ConditionVariableStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The enumerated type representing the return values related to the feature for waiting for a condition variable with a time limit. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae1fe4fe10826c19cf2c66e534962180aa4cad80372ca8b9c68ee8d1a34e806d24"></a>ConditionVariableStatus_Timeout&#160;</td><td class="fielddoc"><p>Timed out. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae1fe4fe10826c19cf2c66e534962180aa2f5f309e61d650e34b30f0308c17818c"></a>ConditionVariableStatus_NoTimeout&#160;</td><td class="fielddoc"><p>Woke up for some reason other than timed out. </p>
</td></tr>
</table>

</div>
</div>
<a id="a11ab71d44973a4135958c420e5682452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ab71d44973a4135958c420e5682452">&#9670;&nbsp;</a></span>EventClearMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452">nn::os::EventClearMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerates the clear modes of an event. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a11ab71d44973a4135958c420e5682452a8b702480f5120eeeb01e7102227285da"></a>EventClearMode_ManualClear&#160;</td><td class="fielddoc"><p>Manually cleared event. </p>
</td></tr>
<tr><td class="fieldname"><a id="a11ab71d44973a4135958c420e5682452a31f6133098296b3ddb7e14da3dc695cc"></a>EventClearMode_AutoClear&#160;</td><td class="fielddoc"><p>Automatically cleared event. </p>
</td></tr>
</table>

</div>
</div>
<a id="a39b515dc6753642a34364d91b5813104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b515dc6753642a34364d91b5813104">&#9670;&nbsp;</a></span>FiberFlag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1os.html#a39b515dc6753642a34364d91b5813104">nn::os::FiberFlag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerates the flags associated with fibers. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a39b515dc6753642a34364d91b5813104ac2bbce12f37e3e01eb6a244e2ada14c7"></a>FiberFlag_NoStackGuard&#160;</td><td class="fielddoc"><p>Do not set up stack guards. </p>
</td></tr>
</table>

</div>
</div>
<a id="a3271c9fc6c46cffdb076b966f15a80bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3271c9fc6c46cffdb076b966f15a80bc">&#9670;&nbsp;</a></span>MessageQueueWaitType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1os.html#a3271c9fc6c46cffdb076b966f15a80bc">nn::os::MessageQueueWaitType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerates the message queue wait types of a multiwait object. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3271c9fc6c46cffdb076b966f15a80bca0fa8f18b62354b68a7838af2bf4e6f01"></a>MessageQueueWaitType_WaitForNotFull&#160;</td><td class="fielddoc"><p>Wait until the message queue has an opening. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3271c9fc6c46cffdb076b966f15a80bca40a79a4dabe0233dd5c21d7c4a718eea"></a>MessageQueueWaitType_WaitForNotEmpty&#160;</td><td class="fielddoc"><p>Wait until the message queue is no longer empty. </p>
</td></tr>
</table>

</div>
</div>
<a id="a883ab0b53c72a07619d9e83de4836b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883ab0b53c72a07619d9e83de4836b9a">&#9670;&nbsp;</a></span>MemoryPermission</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1os.html#a883ab0b53c72a07619d9e83de4836b9a">nn::os::MemoryPermission</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This enumerated type represents memory access permissions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a883ab0b53c72a07619d9e83de4836b9aaf6942de46447bc0df8294a749a329d08"></a>MemoryPermission_None&#160;</td><td class="fielddoc"><p>Access to memory is prohibited. </p>
</td></tr>
<tr><td class="fieldname"><a id="a883ab0b53c72a07619d9e83de4836b9aad0057f9250371335c5b9292ff44e1750"></a>MemoryPermission_ReadOnly&#160;</td><td class="fielddoc"><p>Memory is read-only. </p>
</td></tr>
<tr><td class="fieldname"><a id="a883ab0b53c72a07619d9e83de4836b9aa699f0e08f6eddbe0264cf6664a2a1a4b"></a>MemoryPermission_WriteOnly&#160;</td><td class="fielddoc"><p>Memory is write-only. </p>
</td></tr>
<tr><td class="fieldname"><a id="a883ab0b53c72a07619d9e83de4836b9aa57ead1592d9473ac1c22f0b4f75ed2c0"></a>MemoryPermission_ReadWrite&#160;</td><td class="fielddoc"><p>Memory can be read from and written to. </p>
</td></tr>
<tr><td class="fieldname"><a id="a883ab0b53c72a07619d9e83de4836b9aaedf7a33c0731cc16d736b3b74347a2c2"></a>MemoryPermission_ReadExecute&#160;</td><td class="fielddoc"><p>Memory is available to read. </p>
</td></tr>
</table>

</div>
</div>
<a id="a02aa5878802b6b43d6f12dacb05a5460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02aa5878802b6b43d6f12dacb05a5460">&#9670;&nbsp;</a></span>UserExceptionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1os.html#a02aa5878802b6b43d6f12dacb05a5460">nn::os::UserExceptionType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerated types defining the kinds of exceptions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a02aa5878802b6b43d6f12dacb05a5460ad563258d2c5fdbb3034dfab01d83759c"></a>UserExceptionType_InvalidInstructionAccess&#160;</td><td class="fielddoc"><p>Indicates instruction access to an invalid memory region. </p>
</td></tr>
<tr><td class="fieldname"><a id="a02aa5878802b6b43d6f12dacb05a5460ac0086e1b87acfa1b2009247bc8fda2cb"></a>UserExceptionType_InvalidDataAccess&#160;</td><td class="fielddoc"><p>Indicates data access to an invalid memory region. </p>
</td></tr>
<tr><td class="fieldname"><a id="a02aa5878802b6b43d6f12dacb05a5460ad8cd36398e52f181e3f42c17344b374d"></a>UserExceptionType_UnalignedInstructionAccess&#160;</td><td class="fielddoc"><p>Indicates instruction access with an invalid alignment. </p>
</td></tr>
<tr><td class="fieldname"><a id="a02aa5878802b6b43d6f12dacb05a5460a422b59612c02820b465514da0cd55418"></a>UserExceptionType_UnalignedDataAccess&#160;</td><td class="fielddoc"><p>Indicates data access with an invalid alignment. </p>
</td></tr>
<tr><td class="fieldname"><a id="a02aa5878802b6b43d6f12dacb05a5460acda61d04ba9081139baade0f28796133"></a>UserExceptionType_UndefinedInstruction&#160;</td><td class="fielddoc"><p>Indicates the execution of an undefined instruction. </p>
</td></tr>
<tr><td class="fieldname"><a id="a02aa5878802b6b43d6f12dacb05a5460af92e12c9f4fb7359a207ca3a800fd050"></a>UserExceptionType_ExceptionalInstruction&#160;</td><td class="fielddoc"><p>Indicates the execution of an exception instruction. </p>
</td></tr>
<tr><td class="fieldname"><a id="a02aa5878802b6b43d6f12dacb05a5460af78513bf294c682e7096df4862c16d2e"></a>UserExceptionType_MemorySystemError&#160;</td><td class="fielddoc"><p>Indicates an error from the memory system. </p>
</td></tr>
<tr><td class="fieldname"><a id="a02aa5878802b6b43d6f12dacb05a5460a6bcda4d1a1563579a851bef2515b5bee"></a>UserExceptionType_FloatingPointException&#160;</td><td class="fielddoc"><p>Indicates a floating-point calculation exception. </p>
</td></tr>
<tr><td class="fieldname"><a id="a02aa5878802b6b43d6f12dacb05a5460af85b93bd5f06784cc5ed23911c288d69"></a>UserExceptionType_InvalidSystemCall&#160;</td><td class="fielddoc"><p>Indicates an invalid system call. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="acf2fa6b7b7074a51d0b2de1664cc7bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf2fa6b7b7074a51d0b2de1664cc7bb5">&#9670;&nbsp;</a></span>GetHostArgc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::os::GetHostArgc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of host-specified command-line arguments (<code>argc</code>). </p>
<dl class="section return"><dt>Returns</dt><dd>The number of host-specified command-line arguments. This value is normally 1 or greater.</dd></dl>
<p> <b>Details</b> <br  />
 Gets the number of host-specified command-line arguments (<code>argc</code>). If there is no argument information, the function returns <code>1</code> and <code><a class="el" href="namespacenn_1_1os.html#abd77e6bf19be140867869cc759fa492c" title="Gets the array of pointers (argc) to the strings for the host-specified command-line arguments.">nn::os::GetHostArgv()</a>[0][0]</code> == <code>'\0'</code>.</p>
<p>Use this function to get the number of command-line arguments that have been specified when the program is started from a tool like TargetManager, VSI, or RunOnTarget. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a79">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a38">AudioOut/AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_2_audio_out_with_resampler_8cpp-example.html#a38">AudioOutWithResampler/AudioOutWithResampler.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#a144">FontDemo/Main.cpp</a>, <a class="el" href="_ldn_simple_2_main_8cpp-example.html#a8">LdnSimple/Main.cpp</a>, <a class="el" href="_libcurl_2_basic_2_libcurl_basic_8cpp-example.html#a9">Libcurl/Basic/LibcurlBasic.cpp</a>, <a class="el" href="_libcurl_2_speed_test_2_libcurl_speed_test_8cpp-example.html#a33">Libcurl/SpeedTest/LibcurlSpeedTest.cpp</a>, <a class="el" href="_libcurl_2_ssl_context_import_2_libcurl_ssl_context_import_8cpp-example.html#a9">Libcurl/SslContextImport/LibcurlSslContextImport.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a9">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_2_movie_player_simple_8cpp-example.html#a2">MoviePlayerSimple/MoviePlayerSimple.cpp</a>, <a class="el" href="_openssl_2_client_2_openssl_client_8cpp-example.html#a54">Openssl/Client/OpensslClient.cpp</a>, <a class="el" href="_socket_basic_2_socket_basic_8cpp-example.html#a32">SocketBasic/SocketBasic.cpp</a>, <a class="el" href="_socket_multicast_2_basic_2_socket_multicast_basic_8cpp-example.html#a15">SocketMulticast/Basic/SocketMulticastBasic.cpp</a>, <a class="el" href="_socket_resolver_2_socket_resolver_8cpp-example.html#a32">SocketResolver/SocketResolver.cpp</a>, <a class="el" href="_socket_statistics_overlay_2_socket_statistics_overlay_8cpp-example.html#a57">SocketStatisticsOverlay/SocketStatisticsOverlay.cpp</a>, <a class="el" href="_ssl_simple_2_ssl_simple_8cpp-example.html#a50">SslSimple/SslSimple.cpp</a>, <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#a128">Ui2dDemo/Main.cpp</a>, and <a class="el" href="_unit_test_with_googletest_2_unit_test_with_googletest_8cpp-example.html#a0">UnitTestWithGoogletest/UnitTestWithGoogletest.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="abd77e6bf19be140867869cc759fa492c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd77e6bf19be140867869cc759fa492c">&#9670;&nbsp;</a></span>GetHostArgv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** nn::os::GetHostArgv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the array of pointers (<code>argc</code>) to the strings for the host-specified command-line arguments. </p>
<dl class="section return"><dt>Returns</dt><dd>The array of pointers (<code>argc</code>) to the strings for the host-specified command-line arguments.</dd></dl>
<p> <b>Details</b> <br  />
 Gets the array of pointers (<code>argc</code>) to the strings for the host-specified command-line arguments. If there is no argument information, the function returns a pointer to an array: { "", NULL }. The maximum length for the arguments is 32 KiB. This length is the full path of the executable binary, including the space characters that delimit arguments and the '"' that is added automatically before and after each argument.</p>
<p>Use this function to get the number of command-line arguments that have been specified when the program is started from a tool like TargetManager, VSI, or RunOnTarget. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a80">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a37">AudioOut/AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_2_audio_out_with_resampler_8cpp-example.html#a37">AudioOutWithResampler/AudioOutWithResampler.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#a145">FontDemo/Main.cpp</a>, <a class="el" href="_fontll_save_to_jpeg_2_fontll_save_to_jpeg_8cpp-example.html#a32">FontllSaveToJpeg/FontllSaveToJpeg.cpp</a>, <a class="el" href="_ldn_simple_2_main_8cpp-example.html#a9">LdnSimple/Main.cpp</a>, <a class="el" href="_libcurl_2_basic_2_libcurl_basic_8cpp-example.html#a19">Libcurl/Basic/LibcurlBasic.cpp</a>, <a class="el" href="_libcurl_2_speed_test_2_libcurl_speed_test_8cpp-example.html#a34">Libcurl/SpeedTest/LibcurlSpeedTest.cpp</a>, <a class="el" href="_libcurl_2_ssl_context_import_2_libcurl_ssl_context_import_8cpp-example.html#a19">Libcurl/SslContextImport/LibcurlSslContextImport.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a10">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_2_movie_player_simple_8cpp-example.html#a3">MoviePlayerSimple/MoviePlayerSimple.cpp</a>, <a class="el" href="_openssl_2_client_2_openssl_client_8cpp-example.html#a55">Openssl/Client/OpensslClient.cpp</a>, <a class="el" href="_socket_basic_2_socket_basic_8cpp-example.html#a33">SocketBasic/SocketBasic.cpp</a>, <a class="el" href="_socket_multicast_2_basic_2_socket_multicast_basic_8cpp-example.html#a16">SocketMulticast/Basic/SocketMulticastBasic.cpp</a>, <a class="el" href="_socket_resolver_2_socket_resolver_8cpp-example.html#a33">SocketResolver/SocketResolver.cpp</a>, <a class="el" href="_socket_statistics_overlay_2_socket_statistics_overlay_8cpp-example.html#a58">SocketStatisticsOverlay/SocketStatisticsOverlay.cpp</a>, <a class="el" href="_ssl_simple_2_ssl_simple_8cpp-example.html#a51">SslSimple/SslSimple.cpp</a>, <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#a129">Ui2dDemo/Main.cpp</a>, and <a class="el" href="_unit_test_with_googletest_2_unit_test_with_googletest_8cpp-example.html#a1">UnitTestWithGoogletest/UnitTestWithGoogletest.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a063c2e1620b936cdc599de617a458516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a063c2e1620b936cdc599de617a458516">&#9670;&nbsp;</a></span>InitializeBarrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeBarrier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_barrier_type.html">BarrierType</a> *&#160;</td>
          <td class="paramname"><em>barrier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a <code><a class="el" href="structnn_1_1os_1_1_barrier_type.html" title="This structure defines a barrier object.">BarrierType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">barrier</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_barrier_type.html" title="This structure defines a barrier object.">BarrierType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numThreads</td><td>Number of threads to wait for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>numThreads</em></code> &gt; <code>0</code>.</li>
<li><code><em>barrier</em></code> is in an uninitialized state or has not been initialized.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>barrier</em></code> is in a non-signaled state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Initializes a <code><a class="el" href="structnn_1_1os_1_1_barrier_type.html" title="This structure defines a barrier object.">BarrierType</a></code> object.</p>
<p>This function is not thread-safe. Do not manipulate the object specified in <code><em>barrier</em></code> while this function is being called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_barrier_2_os_barrier_8cpp-example.html#a10">OsBarrier/OsBarrier.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a062ceb897c5cd9b7bd4d779bf5e17c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a062ceb897c5cd9b7bd4d779bf5e17c0b">&#9670;&nbsp;</a></span>FinalizeBarrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FinalizeBarrier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_barrier_type.html">BarrierType</a> *&#160;</td>
          <td class="paramname"><em>barrier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalizes a <code><a class="el" href="structnn_1_1os_1_1_barrier_type.html" title="This structure defines a barrier object.">BarrierType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">barrier</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_barrier_type.html" title="This structure defines a barrier object.">BarrierType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>barrier</em></code> is in a non-signaled state.</li>
<li>No threads are waiting for <code><em>barrier</em></code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>barrier</em></code> is in an uninitialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Finalizes a <code><a class="el" href="structnn_1_1os_1_1_barrier_type.html" title="This structure defines a barrier object.">BarrierType</a></code> object.</p>
<p>This function is not thread-safe. Do not manipulate the object specified in <code><em>barrier</em></code> while this function is being called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_barrier_2_os_barrier_8cpp-example.html#a17">OsBarrier/OsBarrier.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a41fc159f1fb100df1371bbaf63e1ba14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41fc159f1fb100df1371bbaf63e1ba14">&#9670;&nbsp;</a></span>AwaitBarrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::AwaitBarrier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_barrier_type.html">BarrierType</a> *&#160;</td>
          <td class="paramname"><em>barrier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for a <code><a class="el" href="structnn_1_1os_1_1_barrier_type.html" title="This structure defines a barrier object.">BarrierType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">barrier</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_barrier_type.html" title="This structure defines a barrier object.">BarrierType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>barrier</em></code> is in a non-signaled state.</li>
<li>The number of threads to wait for is in the range from <code>0</code> to (<code><em>numThreads</em></code>-1).</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>barrier</em></code> is in a non-signaled state.</li>
<li>The number of threads to wait for is <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Causes the current thread to wait for synchronization at the target barrier. There is no feature that makes it possible to wait for synchronization with polling or a time-out.</p>
<p>When this function has been called on the target barrier a number of times equal to the <code><em>numThreads</em></code> argument specified in <code><a class="el" href="namespacenn_1_1os.html#a063c2e1620b936cdc599de617a458516" title="Initializes a BarrierType object.">InitializeBarrier()</a></code>, all of the threads waiting for synchronization stop waiting. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_barrier_2_os_barrier_8cpp-example.html#a7">OsBarrier/OsBarrier.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae3c90ec0fd947f75d07e4411cbd4cfdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c90ec0fd947f75d07e4411cbd4cfdb">&#9670;&nbsp;</a></span>InitializeBusyMutex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeBusyMutex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_busy_mutex_type.html">BusyMutexType</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a <code><a class="el" href="structnn_1_1os_1_1_busy_mutex_type.html" title="The structure that define a busy mutex object.">BusyMutexType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>A pointer to the <code><a class="el" href="structnn_1_1os_1_1_busy_mutex_type.html" title="The structure that define a busy mutex object.">BusyMutexType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>mutex</em></code> is in an uninitialized state or has not been initialized.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>mutex</em></code> is in an unlocked state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Initializes a busy mutex object.</p>
<p>You can also initialize a busy mutex object using the <code><a class="el" href="os___busy_mutex_api_8h.html#a2e9788ba56f24f1b72656cc38bbe675a">NN_OS_BUSY_MUTEX_INITIALIZER()</a></code> macro, which statically initializes the object.</p>
<p>This function is not thread-safe. Do not manipulate the object specified in <code><em>mutex</em></code> while this function is being called. </p>

</div>
</div>
<a id="acbc5df299ac9ed31c86d87108101dca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbc5df299ac9ed31c86d87108101dca1">&#9670;&nbsp;</a></span>FinalizeBusyMutex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FinalizeBusyMutex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_busy_mutex_type.html">BusyMutexType</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a <code><a class="el" href="structnn_1_1os_1_1_busy_mutex_type.html" title="The structure that define a busy mutex object.">BusyMutexType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>A pointer to the <code><a class="el" href="structnn_1_1os_1_1_busy_mutex_type.html" title="The structure that define a busy mutex object.">BusyMutexType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>mutex</em></code> is in an unlocked state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>mutex</em></code> is in an uninitialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Destroys a <code><a class="el" href="structnn_1_1os_1_1_busy_mutex_type.html" title="The structure that define a busy mutex object.">BusyMutexType</a></code> object.</p>
<p>This function is not thread-safe. Do not manipulate the object specified in <code><em>mutex</em></code> while this function is being called. </p>

</div>
</div>
<a id="ad902011901e60f940cb26ffb62989688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad902011901e60f940cb26ffb62989688">&#9670;&nbsp;</a></span>LockBusyMutex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::LockBusyMutex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_busy_mutex_type.html">BusyMutexType</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locks a <code><a class="el" href="structnn_1_1os_1_1_busy_mutex_type.html" title="The structure that define a busy mutex object.">BusyMutexType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>A pointer to the <code><a class="el" href="structnn_1_1os_1_1_busy_mutex_type.html" title="The structure that define a busy mutex object.">BusyMutexType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>mutex</em></code> is unlocked or locked on another thread.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>mutex</em></code> is in a current thread locked state.</li>
<li>The thread that called this function is in the busy state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The call to this function puts the thread that called the function in the busy state. This busy thread does not migrate to another core and operates on the current CPU core with precedence over the other threads, including those with higher priority. <code><a class="el" href="namespacenn_1_1os.html#a44d95eddeda268be15a448814cfaf2c8" title="Unlocks a BusyMutexType object.">nn::os::UnlockBusyMutex</a></code> ends the busy state of the current thread if the <code><a class="el" href="structnn_1_1os_1_1_busy_mutex_type.html" title="The structure that define a busy mutex object.">nn::os::BusyMutexType</a></code> object locked by the thread no longer exists.</p>
<p>This function gets the lock for <code><em>mutex</em></code> after the thread that called this function enters the busy state. If <code><em>mutex</em></code> is locked on some other thread, the function keeps trying to get the lock in a busy loop until it is unlocked.</p>
<p>While this thread is busy, any other threads that are running on that same core will be blocked, including those threads that have higher priority. This function remains busy and continues to own the CPU so it can stay in the busy loop and continue to try to get the lock for <code><em>mutex</em></code> until it succeeds.</p>
<p>As a rule of thumb, do not use this function in places where a lock of longer than one microsecond is required. In those kinds of places, you must use <code><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="This structure defines a mutex object.">nn::os::MutexType</a></code>.</p>
<p>The following functions are the only ones that can be used while the thread is busy, and operation is not assured if any other NintendoSDK functions are called.</p>
<ul>
<li><code><a class="el" href="namespacenn_1_1os.html#ad902011901e60f940cb26ffb62989688" title="Locks a BusyMutexType object.">nn::os::LockBusyMutex()</a></code> (However, only when the calling thread is not locked.)</li>
<li><code><a class="el" href="namespacenn_1_1os.html#a13af259dc4589bac99195d45db41a1cb" title="Tries to lock a BusyMutexType object.">nn::os::TryLockBusyMutex()</a></code> (However, only when the calling thread is not locked.)</li>
<li><code><a class="el" href="namespacenn_1_1os.html#a44d95eddeda268be15a448814cfaf2c8" title="Unlocks a BusyMutexType object.">nn::os::UnlockBusyMutex()</a></code></li>
<li><code><a class="el" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542" title="Tests whether a condition is satisfied.">NN_ASSERT()</a></code> and other assertion functions.</li>
<li><code><a class="el" href="nn___abort_8h.html#a205eaac89c47d49cb982bf136e113de2" title="Stops execution.">NN_ABORT()</a></code> and other abort functions.</li>
</ul>
<div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
<ul>
<li>In the Windows environment, threads do not take the busy state.</li>
</ul>
</div><div class="platform_section" data-platform="Windows"></div> 
</div>
</div>
<a id="a13af259dc4589bac99195d45db41a1cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13af259dc4589bac99195d45db41a1cb">&#9670;&nbsp;</a></span>TryLockBusyMutex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TryLockBusyMutex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_busy_mutex_type.html">BusyMutexType</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to lock a <code><a class="el" href="structnn_1_1os_1_1_busy_mutex_type.html" title="The structure that define a busy mutex object.">BusyMutexType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>A pointer to the <code><a class="el" href="structnn_1_1os_1_1_busy_mutex_type.html" title="The structure that define a busy mutex object.">BusyMutexType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indicates whether the busy mutex was successfully obtained.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>mutex</em></code> is unlocked or locked on another thread.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the return value is <code>true</code>:<ul>
<li><code><em>mutex</em></code> is in a current thread locked state.</li>
<li>The thread that called this function is in the busy state.</li>
</ul>
</li>
<li>If the return value is <code>false</code>:<ul>
<li>The state of <code><em>mutex</em></code> does not change from that of the preconditions.</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Puts the thread that called this function in the busy state and tries to get the lock for <code><em>mutex</em></code>. If the lock could be obtained, returns <code>true</code> and keeps the thread in the busy state. If the lock could not be obtained, returns <code>false</code> and ends the busy state.</p>
<p>For more information about the busy state, see <code><a class="el" href="namespacenn_1_1os.html#ad902011901e60f940cb26ffb62989688" title="Locks a BusyMutexType object.">nn::os::LockBusyMutex()</a></code>.</p>
<div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
<ul>
<li>In the Windows environment, threads do not take the busy state.</li>
</ul>
</div><div class="platform_section" data-platform="Windows"></div> 
</div>
</div>
<a id="a44d95eddeda268be15a448814cfaf2c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d95eddeda268be15a448814cfaf2c8">&#9670;&nbsp;</a></span>UnlockBusyMutex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::UnlockBusyMutex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_busy_mutex_type.html">BusyMutexType</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlocks a <code><a class="el" href="structnn_1_1os_1_1_busy_mutex_type.html" title="The structure that define a busy mutex object.">BusyMutexType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>A pointer to the <code><a class="el" href="structnn_1_1os_1_1_busy_mutex_type.html" title="The structure that define a busy mutex object.">BusyMutexType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The <code><em>mutex</em></code> object is locked on the calling thread.</li>
<li>The thread that called this function is in the busy state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>mutex</em></code> is in an unlocked state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Unlocking <code><em>mutex</em></code> ends the busy state of the current thread if the <code><a class="el" href="structnn_1_1os_1_1_busy_mutex_type.html" title="The structure that define a busy mutex object.">nn::os::BusyMutexType</a></code> object locked by the thread no longer exists.</p>
<p>For more information about the busy state, see <code><a class="el" href="namespacenn_1_1os.html#ad902011901e60f940cb26ffb62989688" title="Locks a BusyMutexType object.">nn::os::LockBusyMutex()</a></code>.</p>
<div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
<ul>
<li>In the Windows environment, threads do not take the busy state.</li>
</ul>
</div><div class="platform_section" data-platform="Windows"></div> 
</div>
</div>
<a id="a0fc3b750c03200539a98c98f7acca022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc3b750c03200539a98c98f7acca022">&#9670;&nbsp;</a></span>FlushDataCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FlushDataCache </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the data stored in data cache to memory and then invalidates the pertinent cache line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Starting address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The specified memory region is a cache.</li>
<li>The specified memory region is readable or writable.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Writes the data stored in the specified memory region's data cache to memory and then invalidates the pertinent cache line.</p>
<p>If the specified memory region is not aligned to <code><a class="el" href="namespacenn_1_1os.html#a5c212d3f3bc25e8ce9502a178b3e02e3" title="The constant representing the cache line size, in bytes.">nn::os::CacheLineSize</a></code>, the target is the minimum region that is contained in that memory region and is aligned to <code><a class="el" href="namespacenn_1_1os.html#a5c212d3f3bc25e8ce9502a178b3e02e3" title="The constant representing the cache line size, in bytes.">nn::os::CacheLineSize</a></code>. </p>

</div>
</div>
<a id="a1ea1d7b36ec1844ed9e05729e832f6c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ea1d7b36ec1844ed9e05729e832f6c3">&#9670;&nbsp;</a></span>InitializeConditionVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeConditionVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_condition_variable_type.html">ConditionVariableType</a> *&#160;</td>
          <td class="paramname"><em>conditionVariable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a <code><a class="el" href="structnn_1_1os_1_1_condition_variable_type.html" title="This structure defines a condition variable object.">ConditionVariableType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conditionVariable</td><td>Pointer to a condition variable object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>conditionVariable</em></code> is in an uninitialized state or has not been initialized.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>conditionVariable</em></code> is in a non-signaled state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Initializes a condition variable object.</p>
<p>There is also an <a class="el" href="os___condition_variable_api_8h.html#aa662896cf5af9d678aadcc17399c55e1">NN_OS_CONDITION_VARIABLE_INITIALIZER()</a> macro to statically initialize a condition variable object.</p>
<p>This function is not thread-safe. Do not manipulate the object specified in <code><em>conditionVariable</em></code> while this function is being called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_condition_variable_2_os_condition_variable_8cpp-example.html#a12">OsConditionVariable/OsConditionVariable.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a817379cd29b11b49b185d0dc6afdc5c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817379cd29b11b49b185d0dc6afdc5c6">&#9670;&nbsp;</a></span>FinalizeConditionVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FinalizeConditionVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_condition_variable_type.html">ConditionVariableType</a> *&#160;</td>
          <td class="paramname"><em>conditionVariable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalizes a <code><a class="el" href="structnn_1_1os_1_1_condition_variable_type.html" title="This structure defines a condition variable object.">ConditionVariableType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conditionVariable</td><td>Pointer to a condition variable object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>conditionVariable</em></code> is in an initialized state.</li>
<li>No threads are waiting for <code><em>conditionVariable</em></code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>conditionVariable</em></code> is in an uninitialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Finalizes a condition variable object.</p>
<p>This function is not thread-safe. Do not manipulate the object specified in <code><em>conditionVariable</em></code> while this function is being called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_condition_variable_2_os_condition_variable_8cpp-example.html#a20">OsConditionVariable/OsConditionVariable.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae609d8150763b000d77f75d27fd44ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae609d8150763b000d77f75d27fd44ac2">&#9670;&nbsp;</a></span>SignalConditionVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SignalConditionVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_condition_variable_type.html">ConditionVariableType</a> *&#160;</td>
          <td class="paramname"><em>conditionVariable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signals a <code><a class="el" href="structnn_1_1os_1_1_condition_variable_type.html" title="This structure defines a condition variable object.">ConditionVariableType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conditionVariable</td><td>Pointer to a condition variable object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>conditionVariable</em></code> is in a non-signaled state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>conditionVariable</em></code> is in a non-signaled state.</li>
<li>Only one thread waiting for <code><em>conditionVariable</em></code> wakes up.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Signals the specified condition variable object and wakes one of the threads waiting on the condition variable.</p>
<p>After the thread wakes up, the condition variable is automatically restored to its non-signaled state. If there are no waiting threads, this function does nothing (the object remains in a non-signaled state).</p>
<p>It is safer to call this function with a lock on the same mutex that the thread waiting for the signal had locked. If the lock is not acquired, the condition variable could be signaled in the time between when the condition is evaluated and when the <code><a class="el" href="namespacenn_1_1os.html#a69a1e2e570d09ebd7cdbaa9da2d7b187" title="Unlocks a MutexType object and waits for a condition variable atomically.">WaitConditionVariable()</a></code> function puts the thread in a waiting state. In such cases, <code><a class="el" href="namespacenn_1_1os.html#a69a1e2e570d09ebd7cdbaa9da2d7b187" title="Unlocks a MutexType object and waits for a condition variable atomically.">WaitConditionVariable()</a></code> could end up waiting indefinitely. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_condition_variable_2_os_condition_variable_8cpp-example.html#a5">OsConditionVariable/OsConditionVariable.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1588e76fa05096006c0dcba27f9c95bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1588e76fa05096006c0dcba27f9c95bf">&#9670;&nbsp;</a></span>BroadcastConditionVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::BroadcastConditionVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_condition_variable_type.html">ConditionVariableType</a> *&#160;</td>
          <td class="paramname"><em>conditionVariable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcasts to a <code><a class="el" href="structnn_1_1os_1_1_condition_variable_type.html" title="This structure defines a condition variable object.">ConditionVariableType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conditionVariable</td><td>Pointer to a condition variable object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>conditionVariable</em></code> is in a non-signaled state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>conditionVariable</em></code> is in a non-signaled state.</li>
<li>All threads waiting for <code><em>conditionVariable</em></code> wake up.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Broadcasts to the specified condition variable object and wakes all of the threads waiting on that condition variable.</p>
<p>After the thread wakes up, the condition variable is automatically restored to its non-signaled state. If there are no waiting threads, this function does nothing (the object remains in a non-signaled state).</p>
<p>It is safer to call this function with a lock on the same mutex that the thread waiting for the signal had locked. If the lock is not acquired, the condition variable could be signaled in the time between when the condition is evaluated and when the <code><a class="el" href="namespacenn_1_1os.html#a69a1e2e570d09ebd7cdbaa9da2d7b187" title="Unlocks a MutexType object and waits for a condition variable atomically.">WaitConditionVariable()</a></code> function puts the thread in a waiting state. In such cases, <code><a class="el" href="namespacenn_1_1os.html#a69a1e2e570d09ebd7cdbaa9da2d7b187" title="Unlocks a MutexType object and waits for a condition variable atomically.">WaitConditionVariable()</a></code> could end up waiting indefinitely. </p>

</div>
</div>
<a id="a69a1e2e570d09ebd7cdbaa9da2d7b187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69a1e2e570d09ebd7cdbaa9da2d7b187">&#9670;&nbsp;</a></span>WaitConditionVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::WaitConditionVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_condition_variable_type.html">ConditionVariableType</a> *&#160;</td>
          <td class="paramname"><em>conditionVariable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *&#160;</td>
          <td class="paramname"><em>mutex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlocks a <code><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="This structure defines a mutex object.">MutexType</a></code> object and waits for a condition variable atomically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conditionVariable</td><td>Pointer to a condition variable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>Pointer to the target <code><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="This structure defines a mutex object.">MutexType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>conditionVariable</em></code> is in an initialized state.</li>
<li><code><em>mutex</em></code> has only been locked once.</li>
<li>The lock owner of the <code><em>mutex</em></code> is the current thread.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The same as the preconditions.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Unlocks the mutex that <code><em>mutex</em></code> points to, and atomically waits on the condition variable in <code><em>conditionVariable</em></code>. The target mutex must have been locked by the current thread only once at the time this function is called.</p>
<p>If the target mutex is unlocked or is locked by another thread, this function causes an assertion failure. In addition, this API stops execution if a recursive mutex is locked more than once.</p>
<p>While waiting on the condition variable, if the thread is signaled by the <code>SignalConditionVariable</code> or <code>BroadcastConditionVariable</code> function and stops waiting, it locks the target mutex again and returns control to the caller.</p>
<h3><a class="anchor" id="autotoc_md17"></a>
Important Information</h3>
<p>Problems with spurious wakeups can occur with the condition variable feature. Countermeasures against spurious wakeups are necessary when using this feature. For the spurious wakeup problem, see <a href="../../Package/contents/Pages/Page_83955531.html">Using a Condition Variable</a>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_condition_variable_2_os_condition_variable_8cpp-example.html#a4">OsConditionVariable/OsConditionVariable.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a2643c34ccfd738890fdd0c546b61c7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2643c34ccfd738890fdd0c546b61c7a8">&#9670;&nbsp;</a></span>TimedWaitConditionVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1os.html#ae1fe4fe10826c19cf2c66e534962180a">nn::os::ConditionVariableStatus</a> nn::os::TimedWaitConditionVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_condition_variable_type.html">ConditionVariableType</a> *&#160;</td>
          <td class="paramname"><em>conditionVariable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *&#160;</td>
          <td class="paramname"><em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlocks a <code><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="This structure defines a mutex object.">MutexType</a></code> object and waits for a condition variable atomically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conditionVariable</td><td>Pointer to a condition variable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>Pointer to the target <code><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="This structure defines a mutex object.">MutexType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Wait time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the reason why waiting for the condition variable has ended.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The <code><em>conditionVariable</em></code> object is in an initialized state.</li>
<li><code><em>mutex</em></code> has only been locked once.</li>
<li>The lock owner of the <code><em>mutex</em></code> is the current thread.</li>
<li><code><em>timeout</em></code> &gt;= <code>0</code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The same as the preconditions.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Unlocks the mutex that <code><em>mutex</em></code> points to, and atomically waits on the condition variable in <code><em>conditionVariable</em></code>. The target mutex must have been locked by the current thread only once at the time this function is called.</p>
<p>If the target mutex is unlocked or is locked by another thread, this function causes an assertion failure. In addition, this API stops execution if a recursive mutex is locked more than once.</p>
<p>While waiting on the condition variable, if the thread is signaled by the <code><a class="el" href="namespacenn_1_1os.html#ae609d8150763b000d77f75d27fd44ac2">SignalConditionVariable()</a></code> or <code><a class="el" href="namespacenn_1_1os.html#a1588e76fa05096006c0dcba27f9c95bf">BroadcastConditionVariable()</a></code> function and stops waiting, it locks the target mutex again and returns control to the caller.</p>
<p>If the amount of time specified by <code><em>timeout</em></code> elapses after the current thread starts waiting on the condition variable, a time-out occurs and the thread automatically stops waiting. Also in this case, the thread locks the mutex again and returns control to the caller.</p>
<p>For more information about time-out behavior, see <a class="el" href="_page_notification_os_timeout.html">OS-API Timeouts</a>.</p>
<p>You can determine whether this function returned due to a time-out by checking the return value. If the return value is <code><a class="el" href="namespacenn_1_1os.html#ae1fe4fe10826c19cf2c66e534962180aa4cad80372ca8b9c68ee8d1a34e806d24" title="Timed out.">nn::os::ConditionVariableStatus_Timeout</a></code>, a timeout occurred.</p>
<p>If the return value is <code><a class="el" href="namespacenn_1_1os.html#ae1fe4fe10826c19cf2c66e534962180aa2f5f309e61d650e34b30f0308c17818c" title="Woke up for some reason other than timed out.">nn::os::ConditionVariableStatus_NoTimeout</a></code>, on the other hand, either the function was signaled by a call to <code><a class="el" href="namespacenn_1_1os.html#ae609d8150763b000d77f75d27fd44ac2" title="Signals a ConditionVariableType object.">SignalConditionVariable()</a></code> or <code><a class="el" href="namespacenn_1_1os.html#a1588e76fa05096006c0dcba27f9c95bf" title="Broadcasts to a ConditionVariableType object.">BroadcastConditionVariable()</a></code> on another thread, or was woken by a spurious wakeup. Consequently, the caller must recheck the wait conditions.</p>
<p>In any case, if the target mutex is already locked by another thread when control returns to the caller, the function continues to attempt to lock the target mutex indefinitely, regardless of the timeout value. (In other words, the specified <code><em>timeout</em></code> is the timeout value of the condition variable, and not the timeout value of the mutex.</p>
<h3><a class="anchor" id="autotoc_md18"></a>
Important Information</h3>
<p>Problems with spurious wakeups can occur with the condition variable feature. Countermeasures against spurious wakeups are necessary when using this feature. For the spurious wakeup problem, see <a href="../../Package/contents/Pages/Page_83955531.html">Using a Condition Variable</a>. </p>

</div>
</div>
<a id="a036a9dca8974a28f03c6e8f3688efb12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036a9dca8974a28f03c6e8f3688efb12">&#9670;&nbsp;</a></span>GetCurrentStackInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::GetCurrentStackInfo </td>
          <td>(</td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>outStack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>outStackSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the stack data used in the current context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">outStack</td><td>Location storing the starting address of the stack that is currently in use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outStackSize</td><td>Location storing the size of the stack that is currently in use.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
 The starting address and the size of the stack region being used by the current context are stored in <code><em>outStack</em></code> and <code><em>outStackSize</em></code>. This information is not returned when <code>NULL</code> is specified for <code><em>outStack</em></code> or <code><em>outStackSize</em></code>.</p>
<p>The current context contains the following.</p>
<ul>
<li>Thread</li>
<li>Fibers</li>
<li>User exception handler</li>
</ul>
<p>When a current stack pointer does not point to a position in any of this stack space, the function treats the situation like a stack overflow and stops executing. </p>

</div>
</div>
<a id="a79f2a489da0a124ebdc8130595c70b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f2a489da0a124ebdc8130595c70b94">&#9670;&nbsp;</a></span>QueryMemoryInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::QueryMemoryInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_memory_info.html">MemoryInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets information including the amount of memory currently being used by this program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">info</td><td>Starting address of the structure storing the information.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
 Gets information including the amount of memory currently being used by this program from the <code><a class="el" href="structnn_1_1os_1_1_memory_info.html" title="The structure for storing the obtained memory information.">nn::os::MemoryInfo</a></code> structure. The member variables of the structure can be referenced directly. For more information about what is stored in each member variable, see the individual references.</p>
<p>The state of memory usage can change while information is being obtained by this function, so treat the values stored in <code><a class="el" href="structnn_1_1os_1_1_memory_info.html" title="The structure for storing the obtained memory information.">MemoryInfo</a></code> as yardsticks. We recommend using this function while other threads are inactive whenever possible.</p>
<p>Features like thread stacks that map one real memory region to multiple locations only count the size of the memory one time.</p>
<p>This function is not thread-safe. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_fs_file_data_cache_2_fs_global_file_data_cache_default_disabled_2_fs_global_file_data_cache_default_disabled_8cpp-example.html#a1">FsFileDataCache/FsGlobalFileDataCacheDefaultDisabled/FsGlobalFileDataCacheDefaultDisabled.cpp</a>, <a class="el" href="_fs_file_data_cache_2_fs_global_file_data_cache_manually_enabled_2_fs_global_file_data_cache_manually_enabled_8cpp-example.html#a1">FsFileDataCache/FsGlobalFileDataCacheManuallyEnabled/FsGlobalFileDataCacheManuallyEnabled.cpp</a>, <a class="el" href="_fs_file_data_cache_2_fs_individual_file_data_cache_2_fs_individual_file_data_cache_8cpp-example.html#a26">FsFileDataCache/FsIndividualFileDataCache/FsIndividualFileDataCache.cpp</a>, and <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_simple_framework_8cpp-example.html#a17">NvnSimple/NvnSimpleSharedLib/SimpleFramework.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a54cfc2e44df793d57fdd057a94578bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54cfc2e44df793d57fdd057a94578bf8">&#9670;&nbsp;</a></span>GetIdleTickCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1os_1_1_tick.html">Tick</a> nn::os::GetIdleTickCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the accumulated tick count during an idle segment on the local core. </p>
<dl class="section return"><dt>Returns</dt><dd>Accumulated tick count during an idle segment on the local core.</dd></dl>
<p> <b>Details</b> <br  />
 Gets the accumulated tick count during past idle segments on the core on which the original thread is running. An idle segment refers to time on the relevant core when a thread that should be running is not.</p>
<p>Call this API between two specific points and get the difference between their respective tick values. This can be used to calculate processor usage rates for the relevant segment.</p>
<p>This API can only get data for the core on which the current thread is running. To get the accumulated tick counts for idle segments on all cores that are available to the program, call this API on each core.</p>
<div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
<ul>
<li>This function is not supported in the Windows environment. It always returns an object equivalent to <code>Tick(0)</code>.</li>
</ul>
</div><div class="platform_section" data-platform="Windows"></div> 
</div>
</div>
<a id="a07456130a8d16c6f83beee9adae8dad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07456130a8d16c6f83beee9adae8dad2">&#9670;&nbsp;</a></span>GetFreeThreadCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::os::GetFreeThreadCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of threads that can be generated. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of threads that can be generated.</dd></dl>
<p> <b>Details</b> <br  />
 Gets the number of threads that can be newly generated by the <code><a class="el" href="namespacenn_1_1os.html#a75f43e1d3c194c0d2173ef5d95785933" title="Generates a thread.">nn::os::CreateThread()</a></code> function.</p>
<p>The value that can be obtained is subtracted by 1 each time <code><a class="el" href="namespacenn_1_1os.html#a75f43e1d3c194c0d2173ef5d95785933" title="Generates a thread.">nn::os::CreateThread()</a></code> is called and a thread is generated, and adds 1 each time <code><a class="el" href="namespacenn_1_1os.html#a9dbfcfb82583a9e34431e8c11d2411dd" title="Deletes a thread.">nn::os::DestroyThread()</a></code> is called to destroy a thread, enabling a new thread to be created.</p>
<div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
<ul>
<li>This function is not supported in the Windows environment. Always returns <code>0</code>.</li>
</ul>
</div><div class="platform_section" data-platform="Windows"></div> 
</div>
</div>
<a id="aa9f112844be928c69600e987eb45980f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f112844be928c69600e987eb45980f">&#9670;&nbsp;</a></span>DefaultUserExceptionHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::DefaultUserExceptionHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_user_exception_info.html">nn::os::UserExceptionInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default user exception handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">info</td><td>Information about the exception.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
 Standard user exception handler that is set when the program is started. It outputs the following information to the log when an exception occurs.</p>
<ul>
<li>The thread, or information about the fiber</li>
<li>List of registers</li>
<li>Stack trace</li>
<li>Stack dump</li>
<li>List of memory states</li>
</ul>
<p>This default user exception handler is registered with settings comparable to the following configuration.</p>
<p><a class="el" href="namespacenn_1_1os.html#a80a1e659aaba155ff9552f48604aec54" title="Sets the user exception handler.">nn::os::SetUserExceptionHandler</a>(<a class="el" href="namespacenn_1_1os.html#aa9f112844be928c69600e987eb45980f" title="Default user exception handler.">nn::os::DefaultUserExceptionHandler</a>, <a class="el" href="namespacenn_1_1os.html#ac0ca06939bae41f0ab89eda5be97d4fa" title="Constant that specifies a thread stack as a user exception handler stack.">nn::os::HandlerStackUsesThreadStack</a>, 0, <a class="el" href="namespacenn_1_1os.html#a74b6dc109705a61e232eb0087fbb8720" title="Constant that specifies an exception handler stack as a region storing exception information.">nn::os::UserExceptionInfoUsesHandlerStack</a>);</p>
<p>If you want to use you own user exception handler, overwrite the default version using <code><a class="el" href="namespacenn_1_1os.html#a80a1e659aaba155ff9552f48604aec54" title="Sets the user exception handler.">SetUserExceptionHandler()</a></code>. This API may be called from a proprietary user exception handler. </p>

</div>
</div>
<a id="a25125eea675c69bc6912e1140d4df148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25125eea675c69bc6912e1140d4df148">&#9670;&nbsp;</a></span>SetDyingMessageRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SetDyingMessageRegion </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a memory region for storing user-defined data (dying messages) to include in crash reports. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The starting address of the dying message region. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the dying message region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>address</em></code> is an integer multiple of <code><a class="el" href="namespacenn_1_1os.html#ac880b46610757e748d5bd79211af4236" title="This constant stores the minimum unit for memory operations.">nn::os::MemoryPageSize</a></code>.</li>
<li><code><em>size</em></code> &lt;= <code>4096</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The content of the memory region set using this function is stored in crash reports and sent to the server.</p>
<p>The specified memory region must be 4 KB or less.</p>
<p>This function does not need to be called each time you want to overwrite the content of the memory region. This function only has to be called once on application startup.</p>
<p>Make sure that no personal information is stored in the memory region set using this function. </p>

</div>
</div>
<a id="af07abef747ac6b51112b9e800ba9632c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07abef747ac6b51112b9e800ba9632c">&#9670;&nbsp;</a></span>InitializeEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initiallySignaled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452">EventClearMode</a>&#160;</td>
          <td class="paramname"><em>clearMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an <code><a class="el" href="structnn_1_1os_1_1_event_type.html" title="This structure defines an event object.">EventType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to an <code><a class="el" href="structnn_1_1os_1_1_event_type.html" title="This structure defines an event object.">EventType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initiallySignaled</td><td>Initial state of the event. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clearMode</td><td>Auto-clear mode of the event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>event</em></code> is in an uninitialized state or has not been initialized.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If <code><em>initiallySignaled</em></code> == <code>true</code>, <code><em>event</em></code> is in a signaled state.</li>
<li>If <code><em>initiallySignaled</em></code> == <code>false</code>, <code><em>event</em></code> is in a non-signaled state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Initializes an event object.</p>
<p>The initialized event object has two states, a signaled state and a non-signaled state. The state immediately after initialization is determined by <code>initiallySignaled</code>.</p>
<p>A signaled event object can be cleared by setting one of the following to <code>clearMode</code>.</p>
<ul>
<li><code><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a31f6133098296b3ddb7e14da3dc695cc" title="Automatically cleared event.">nn::os::EventClearMode_AutoClear</a></code>: Automatically cleared.</li>
<li><code><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a8b702480f5120eeeb01e7102227285da" title="Manually cleared event.">nn::os::EventClearMode_ManualClear</a></code>: Manually cleared.</li>
</ul>
<p>When <code><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a31f6133098296b3ddb7e14da3dc695cc" title="Automatically cleared event.">nn::os::EventClearMode_AutoClear</a></code> is specified, the event mode is cleared automatically. In this case, when <code><a class="el" href="namespacenn_1_1os.html#a9b959a51c1d28b76894597695fd3d081" title="Puts an EventType object in a signaled state.">SignalEvent()</a></code> is called, only one of the threads waiting with the <code><a class="el" href="namespacenn_1_1os.html#aabdcb2de0b5dbdd64a0ec3d7e65c72f4" title="Waits for an EventType object to enter a signaled state.">WaitEvent()</a></code> function stops waiting, and the event is cleared to a non-signaled state.</p>
<p>If no threads are waiting with the <code><a class="el" href="namespacenn_1_1os.html#aabdcb2de0b5dbdd64a0ec3d7e65c72f4" title="Waits for an EventType object to enter a signaled state.">WaitEvent()</a></code> function when <code><a class="el" href="namespacenn_1_1os.html#a9b959a51c1d28b76894597695fd3d081" title="Puts an EventType object in a signaled state.">SignalEvent()</a></code> is called, the event maintains its signaled state for the time being. Afterward, the first thread from which <code><a class="el" href="namespacenn_1_1os.html#aabdcb2de0b5dbdd64a0ec3d7e65c72f4" title="Waits for an EventType object to enter a signaled state.">WaitEvent()</a></code> is called immediately stops waiting and the event state is automatically cleared.</p>
<p>When <code><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a8b702480f5120eeeb01e7102227285da" title="Manually cleared event.">nn::os::EventClearMode_ManualClear</a></code> is specified, the event mode is cleared manually. All threads waiting with the <code><a class="el" href="namespacenn_1_1os.html#aabdcb2de0b5dbdd64a0ec3d7e65c72f4" title="Waits for an EventType object to enter a signaled state.">WaitEvent()</a></code> function wake up when <code><a class="el" href="namespacenn_1_1os.html#a9b959a51c1d28b76894597695fd3d081" title="Puts an EventType object in a signaled state.">SignalEvent()</a></code> is called, but the event remains in a signaled state until <code><a class="el" href="namespacenn_1_1os.html#a46abbb4e59711874cfec72fe97b58e36" title="Puts an EventType object in a cleared state.">ClearEvent()</a></code> is called.</p>
<p>This function is not thread-safe. Do not operate on the object specified in <code><em>event</em></code> while this function is being called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_demo1_2_demo1_8cpp-example.html#a12">Demo1/Demo1.cpp</a>, <a class="el" href="_g3d_demo_2_parallel_8cpp-example.html#a126">G3dDemo/Parallel.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_access_point_2_ldn_access_point_8cpp-example.html#a101">LdnBasic/LdnAccessPoint/LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_station_2_ldn_station_8cpp-example.html#a100">LdnBasic/LdnStation/LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a49">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_2_movie_player_simple_8cpp-example.html#a14">MoviePlayerSimple/MoviePlayerSimple.cpp</a>, <a class="el" href="_os_event_2_os_event_8cpp-example.html#a10">OsEvent/OsEvent.cpp</a>, <a class="el" href="_os_multi_wait_2_os_multi_wait_8cpp-example.html#a29">OsMultiWait/OsMultiWait.cpp</a>, <a class="el" href="_os_multi_wait_utility_2_os_multi_wait_utility_8cpp-example.html#a19">OsMultiWaitUtility/OsMultiWaitUtility.cpp</a>, <a class="el" href="_perf_simple_2_perf_simple_8cpp-example.html#a68">PerfSimple/PerfSimple.cpp</a>, and <a class="el" href="_socket_event_fd_2_socket_event_fd_8cpp-example.html#a5">SocketEventFd/SocketEventFd.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="adae3d14bd5e37dd1feee56bbf1717e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae3d14bd5e37dd1feee56bbf1717e37">&#9670;&nbsp;</a></span>FinalizeEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FinalizeEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalizes an <code><a class="el" href="structnn_1_1os_1_1_event_type.html" title="This structure defines an event object.">EventType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to an <code><a class="el" href="structnn_1_1os_1_1_event_type.html" title="This structure defines an event object.">EventType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>event</em></code> is in an initialized state.</li>
<li>No threads are waiting for <code><em>event</em></code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>event</em></code> is in an uninitialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Finalizes an event object.</p>
<p>This function is not thread-safe. Do not operate on the object specified in <code><em>event</em></code> while this function is being called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_parallel_8cpp-example.html#a141">G3dDemo/Parallel.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_access_point_2_ldn_access_point_8cpp-example.html#a106">LdnBasic/LdnAccessPoint/LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_station_2_ldn_station_8cpp-example.html#a104">LdnBasic/LdnStation/LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a55">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_2_movie_player_simple_8cpp-example.html#a19">MoviePlayerSimple/MoviePlayerSimple.cpp</a>, <a class="el" href="_os_event_2_os_event_8cpp-example.html#a18">OsEvent/OsEvent.cpp</a>, <a class="el" href="_os_multi_wait_2_os_multi_wait_8cpp-example.html#a39">OsMultiWait/OsMultiWait.cpp</a>, <a class="el" href="_os_multi_wait_utility_2_os_multi_wait_utility_8cpp-example.html#a29">OsMultiWaitUtility/OsMultiWaitUtility.cpp</a>, <a class="el" href="_perf_simple_2_perf_simple_8cpp-example.html#a70">PerfSimple/PerfSimple.cpp</a>, and <a class="el" href="_socket_event_fd_2_socket_event_fd_8cpp-example.html#a7">SocketEventFd/SocketEventFd.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a9b959a51c1d28b76894597695fd3d081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b959a51c1d28b76894597695fd3d081">&#9670;&nbsp;</a></span>SignalEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SignalEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts an <code><a class="el" href="structnn_1_1os_1_1_event_type.html" title="This structure defines an event object.">EventType</a></code> object in a signaled state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to an <code><a class="el" href="structnn_1_1os_1_1_event_type.html" title="This structure defines an event object.">EventType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>event</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>event</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sets an event's state to a signaled state.</p>
<p>The behavior after setting an event to a signaled state depends on the <code><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452" title="Enumerates the clear modes of an event.">nn::os::EventClearMode</a></code> of the event. For more information, see <code><a class="el" href="namespacenn_1_1os.html#af07abef747ac6b51112b9e800ba9632c" title="Initializes an EventType object.">InitializeEvent()</a></code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_parallel_8cpp-example.html#a11">G3dDemo/Parallel.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_access_point_2_ldn_access_point_8cpp-example.html#a23">LdnBasic/LdnAccessPoint/LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_station_2_ldn_station_8cpp-example.html#a23">LdnBasic/LdnStation/LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a102">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_os_event_2_os_event_8cpp-example.html#a7">OsEvent/OsEvent.cpp</a>, <a class="el" href="_os_multi_wait_2_os_multi_wait_8cpp-example.html#a25">OsMultiWait/OsMultiWait.cpp</a>, <a class="el" href="_os_multi_wait_utility_2_os_multi_wait_utility_8cpp-example.html#a15">OsMultiWaitUtility/OsMultiWaitUtility.cpp</a>, <a class="el" href="_perf_simple_2_perf_simple_8cpp-example.html#a116">PerfSimple/PerfSimple.cpp</a>, and <a class="el" href="_socket_event_fd_2_socket_event_fd_8cpp-example.html#a43">SocketEventFd/SocketEventFd.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aabdcb2de0b5dbdd64a0ec3d7e65c72f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabdcb2de0b5dbdd64a0ec3d7e65c72f4">&#9670;&nbsp;</a></span>WaitEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::WaitEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for an <code><a class="el" href="structnn_1_1os_1_1_event_type.html" title="This structure defines an event object.">EventType</a></code> object to enter a signaled state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to an <code><a class="el" href="structnn_1_1os_1_1_event_type.html" title="This structure defines an event object.">EventType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>event</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>event</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Waits for an event object to enter a signaled state. If the event is already in a signaled state, this function succeeds immediately. If the <code><em>event</em></code> object is set to <code><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a31f6133098296b3ddb7e14da3dc695cc" title="Automatically cleared event.">nn::os::EventClearMode_AutoClear</a></code>, the event is cleared to a non-signaled state as soon as a signaled state is detected. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_parallel_8cpp-example.html#a12">G3dDemo/Parallel.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_access_point_2_ldn_access_point_8cpp-example.html#a89">LdnBasic/LdnAccessPoint/LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_station_2_ldn_station_8cpp-example.html#a88">LdnBasic/LdnStation/LdnStation.cpp</a>, <a class="el" href="_os_event_2_os_event_8cpp-example.html#a4">OsEvent/OsEvent.cpp</a>, <a class="el" href="_perf_simple_2_perf_simple_8cpp-example.html#a111">PerfSimple/PerfSimple.cpp</a>, and <a class="el" href="_socket_event_fd_2_socket_event_fd_8cpp-example.html#a21">SocketEventFd/SocketEventFd.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a679439764fa7d9544094a0246ab6eebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679439764fa7d9544094a0246ab6eebb">&#9670;&nbsp;</a></span>TryWaitEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TryWaitEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Polls the signaled state of an <code><a class="el" href="structnn_1_1os_1_1_event_type.html" title="This structure defines an event object.">EventType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to an <code><a class="el" href="structnn_1_1os_1_1_event_type.html" title="This structure defines an event object.">EventType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether waiting for the event was successful.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>event</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>event</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Checks whether an event is in a signaled state. If the event is in a signaled state, the function returns <code>true</code>. If the <code><em>event</em></code> object is set to <code><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a31f6133098296b3ddb7e14da3dc695cc" title="Automatically cleared event.">nn::os::EventClearMode_AutoClear</a></code>, the event is cleared to a non-signaled state as soon as a signaled state is detected.</p>
<p>If the event is in a non-signaled state, the function immediately returns <code>false</code>. This function does not go into a waiting state. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ldn_basic_2_ldn_access_point_2_ldn_access_point_8cpp-example.html#a48">LdnBasic/LdnAccessPoint/LdnAccessPoint.cpp</a>, and <a class="el" href="_ldn_basic_2_ldn_station_2_ldn_station_8cpp-example.html#a41">LdnBasic/LdnStation/LdnStation.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a9fba39baba3e475cae08127a632cab07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fba39baba3e475cae08127a632cab07">&#9670;&nbsp;</a></span>TimedWaitEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TimedWaitEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for an <code><a class="el" href="structnn_1_1os_1_1_event_type.html" title="This structure defines an event object.">EventType</a></code> object to enter a signaled state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to an <code><a class="el" href="structnn_1_1os_1_1_event_type.html" title="This structure defines an event object.">EventType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Wait time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether waiting for the event was successful.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>event</em></code> is in an initialized state.</li>
<li><code><em>timeout</em></code> &gt;= <code>0</code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>event</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Waits for an <code><a class="el" href="structnn_1_1os_1_1_event_type.html" title="This structure defines an event object.">EventType</a></code> object to enter a signaled state, with a timeout. If the event is already in a signaled state, this function returns <code>true</code> immediately without waiting.</p>
<p>If the <code><em>event</em></code> object is set to <code><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a31f6133098296b3ddb7e14da3dc695cc" title="Automatically cleared event.">nn::os::EventClearMode_AutoClear</a></code>, the event is cleared to a non-signaled state as soon as a signaled state is detected.</p>
<p>If the amount of time specified by <code><em>timeout</em></code> elapses after the current thread starts waiting, a time-out occurs and the thread automatically stops waiting. In this case, the function returns <code>false</code>.</p>
<p>For more information about time-out behavior, see <a class="el" href="_page_notification_os_timeout.html">OS-API Timeouts</a>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ldn_basic_2_ldn_access_point_2_ldn_access_point_8cpp-example.html#a44">LdnBasic/LdnAccessPoint/LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_station_2_ldn_station_8cpp-example.html#a37">LdnBasic/LdnStation/LdnStation.cpp</a>, and <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a110">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a46abbb4e59711874cfec72fe97b58e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46abbb4e59711874cfec72fe97b58e36">&#9670;&nbsp;</a></span>ClearEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::ClearEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts an <code><a class="el" href="structnn_1_1os_1_1_event_type.html" title="This structure defines an event object.">EventType</a></code> object in a cleared state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to an <code><a class="el" href="structnn_1_1os_1_1_event_type.html" title="This structure defines an event object.">EventType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>event</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>event</em></code> is in a non-signaled state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Clears the event state to the nonsignaled state. The behavior of this function does not change based on the <code><em>clearMode</em></code> value for the target event.</p>
<p>Although this function is thread-safe, you must be cautious if this function will be issued at nearly the same time as the <code><a class="el" href="namespacenn_1_1os.html#a9b959a51c1d28b76894597695fd3d081" title="Puts an EventType object in a signaled state.">SignalEvent()</a></code> and <code><a class="el" href="namespacenn_1_1os.html#aabdcb2de0b5dbdd64a0ec3d7e65c72f4" title="Waits for an EventType object to enter a signaled state.">WaitEvent()</a></code> in another thread, because the order of these operations cannot be assured. For this reason, design your software so that the target <code><em>event</em></code> is not manipulated when using this function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a107">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_2_movie_player_simple_8cpp-example.html#a27">MoviePlayerSimple/MoviePlayerSimple.cpp</a>, <a class="el" href="_os_multi_wait_2_os_multi_wait_8cpp-example.html#a6">OsMultiWait/OsMultiWait.cpp</a>, and <a class="el" href="_os_multi_wait_utility_2_os_multi_wait_utility_8cpp-example.html#a6">OsMultiWaitUtility/OsMultiWaitUtility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a4f8d998425d067cb5fec2604ae7845dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8d998425d067cb5fec2604ae7845dc">&#9670;&nbsp;</a></span>InitializeMultiWaitHolder() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeMultiWaitHolder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *&#160;</td>
          <td class="paramname"><em>multiWaitHolder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a <code>multiWaitHolder</code> object and binds it to an event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWaitHolder</td><td>Pointer to a multiwait object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to the event to associate to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>multiWaitHolder</em></code> is in an uninitialized state.</li>
<li><code><em>event</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>multiWaitHolder</em></code> is in an initialized state (and bound to <code><em>event</em></code>).</li>
<li><code><a class="el" href="namespacenn_1_1os.html#a9e8c73312415fc00c72808fcc00fea33">nn::os::GetMultiWaitHolderUserData(multiWaitHolder)</a></code> == <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Initializes <code><em>multiWaitHolder</em></code> and binds it to the object specified in <code><em>event</em></code>.</p>
<p>The bound <code><em>multiWaitHolder</em></code> enters a signaled state when the target event is set. Also, if the target event is already set, the object enters a signaled state immediately.</p>
<p>Unlike a normal <code><a class="el" href="namespacenn_1_1os.html#aabdcb2de0b5dbdd64a0ec3d7e65c72f4" title="Waits for an EventType object to enter a signaled state.">WaitEvent()</a></code>, using a <code><em>multiWaitHolder</em></code> object initialized using this API and the target event signaled to wake the multiwait does not automatically clear the event to the nonsignaled state. For more information, see <a class="el" href="_page_notification_os_multi_wait.html#PageNotificationOsMultiWait_AboutWakeup">Waking a multiwait PageNotificationOsMultiWait_AboutWakeup</a>.</p>
<p>Do not operate on <code><em>multiWaitHolder</em></code> while this function is being called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a64">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_access_point_2_ldn_access_point_8cpp-example.html#a17">LdnBasic/LdnAccessPoint/LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_station_2_ldn_station_8cpp-example.html#a17">LdnBasic/LdnStation/LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a51">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_2_movie_player_simple_8cpp-example.html#a29">MoviePlayerSimple/MoviePlayerSimple.cpp</a>, and <a class="el" href="_os_multi_wait_2_os_multi_wait_8cpp-example.html#a12">OsMultiWait/OsMultiWait.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a9f0b5787e55da6b3b0e089d6b3ee6816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0b5787e55da6b3b0e089d6b3ee6816">&#9670;&nbsp;</a></span>InitializeFiber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeFiber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_fiber_type.html">FiberType</a> *&#160;</td>
          <td class="paramname"><em>fiber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1os.html#a00a0fffd9172c3779939c06927973bed">FiberFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>argument</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fiberFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a fiber object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fiber</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_fiber_type.html" title="This structure defines a fiber object.">FiberType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function entry for fiber. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argument</td><td>Arguments passed to the fiber. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stack</td><td>Starting address of the stack space for the fiber. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stackSize</td><td>Stack size of the fiber. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fiberFlag</td><td>Flags to associate with the fiber.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>fiber</em></code> is in the <code>NotInitialized</code> state or has not been initialized.</li>
<li>When <code><em>fiberFlag</em></code> includes <code><a class="el" href="namespacenn_1_1os.html#a39b515dc6753642a34364d91b5813104ac2bbce12f37e3e01eb6a244e2ada14c7" title="Do not set up stack guards.">nn::os::FiberFlag_NoStackGuard</a></code>:<ul>
<li><code><em>stack</em></code> is aligned on <code><a class="el" href="namespacenn_1_1os.html#ab8818e7de49601e4f83bd6d3ee822449" title="Constant indicating the alignment rules for the fiber stack space.">nn::os::FiberStackAlignment</a></code>.</li>
<li><code><em>stackSize</em></code> % <code><a class="el" href="namespacenn_1_1os.html#ab8818e7de49601e4f83bd6d3ee822449" title="Constant indicating the alignment rules for the fiber stack space.">nn::os::FiberStackAlignment</a></code> == <code>0</code>.</li>
<li><code><em>stackSize</em></code> &gt; <code>0</code>.</li>
</ul>
</li>
<li>When <code><em>fiberFlag</em></code> does not include <code><a class="el" href="namespacenn_1_1os.html#a39b515dc6753642a34364d91b5813104ac2bbce12f37e3e01eb6a244e2ada14c7" title="Do not set up stack guards.">nn::os::FiberFlag_NoStackGuard</a></code>:<ul>
<li><code><em>stack</em></code> is aligned on <code><a class="el" href="namespacenn_1_1os.html#a09b2d95cc4315e16021578c2ba43208d" title="Constant indicating the alignment rules for a guarded stack space.">nn::os::GuardedStackAlignment</a></code>.</li>
<li><code><em>stackSize</em></code> % <code><a class="el" href="namespacenn_1_1os.html#a09b2d95cc4315e16021578c2ba43208d" title="Constant indicating the alignment rules for a guarded stack space.">nn::os::GuardedStackAlignment</a></code> == <code>0</code>.</li>
<li><code><em>stackSize</em></code> &gt; <code>0</code>.</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>fiber</em></code> is in the <code>Ready</code> state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function initializes the fiber object specified in <code><em>fiber</em></code>.</p>
<p>A fiber is an execution thread for which the user must manually handle scheduling. Fibers run in a thread context and can be switched by explicitly calling <code><a class="el" href="namespacenn_1_1os.html#a3ba39dbca8b416903a5e2947927ed3e0" title="Starts or resumes execution of a fiber.">SwitchToFiber()</a></code>. A fiber is never automatically preempted by another fiber.</p>
<p>The <code><em>function</em></code> parameter takes the entry point of the fiber function, the <code><em>argument</em></code> parameter takes the arguments to pass to the fiber function, and the <code><em>stack</em></code> and <code><em>stackSize</em></code> parameters specify the stack space to be used by the fiber.</p>
<p>The <code><em>fiberFlag</em></code> parameter specifies the logical OR of enumerators defined by <code><a class="el" href="namespacenn_1_1os.html#a39b515dc6753642a34364d91b5813104" title="Enumerates the flags associated with fibers.">nn::os::FiberFlag</a></code>.</p>
<p>When <code><em>fiberFlag</em></code> does not include <code><a class="el" href="namespacenn_1_1os.html#a39b515dc6753642a34364d91b5813104ac2bbce12f37e3e01eb6a244e2ada14c7" title="Do not set up stack guards.">nn::os::FiberFlag_NoStackGuard</a></code>, a stack guard is prepared. In other words, the memory space specified by <code><em>stack</em></code> is mirrored in a different space, which is used as the stack space for that fiber after guard pages are set before and after the space.</p>
<p>When <code><em>fiberFlag</em></code> includes <code><a class="el" href="namespacenn_1_1os.html#a39b515dc6753642a34364d91b5813104ac2bbce12f37e3e01eb6a244e2ada14c7" title="Do not set up stack guards.">nn::os::FiberFlag_NoStackGuard</a></code>, a stack guard is not prepared. In other words, the space specified in <code><em>stack</em></code> is used as the stack space. Because no guard pages are set around the stack space, you must be careful about stack overflows.</p>
<p>To switch from the current thread to a fiber for the first time, call the <code><a class="el" href="namespacenn_1_1os.html#a3ba39dbca8b416903a5e2947927ed3e0" title="Starts or resumes execution of a fiber.">SwitchToFiber()</a></code> function. To return to the original thread from a different fiber, specify <code>NULL</code> as the fiber object (for example, <code>SwitchToFiber( NULL )</code>).</p>
<p>All fibers share the context of the current thread for properties associated with a thread, such as execution priority and <code><a class="el" href="classnn_1_1os_1_1_thread_local_storage.html" title="Class for handling thread-local storage.">nn::os::ThreadLocalStorage</a></code>. However, each fiber has its own stack space.</p>
<p>A fiber can be specified in <code><a class="el" href="namespacenn_1_1os.html#a3ba39dbca8b416903a5e2947927ed3e0" title="Starts or resumes execution of a fiber.">SwitchToFiber()</a></code> even if it was created from a different thread. The fiber cannot be specified, however, if it is already running on a different thread.</p>
<p>When returning from a fiber, specify the fiber to switch to as the return value. It must be <code>sockaddr_in</code>. To return to the original thread, specify a return value of <code>NULL</code>. Note that after returning from a fiber, you cannot switch back to it using <code><a class="el" href="namespacenn_1_1os.html#a3ba39dbca8b416903a5e2947927ed3e0" title="Starts or resumes execution of a fiber.">SwitchToFiber()</a></code>.</p>
<div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
<ul>
<li>The stack area used by fibers is not the one specified by <code><em>stack</em></code>, but rather an area allocated independently by Windows.</li>
<li>The <code><a class="el" href="namespacenn_1_1os.html#a39b515dc6753642a34364d91b5813104ac2bbce12f37e3e01eb6a244e2ada14c7" title="Do not set up stack guards.">nn::os::FiberFlag_NoStackGuard</a></code> flag specified in <code><em>fiberFlag</em></code> is ignored.</li>
</ul>
</div><div class="platform_section" data-platform="Windows"></div> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_fiber_2_os_fiber_8cpp-example.html#a9">OsFiber/OsFiber.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af54bbd489d9e733f72e8555d7ff940cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af54bbd489d9e733f72e8555d7ff940cf">&#9670;&nbsp;</a></span>FinalizeFiber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FinalizeFiber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_fiber_type.html">FiberType</a> *&#160;</td>
          <td class="paramname"><em>fiber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a fiber object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fiber</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_fiber_type.html" title="This structure defines a fiber object.">FiberType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>fiber</em></code> is in the <code>Ready</code> or <code>Completed</code> state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>fiber</em></code> is in the <code>NotInitialized</code> state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Destroys a fiber object. The function causes an assertion failure if the fiber is in the <code>Running</code> state. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_fiber_2_os_fiber_8cpp-example.html#a11">OsFiber/OsFiber.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3ba39dbca8b416903a5e2947927ed3e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba39dbca8b416903a5e2947927ed3e0">&#9670;&nbsp;</a></span>SwitchToFiber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SwitchToFiber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_fiber_type.html">FiberType</a> *&#160;</td>
          <td class="paramname"><em>fiber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts or resumes execution of a fiber. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fiber</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_fiber_type.html" title="This structure defines a fiber object.">FiberType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>fiber</em></code> is in the <code>Ready</code> state.</li>
<li><code><em>fiber</em></code> != <code><a class="el" href="namespacenn_1_1os.html#a5bacafa4afccd548bb410d0f2fb3762e" title="Gets a FiberType object for the current fiber.">GetCurrentFiber()</a></code></li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The fiber that was running before the call is in the <code>Ready</code> state.</li>
<li><code><em>fiber</em></code> is in the <code>Running</code> state.</li>
<li><code><em>fiber</em></code> == <code><a class="el" href="namespacenn_1_1os.html#a5bacafa4afccd548bb410d0f2fb3762e" title="Gets a FiberType object for the current fiber.">GetCurrentFiber()</a></code></li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function stops the currently running thread or fiber, and starts or resumes execution of the fiber specified in the <code><em>fiber</em></code> parameter.</p>
<p>If <code><em>fiber</em></code> is set to <code>NULL</code>, control returns to the thread where <code><a class="el" href="namespacenn_1_1os.html#a3ba39dbca8b416903a5e2947927ed3e0" title="Starts or resumes execution of a fiber.">SwitchToFiber()</a></code> was originally called. In addition, <code><em>fiber</em></code> cannot be set to the current fiber. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_fiber_2_os_fiber_8cpp-example.html#a8">OsFiber/OsFiber.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a5bacafa4afccd548bb410d0f2fb3762e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bacafa4afccd548bb410d0f2fb3762e">&#9670;&nbsp;</a></span>GetCurrentFiber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1os_1_1_fiber_type.html">FiberType</a>* nn::os::GetCurrentFiber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a <code><a class="el" href="structnn_1_1os_1_1_fiber_type.html" title="This structure defines a fiber object.">FiberType</a></code> object for the current fiber. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to a <code><a class="el" href="structnn_1_1os_1_1_fiber_type.html" title="This structure defines a fiber object.">FiberType</a></code> object.</dd></dl>
<p> <b>Details</b> <br  />
 This function returns a pointer to a <code><a class="el" href="structnn_1_1os_1_1_fiber_type.html" title="This structure defines a fiber object.">FiberType</a></code> object for the currently running fiber. If no fiber is currently running (in other words, a simple thread is running), this function returns <code>NULL</code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_fiber_2_os_fiber_8cpp-example.html#a7">OsFiber/OsFiber.cpp</a>, and <a class="el" href="_os_user_exception_handler_sample_8cpp-example.html#a18">OsUserExceptionHandlerSample.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a20238ce26424ba34876552fb2d53165a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20238ce26424ba34876552fb2d53165a">&#9670;&nbsp;</a></span>IsMemoryLocked() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::IsMemoryLocked </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the specified memory area is locked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The start address of the memory area to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the memory area to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>size</em></code> &gt; <code>0</code>.</li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> is the specified memory area is locked, or <code>false</code> otherwise.</dd></dl>
<p> <b>Details</b> <br  />
 If a certain memory space is already being used for another purpose, the system will lock that space so it is not inadvertently used in an overlapping fashion.</p>
<p>This function checks whether the specified memory area is locked as shown, and returns a Boolean value for the result.</p>
<p>This function cannot be used in the retail device.</p>
<div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
<ul>
<li>This function is not supported in the Windows environment. If the function is called, it will exit.</li>
</ul>
</div><div class="platform_section" data-platform="Windows"></div> 
</div>
</div>
<a id="ac2789b550619d98db2c52198839d35c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2789b550619d98db2c52198839d35c0">&#9670;&nbsp;</a></span>IsMemoryLocked() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::IsMemoryLocked </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the specified memory area is locked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The start address of the memory area to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the memory area to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>size</em></code> &gt; <code>0</code>.</li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the specified memory area is locked, or <code>false</code> otherwise.</dd></dl>
<p> <b>Details</b> <br  />
 This function works the same as <code><a class="el" href="namespacenn_1_1os.html#a20238ce26424ba34876552fb2d53165a">nn::os::IsMemoryLocked(void*, size_t)</a></code>.</p>
<div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
<ul>
<li>This function is not supported in the Windows environment. If the function is called, it will exit.</li>
</ul>
</div><div class="platform_section" data-platform="Windows"></div> 
</div>
</div>
<a id="a47e18c280ac1b7dacdd0a0ea0410517d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e18c280ac1b7dacdd0a0ea0410517d">&#9670;&nbsp;</a></span>GetThreadTickCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1os_1_1_tick.html">Tick</a> nn::os::GetThreadTickCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current thread's cumulative execution time. </p>
<dl class="section return"><dt>Returns</dt><dd>The cumulative tick count of the current thread in the executing state.</dd></dl>
<p> <b>Details</b> <br  />
 Gets the cumulative tick count of the current thread in the actual executing state.</p>
<p>Call this function between two specific points and get the difference between their respective tick values. This can be used to calculate the execution time of the thread during that segment.</p>
<p>This function cannot be used in the retail device.</p>
<div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
<ul>
<li>This function is not supported in the Windows environment. It always returns an object equivalent to <code>Tick(0)</code>.</li>
</ul>
</div><div class="platform_section" data-platform="Windows"></div> 
</div>
</div>
<a id="af5900620f2a25ffdd500d7fbcba5fe26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5900620f2a25ffdd500d7fbcba5fe26">&#9670;&nbsp;</a></span>InitializeLightEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeLightEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_event_type.html">LightEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initiallySignaled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452">EventClearMode</a>&#160;</td>
          <td class="paramname"><em>clearMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a <code><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="This structure defines a lightweight event object.">LightEventType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="This structure defines a lightweight event object.">LightEventType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initiallySignaled</td><td>The initial state of a lightweight event. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clearMode</td><td>The auto-clear mode for lightweight events.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>event</em></code> is in an uninitialized state or has not been initialized.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If <code><em>initiallySignaled</em></code> == <code>true</code>, <code><em>event</em></code> is in a signaled state.</li>
<li>If <code><em>initiallySignaled</em></code> == <code>false</code>, <code><em>event</em></code> is in a non-signaled state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Initializes a lightweight event object.</p>
<p>The initialized lightweight event object has two states, a signaled state and a non-signaled state. The initial state is specified using <code><em>initiallySignalled</em></code>.</p>
<p>Specify one of the following for <code><em>clearMode</em></code>, as a clearing method for lightweight event objects.</p>
<ul>
<li><code><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a31f6133098296b3ddb7e14da3dc695cc" title="Automatically cleared event.">nn::os::EventClearMode_AutoClear</a></code>: Automatically cleared.</li>
<li><code><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a8b702480f5120eeeb01e7102227285da" title="Manually cleared event.">nn::os::EventClearMode_ManualClear</a></code>: Manually cleared.</li>
</ul>
<p>Automatic clearing will automatically clear any thread that was set to a signaled state to a non-signaled state, when that thread wakes. As a result, only one thread wakes when set to a signaled state once, even if multiple threads are waiting.</p>
<p>For manually clearing, the signaled state is never cleared automatically. As a result, setting one flag wakes all the threads if multiple threads are waiting.</p>
<p>This function is not thread-safe. Do not operate on the object specified in <code><em>event</em></code> while this function is being called. </p>

</div>
</div>
<a id="a88b4a0191e818ad124b28b818349f072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88b4a0191e818ad124b28b818349f072">&#9670;&nbsp;</a></span>FinalizeLightEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FinalizeLightEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_event_type.html">LightEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalizes a <code><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="This structure defines a lightweight event object.">LightEventType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="This structure defines a lightweight event object.">LightEventType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>event</em></code> is in an uninitialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Finalize a lightweight event object.</p>
<p>This function is not thread-safe. Do not operate on the object specified in <code><em>event</em></code> while this function is being called. </p>

</div>
</div>
<a id="a07e40a45392d6eb98e2ca635bc0c3506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e40a45392d6eb98e2ca635bc0c3506">&#9670;&nbsp;</a></span>SignalLightEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SignalLightEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_event_type.html">LightEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <code><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="This structure defines a lightweight event object.">LightEventType</a></code> to a signaled state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="This structure defines a lightweight event object.">LightEventType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>event</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sets a lightweight event object to the signaled state. When there is a thread waiting for the target event, that thread will be awakened. When there are no waiting threads, the signaled state remains set.</p>
<p>For automatic clearing, only one thread is awakened, even if multiple threads are waiting. In addition to waking a waiting thread, that thread is cleared to a non-signaled state.</p>
<p>When manually clearing, all waiting threads are awakened. In this case, the signaled state remains set. </p>

</div>
</div>
<a id="a148036d27d59d8b674c3f1b7579aa5c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a148036d27d59d8b674c3f1b7579aa5c9">&#9670;&nbsp;</a></span>WaitLightEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::WaitLightEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_event_type.html">LightEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for an <code><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="This structure defines a lightweight event object.">LightEventType</a></code> object to enter a signaled state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="This structure defines a lightweight event object.">LightEventType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>event</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Waits for a lightweight event object to enter a signaled state. If the lightweight event is already in a signaled state, this API succeeds immediately.</p>
<p>For automatic clearing, a lightweight event is cleared to a non-signaled state at the same time a signaled state is detected. For manually clearing, the signaled state is never cleared automatically. </p>

</div>
</div>
<a id="ae1d2d9367d6312b284cd9e205a69adab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1d2d9367d6312b284cd9e205a69adab">&#9670;&nbsp;</a></span>TryWaitLightEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TryWaitLightEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_event_type.html">LightEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Polls the signaled state of a <code><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="This structure defines a lightweight event object.">LightEventType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="This structure defines a lightweight event object.">LightEventType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indicates whether polling of the lightweight event was successful.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>event</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Polls whether a lightweight event object is in a signaled state. If the lightweight event is in a signaled state, the function returns <code>true</code>. Otherwise returns <code>false</code>. This function does not go into a waiting state.</p>
<p>For automatic clearing, a lightweight event is cleared to a non-signaled state at the same time a signaled state is detected. For manually clearing, the signaled state is never cleared automatically. </p>

</div>
</div>
<a id="a6aeea3ec3d35c57cd757b4a3d2ff7273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aeea3ec3d35c57cd757b4a3d2ff7273">&#9670;&nbsp;</a></span>TimedWaitLightEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TimedWaitLightEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_event_type.html">LightEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for a <code><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="This structure defines a lightweight event object.">LightEventType</a></code> object to enter a signaled state, with a timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="This structure defines a lightweight event object.">LightEventType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Wait time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether waiting for the event was successful.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>event</em></code> is in an initialized state.</li>
<li><code><em>timeout</em></code> &gt;= <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Waits for a lightweight event object to be set to a signaled state, with a timeout. If the event is in a signaled state, the function returns <code>true</code>. Returns <code>false</code> when the timeout was reached without detecting a signaled state.</p>
<p>When the lightweight event automatic clearing mode is set to automatic clearing, the lightweight event is cleared to a non-signaled state when the signaled state is detected. For manually clearing, the signaled state is never cleared automatically.</p>
<p>For more information about time-out behavior, see the important information in <code><a class="el" href="_page_notification_os_timeout.html">OS-API Timeouts</a></code>. </p>

</div>
</div>
<a id="ab236036e46ae861732a4c6418b63ec01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab236036e46ae861732a4c6418b63ec01">&#9670;&nbsp;</a></span>ClearLightEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::ClearLightEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_event_type.html">LightEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts a <code><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="This structure defines a lightweight event object.">LightEventType</a></code> object in a cleared state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="This structure defines a lightweight event object.">LightEventType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>event</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Clears a lightweight event object to a non-signaled state. </p>

</div>
</div>
<a id="a3b9261137505f66b2d185aafeed5c9dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9261137505f66b2d185aafeed5c9dc">&#9670;&nbsp;</a></span>InitializeLightMessageQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeLightMessageQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html">LightMessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a light message queue object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html" title="This structure defines a light message queue object.">LightMessageQueueType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Starting address of the light message queue buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Maximum number of data items that can be stored in the light message queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an uninitialized state or has not been initialized.</li>
<li><code><em>buffer</em></code> points to a memory region of <code><em>count</em></code> * <code>sizeof</code>(<code>uintptr_t</code>) bytes.</li>
<li><code><em>count</em></code> &gt;= <code>1</code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an initialized (empty) state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Initializes a <code><a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html" title="This structure defines a light message queue object.">LightMessageQueueType</a></code> object. In other words, it initializes the object to a state without any accumulated message data, threads waiting to send messages, or threads waiting to receive messages.</p>
<p>Pass the <code>uintptr_t</code> type array to the light message queue buffer region. A memory area of <code><em>count</em></code> * <code><em>sizeof</em>(uintptr_t)</code> must be allocated.</p>
<p>This function is not thread-safe. Do not manipulate the object specified in <code><em>messageQueue</em></code> while this function is being called. </p>

</div>
</div>
<a id="a6bf0c1a8c8136bc6a3aedf792009f1a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf0c1a8c8136bc6a3aedf792009f1a4">&#9670;&nbsp;</a></span>FinalizeLightMessageQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FinalizeLightMessageQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html">LightMessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalizes a light message queue object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html" title="This structure defines a light message queue object.">LightMessageQueueType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an initialized state.</li>
<li>No threads are waiting for <code><em>messageQueue</em></code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an uninitialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Finalizes a <code><a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html" title="This structure defines a light message queue object.">LightMessageQueueType</a></code> object. Finalize can be performed even if there is data remaining in the light message queue.</p>
<p>After finalization, the memory area used for the light message queue buffer can be reused for another purpose.</p>
<p>This function is not thread-safe. Do not manipulate the object specified in <code><em>messageQueue</em></code> while this function is being called. </p>

</div>
</div>
<a id="a2ec37a4b03c00777cb0840d4f5becf0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec37a4b03c00777cb0840d4f5becf0e">&#9670;&nbsp;</a></span>SendLightMessageQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SendLightMessageQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html">LightMessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends one piece of data to the back of the light message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html" title="This structure defines a light message queue object.">LightMessageQueueType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in a <code>NotEmpty</code> state.</li>
<li><code><em>data</em></code> is added to the end of the <code><em>messageQueue</em></code> data array.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sends one piece of data to the back of the light message queue. If there is space in the light message queue, the function sends the data and then immediately returns.</p>
<p>If there is no space in the light message queue, the current thread waits to send. When the thread stops waiting, the function sends the data and then returns. </p>

</div>
</div>
<a id="a78f71a4b08b8492646bad8aed17d296b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f71a4b08b8492646bad8aed17d296b">&#9670;&nbsp;</a></span>TrySendLightMessageQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TrySendLightMessageQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html">LightMessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends one piece of data to the back of the light message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html" title="This structure defines a light message queue object.">LightMessageQueueType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether sending to the light message queue was successful.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the return value is <code>true</code>:<ul>
<li><code><em>messageQueue</em></code> is in a <code>NotEmpty</code> state.</li>
<li><code><em>data</em></code> is added to the end of the <code><em>messageQueue</em></code> data array.</li>
</ul>
</li>
<li>If the return value is <code>false</code>:<ul>
<li><code><em>messageQueue</em></code> is in an initialized state (the state does not change).</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sends one piece of data to the back of the light message queue. If there is space in the light message queue, the function sends the data and then returns <code>true</code>. If there is no space in the light message queue, the function returns <code>false</code> without going into a waiting state. </p>

</div>
</div>
<a id="a431668e7d0b3605da365a406becace2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431668e7d0b3605da365a406becace2b">&#9670;&nbsp;</a></span>TimedSendLightMessageQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TimedSendLightMessageQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html">LightMessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends one piece of data to the back of the light message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html" title="This structure defines a light message queue object.">LightMessageQueueType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Wait time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether sending to the light message queue was successful.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an initialized state.</li>
<li><code><em>timeout</em></code> &gt;= <code>0</code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the return value is <code>true</code>:<ul>
<li><code><em>messageQueue</em></code> is in a <code>NotEmpty</code> state.</li>
<li><code><em>data</em></code> is added to the end of the <code><em>messageQueue</em></code> data array.</li>
</ul>
</li>
<li>If the return value is <code>false</code>:<ul>
<li><code><em>messageQueue</em></code> is in an initialized state (the state does not change).</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sends one piece of data to the back of the light message queue. If there is space in the light message queue, the function sends the data and then returns <code>true</code>.</p>
<p>If there is no space in the light message queue, the current thread waits to send. When space becomes available in the light message queue, the thread stops waiting, sends the data, and then returns. In this case, the return value is <code>true</code>.</p>
<p>If the amount of time specified by <code><em>timeout</em></code> elapses after the current thread starts waiting, a timeout occurs and the thread automatically stops waiting and returns. In this case, the function returns <code>false</code> without sending any data.</p>
<p>For more information about time-out behavior, see <a class="el" href="_page_notification_os_timeout.html">OS-API Timeouts</a>. </p>

</div>
</div>
<a id="ae544b7a419a19f766d0d5fc22dbb89a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae544b7a419a19f766d0d5fc22dbb89a9">&#9670;&nbsp;</a></span>JamLightMessageQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::JamLightMessageQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html">LightMessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends one piece of data to the front of the light message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html" title="This structure defines a light message queue object.">LightMessageQueueType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an initialized state. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in a <code>NotEmpty</code> state.</li>
<li><code><em>data</em></code> is added to the beginning of the <code><em>messageQueue</em></code>data array.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sends one piece of data to the front of the light message queue. If there is space in the light message queue, the function sends the data and then immediately returns.</p>
<p>If there is no space in the light message queue, the current thread waits to send. When the thread stops waiting, the function sends the data and then returns. </p>

</div>
</div>
<a id="a3715853cab09866f3a6ee79e7988a145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3715853cab09866f3a6ee79e7988a145">&#9670;&nbsp;</a></span>TryJamLightMessageQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TryJamLightMessageQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html">LightMessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends one piece of data to the front of the light message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html" title="This structure defines a light message queue object.">LightMessageQueueType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether sending to the light message queue was successful.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the return value is <code>true</code>:<ul>
<li><code><em>messageQueue</em></code> is in a <code>NotEmpty</code> state.</li>
<li><code><em>data</em></code> is added to the beginning of the <code><em>messageQueue</em></code>data array.</li>
</ul>
</li>
<li>If the return value is <code>false</code>:<ul>
<li><code><em>messageQueue</em></code> is in an initialized state (the state does not change).</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sends one piece of data to the front of the light message queue. If there is space in the light message queue, the function sends the data and then returns <code>true</code>. If there is no space in the light message queue, the function returns <code>false</code> without going into a waiting state. </p>

</div>
</div>
<a id="ac75336eea6700c67ec9a53fb3214e71b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75336eea6700c67ec9a53fb3214e71b">&#9670;&nbsp;</a></span>TimedJamLightMessageQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TimedJamLightMessageQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html">LightMessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends one piece of data to the front of the light message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html" title="This structure defines a light message queue object.">LightMessageQueueType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Wait time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether sending to the light message queue was successful.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an initialized state.</li>
<li><code><em>timeout</em></code> &gt;= <code>0</code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the return value is <code>true</code>:<ul>
<li><code><em>messageQueue</em></code> is in a <code>NotEmpty</code> state.</li>
<li><code><em>data</em></code> is added to the beginning of the <code><em>messageQueue</em></code>data array.</li>
</ul>
</li>
<li>If the return value is <code>false</code>:<ul>
<li><code><em>messageQueue</em></code> is in an initialized state (the state does not change).</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sends one piece of data to the front of the light message queue. If there is space in the light message queue, the function sends the data and then returns <code>true</code>.</p>
<p>If there is no space in the light message queue, the current thread waits to send. When space becomes available in the light message queue, the thread stops waiting, sends the data, and then returns. In this case, the return value is <code>true</code>.</p>
<p>If the amount of time specified by <code><em>timeout</em></code> elapses after the current thread starts waiting, a timeout occurs and the thread automatically stops waiting. In this case, the function returns <code>false</code> without sending any data.</p>
<p>For more information about time-out behavior, see <a class="el" href="_page_notification_os_timeout.html">OS-API Timeouts</a>. </p>

</div>
</div>
<a id="a20eb39483646e5dd69388d01985e0307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20eb39483646e5dd69388d01985e0307">&#9670;&nbsp;</a></span>ReceiveLightMessageQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::ReceiveLightMessageQueue </td>
          <td>(</td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>outData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html">LightMessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives one piece of data from the front of the light message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outData</td><td>Location for storing the received data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html" title="This structure defines a light message queue object.">LightMessageQueueType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in a <code>NotFull</code> state.</li>
<li>The data at the beginning of the <code><em>messageQueue</em></code> data array is retrieved and stored in <code><em>outData</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Receives one piece of data from the front of the light message queue. If there is any data in the light message queue, the data is extracted and stored in the area specified by <code><em>outData</em></code>. If there is no data in the light message queue, the current thread waits to receive. </p>

</div>
</div>
<a id="a4faba929a7270dce159e1e8b0e52477a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4faba929a7270dce159e1e8b0e52477a">&#9670;&nbsp;</a></span>TryReceiveLightMessageQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TryReceiveLightMessageQueue </td>
          <td>(</td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>outData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html">LightMessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives one piece of data from the front of the light message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outData</td><td>Location for storing the received data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html" title="This structure defines a light message queue object.">LightMessageQueueType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indicates whether data was successfully received from the light message queue.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the return value is <code>true</code>:<ul>
<li><code><em>messageQueue</em></code> is in a <code>NotFull</code> state.</li>
<li>The data at the beginning of the <code><em>messageQueue</em></code> data array is retrieved and stored in <code><em>outData</em></code>.</li>
</ul>
</li>
<li>If the return value is <code>false</code>:<ul>
<li><code><em>messageQueue</em></code> is in an initialized state (the state does not change).</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Receives one piece of data from the front of the light message queue. If there is any data in the light message queue, the data is extracted and stored in the area specified by <code><em>outData</em></code>, and the function returns <code>true</code>. If there is no data in the light message queue, the current thread returns <code>false</code> without going into a waiting state. </p>

</div>
</div>
<a id="a0e96e17480064f66c6aff10c3ef989b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e96e17480064f66c6aff10c3ef989b6">&#9670;&nbsp;</a></span>TimedReceiveLightMessageQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TimedReceiveLightMessageQueue </td>
          <td>(</td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>outData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html">LightMessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives one piece of data from the front of the light message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outData</td><td>Location for storing the received data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html" title="This structure defines a light message queue object.">LightMessageQueueType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Wait time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indicates whether data was successfully received from the light message queue.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an initialized state.</li>
<li><code><em>timeout</em></code> &gt;= <code>0</code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the return value is <code>true</code>:<ul>
<li><code><em>messageQueue</em></code> is in a <code>NotFull</code> state.</li>
<li>The data at the beginning of the <code><em>messageQueue</em></code> data array is retrieved and stored in <code><em>outData</em></code>.</li>
</ul>
</li>
<li>If the return value is <code>false</code>:<ul>
<li><code><em>messageQueue</em></code> is in an initialized state (the state does not change).</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Receives one piece of data from the front of the light message queue. If there is any data in the light message queue, the data is extracted and stored in the area specified by <code><em>outData</em></code>, and the function returns <code>true</code>. If there is no data in the light message queue, the current thread waits to receive.</p>
<p>If the amount of time specified by <code><em>timeout</em></code> elapses after the current thread starts waiting, a timeout occurs and the thread automatically stops waiting. In this case, the function returns <code>false</code> without receiving any data.</p>
<p>For more information about time-out behavior, see <a class="el" href="_page_notification_os_timeout.html">OS-API Timeouts</a>. </p>

</div>
</div>
<a id="a1d34d548b81497f306cd26ebff16ab54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d34d548b81497f306cd26ebff16ab54">&#9670;&nbsp;</a></span>PeekLightMessageQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::PeekLightMessageQueue </td>
          <td>(</td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>outData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html">LightMessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the first data item in a light message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outData</td><td>Location for storing the looked-up data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html" title="This structure defines a light message queue object.">LightMessageQueueType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an initialized state (the state does not change).</li>
<li>The data at the beginning of the <code><em>messageQueue</em></code> data array is read and stored in <code><em>outData</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Reads the data at the beginning of the light message queue and stores it in the area specified by <code><em>outData</em></code>. The data is never actually extracted and the state of the light message queue does not change.</p>
<p>If there is any data in the light message queue, the function reads the data and then immediately returns. If there is no data in the light message queue, the current thread waits to receive. </p>

</div>
</div>
<a id="a60ecfcd68491819e5ede0dcae313cace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ecfcd68491819e5ede0dcae313cace">&#9670;&nbsp;</a></span>TryPeekLightMessageQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TryPeekLightMessageQueue </td>
          <td>(</td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>outData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html">LightMessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the first data item in a light message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outData</td><td>Location for storing the looked-up data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html" title="This structure defines a light message queue object.">LightMessageQueueType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indicates whether data was successfully referenced from the light message queue.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an initialized state. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the return value is <code>true</code>:<ul>
<li><code><em>messageQueue</em></code> is in an initialized state (the state does not change).</li>
<li>The data at the beginning of the <code><em>messageQueue</em></code> data array is read and stored in <code><em>outData</em></code>.</li>
</ul>
</li>
<li>If the return value is <code>false</code>:<ul>
<li><code><em>messageQueue</em></code> is in an initialized state (the state does not change).</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Reads the data at the beginning of the light message queue and stores it in the area specified by <code><em>outData</em></code>. The data is never actually extracted and the state of the light message queue does not change.</p>
<p>If there is any data in the light message queue, the function reads the data and then returns <code>true</code>. If there is no data in the message queue, the function returns <code>false</code> without going into a waiting state. </p>

</div>
</div>
<a id="a0346a384e4e057f6162bad8da416ba98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0346a384e4e057f6162bad8da416ba98">&#9670;&nbsp;</a></span>TimedPeekLightMessageQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TimedPeekLightMessageQueue </td>
          <td>(</td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>outData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html">LightMessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the first data item in a light message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outData</td><td>Location for storing the looked-up data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_light_message_queue_type.html" title="This structure defines a light message queue object.">LightMessageQueueType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Wait time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indicates whether data was successfully referenced from the light message queue.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an initialized state.</li>
<li><code><em>timeout</em></code> &gt;= <code>0</code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the return value is <code>true</code>:<ul>
<li><code><em>messageQueue</em></code> is in an initialized state (the state does not change).</li>
<li>The data at the beginning of the <code><em>messageQueue</em></code> data array is read and stored in <code><em>outData</em></code>.</li>
</ul>
</li>
<li>If the return value is <code>false</code>:<ul>
<li><code><em>messageQueue</em></code> is in an initialized state (the state does not change).</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Reads the data at the beginning of the light message queue and stores it in the area specified by <code><em>outData</em></code>. The data is never actually extracted and the state of the light message queue does not change.</p>
<p>If there is any data in the light message queue, the function reads the data and then returns <code>true</code>. If there is no data in the light message queue, the current thread waits to receive.</p>
<p>If the amount of time specified by <code><em>timeout</em></code> elapses after the current thread starts waiting, a timeout occurs and the thread automatically stops waiting. In this case, the function returns <code>false</code> without getting any data.</p>
<p>For more information about time-out behavior, see <a class="el" href="_page_notification_os_timeout.html">OS-API Timeouts</a>. </p>

</div>
</div>
<a id="a5ab8dff3311a08d0718855bff6d2c297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab8dff3311a08d0718855bff6d2c297">&#9670;&nbsp;</a></span>InitializeLightSemaphore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeLightSemaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html">LightSemaphoreType</a> *&#160;</td>
          <td class="paramname"><em>semaphore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>initialCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a <code><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html" title="This structure defines a light semaphore object.">LightSemaphoreType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">semaphore</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html" title="This structure defines a light semaphore object.">LightSemaphoreType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initialCount</td><td>Initial value of the light semaphore counter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxCount</td><td>Maximum value of the light semaphore counter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>semaphore</em></code> is in an uninitialized state or has not been initialized.</li>
<li><code><em>maxCount</em></code> &gt;= <code>1</code>.</li>
<li><code>0</code> &lt;= <code><em>initialCount</em></code> &lt;= <code><em>maxCount</em></code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>semaphore</em></code> is in an initialized state.<ul>
<li>If <code><em>initialCount</em></code> == <code>0</code>, the object is in a non-signaled state.</li>
<li>If <code><em>initialCount</em></code> &gt;= <code>1</code>, the object is in a signaled state.</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Initializes a <code><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html" title="This structure defines a light semaphore object.">LightSemaphoreType</a></code> object.</p>
<p>This function is not thread-safe. Do not manipulate the object specified in <code>semaphore</code> while this function is being called. </p>

</div>
</div>
<a id="a45176bf824434fe4269db3e4d9532701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45176bf824434fe4269db3e4d9532701">&#9670;&nbsp;</a></span>FinalizeLightSemaphore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FinalizeLightSemaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html">LightSemaphoreType</a> *&#160;</td>
          <td class="paramname"><em>semaphore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalizes a <code><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html" title="This structure defines a light semaphore object.">LightSemaphoreType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">semaphore</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html" title="This structure defines a light semaphore object.">LightSemaphoreType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>semaphore</em></code> is in an initialized state.</li>
<li>No threads are waiting for <code><em>semaphore</em></code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>semaphore</em></code> is in an uninitialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Finalizes a <code><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html" title="This structure defines a light semaphore object.">LightSemaphoreType</a></code> object.</p>
<p>This function is not thread-safe. Do not manipulate the object specified in <code>semaphore</code> while this function is being called. </p>

</div>
</div>
<a id="a14ae7374f92f8bb82cd77dce0354d5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ae7374f92f8bb82cd77dce0354d5d5">&#9670;&nbsp;</a></span>AcquireLightSemaphore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::AcquireLightSemaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html">LightSemaphoreType</a> *&#160;</td>
          <td class="paramname"><em>semaphore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a <code><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html" title="This structure defines a light semaphore object.">LightSemaphoreType</a></code> object (P operation). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">semaphore</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html" title="This structure defines a light semaphore object.">LightSemaphoreType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>semaphore</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>semaphore</em></code> is in an initialized state.</li>
<li>The light semaphore counter is decremented.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets one count from the specified light semaphore (P operation). If the count for the target light semaphore is already 0, the current thread waits for another thread to return a light semaphore. </p>

</div>
</div>
<a id="a91955b6e49515c4f50e2d2778d442c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91955b6e49515c4f50e2d2778d442c1b">&#9670;&nbsp;</a></span>TryAcquireLightSemaphore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TryAcquireLightSemaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html">LightSemaphoreType</a> *&#160;</td>
          <td class="paramname"><em>semaphore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to get a <code><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html" title="This structure defines a light semaphore object.">LightSemaphoreType</a></code> object (P operation). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">semaphore</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html" title="This structure defines a light semaphore object.">LightSemaphoreType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the light semaphore was successfully acquired.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>semaphore</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the return value is <code>true</code>:<ul>
<li><code><em>semaphore</em></code> is in an initialized state.</li>
<li>The light semaphore counter is decremented.</li>
</ul>
</li>
<li>If the return value is <code>false</code>:<ul>
<li><code><em>semaphore</em></code> is in a non-signaled state.</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets one count from the specified light semaphore (P operation). Returns <code>true</code> if successfully acquired. If the count for the target semaphore is already 0, the current thread does not wait and the function returns <code>false</code>. </p>

</div>
</div>
<a id="abcdacde38f33f90323d5595c5ec2b180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcdacde38f33f90323d5595c5ec2b180">&#9670;&nbsp;</a></span>TimedAcquireLightSemaphore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TimedAcquireLightSemaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html">LightSemaphoreType</a> *&#160;</td>
          <td class="paramname"><em>semaphore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to get a <code><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html" title="This structure defines a light semaphore object.">LightSemaphoreType</a></code> object with a timeout (P operation). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">semaphore</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html" title="This structure defines a light semaphore object.">LightSemaphoreType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Timeout when waiting for the light semaphore.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the light semaphore was successfully acquired.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>semaphore</em></code> is in an initialized state.</li>
<li><code><em>timeout</em></code> &gt;= <code>0</code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the return value is <code>true</code>:<ul>
<li><code><em>semaphore</em></code> is in an initialized state.</li>
<li>The light semaphore counter is decremented.</li>
</ul>
</li>
<li>If the return value is <code>false</code>:<ul>
<li><code><em>semaphore</em></code> is in a non-signaled state.</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets one count from the specified light semaphore (P operation). Returns <code>true</code> if successfully acquired. If the count for the target light semaphore is already 0, the current thread waits for another thread to return a light semaphore. If the amount of time specified by <code><em>timeout</em></code> elapses after the current thread starts waiting, a timeout occurs and the thread automatically stops waiting. In this case, the function returns <code>false</code>.</p>
<p>For more information about time-out behavior, see <a class="el" href="_page_notification_os_timeout.html">OS-API Timeouts</a>. </p>

</div>
</div>
<a id="a3ceaceb7088707e07f3be60222ae4e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ceaceb7088707e07f3be60222ae4e4b">&#9670;&nbsp;</a></span>ReleaseLightSemaphore() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::ReleaseLightSemaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html">LightSemaphoreType</a> *&#160;</td>
          <td class="paramname"><em>semaphore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases only one count of an <code><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html" title="This structure defines a light semaphore object.">LightSemaphoreType</a></code> object (V operation). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">semaphore</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html" title="This structure defines a light semaphore object.">LightSemaphoreType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>semaphore</em></code> is in an initialized state.</li>
<li>The light semaphore counter of <code><em>semaphore</em></code> is less than <code><em>maxCount</em></code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The light semaphore counter of <code><em>semaphore</em></code> is incremented.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Releases one count to the specified light semaphore (V operation). If there is a thread that is waiting for the target light semaphore, this function cancels standby.</p>
<p>If the counter of the target light semaphore exceeds the <code><em>maxCount</em></code> value specified when <code><a class="el" href="namespacenn_1_1os.html#a5ab8dff3311a08d0718855bff6d2c297" title="Initializes a LightSemaphoreType object.">InitializeLightSemaphore()</a></code> was called, this function causes an assertion failure. </p>

</div>
</div>
<a id="a2090b620e107723237bc81eb23e11e63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2090b620e107723237bc81eb23e11e63">&#9670;&nbsp;</a></span>ReleaseLightSemaphore() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::ReleaseLightSemaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html">LightSemaphoreType</a> *&#160;</td>
          <td class="paramname"><em>semaphore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases multiple counts of a <code><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html" title="This structure defines a light semaphore object.">LightSemaphoreType</a></code> object (V operation). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">semaphore</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html" title="This structure defines a light semaphore object.">LightSemaphoreType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Light semaphore count to release.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>count</em></code> &gt;= <code>1</code>.</li>
<li><code><em>semaphore</em></code> is in an initialized state.</li>
<li>The light semaphore counter of <code><em>semaphore</em></code> is less than or equal to <code><em>maxCount</em></code> - <code>count</code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The light semaphore counter of <code><em>semaphore</em></code> is increased by <code>count</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Returns <code>count</code> to the counter of the specified light semaphore (V operation). If there is a thread that is waiting for the target light semaphore, this function cancels standby.</p>
<p>If the counter of the target light semaphore exceeds the <code><em>maxCount</em></code> value specified when <code><a class="el" href="namespacenn_1_1os.html#a5ab8dff3311a08d0718855bff6d2c297" title="Initializes a LightSemaphoreType object.">InitializeLightSemaphore()</a></code> was called, this function causes an assertion failure. </p>

</div>
</div>
<a id="a46089352b69aa5a45a0369e4c5b315f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46089352b69aa5a45a0369e4c5b315f6">&#9670;&nbsp;</a></span>GetCurrentLightSemaphoreCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::os::GetCurrentLightSemaphoreCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html">LightSemaphoreType</a> *&#160;</td>
          <td class="paramname"><em>semaphore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current counter value of a <code><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html" title="This structure defines a light semaphore object.">LightSemaphoreType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">semaphore</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_light_semaphore_type.html" title="This structure defines a light semaphore object.">LightSemaphoreType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current counter value of the target light semaphore.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>semaphore</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>semaphore</em></code> is in an initialized state.</li>
<li>The current counter value of <code><em>semaphore</em></code> is returned.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Returns the current light semaphore count value.</p>
<p>The counter value of a light semaphore is manipulated by other threads. The counter value returned by this function is just a snapshot of the counter value at that instant. Take note of this when using the API. </p>

</div>
</div>
<a id="a347a69381452967e4a51b3c18aae7807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a347a69381452967e4a51b3c18aae7807">&#9670;&nbsp;</a></span>SetMemoryAllocatorForThreadLocal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SetMemoryAllocatorForThreadLocal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn.html#ae292809a1837a548ce8e91c92dd5fac8">nn::AlignedAllocateFunction</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn.html#ac4bc1dec66991644b7abd9f9cd9d0ca6">nn::DeallocateFunction</a>&#160;</td>
          <td class="paramname"><em>deallocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers the compiler thread local implementation memory allocator and memory deallocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Function pointer to the memory allocator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deallocator</td><td>Function pointer to the memory deallocator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>First time the API is called in the program.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Registers the memory allocator and deallocator functions used in the implementation of the thread local specifiers (<code>_Thread_local</code>, <code>thread_local</code>, <code>__thread</code>). However, for more information about whether the compiler supports these specifiers, see the compiler documentation.</p>
<p>This function is expected to be called once during the startup of each program, in <code><a class="el" href="init___startup_8h.html#ac781c07f35d3d9e7a71d21ad25e25f8f" title="Startup initialization routine.">nninitStartup()</a></code>. This function is called in a default <code><a class="el" href="init___startup_8h.html#ac781c07f35d3d9e7a71d21ad25e25f8f" title="Startup initialization routine.">nninitStartup()</a></code> after the memory heap is initialized. The function then registers the default allocator and default deallocator functions for thread local use.</p>
<p>The default allocator and deallocator functions use the same memory space as <code>malloc()</code> and <code>free()</code>. If you need to have the allocator and deallocator function to use a different memory space, the application must define its own <code><a class="el" href="init___startup_8h.html#ac781c07f35d3d9e7a71d21ad25e25f8f" title="Startup initialization routine.">nninitStartup()</a></code> that registers a different allocator and deallocator function.</p>
<p>Pass a function pointer of <code><a class="el" href="namespacenn.html#ae292809a1837a548ce8e91c92dd5fac8" title="This interface is for memory allocation functions.">nn::AlignedAllocateFunction</a></code> and <code><a class="el" href="namespacenn.html#ac4bc1dec66991644b7abd9f9cd9d0ca6" title="This interface is for memory deallocation functions.">nn::DeallocateFunction</a></code> type to the allocator and deallocator functions.</p>
<div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
<ul>
<li>This API does nothing and returns in a Windows environment, leaving the allocator and deallocator function unregistered.</li>
<li>The behavior of an object specified as thread local in a Windows environment follows the Visual C++ specification.</li>
</ul>
</div><div class="platform_section" data-platform="Windows"></div> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_fs_file_data_cache_2_fs_global_file_data_cache_default_disabled_2_fs_global_file_data_cache_default_disabled_8cpp-example.html#a10">FsFileDataCache/FsGlobalFileDataCacheDefaultDisabled/FsGlobalFileDataCacheDefaultDisabled.cpp</a>, <a class="el" href="_fs_file_data_cache_2_fs_global_file_data_cache_manually_enabled_2_fs_global_file_data_cache_manually_enabled_8cpp-example.html#a10">FsFileDataCache/FsGlobalFileDataCacheManuallyEnabled/FsGlobalFileDataCacheManuallyEnabled.cpp</a>, and <a class="el" href="_fs_file_data_cache_2_fs_individual_file_data_cache_2_fs_individual_file_data_cache_8cpp-example.html#a34">FsFileDataCache/FsIndividualFileDataCache/FsIndividualFileDataCache.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a0b9900ac6f5ffc3cceeaf9e4d4628fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b9900ac6f5ffc3cceeaf9e4d4628fd6">&#9670;&nbsp;</a></span>FenceMemoryStoreStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FenceMemoryStoreStore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a <code>Store-Store</code> memory fence. </p>
<p> <b>Details</b> <br  />
 Calling this API inserts a <code>Store-Store</code> memory fence in the location where the API is located. For more information, see <a class="el" href="_page_notification_os_memory_fence.html">OS API Memory Fence</a>. </p>

</div>
</div>
<a id="a89bc7c5ef7a7884fa2cdb771d1050045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89bc7c5ef7a7884fa2cdb771d1050045">&#9670;&nbsp;</a></span>FenceMemoryStoreLoad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FenceMemoryStoreLoad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a <code>Store-Load</code> memory fence. </p>
<p> <b>Details</b> <br  />
 Calling this API inserts a <code>Store-Load</code> memory fence in the location where the API is located. For more information, see <a class="el" href="_page_notification_os_memory_fence.html">OS API Memory Fence</a>. </p>

</div>
</div>
<a id="a8ecf770755dd217ffff4479db6102863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ecf770755dd217ffff4479db6102863">&#9670;&nbsp;</a></span>FenceMemoryStoreAny()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FenceMemoryStoreAny </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a <code>Store-Any</code> memory fence. </p>
<p> <b>Details</b> <br  />
 Calling this API inserts a <code>Store-Any</code> memory fence in the location where the API is located. For more information, see <a class="el" href="_page_notification_os_memory_fence.html">OS API Memory Fence</a>. </p>

</div>
</div>
<a id="a36d20e99e9c3b0e699b51a13acd3ead6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36d20e99e9c3b0e699b51a13acd3ead6">&#9670;&nbsp;</a></span>FenceMemoryLoadStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FenceMemoryLoadStore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a <code>Load-Store</code> memory fence. </p>
<p> <b>Details</b> <br  />
 Calling this API inserts a <code>Load-Store</code> memory fence in the location where the API is located. For more information, see <a class="el" href="_page_notification_os_memory_fence.html">OS API Memory Fence</a>. </p>

</div>
</div>
<a id="a24612da5b069435fc5f1d8f8720adadf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24612da5b069435fc5f1d8f8720adadf">&#9670;&nbsp;</a></span>FenceMemoryLoadLoad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FenceMemoryLoadLoad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a <code>Load-Load</code> memory fence. </p>
<p> <b>Details</b> <br  />
 Calling this API inserts a <code>Load-Load</code> memory fence in the location where the API is located. For more information, see <a class="el" href="_page_notification_os_memory_fence.html">OS API Memory Fence</a>. </p>

</div>
</div>
<a id="a367aa8b77b2ae4d88e358810ef54b973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367aa8b77b2ae4d88e358810ef54b973">&#9670;&nbsp;</a></span>FenceMemoryLoadAny()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FenceMemoryLoadAny </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a <code>Load-Any</code> memory fence. </p>
<p> <b>Details</b> <br  />
 Calling this API inserts a <code>Load-Any</code> memory fence in the location where the API is located. For more information, see <a class="el" href="_page_notification_os_memory_fence.html">OS API Memory Fence</a>. </p>

</div>
</div>
<a id="acebc9c7ff99fc0e1b04a693daeebda8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acebc9c7ff99fc0e1b04a693daeebda8f">&#9670;&nbsp;</a></span>FenceMemoryAnyStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FenceMemoryAnyStore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a <code>Any-Store</code> memory fence. </p>
<p> <b>Details</b> <br  />
 Calling this API inserts a <code>Any-Store</code> memory fence in the location where the API is located. For more information, see <a class="el" href="_page_notification_os_memory_fence.html">OS API Memory Fence</a>. </p>

</div>
</div>
<a id="a7bfb421bf54c835b5b731db28d171cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bfb421bf54c835b5b731db28d171cf9">&#9670;&nbsp;</a></span>FenceMemoryAnyLoad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FenceMemoryAnyLoad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a <code>Any-Load</code> memory fence. </p>
<p> <b>Details</b> <br  />
 Calling this API inserts a <code>Any-Load</code> memory fence in the location where the API is located. For more information, see <a class="el" href="_page_notification_os_memory_fence.html">OS API Memory Fence</a>. </p>

</div>
</div>
<a id="addf5cd70de75b033bb8ae4eac87f8fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf5cd70de75b033bb8ae4eac87f8fe2">&#9670;&nbsp;</a></span>FenceMemoryAnyAny()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FenceMemoryAnyAny </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a <code>Any-Any</code> memory fence. </p>
<p> <b>Details</b> <br  />
 Calling this API inserts a <code>Any-Any</code> memory fence in the location where the API is located. For more information, see <a class="el" href="_page_notification_os_memory_fence.html">OS API Memory Fence</a>. </p>

</div>
</div>
<a id="a2be8bac50d8d37a91f866d9e0c55886e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be8bac50d8d37a91f866d9e0c55886e">&#9670;&nbsp;</a></span>SetMemoryHeapSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::os::SetMemoryHeapSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the size of the memory heap region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the memory heap region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1os_1_1_result_out_of_memory.html">nn::os::ResultOutOfMemory</a> must be handled.</li>
<li><a class="el" href="classnn_1_1os_1_1_result_busy.html">nn::os::ResultBusy</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>size</em></code> &gt;= <code>0</code>.</li>
<li><code><em>size</em></code> is an integer multiple of <code><a class="el" href="namespacenn_1_1os.html#aeed47f05ce9175eb46876c1ddd0512c7" title="This constant stores the minimum unit of a memory heap region.">nn::os::MemoryHeapUnitSize</a></code>.</li>
<li>The memory heap is not in use.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The overall size of the memory heap is <code><em>size</em></code> bytes.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Changes the size of the memory heap.</p>
<p>When expanding the memory heap beyond its current size, additional memory is allocated to the end of the current memory heap. In this case, it is fine if a portion of the existing memory heap has already been allocated using the <code><a class="el" href="namespacenn_1_1os.html#a875bf6b3129f06654e641513c63017dd" title="Allocates a memory block from the memory heap.">AllocateMemoryBlock()</a></code> function.</p>
<p>When reducing the memory heap from its current size, memory is freed from the end of the current memory heap. In this case, it is fine if a portion of the existing memory heap has already been allocated using the <code><a class="el" href="namespacenn_1_1os.html#a875bf6b3129f06654e641513c63017dd" title="Allocates a memory block from the memory heap.">AllocateMemoryBlock()</a></code> function, as long as the allocated portion is not part of the memory to be freed.</p>
<p>If you want to manage the memory in the heap using your own memory management mechanism, allocate the area in question using the <code><a class="el" href="namespacenn_1_1os.html#a875bf6b3129f06654e641513c63017dd" title="Allocates a memory block from the memory heap.">AllocateMemoryBlock()</a></code> function. Proper operation cannot be guaranteed if you access the memory heap area directly without using the <code><a class="el" href="namespacenn_1_1os.html#a875bf6b3129f06654e641513c63017dd" title="Allocates a memory block from the memory heap.">AllocateMemoryBlock()</a></code> function for allocation. You can use this as a generic memory allocator by using a <code><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="Class for managing memory.">nn::mem::StandardAllocator</a></code> or similar class on a memory space obtained using the <code><a class="el" href="namespacenn_1_1os.html#a875bf6b3129f06654e641513c63017dd" title="Allocates a memory block from the memory heap.">AllocateMemoryBlock()</a></code> function.</p>
<p>If <code><a class="el" href="init___startup_8h.html#ac781c07f35d3d9e7a71d21ad25e25f8f" title="Startup initialization routine.">nninitStartup()</a></code> is not defined in the program, the default <code><a class="el" href="init___startup_8h.html#ac781c07f35d3d9e7a71d21ad25e25f8f" title="Startup initialization routine.">nninitStartup()</a></code> function of the SDK is called. The default function allocates as much memory heap as possible and passes it all to <code><a class="el" href="namespacenn_1_1init.html#a216ae7a5ca53a1c1e6dc0514f7283974" title="Initializes a memory allocator.">nn::init::InitializeAllocator()</a></code> for the memory allocator. If you want to change how the memory heap is used, you must define your own <code><a class="el" href="init___startup_8h.html#ac781c07f35d3d9e7a71d21ad25e25f8f" title="Startup initialization routine.">nninitStartup()</a></code> function.</p>
<div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
<ul>
<li>In the Windows environment, in some cases it is not possible to allocate the maximum for the memory heap. In these cases, only 32 MB will be allocated.</li>
</ul>
</div><div class="platform_section" data-platform="Windows"></div> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_fs_file_data_cache_2_fs_global_file_data_cache_default_disabled_2_fs_global_file_data_cache_default_disabled_8cpp-example.html#a7">FsFileDataCache/FsGlobalFileDataCacheDefaultDisabled/FsGlobalFileDataCacheDefaultDisabled.cpp</a>, <a class="el" href="_fs_file_data_cache_2_fs_global_file_data_cache_manually_enabled_2_fs_global_file_data_cache_manually_enabled_8cpp-example.html#a7">FsFileDataCache/FsGlobalFileDataCacheManuallyEnabled/FsGlobalFileDataCacheManuallyEnabled.cpp</a>, <a class="el" href="_fs_file_data_cache_2_fs_individual_file_data_cache_2_fs_individual_file_data_cache_8cpp-example.html#a31">FsFileDataCache/FsIndividualFileDataCache/FsIndividualFileDataCache.cpp</a>, <a class="el" href="_init_startup_2_init_startup_8cpp-example.html#a2">InitStartup/InitStartup.cpp</a>, <a class="el" href="_mifare_simple_2_mifare_simple_8cpp-example.html#a1">MifareSimple/MifareSimple.cpp</a>, <a class="el" href="_mii_compressed_texture_2_mii_compressed_texture_8cpp-example.html#a433">MiiCompressedTexture/MiiCompressedTexture.cpp</a>, <a class="el" href="_mii_database_2_mii_database_8cpp-example.html#a416">MiiDatabase/MiiDatabase.cpp</a>, <a class="el" href="_mii_dynamic_mask_2_mii_dynamic_mask_8cpp-example.html#a403">MiiDynamicMask/MiiDynamicMask.cpp</a>, <a class="el" href="_mii_g3d_headwear_2_mii_g3d_headwear_8cpp-example.html#a373">MiiG3dHeadwear/MiiG3dHeadwear.cpp</a>, <a class="el" href="_mii_g3d_simple_2_mii_g3d_simple_8cpp-example.html#a353">MiiG3dSimple/MiiG3dSimple.cpp</a>, <a class="el" href="_mii_headwear_example_2_mii_headwear_example_8cpp-example.html#a450">MiiHeadwearExample/MiiHeadwearExample.cpp</a>, <a class="el" href="_mii_mip_map_2_mii_mip_map_8cpp-example.html#a417">MiiMipMap/MiiMipMap.cpp</a>, <a class="el" href="_mii_premultiplied_alpha_icon_2_mii_premultiplied_alpha_icon_8cpp-example.html#a459">MiiPremultipliedAlphaIcon/MiiPremultipliedAlphaIcon.cpp</a>, <a class="el" href="_mii_shader_example_2_mii_shader_example_8cpp-example.html#a431">MiiShaderExample/MiiShaderExample.cpp</a>, <a class="el" href="_mii_simple_2_mii_simple_8cpp-example.html#a402">MiiSimple/MiiSimple.cpp</a>, <a class="el" href="_mii_simple_icon_2_mii_simple_icon_8cpp-example.html#a328">MiiSimpleIcon/MiiSimpleIcon.cpp</a>, <a class="el" href="_mii_simple_icon_body_2_mii_simple_icon_body_8cpp-example.html#a336">MiiSimpleIconBody/MiiSimpleIconBody.cpp</a>, <a class="el" href="_mii_simple_variable_icon_body_2_mii_simple_variable_icon_body_8cpp-example.html#a338">MiiSimpleVariableIconBody/MiiSimpleVariableIconBody.cpp</a>, <a class="el" href="_mii_system_resource_2_mii_system_resource_8cpp-example.html#a412">MiiSystemResource/MiiSystemResource.cpp</a>, <a class="el" href="_mii_transparent_adjuster_2_mii_transparent_adjuster_8cpp-example.html#a338">MiiTransparentAdjuster/MiiTransparentAdjuster.cpp</a>, <a class="el" href="_nfc_pass_through_simple_2_nfc_pass_through_simple_8cpp-example.html#a1">NfcPassThroughSimple/NfcPassThroughSimple.cpp</a>, <a class="el" href="_nfp_multi_2_nfp_multi_8cpp-example.html#a1">NfpMulti/NfpMulti.cpp</a>, <a class="el" href="_nfp_simple_2_nfp_simple_8cpp-example.html#a1">NfpSimple/NfpSimple.cpp</a>, <a class="el" href="_ngc_simple_2_ngc_simple_8cpp-example.html#a16">NgcSimple/NgcSimple.cpp</a>, <a class="el" href="_oe_launch_parameter_2_oe_launch_parameter_8cpp-example.html#a3">OeLaunchParameter/OeLaunchParameter.cpp</a>, <a class="el" href="_os_memory_heap_2_os_memory_heap_8cpp-example.html#a0">OsMemoryHeap/OsMemoryHeap.cpp</a>, <a class="el" href="_socket_multicast_2_basic_2_socket_multicast_basic_8cpp-example.html#a17">SocketMulticast/Basic/SocketMulticastBasic.cpp</a>, <a class="el" href="_ssl_simple_2_ssl_simple_8cpp-example.html#a46">SslSimple/SslSimple.cpp</a>, <a class="el" href="_swkbd_simple_2_swkbd_simple_8cpp-example.html#a4">SwkbdSimple/SwkbdSimple.cpp</a>, and <a class="el" href="_unit_test_with_googletest_2_unit_test_with_googletest_8cpp-example.html#a7">UnitTestWithGoogletest/UnitTestWithGoogletest.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a875bf6b3129f06654e641513c63017dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a875bf6b3129f06654e641513c63017dd">&#9670;&nbsp;</a></span>AllocateMemoryBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::os::AllocateMemoryBlock </td>
          <td>(</td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a memory block from the memory heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Location for storing the starting address of the allocated memory block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the memory block to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1os_1_1_result_out_of_memory.html">nn::os::ResultOutOfMemory</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>size</em></code> &gt; <code>0</code>.</li>
<li><code><em>size</em></code> is an integer multiple of <code><a class="el" href="namespacenn_1_1os.html#ade84ad9f438e76820510ca0623c5a823" title="This constant stores the minimum unit of a memory block.">nn::os::MemoryBlockUnitSize</a></code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If memory block allocation succeeds:<ul>
<li><code><em>address</em></code> contains the starting address of the allocated memory block.</li>
<li>The allocated memory block has the <code><a class="el" href="namespacenn_1_1os.html#a883ab0b53c72a07619d9e83de4836b9aa57ead1592d9473ac1c22f0b4f75ed2c0" title="Memory can be read from and written to.">nn::os::MemoryPermission_ReadWrite</a></code> attribute.</li>
</ul>
</li>
<li>If memory block allocation fails:<ul>
<li>There are no changes to the memory heap region.</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Allocates a memory block with a size of <code><em>size</em></code> from the memory heap region. If the memory block is successfully allocated, the starting address is stored in <code><em>address</em></code>.</p>
<p>The ability to allocate memory blocks equivalent, in total, to the memory heap size is ensured, because there is no overhead for things like memory block management areas. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_fs_file_data_cache_2_fs_global_file_data_cache_default_disabled_2_fs_global_file_data_cache_default_disabled_8cpp-example.html#a8">FsFileDataCache/FsGlobalFileDataCacheDefaultDisabled/FsGlobalFileDataCacheDefaultDisabled.cpp</a>, <a class="el" href="_fs_file_data_cache_2_fs_global_file_data_cache_manually_enabled_2_fs_global_file_data_cache_manually_enabled_8cpp-example.html#a8">FsFileDataCache/FsGlobalFileDataCacheManuallyEnabled/FsGlobalFileDataCacheManuallyEnabled.cpp</a>, <a class="el" href="_fs_file_data_cache_2_fs_individual_file_data_cache_2_fs_individual_file_data_cache_8cpp-example.html#a32">FsFileDataCache/FsIndividualFileDataCache/FsIndividualFileDataCache.cpp</a>, <a class="el" href="_init_startup_2_init_startup_8cpp-example.html#a3">InitStartup/InitStartup.cpp</a>, <a class="el" href="_mifare_simple_2_mifare_simple_8cpp-example.html#a2">MifareSimple/MifareSimple.cpp</a>, <a class="el" href="_mii_compressed_texture_2_mii_compressed_texture_8cpp-example.html#a434">MiiCompressedTexture/MiiCompressedTexture.cpp</a>, <a class="el" href="_mii_database_2_mii_database_8cpp-example.html#a417">MiiDatabase/MiiDatabase.cpp</a>, <a class="el" href="_mii_dynamic_mask_2_mii_dynamic_mask_8cpp-example.html#a404">MiiDynamicMask/MiiDynamicMask.cpp</a>, <a class="el" href="_mii_g3d_headwear_2_mii_g3d_headwear_8cpp-example.html#a374">MiiG3dHeadwear/MiiG3dHeadwear.cpp</a>, <a class="el" href="_mii_g3d_simple_2_mii_g3d_simple_8cpp-example.html#a354">MiiG3dSimple/MiiG3dSimple.cpp</a>, <a class="el" href="_mii_headwear_example_2_mii_headwear_example_8cpp-example.html#a451">MiiHeadwearExample/MiiHeadwearExample.cpp</a>, <a class="el" href="_mii_mip_map_2_mii_mip_map_8cpp-example.html#a418">MiiMipMap/MiiMipMap.cpp</a>, <a class="el" href="_mii_premultiplied_alpha_icon_2_mii_premultiplied_alpha_icon_8cpp-example.html#a460">MiiPremultipliedAlphaIcon/MiiPremultipliedAlphaIcon.cpp</a>, <a class="el" href="_mii_shader_example_2_mii_shader_example_8cpp-example.html#a432">MiiShaderExample/MiiShaderExample.cpp</a>, <a class="el" href="_mii_simple_2_mii_simple_8cpp-example.html#a403">MiiSimple/MiiSimple.cpp</a>, <a class="el" href="_mii_simple_icon_2_mii_simple_icon_8cpp-example.html#a329">MiiSimpleIcon/MiiSimpleIcon.cpp</a>, <a class="el" href="_mii_simple_icon_body_2_mii_simple_icon_body_8cpp-example.html#a337">MiiSimpleIconBody/MiiSimpleIconBody.cpp</a>, <a class="el" href="_mii_simple_variable_icon_body_2_mii_simple_variable_icon_body_8cpp-example.html#a339">MiiSimpleVariableIconBody/MiiSimpleVariableIconBody.cpp</a>, <a class="el" href="_mii_system_resource_2_mii_system_resource_8cpp-example.html#a413">MiiSystemResource/MiiSystemResource.cpp</a>, <a class="el" href="_mii_transparent_adjuster_2_mii_transparent_adjuster_8cpp-example.html#a339">MiiTransparentAdjuster/MiiTransparentAdjuster.cpp</a>, <a class="el" href="_nfc_pass_through_simple_2_nfc_pass_through_simple_8cpp-example.html#a2">NfcPassThroughSimple/NfcPassThroughSimple.cpp</a>, <a class="el" href="_nfp_multi_2_nfp_multi_8cpp-example.html#a2">NfpMulti/NfpMulti.cpp</a>, <a class="el" href="_nfp_simple_2_nfp_simple_8cpp-example.html#a2">NfpSimple/NfpSimple.cpp</a>, <a class="el" href="_ngc_simple_2_ngc_simple_8cpp-example.html#a17">NgcSimple/NgcSimple.cpp</a>, <a class="el" href="_oe_launch_parameter_2_oe_launch_parameter_8cpp-example.html#a4">OeLaunchParameter/OeLaunchParameter.cpp</a>, <a class="el" href="_os_memory_heap_2_os_memory_heap_8cpp-example.html#a3">OsMemoryHeap/OsMemoryHeap.cpp</a>, <a class="el" href="_socket_multicast_2_basic_2_socket_multicast_basic_8cpp-example.html#a19">SocketMulticast/Basic/SocketMulticastBasic.cpp</a>, <a class="el" href="_ssl_simple_2_ssl_simple_8cpp-example.html#a48">SslSimple/SslSimple.cpp</a>, <a class="el" href="_swkbd_simple_2_swkbd_simple_8cpp-example.html#a5">SwkbdSimple/SwkbdSimple.cpp</a>, and <a class="el" href="_unit_test_with_googletest_2_unit_test_with_googletest_8cpp-example.html#a8">UnitTestWithGoogletest/UnitTestWithGoogletest.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a20fa47e171856fb202b60e6b2a1de719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20fa47e171856fb202b60e6b2a1de719">&#9670;&nbsp;</a></span>FreeMemoryBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FreeMemoryBlock </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases a memory block back to the memory heap region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Starting address of the memory block to release. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the memory block to release.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>address</em></code> is an integer multiple of <code><a class="el" href="namespacenn_1_1os.html#ade84ad9f438e76820510ca0623c5a823" title="This constant stores the minimum unit of a memory block.">nn::os::MemoryBlockUnitSize</a></code>.</li>
<li><code><em>size</em></code> &gt; <code>0</code>.</li>
<li><code><em>size</em></code> is an integer multiple of <code><a class="el" href="namespacenn_1_1os.html#ade84ad9f438e76820510ca0623c5a823" title="This constant stores the minimum unit of a memory block.">nn::os::MemoryBlockUnitSize</a></code>.</li>
<li>The memory block to release is within the memory heap region.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The memory block is released back to the memory heap.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Releases the memory block in the range of <code><em>address</em></code> to (<code><em>address</em></code>+ <code><em>size</em></code>) back to the memory heap region. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_memory_heap_2_os_memory_heap_8cpp-example.html#a5">OsMemoryHeap/OsMemoryHeap.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae3d0ddd1807c032d7ab0e0fda9739bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3d0ddd1807c032d7ab0e0fda9739bef">&#9670;&nbsp;</a></span>SetMemoryPermission()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SetMemoryPermission </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1os.html#a883ab0b53c72a07619d9e83de4836b9a">MemoryPermission</a>&#160;</td>
          <td class="paramname"><em>permission</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the access permission for the specified region of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Specifies the starting address of the memory region to configure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Specifies the size of the memory region to configure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">permission</td><td>Specifies the access permission you want to set for the memory region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>address</em></code> is an integer multiple of <code><a class="el" href="namespacenn_1_1os.html#ac880b46610757e748d5bd79211af4236" title="This constant stores the minimum unit for memory operations.">nn::os::MemoryPageSize</a></code>.</li>
<li><code><em>size</em></code> is an integer multiple of <code><a class="el" href="namespacenn_1_1os.html#ac880b46610757e748d5bd79211af4236" title="This constant stores the minimum unit for memory operations.">nn::os::MemoryPageSize</a></code>.</li>
<li><code><em>permission</em></code> is one of the following.<ul>
<li><a class="el" href="namespacenn_1_1os.html#a883ab0b53c72a07619d9e83de4836b9aaf6942de46447bc0df8294a749a329d08" title="Access to memory is prohibited.">nn::os::MemoryPermission_None</a></li>
<li><a class="el" href="namespacenn_1_1os.html#a883ab0b53c72a07619d9e83de4836b9aad0057f9250371335c5b9292ff44e1750" title="Memory is read-only.">nn::os::MemoryPermission_ReadOnly</a></li>
<li><a class="el" href="namespacenn_1_1os.html#a883ab0b53c72a07619d9e83de4836b9aa57ead1592d9473ac1c22f0b4f75ed2c0" title="Memory can be read from and written to.">nn::os::MemoryPermission_ReadWrite</a></li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The specified memory region has a memory access permission of <code><em>permission</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Changes the memory access permission of the specified memory region to <code><em>permission</em></code>. </p>

</div>
</div>
<a id="ab7baa013ea5d9d4f9e84eb5d1afcec49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7baa013ea5d9d4f9e84eb5d1afcec49">&#9670;&nbsp;</a></span>InitializeMessageQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeMessageQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a message queue object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="This structure defines a message queue object.">MessageQueueType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Starting address of the message queue buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Maximum number of data items that can be stored in the message queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an uninitialized state or has not been initialized.</li>
<li><code><em>buffer</em></code> points to a memory region of <code><em>count</em></code> * sizeof(<code>uintptr_t</code>) bytes.</li>
<li><code><em>count</em></code> &gt;= <code>1</code></li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an initialized (empty) state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Initializes a <code><a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="This structure defines a message queue object.">MessageQueueType</a></code> object. In other words, it initializes the object to a state without any accumulated message data, threads waiting to send messages, or threads waiting to receive messages.</p>
<p>Pass the <code>uintptr_t</code> type array to the message queue buffer region. A memory area of <code><em>count</em></code> * <code><em>sizeof</em>(uintptr_t)</code> must be allocated.</p>
<p>This function is not thread-safe. Do not manipulate the object specified in <code><em>messageQueue</em></code> while this function is being called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a54">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_os_message_queue_2_os_message_queue_8cpp-example.html#a8">OsMessageQueue/OsMessageQueue.cpp</a>, <a class="el" href="_os_multi_wait_2_os_multi_wait_8cpp-example.html#a31">OsMultiWait/OsMultiWait.cpp</a>, and <a class="el" href="_os_multi_wait_utility_2_os_multi_wait_utility_8cpp-example.html#a21">OsMultiWaitUtility/OsMultiWaitUtility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af9c98095075b7ef0570c1a449545e392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c98095075b7ef0570c1a449545e392">&#9670;&nbsp;</a></span>FinalizeMessageQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FinalizeMessageQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalizes a message queue object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="This structure defines a message queue object.">MessageQueueType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an initialized state.</li>
<li>No threads are waiting for <code><em>messageQueue</em></code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an uninitialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Finalizes a <code><a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="This structure defines a message queue object.">MessageQueueType</a></code> object. The object can be finalized even if there are messages in the queue, but if any threads are waiting to send to or receive from the message queue, the function cannot be called.</p>
<p>After finalization, the memory area used for the message queue buffer can be reused for another purpose.</p>
<p>This function is not thread-safe. Do not manipulate the object specified in <code><em>messageQueue</em></code> while this function is being called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a59">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_os_message_queue_2_os_message_queue_8cpp-example.html#a15">OsMessageQueue/OsMessageQueue.cpp</a>, <a class="el" href="_os_multi_wait_2_os_multi_wait_8cpp-example.html#a40">OsMultiWait/OsMultiWait.cpp</a>, and <a class="el" href="_os_multi_wait_utility_2_os_multi_wait_utility_8cpp-example.html#a30">OsMultiWaitUtility/OsMultiWaitUtility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="afec9c0c3cacf43c7aa82f323da656af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec9c0c3cacf43c7aa82f323da656af5">&#9670;&nbsp;</a></span>SendMessageQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SendMessageQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends one piece of data to the end of the message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="This structure defines a message queue object.">MessageQueueType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in a <code>NotEmpty</code> state.</li>
<li><code><em>data</em></code> is added to the end of the <code><em>messageQueue</em></code> data array.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sends one piece of data to the end of the message queue. If there is space in the message queue, the function sends the data and then immediately returns.</p>
<p>If there is no space in the message queue, the current thread waits to send. When the thread stops waiting, the function sends the data and then returns. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a101">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_os_message_queue_2_os_message_queue_8cpp-example.html#a2">OsMessageQueue/OsMessageQueue.cpp</a>, <a class="el" href="_os_multi_wait_2_os_multi_wait_8cpp-example.html#a26">OsMultiWait/OsMultiWait.cpp</a>, and <a class="el" href="_os_multi_wait_utility_2_os_multi_wait_utility_8cpp-example.html#a16">OsMultiWaitUtility/OsMultiWaitUtility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a78cd82954aa87f10f881a7e34fad596b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78cd82954aa87f10f881a7e34fad596b">&#9670;&nbsp;</a></span>TrySendMessageQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TrySendMessageQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends one piece of data to the end of the message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="This structure defines a message queue object.">MessageQueueType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether sending to the message queue was successful.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the return value is <code>true</code>:<ul>
<li><code><em>messageQueue</em></code> is in a <code>NotEmpty</code> state.</li>
<li><code><em>data</em></code> is added to the end of the <code><em>messageQueue</em></code> data array.</li>
</ul>
</li>
<li>If the return value is <code>false</code>:<ul>
<li><code><em>messageQueue</em></code> is in an initialized state (the state does not change).</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sends one piece of data to the end of the message queue. If there is space in the message queue, the function sends the data and then returns <code>true</code>. If there is no space in the message queue, the function returns <code>false</code> without going into a waiting state. </p>

</div>
</div>
<a id="ad5e14ae7d5a67147af209a1029991095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e14ae7d5a67147af209a1029991095">&#9670;&nbsp;</a></span>TimedSendMessageQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TimedSendMessageQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends one piece of data to the end of the message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="This structure defines a message queue object.">MessageQueueType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Wait time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether sending to the message queue was successful.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an initialized state.</li>
<li><code><em>timeout</em></code> &gt;= <code>0</code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the return value is <code>true</code>:<ul>
<li><code><em>messageQueue</em></code> is in a <code>NotEmpty</code> state.</li>
<li><code><em>data</em></code> is added to the end of the <code><em>messageQueue</em></code> data array.</li>
</ul>
</li>
<li>If the return value is <code>false</code>:<ul>
<li><code><em>messageQueue</em></code> is in an initialized state (the state does not change).</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sends one piece of data to the end of the message queue. If there is space in the message queue, the function sends the data and then returns <code>true</code>.</p>
<p>If there is no space in the message queue, the current thread waits to send. When space becomes available in the message queue, the thread stops waiting, sends the data, and then returns. In this case, the return value is <code>true</code>.</p>
<p>If the amount of time specified by <code><em>timeout</em></code> elapses after the current thread starts waiting, a timeout occurs and the thread automatically stops waiting and returns. In this case, the function returns <code>false</code> without sending any data.</p>
<p>For more information about time-out behavior, see <a class="el" href="_page_notification_os_timeout.html">OS-API Timeouts</a>. </p>

</div>
</div>
<a id="a7a47bc9d914dbdf48011deeb859cb877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a47bc9d914dbdf48011deeb859cb877">&#9670;&nbsp;</a></span>JamMessageQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::JamMessageQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends one piece of data to the beginning of the message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="This structure defines a message queue object.">MessageQueueType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an initialized state. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in a <code>NotEmpty</code> state.</li>
<li><code><em>data</em></code> is added to the beginning of the <code><em>messageQueue</em></code> data array.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sends one piece of data to the beginning of the message queue. If there is space in the message queue, the function sends the data and then immediately returns.</p>
<p>If there is no space in the message queue, the current thread waits to send. When the thread stops waiting, the function sends the data and then returns. </p>

</div>
</div>
<a id="aa6fd916fb5a94b34c37d2b8faa43ce3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6fd916fb5a94b34c37d2b8faa43ce3c">&#9670;&nbsp;</a></span>TryJamMessageQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TryJamMessageQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends one piece of data to the beginning of the message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="This structure defines a message queue object.">MessageQueueType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether sending to the message queue was successful.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the return value is <code>true</code>:<ul>
<li><code><em>messageQueue</em></code> is in a <code>NotEmpty</code> state.</li>
<li><code><em>data</em></code> is added to the beginning of the <code><em>messageQueue</em></code> data array.</li>
</ul>
</li>
<li>If the return value is <code>false</code>:<ul>
<li><code><em>messageQueue</em></code> is in an initialized state (the state does not change).</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sends one piece of data to the beginning of the message queue. If there is space in the message queue, the function sends the data and then returns <code>true</code>. If there is no space in the message queue, the function returns <code>false</code> without going into a waiting state. </p>

</div>
</div>
<a id="ad4cfd66c4587832586ee7a50e5fd90b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4cfd66c4587832586ee7a50e5fd90b0">&#9670;&nbsp;</a></span>TimedJamMessageQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TimedJamMessageQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends one piece of data to the beginning of the message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="This structure defines a message queue object.">MessageQueueType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Wait time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether sending to the message queue was successful.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an initialized state.</li>
<li><code><em>timeout</em></code> &gt;= <code>0</code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the return value is <code>true</code>:<ul>
<li><code><em>messageQueue</em></code> is in a <code>NotEmpty</code> state.</li>
<li><code><em>data</em></code> is added to the beginning of the <code><em>messageQueue</em></code> data array.</li>
</ul>
</li>
<li>If the return value is <code>false</code>:<ul>
<li><code><em>messageQueue</em></code> is in an initialized state (the state does not change).</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sends one piece of data to the beginning of the message queue. If there is space in the message queue, the function sends the data and then returns <code>true</code>.</p>
<p>If there is no space in the message queue, the current thread waits to send. When space becomes available in the message queue, the thread stops waiting, sends the data, and then returns. In this case, the return value is <code>true</code>.</p>
<p>If the amount of time specified by <code><em>timeout</em></code> elapses after the current thread starts waiting, a time-out occurs and the thread automatically stops waiting. In this case, the function returns <code>false</code> without sending any data.</p>
<p>For more information about time-out behavior, see <a class="el" href="_page_notification_os_timeout.html">OS-API Timeouts</a>. </p>

</div>
</div>
<a id="ace7ad0de1da8fdeeeb01e7de7494dc87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7ad0de1da8fdeeeb01e7de7494dc87">&#9670;&nbsp;</a></span>ReceiveMessageQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::ReceiveMessageQueue </td>
          <td>(</td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>outData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives one piece of data from the beginning of the message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outData</td><td>Location for storing the received data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="This structure defines a message queue object.">MessageQueueType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in a <code>NotFull</code> state.</li>
<li>The data at the beginning of the <code><em>messageQueue</em></code> data array is retrieved and stored in <code><em>outData</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Receives one piece of data from the beginning of the message queue. If there is any data in the message queue, the data is extracted and stored in the area specified by <code><em>outData</em></code>. If there is no data in the message queue, the current thread waits to receive. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a103">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_os_message_queue_2_os_message_queue_8cpp-example.html#a4">OsMessageQueue/OsMessageQueue.cpp</a>, <a class="el" href="_os_multi_wait_2_os_multi_wait_8cpp-example.html#a7">OsMultiWait/OsMultiWait.cpp</a>, and <a class="el" href="_os_multi_wait_utility_2_os_multi_wait_utility_8cpp-example.html#a7">OsMultiWaitUtility/OsMultiWaitUtility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a921571e9781d3e6fbf60ca8ee4a1825d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a921571e9781d3e6fbf60ca8ee4a1825d">&#9670;&nbsp;</a></span>TryReceiveMessageQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TryReceiveMessageQueue </td>
          <td>(</td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>outData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives one piece of data from the beginning of the message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outData</td><td>Location for storing the received data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="This structure defines a message queue object.">MessageQueueType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether receiving from the message queue was successful.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the return value is <code>true</code>:<ul>
<li><code><em>messageQueue</em></code> is in a <code>NotFull</code> state.</li>
<li>The data at the beginning of the <code><em>messageQueue</em></code> data array is retrieved and stored in <code><em>outData</em></code>.</li>
</ul>
</li>
<li>If the return value is <code>false</code>:<ul>
<li><code><em>messageQueue</em></code> is in an initialized state (the state does not change).</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Receives one piece of data from the beginning of the message queue. If there is any data in the message queue, the data is extracted and stored in the area specified by <code><em>outData</em></code>, and the function returns <code>true</code>. If there is no data in the message queue, the current thread returns <code>false</code> without going into a waiting state. </p>

</div>
</div>
<a id="ae0838f36e8391d50f81549950611aeb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0838f36e8391d50f81549950611aeb4">&#9670;&nbsp;</a></span>TimedReceiveMessageQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TimedReceiveMessageQueue </td>
          <td>(</td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>outData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives one piece of data from the beginning of the message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outData</td><td>Location for storing the received data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="This structure defines a message queue object.">MessageQueueType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Wait time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether receiving from the message queue was successful.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an initialized state.</li>
<li><code><em>timeout</em></code> &gt;= <code>0</code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the return value is <code>true</code>:<ul>
<li><code><em>messageQueue</em></code> is in a <code>NotFull</code> state.</li>
<li>The data at the beginning of the <code><em>messageQueue</em></code> data array is retrieved and stored in <code><em>outData</em></code>.</li>
</ul>
</li>
<li>If the return value is <code>false</code>:<ul>
<li><code><em>messageQueue</em></code> is in an initialized state (the state does not change).</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Receives one piece of data from the beginning of the message queue. If there is any data in the message queue, the data is extracted and stored in the area specified by <code><em>outData</em></code>, and the function returns <code>true</code>. If there is no data in the message queue, the current thread waits to receive.</p>
<p>If the amount of time specified by <code><em>timeout</em></code> elapses after the current thread starts waiting, a time-out occurs and the thread automatically stops waiting. In this case, the function returns <code>false</code> without receiving any data.</p>
<p>For more information about time-out behavior, see <a class="el" href="_page_notification_os_timeout.html">OS-API Timeouts</a>. </p>

</div>
</div>
<a id="a7fab6d997fb47451e6c9cd47ef754e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fab6d997fb47451e6c9cd47ef754e99">&#9670;&nbsp;</a></span>PeekMessageQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::PeekMessageQueue </td>
          <td>(</td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>outData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the first data item in a message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outData</td><td>Location for storing the looked-up data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="This structure defines a message queue object.">MessageQueueType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an initialized state (the state does not change).</li>
<li>The data at the beginning of the <code><em>messageQueue</em></code> data array is read and stored in <code><em>outData</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Reads the data at the beginning of the message queue and stores it in the area specified by <code><em>outData</em></code>. The data is never actually extracted and the state of the message queue does not change.</p>
<p>If there is any data in the message queue, the function reads the data and then immediately returns. If there is no data in the message queue, the current thread waits to receive. </p>

</div>
</div>
<a id="a6f08aef79a422888383a8ab1d5786fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f08aef79a422888383a8ab1d5786fe3">&#9670;&nbsp;</a></span>TryPeekMessageQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TryPeekMessageQueue </td>
          <td>(</td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>outData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the first data item in a message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outData</td><td>Location for storing the looked-up data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="This structure defines a message queue object.">MessageQueueType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether reading the data from the message queue was successful.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an initialized state. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the return value is <code>true</code>:<ul>
<li><code><em>messageQueue</em></code> is in an initialized state (the state does not change).</li>
<li>The data at the beginning of the <code><em>messageQueue</em></code> data array is read and stored in <code><em>outData</em></code>.</li>
</ul>
</li>
<li>If the return value is <code>false</code>:<ul>
<li><code><em>messageQueue</em></code> is in an initialized state (the state does not change).</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Reads the data at the beginning of the message queue and stores it in the area specified by <code><em>outData</em></code>. The data is never actually extracted and the state of the message queue does not change.</p>
<p>If there is any data in the message queue, the function reads the data and then returns <code>true</code>. If there is no data in the message queue, the current thread returns <code>false</code> without going into a waiting state. </p>

</div>
</div>
<a id="a0dc5fb4ad2ef7a5dfff029e0128efa55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc5fb4ad2ef7a5dfff029e0128efa55">&#9670;&nbsp;</a></span>TimedPeekMessageQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TimedPeekMessageQueue </td>
          <td>(</td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>outData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the first data item in a message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outData</td><td>Location for storing the looked-up data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="This structure defines a message queue object.">MessageQueueType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Wait time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether reading the data from the message queue was successful.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an initialized state.</li>
<li><code><em>timeout</em></code> &gt;= <code>0</code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the return value is <code>true</code>:<ul>
<li><code><em>messageQueue</em></code> is in an initialized state (the state does not change).</li>
<li>The data at the beginning of the <code><em>messageQueue</em></code> data array is read and stored in <code><em>outData</em></code>.</li>
</ul>
</li>
<li>If the return value is <code>false</code>:<ul>
<li><code><em>messageQueue</em></code> is in an initialized state (the state does not change).</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Reads the data at the beginning of the message queue and stores it in the area specified by <code><em>outData</em></code>. The data is never actually extracted and the state of the message queue does not change.</p>
<p>If there is any data in the message queue, the function reads the data and then returns <code>true</code>. If there is no data in the message queue, the current thread waits to receive.</p>
<p>If the amount of time specified by <code><em>timeout</em></code> elapses after the current thread starts waiting, a time-out occurs and the thread automatically stops waiting. In this case, the function returns <code>false</code> without getting any data.</p>
<p>For more information about time-out behavior, see <a class="el" href="_page_notification_os_timeout.html">OS-API Timeouts</a>. </p>

</div>
</div>
<a id="a241484ed12a060d60eeb234db88484d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241484ed12a060d60eeb234db88484d0">&#9670;&nbsp;</a></span>InitializeMultiWaitHolder() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeMultiWaitHolder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *&#160;</td>
          <td class="paramname"><em>multiWaitHolder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1os.html#a3271c9fc6c46cffdb076b966f15a80bc">MessageQueueWaitType</a>&#160;</td>
          <td class="paramname"><em>waitType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a <code>MultiWaitHolder</code> object and binds it to a message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWaitHolder</td><td>Pointer to a multiwait object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>Pointer to the message queue to bind to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">waitType</td><td>Wait type of the message queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>multiWaitHolder</em></code> is in an uninitialized state.</li>
<li><code><em>messageQueue</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>multiWaitHolder</em></code> is in an initialized state (and bound to <code><em>messageQueue</em></code>).</li>
<li><code><a class="el" href="namespacenn_1_1os.html#a9e8c73312415fc00c72808fcc00fea33">nn::os::GetMultiWaitHolderUserData(multiWaitHolder)</a></code> == <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Initializes <code><em>multiWaitHolder</em></code> and binds it to the object specified in <code><em>messageQueue</em></code>.</p>
<p>Specify one of the following two types for <code><em>waitType</em></code>.</p><ul>
<li><a class="el" href="namespacenn_1_1os.html#a3271c9fc6c46cffdb076b966f15a80bca0fa8f18b62354b68a7838af2bf4e6f01" title="Wait until the message queue has an opening.">nn::os::MessageQueueWaitType_WaitForNotFull</a></li>
<li><a class="el" href="namespacenn_1_1os.html#a3271c9fc6c46cffdb076b966f15a80bca40a79a4dabe0233dd5c21d7c4a718eea" title="Wait until the message queue is no longer empty.">nn::os::MessageQueueWaitType_WaitForNotEmpty</a></li>
</ul>
<p>If <code><em>waitType</em></code> is <code>WaitForNotFull</code>, the bound <code><em>multiWaitHolder</em></code> enters a signaled state when there are one or more spaces available in the message queue buffer. If at least one space is available in the message queue, the object enters a signaled state immediately.</p>
<p>If <code><em>waitType</em></code> is <code>WaitForNotEmpty</code>, the bound <code><em>multiWaitHolder</em></code> enters a signaled state when one or more data items have accumulated in the message queue buffer. If at least one data item has already accumulated in the message queue, the object enters a signaled state immediately.</p>
<p>Using a <code><em>multiWaitHolder</em></code> object initialized using this API and the target message queue signaled to wake the multiwait does not alter the contents of the message queue buffer. For more information, see <a class="el" href="_page_notification_os_multi_wait.html#PageNotificationOsMultiWait_AboutWakeup">Waking a multiwait PageNotificationOsMultiWait_AboutWakeup</a>.</p>
<p>Do not operate on <code><em>multiWaitHolder</em></code> while this function is being called. </p>

</div>
</div>
<a id="a48e6662e7fdf9f78bcae79ba94d64a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e6662e7fdf9f78bcae79ba94d64a93">&#9670;&nbsp;</a></span>InitializeMultiWait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeMultiWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *&#160;</td>
          <td class="paramname"><em>multiWait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the <code><em>multiWait</em></code> object header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWait</td><td>Pointer to a multiwait object header.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>multiWait</em></code> is in an uninitialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>multiWait</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Initializes <em>multiWait</em>.</p>
<p>When using the multiwait feature, a <code><a class="el" href="structnn_1_1os_1_1_multi_wait_type.html" title="This structure defines a multiwait object.">MultiWaitType</a></code> object is initialized as a list header and <code><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="This structure defines a multiwait object holder.">MultiWaitHolderType</a></code> objects are linked as list elements.</p>
<p>The required number of threads and <code><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="This structure defines a multiwait object holder.">MultiWaitHolderType</a></code> objects bound to a semaphore, event, or message queue are prepared and linked to the list. The prepared <code><a class="el" href="structnn_1_1os_1_1_multi_wait_type.html" title="This structure defines a multiwait object.">MultiWaitType</a></code> object can then be passed to the <code><a class="el" href="namespacenn_1_1os.html#ab9b837eb53fa2c8a9610cec2b69666fd" title="Waits for any of the multiWaitHolder objects in the multiWait list.">WaitAny()</a></code> function to wait for any of the objects to enter a signaled state.</p>
<p>The <code><a class="el" href="namespacenn_1_1os.html#ab9b837eb53fa2c8a9610cec2b69666fd" title="Waits for any of the multiWaitHolder objects in the multiWait list.">WaitAny()</a></code> function wakes the thread when it detects a signaled object. This is not done, however, until the resources are acquired for the target object. For this reason, a separate resource allocation API must be called on the sychronization object associated with the <code><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="This structure defines a multiwait object holder.">MultiWaitHolderType</a></code> object returned by the <code><a class="el" href="namespacenn_1_1os.html#ab9b837eb53fa2c8a9610cec2b69666fd" title="Waits for any of the multiWaitHolder objects in the multiWait list.">WaitAny()</a></code> function.</p>
<p>This function is not thread-safe. Do not manipulate the object specified in <em>multiWait</em> while this function is being called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a72">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_access_point_2_ldn_access_point_8cpp-example.html#a16">LdnBasic/LdnAccessPoint/LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_station_2_ldn_station_8cpp-example.html#a16">LdnBasic/LdnStation/LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a52">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_2_movie_player_simple_8cpp-example.html#a16">MoviePlayerSimple/MoviePlayerSimple.cpp</a>, and <a class="el" href="_os_multi_wait_2_os_multi_wait_8cpp-example.html#a15">OsMultiWait/OsMultiWait.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a60873f9b623e014948a9ea53a611da4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60873f9b623e014948a9ea53a611da4c">&#9670;&nbsp;</a></span>FinalizeMultiWait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FinalizeMultiWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *&#160;</td>
          <td class="paramname"><em>multiWait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalizes the <code><em>multiWait</em></code> object header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWait</td><td>Pointer to a multiwait object header.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>multiWait</em></code> is in an initialized state.</li>
<li>There are no <code><em>multiWaitHolder</em></code> objects linked to the <code><em>multiWait</em></code> list.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>multiWait</em></code> is in an uninitialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Finalizes <em>multiWait</em>. If any <code>MultiWaitHolder</code> objects are linked to the object in <em>multiWait</em>, the function fails on an assert.</p>
<p>This function is not thread-safe. Do not manipulate the object specified in <em>multiWait</em> while this function is being called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a77">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_access_point_2_ldn_access_point_8cpp-example.html#a36">LdnBasic/LdnAccessPoint/LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_station_2_ldn_station_8cpp-example.html#a30">LdnBasic/LdnStation/LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a57">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_2_movie_player_simple_8cpp-example.html#a20">MoviePlayerSimple/MoviePlayerSimple.cpp</a>, and <a class="el" href="_os_multi_wait_2_os_multi_wait_8cpp-example.html#a21">OsMultiWait/OsMultiWait.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab9b837eb53fa2c8a9610cec2b69666fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9b837eb53fa2c8a9610cec2b69666fd">&#9670;&nbsp;</a></span>WaitAny() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">nn::os::MultiWaitHolderType</a> * nn::os::WaitAny </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *&#160;</td>
          <td class="paramname"><em>multiWait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for any of the <code><em>multiWaitHolder</em></code> objects in the <code><em>multiWait</em></code> list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWait</td><td>Pointer to a multiwait object header.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the <code><em>multiWaitHolder</em></code> object with its state changed to signaled.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>multiWait</em></code> is in an initialized state.</li>
<li>All <code><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="This structure defines a multiwait object holder.">MultiWaitHolderType</a></code> objects connected to <code><em>multiWait</em></code> are in an initialized state.</li>
<li><code><em>multiWait</em></code> is not being used in another thread.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If any of the <code>multiWait</code> objects is signaled, returns a pointer to the <code><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="This structure defines a multiwait object holder.">MultiWaitHolderType</a></code> that detected the signaling.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Waits for any of the <code><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="This structure defines a multiwait object holder.">MultiWaitHolderType</a></code> objects linked to the <em>multiWait</em> list header to enter a signaled state.</p>
<p>The target object state does not change its signal state after an object's signal state is detected and returns a non-<code>NULL</code> value. For more information, see <a class="el" href="_page_notification_os_multi_wait.html#PageNotificationOsMultiWait_AboutWakeup">Waking a multiwait PageNotificationOsMultiWait_AboutWakeup</a>.</p>
<p><code>multiWait</code> must not be used in another thread. Specifically, operations against a <code>multiWait</code> or a multiwait using a specified <code>multiWait</code> must not be executed at the same time in a different thread before returning from <code><a class="el" href="namespacenn_1_1os.html#ab9b837eb53fa2c8a9610cec2b69666fd" title="Waits for any of the multiWaitHolder objects in the multiWait list.">WaitAny()</a></code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a74">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_access_point_2_ldn_access_point_8cpp-example.html#a19">LdnBasic/LdnAccessPoint/LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_station_2_ldn_station_8cpp-example.html#a19">LdnBasic/LdnStation/LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a106">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_2_movie_player_simple_8cpp-example.html#a25">MoviePlayerSimple/MoviePlayerSimple.cpp</a>, <a class="el" href="_os_multi_wait_2_os_multi_wait_8cpp-example.html#a17">OsMultiWait/OsMultiWait.cpp</a>, and <a class="el" href="_os_multi_wait_utility_2_os_multi_wait_utility_8cpp-example.html#a10">OsMultiWaitUtility/OsMultiWaitUtility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="add056696d279031175e9053145c82677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add056696d279031175e9053145c82677">&#9670;&nbsp;</a></span>TryWaitAny() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">nn::os::MultiWaitHolderType</a> * nn::os::TryWaitAny </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *&#160;</td>
          <td class="paramname"><em>multiWait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Polls for any of the <code>multiWaitHolder</code> objects in the <code><em>multiWait</em></code> list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWait</td><td>Pointer to a multiwait object header.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the <code><em>multiWaitHolder</em></code> object with its state changed to signaled. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000115">Return Values:</a></b></dt><dd><b>NULL</b> Polling failure.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>multiWait</em></code> is in an initialized state.</li>
<li>All <code><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="This structure defines a multiwait object holder.">MultiWaitHolderType</a></code> objects connected to <code><em>multiWait</em></code> are in an initialized state.</li>
<li><code><em>multiWait</em></code> is not being used in another thread.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If a change to signaled state is detected in any of the multiwait objects:<ul>
<li>Returns a pointer to the <code><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="This structure defines a multiwait object holder.">MultiWaitHolderType</a></code> that detected the signal.</li>
</ul>
</li>
<li>If a change to signaled state is not detected in any of the multiwait objects:<ul>
<li>Returns <code>NULL</code>.</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Polls all of the <code><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="This structure defines a multiwait object holder.">MultiWaitHolderType</a></code> objects linked to the <em>multiWait</em> list header to determine if any of them are in a signaled state. If all of the <code><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="This structure defines a multiwait object holder.">MultiWaitHolderType</a></code> objects are in a non-signaled state, polling fails and the function returns <code>NULL</code>.</p>
<p>The target object state does not change its signal state after an object's signal state is detected and returns a non-<code>NULL</code> value. For more information, see <a class="el" href="_page_notification_os_multi_wait.html#PageNotificationOsMultiWait_AboutWakeup">Waking a multiwait PageNotificationOsMultiWait_AboutWakeup</a>.</p>
<p><code>multiWait</code> must not be used in another thread. Specifically, operations against a <code>multiWait</code> or a multiwait using a specified <code>multiWait</code> must not be executed at the same time in a different thread before returning from <code><a class="el" href="namespacenn_1_1os.html#add056696d279031175e9053145c82677" title="Polls for any of the multiWaitHolder objects in the multiWait list.">TryWaitAny()</a></code>. </p>

</div>
</div>
<a id="a6a76f1be743cfc8791d2a139c7409470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a76f1be743cfc8791d2a139c7409470">&#9670;&nbsp;</a></span>TimedWaitAny() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">nn::os::MultiWaitHolderType</a> * nn::os::TimedWaitAny </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *&#160;</td>
          <td class="paramname"><em>multiWait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for any of the <code><em>multiWaitHolder</em></code> objects in the <code><em>multiWait</em></code> list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWait</td><td>Pointer to a multiwait object header. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Timeout value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the <code><em>multiWaitHolder</em></code> object with its state changed to signaled. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000116">Return Values:</a></b></dt><dd><b>NULL</b> Timeout.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>multiWait</em></code> is in an initialized state.</li>
<li>All <code><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="This structure defines a multiwait object holder.">MultiWaitHolderType</a></code> objects connected to <code><em>multiWait</em></code> are in an initialized state.</li>
<li><code><em>multiWait</em></code> is not being used in another thread.</li>
<li><code><em>timeout</em></code> &gt;= <code>0</code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If a change to signaled state is detected in any of the multiwait objects:<ul>
<li>Returns a pointer to the <code><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="This structure defines a multiwait object holder.">MultiWaitHolderType</a></code> that detected the signal.</li>
</ul>
</li>
<li>If a change to signaled state is not detected in any of the multiwait objects:<ul>
<li>Returns <code>NULL</code>.</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Waits for any of the <code><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="This structure defines a multiwait object holder.">MultiWaitHolderType</a></code> objects linked to the <em>multiWait</em> list header to enter a signaled state. If the amount of time specified by <em>timeout</em> elapses after the current thread starts waiting, a timeout occurs and the thread automatically stops waiting. In such cases, the function returns <code>NULL</code>.</p>
<p>For more information about timeout behavior, see the cautions in <a class="el" href="_page_notification_os_timeout.html">OS-API Timeouts</a>.</p>
<p>The target object state does not change its signal state after an object's signal state is detected and returns a non-<code>NULL</code> value. For more information, see <a class="el" href="_page_notification_os_multi_wait.html#PageNotificationOsMultiWait_AboutWakeup">Waking a multiwait PageNotificationOsMultiWait_AboutWakeup</a>.</p>
<p><code>multiWait</code> must not be used in another thread. Specifically, operations against a <code><em>multiWait</em></code> or a multiwait using a specified <code><em>multiWait</em></code> must not be executed at the same time in a different thread before returning from <code><a class="el" href="namespacenn_1_1os.html#a6a76f1be743cfc8791d2a139c7409470" title="Waits for any of the multiWaitHolder objects in the multiWait list.">TimedWaitAny()</a></code>. </p>

</div>
</div>
<a id="a2de358e6bfa261b74c399b5b59c0da1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de358e6bfa261b74c399b5b59c0da1d">&#9670;&nbsp;</a></span>FinalizeMultiWaitHolder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FinalizeMultiWaitHolder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *&#160;</td>
          <td class="paramname"><em>multiWaitHolder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalizes a <code><em>multiWaitHolder</em></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWaitHolder</td><td>Pointer to a multiwait object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>multiWaitHolder</em></code> is in an initialized state.</li>
<li><code><em>multiWaitHolder</em></code> is not linked to any lists.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>multiWaitHolder</em></code> is in an uninitialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Finalizes <em>multiWaitHolder</em>. If the object specified in <em>multiWaitHolder</em> is linked to a list, the function fails on an assert.</p>
<p>This function is not thread-safe. Do not manipulate the object specified in <em>multiWaitHolder</em> while this function is being called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a68">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_access_point_2_ldn_access_point_8cpp-example.html#a35">LdnBasic/LdnAccessPoint/LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_station_2_ldn_station_8cpp-example.html#a29">LdnBasic/LdnStation/LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a56">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_2_movie_player_simple_8cpp-example.html#a18">MoviePlayerSimple/MoviePlayerSimple.cpp</a>, and <a class="el" href="_os_multi_wait_2_os_multi_wait_8cpp-example.html#a20">OsMultiWait/OsMultiWait.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a7cd9b25e14bee063959eb9e7f62a4aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd9b25e14bee063959eb9e7f62a4aa8">&#9670;&nbsp;</a></span>LinkMultiWaitHolder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::LinkMultiWaitHolder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *&#160;</td>
          <td class="paramname"><em>multiWait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *&#160;</td>
          <td class="paramname"><em>multiWaitHolder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Links a <code><em>multiWaitHolder</em></code> object to a <code><em>multiWait</em></code> object header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWait</td><td>Pointer to a multiwait object header. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWaitHolder</td><td>Pointer to a multiwait object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>multiWait</em></code> is in an initialized state.</li>
<li><code><em>multiWaitHolder</em></code> is in an initialized state.</li>
<li><code><em>multiWaitHolder</em></code> is not linked to any lists.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The <code><em>multiWaitHolder</em></code> object is linked to the <code><em>multiWait</em></code> list.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Links the multiwait object in <code><em>multiWaitHolder</em></code> to the multiwait object header in <code><em>multiWait</em></code>. Linked <code><em>multiWaitHolder</em></code>. When <code><em>multiWait</em></code> is passed to one of the <code><a class="el" href="namespacenn_1_1os.html#ab9b837eb53fa2c8a9610cec2b69666fd" title="Waits for any of the multiWaitHolder objects in the multiWait list.">WaitAny()</a></code> functions, the object becomes one of the synchronization objects waiting for a change to the signaled state.</p>
<p>This function is not thread-safe. Do not operate on the target <code><em>multiWait</em></code> and <code><em>multiWaitHolder</em></code> objects while this function is being called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a66">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_access_point_2_ldn_access_point_8cpp-example.html#a18">LdnBasic/LdnAccessPoint/LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_station_2_ldn_station_8cpp-example.html#a18">LdnBasic/LdnStation/LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a104">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_2_movie_player_simple_8cpp-example.html#a28">MoviePlayerSimple/MoviePlayerSimple.cpp</a>, and <a class="el" href="_os_multi_wait_2_os_multi_wait_8cpp-example.html#a16">OsMultiWait/OsMultiWait.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a07c9c7bbc51249b69dc2361957fd650b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c9c7bbc51249b69dc2361957fd650b">&#9670;&nbsp;</a></span>UnlinkMultiWaitHolder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::UnlinkMultiWaitHolder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *&#160;</td>
          <td class="paramname"><em>multiWaitHolder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlinks the <code><em>multiWaitHolder</em></code> object from the <code><em>multiWait</em></code> header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWaitHolder</td><td>Pointer to a multiwait object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>multiWaitHolder</em></code> is in an initialized state.</li>
<li><code><em>multiWaitHolder</em></code> is linked to the <code><em>multiWait</em></code> list.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>multiWaitHolder</em></code> is not linked to any lists.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Unlinks the multiwait object in <code><em>multiWaitHolder</em></code> from the linked multiwait object header. The unlinked <code><em>multiWaitHolder</em></code> object is no longer linked to any list headers.</p>
<p>This function is not thread-safe. Do not operate on the target <code><em>multiWait</em></code> and <code><em>multiWaitHolder</em></code> objects while this function is being called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a67">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_access_point_2_ldn_access_point_8cpp-example.html#a34">LdnBasic/LdnAccessPoint/LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_station_2_ldn_station_8cpp-example.html#a28">LdnBasic/LdnStation/LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a109">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_2_movie_player_simple_8cpp-example.html#a17">MoviePlayerSimple/MoviePlayerSimple.cpp</a>, and <a class="el" href="_os_multi_wait_2_os_multi_wait_8cpp-example.html#a19">OsMultiWait/OsMultiWait.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a7bdfded3152755dfd1fadb8eeea4565e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bdfded3152755dfd1fadb8eeea4565e">&#9670;&nbsp;</a></span>UnlinkAllMultiWaitHolder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::UnlinkAllMultiWaitHolder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *&#160;</td>
          <td class="paramname"><em>multiWait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlinks all <code><em>multiWaitHolder</em></code> objects linked to the <code><em>multiWait</em></code> header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWait</td><td>Pointer to a multiwait object header.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>multiWait</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The multiwait object holder that was linked to <code><em>multiWait</em></code> is no longer linked to any list.</li>
<li>There are no multiwait object holders linked to the <code><em>multiWait</em></code> list.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Unlinks all multiwait object holders linked to the multiwait object header in <code><em>multiWait</em></code>. The unlinked multiwait object holders are no longer linked to any list headers.</p>
<p>This function is not thread-safe. Do not perform operations on the target <code><em>multiWait</em></code> object or the linked multiwait object holders while this function is being called. </p>

</div>
</div>
<a id="ab8fb5f6b288f3b208f0d4750d0ba079d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8fb5f6b288f3b208f0d4750d0ba079d">&#9670;&nbsp;</a></span>MoveAllMultiWaitHolder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::MoveAllMultiWaitHolder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *&#160;</td>
          <td class="paramname"><em>dstMultiWait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *&#160;</td>
          <td class="paramname"><em>srcMultiWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlinks all <code><em>multiWaitHolder</em></code> objects linked to the <code><em>srcMultiWait</em></code> header and links them to <code><em>dstMultiWait</em></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dstMultiWait</td><td>Pointer to the multiwait object header to link to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcMultiWait</td><td>Pointer to the linked multiwait object header.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>dstMultiWait</em></code> is in an initialized state.</li>
<li><code><em>srcMultiWait</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>All of the following become linked to <code><em>dstMultiWait</em></code>.<ul>
<li>All multiwait object holders that were linked to <code><em>dstMultiWait</em></code> before this function was called.</li>
<li>All multiwait object holders that were linked to <code><em>srcMultiWait</em></code> before this function was called.</li>
</ul>
</li>
<li>No multiwait object holders are linked to the <code><em>srcMultiWait</em></code> list.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Unlinks all multiwait object holders that were linked to the multiwait object header pointed to by <code><em>srcMultiWait</em></code>, and instead links them to <code><em>dstMultiWait</em></code>.</p>
<p>This function is not thread-safe. Do not perform operations on the target <code><em>dstMultiWait</em></code> and <code><em>srcMultiWait</em></code> objects or on the multiwait object holders linked to them while this function is being called. </p>

</div>
</div>
<a id="a05af1a7e142f1ece42a53fe41085f53b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05af1a7e142f1ece42a53fe41085f53b">&#9670;&nbsp;</a></span>SetMultiWaitHolderUserData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SetMultiWaitHolderUserData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *&#160;</td>
          <td class="paramname"><em>multiWaitHolder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>userData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a user data value in the <code>multiWaitHolder</code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWaitHolder</td><td>Pointer to a multiwait object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userData</td><td>Value to set as user data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>multiWaitHolder</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>multiWaitHolder</em></code> is in an initialized state. (Only the user data changes.)</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sets a user data value in the <code><em>multiWaitHolder</em></code> object.</p>
<p>This function is not thread-safe. Do not perform operations on the object specified in <code><em>multiWaitHolder</em></code> while this function is being called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a65">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_movie_player_simple_2_movie_player_simple_8cpp-example.html#a30">MoviePlayerSimple/MoviePlayerSimple.cpp</a>, and <a class="el" href="_os_multi_wait_2_os_multi_wait_8cpp-example.html#a13">OsMultiWait/OsMultiWait.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a9e8c73312415fc00c72808fcc00fea33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8c73312415fc00c72808fcc00fea33">&#9670;&nbsp;</a></span>GetMultiWaitHolderUserData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uintptr_t nn::os::GetMultiWaitHolderUserData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *&#160;</td>
          <td class="paramname"><em>multiWaitHolder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the user data set in a <code><em>multiWaitHolder</em></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWaitHolder</td><td>Pointer to a multiwait object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value set as user data.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>multiWaitHolder</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>multiWaitHolder</em></code> is in an initialized state. (No changes.)</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the user data value set in the <code><em>multiWaitHolder</em></code> object. The default value immediately after each call to <code><a class="el" href="namespacenn_1_1os.html#a4f8d998425d067cb5fec2604ae7845dc" title="Initializes a multiWaitHolder object and binds it to an event.">InitializeMultiWaitHolder()</a></code> is <code>0</code>.</p>
<p>This function is not thread-safe. Do not perform operations on the object specified in <code><em>multiWaitHolder</em></code> while this function is being called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a75">AudioEchoback/AudioEchoback.cpp</a>, and <a class="el" href="_os_multi_wait_2_os_multi_wait_8cpp-example.html#a18">OsMultiWait/OsMultiWait.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a22c4b696270b511328e43c40e30a53f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22c4b696270b511328e43c40e30a53f6">&#9670;&nbsp;</a></span>WaitAny() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a>*, int&gt; nn::os::WaitAny </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *&#160;</td>
          <td class="paramname"><em>pMultiWait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts a <code>multiWaitHolder</code> object in a <code>multiWait</code> list on standby, or puts multiple specified objects on standby (for objects that support standby). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Variable-length parameter for additional standby objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pMultiWait</td><td>Pointer to a <code><em>multiWait</em></code> object header. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable-length parameter for objects that support standby.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>{ p, -1 }</code> if a <code><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="This structure defines a multiwait object holder.">MultiWaitHolderType</a></code> object linked to <code><em>pMultiWait</em></code> is signaled (where <code><em>p</em></code> is the corresponding pointer). Returns <code>{ nullptr, n }</code> if an object specified for <code><em>args</em></code> is signaled (where <code><em>n</em></code> is a zero-based index in <code><em>args</em></code>).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>multiWait</em></code> is in an initialized state.</li>
<li>All <code><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="This structure defines a multiwait object holder.">MultiWaitHolderType</a></code> objects connected to <code><em>multiWait</em></code> are in an initialized state.</li>
<li><code><em>multiWait</em></code> is not being used in another thread.</li>
<li><code>InitializeMultiWaitHolder(<em>pHolder</em>, <em>x</em>)</code> can be called correctly for each parameter <code><em>x</em></code> in <code><em>args</em></code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>An object that supports standby and corresponds to the returned value was signaled.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is the same as <code><a class="el" href="namespacenn_1_1os.html#ab9b837eb53fa2c8a9610cec2b69666fd" title="Waits for any of the multiWaitHolder objects in the multiWait list.">WaitAny(MultiWaitType*)</a></code> except for how standby targets are specified and how results are returned.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenn_1_1os.html#ab9b837eb53fa2c8a9610cec2b69666fd" title="Waits for any of the multiWaitHolder objects in the multiWait list.">WaitAny(MultiWaitType*)</a> </dd></dl>

</div>
</div>
<a id="a3c212b9d05d000b8d34dabf2b65ec367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c212b9d05d000b8d34dabf2b65ec367">&#9670;&nbsp;</a></span>WaitAny() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int nn::os::WaitAny </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts multiple specified objects on standby (for objects that support standby). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Variable-length parameter for standby objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable-length parameter for objects that support standby.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the zero-based indices of the signaled objects in <code>args</code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code>InitializeMultiWaitHolder(<em>pHolder</em>, <em>x</em>)</code> can be called correctly for each parameter <code><em>x</em></code> in <code><em>args</em></code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>An object that supports standby and corresponds to the returned value was signaled.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is the same as <code><a class="el" href="namespacenn_1_1os.html#ab9b837eb53fa2c8a9610cec2b69666fd" title="Waits for any of the multiWaitHolder objects in the multiWait list.">WaitAny(MultiWaitType*)</a></code> except for how standby targets are specified and how results are returned.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenn_1_1os.html#ab9b837eb53fa2c8a9610cec2b69666fd" title="Waits for any of the multiWaitHolder objects in the multiWait list.">WaitAny(MultiWaitType*)</a> </dd></dl>

</div>
</div>
<a id="a8fab21890e314a0c21f95cad61bfb8ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fab21890e314a0c21f95cad61bfb8ef">&#9670;&nbsp;</a></span>TryWaitAny() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a>*, int&gt; nn::os::TryWaitAny </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *&#160;</td>
          <td class="paramname"><em>pMultiWait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Polls a <code>multiWaitHolder</code> object in a <code>multiWait</code> list, or polls multiple specified objects (for objects that support standby). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Variable-length parameter for additional standby objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pMultiWait</td><td>Pointer to a <code><em>multiWait</em></code> object header. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable-length parameter for objects that support standby.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>{ p, -1 }</code> if a <code><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="This structure defines a multiwait object holder.">MultiWaitHolderType</a></code> object linked to <code><em>pMultiWait</em></code> is signaled (where <code><em>p</em></code> is the corresponding pointer). Returns <code>{ nullptr, n }</code> if an object specified for <code><em>args</em></code> is signaled (where <code><em>n</em></code> is a zero-based index in <code><em>args</em></code>). Returns <code>{ nullptr, -1 }</code> if neither type of object is signaled.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>multiWait</em></code> is in an initialized state.</li>
<li>All <code><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="This structure defines a multiwait object holder.">MultiWaitHolderType</a></code> objects connected to <code><em>multiWait</em></code> are in an initialized state.</li>
<li><code><em>multiWait</em></code> is not being used in another thread.</li>
<li><code>InitializeMultiWaitHolder(<em>pHolder</em>, <em>x</em>)</code> can be called correctly for each parameter <code><em>x</em></code> in <code><em>args</em></code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>When the return value is not <code>{ nullptr, -1 }</code>, an object that supports standby and corresponds to the returned value was signaled.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is the same as <code><a class="el" href="namespacenn_1_1os.html#add056696d279031175e9053145c82677" title="Polls for any of the multiWaitHolder objects in the multiWait list.">TryWaitAny(MultiWaitType*)</a></code> except for how standby targets are specified and how results are returned.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenn_1_1os.html#add056696d279031175e9053145c82677" title="Polls for any of the multiWaitHolder objects in the multiWait list.">TryWaitAny(MultiWaitType*)</a> </dd></dl>

</div>
</div>
<a id="a8351902f4ee90954cb0332ae741bb925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8351902f4ee90954cb0332ae741bb925">&#9670;&nbsp;</a></span>TryWaitAny() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int nn::os::TryWaitAny </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Polls multiple specified objects (for objects that support standby). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Variable-length parameter for standby objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable-length parameter for objects that support standby.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the zero-based indices of the signaled objects in <code><em>args</em></code>. Returns <code>-1</code> if no objects are signaled.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code>InitializeMultiWaitHolder(<em>pHolder</em>, <em>x</em>)</code> can be called correctly for each parameter <code><em>x</em></code> in <code><em>args</em></code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>When the return value is greater than or equal to 0, an object that supports standby and corresponds to the returned value was signaled.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is the same as <code><a class="el" href="namespacenn_1_1os.html#add056696d279031175e9053145c82677" title="Polls for any of the multiWaitHolder objects in the multiWait list.">TryWaitAny(MultiWaitType*)</a></code> except for how standby targets are specified and how results are returned.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenn_1_1os.html#add056696d279031175e9053145c82677" title="Polls for any of the multiWaitHolder objects in the multiWait list.">TryWaitAny(MultiWaitType*)</a> </dd></dl>

</div>
</div>
<a id="adcae3cbfea9890fd7b1ace389192094c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcae3cbfea9890fd7b1ace389192094c">&#9670;&nbsp;</a></span>TimedWaitAny() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a>*, int&gt; nn::os::TimedWaitAny </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *&#160;</td>
          <td class="paramname"><em>pMultiWait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts a <code>multiWaitHolder</code> object in a <code>multiWait</code> list on standby with a timeout, or puts multiple specified objects on standby with a timeout (for objects that support standby). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Variable-length parameter for additional standby objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pMultiWait</td><td>Pointer to a <code><em>multiWait</em></code> object header. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Timeout value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable-length parameter for objects that support standby.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>{ p, -1 }</code> if a <code><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="This structure defines a multiwait object holder.">MultiWaitHolderType</a></code> object linked to <code><em>pMultiWait</em></code> is signaled (where <code><em>p</em></code> is the corresponding pointer). Returns <code>{ nullptr, n }</code> if an object specified for <code><em>args</em></code> is signaled (where <code><em>n</em></code> is a zero-based index in <code><em>args</em></code>). Returns <code>{ nullptr, -1 }</code> if neither type of object is signaled within the specified timeout time.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>multiWait</em></code> is in an initialized state.</li>
<li>All <code><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="This structure defines a multiwait object holder.">MultiWaitHolderType</a></code> objects connected to <code><em>multiWait</em></code> are in an initialized state.</li>
<li><code><em>multiWait</em></code> is not being used in another thread.</li>
<li><code><em>timeout</em></code> &gt;= <code>0</code>.</li>
<li><code>InitializeMultiWaitHolder(<em>pHolder</em>, <em>x</em>)</code> can be called correctly for each parameter <code><em>x</em></code> in <code><em>args</em></code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>When the return value is not <code>{ nullptr, -1 }</code>, an object that supports standby and corresponds to the returned value was signaled.</li>
<li>When the return value is <code>{ nullptr, -1 }</code>, the time specified for <code><em>timeout</em></code> has elapsed since the function was called.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is the same as <code><a class="el" href="namespacenn_1_1os.html#a6a76f1be743cfc8791d2a139c7409470" title="Waits for any of the multiWaitHolder objects in the multiWait list.">TimedWaitAny(MultiWaitType*, TimeSpan)</a></code> except for how standby targets are specified and how results are returned.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenn_1_1os.html#a6a76f1be743cfc8791d2a139c7409470" title="Waits for any of the multiWaitHolder objects in the multiWait list.">TimedWaitAny(MultiWaitType*, TimeSpan)</a> </dd></dl>

</div>
</div>
<a id="ab095940b13b3c3b338c3b5c76ffb7b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab095940b13b3c3b338c3b5c76ffb7b24">&#9670;&nbsp;</a></span>TimedWaitAny() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int nn::os::TimedWaitAny </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts multiple specified objects on standby with a timeout (for objects that support standby). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Variable-length parameter for standby objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Timeout value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable-length parameter for objects that support standby.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the zero-based indices of the signaled objects in <code><em>args</em></code>. Returns <code>-1</code> if no objects are signaled within the specified timeout time.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>timeout</em></code> &gt;= <code>0</code>.</li>
<li><code>InitializeMultiWaitHolder(<em>pHolder</em>, <em>x</em>)</code> can be called correctly for each parameter <code><em>x</em></code> in <code><em>args</em></code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>When the return value is greater than or equal to 0, an object that supports standby and corresponds to the returned value was signaled.</li>
<li>When the return value is <code>-1</code>, the time specified for <code><em>timeout</em></code> has elapsed since the function was called.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function is the same as <code><a class="el" href="namespacenn_1_1os.html#a6a76f1be743cfc8791d2a139c7409470" title="Waits for any of the multiWaitHolder objects in the multiWait list.">TimedWaitAny(MultiWaitType*, TimeSpan)</a></code> except for how standby targets are specified and how results are returned.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenn_1_1os.html#a6a76f1be743cfc8791d2a139c7409470" title="Waits for any of the multiWaitHolder objects in the multiWait list.">TimedWaitAny(MultiWaitType*, TimeSpan)</a> </dd></dl>

</div>
</div>
<a id="a0a434b3b646d4fafdc951f63fa3a4689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a434b3b646d4fafdc951f63fa3a4689">&#9670;&nbsp;</a></span>operator&amp;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">detail::MessageQueueWaitMultiWaitHelper nn::os::operator&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1os.html#a3271c9fc6c46cffdb076b966f15a80bc">MessageQueueWaitType</a>&#160;</td>
          <td class="paramname"><em>waitType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility for specifying a message queue for the multiwait utility. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>Pointer to the message queue to bind to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">waitType</td><td>Wait type of the message queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>messageQueue</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the value to pass to the multiwait utility.</dd></dl>
<p> <b>Details</b> <br  />
 When the return value from this function is passed to a multiwait utility function, the standby targets go into the type of standby specified for <code><em>waitType</em></code> in the message queue specified for <code><em>messageQueue</em></code>. </p>

</div>
</div>
<a id="a8d0a550df15490a884932a062dc26533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d0a550df15490a884932a062dc26533">&#9670;&nbsp;</a></span>InitializeMutex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeMutex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *&#160;</td>
          <td class="paramname"><em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recursive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lockLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a <code><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="This structure defines a mutex object.">MutexType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="This structure defines a mutex object.">MutexType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recursive</td><td>Whether to allow recursive locking in the mutex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lockLevel</td><td>The lock level.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>mutex</em></code> is in an uninitialized state or has not been initialized.</li>
<li><code><em>lockLevel</em></code> == <code>0</code>. || ( <code><a class="el" href="namespacenn_1_1os.html#aafb8cce9509759efcb7b1080b20ca960" title="This constant represents the minimum value of a mutex lock level.">nn::os::MutexLockLevelMin</a></code> &lt;= <code><em>lockLevel</em></code> &lt;= <code><a class="el" href="namespacenn_1_1os.html#a20b0e2596b8091c49374130b049168f6" title="This constant represents the maximum value of a mutex lock level.">nn::os::MutexLockLevelMax</a></code>. )</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>mutex</em></code> is in an unlocked state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Initializes a mutex object.</p>
<p>Set <code><em>recursive</em></code> to <code>true</code> to enable recursive locks, or <code>false</code> to disable recursive locks.</p>
<p>Specify a range from <code><a class="el" href="namespacenn_1_1os.html#aafb8cce9509759efcb7b1080b20ca960" title="This constant represents the minimum value of a mutex lock level.">nn::os::MutexLockLevelMin</a></code> (the minimum value) to <code><a class="el" href="namespacenn_1_1os.html#a20b0e2596b8091c49374130b049168f6" title="This constant represents the maximum value of a mutex lock level.">nn::os::MutexLockLevelMax</a></code> (the maximum value) in <code><em>lockLevel</em></code> for the lock levels to set on the mutex. Specify <code>0</code> to skip the lock level check. The lock level feature is disabled in the Release build in order to boost processing speed.</p>
<p>The lock level feature monitors the order in which the mutex is locked or unlocked for debugging purposes. Each thread logs the lock level value every time it is changed by a lock operation, and compares the values when locking or unlocking.</p>
<p>The specifics are as follows.</p>
<p>First, the lock operation behaves as follows depending on how <code><em>recursive</em></code> is set. When <code><em>recursive</em></code> == <code>true</code>, a lock on <code><em>mutex</em></code> only succeeds if the lock level is equal to or greater than the <code><em>lockLevel</em></code> of the mutex. When <code><em>recursive</em></code> == <code>false</code>, it only succeeds if the lock level is greater than the <code><em>lockLevel</em></code> of the mutex.</p>
<p>In either case, if the <code><em>lockLevel</em></code> value is less than the current lock level of the current thread, the function detects an invalid lock operation, causing an assertion failure.</p>
<p>An unlock operation, on the other hand, only succeeds if the <code><em>lockLevel</em></code> value is equal to the current lock level of the current thread. The lock log then reverts to the state it was in prior to the lock. If the <code><em>lockLevel</em></code> value is not equivalent to the current lock level, the function detects an invalid lock operation and causes an assertion failure.</p>
<p>There is also an <code><a class="el" href="os___mutex_api_8h.html#a90be4df5dbd89de101035979076507a8">NN_OS_MUTEX_INITIALIZER()</a></code> macro to statically initialize a mutex.</p>
<p>This function is not thread-safe. Do not manipulate the object specified in <code><em>mutex</em></code> while this function is being called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__main_8cpp-example.html#a10">HidControllerSequence/HidControllerSequence_Main.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_access_point_2_ldn_access_point_8cpp-example.html#a103">LdnBasic/LdnAccessPoint/LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_station_2_ldn_station_8cpp-example.html#a102">LdnBasic/LdnStation/LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a47">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_nvn_tutorial_2_render_thread_pool_8cpp-example.html#a3">NvnTutorial/RenderThreadPool.cpp</a>, <a class="el" href="_nvn_tutorial04_multi_threaded_asset_file_loading_2_nvn_tutorial04_8cpp-example.html#a28">NvnTutorial04MultiThreadedAssetFileLoading/NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial06_frame_buffering_2_nvn_tutorial06_8cpp-example.html#a27">NvnTutorial06FrameBuffering/NvnTutorial06.cpp</a>, <a class="el" href="_os_condition_variable_2_os_condition_variable_8cpp-example.html#a11">OsConditionVariable/OsConditionVariable.cpp</a>, <a class="el" href="_os_mutex_2_os_mutex_8cpp-example.html#a7">OsMutex/OsMutex.cpp</a>, and <a class="el" href="_profiler_thread_state_2_profiler_thread_state_8cpp-example.html#a6">ProfilerThreadState/ProfilerThreadState.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a8ce43d38754bf3049ab8d60b9d9e0046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce43d38754bf3049ab8d60b9d9e0046">&#9670;&nbsp;</a></span>FinalizeMutex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FinalizeMutex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalizes a <code><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="This structure defines a mutex object.">MutexType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="This structure defines a mutex object.">MutexType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>mutex</em></code> is in an unlocked state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>mutex</em></code> is in an uninitialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Finalizes a <code><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="This structure defines a mutex object.">MutexType</a></code> object.</p>
<p>This function is not thread-safe. Do not manipulate the object specified in <code><em>mutex</em></code> while this function is being called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ldn_basic_2_ldn_access_point_2_ldn_access_point_8cpp-example.html#a105">LdnBasic/LdnAccessPoint/LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_station_2_ldn_station_8cpp-example.html#a103">LdnBasic/LdnStation/LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a58">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_nvn_tutorial_2_render_thread_pool_8cpp-example.html#a0">NvnTutorial/RenderThreadPool.cpp</a>, <a class="el" href="_nvn_tutorial04_multi_threaded_asset_file_loading_2_nvn_tutorial04_8cpp-example.html#a39">NvnTutorial04MultiThreadedAssetFileLoading/NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial06_frame_buffering_2_nvn_tutorial06_8cpp-example.html#a43">NvnTutorial06FrameBuffering/NvnTutorial06.cpp</a>, <a class="el" href="_os_condition_variable_2_os_condition_variable_8cpp-example.html#a19">OsConditionVariable/OsConditionVariable.cpp</a>, <a class="el" href="_os_mutex_2_os_mutex_8cpp-example.html#a16">OsMutex/OsMutex.cpp</a>, and <a class="el" href="_profiler_thread_state_2_profiler_thread_state_8cpp-example.html#a23">ProfilerThreadState/ProfilerThreadState.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a8d4678856d87c3faea21f47ced342bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d4678856d87c3faea21f47ced342bb6">&#9670;&nbsp;</a></span>LockMutex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::LockMutex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locks a <code><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="This structure defines a mutex object.">MutexType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="This structure defines a mutex object.">MutexType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>mutex</em></code> is in one of the following states.<ul>
<li>With <code><em>recursive</em></code> == <code>false</code>, <code><em>mutex</em></code> is in an unlocked state or is locked by another thread.</li>
<li>With <code><em>recursive</em></code> == <code>true</code>, <code><em>mutex</em></code> is in an initialized state.</li>
</ul>
</li>
<li>When <code><em>lockLevel</em></code> &gt; <code>0</code>, the following precondition also applies.<ul>
<li><code><em>lockLevel</em></code> is higher than the current lock level of the current thread.</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>mutex</em></code> is in a current thread locked state.</li>
<li>The current lock counter is incremented.</li>
<li>When <code><em>lockLevel</em></code> &gt; <code>0</code> for <code><em>mutex</em></code>, the following postcondition also applies.<ul>
<li>The current lock level of the current thread is set to the <code><em>lockLevel</em></code>.</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Locks the specified mutex. The lock operation succeeds if the target mutex is unlocked.</p>
<p>If the target mutex is already in a locked state and owned by another thread, the current thread enters a waiting state.</p>
<p>If the target mutex is already in a locked state and owned by the current thread, the behavior varies as follows depending on the <code><em>recursive</em></code> value when the mutex was initialized.</p>
<p>When <code><em>recursive</em></code> == <code>true</code>, the recursive lock succeeds, and the function immediately returns. When <code><em>recursive</em></code> == <em>false</em>, the preconditions are violated, and the function causes an assertion failure.</p>
<p>If <code><em>mutex</em></code> has a <code>lockLevel</code> of <code>1</code> or greater, the lock level is checked when the lock is obtained. For more information about the lock level feature, see <code><a class="el" href="namespacenn_1_1os.html#a8d0a550df15490a884932a062dc26533" title="Initializes a MutexType object.">InitializeMutex()</a></code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__game_8cpp-example.html#a45">HidControllerSequence/HidControllerSequence_Game.cpp</a>, <a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__main_8cpp-example.html#a27">HidControllerSequence/HidControllerSequence_Main.cpp</a>, <a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__start_8cpp-example.html#a1">HidControllerSequence/HidControllerSequence_Start.cpp</a>, <a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__title_8cpp-example.html#a3">HidControllerSequence/HidControllerSequence_Title.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_access_point_2_ldn_access_point_8cpp-example.html#a32">LdnBasic/LdnAccessPoint/LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_station_2_ldn_station_8cpp-example.html#a26">LdnBasic/LdnStation/LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a92">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_nvn_tutorial_2_multi_threaded_asset_file_loading_helper_8cpp-example.html#a17">NvnTutorial/MultiThreadedAssetFileLoadingHelper.cpp</a>, <a class="el" href="_nvn_tutorial_2_render_thread_pool_8cpp-example.html#a6">NvnTutorial/RenderThreadPool.cpp</a>, <a class="el" href="_os_condition_variable_2_os_condition_variable_8cpp-example.html#a3">OsConditionVariable/OsConditionVariable.cpp</a>, <a class="el" href="_os_mutex_2_os_mutex_8cpp-example.html#a3">OsMutex/OsMutex.cpp</a>, and <a class="el" href="_profiler_thread_state_2_profiler_thread_state_8cpp-example.html#a2">ProfilerThreadState/ProfilerThreadState.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af32963cc501eefcb10a0ebb993080b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af32963cc501eefcb10a0ebb993080b9f">&#9670;&nbsp;</a></span>TryLockMutex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TryLockMutex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to get a lock with a <code><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="This structure defines a mutex object.">MutexType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="This structure defines a mutex object.">MutexType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether the mutex was successfully obtained.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>mutex</em></code> is in one of the following states.<ul>
<li>With <code><em>recursive</em></code> == <code>false</code>, <code><em>mutex</em></code> is in an unlocked state or is locked by another thread.</li>
<li>With <code><em>recursive</em></code> == <code>true</code>, <code><em>mutex</em></code> is in an initialized state.</li>
</ul>
</li>
<li>When <code><em>lockLevel</em></code> &gt; <code>0</code>, the following precondition also applies.<ul>
<li><code><em>lockLevel</em></code> is higher than the current lock level of the current thread.</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the return value is <code>true</code>:<ul>
<li><code><em>mutex</em></code> is in a current thread locked state.</li>
<li>The current lock counter is incremented.</li>
<li>When <code><em>lockLevel</em></code> &gt; <code>0</code> for <code><em>mutex</em></code>, the following postcondition also applies.<ul>
<li>The current lock level of the current thread is set to the <code><em>lockLevel</em></code>.</li>
</ul>
</li>
</ul>
</li>
<li>If the return value is <code>false</code>:<ul>
<li>The state of <code><em>mutex</em></code> does not change from that of the preconditions.</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Attempts to lock the specified mutex. If the target mutex is unlocked, the lock succeeds and the function returns <code>true</code>.</p>
<p>If the target mutex is already in a locked state and owned by another thread, the current thread does not wait and function returns <code>false</code>.</p>
<p>If the target mutex is already in a locked state and owned by the current thread, the behavior varies as follows depending on the <code><em>recursive</em></code> value when the mutex was initialized.</p>
<p>When <code><em>recursive</em></code> == <code>true</code>, the recursive lock succeeds, and the function returns <code>true</code>. When <code><em>recursive</em></code> == <em>false</em>, the preconditions are violated, and the function causes an assertion failure.</p>
<p>If <code><em>mutex</em></code> has a <code>lockLevel</code> of <code>1</code> or greater, the lock level is checked when the lock is obtained. For more information about the lock level feature, see <code><a class="el" href="namespacenn_1_1os.html#a8d0a550df15490a884932a062dc26533" title="Initializes a MutexType object.">InitializeMutex()</a></code>. </p>

</div>
</div>
<a id="aa661a7036a18c378a694ad67941cd75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa661a7036a18c378a694ad67941cd75e">&#9670;&nbsp;</a></span>UnlockMutex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::UnlockMutex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlocks a <code><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="This structure defines a mutex object.">MutexType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="This structure defines a mutex object.">MutexType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>mutex</em></code> is in one of the following states.<ul>
<li>When <code><em>recursive</em></code> == <code>false</code>, <code><em>mutex</em></code> is in a locked state.</li>
<li>When <code><em>recursive</em></code> == <code>true</code>, <code><em>mutex</em></code> is in a locked state or a recursive locked state.</li>
</ul>
</li>
<li>The lock owner of the <code><em>mutex</em></code> is the current thread.</li>
<li>When <code><em>lockLevel</em></code> &gt; <code>0</code> for <code><em>mutex</em></code>, the following precondition also applies.<ul>
<li>The <code><em>lockLevel</em></code> is equal to the current lock level of the current thread.</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The lock counter is decremented.</li>
<li>When the lock counter reaches <code>0</code>, <code><em>mutex</em></code> is in an unlocked state.</li>
<li>When <code><em>lockLevel</em></code> &gt; <code>0</code> for <code><em>mutex</em></code>, the following precondition also applies.<ul>
<li>The current lock level of the current thread is set to the lock level prior to locking <code><em>mutex</em></code>.</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Unlocks the specified mutex.</p>
<p>If the target mutex is not locked, or if it is locked and owned by another thread, the function causes an assertion failure.</p>
<p>After a mutex is successfully unlocked, if there is a thread waiting for that mutex, it stops waiting.</p>
<p>If <code><em>mutex</em></code> has a <code>lockLevel</code> of <code>1</code> or greater, the lock level is checked when unlocking. For more information about the lock level feature, see <code><a class="el" href="namespacenn_1_1os.html#a8d0a550df15490a884932a062dc26533" title="Initializes a MutexType object.">InitializeMutex()</a></code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__game_8cpp-example.html#a46">HidControllerSequence/HidControllerSequence_Game.cpp</a>, <a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__main_8cpp-example.html#a30">HidControllerSequence/HidControllerSequence_Main.cpp</a>, <a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__start_8cpp-example.html#a2">HidControllerSequence/HidControllerSequence_Start.cpp</a>, <a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__title_8cpp-example.html#a4">HidControllerSequence/HidControllerSequence_Title.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_access_point_2_ldn_access_point_8cpp-example.html#a33">LdnBasic/LdnAccessPoint/LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_station_2_ldn_station_8cpp-example.html#a27">LdnBasic/LdnStation/LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a93">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_nvn_tutorial_2_multi_threaded_asset_file_loading_helper_8cpp-example.html#a18">NvnTutorial/MultiThreadedAssetFileLoadingHelper.cpp</a>, <a class="el" href="_nvn_tutorial_2_render_thread_pool_8cpp-example.html#a7">NvnTutorial/RenderThreadPool.cpp</a>, <a class="el" href="_os_condition_variable_2_os_condition_variable_8cpp-example.html#a6">OsConditionVariable/OsConditionVariable.cpp</a>, <a class="el" href="_os_mutex_2_os_mutex_8cpp-example.html#a4">OsMutex/OsMutex.cpp</a>, and <a class="el" href="_profiler_thread_state_2_profiler_thread_state_8cpp-example.html#a3">ProfilerThreadState/ProfilerThreadState.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3a2107dd611741af2a44adf2dad29c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2107dd611741af2a44adf2dad29c74">&#9670;&nbsp;</a></span>IsMutexLockedByCurrentThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::IsMutexLockedByCurrentThread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a <code><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="This structure defines a mutex object.">MutexType</a></code> object has been locked by the current thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="This structure defines a mutex object.">MutexType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether the mutex has been obtained by the current thread.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>mutex</em></code> is either locked or unlocked.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Returns <code>true</code> if the object specified by <code><em>mutex</em></code> has been obtained by the current thread, or <code>false</code> otherwise. This function does not change the state of the object specified by <code><em>mutex</em></code>.</p>
<p>This function is used primarily to assert that the object specified by <code><em>mutex</em></code> is definitely locked by the current thread. </p>

</div>
</div>
<a id="a84abb8d61f9ab227f76ae7b54dcce5d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84abb8d61f9ab227f76ae7b54dcce5d4">&#9670;&nbsp;</a></span>CloseNativeHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::CloseNativeHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1os.html#a84b48561ef817ac28bde556d321a382e">NativeHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the specified handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The handle to close.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>handle</em></code> is valid or is <code><a class="el" href="namespacenn_1_1os.html#a8beb482b6d0aef56dc4877498abc9756" title="The constant representing invalid handles.">nn::os::InvalidNativeHandle</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Closes the specified handle. If <code><em>handle</em></code> is <code><a class="el" href="namespacenn_1_1os.html#a8beb482b6d0aef56dc4877498abc9756" title="The constant representing invalid handles.">nn::os::InvalidNativeHandle</a></code>, the function returns without doing anything.</p>
<p>Handles are normally obtained from the system when objects like <code>CreateSystemEvent()</code> are initialized, and they are managed inside the objects. However, sometimes an unnecessary handle can persist after it has been detached from the object by functions like <code>DetachSystemEvent()</code>, so use this API to close the handles.</p>
<p>This API is primarily designed for use by SDK developers because using it requires an accurate understanding of the reference count to kernel objects by handles and the management of OS objects. </p>

</div>
</div>
<a id="a1771e01a3ebd2fb3dc464756f7208276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1771e01a3ebd2fb3dc464756f7208276">&#9670;&nbsp;</a></span>GenerateRandomBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::GenerateRandomBytes </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pOutBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random byte string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pOutBuffer</td><td>The buffer storing the random byte string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The byte array size.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
 Use an initialized random number generator to generate a random byte sequence for the size byte, and store it in the buffer specified by <code><em>pOutBuffer</em></code>.</p>
<p>This function is expected to be used to generate relatively small amounts of random numbers that include the random number seed. To generate large amounts of random numbers or if the random numbers need to be reproduceable, use a separate C++ standard library or <code><a class="el" href="classnn_1_1util_1_1_tiny_mt.html">nn::util::TinyMt</a></code>.</p>
<p>This function cannot be used for encryption. The <code><a class="el" href="namespacenn_1_1crypto.html#a6839e351ff9a035fd539ab60904a13d0">nn::crypto::GenerateCryptographicallyRandomBytes</a></code> function is provided for encryption purposes.</p>
<p>This function is thread-safe. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_prepo_simple_2_prepo_simple_8cpp-example.html#a1">PrepoSimple/PrepoSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a659d0526afb3df351ed0a95ddc0776fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659d0526afb3df351ed0a95ddc0776fa">&#9670;&nbsp;</a></span>InitializeReaderWriterLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeReaderWriterLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a <code><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="The structure for defining a readers-writer lock object.">ReaderWriterLockType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rwlock</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="The structure for defining a readers-writer lock object.">ReaderWriterLockType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>rwlock</em></code> is in an uninitialized state or has not been initialized.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>rwlock</em></code> is in the unlocked state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Initializes the object specified by <code><em>rwlock</em></code>.</p>
<p>A readers-writer lock is a kind of synchronization object that is used for mutual exclusion among threads. This feature is used for mutual exclusion of a shared resource for which many readers threads have read access and a single writer thread has write access.</p>
<p>The <code><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="The structure for defining a readers-writer lock object.">ReaderWriterLockType</a></code> object takes one of the following states. In the exclusive lock state, one thread is managed as the lock owner.</p>
<ul>
<li>Uninitialized state</li>
<li>Unlocked state</li>
<li>Shared lock state (there is no lock owner)</li>
<li>Exclusive lock state (there is a lock owner)</li>
</ul>
<p>In the unlocked state, none of the threads have a lock.</p>
<p>In the shared lock state, there is no lock owner, and one or more threads have readers locks. In this shared lock state, the object returns to the unlocked state if <code><a class="el" href="namespacenn_1_1os.html#a4d8f51bbfa3341c9678758b191896a05" title="Releases a single readers lock.">ReleaseReadLock()</a></code> is called as many times as <code><a class="el" href="namespacenn_1_1os.html#a6fa888b2694902212ebc056ccaa4354b" title="Gets a readers lock.">AcquireReadLock()</a></code> and <code><a class="el" href="namespacenn_1_1os.html#ac0ce54963ebf2636dd1c78a0d16125a8" title="Tries to acquire a readers lock.">TryAcquireReadLock()</a></code> were called.</p>
<p>In the exclusive lock state, one thread is set as the lock owner and has a readers lock or a writer lock. The lock owner is first set when a single thread successfully calls <code><a class="el" href="namespacenn_1_1os.html#a97d3e3f946b214bcbf85e4aebb61699f" title="Acquires a writer lock.">AcquireWriteLock()</a></code> or <code><a class="el" href="namespacenn_1_1os.html#ad042341aecc3ba00473ab85466fa76a8" title="Tries to acquire a writer lock.">TryAcquireWriteLock()</a></code>, at which point that caller thread is set as the lock owner of the <code><em>rwlock</em></code> object.</p>
<p>After a thread becomes the lock owner, it can do the following.</p>
<ul>
<li>Acquire additional readers locks without blocking.</li>
<li>Acquire additional writer locks without blocking.</li>
<li>After all readers and writer locks have been released, the thread loses its lock owner status, and the object returns to the unlocked state.</li>
<li>There are no limitations on the order in which readers locks and writer locks can be acquired and released.</li>
</ul>
<p>Threads that begin blocking when attempting to acquire a readers or writer lock will automatically attempt to acquire a lock again at the next opportunity when the conditions that make it possible to acquire a lock are satisfied. At this time, if there are multiple threads that have sent readers lock requests or writer lock requests, the writer lock requests are prioritized.</p>
<p>This function is not thread-safe. Do not operate on the <code><em>rwlock</em></code> object while this function is running. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_reader_writer_lock_2_os_reader_writer_lock_8cpp-example.html#a11">OsReaderWriterLock/OsReaderWriterLock.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a6b179b4351145d32ec583bc5a52452bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b179b4351145d32ec583bc5a52452bb">&#9670;&nbsp;</a></span>FinalizeReaderWriterLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FinalizeReaderWriterLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a <code><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="The structure for defining a readers-writer lock object.">ReaderWriterLockType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rwlock</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="The structure for defining a readers-writer lock object.">ReaderWriterLockType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>rwlock</em></code> is in the unlocked state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>rwlock</em></code> is in an uninitialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Frees the object specified by <code><em>rwlock</em></code>.</p>
<p>This function is not thread-safe. Do not operate on the <code><em>rwlock</em></code> object while this function is running. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_reader_writer_lock_2_os_reader_writer_lock_8cpp-example.html#a18">OsReaderWriterLock/OsReaderWriterLock.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a6fa888b2694902212ebc056ccaa4354b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa888b2694902212ebc056ccaa4354b">&#9670;&nbsp;</a></span>AcquireReadLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::AcquireReadLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a readers lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rwlock</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="The structure for defining a readers-writer lock object.">ReaderWriterLockType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The <code><em>rwlock</em></code> object is in the unlocked, shared lock, or exclusive lock state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1os.html#a434e0c862bf65234e1eee8756edbabf4" title="Determines whether any threads currently have readers locks.">IsReadLockHeld()</a></code> == <code>true</code>.</li>
<li>The <code><em>rwlock</em></code> object is in the shared lock state (if the current thread is not the owner).</li>
<li>The <code><em>rwlock</em></code> object is in the exclusive lock state (if the current thread is the owner).</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets a readers lock for the <code><em>rwlock</em></code> object.</p>
<p>The readers lock is obtained successfully in any of the following situations.</p><ul>
<li>The <code><em>rwlock</em></code> object is unlocked.</li>
<li>The <code><em>rwlock</em></code> object has a shared lock and there is no thread with a writer lock request.</li>
<li>The <code><em>rwlock</em></code> object has an exclusive lock and the current thread is the lock owner.</li>
</ul>
<p>If the readers lock cannot be obtained, the current thread is blocked until the readers lock is successfully obtained. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_reader_writer_lock_2_os_reader_writer_lock_8cpp-example.html#a3">OsReaderWriterLock/OsReaderWriterLock.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac0ce54963ebf2636dd1c78a0d16125a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ce54963ebf2636dd1c78a0d16125a8">&#9670;&nbsp;</a></span>TryAcquireReadLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TryAcquireReadLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to acquire a readers lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rwlock</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="The structure for defining a readers-writer lock object.">ReaderWriterLockType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether the readers lock succeeded.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The <code><em>rwlock</em></code> object is in the unlocked, shared lock, or exclusive lock state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the return value is <code>true</code>, the following conditions go into effect.<ul>
<li><code><a class="el" href="namespacenn_1_1os.html#a434e0c862bf65234e1eee8756edbabf4" title="Determines whether any threads currently have readers locks.">IsReadLockHeld()</a></code> == <code>true</code>.</li>
<li>The <code><em>rwlock</em></code> object is in the shared lock state (if the current thread is not the owner).</li>
<li>The <code><em>rwlock</em></code> object is in the exclusive lock state (if the current thread is the owner).</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Tries to get a readers lock for the <code><em>rwlock</em></code> object, and returns a <code>bool</code> type indicating whether the lock succeeded.</p>
<p>If the return value is <code>true</code>, the readers lock was successfully acquired. If the return value is <code>false</code>, a readers lock failed to be acquired, and the state of the <code><em>rwlock</em></code> object does not change. </p>

</div>
</div>
<a id="a4d8f51bbfa3341c9678758b191896a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8f51bbfa3341c9678758b191896a05">&#9670;&nbsp;</a></span>ReleaseReadLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::ReleaseReadLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases a single readers lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rwlock</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="The structure for defining a readers-writer lock object.">ReaderWriterLockType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1os.html#a434e0c862bf65234e1eee8756edbabf4" title="Determines whether any threads currently have readers locks.">IsReadLockHeld()</a></code> == <code>true</code>.</li>
<li>The <code><em>rwlock</em></code> object is in the shared lock state (if the current thread is not the owner).</li>
<li>The <code><em>rwlock</em></code> object is in the exclusive lock state (if the current thread is the owner).</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The <code><em>rwlock</em></code> object is in the unlocked, shared lock, or exclusive lock state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Releases a single readers lock from the specified <code><em>rwlock</em></code> object.</p>
<p>After all readers and writer locks are released, the object returns to the unlocked state, and any threads that were blocking while waiting for a lock are reactivated. At this time, if there are multiple threads that have sent readers lock requests or writer lock requests, the writer lock requests are prioritized. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_reader_writer_lock_2_os_reader_writer_lock_8cpp-example.html#a5">OsReaderWriterLock/OsReaderWriterLock.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a97d3e3f946b214bcbf85e4aebb61699f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d3e3f946b214bcbf85e4aebb61699f">&#9670;&nbsp;</a></span>AcquireWriteLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::AcquireWriteLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires a writer lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rwlock</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="The structure for defining a readers-writer lock object.">ReaderWriterLockType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The <code><em>rwlock</em></code> object is in the unlocked, shared lock, or exclusive lock state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1os.html#a6658b045d8ca185b5108ddb802f2440e" title="Determines whether the current thread has acquired a writer lock.">IsWriteLockHeldByCurrentThread()</a></code> == <code>true</code>.</li>
<li><code><a class="el" href="namespacenn_1_1os.html#ace3bf890340f587ab633cd1804a93e0b" title="Determines whether the current thread is the lock owner.">IsReaderWriterLockOwnerThread()</a></code> == <code>true</code>.</li>
<li><code><em>rwlock</em></code> is in the exclusive lock state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets a writer lock for the <code><em>rwlock</em></code> object. If the lock is successfully acquired, the current thread becomes the lock owner.</p>
<p>If the writer lock cannot be acquired, the current thread enters a blocking state until a writer lock can be acquired. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_reader_writer_lock_2_os_reader_writer_lock_8cpp-example.html#a6">OsReaderWriterLock/OsReaderWriterLock.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad042341aecc3ba00473ab85466fa76a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad042341aecc3ba00473ab85466fa76a8">&#9670;&nbsp;</a></span>TryAcquireWriteLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TryAcquireWriteLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to acquire a writer lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rwlock</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="The structure for defining a readers-writer lock object.">ReaderWriterLockType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether the writer lock succeeded.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The <code><em>rwlock</em></code> object is in the unlocked, shared lock, or exclusive lock state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the return value is <code>true</code>, the following conditions go into effect.<ul>
<li><code><a class="el" href="namespacenn_1_1os.html#a6658b045d8ca185b5108ddb802f2440e" title="Determines whether the current thread has acquired a writer lock.">IsWriteLockHeldByCurrentThread()</a></code> == <code>true</code>.</li>
<li><code><a class="el" href="namespacenn_1_1os.html#ace3bf890340f587ab633cd1804a93e0b" title="Determines whether the current thread is the lock owner.">IsReaderWriterLockOwnerThread()</a></code> == <code>true</code>.</li>
<li><code><em>rwlock</em></code> is in the exclusive lock state.</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Tries to get a writer lock for the <code><em>rwlock</em></code> object and returns a <code>bool</code> type indicating whether the lock succeeded.</p>
<p>If the return value is <code>true</code>, the writer lock was successfully acquired, and the current thread becomes the thread owner. </p>

</div>
</div>
<a id="ae30220320ff7ba5af52183fd5fbe1312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae30220320ff7ba5af52183fd5fbe1312">&#9670;&nbsp;</a></span>ReleaseWriteLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::ReleaseWriteLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases a single writer lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rwlock</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="The structure for defining a readers-writer lock object.">ReaderWriterLockType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1os.html#a6658b045d8ca185b5108ddb802f2440e" title="Determines whether the current thread has acquired a writer lock.">IsWriteLockHeldByCurrentThread()</a></code> == <code>true</code>.</li>
<li><code><a class="el" href="namespacenn_1_1os.html#ace3bf890340f587ab633cd1804a93e0b" title="Determines whether the current thread is the lock owner.">IsReaderWriterLockOwnerThread()</a></code> == <code>true</code>.</li>
<li><code><em>rwlock</em></code> is in the exclusive lock state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The <code><em>rwlock</em></code> object is in the unlocked, shared lock, or exclusive lock state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Releases a single writer lock from the specified <code><em>rwlock</em></code> object.</p>
<p>After all readers and writer locks are released, the object returns to the unlocked state, and any threads that were blocking while waiting for a lock are reactivated. At this time, if there are multiple threads that have sent readers lock requests or writer lock requests, the writer lock requests are prioritized. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_reader_writer_lock_2_os_reader_writer_lock_8cpp-example.html#a9">OsReaderWriterLock/OsReaderWriterLock.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a434e0c862bf65234e1eee8756edbabf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434e0c862bf65234e1eee8756edbabf4">&#9670;&nbsp;</a></span>IsReadLockHeld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::IsReadLockHeld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether any threads currently have readers locks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rwlock</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="The structure for defining a readers-writer lock object.">ReaderWriterLockType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether any threads currently have readers locks.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The <code><em>rwlock</em></code> object is in the unlocked, shared lock, or exclusive lock state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Returns <code>true</code> if any of the threads currently have a readers lock for the specified <code><em>rwlock</em></code> object, and <code>false</code> otherwise. </p>

</div>
</div>
<a id="a6658b045d8ca185b5108ddb802f2440e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6658b045d8ca185b5108ddb802f2440e">&#9670;&nbsp;</a></span>IsWriteLockHeldByCurrentThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::IsWriteLockHeldByCurrentThread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the current thread has acquired a writer lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rwlock</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="The structure for defining a readers-writer lock object.">ReaderWriterLockType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether the current thread has obtained a writer lock already.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The <code><em>rwlock</em></code> object is in the unlocked, shared lock, or exclusive lock state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Returns <code>true</code> if the current thread has acquired a writer lock for the specified <code><em>rwlock</em></code> object, and <code>false</code> otherwise. </p>

</div>
</div>
<a id="ace3bf890340f587ab633cd1804a93e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3bf890340f587ab633cd1804a93e0b">&#9670;&nbsp;</a></span>IsReaderWriterLockOwnerThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::IsReaderWriterLockOwnerThread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the current thread is the lock owner. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rwlock</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="The structure for defining a readers-writer lock object.">ReaderWriterLockType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the current thread is the lock owner.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The <code><em>rwlock</em></code> object is in the unlocked, shared lock, or exclusive lock state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Returns <code>true</code> if the current thread is the lock owner of the specified <code><em>rwlock</em></code> object, or <code>false</code> otherwise.</p>
<p>This function returns a different value than the <code><a class="el" href="namespacenn_1_1os.html#a6658b045d8ca185b5108ddb802f2440e" title="Determines whether the current thread has acquired a writer lock.">IsWriteLockHeldByCurrentThread()</a></code> function in the following case.</p>
<p>A thread acquires a writer lock and becomes the lock owner and then acquires a readers lock and releases only the writer lock, at which point the thread still remains the lock owner but only has a reader lock. This causes the <code><em>rwlock</em></code> object to remain in the exclusive lock state, and each function returns the following values.</p>
<ul>
<li><code><a class="el" href="namespacenn_1_1os.html#ace3bf890340f587ab633cd1804a93e0b" title="Determines whether the current thread is the lock owner.">IsReaderWriterLockOwnerThread()</a></code> returns <code>true</code>.</li>
<li><code><a class="el" href="namespacenn_1_1os.html#a6658b045d8ca185b5108ddb802f2440e" title="Determines whether the current thread has acquired a writer lock.">IsWriteLockHeldByCurrentThread()</a></code> returns <code>false</code>.</li>
<li><code><a class="el" href="namespacenn_1_1os.html#a434e0c862bf65234e1eee8756edbabf4" title="Determines whether any threads currently have readers locks.">IsReadLockHeld()</a></code> returns <code>true</code>. </li>
</ul>

</div>
</div>
<a id="af76bc96a9333f18ed5d7bead209eb4f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af76bc96a9333f18ed5d7bead209eb4f3">&#9670;&nbsp;</a></span>InitializeSemaphore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeSemaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *&#160;</td>
          <td class="paramname"><em>semaphore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>initialCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a <code><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="This structure defines a semaphore object.">SemaphoreType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">semaphore</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="This structure defines a semaphore object.">SemaphoreType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initialCount</td><td>Initial value of the semaphore counter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxCount</td><td>Maximum value of the semaphore counter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>semaphore</em></code> is in an uninitialized state or has not been initialized.</li>
<li><code><em>maxCount</em></code> &gt;= <code>1</code>.</li>
<li><code>0</code> &lt;= <code><em>initialCount</em></code> &lt;= <code><em>maxCount</em></code></li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>semaphore</em></code> is in an initialized state.<ul>
<li>If <code><em>initialCount</em></code> == <code>0</code>, the object is in a non-signaled state.</li>
<li>If <code><em>initialCount</em></code> &gt;= <code>1</code>, the object is in a signaled state.</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Initializes a <code><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="This structure defines a semaphore object.">SemaphoreType</a></code> object.</p>
<p>This function is not thread-safe. Do not manipulate the object specified in <code>semaphore</code> while this function is being called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_multi_wait_2_os_multi_wait_8cpp-example.html#a28">OsMultiWait/OsMultiWait.cpp</a>, <a class="el" href="_os_multi_wait_utility_2_os_multi_wait_utility_8cpp-example.html#a18">OsMultiWaitUtility/OsMultiWaitUtility.cpp</a>, and <a class="el" href="_os_semaphore_2_os_semaphore_8cpp-example.html#a8">OsSemaphore/OsSemaphore.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a201a00464d5606e40bef1798cba2ace8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a201a00464d5606e40bef1798cba2ace8">&#9670;&nbsp;</a></span>FinalizeSemaphore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FinalizeSemaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *&#160;</td>
          <td class="paramname"><em>semaphore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalizes a <code><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="This structure defines a semaphore object.">SemaphoreType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">semaphore</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="This structure defines a semaphore object.">SemaphoreType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>semaphore</em></code> is in an initialized state.</li>
<li>No threads are waiting for <code><em>semaphore</em></code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>semaphore</em></code> is in an uninitialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Finalizes a <code><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="This structure defines a semaphore object.">SemaphoreType</a></code> object.</p>
<p>This function is not thread-safe. Do not manipulate the object specified in <code>semaphore</code> while this function is being called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_multi_wait_2_os_multi_wait_8cpp-example.html#a38">OsMultiWait/OsMultiWait.cpp</a>, <a class="el" href="_os_multi_wait_utility_2_os_multi_wait_utility_8cpp-example.html#a28">OsMultiWaitUtility/OsMultiWaitUtility.cpp</a>, and <a class="el" href="_os_semaphore_2_os_semaphore_8cpp-example.html#a15">OsSemaphore/OsSemaphore.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac9e1d42bdb0279e887dc1caef45fcff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e1d42bdb0279e887dc1caef45fcff1">&#9670;&nbsp;</a></span>AcquireSemaphore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::AcquireSemaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *&#160;</td>
          <td class="paramname"><em>semaphore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires a <code><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="This structure defines a semaphore object.">SemaphoreType</a></code> object (<em>P</em> operation). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">semaphore</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="This structure defines a semaphore object.">SemaphoreType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>semaphore</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>semaphore</em></code> is in an initialized state.</li>
<li>The semaphore counter is decremented.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets one count from the specified semaphore (P operation). If the count for the target semaphore is already <code>0</code>, the current thread waits for another thread to return a semaphore. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_multi_wait_2_os_multi_wait_8cpp-example.html#a5">OsMultiWait/OsMultiWait.cpp</a>, <a class="el" href="_os_multi_wait_utility_2_os_multi_wait_utility_8cpp-example.html#a5">OsMultiWaitUtility/OsMultiWaitUtility.cpp</a>, and <a class="el" href="_os_semaphore_2_os_semaphore_8cpp-example.html#a2">OsSemaphore/OsSemaphore.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af5fa41594b3b3072d78735f366bdb7ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5fa41594b3b3072d78735f366bdb7ce">&#9670;&nbsp;</a></span>TryAcquireSemaphore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TryAcquireSemaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *&#160;</td>
          <td class="paramname"><em>semaphore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to acquire a <code><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="This structure defines a semaphore object.">SemaphoreType</a></code> object (<em>P</em> operation). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">semaphore</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="This structure defines a semaphore object.">SemaphoreType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether the semaphore was successfully acquired.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>semaphore</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the return value is <code>true</code>:<ul>
<li><code><em>semaphore</em></code> is in an initialized state.</li>
<li>The semaphore counter is decremented.</li>
</ul>
</li>
<li>If the return value is <code>false</code>:<ul>
<li><code><em>semaphore</em></code> is in a non-signaled state.</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets one count from the specified semaphore (P operation). Returns <code>true</code> if successfully acquired. If the count for the target semaphore is already <code>0</code>, the current thread does not wait and the function returns <code>false</code>. </p>

</div>
</div>
<a id="a54c8209e58cabbf5ab5173867dcad732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c8209e58cabbf5ab5173867dcad732">&#9670;&nbsp;</a></span>TimedAcquireSemaphore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TimedAcquireSemaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *&#160;</td>
          <td class="paramname"><em>semaphore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to acquire a <code><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="This structure defines a semaphore object.">SemaphoreType</a></code> object with a timeout (<em>P</em> operation). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">semaphore</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="This structure defines a semaphore object.">SemaphoreType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Timeout when waiting for the semaphore.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether the semaphore was successfully acquired.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>semaphore</em></code> is in an initialized state.</li>
<li><code><em>timeout</em></code> &gt;= <code>0</code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the return value is <code>true</code>:<ul>
<li><code><em>semaphore</em></code> is in an initialized state.</li>
<li>The semaphore counter is decremented.</li>
</ul>
</li>
<li>If the return value is <code>false</code>:<ul>
<li><code><em>semaphore</em></code> is in a non-signaled state.</li>
</ul>
</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Acquires one count from the specified semaphore (P operation). Returns <code>true</code> if successfully acquired. If the count for the target semaphore is already <code>0</code>, the current thread waits for another thread to return a semaphore. If the amount of time specified by <code><em>timeout</em></code> elapses after the current thread starts waiting, a timeout occurs and the thread automatically stops waiting. In this case, the function returns <code>false</code>.</p>
<p>For more information about time-out behavior, see <a class="el" href="_page_notification_os_timeout.html">OS-API Timeouts</a>. </p>

</div>
</div>
<a id="acf2cbceb4266858d27387ff2cb29a5ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf2cbceb4266858d27387ff2cb29a5ae">&#9670;&nbsp;</a></span>ReleaseSemaphore() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::ReleaseSemaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *&#160;</td>
          <td class="paramname"><em>semaphore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases only one count of a <code><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="This structure defines a semaphore object.">SemaphoreType</a></code> object (<em>V</em> operation). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">semaphore</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="This structure defines a semaphore object.">SemaphoreType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>semaphore</em></code> is in an initialized state.</li>
<li>The semaphore counter of <code><em>semaphore</em></code> is less than <code>maxCount</code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The semaphore counter of <code><em>semaphore</em></code> is incremented.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Releases one count to the specified semaphore (V operation). At this time, if there is a thread that is waiting for the target light semaphore, this function cancels standby.</p>
<p>If the counter of the target semaphore exceeds the <code><em>maxCount</em></code> value specified when <code><a class="el" href="namespacenn_1_1os.html#af76bc96a9333f18ed5d7bead209eb4f3" title="Initializes a SemaphoreType object.">InitializeSemaphore()</a></code> was called, this function causes an assertion failure. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_multi_wait_2_os_multi_wait_8cpp-example.html#a24">OsMultiWait/OsMultiWait.cpp</a>, <a class="el" href="_os_multi_wait_utility_2_os_multi_wait_utility_8cpp-example.html#a14">OsMultiWaitUtility/OsMultiWaitUtility.cpp</a>, and <a class="el" href="_os_semaphore_2_os_semaphore_8cpp-example.html#a6">OsSemaphore/OsSemaphore.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a40039d059051bc9970e072417ac9576d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40039d059051bc9970e072417ac9576d">&#9670;&nbsp;</a></span>ReleaseSemaphore() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::ReleaseSemaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *&#160;</td>
          <td class="paramname"><em>semaphore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases multiple counts of a <code><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="This structure defines a semaphore object.">SemaphoreType</a></code> object (<em>V</em> operation). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">semaphore</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="This structure defines a semaphore object.">SemaphoreType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td><a class="el" href="classnn_1_1os_1_1_semaphore.html" title="Class for handling semaphores.">Semaphore</a> count to release.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>count</em></code> &gt;= <code>1</code>.</li>
<li><code><em>semaphore</em></code> is in an initialized state.</li>
<li>The semaphore counter of <code><em>semaphore</em></code> is less than or equal to <code><em>maxCount</em></code> - <code><em>count</em></code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The semaphore counter of <code><em>semaphore</em></code> is incremented by <code><em>count</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Returns <code><em>count</em></code> to the counter of the specified semaphore (V operation). At this time, if there is a thread that is waiting for the target light semaphore, this function cancels standby.</p>
<p>If the counter of the target semaphore exceeds the <code><em>maxCount</em></code> value specified when <code><a class="el" href="namespacenn_1_1os.html#af76bc96a9333f18ed5d7bead209eb4f3" title="Initializes a SemaphoreType object.">InitializeSemaphore()</a></code> was called, this function causes an assertion failure. </p>

</div>
</div>
<a id="aa6a315a7f4822cee3e62e9912737edfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a315a7f4822cee3e62e9912737edfa">&#9670;&nbsp;</a></span>GetCurrentSemaphoreCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::os::GetCurrentSemaphoreCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *&#160;</td>
          <td class="paramname"><em>semaphore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The current counter value of a <code><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="This structure defines a semaphore object.">SemaphoreType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">semaphore</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="This structure defines a semaphore object.">SemaphoreType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the current counter value of the semaphore.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>semaphore</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>semaphore</em></code> is in an initialized state.</li>
<li>The current counter value of <code><em>semaphore</em></code> is returned.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Returns the current semaphore count value.</p>
<p>The counter value of a semaphore is manipulated by other threads. The counter value returned by this function is just a snapshot of the counter value at that instant. Take note of this when using the API. </p>

</div>
</div>
<a id="a0e0b40464c9936df7d8cb77dadffcbd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0b40464c9936df7d8cb77dadffcbd9">&#9670;&nbsp;</a></span>InitializeMultiWaitHolder() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeMultiWaitHolder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *&#160;</td>
          <td class="paramname"><em>multiWaitHolder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *&#160;</td>
          <td class="paramname"><em>semaphore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a <code>MultiWaitHolder</code> object and associates it to a semaphore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWaitHolder</td><td>Pointer to a multiwait object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">semaphore</td><td>Pointer to the semaphore to associate to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>multiWaitHolder</em></code> is in an uninitialized state.</li>
<li><code><em>semaphore</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>multiWaitHolder</em></code> is in an initialized state (and bound to <code><em>semaphore</em></code>).</li>
<li><code><a class="el" href="namespacenn_1_1os.html#a9e8c73312415fc00c72808fcc00fea33">nn::os::GetMultiWaitHolderUserData(multiWaitHolder)</a></code> == <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Initializes <code><em>multiWaitHolder</em></code> and binds it to the object specified in <code><em>semaphore</em></code>.</p>
<p>The bound <code><em>multiWaitHolder</em></code> enters a signaled state when the counter of the target semaphore is <code>1</code> or greater. If the semaphore's counter is already <code>1</code> or greater, the object enters a signaled state immediately.</p>
<p>Using a <code><em>multiWaitHolder</em></code> object initialized using this API and the target semaphore signaled to wake the multiwait does not automatically get the target semaphore. For more information, see <a class="el" href="_page_notification_os_multi_wait.html#PageNotificationOsMultiWait_AboutWakeup">Waking a multiwait PageNotificationOsMultiWait_AboutWakeup</a>.</p>
<p>Do not operate on <code><em>multiWaitHolder</em></code> while this function is being called. </p>

</div>
</div>
<a id="a3d924bc362ec80648323428be5182338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d924bc362ec80648323428be5182338">&#9670;&nbsp;</a></span>DestroySystemEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::DestroySystemEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_system_event_type.html">SystemEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a <code><a class="el" href="structnn_1_1os_1_1_system_event_type.html" title="This structure defines a system event object.">SystemEventType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_system_event_type.html" title="This structure defines a system event object.">SystemEventType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The <code><em>event</em></code> object is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The <code><em>event</em></code> object is in an uninitialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Destroys a <code><a class="el" href="structnn_1_1os_1_1_system_event_type.html" title="This structure defines a system event object.">SystemEventType</a></code> object. Do not perform operations on the object specified in <code><em>event</em></code> while this function is being called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a157">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a132">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a59">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a211">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a169">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a121">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a61">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a93">AudioOut/AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_2_audio_out_with_resampler_8cpp-example.html#a92">AudioOutWithResampler/AudioOutWithResampler.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a167">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a150">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a119">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a159">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a81">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a130">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#a80">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#a89">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a103">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aa689721442ec303678047dd75c957bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa689721442ec303678047dd75c957bea">&#9670;&nbsp;</a></span>WaitSystemEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::WaitSystemEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_system_event_type.html">SystemEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for a system event to enter a signaled state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_system_event_type.html" title="This structure defines a system event object.">SystemEventType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The <code><em>event</em></code> object is in an initialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Waits for a system event to enter a signaled state. If the system event is already in a signaled state, this function returns immediately. </p>

</div>
</div>
<a id="a0367a830f313d114698a17311e7274c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0367a830f313d114698a17311e7274c5">&#9670;&nbsp;</a></span>TryWaitSystemEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TryWaitSystemEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_system_event_type.html">SystemEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Polls whether system events are in the signaled state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_system_event_type.html" title="This structure defines a system event object.">SystemEventType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether waiting for the system event was successful.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The <code><em>event</em></code> object is in an initialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Polls whether the system event is in the signaled state. If the system event is already in the signaled state, this function immediately returns <code>true</code>. If the system event is in the non-signaled state, this function returns <code>false</code> without waiting. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_friends_friend_invitation_2_friends_friend_invitation_8cpp-example.html#a9">FriendsFriendInvitation/FriendsFriendInvitation.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_access_point_2_ldn_access_point_8cpp-example.html#a20">LdnBasic/LdnAccessPoint/LdnAccessPoint.cpp</a>, and <a class="el" href="_ldn_basic_2_ldn_station_2_ldn_station_8cpp-example.html#a20">LdnBasic/LdnStation/LdnStation.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af25710360462b312201c3685e238f46e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af25710360462b312201c3685e238f46e">&#9670;&nbsp;</a></span>TimedWaitSystemEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TimedWaitSystemEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_system_event_type.html">SystemEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for a system event to enter a signaled state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_system_event_type.html" title="This structure defines a system event object.">SystemEventType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Wait time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether waiting for the system event was successful.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The <code><em>event</em></code> object is in an initialized state.</li>
<li><code><em>timeout</em></code> &gt;= <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Waits for a system event to enter a signaled state. Returns <code>true</code> when the system event enters the signaled state. If the amount of time specified by <code><em>timeout</em></code> elapses after the current thread starts waiting, it automatically stops waiting. In this case, the function returns <code>false</code>.</p>
<p>For more information about time-out behavior, see <a class="el" href="_page_notification_os_timeout.html">OS-API Timeouts</a>. </p>

</div>
</div>
<a id="a70789090416cc882f4aa2c786092e49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70789090416cc882f4aa2c786092e49a">&#9670;&nbsp;</a></span>ClearSystemEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::ClearSystemEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_system_event_type.html">SystemEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the system event to the nonsignaled state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_system_event_type.html" title="This structure defines a system event object.">SystemEventType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The <code><em>event</em></code> object is in an initialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Clears the system event to the nonsignaled state. </p>

</div>
</div>
<a id="a4b03654db54c77da2e8a8c185257d250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b03654db54c77da2e8a8c185257d250">&#9670;&nbsp;</a></span>InitializeMultiWaitHolder() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeMultiWaitHolder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *&#160;</td>
          <td class="paramname"><em>multiWaitHolder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_system_event_type.html">SystemEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the <code><em>multiWaitHolder</em></code> object and binds it to a <code><a class="el" href="structnn_1_1os_1_1_system_event_type.html" title="This structure defines a system event object.">SystemEventType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWaitHolder</td><td>Pointer to a multiwait object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_system_event_type.html" title="This structure defines a system event object.">SystemEventType</a></code> object to bind to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>multiWaitHolder</em></code> is in an uninitialized state.</li>
<li><code><em>event</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>multiWaitHolder</em></code> is in an initialized state (and bound to <code><em>event</em></code>).</li>
<li><code><a class="el" href="namespacenn_1_1os.html#a9e8c73312415fc00c72808fcc00fea33">nn::os::GetMultiWaitHolderUserData(multiWaitHolder)</a></code> == <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Initializes <code><em>multiWaitHolder</em></code> and binds it to the object specified in <code><em>event</em></code>.</p>
<p>The signal state of the bound <code><em>multiWaitHolder</em></code> changes to match the signal state of the target system event.</p>
<p>Unlike with the <code><a class="el" href="namespacenn_1_1os.html#aa689721442ec303678047dd75c957bea" title="Waits for a system event to enter a signaled state.">WaitSystemEvent()</a></code> function, when you perform a multiwait using a <code><em>multiWaitHolder</em></code> object initialized by this API, the target system event is not automatically cleared to the non-signaled state after it has been signaled and the multiwait has ended. For more information, see <a class="el" href="_page_notification_os_multi_wait.html#PageNotificationOsMultiWait_AboutWakeup">Waking a multiwait PageNotificationOsMultiWait_AboutWakeup</a>.</p>
<p>Do not operate on <code><em>multiWaitHolder</em></code> while this function is being called. </p>

</div>
</div>
<a id="a75f43e1d3c194c0d2173ef5d95785933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f43e1d3c194c0d2173ef5d95785933">&#9670;&nbsp;</a></span>CreateThread() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::os::CreateThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1os.html#abec974a5d224f7c62cfa9af4af3c954a">ThreadFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>argument</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idealCoreNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="This structure defines a thread object.">ThreadType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function entry for the thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argument</td><td>Arguments passed to the thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stack</td><td>Starting address of the stack space for the thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stackSize</td><td>Thread stack size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td>Priority of the thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idealCoreNumber</td><td>The number for the core to create the thread on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1os_1_1_result_out_of_memory.html">nn::os::ResultOutOfMemory</a> must be handled.</li>
<li><a class="el" href="classnn_1_1os_1_1_result_out_of_resource.html">nn::os::ResultOutOfResource</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>thread</em></code> is in the <code>NotInitialized</code> state or has not been initialized.</li>
<li><code><em>stack</em></code> is aligned to <code><a class="el" href="namespacenn_1_1os.html#a8b116319f3d483f3805c193661f22150" title="Constant indicating the alignment rules for a thread stack space.">nn::os::ThreadStackAlignment</a></code>.</li>
<li><code><em>stackSize</em></code> &gt; <code>0</code>.</li>
<li><code><em>stackSize</em></code> % <code><a class="el" href="namespacenn_1_1os.html#a8b116319f3d483f3805c193661f22150" title="Constant indicating the alignment rules for a thread stack space.">nn::os::ThreadStackAlignment</a></code> == <code>0</code>.</li>
<li><code><a class="el" href="namespacenn_1_1os.html#a20238ce26424ba34876552fb2d53165a" title="Determines whether the specified memory area is locked.">nn::os::IsMemoryLocked</a> (<em>stack</em>, <em>stackSize</em>)</code> == <code>false</code></li>
<li><code><a class="el" href="namespacenn_1_1os.html#a44ed3b4dddf9ebfb69bc33167369b816" title="Constant indicating the highest thread priority.">nn::os::HighestThreadPriority</a></code> &lt;= <code><em>priority</em></code> &lt;= <code><a class="el" href="namespacenn_1_1os.html#a88510f5f630a16612aa8d479c10b56de" title="Constant indicating the lowest thread priority.">nn::os::LowestThreadPriority</a></code>.</li>
<li><code><em>idealCoreNumber</em></code> is a valid value defined for the target operating environment.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>thread</em></code> is in the <code>Initialized</code> state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Creates a thread and initializes the thread object. Note that the thread does not start running after this function is called. Call the <code><a class="el" href="namespacenn_1_1os.html#a18eec7c4c4c298f7abaa9ef41d6de76b" title="Starts execution on a thread.">StartThread()</a></code> function to start the thread.</p>
<p>The memory space between <code><em>stack</em></code> and (<code><em>stack</em></code> + <code><em>stackSize</em></code>) is used as stack memory. How the stack memory is used depends on the environment.</p>
<p><code><em>stack</em></code> and <code><em>stackSize</em></code> must be aligned to the constant value represented by <code><a class="el" href="namespacenn_1_1os.html#a895eb281cfb4500d6ac462cec6631613" title="Constant indicating the alignment rules for the stack space.">nn::os::StackRegionAlignment</a></code>. Use the <code><a class="el" href="os___thread_common_8h.html#a5ce0c3c0aaceb976178a60a18d90f470">NN_OS_ALIGNAS_THREAD_STACK</a></code> macro to define a buffer for stack space using an alignment equivalent to this constant value.</p>
<p>The thread priority is indicated by <code><em>priority</em></code>, which takes a value from <code><a class="el" href="namespacenn_1_1os.html#a44ed3b4dddf9ebfb69bc33167369b816" title="Constant indicating the highest thread priority.">nn::os::HighestThreadPriority</a></code> to <code><a class="el" href="namespacenn_1_1os.html#a88510f5f630a16612aa8d479c10b56de" title="Constant indicating the lowest thread priority.">nn::os::LowestThreadPriority</a></code>. A smaller number indicates a higher priority.</p>
<p>The <code><em>idealCoreNumber</em></code> parameter indicates the number of the core that creates the thread. Valid processor number values depend on the environment.</p>
<p>This function is not thread-safe. Do not perform operations on the object specified in <code><em>thread</em></code> while this function is being called.</p>
<div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
<ul>
<li>The stack area used by threads is not the one specified by <code><em>stack</em></code>, but rather an area allocated independently by Windows.</li>
<li>Even so, make sure that you pass an amount of memory that satisfies the preconditions to the <code><em>stack</em></code> parameter. If <code>NULL</code> is specified, this function causes an assertion failure.</li>
<li>Thread priority is ignored. Threads are always created with a standard priority.</li>
<li><code><em>idealcoreNumber</em></code> is ignored. Threads operate according to Windows scheduling.</li>
</ul>
</div><div class="platform_section" data-platform="Windows"></div><p> <b>Target Hardware Environment:</b></p>
<ul>
<li>In the target hardware environment, the region specified by <code><em>stack</em></code> is not itself used as the stack area. Rather, the region is mirrored in another unused memory space, and that memory space is used as the stack area.</li>
<li>4-KB guard pages are prepared before and after the stack area in the mirrored space. These guard pages cannot be written to or read from.</li>
<li>When <code><a class="el" href="namespacenn_1_1os.html#a9dbfcfb82583a9e34431e8c11d2411dd" title="Deletes a thread.">DestroyThread()</a></code> is called on the thread, the mirrored space for that thread's stack area is freed and becomes available again as memory space. </li>
</ul>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a90">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a66">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_bcat_practical_2_bcat_practical_8cpp-example.html#a5">BcatPractical/BcatPractical.cpp</a>, <a class="el" href="_g3d_demo_2_parallel_8cpp-example.html#a129">G3dDemo/Parallel.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_access_point_2_ldn_access_point_8cpp-example.html#a69">LdnBasic/LdnAccessPoint/LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_station_2_ldn_station_8cpp-example.html#a65">LdnBasic/LdnStation/LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a62">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_nifm_network_connection_simple_2_nifm_network_connection_simple__main_8cpp-example.html#a4">NifmNetworkConnectionSimple/NifmNetworkConnectionSimple_Main.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_simple_framework_8cpp-example.html#a27">NvnSimple/NvnSimpleSharedLib/SimpleFramework.cpp</a>, <a class="el" href="_nvn_tutorial_2_render_thread_pool_8cpp-example.html#a9">NvnTutorial/RenderThreadPool.cpp</a>, <a class="el" href="_nvn_tutorial04_multi_threaded_asset_file_loading_2_nvn_tutorial04_8cpp-example.html#a35">NvnTutorial04MultiThreadedAssetFileLoading/NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial06_frame_buffering_2_nvn_tutorial06_8cpp-example.html#a39">NvnTutorial06FrameBuffering/NvnTutorial06.cpp</a>, <a class="el" href="_oe_disable_auto_sleep_2_oe_disable_auto_sleep_8cpp-example.html#a6">OeDisableAutoSleep/OeDisableAutoSleep.cpp</a>, <a class="el" href="_os_barrier_2_os_barrier_8cpp-example.html#a12">OsBarrier/OsBarrier.cpp</a>, <a class="el" href="_os_condition_variable_2_os_condition_variable_8cpp-example.html#a14">OsConditionVariable/OsConditionVariable.cpp</a>, <a class="el" href="_os_event_2_os_event_8cpp-example.html#a13">OsEvent/OsEvent.cpp</a>, <a class="el" href="_os_message_queue_2_os_message_queue_8cpp-example.html#a10">OsMessageQueue/OsMessageQueue.cpp</a>, <a class="el" href="_os_multi_wait_2_os_multi_wait_8cpp-example.html#a33">OsMultiWait/OsMultiWait.cpp</a>, <a class="el" href="_os_multi_wait_utility_2_os_multi_wait_utility_8cpp-example.html#a23">OsMultiWaitUtility/OsMultiWaitUtility.cpp</a>, <a class="el" href="_os_mutex_2_os_mutex_8cpp-example.html#a9">OsMutex/OsMutex.cpp</a>, <a class="el" href="_os_reader_writer_lock_2_os_reader_writer_lock_8cpp-example.html#a12">OsReaderWriterLock/OsReaderWriterLock.cpp</a>, <a class="el" href="_os_semaphore_2_os_semaphore_8cpp-example.html#a10">OsSemaphore/OsSemaphore.cpp</a>, <a class="el" href="_os_thread_2_os_thread_8cpp-example.html#a12">OsThread/OsThread.cpp</a>, <a class="el" href="_os_thread_local_storage_2_os_thread_local_storage_8cpp-example.html#a9">OsThreadLocalStorage/OsThreadLocalStorage.cpp</a>, <a class="el" href="_os_timer_event_2_os_timer_event_8cpp-example.html#a15">OsTimerEvent/OsTimerEvent.cpp</a>, <a class="el" href="_perf_simple_2_perf_simple_8cpp-example.html#a56">PerfSimple/PerfSimple.cpp</a>, <a class="el" href="_profiler_thread_state_2_profiler_thread_state_8cpp-example.html#a10">ProfilerThreadState/ProfilerThreadState.cpp</a>, <a class="el" href="_socket_event_fd_2_socket_event_fd_8cpp-example.html#a32">SocketEventFd/SocketEventFd.cpp</a>, <a class="el" href="_socket_statistics_overlay_2_socket_statistics_overlay_8cpp-example.html#a65">SocketStatisticsOverlay/SocketStatisticsOverlay.cpp</a>, <a class="el" href="_vi_timestamp_2_vi_timestamp_8cpp-example.html#a28">ViTimestamp/ViTimestamp.cpp</a>, and <a class="el" href="_web_socket_chat_2_web_socket_chat_8cpp-example.html#a23">WebSocketChat/WebSocketChat.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1e7db66d31e254873b613d4eadd0d716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e7db66d31e254873b613d4eadd0d716">&#9670;&nbsp;</a></span>CreateThread() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::os::CreateThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1os.html#abec974a5d224f7c62cfa9af4af3c954a">ThreadFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>argument</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="This structure defines a thread object.">ThreadType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function entry for the thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argument</td><td>Arguments passed to the thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stack</td><td>Starting address of the stack space for the thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stackSize</td><td>Thread stack size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td>Priority of the thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1os_1_1_result_out_of_memory.html">nn::os::ResultOutOfMemory</a> must be handled.</li>
<li><a class="el" href="classnn_1_1os_1_1_result_out_of_resource.html">nn::os::ResultOutOfResource</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>thread</em></code> is in the <code>NotInitialized</code> state or has not been initialized.</li>
<li><code><em>stack</em></code> is aligned to <code><a class="el" href="namespacenn_1_1os.html#a8b116319f3d483f3805c193661f22150" title="Constant indicating the alignment rules for a thread stack space.">nn::os::ThreadStackAlignment</a></code>.</li>
<li><code><em>stackSize</em></code> &gt; <code>0</code>.</li>
<li><code><em>stackSize</em></code> % <code><a class="el" href="namespacenn_1_1os.html#a8b116319f3d483f3805c193661f22150" title="Constant indicating the alignment rules for a thread stack space.">nn::os::ThreadStackAlignment</a></code> == <code>0</code>.</li>
<li><code><a class="el" href="namespacenn_1_1os.html#a20238ce26424ba34876552fb2d53165a" title="Determines whether the specified memory area is locked.">nn::os::IsMemoryLocked</a> (<em>stack</em>, <em>stackSize</em>)</code> == <code>false</code></li>
<li><code><a class="el" href="namespacenn_1_1os.html#a44ed3b4dddf9ebfb69bc33167369b816" title="Constant indicating the highest thread priority.">nn::os::HighestThreadPriority</a></code> &lt;= <code><em>priority</em></code> &lt;= <code><a class="el" href="namespacenn_1_1os.html#a88510f5f630a16612aa8d479c10b56de" title="Constant indicating the lowest thread priority.">nn::os::LowestThreadPriority</a></code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>thread</em></code> is in the <code>Initialized</code> state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Creates a thread and initializes the thread object.</p>
<p>In general, this functionally is equivalent to the other <code><a class="el" href="namespacenn_1_1os.html#a75f43e1d3c194c0d2173ef5d95785933" title="Generates a thread.">CreateThread()</a></code>, but you cannot specify a core number in this variation. The core number gets the value prescribed for the target environment. </p>

</div>
</div>
<a id="a9dbfcfb82583a9e34431e8c11d2411dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dbfcfb82583a9e34431e8c11d2411dd">&#9670;&nbsp;</a></span>DestroyThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::DestroyThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="This structure defines a thread object.">ThreadType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>thread</em></code> is in the <code>Initialized</code>, <code>Started</code>, or <code>Exited</code> state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>thread</em></code> is in the <code>NotInitialized</code> state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Destroys the thread object and deletes the thread. If the thread is in a started state, the function waits for the state to become <code>Exited</code> before deleting the thread. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a108">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a70">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_g3d_demo_2_parallel_8cpp-example.html#a140">G3dDemo/Parallel.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_access_point_2_ldn_access_point_8cpp-example.html#a73">LdnBasic/LdnAccessPoint/LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_station_2_ldn_station_8cpp-example.html#a68">LdnBasic/LdnStation/LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a69">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_simple_framework_8cpp-example.html#a37">NvnSimple/NvnSimpleSharedLib/SimpleFramework.cpp</a>, <a class="el" href="_nvn_tutorial_2_render_thread_pool_8cpp-example.html#a14">NvnTutorial/RenderThreadPool.cpp</a>, <a class="el" href="_nvn_tutorial04_multi_threaded_asset_file_loading_2_nvn_tutorial04_8cpp-example.html#a40">NvnTutorial04MultiThreadedAssetFileLoading/NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial06_frame_buffering_2_nvn_tutorial06_8cpp-example.html#a44">NvnTutorial06FrameBuffering/NvnTutorial06.cpp</a>, <a class="el" href="_os_barrier_2_os_barrier_8cpp-example.html#a16">OsBarrier/OsBarrier.cpp</a>, <a class="el" href="_os_condition_variable_2_os_condition_variable_8cpp-example.html#a18">OsConditionVariable/OsConditionVariable.cpp</a>, <a class="el" href="_os_event_2_os_event_8cpp-example.html#a17">OsEvent/OsEvent.cpp</a>, <a class="el" href="_os_message_queue_2_os_message_queue_8cpp-example.html#a14">OsMessageQueue/OsMessageQueue.cpp</a>, <a class="el" href="_os_multi_wait_2_os_multi_wait_8cpp-example.html#a37">OsMultiWait/OsMultiWait.cpp</a>, <a class="el" href="_os_multi_wait_utility_2_os_multi_wait_utility_8cpp-example.html#a27">OsMultiWaitUtility/OsMultiWaitUtility.cpp</a>, <a class="el" href="_os_mutex_2_os_mutex_8cpp-example.html#a15">OsMutex/OsMutex.cpp</a>, <a class="el" href="_os_reader_writer_lock_2_os_reader_writer_lock_8cpp-example.html#a17">OsReaderWriterLock/OsReaderWriterLock.cpp</a>, <a class="el" href="_os_semaphore_2_os_semaphore_8cpp-example.html#a14">OsSemaphore/OsSemaphore.cpp</a>, <a class="el" href="_os_thread_2_os_thread_8cpp-example.html#a15">OsThread/OsThread.cpp</a>, <a class="el" href="_os_thread_local_storage_2_os_thread_local_storage_8cpp-example.html#a13">OsThreadLocalStorage/OsThreadLocalStorage.cpp</a>, <a class="el" href="_os_timer_event_2_os_timer_event_8cpp-example.html#a23">OsTimerEvent/OsTimerEvent.cpp</a>, <a class="el" href="_perf_simple_2_perf_simple_8cpp-example.html#a65">PerfSimple/PerfSimple.cpp</a>, <a class="el" href="_profiler_thread_state_2_profiler_thread_state_8cpp-example.html#a21">ProfilerThreadState/ProfilerThreadState.cpp</a>, and <a class="el" href="_web_socket_chat_2_web_socket_chat_8cpp-example.html#a27">WebSocketChat/WebSocketChat.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a18eec7c4c4c298f7abaa9ef41d6de76b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18eec7c4c4c298f7abaa9ef41d6de76b">&#9670;&nbsp;</a></span>StartThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::StartThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts execution on a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="This structure defines a thread object.">ThreadType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>thread</em></code> is in the <code>Initialized</code> state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>thread</em></code> is in the <code>Started</code> state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Starts execution on the specified thread. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a92">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a68">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_bcat_practical_2_bcat_practical_8cpp-example.html#a7">BcatPractical/BcatPractical.cpp</a>, <a class="el" href="_g3d_demo_2_parallel_8cpp-example.html#a132">G3dDemo/Parallel.cpp</a>, <a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__main_8cpp-example.html#a29">HidControllerSequence/HidControllerSequence_Main.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_access_point_2_ldn_access_point_8cpp-example.html#a70">LdnBasic/LdnAccessPoint/LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_station_2_ldn_station_8cpp-example.html#a66">LdnBasic/LdnStation/LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a67">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_nifm_network_connection_simple_2_nifm_network_connection_simple__main_8cpp-example.html#a7">NifmNetworkConnectionSimple/NifmNetworkConnectionSimple_Main.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_simple_framework_8cpp-example.html#a29">NvnSimple/NvnSimpleSharedLib/SimpleFramework.cpp</a>, <a class="el" href="_nvn_tutorial_2_render_thread_pool_8cpp-example.html#a11">NvnTutorial/RenderThreadPool.cpp</a>, <a class="el" href="_nvn_tutorial04_multi_threaded_asset_file_loading_2_nvn_tutorial04_8cpp-example.html#a37">NvnTutorial04MultiThreadedAssetFileLoading/NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial06_frame_buffering_2_nvn_tutorial06_8cpp-example.html#a41">NvnTutorial06FrameBuffering/NvnTutorial06.cpp</a>, <a class="el" href="_oe_disable_auto_sleep_2_oe_disable_auto_sleep_8cpp-example.html#a12">OeDisableAutoSleep/OeDisableAutoSleep.cpp</a>, <a class="el" href="_oe_idle_policy_2_oe_idle_policy_8cpp-example.html#a16">OeIdlePolicy/OeIdlePolicy.cpp</a>, <a class="el" href="_os_barrier_2_os_barrier_8cpp-example.html#a14">OsBarrier/OsBarrier.cpp</a>, <a class="el" href="_os_condition_variable_2_os_condition_variable_8cpp-example.html#a16">OsConditionVariable/OsConditionVariable.cpp</a>, <a class="el" href="_os_event_2_os_event_8cpp-example.html#a15">OsEvent/OsEvent.cpp</a>, <a class="el" href="_os_message_queue_2_os_message_queue_8cpp-example.html#a12">OsMessageQueue/OsMessageQueue.cpp</a>, <a class="el" href="_os_multi_wait_2_os_multi_wait_8cpp-example.html#a35">OsMultiWait/OsMultiWait.cpp</a>, <a class="el" href="_os_multi_wait_utility_2_os_multi_wait_utility_8cpp-example.html#a25">OsMultiWaitUtility/OsMultiWaitUtility.cpp</a>, <a class="el" href="_os_mutex_2_os_mutex_8cpp-example.html#a11">OsMutex/OsMutex.cpp</a>, <a class="el" href="_os_reader_writer_lock_2_os_reader_writer_lock_8cpp-example.html#a14">OsReaderWriterLock/OsReaderWriterLock.cpp</a>, <a class="el" href="_os_semaphore_2_os_semaphore_8cpp-example.html#a12">OsSemaphore/OsSemaphore.cpp</a>, <a class="el" href="_os_thread_2_os_thread_8cpp-example.html#a14">OsThread/OsThread.cpp</a>, <a class="el" href="_os_thread_local_storage_2_os_thread_local_storage_8cpp-example.html#a11">OsThreadLocalStorage/OsThreadLocalStorage.cpp</a>, <a class="el" href="_os_timer_event_2_os_timer_event_8cpp-example.html#a17">OsTimerEvent/OsTimerEvent.cpp</a>, <a class="el" href="_perf_simple_2_perf_simple_8cpp-example.html#a161">PerfSimple/PerfSimple.cpp</a>, <a class="el" href="_profiler_thread_state_2_profiler_thread_state_8cpp-example.html#a14">ProfilerThreadState/ProfilerThreadState.cpp</a>, <a class="el" href="_socket_event_fd_2_socket_event_fd_8cpp-example.html#a34">SocketEventFd/SocketEventFd.cpp</a>, <a class="el" href="_socket_statistics_overlay_2_socket_statistics_overlay_8cpp-example.html#a67">SocketStatisticsOverlay/SocketStatisticsOverlay.cpp</a>, <a class="el" href="_vi_timestamp_2_vi_timestamp_8cpp-example.html#a34">ViTimestamp/ViTimestamp.cpp</a>, and <a class="el" href="_web_socket_chat_2_web_socket_chat_8cpp-example.html#a25">WebSocketChat/WebSocketChat.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad106866a5b13bc3d430104333966b479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad106866a5b13bc3d430104333966b479">&#9670;&nbsp;</a></span>GetCurrentThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a>* nn::os::GetCurrentThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a <code><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="This structure defines a thread object.">ThreadType</a></code> object for the current thread. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="This structure defines a thread object.">ThreadType</a></code> object.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>None.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>Returns a pointer to a <code><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="This structure defines a thread object.">ThreadType</a></code> object for the current thread.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Returns a pointer to a <code><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="This structure defines a thread object.">ThreadType</a></code> object for the current thread. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_framework_demo_2_main_8cpp-example.html#a37">FrameworkDemo/Main.cpp</a>, <a class="el" href="_g3d_demo_2_parallel_8cpp-example.html#a9">G3dDemo/Parallel.cpp</a>, <a class="el" href="_g3d_demo_2_shape_animation_8cpp-example.html#a229">G3dDemo/ShapeAnimation.cpp</a>, <a class="el" href="_g3d_demo_2_skeletal_animation_8cpp-example.html#a114">G3dDemo/SkeletalAnimation.cpp</a>, <a class="el" href="_g3d_demo_2_tessellation_8cpp-example.html#a110">G3dDemo/Tessellation.cpp</a>, <a class="el" href="_g3d_demo_2_town_8cpp-example.html#a172">G3dDemo/Town.cpp</a>, <a class="el" href="_gfx_primitive_renderer_2_gfx_primitive_renderer_8cpp-example.html#a381">GfxPrimitiveRenderer/GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__main_8cpp-example.html#a12">HidControllerSequence/HidControllerSequence_Main.cpp</a>, <a class="el" href="_ldn_simple_2_main_8cpp-example.html#a7">LdnSimple/Main.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a6">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_os_user_exception_handler_sample_8cpp-example.html#a20">OsUserExceptionHandlerSample.cpp</a>, <a class="el" href="_perf_simple_2_perf_simple_8cpp-example.html#a63">PerfSimple/PerfSimple.cpp</a>, and <a class="el" href="_vi_timestamp_2_vi_timestamp_8cpp-example.html#a31">ViTimestamp/ViTimestamp.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a182856f23709b02b6022cc1b1765f69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182856f23709b02b6022cc1b1765f69e">&#9670;&nbsp;</a></span>TryWaitThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TryWaitThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Polls to determine whether the target thread has ended. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="This structure defines a thread object.">ThreadType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a Boolean value indicating whether the thread specified by <code><em>thread</em></code> has ended.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>thread</em></code> is in the <code>Initialized</code>, <code>Started</code>, or <code>Exited</code> state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The state is the same as when <code><em>thread</em></code> was called.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Returns <code>true</code> if the target thread is finished processing, or <code>false</code> otherwise. When <code>true</code> is returned, the <code><em>thread</em></code> object is in an excited state. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_web_socket_chat_2_web_socket_chat_8cpp-example.html#a26">WebSocketChat/WebSocketChat.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a8070c91be85c5ccb36b56e9ff3a75b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8070c91be85c5ccb36b56e9ff3a75b26">&#9670;&nbsp;</a></span>WaitThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::WaitThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for the specified thread to stop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="This structure defines a thread object.">ThreadType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>thread</em></code> is in the <code>Initialized</code>, <code>Started</code>, or <code>Exited</code> state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>thread</em></code> is in the <code>Exited</code> state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Waits (blocks) until the specified thread stops. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a107">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a69">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_g3d_demo_2_parallel_8cpp-example.html#a139">G3dDemo/Parallel.cpp</a>, <a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__main_8cpp-example.html#a28">HidControllerSequence/HidControllerSequence_Main.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_access_point_2_ldn_access_point_8cpp-example.html#a72">LdnBasic/LdnAccessPoint/LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_station_2_ldn_station_8cpp-example.html#a67">LdnBasic/LdnStation/LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a68">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_nifm_network_connection_simple_2_nifm_network_connection_simple__main_8cpp-example.html#a9">NifmNetworkConnectionSimple/NifmNetworkConnectionSimple_Main.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_simple_framework_8cpp-example.html#a36">NvnSimple/NvnSimpleSharedLib/SimpleFramework.cpp</a>, <a class="el" href="_nvn_tutorial_2_render_thread_pool_8cpp-example.html#a13">NvnTutorial/RenderThreadPool.cpp</a>, <a class="el" href="_nvn_tutorial04_multi_threaded_asset_file_loading_2_nvn_tutorial04_8cpp-example.html#a38">NvnTutorial04MultiThreadedAssetFileLoading/NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial06_frame_buffering_2_nvn_tutorial06_8cpp-example.html#a42">NvnTutorial06FrameBuffering/NvnTutorial06.cpp</a>, <a class="el" href="_os_barrier_2_os_barrier_8cpp-example.html#a15">OsBarrier/OsBarrier.cpp</a>, <a class="el" href="_os_condition_variable_2_os_condition_variable_8cpp-example.html#a17">OsConditionVariable/OsConditionVariable.cpp</a>, <a class="el" href="_os_event_2_os_event_8cpp-example.html#a16">OsEvent/OsEvent.cpp</a>, <a class="el" href="_os_message_queue_2_os_message_queue_8cpp-example.html#a13">OsMessageQueue/OsMessageQueue.cpp</a>, <a class="el" href="_os_multi_wait_2_os_multi_wait_8cpp-example.html#a36">OsMultiWait/OsMultiWait.cpp</a>, <a class="el" href="_os_multi_wait_utility_2_os_multi_wait_utility_8cpp-example.html#a26">OsMultiWaitUtility/OsMultiWaitUtility.cpp</a>, <a class="el" href="_os_mutex_2_os_mutex_8cpp-example.html#a12">OsMutex/OsMutex.cpp</a>, <a class="el" href="_os_reader_writer_lock_2_os_reader_writer_lock_8cpp-example.html#a16">OsReaderWriterLock/OsReaderWriterLock.cpp</a>, <a class="el" href="_os_semaphore_2_os_semaphore_8cpp-example.html#a13">OsSemaphore/OsSemaphore.cpp</a>, <a class="el" href="_os_thread_2_os_thread_8cpp-example.html#a7">OsThread/OsThread.cpp</a>, <a class="el" href="_os_thread_local_storage_2_os_thread_local_storage_8cpp-example.html#a12">OsThreadLocalStorage/OsThreadLocalStorage.cpp</a>, <a class="el" href="_os_timer_event_2_os_timer_event_8cpp-example.html#a22">OsTimerEvent/OsTimerEvent.cpp</a>, <a class="el" href="_profiler_thread_state_2_profiler_thread_state_8cpp-example.html#a20">ProfilerThreadState/ProfilerThreadState.cpp</a>, <a class="el" href="_socket_event_fd_2_socket_event_fd_8cpp-example.html#a46">SocketEventFd/SocketEventFd.cpp</a>, <a class="el" href="_socket_statistics_overlay_2_socket_statistics_overlay_8cpp-example.html#a68">SocketStatisticsOverlay/SocketStatisticsOverlay.cpp</a>, and <a class="el" href="_vi_timestamp_2_vi_timestamp_8cpp-example.html#a41">ViTimestamp/ViTimestamp.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a8bd5e5e72c058eb7d1b5f0ebfbb2cf6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd5e5e72c058eb7d1b5f0ebfbb2cf6f">&#9670;&nbsp;</a></span>YieldThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::YieldThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides an opportunity to execute to another thread of the same priority. </p>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>None.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>Provides an opportunity to execute to another thread with the same priority as the current thread.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function provides an opportunity to execute to other threads that are ready to run on the same core as the current thread and have the same priority as the current thread.</p>
<p>If the core has no other threads with the same priority, the current thread may continue to execute. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_nvn_tutorial_2_render_thread_pool_8cpp-example.html#a12">NvnTutorial/RenderThreadPool.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a96b335e87af44c60a0d6dca75f11c9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b335e87af44c60a0d6dca75f11c9d2">&#9670;&nbsp;</a></span>SleepThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SleepThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts the current thread to sleep for the specified amount of time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>Amount of time to put the current thread to sleep for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>time</em></code> &gt;= <code>0</code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>Puts the current thread to sleep for the amount of time specified in <code><em>time</em></code>, and then automatically wakes the thread after the time elapses.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Puts the current thread to sleep for the specified amount of time. The thread cannot be waked from another thread. The units of the sleep time depend on the <code><a class="el" href="classnn_1_1_time_span.html" title="This class represents a length of time.">TimeSpan</a></code> object. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_album_save_screenshot_2_album_save_screenshot__main_8cpp-example.html#a10">AlbumSaveScreenshot/AlbumSaveScreenshot_Main.cpp</a>, <a class="el" href="_atk_addon_sound_archive_2_atk_addon_sound_archive_8cpp-example.html#a33">AtkAddonSoundArchive/AtkAddonSoundArchive.cpp</a>, <a class="el" href="_atk_effect_2_atk_effect_8cpp-example.html#a59">AtkEffect/AtkEffect.cpp</a>, <a class="el" href="_atk_filter_2_atk_filter_8cpp-example.html#a22">AtkFilter/AtkFilter.cpp</a>, <a class="el" href="_atk_group_2_atk_group_8cpp-example.html#a24">AtkGroup/AtkGroup.cpp</a>, <a class="el" href="_atk_mix_mode_2_atk_mix_mode_8cpp-example.html#a37">AtkMixMode/AtkMixMode.cpp</a>, <a class="el" href="_atk_profile_2_atk_profile_8cpp-example.html#a34">AtkProfile/AtkProfile.cpp</a>, <a class="el" href="_atk_simple_2_atk_simple_8cpp-example.html#a17">AtkSimple/AtkSimple.cpp</a>, <a class="el" href="_atk_sound3_d_2_atk_sound3_d_8cpp-example.html#a28">AtkSound3D/AtkSound3D.cpp</a>, <a class="el" href="_atk_sound_actor_2_atk_sound_actor_8cpp-example.html#a19">AtkSoundActor/AtkSoundActor.cpp</a>, <a class="el" href="_atk_stream_sound_2_atk_stream_sound_8cpp-example.html#a51">AtkStreamSound/AtkStreamSound.cpp</a>, <a class="el" href="_atk_sub_mix_2_atk_sub_mix_8cpp-example.html#a14">AtkSubMix/AtkSubMix.cpp</a>, <a class="el" href="_atk_viewer_2_atk_viewer_8cpp-example.html#a35">AtkViewer/AtkViewer.cpp</a>, <a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a88">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a57">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a70">AudioOut/AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_2_audio_out_with_resampler_8cpp-example.html#a74">AudioOutWithResampler/AudioOutWithResampler.cpp</a>, <a class="el" href="_bcat_practical_2_bcat_practical_8cpp-example.html#a12">BcatPractical/BcatPractical.cpp</a>, <a class="el" href="_bcat_simple_2_bcat_simple_8cpp-example.html#a9">BcatSimple/BcatSimple.cpp</a>, <a class="el" href="_framework_demo_2_main_8cpp-example.html#a44">FrameworkDemo/Main.cpp</a>, <a class="el" href="_friends_simple_2_friends_simple_8cpp-example.html#a11">FriendsSimple/FriendsSimple.cpp</a>, <a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__main_8cpp-example.html#a31">HidControllerSequence/HidControllerSequence_Main.cpp</a>, <a class="el" href="_htcs_2_htcs_target_app_2_htcs_target_app_8cpp-example.html#a15">Htcs/HtcsTargetApp/HtcsTargetApp.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_access_point_2_ldn_access_point_8cpp-example.html#a107">LdnBasic/LdnAccessPoint/LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_station_2_ldn_station_8cpp-example.html#a105">LdnBasic/LdnStation/LdnStation.cpp</a>, <a class="el" href="_ldn_simple_2_main_8cpp-example.html#a14">LdnSimple/Main.cpp</a>, <a class="el" href="_libcurl_2_basic_2_libcurl_basic_8cpp-example.html#a13">Libcurl/Basic/LibcurlBasic.cpp</a>, <a class="el" href="_libcurl_2_speed_test_2_libcurl_speed_test_8cpp-example.html#a39">Libcurl/SpeedTest/LibcurlSpeedTest.cpp</a>, <a class="el" href="_libcurl_2_ssl_context_import_2_libcurl_ssl_context_import_8cpp-example.html#a13">Libcurl/SslContextImport/LibcurlSslContextImport.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a44">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_nifm_network_connection_simple_2_nifm_network_connection_simple_8cpp-example.html#a2">NifmNetworkConnectionSimple/NifmNetworkConnectionSimple.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_font_8cpp-example.html#a11">NvnSimple/NvnSimpleSharedLib/Font.cpp</a>, <a class="el" href="_oe_disable_auto_sleep_2_oe_disable_auto_sleep_8cpp-example.html#a22">OeDisableAutoSleep/OeDisableAutoSleep.cpp</a>, <a class="el" href="_oe_idle_policy_2_oe_idle_policy_8cpp-example.html#a17">OeIdlePolicy/OeIdlePolicy.cpp</a>, <a class="el" href="_oe_idle_policy_api_for_application_specific_control_2_oe_idle_policy_api_for_application_specific_control_8cpp-example.html#a1">OeIdlePolicyApiForApplicationSpecificControl/OeIdlePolicyApiForApplicationSpecificControl.cpp</a>, <a class="el" href="_openssl_2_client_2_openssl_client_8cpp-example.html#a63">Openssl/Client/OpensslClient.cpp</a>, <a class="el" href="_os_barrier_2_os_barrier_8cpp-example.html#a6">OsBarrier/OsBarrier.cpp</a>, <a class="el" href="_os_event_2_os_event_8cpp-example.html#a5">OsEvent/OsEvent.cpp</a>, <a class="el" href="_os_multi_wait_2_os_multi_wait_8cpp-example.html#a22">OsMultiWait/OsMultiWait.cpp</a>, <a class="el" href="_os_multi_wait_utility_2_os_multi_wait_utility_8cpp-example.html#a12">OsMultiWaitUtility/OsMultiWaitUtility.cpp</a>, <a class="el" href="_os_reader_writer_lock_2_os_reader_writer_lock_8cpp-example.html#a7">OsReaderWriterLock/OsReaderWriterLock.cpp</a>, <a class="el" href="_os_semaphore_2_os_semaphore_8cpp-example.html#a4">OsSemaphore/OsSemaphore.cpp</a>, <a class="el" href="_os_tick_and_time_span_2_os_tick_and_time_span_8cpp-example.html#a8">OsTickAndTimeSpan/OsTickAndTimeSpan.cpp</a>, <a class="el" href="_pcm_basic_2_pcm_basic_8cpp-example.html#a17">PcmBasic/PcmBasic.cpp</a>, <a class="el" href="_profiler_simple_2_profiler_simple_8cpp-example.html#a3">ProfilerSimple/ProfilerSimple.cpp</a>, <a class="el" href="_profiler_thread_state_2_profiler_thread_state_8cpp-example.html#a18">ProfilerThreadState/ProfilerThreadState.cpp</a>, <a class="el" href="_socket_basic_2_socket_basic_8cpp-example.html#a37">SocketBasic/SocketBasic.cpp</a>, <a class="el" href="_socket_resolver_2_socket_resolver_8cpp-example.html#a37">SocketResolver/SocketResolver.cpp</a>, <a class="el" href="_socket_statistics_overlay_2_socket_statistics_overlay_8cpp-example.html#a37">SocketStatisticsOverlay/SocketStatisticsOverlay.cpp</a>, <a class="el" href="_spy_atk_2_spy_atk_8cpp-example.html#a39">SpyAtk/SpyAtk.cpp</a>, <a class="el" href="_ssl_simple_2_ssl_simple_8cpp-example.html#a9">SslSimple/SslSimple.cpp</a>, <a class="el" href="_time_calculate_span_between_2_time_calculate_span_between_8cpp-example.html#a5">TimeCalculateSpanBetween/TimeCalculateSpanBetween.cpp</a>, <a class="el" href="_time_calculate_user_system_clock_difference_2_time_calculate_user_system_clock_difference_8cpp-example.html#a5">TimeCalculateUserSystemClockDifference/TimeCalculateUserSystemClockDifference.cpp</a>, <a class="el" href="_time_claim_periodic_benefit_2_time_claim_periodic_benefit_8cpp-example.html#a26">TimeClaimPeriodicBenefit/TimeClaimPeriodicBenefit.cpp</a>, <a class="el" href="_web_socket_chat_2_web_socket_chat_8cpp-example.html#a30">WebSocketChat/WebSocketChat.cpp</a>, and <a class="el" href="_web_socket_echo_2_web_socket_echo_8cpp-example.html#a38">WebSocketEcho/WebSocketEcho.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac7eb0e6eae11777e92308cdee62e6cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7eb0e6eae11777e92308cdee62e6cb2">&#9670;&nbsp;</a></span>ChangeThreadPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::os::ChangeThreadPriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the priority of the specified thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="This structure defines a thread object.">ThreadType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td>Priority to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Thread priority prior to the change.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>thread</em></code> is in the <code>Initialized</code>, <code>Started</code>, or <code>Exited</code> state.</li>
<li><code><a class="el" href="namespacenn_1_1os.html#a44ed3b4dddf9ebfb69bc33167369b816" title="Constant indicating the highest thread priority.">nn::os::HighestThreadPriority</a></code> &lt;= <code><em>priority</em></code> &lt;= <code><a class="el" href="namespacenn_1_1os.html#a88510f5f630a16612aa8d479c10b56de" title="Constant indicating the lowest thread priority.">nn::os::LowestThreadPriority</a></code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The state is the same as when <code><em>thread</em></code> was called.</li>
<li><code><em>thread</em></code> has a new priority and is in the lowest position of the group of threads with that priority.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Changes the priority of the specified thread. The thread priority is indicated by <code><em>priority</em></code>, which takes a value from <code><a class="el" href="namespacenn_1_1os.html#a44ed3b4dddf9ebfb69bc33167369b816" title="Constant indicating the highest thread priority.">nn::os::HighestThreadPriority</a></code> to <code><a class="el" href="namespacenn_1_1os.html#a88510f5f630a16612aa8d479c10b56de" title="Constant indicating the lowest thread priority.">nn::os::LowestThreadPriority</a></code>. A smaller number indicates a higher priority.</p>
<p>If the specified thread is waiting for some sort of synchronization object, the handling of that thread in the queue is determined by the policy of the synchronization object. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_thread_2_os_thread_8cpp-example.html#a9">OsThread/OsThread.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a912a6d5e17c206344f177bc192cb1e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a912a6d5e17c206344f177bc192cb1e50">&#9670;&nbsp;</a></span>GetThreadPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::os::GetThreadPriority </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the original priority of the specified thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="This structure defines a thread object.">ThreadType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Original priority of the specified thread.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>thread</em></code> is in the <code>Initialized</code>, <code>Started</code>, or <code>Exited</code> state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The state is the same as when <code><em>thread</em></code> was called.</li>
<li>Returns the original priority of <code><em>thread</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Returns the original priority of the specified thread. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_thread_2_os_thread_8cpp-example.html#a4">OsThread/OsThread.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a9b6b2e5e1968e008dde27d6c4762b33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b6b2e5e1968e008dde27d6c4762b33d">&#9670;&nbsp;</a></span>GetThreadCurrentPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::os::GetThreadCurrentPriority </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current priority of the specified thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="This structure defines a thread object.">ThreadType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current priority of the specified thread.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>thread</em></code> is in the <code>Initialized</code>, <code>Started</code>, or <code>Exited</code> state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The state is the same as when <code><em>thread</em></code> was called.</li>
<li>Returns the current priority of <code><em>thread</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Returns the current priority of the specified thread. If the mutex priority inheritance is active, returns the inherited priority.</p>
<p>The thread priority can change at any time, due to factors such as another thread calling <code><a class="el" href="namespacenn_1_1os.html#ac7eb0e6eae11777e92308cdee62e6cb2" title="Changes the priority of the specified thread.">ChangeThreadPriority()</a></code> or mutex priority inheritance.</p>
<p>The current priority reference just gets an instantaneous value. Consider this fact when using the API. </p>

</div>
</div>
<a id="a05cbcb85bd308694ec37eff49be93cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05cbcb85bd308694ec37eff49be93cf1">&#9670;&nbsp;</a></span>SetThreadName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SetThreadName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>threadName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the name of the specified thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="This structure defines a thread object.">ThreadType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threadName</td><td>Address where the null-terminated string for the thread name is stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>thread</em></code> is in the <code>Initialized</code>, <code>Started</code>, or <code>Exited</code> state.</li>
<li>The string specified in <code><em>threadName</em></code> is shorter than <code><a class="el" href="namespacenn_1_1os.html#a793a3781900c43f3d8afda6e02ec1b58" title="Constant indicating the maximum length of a thread name.">nn::os::ThreadNameLengthMax</a></code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The state is the same as when <code><em>thread</em></code> was called.</li>
<li>The thread name of <code><em>thread</em></code> is changed to the name indicated by <code><em>threadName</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sets the name of the specified thread. If <code><em>threadName</em></code> is <code>NULL</code>, the thread name reverts to the initial state.</p>
<p>The set thread name is stored in the <code><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="This structure defines a thread object.">ThreadType</a></code> object, so the memory area that <code><em>threadName</em></code> points to does not need to be retained. Also, you can use the <code>nn:os:<a class="el" href="namespacenn_1_1os.html#a2941b0122ed1f1af2d7007af285d83b5" title="Gets the address where the name of the target thread is stored.">GetThreadNamePointer()</a></code> function to get the address where the thread name set with this API function is stored.</p>
<p>The thread name assumes ASCII encoding. The maximum string length, including the terminating null character, must be equal to or less than <code><a class="el" href="namespacenn_1_1os.html#a793a3781900c43f3d8afda6e02ec1b58" title="Constant indicating the maximum length of a thread name.">nn::os::ThreadNameLengthMax</a></code>. If the thread name exceeds the maximum length, the function causes an assertion failure.</p>
<p><code><a class="el" href="namespacenn_1_1os.html#a793a3781900c43f3d8afda6e02ec1b58" title="Constant indicating the maximum length of a thread name.">nn::os::ThreadNameLengthMax</a></code> is a specific value that does not depend on the operating environment.</p>
<p>This function is not thread-safe. Do not delete the target thread or call the <code><a class="el" href="namespacenn_1_1os.html#a05cbcb85bd308694ec37eff49be93cf1" title="Sets the name of the specified thread.">nn::os::SetThreadName()</a>&lt;</code> or <code><a class="el" href="namespacenn_1_1os.html#a90f2d7d33024e710d09a2b6d01b15522" title="The address where the name of the target thread is stored.">nn::os::SetThreadNamePointer()</a></code> functions while this API function is running.</p>
<div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
<ul>
<li>The Visual Studio debugger can end abnormally when running a program that will continuously call this function within a Windows environment. This problem seems to be due to Visual Studio's inability to keep up with thread name change notifications. For this reason, please avoid processing that would continuously call this API when connected to the Visual Studio debugger.</li>
</ul>
</div><div class="platform_section" data-platform="Windows"></div> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ldn_simple_2_main_8cpp-example.html#a6">LdnSimple/Main.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a65">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_os_thread_2_os_thread_8cpp-example.html#a8">OsThread/OsThread.cpp</a>, <a class="el" href="_perf_simple_2_perf_simple_8cpp-example.html#a58">PerfSimple/PerfSimple.cpp</a>, and <a class="el" href="_profiler_thread_state_2_profiler_thread_state_8cpp-example.html#a13">ProfilerThreadState/ProfilerThreadState.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a90f2d7d33024e710d09a2b6d01b15522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f2d7d33024e710d09a2b6d01b15522">&#9670;&nbsp;</a></span>SetThreadNamePointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SetThreadNamePointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>threadName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The address where the name of the target thread is stored. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="This structure defines a thread object.">ThreadType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threadName</td><td>Address where the null-terminated string for the thread name is stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>thread</em></code> is in the <code>Initialized</code>, <code>Started</code>, or <code>Exited</code> state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The state is the same as when <code><em>thread</em></code> was called.</li>
<li>The thread name of <code><em>thread</em></code> is changed to the name indicated by <code><em>threadName</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sets the name of the specified thread. If <code><em>threadName</em></code> is <code>NULL</code>, the thread name reverts to the initial state.</p>
<p>The specified thread name holds only its start address in an internal <code><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="This structure defines a thread object.">ThreadType</a></code> object. For that reason, the memory region containing the thread name must be maintained in a usable state until either the <code><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="This structure defines a thread object.">ThreadType</a></code> is freed or a new thread name is set.</p>
<p>You can use the <code>nn:os:<a class="el" href="namespacenn_1_1os.html#a2941b0122ed1f1af2d7007af285d83b5" title="Gets the address where the name of the target thread is stored.">GetThreadNamePointer()</a></code> function to get the address where the thread name set with this API function is stored.</p>
<p>This function is not thread-safe. Do not delete the target thread or call the <code><a class="el" href="namespacenn_1_1os.html#a05cbcb85bd308694ec37eff49be93cf1" title="Sets the name of the specified thread.">nn::os::SetThreadName()</a>&lt;</code> or <code><a class="el" href="namespacenn_1_1os.html#a90f2d7d33024e710d09a2b6d01b15522" title="The address where the name of the target thread is stored.">nn::os::SetThreadNamePointer()</a></code> functions while this API function is running.</p>
<div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
<ul>
<li>The Visual Studio debugger can end abnormally when running a program that will continuously call this function within a Windows environment. This problem seems to be due to Visual Studio's inability to keep up with thread name change notifications. For this reason, please avoid processing that would continuously call this API when connected to the Visual Studio debugger.</li>
</ul>
</div><div class="platform_section" data-platform="Windows"></div> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_nifm_network_connection_simple_2_nifm_network_connection_simple__main_8cpp-example.html#a6">NifmNetworkConnectionSimple/NifmNetworkConnectionSimple_Main.cpp</a>, <a class="el" href="_oe_disable_auto_sleep_2_oe_disable_auto_sleep_8cpp-example.html#a11">OeDisableAutoSleep/OeDisableAutoSleep.cpp</a>, and <a class="el" href="_oe_idle_policy_2_oe_idle_policy_8cpp-example.html#a15">OeIdlePolicy/OeIdlePolicy.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a2941b0122ed1f1af2d7007af285d83b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2941b0122ed1f1af2d7007af285d83b5">&#9670;&nbsp;</a></span>GetThreadNamePointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * nn::os::GetThreadNamePointer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the address where the name of the target thread is stored. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="This structure defines a thread object.">ThreadType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address where the name of the target thread is stored.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>thread</em></code> is in the <code>Initialized</code>, <code>Started</code>, or <code>Exited</code> state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The state is the same as when <code><em>thread</em></code> was called.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the address where the name of the target thread is stored.</p>
<p>When the thread name is set with the <code><a class="el" href="namespacenn_1_1os.html#a05cbcb85bd308694ec37eff49be93cf1" title="Sets the name of the specified thread.">nn::os::SetThreadName()</a></code> function, this function returns the start address of the region where the thread name is stored, which is held in the <code><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="This structure defines a thread object.">ThreadType</a></code> object. When the thread name is set with the <code><a class="el" href="namespacenn_1_1os.html#a90f2d7d33024e710d09a2b6d01b15522" title="The address where the name of the target thread is stored.">nn::os::SetThreadNamePointer()</a></code> function, this function returns the thread name set with the <code><a class="el" href="namespacenn_1_1os.html#a90f2d7d33024e710d09a2b6d01b15522" title="The address where the name of the target thread is stored.">nn::os::SetThreadNamePointer()</a></code> function.</p>
<p>If the thread name is unchanged, or if the thread name has been restored to its initial state by the API functions described previously, the thread name storage region in the <code><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="This structure defines a thread object.">nn::os::ThreadType</a></code> object stores the initial thread name, and this function returns its start address. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__main_8cpp-example.html#a37">HidControllerSequence/HidControllerSequence_Main.cpp</a>, <a class="el" href="_os_thread_2_os_thread_8cpp-example.html#a3">OsThread/OsThread.cpp</a>, and <a class="el" href="_os_user_exception_handler_sample_8cpp-example.html#a21">OsUserExceptionHandlerSample.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a500af81132a0e2b26db7289bbd19942e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a500af81132a0e2b26db7289bbd19942e">&#9670;&nbsp;</a></span>GetCurrentProcessorNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::os::GetCurrentProcessorNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the core number on which the current thread is running. </p>
<p>This function is deprecated. Please check the details for usage conditions and substitute functions. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000009">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Core number on which the current thread is running.</dd></dl>
<p> <b>Details</b> <br  />
 This function has been deprecated and is scheduled for removal. Use <code><a class="el" href="namespacenn_1_1os.html#a4b94c321b41c4fb4d0a4e87473297c48" title="Gets the core number on which the current thread is running.">nn::os::GetCurrentCoreNumber()</a></code> instead. </p>

</div>
</div>
<a id="a4b94c321b41c4fb4d0a4e87473297c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b94c321b41c4fb4d0a4e87473297c48">&#9670;&nbsp;</a></span>GetCurrentCoreNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::os::GetCurrentCoreNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the core number on which the current thread is running. </p>
<dl class="section return"><dt>Returns</dt><dd>Core number on which the current thread is running.</dd></dl>
<p> <b>Details</b> <br  />
 Gets the core number on which the current thread is running. The range of core numbers that can be returned depends on the target environment. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_thread_2_os_thread_8cpp-example.html#a5">OsThread/OsThread.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac50b86561c15ee3e8195c83fddc8e732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac50b86561c15ee3e8195c83fddc8e732">&#9670;&nbsp;</a></span>SetThreadCoreMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SetThreadCoreMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idealCore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bit64&#160;</td>
          <td class="paramname"><em>affinityMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the target thread core assignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="This structure defines a thread object.">ThreadType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idealCore</td><td>Preferred core number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">affinityMask</td><td>Affinity mask for each core.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>thread</em></code> is in the <code>Initialized</code>, <code>Started</code>, or <code>Exited</code> state.</li>
<li><code><em>idealCore</em></code> is a special value that can be specified or is a valid core number.</li>
<li>When <code><em>idealCore</em></code> is a core number, the core specified by <code><em>idealCore</em></code> is contained in <code><em>affinityMask</em></code>.</li>
<li>If <code><em>idealCore</em></code> != <code><a class="el" href="namespacenn_1_1os.html#a3959f30f2583f83a37ec382f091fd9fa" title="Only operates on the preferred core set in this program.">nn::os::IdealCoreUseDefaultValue</a></code>, <code><em>affinityMask</em></code> contains at least one usable core.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The state is the same as when <code><em>thread</em></code> was called.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code><em>idealCore</em></code> specifies the preferred core to run on. <code><em>idealCore</em></code> may take the following values in addition to a core number.</p>
<ul>
<li><code><a class="el" href="namespacenn_1_1os.html#a3959f30f2583f83a37ec382f091fd9fa" title="Only operates on the preferred core set in this program.">nn::os::IdealCoreUseDefaultValue</a>:</code>: Sets both an affinity mask and a preferred core so processes run only on the preferred core set in this program. Values specified by <code><em>affinityMask</em></code> are ignored.</li>
<li><code><a class="el" href="namespacenn_1_1os.html#a418170f89de31518fdc59c699d78a1b1" title="Does not update the preferred core number.">nn::os::IdealCoreNoUpdate</a></code>: The preferred core number is not updated.</li>
<li><code><a class="el" href="namespacenn_1_1os.html#a333a7029b85a51321a4c79176e91eab3" title="Sets without a preferred core number.">nn::os::IdealCoreDontCare</a></code>: Configured to not have a preferred core number.</li>
</ul>
<p>Specify usable cores in <code><em>affinityMask</em></code>. If bit <em>n</em> in <code><em>affinityMask</em></code> is set to <code>1</code>, the thread can run on core <em>n</em>.</p>
<p>If <code><a class="el" href="namespacenn_1_1os.html#a418170f89de31518fdc59c699d78a1b1" title="Does not update the preferred core number.">nn::os::IdealCoreNoUpdate</a></code> has been specified for <code><em>idealCore</em></code>, the bit representing the currently configured preferred core must be set to <code>1</code> in <code><em>affinityMask</em></code>.</p>
<div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
<ul>
<li>In the Windows environment, the Windows scheduler restricts which core the thread runs on, even if a preferred core has been specified.</li>
</ul>
</div><div class="platform_section" data-platform="Windows"></div><p> <b>In the development hardware environment</b></p>
<ul>
<li>In the development hardware environment, the target thread does not move to another core immediately after this function is called. Rather, the implementation is designed for the thread to move to a different core when it runs again. </li>
</ul>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_framework_demo_2_main_8cpp-example.html#a36">FrameworkDemo/Main.cpp</a>, <a class="el" href="_g3d_demo_2_parallel_8cpp-example.html#a118">G3dDemo/Parallel.cpp</a>, <a class="el" href="_g3d_demo_2_shape_animation_8cpp-example.html#a228">G3dDemo/ShapeAnimation.cpp</a>, <a class="el" href="_g3d_demo_2_skeletal_animation_8cpp-example.html#a113">G3dDemo/SkeletalAnimation.cpp</a>, <a class="el" href="_g3d_demo_2_tessellation_8cpp-example.html#a109">G3dDemo/Tessellation.cpp</a>, <a class="el" href="_g3d_demo_2_town_8cpp-example.html#a171">G3dDemo/Town.cpp</a>, <a class="el" href="_gfx_primitive_renderer_2_gfx_primitive_renderer_8cpp-example.html#a380">GfxPrimitiveRenderer/GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__main_8cpp-example.html#a11">HidControllerSequence/HidControllerSequence_Main.cpp</a>, <a class="el" href="_perf_simple_2_perf_simple_8cpp-example.html#a59">PerfSimple/PerfSimple.cpp</a>, and <a class="el" href="_vi_timestamp_2_vi_timestamp_8cpp-example.html#a30">ViTimestamp/ViTimestamp.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a39edb8f3e676c4bab13047a5ad1894f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39edb8f3e676c4bab13047a5ad1894f8">&#9670;&nbsp;</a></span>GetThreadCoreMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::GetThreadCoreMask </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutIdealCore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bit64 *&#160;</td>
          <td class="paramname"><em>pOutAffinityMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td>
          <td class="paramname"><em>thread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the target thread core assignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutIdealCore</td><td>Pointer to the buffer storing the preferred core number. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutAffinityMask</td><td>Pointer to the buffer storing the affinity mask for each core. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="This structure defines a thread object.">ThreadType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>thread</em></code> is in the <code>Initialized</code>, <code>Started</code>, or <code>Exited</code> state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The state is the same as when <code><em>thread</em></code> was called.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 <code><em>pOutIdealCore</em></code> stores either the core number that has been specified as the preferred core or <code><a class="el" href="namespacenn_1_1os.html#a333a7029b85a51321a4c79176e91eab3" title="Sets without a preferred core number.">nn::os::IdealCoreDontCare</a></code>. If the <em>n</em>th bit in <code>*<em>pOutAffinityMask</em></code> is <code>1</code>, it indicates the ability to run on the number <em>n</em> core.</p>
<p>The value is not obtained when <code>NULL</code> is specified for <code><em>pOutIdealCore</em></code> or <code><em>pOutAffinityMask</em></code>. </p>

</div>
</div>
<a id="a91345e6e4543ab561f49480b89ae9a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91345e6e4543ab561f49480b89ae9a65">&#9670;&nbsp;</a></span>GetThreadAvailableCoreMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nn::Bit64 nn::os::GetThreadAvailableCoreMask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets assignable cores. </p>
<dl class="section return"><dt>Returns</dt><dd>Cores that can be assigned.</dd></dl>
<p> <b>Details</b> <br  />
 Gets cores that may be assigned to the thread. Cores that can be assigned are common to all threads. The <em>n</em>th bit in the return value set to <code>1</code> indicates the ability to run on the number <em>n</em> core. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_nvn_tutorial_2_render_thread_pool_8cpp-example.html#a8">NvnTutorial/RenderThreadPool.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="adcae078c4e6e1d1746ff8bd0eb7f7d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcae078c4e6e1d1746ff8bd0eb7f7d85">&#9670;&nbsp;</a></span>GetThreadId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1os.html#a34ce3817621fa1ea9b26c4f55c3bb284">ThreadId</a> nn::os::GetThreadId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the thread identifier for the target thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="This structure defines a thread object.">ThreadType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Thread identifier for the target thread.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>thread</em></code> is in the <code>Initialized</code>, <code>Started</code>, or <code>Exited</code> state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The state is the same as when <code><em>thread</em></code> was called.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets an ID capable of identifying the thread.</p>
<div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
<ul>
<li>In the Windows environment, it matches the thread identifier obtained by the <code>GetCurrentThreadId()</code> and <code>GetThreadId()</code> Windows APIs.</li>
</ul>
</div><div class="platform_section" data-platform="Windows"></div> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_g3d_demo_2_parallel_8cpp-example.html#a8">G3dDemo/Parallel.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a72d36b7ef64f2c1e82f03d895fdd5609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d36b7ef64f2c1e82f03d895fdd5609">&#9670;&nbsp;</a></span>InitializeMultiWaitHolder() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeMultiWaitHolder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *&#160;</td>
          <td class="paramname"><em>multiWaitHolder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td>
          <td class="paramname"><em>thread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a <code>MultiWaitHolder</code> object and binds it to a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWaitHolder</td><td>Pointer to a multiwait object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>Pointer to the thread to bind to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>multiWaitHolder</em></code> is in an uninitialized state.</li>
<li><code><em>thread</em></code> is in the <code>Initialized</code>, <code>Started</code>, or <code>Exited</code> state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>multiWaitHolder</em></code> is in an initialized state (and bound to <code><em>thread</em></code>).</li>
<li><code><a class="el" href="namespacenn_1_1os.html#a9e8c73312415fc00c72808fcc00fea33">nn::os::GetMultiWaitHolderUserData(multiWaitHolder)</a></code> == <code>0</code>.</li>
<li>The state is the same as when <code><em>thread</em></code> was called.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Initializes a <code><em>multiWaitHolder</em></code> object and binds it to the object specified in <code><em>thread</em></code>.</p>
<p>The bound <code><em>multiWaitHolder</em></code> enters a signaled state when the thread ends. If the thread has already ended, the object enters a signaled state immediately.</p>
<p>Do not operate on <code><em>multiWaitHolder</em></code> while this function is being called. </p>

</div>
</div>
<a id="a2a67ebeb78e5d624b45ec27d66bdf0b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a67ebeb78e5d624b45ec27d66bdf0b2">&#9670;&nbsp;</a></span>AllocateTlsSlot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::os::AllocateTlsSlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_tls_slot.html">TlsSlot</a> *&#160;</td>
          <td class="paramname"><em>outTlsSlot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1os.html#af369e7c06c6548eebe7abda706ec54f3">TlsDestructor</a>&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates an empty TLS slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outTlsSlot</td><td>Location to store the retrieved TLS slot number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Entry point for the destructor callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1os_1_1_result_out_of_resource.html">nn::os::ResultOutOfResource</a> must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>None.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>Allocates an empty TLS slot and stores the slot number in <em>outTlsSlot</em>.</li>
<li>Sets the initial TLS value of the allocated TLS slot to <code>0</code> (all threads).</li>
<li>If <em>function</em> is not <code>NULL</code>, registers the TLS destructor function.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Allocates one unused and empty TLS slot and returns its slot number. The initial TLS value of the allocated slot is always <code>0</code>.</p>
<p>Specify the callback function to be called as the TLS destructor when the thread ends in <code><em>function</em></code>. The callback function is called with the context of the thread that is ending.</p>
<p>The callback function is of the <code><a class="el" href="namespacenn_1_1os.html#af369e7c06c6548eebe7abda706ec54f3" title="This type represents a TLS destructor function.">nn::os::TlsDestructor</a></code> type and takes the TLS value of the applicable slot as an argument.</p>
<p>Unlike with POSIX, the callback function is still called even if the TLS value is <code>0</code>. The order in which the callback function for each slot is invoked is undefined.</p>
<p><code>NULL</code> can be specified for <code><em>function</em></code>. If <code><em>function</em></code> is set to <code>NULL</code>, no TLS destructor is registered, and the callback function is not invoked. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_thread_local_storage_2_os_thread_local_storage_8cpp-example.html#a8">OsThreadLocalStorage/OsThreadLocalStorage.cpp</a>, and <a class="el" href="_perf_simple_2_perf_simple_8cpp-example.html#a54">PerfSimple/PerfSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="afded66e76230ba96acc86ba3d48d76c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afded66e76230ba96acc86ba3d48d76c4">&#9670;&nbsp;</a></span>FreeTlsSlot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FreeTlsSlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_tls_slot.html">TlsSlot</a>&#160;</td>
          <td class="paramname"><em>tlsSlot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a TLS slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tlsSlot</td><td>TLS slot number to free.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>An allocated <em>tlsSlot</em> is specified.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The TLS slot specified in <em>tlsSlot</em> is free (in an unused state).</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Frees an allocated TLS slot. <code><a class="el" href="namespacenn_1_1os.html#afded66e76230ba96acc86ba3d48d76c4" title="Frees a TLS slot.">FreeTlsSlot()</a></code> does not invoke the TLS destructor callback function that was set with <code><a class="el" href="namespacenn_1_1os.html#a2a67ebeb78e5d624b45ec27d66bdf0b2" title="Allocates an empty TLS slot.">AllocateTlsSlot()</a></code>. This makes it possible to call the <code><a class="el" href="namespacenn_1_1os.html#afded66e76230ba96acc86ba3d48d76c4" title="Frees a TLS slot.">FreeTlsSlot()</a></code> function from within a callback function registered as a TLS destructor. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_thread_local_storage_2_os_thread_local_storage_8cpp-example.html#a14">OsThreadLocalStorage/OsThreadLocalStorage.cpp</a>, and <a class="el" href="_perf_simple_2_perf_simple_8cpp-example.html#a66">PerfSimple/PerfSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a452445507fba4dc49cb9cfb77b4c88c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452445507fba4dc49cb9cfb77b4c88c1">&#9670;&nbsp;</a></span>GetTlsValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uintptr_t nn::os::GetTlsValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_tls_slot.html">TlsSlot</a>&#160;</td>
          <td class="paramname"><em>tlsSlot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the value from the specified TLS slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tlsSlot</td><td>TLS slot number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the TLS value in the specified slot.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>An allocated <em>tlsSlot</em> is specified.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>Returns the TLS value in the TLS slot specified in <em>tlsSlot</em>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the value from the specified TLS slot. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_thread_local_storage_2_os_thread_local_storage_8cpp-example.html#a2">OsThreadLocalStorage/OsThreadLocalStorage.cpp</a>, and <a class="el" href="_perf_simple_2_perf_simple_8cpp-example.html#a50">PerfSimple/PerfSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a8f54d6581f3380bc9b6b7d92c9855acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f54d6581f3380bc9b6b7d92c9855acd">&#9670;&nbsp;</a></span>SetTlsValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SetTlsValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_tls_slot.html">TlsSlot</a>&#160;</td>
          <td class="paramname"><em>tlsSlot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a value in the specified TLS slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tlsSlot</td><td>TLS slot number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>TLS value to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>An allocated <em>tlsSlot</em> is specified.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>Sets a TLS value in the TLS slot specified in <em>tlsSlot</em>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sets a value in the specified TLS slot. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_thread_local_storage_2_os_thread_local_storage_8cpp-example.html#a4">OsThreadLocalStorage/OsThreadLocalStorage.cpp</a>, and <a class="el" href="_perf_simple_2_perf_simple_8cpp-example.html#a64">PerfSimple/PerfSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aa0db5a1ab770f99f96e327aeb5c653ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0db5a1ab770f99f96e327aeb5c653ce">&#9670;&nbsp;</a></span>GetUsedTlsSlotCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::os::GetUsedTlsSlotCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of allocated TLS slots. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of allocated TLS slots.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>None.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>Returns the number of currently allocated TLS slots.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the number of currently allocated TLS slots. You can also calculate the number of unused slots available for allocation using the formula <code>TlsSlotCountMax - GetUsedTlsSlotCount</code>. </p>

</div>
</div>
<a id="a79e29821bfb2b0c3a5c222488e90cc89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e29821bfb2b0c3a5c222488e90cc89">&#9670;&nbsp;</a></span>GetSystemTick()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1os_1_1_tick.html">Tick</a> nn::os::GetSystemTick </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the system tick value. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the system tick value.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>None.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>Returns the current system tick value.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Returns the current system tick value as a <code><a class="el" href="classnn_1_1os_1_1_tick.html" title="Class for handling system ticks.">Tick</a></code> type. Due to CPU out-of-order execution, there might be changes in the sequence of getting the system tick value and the performance of CPU instructions or memory operations that are done around the time that this function is called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a40">AudioOut/AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_2_audio_out_with_resampler_8cpp-example.html#a40">AudioOutWithResampler/AudioOutWithResampler.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a73">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_ec_purchased_event_2_main_8cpp-example.html#a7">EcPurchasedEvent/Main.cpp</a>, <a class="el" href="_friends_profile_image_2_friends_profile_image_8cpp-example.html#a30">FriendsProfileImage/FriendsProfileImage.cpp</a>, <a class="el" href="_gl_simple_2_gl_simple_8cpp-example.html#a5">GlSimple/GlSimple.cpp</a>, <a class="el" href="_hid_npad_six_axis_sensor_2_hid_npad_six_axis_sensor__main_8cpp-example.html#a50">HidNpadSixAxisSensor/HidNpadSixAxisSensor_Main.cpp</a>, <a class="el" href="_ldn_simple_2_main_8cpp-example.html#a12">LdnSimple/Main.cpp</a>, <a class="el" href="_libcurl_2_basic_2_libcurl_basic_8cpp-example.html#a5">Libcurl/Basic/LibcurlBasic.cpp</a>, <a class="el" href="_libcurl_2_speed_test_2_libcurl_speed_test_8cpp-example.html#a23">Libcurl/SpeedTest/LibcurlSpeedTest.cpp</a>, <a class="el" href="_libcurl_2_ssl_context_import_2_libcurl_ssl_context_import_8cpp-example.html#a5">Libcurl/SslContextImport/LibcurlSslContextImport.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_time_utilities_8cpp-example.html#a2">NvnSimple/NvnSimpleSharedLib/TimeUtilities.cpp</a>, <a class="el" href="_nvn_tutorial_2_tutorial_base_class_8_nx_8cpp-example.html#a9">NvnTutorial/TutorialBaseClass.Nx.cpp</a>, <a class="el" href="_nvn_tutorial12_deferred_renderer_2_nvn_tutorial12_8cpp-example.html#a20">NvnTutorial12DeferredRenderer/NvnTutorial12.cpp</a>, <a class="el" href="_nvn_tutorial13_screen_space_a_o_2_nvn_tutorial13_8cpp-example.html#a20">NvnTutorial13ScreenSpaceAO/NvnTutorial13.cpp</a>, <a class="el" href="_nvn_tutorial14_frustum_culling_2_nvn_tutorial14_8cpp-example.html#a20">NvnTutorial14FrustumCulling/NvnTutorial14.cpp</a>, <a class="el" href="_oe_disable_auto_sleep_2_oe_disable_auto_sleep_8cpp-example.html#a19">OeDisableAutoSleep/OeDisableAutoSleep.cpp</a>, <a class="el" href="_os_barrier_2_os_barrier_8cpp-example.html#a2">OsBarrier/OsBarrier.cpp</a>, <a class="el" href="_os_tick_and_time_span_2_os_tick_and_time_span_8cpp-example.html#a3">OsTickAndTimeSpan/OsTickAndTimeSpan.cpp</a>, <a class="el" href="_os_timer_event_2_os_timer_event_8cpp-example.html#a3">OsTimerEvent/OsTimerEvent.cpp</a>, <a class="el" href="_profiler_simple_2_profiler_simple_8cpp-example.html#a8">ProfilerSimple/ProfilerSimple.cpp</a>, <a class="el" href="_profiler_thread_state_2_profiler_thread_state_8cpp-example.html#a15">ProfilerThreadState/ProfilerThreadState.cpp</a>, <a class="el" href="_spy_atk_2_spy_atk_8cpp-example.html#a29">SpyAtk/SpyAtk.cpp</a>, and <a class="el" href="_spy_audio_2_spy_audio_8cpp-example.html#a80">SpyAudio/SpyAudio.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac0439628669fdcc2c6a94a852b2a6ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0439628669fdcc2c6a94a852b2a6ea3">&#9670;&nbsp;</a></span>GetSystemTickOrdered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1os_1_1_tick.html">Tick</a> nn::os::GetSystemTickOrdered </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the system tick value. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the system tick value.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>None.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>Returns the current system tick value.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Returns the current system tick value as a <code><a class="el" href="classnn_1_1os_1_1_tick.html" title="Class for handling system ticks.">Tick</a></code> type. The system tick value is the value after the completion of CPU instructions and memory operations that preceded the call to this function. CPU instructions that follow this function call are executed after the system tick value has been obtained. </p>

</div>
</div>
<a id="aa64f2523f9e13afef5de6197898afa27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa64f2523f9e13afef5de6197898afa27">&#9670;&nbsp;</a></span>GetSystemTickFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t nn::os::GetSystemTickFrequency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the frequency of the system tick value. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of system ticks per second.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>None.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>Returns the current system tick frequency.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Returns the number of system ticks per second. This is equivalent to the system tick frequency (in Hertz). </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_hid_npad_six_axis_sensor_2_hid_npad_six_axis_sensor__main_8cpp-example.html#a52">HidNpadSixAxisSensor/HidNpadSixAxisSensor_Main.cpp</a>, and <a class="el" href="_os_tick_and_time_span_2_os_tick_and_time_span_8cpp-example.html#a0">OsTickAndTimeSpan/OsTickAndTimeSpan.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a53032bee4cfe0f01916e8149c393adad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53032bee4cfe0f01916e8149c393adad">&#9670;&nbsp;</a></span>ConvertToTimeSpan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> nn::os::ConvertToTimeSpan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1os_1_1_tick.html">Tick</a>&#160;</td>
          <td class="paramname"><em>tick</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the system ticks and returns them as an <code><a class="el" href="classnn_1_1_time_span.html" title="This class represents a length of time.">nn::TimeSpan</a></code> representation of time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tick</td><td>System tick value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Time represented as an <code><a class="el" href="classnn_1_1_time_span.html" title="This class represents a length of time.">nn::TimeSpan</a></code> type.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>None.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>Returns the specified system tick value converted to an <code><a class="el" href="classnn_1_1_time_span.html" title="This class represents a length of time.">nn::TimeSpan</a></code> type.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Converts the system tick value, a system-dependent representation of time, to system time in an <code><a class="el" href="classnn_1_1_time_span.html" title="This class represents a length of time.">nn::TimeSpan</a></code> natural representation of time. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_libcurl_2_basic_2_libcurl_basic_8cpp-example.html#a6">Libcurl/Basic/LibcurlBasic.cpp</a>, <a class="el" href="_libcurl_2_speed_test_2_libcurl_speed_test_8cpp-example.html#a27">Libcurl/SpeedTest/LibcurlSpeedTest.cpp</a>, <a class="el" href="_libcurl_2_ssl_context_import_2_libcurl_ssl_context_import_8cpp-example.html#a6">Libcurl/SslContextImport/LibcurlSslContextImport.cpp</a>, <a class="el" href="_oe_disable_auto_sleep_2_oe_disable_auto_sleep_8cpp-example.html#a20">OeDisableAutoSleep/OeDisableAutoSleep.cpp</a>, <a class="el" href="_os_tick_and_time_span_2_os_tick_and_time_span_8cpp-example.html#a5">OsTickAndTimeSpan/OsTickAndTimeSpan.cpp</a>, and <a class="el" href="_os_timer_event_2_os_timer_event_8cpp-example.html#a4">OsTimerEvent/OsTimerEvent.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a8c9b3542885a746dca530490408f78c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9b3542885a746dca530490408f78c1">&#9670;&nbsp;</a></span>ConvertToTick()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1os_1_1_tick.html">Tick</a> nn::os::ConvertToTick </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeSpan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an <code><a class="el" href="classnn_1_1_time_span.html" title="This class represents a length of time.">nn::TimeSpan</a></code> representation of time and returns it as a system tick. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeSpan</td><td>Time represented as an <code><a class="el" href="classnn_1_1_time_span.html" title="This class represents a length of time.">nn::TimeSpan</a></code> type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the system tick value.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>None.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>Returns the specified <code><a class="el" href="classnn_1_1_time_span.html" title="This class represents a length of time.">nn::TimeSpan</a></code> representation of time as system ticks.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Converts an <code><a class="el" href="classnn_1_1_time_span.html" title="This class represents a length of time.">nn::TimeSpan</a></code> natural representation of time to a system tick value, which is a system-dependent representation of time. </p>

</div>
</div>
<a id="a9fdcd9b26aa9e78c2c17f6b9c02c0314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fdcd9b26aa9e78c2c17f6b9c02c0314">&#9670;&nbsp;</a></span>InitializeTimerEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeTimerEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452">EventClearMode</a>&#160;</td>
          <td class="paramname"><em>clearMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a <code><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="This structure defines a timer event object.">TimerEventType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="This structure defines a timer event object.">TimerEventType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clearMode</td><td>Automatic clear mode of the timer event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>event</em></code> is in an uninitialized state or has not been initialized.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>event</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Initializes a timer event object.</p>
<p>The timer event object comes with a feature you can use to postpone signaling for a specified amount of time, in addition to the normal event features. There is no time-limited standby feature, however.</p>
<p>The initialized timer event object has two states, a signaled state and a non-signaled state. Immediately after initialization, it is in the non-signaled state.</p>
<p>A signaled timer event object can be cleared by specifying one of the following to <code><em>clearMode</em></code>.</p>
<ul>
<li><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a31f6133098296b3ddb7e14da3dc695cc" title="Automatically cleared event.">nn::os::EventClearMode_AutoClear</a></li>
<li><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a8b702480f5120eeeb01e7102227285da" title="Manually cleared event.">nn::os::EventClearMode_ManualClear</a></li>
</ul>
<p>When <code><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a31f6133098296b3ddb7e14da3dc695cc" title="Automatically cleared event.">nn::os::EventClearMode_AutoClear</a></code> is specified, the event mode is cleared automatically. In this case, when <code><a class="el" href="namespacenn_1_1os.html#ad526c59d6481d5fcf0e130d71c7f1252" title="Immediately sets a TimerEventType object to the signaled state.">SignalTimerEvent()</a></code> is called, only one of the threads waiting with the <code><a class="el" href="namespacenn_1_1os.html#a3bdecafeed401cb6b8accdb15178ad66" title="Waits for a TimerEventType object to enter a signaled state.">WaitTimerEvent()</a></code> function stops waiting, and the timer event is cleared to a non-signaled state. If no threads are waiting with the <code><a class="el" href="namespacenn_1_1os.html#a3bdecafeed401cb6b8accdb15178ad66" title="Waits for a TimerEventType object to enter a signaled state.">WaitTimerEvent()</a></code> function when <code><a class="el" href="namespacenn_1_1os.html#ad526c59d6481d5fcf0e130d71c7f1252" title="Immediately sets a TimerEventType object to the signaled state.">SignalTimerEvent()</a></code> is called, the timer event is temporarily reset to a signaled state. Afterward, the first thread from which <code><a class="el" href="namespacenn_1_1os.html#a3bdecafeed401cb6b8accdb15178ad66" title="Waits for a TimerEventType object to enter a signaled state.">WaitTimerEvent()</a></code> is called immediately stops waiting and the timer event is automatically cleared to a non-signaled state.</p>
<p>When <code><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a8b702480f5120eeeb01e7102227285da" title="Manually cleared event.">nn::os::EventClearMode_ManualClear</a></code> is specified, the event mode is cleared manually. In this case, when <code><a class="el" href="namespacenn_1_1os.html#ad526c59d6481d5fcf0e130d71c7f1252" title="Immediately sets a TimerEventType object to the signaled state.">SignalTimerEvent()</a></code> is called, all of the threads waiting with the <code><a class="el" href="namespacenn_1_1os.html#a3bdecafeed401cb6b8accdb15178ad66" title="Waits for a TimerEventType object to enter a signaled state.">WaitTimerEvent()</a></code> function stop waiting, and the timer event maintains its signaled state. Call the <code><a class="el" href="namespacenn_1_1os.html#a2612c1c11f55172e23bf13d0b8a4e5b2" title="Clears a TimerEventType object to the non-signaled state.">ClearTimerEvent()</a></code> function to clear the timer event to a non-signaled state.</p>
<p>This clearing operation is the same with <code><a class="el" href="namespacenn_1_1os.html#a9b3ec8d6c3a7f4410dc6f9c4dec0f88d" title="Starts the TimerEventType object&#39;s one-shot timer.">StartOneShotTimerEvent()</a></code> and <code><a class="el" href="namespacenn_1_1os.html#ac869e53e9d805c3a5781d6493fad6ccd" title="Starts the TimerEventType object&#39;s periodic timer.">StartPeriodicTimerEvent()</a></code> when in a signaled state.</p>
<p>This function is not thread-safe. Do not manipulate the object specified in the target timer event while this function is being called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_timer_event_2_os_timer_event_8cpp-example.html#a12">OsTimerEvent/OsTimerEvent.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1752ba511e60ce027c4af0f6d5e3ebe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1752ba511e60ce027c4af0f6d5e3ebe9">&#9670;&nbsp;</a></span>FinalizeTimerEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FinalizeTimerEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a <code><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="This structure defines a timer event object.">TimerEventType</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Returns a pointer to the <code><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="This structure defines a timer event object.">TimerEventType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>event</em></code> is in an initialized state.</li>
<li>No threads are waiting for <code><em>event</em></code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>event</em></code> is in an uninitialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Frees a timer event object.</p>
<p>This function is not thread-safe. Do not manipulate the object specified in the target timer event while this function is being called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_timer_event_2_os_timer_event_8cpp-example.html#a24">OsTimerEvent/OsTimerEvent.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a9b3ec8d6c3a7f4410dc6f9c4dec0f88d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b3ec8d6c3a7f4410dc6f9c4dec0f88d">&#9670;&nbsp;</a></span>StartOneShotTimerEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::StartOneShotTimerEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td>
          <td class="paramname"><em>first</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the <code><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="This structure defines a timer event object.">TimerEventType</a></code> object's one-shot timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="This structure defines a timer event object.">TimerEventType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Time until the first timer notification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>event</em></code> is in an initialized state.</li>
<li><code><em>first</em></code> &gt;= <code>0</code></li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>event</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Starts the timer event's one-shot timer. Specify the time until the timer event goes into a signaled state in <code><em>first</em></code>.</p>
<p>If the timer operation has already been started, that timer is temporarily stopped and operation starts again as a new one-shot timer. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_timer_event_2_os_timer_event_8cpp-example.html#a21">OsTimerEvent/OsTimerEvent.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac869e53e9d805c3a5781d6493fad6ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac869e53e9d805c3a5781d6493fad6ccd">&#9670;&nbsp;</a></span>StartPeriodicTimerEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::StartPeriodicTimerEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td>
          <td class="paramname"><em>interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the <code><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="This structure defines a timer event object.">TimerEventType</a></code> object's periodic timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Returns a pointer to the <code><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="This structure defines a timer event object.">TimerEventType</a></code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Time until the first timer notification. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interval</td><td>Interval for the second and subsequent timer notifications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>event</em></code> is in an initialized state.</li>
<li><code><em>first</em></code> &gt;= <code>0</code></li>
<li><code><em>interval</em></code> &gt; <code>0</code></li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>event</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Starts the timer event's periodic timer. Specify the time until the timer event goes into a signaled state in <code><em>first</em></code>, and the interval for second and subsequent notifications in <code><em>interval</em></code>.</p>
<p>If the timer operation has already been started, that timer is temporarily stopped and operation starts again as a new periodic timer. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_timer_event_2_os_timer_event_8cpp-example.html#a20">OsTimerEvent/OsTimerEvent.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a6aa23680b72e19fd5cb974ef44325695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa23680b72e19fd5cb974ef44325695">&#9670;&nbsp;</a></span>StopTimerEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::StopTimerEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops the <code><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="This structure defines a timer event object.">TimerEventType</a></code> object's timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="This structure defines a timer event object.">TimerEventType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>event</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>event</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Stops the timer event's timer. This API function does not change the timer event's signaled state. Also, even if there are waiting threads, this API function does not wake them. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_timer_event_2_os_timer_event_8cpp-example.html#a9">OsTimerEvent/OsTimerEvent.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3bdecafeed401cb6b8accdb15178ad66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bdecafeed401cb6b8accdb15178ad66">&#9670;&nbsp;</a></span>WaitTimerEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::WaitTimerEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for a <code><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="This structure defines a timer event object.">TimerEventType</a></code> object to enter a signaled state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Returns a pointer to the <code><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="This structure defines a timer event object.">TimerEventType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>event</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>event</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Waits until a timer event is in a signaled state. If the timer event is already in a signaled state, this function returns immediately. If the timer event is set to <code><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a31f6133098296b3ddb7e14da3dc695cc" title="Automatically cleared event.">nn::os::EventClearMode_AutoClear</a></code>, the timer event is cleared to a non-signaled state as soon as a signaled state is detected. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_timer_event_2_os_timer_event_8cpp-example.html#a7">OsTimerEvent/OsTimerEvent.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aa431fe82cc23064bbad8cacf102756fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa431fe82cc23064bbad8cacf102756fd">&#9670;&nbsp;</a></span>TryWaitTimerEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TryWaitTimerEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Polls whether a <code><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="This structure defines a timer event object.">TimerEventType</a></code> object is in a signaled state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="This structure defines a timer event object.">TimerEventType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether waiting for the timer event was successful.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>event</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>event</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Checks whether a timer event is in a signaled state. If the timer event is already in a signaled state, this function returns <code>true</code> immediately. If the timer event is set to <code><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a31f6133098296b3ddb7e14da3dc695cc" title="Automatically cleared event.">nn::os::EventClearMode_AutoClear</a></code>, the timer event is cleared to a non-signaled state as soon as a signaled state is detected.</p>
<p>If the timer event is in a non-signaled state, the function immediately returns <code>false</code>. </p>

</div>
</div>
<a id="ad526c59d6481d5fcf0e130d71c7f1252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad526c59d6481d5fcf0e130d71c7f1252">&#9670;&nbsp;</a></span>SignalTimerEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SignalTimerEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Immediately sets a <code><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="This structure defines a timer event object.">TimerEventType</a></code> object to the signaled state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Returns a pointer to the <code><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="This structure defines a timer event object.">TimerEventType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>event</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>event</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Immediately sets a timer event to a signaled state. Timer operation is not affected even if this API function sets the timer event's signal state. </p>

</div>
</div>
<a id="a2612c1c11f55172e23bf13d0b8a4e5b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2612c1c11f55172e23bf13d0b8a4e5b2">&#9670;&nbsp;</a></span>ClearTimerEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::ClearTimerEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears a <code><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="This structure defines a timer event object.">TimerEventType</a></code> object to the non-signaled state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to the <code><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="This structure defines a timer event object.">TimerEventType</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>event</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>event</em></code> is in a non-signaled state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Clears the timer event to the non-signaled state. Timer operation is not affected even if this API function clears the timer event to a non-signaled state. </p>

</div>
</div>
<a id="a4083f1b95f58372c092726cfd9800054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4083f1b95f58372c092726cfd9800054">&#9670;&nbsp;</a></span>InitializeMultiWaitHolder() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeMultiWaitHolder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *&#160;</td>
          <td class="paramname"><em>multiWaitHolder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *&#160;</td>
          <td class="paramname"><em>timerEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a <code>multiWaitHolder</code> object and binds it to a timer event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWaitHolder</td><td>Pointer to a multiwait object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timerEvent</td><td>Pointer to a <code><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="This structure defines a timer event object.">TimerEventType</a></code> object being bound</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>multiWaitHolder</em></code> is in an uninitialized state.</li>
<li><code><em>timerEvent</em></code> is in an initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>multiWaitHolder</em></code> is in an initialized state (and bound to <code><em>timerEvent</em></code>).</li>
<li><code><a class="el" href="namespacenn_1_1os.html#a9e8c73312415fc00c72808fcc00fea33">nn::os::GetMultiWaitHolderUserData(multiWaitHolder)</a></code> == <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Initializes a <code><em>multiWaitHolder</em></code> object and binds it to the object specified in <code><em>timerEvent</em></code>.</p>
<p>The bound <code><em>multiWaitHolder</em></code> enters a signaled state when the target timer event is set to a signaled state. Also, if the target timer event is already set, the object enters a signaled state immediately.</p>
<p>Unlike a normal <code><a class="el" href="namespacenn_1_1os.html#a3bdecafeed401cb6b8accdb15178ad66" title="Waits for a TimerEventType object to enter a signaled state.">WaitTimerEvent()</a></code>, using a <code><em>multiWaitHolder</em></code> object initialized using this API and the target timer event signaled to wake the multiwait does not automatically clear the timer event to the non-signaled state. For more information, see <a class="el" href="_page_notification_os_multi_wait.html#PageNotificationOsMultiWait_AboutWakeup">Waking a multiwait PageNotificationOsMultiWait_AboutWakeup</a>.</p>
<p>Do not operate on <code><em>multiWaitHolder</em></code> while this function is being called. </p>

</div>
</div>
<a id="a80a1e659aaba155ff9552f48604aec54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a1e659aaba155ff9552f48604aec54">&#9670;&nbsp;</a></span>SetUserExceptionHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SetUserExceptionHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1os.html#aff433bbe881d0fcb8fbb47fe3e299173">UserExceptionHandler</a>&#160;</td>
          <td class="paramname"><em>pHandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_user_exception_info.html">UserExceptionInfo</a> *&#160;</td>
          <td class="paramname"><em>pExceptionInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the user exception handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandler</td><td>The exception handler function to call when an exception is thrown. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stack</td><td>The starting address of the stack region used by the exception handler. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stackSize</td><td>The size of the stack region used by the exception handler. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pExceptionInfo</td><td>The pointer to the buffer region for storing the exception information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>stack</em></code> % <code><a class="el" href="namespacenn_1_1os.html#ae88f7888a125e3cf4d07f28cf9acb95a" title="Constant representing a stack alignment restriction for a user exception handler.">nn::os::HandlerStackAlignment</a></code> == <code>0</code>.</li>
<li><code><em>stackSize</em></code> % <code><a class="el" href="namespacenn_1_1os.html#ae88f7888a125e3cf4d07f28cf9acb95a" title="Constant representing a stack alignment restriction for a user exception handler.">nn::os::HandlerStackAlignment</a></code> == <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sets the user exception handler.</p>
<p><code><em>pHandler</em></code> specifies the function to call when an exception is thrown. This function is an <code><a class="el" href="namespacenn_1_1os.html#aff433bbe881d0fcb8fbb47fe3e299173" title="Type representing a user exception handler function.">nn::os::UserExceptionHandler</a></code> type, and passes a pointer to an exception data buffer <code><a class="el" href="structnn_1_1os_1_1_user_exception_info.html" title="The structure that stores the exception information.">nn::os::UserExceptionInfo</a>*</code> as an argument. If you specify <code>NULL</code> for <code><em>pHandler</em></code>, the user exception handler settings are cleared.</p>
<p>Specify a stack space used by the exception handler in <code><em>stack</em></code> and <code><em>stackSize</em></code>. Use the stack of the thread that threw the exception as the exception handler stack by setting <code><em>stack</em></code> to <code><a class="el" href="namespacenn_1_1os.html#ac0ca06939bae41f0ab89eda5be97d4fa" title="Constant that specifies a thread stack as a user exception handler stack.">nn::os::HandlerStackUsesThreadStack</a></code>. When you specify that setting, the <code><em>stackSize</em></code> specification will be ignored.</p>
<p><code><em>pExceptionInfo</em></code> specifies the buffer for storing the exception information when an exception is thrown. Allocate a buffer space in the exception handler stack by setting <code><em>pExceptionInfo</em></code> to <code><a class="el" href="namespacenn_1_1os.html#a74b6dc109705a61e232eb0087fbb8720" title="Constant that specifies an exception handler stack as a region storing exception information.">nn::os::UserExceptionInfoUsesHandlerStack</a></code>. Dynamically allocate a buffer space in the stack of the thread that threw the exception by setting <code><em>pExceptionInfo</em></code> to <code><a class="el" href="namespacenn_1_1os.html#ae95b1a34cff3839ca8d8af43ff4512cd" title="Constant that specifies a thread stack as a region storing exception information.">nn::os::UserExceptionInfoUsesThreadStack</a></code>.</p>
<p>Only one exception handler can be set for each process. When this API is called multiple times, the handler is overwritten each time. The value that is set last is the only valid value. This function is not thread-safe, and operation results are undefined when this function is called from a different thread when this thread is mid-operation.</p>
<p><code><em>pHandler</em></code> is called when an exception is thrown when an exception handler is set, in the context of the thread where the exception was thrown. However, the stack is replaced with the stack specified by <code><em>stack</em></code> and <code><em>stackSize</em></code>.</p>
<p>No special processes such as prohibiting interrupt or halting other threads are executed when the exception handler is called. Other threads continue working while an exception handler is running in any thread. Because an exception handler does not stop other threads, make sure that the exception handler stack or the exception information buffer is not used concurrently with other threads, when multiple threads point to the same shared memory space. For example, when exception handlers are started nearly simultaneously in multiple threads, the space used by the exception handlers must not be used simultaneously.</p>
<p>The exception handler is provided as a way to output debugging information. If control returns from the exception handler, processing continues just like it would if a user exception handler was not set in the first place.</p>
<p>If the debugger is in the <code>Attach</code> state, the user exception handler is not called even if one has been registered. However, if <code>true</code> is specified for <code><a class="el" href="namespacenn_1_1os.html#a52dba2921df0ef2adf203a4b9829a6d6" title="Sets whether to enable the user exception handler even when connected to the debugger.">nn::os::EnableUserExceptionHandlerOnDebugging()</a></code>, the user exception handler is called and then the debugger stops.</p>
<div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
 User exception handlers are not supported in the Windows environment. Even if this function is called, exceptions will not be picked up and the setting will be ignored.</div><div class="platform_section" data-platform="Windows"></div> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_user_exception_handler_sample_8cpp-example.html#a36">OsUserExceptionHandlerSample.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a52dba2921df0ef2adf203a4b9829a6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52dba2921df0ef2adf203a4b9829a6d6">&#9670;&nbsp;</a></span>EnableUserExceptionHandlerOnDebugging()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::EnableUserExceptionHandlerOnDebugging </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isEnabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether to enable the user exception handler even when connected to the debugger. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">isEnabled</td><td>Whether to enable the user exception handler even when connected to the debugger.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
 The user exception handler normally is not enabled when connected to the debugger, but this function enables the user exception handler even in this state.</p>
<p>If <code>true</code> is specified for <code>isEnabled</code> and then a user exception is thrown while the debugger is connected, the debugger stops the program after the user exception handler has started.</p>
<p>Note that the position, registers, and other context shown in the debugger when the program stops are not for use when the exception was actually thrown, but for use after the user exception handler process, so the memory rewritten by the user exception handler is for use after the change.</p>
<p>This function is designed for debugging the user exception handler.</p>
<p>The default is <code><em>isEnabled</em></code> == <code>false</code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_user_exception_handler_2_os_user_exception_handler_8cpp-example.html#a1">OsUserExceptionHandler/OsUserExceptionHandler.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a11dca1988a4d23dc773f216847a56ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11dca1988a4d23dc773f216847a56ecd">&#9670;&nbsp;</a></span>AllocateAddressRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::os::AllocateAddressRegion </td>
          <td>(</td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>pOutAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates an address area from the virtual address space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutAddress</td><td>Pointer to the starting address of the memory area allocated for storing the address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the address area to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1os_1_1_result_out_of_virtual_address_space.html">nn::os::ResultOutOfVirtualAddressSpace</a> Failed to allocate an address area because there was not enough virtual address space.</li>
<li><a class="el" href="classnn_1_1os_1_1_result_out_of_memory.html">nn::os::ResultOutOfMemory</a> Failed to allocate the required physical memory for virtual address space management.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="Determines whether virtual address memory management is available.">nn::os::IsVirtualAddressMemoryEnabled()</a></code> == <code>true</code></li>
<li>The region indicated by <code><em>pOutAddress</em></code> is writable.</li>
<li><code><em>size</em></code> &gt; <code>0</code>.</li>
<li><code><em>size</em></code> is an integer multiple of <code><a class="el" href="namespacenn_1_1os.html#ac880b46610757e748d5bd79211af4236" title="This constant stores the minimum unit for memory operations.">nn::os::MemoryPageSize</a></code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>An address area with a size of <code><em>size</em></code> bytes was allocated and its starting address is stored in <code>*<em>pOutAddress</em></code>.</li>
<li>The address stored in <code>*<em>pOutAddress</em></code> is aligned using <code><a class="el" href="namespacenn_1_1os.html#a82acf7f7f39eb127ebffdef2c748c5e6" title="Constants that indicate the alignment restrictions for the starting address of the address area.">nn::os::AddressRegionAlignment</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Allocates a new address area, with a size of <code><em>size</em></code> bytes, in the virtual address space and returns the starting address for it. The starting address for the allocated address area will be aligned using the value indicated by the <code><a class="el" href="namespacenn_1_1os.html#a82acf7f7f39eb127ebffdef2c748c5e6" title="Constants that indicate the alignment restrictions for the starting address of the address area.">nn::os::AddressRegionAlignment</a></code> constant.</p>
<p>No physical memory has yet to be assigned to the allocated address area. An access exception will result if you access memory in an address region while no physical memory has been assigned for it. You can assign physical memory to the allocated address area using <code><a class="el" href="namespacenn_1_1os.html#afc2aecae3365f9881e63f3c9a77be239" title="Physical memory is assigned to the specified area.">nn::os::AllocateMemoryPages</a></code>.</p>
<p>You can free the allocated address area using <code><a class="el" href="namespacenn_1_1os.html#a822e071b5061ef30ce2202d67fad8dd0" title="Frees the address area.">nn::os::FreeAddressRegion</a></code>.</p>
<p>For the virtual address memory management feature, memory is allocated dynamically in the <code>os</code> library for the management of address regions. As a result, dynamic memory allocation will in some cases take place internally when the <code><a class="el" href="namespacenn_1_1os.html#a11dca1988a4d23dc773f216847a56ecd" title="Allocates an address area from the virtual address space.">nn::os::AllocateAddressRegion()</a></code> function is called. If dynamic memory allocation inside the <code>os</code> library fails, the function will return <code><a class="el" href="classnn_1_1os_1_1_result_out_of_memory.html" title="A class that represents error Result values (os: Insufficient free memory.).">nn::os::ResultOutOfMemory</a></code>.</p>
<p>The memory that has been allocated dynamically in the <code>os</code> library is included in the <code><em>totalUsedMemorySize</em></code> value that can be obtained using the <code><a class="el" href="namespacenn_1_1os.html#a79f2a489da0a124ebdc8130595c70b94" title="Gets information including the amount of memory currently being used by this program.">nn::os::QueryMemoryInfo()</a></code> function.</p>
<p>63 GiB is available as virtual address space. Because of the management overhead, the total address region actually available is less than this amount.</p>
<p>This function is thread-safe.</p>
<p>This function can only be used when <code><a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="Determines whether virtual address memory management is available.">nn::os::IsVirtualAddressMemoryEnabled()</a></code> returns <code>true</code>. For more information, see the <code><a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="Determines whether virtual address memory management is available.">nn::os::IsVirtualAddressMemoryEnabled()</a></code> function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_virtual_address_memory_2_os_virtual_address_memory_8cpp-example.html#a0">OsVirtualAddressMemory/OsVirtualAddressMemory.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a822e071b5061ef30ce2202d67fad8dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822e071b5061ef30ce2202d67fad8dd0">&#9670;&nbsp;</a></span>FreeAddressRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::os::FreeAddressRegion </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the address area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Starting address for the address area to free.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1os_1_1_result_invalid_parameter.html">nn::os::ResultInvalidParameter</a> <code><em>address</em></code> is not a starting address for a valid address area.</li>
<li><a class="el" href="classnn_1_1os_1_1_result_busy.html">nn::os::ResultBusy</a> The address area includes memory in use.</li>
<li><a class="el" href="classnn_1_1os_1_1_result_out_of_resource.html">nn::os::ResultOutOfResource</a> Not enough resources are available for physical memory operations.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="Determines whether virtual address memory management is available.">nn::os::IsVirtualAddressMemoryEnabled()</a></code> == <code>true</code></li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>No physical memory has yet to be assigned to the entire address area for which <code><em>address</em></code> is the starting address.</li>
<li>The address area for which <code><em>address</em></code> is the starting address has been freed.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Frees the address area for which <code><em>address</em></code> is the starting address. You must release any assigned physical memory for an address area when there is an area with assigned physical memory within the address area.</p>
<p><code><em>address</em></code> must be a starting address for the address area allocated using <code><a class="el" href="namespacenn_1_1os.html#a11dca1988a4d23dc773f216847a56ecd" title="Allocates an address area from the virtual address space.">nn::os::AllocateAddressRegion</a></code> and still not freed. The target address area must also not include any memory in use by any of the SDK's APIs.</p>
<p>This function is thread-safe.</p>
<p>This function can only be used when <code><a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="Determines whether virtual address memory management is available.">nn::os::IsVirtualAddressMemoryEnabled()</a></code> returns <code>true</code>. For more information, see the <code><a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="Determines whether virtual address memory management is available.">nn::os::IsVirtualAddressMemoryEnabled()</a></code> function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_virtual_address_memory_2_os_virtual_address_memory_8cpp-example.html#a6">OsVirtualAddressMemory/OsVirtualAddressMemory.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="afc2aecae3365f9881e63f3c9a77be239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc2aecae3365f9881e63f3c9a77be239">&#9670;&nbsp;</a></span>AllocateMemoryPages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::os::AllocateMemoryPages </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Physical memory is assigned to the specified area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Starting address for the area to assign physical memory to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the area to assign physical memory to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1os_1_1_result_invalid_parameter.html">nn::os::ResultInvalidParameter</a> An area of <code><em>size</em></code> bytes, starting from <code><em>address</em></code>, does not include a valid address area.</li>
<li><a class="el" href="classnn_1_1os_1_1_result_out_of_memory.html">nn::os::ResultOutOfMemory</a> Failed to allocate the physical memory to assign.</li>
<li><a class="el" href="classnn_1_1os_1_1_result_out_of_resource.html">nn::os::ResultOutOfResource</a> Not enough resources are available for physical memory operations.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="Determines whether virtual address memory management is available.">nn::os::IsVirtualAddressMemoryEnabled()</a></code> == <code>true</code></li>
<li><code><em>address</em></code> is an integer multiple of <code><a class="el" href="namespacenn_1_1os.html#ac880b46610757e748d5bd79211af4236" title="This constant stores the minimum unit for memory operations.">nn::os::MemoryPageSize</a></code>.</li>
<li><code><em>size</em></code> is an integer multiple of <code><a class="el" href="namespacenn_1_1os.html#ac880b46610757e748d5bd79211af4236" title="This constant stores the minimum unit for memory operations.">nn::os::MemoryPageSize</a></code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>Physical memory is assigned to an area starting from <code><em>address</em></code> with a size of <code><em>size</em></code> bytes.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Allocates and assigns physical memory for an area starting from <code><em>address</em></code> with a size of <code><em>size</em></code> bytes.</p>
<p>The area of <code><em>size</em></code> bytes starting from <code><em>address</em></code> must be included in an address region that has been allocated with <code><a class="el" href="namespacenn_1_1os.html#a11dca1988a4d23dc773f216847a56ecd" title="Allocates an address area from the virtual address space.">nn::os::AllocateAddressRegion</a></code> and that is not yet freed.</p>
<p>Any area that has already been assigned physical memory for an area starting from <code><em>address</em></code> with a size of <code><em>size</em></code> bytes will maintain its condition from before the function call.</p>
<p>Use <code><a class="el" href="namespacenn_1_1os.html#aadde176efe5d5ec8352539a4c41cc468" title="Releases memory assigned to the specified area.">nn::os::FreeMemoryPages</a></code> to release the assignment of physical memory that was assigned using this function.</p>
<p>This function is thread-safe.</p>
<p>This function can only be used when <code><a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="Determines whether virtual address memory management is available.">nn::os::IsVirtualAddressMemoryEnabled()</a></code> returns <code>true</code>. For more information, see the <code><a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="Determines whether virtual address memory management is available.">nn::os::IsVirtualAddressMemoryEnabled()</a></code> function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_virtual_address_memory_2_os_virtual_address_memory_8cpp-example.html#a2">OsVirtualAddressMemory/OsVirtualAddressMemory.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aadde176efe5d5ec8352539a4c41cc468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadde176efe5d5ec8352539a4c41cc468">&#9670;&nbsp;</a></span>FreeMemoryPages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::os::FreeMemoryPages </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases memory assigned to the specified area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Starting address for the area to release assigned memory from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the area to release assigned memory from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1os_1_1_result_invalid_parameter.html">nn::os::ResultInvalidParameter</a> An area of <code><em>size</em></code> bytes, starting from <code><em>address</em></code>, does not include a valid address area.</li>
<li><a class="el" href="classnn_1_1os_1_1_result_busy.html">nn::os::ResultBusy</a> The address area includes memory in use.</li>
<li><a class="el" href="classnn_1_1os_1_1_result_out_of_resource.html">nn::os::ResultOutOfResource</a> Not enough resources are available for physical memory operations.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="Determines whether virtual address memory management is available.">nn::os::IsVirtualAddressMemoryEnabled()</a></code> == <code>true</code></li>
<li><code><em>address</em></code> is an integer multiple of <code><a class="el" href="namespacenn_1_1os.html#ac880b46610757e748d5bd79211af4236" title="This constant stores the minimum unit for memory operations.">nn::os::MemoryPageSize</a></code>.</li>
<li><code><em>size</em></code> is an integer multiple of <code><a class="el" href="namespacenn_1_1os.html#ac880b46610757e748d5bd79211af4236" title="This constant stores the minimum unit for memory operations.">nn::os::MemoryPageSize</a></code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>Physical memory has not been assigned to an area starting from <code><em>address</em></code> with a size of <code><em>size</em></code> bytes.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Releases physical memory assigned to the area starting from <code><em>address</em></code> with a size of <code><em>size</em></code> bytes.</p>
<p><code><em>address</em></code> and <code><em>size</em></code> do not need to be same as they were when <code>AllocateMemoryPages</code> was called, which means that the allocated physical memory can be partially freed.</p>
<p>The area of <code><em>size</em></code> bytes starting from <code><em>address</em></code> must be included in an address region that has been allocated with <code><a class="el" href="namespacenn_1_1os.html#a11dca1988a4d23dc773f216847a56ecd" title="Allocates an address area from the virtual address space.">nn::os::AllocateAddressRegion</a></code> and that is not yet freed. This area must also not include any memory in use by any of the SDK's APIs.</p>
<p>Any area for which no physical memory has been assigned, within the area starting from <code><em>address</em></code> with a size of <code><em>size</em></code> bytes, is ignored.</p>
<p>An access exception will result if you access memory for an address where no physical memory has been assigned.</p>
<p>This function is thread-safe.</p>
<p>This function can only be used when <code><a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="Determines whether virtual address memory management is available.">nn::os::IsVirtualAddressMemoryEnabled()</a></code> returns <code>true</code>. For more information, see the <code><a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="Determines whether virtual address memory management is available.">nn::os::IsVirtualAddressMemoryEnabled()</a></code> function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_virtual_address_memory_2_os_virtual_address_memory_8cpp-example.html#a3">OsVirtualAddressMemory/OsVirtualAddressMemory.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a49b13b1f8e6e4fa352192eb9d121ff49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b13b1f8e6e4fa352192eb9d121ff49">&#9670;&nbsp;</a></span>GetVirtualAddressMemoryResourceUsage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1os_1_1_virtual_address_memory_resource_usage.html">VirtualAddressMemoryResourceUsage</a> nn::os::GetVirtualAddressMemoryResourceUsage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the amount of resources consumed for virtual address memory management. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the acquired amount of consumed resources.</dd></dl>
<p> <b>Details</b> <br  />
 This function is thread-safe.</p>
<div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
 The available value for both <code><em>assignedSize</em></code> and <code><em>usedSize</em></code> is always <code>0</code>.</div><div class="platform_section" data-platform="Windows"></div><div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
 The available <code><em>assignedSize</em></code> value will be the value configured for <code>SystemResourceSize</code> by using the NMETA file. This value does not change during the course of program execution.</div><div class="platform_section" data-platform="NX"> The amount of resources consumed until now is stored in the available <code><em>usedSize</em></code> value. This value increases monotonically as the program runs because resources are never released after being consumed. The virtual address memory management API resources could fail with <code><a class="el" href="classnn_1_1os_1_1_result_out_of_resource.html" title="A class that represents error Result values (os: Insufficient free resources.).">nn::os::ResultOutOfResource</a></code> if this value is the same as the value of <code><em>assignedSize</em></code>.</div><div class="platform_section" data-platform="NX"></div> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_virtual_address_memory_2_os_virtual_address_memory_8cpp-example.html#a5">OsVirtualAddressMemory/OsVirtualAddressMemory.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab9e6556970df605db16e5548b9fd188c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9e6556970df605db16e5548b9fd188c">&#9670;&nbsp;</a></span>IsVirtualAddressMemoryEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::IsVirtualAddressMemoryEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether virtual address memory management is available. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> when virtual address memory management is available; otherwise returns <code>false</code>.</dd></dl>
<p> <b>Details</b> <br  />
 You cannot use virtual address memory management with 32-bit programs. <code>false</code> will always be returned as a result.</p>
<p>This function is thread-safe.</p>
<div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
 Virtual address memory management is always available for 64-bit programs.</div><div class="platform_section" data-platform="Windows"></div><div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
 To make virtual address memory management available in 64-bit programs, you must set a value larger than zero for <code>SystemResourceSize</code> in the NMETA file. For more information, see the Determining the Value for <code>SystemResourceSize</code> section in the <a href="../../Package/contents/Pages/Page_83956147.html">Memory Management</a> documentation.</div><div class="platform_section" data-platform="NX"></div><p> <b>Details</b> <br  />
</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a5c212d3f3bc25e8ce9502a178b3e02e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c212d3f3bc25e8ce9502a178b3e02e3">&#9670;&nbsp;</a></span>CacheLineSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t nn::os::CacheLineSize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The constant representing the cache line size, in bytes. </p>
<p>Only defined in the development hardware environment.</p>
<p> <b>Details</b> <br  />
</p><div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
 The value is <code>64</code>.</div><div class="platform_section" data-platform="NX"></div> 
</div>
</div>
<a id="ab8818e7de49601e4f83bd6d3ee822449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8818e7de49601e4f83bd6d3ee822449">&#9670;&nbsp;</a></span>FiberStackAlignment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t nn::os::FiberStackAlignment = 16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant indicating the alignment rules for the fiber stack space. </p>
<p> <b>Details</b> <br  />
 This constant represents the alignment for the stack space of a fiber without stack guards. Use <code><a class="el" href="namespacenn_1_1os.html#a09b2d95cc4315e16021578c2ba43208d" title="Constant indicating the alignment rules for a guarded stack space.">nn::os::GuardedStackAlignment</a></code> for a fiber stack space that will include stack guards. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_os_fiber_2_os_fiber_8cpp-example.html#a1">OsFiber/OsFiber.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a793a3781900c43f3d8afda6e02ec1b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a793a3781900c43f3d8afda6e02ec1b58">&#9670;&nbsp;</a></span>ThreadNameLengthMax</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int nn::os::ThreadNameLengthMax = 32</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant indicating the maximum length of a thread name. </p>
<p>This number includes the terminating character <code>\0</code>. </p>

</div>
</div>
<a id="a44ed3b4dddf9ebfb69bc33167369b816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ed3b4dddf9ebfb69bc33167369b816">&#9670;&nbsp;</a></span>HighestThreadPriority</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int nn::os::HighestThreadPriority = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant indicating the highest thread priority. </p>
<p>It has a value of <code>0</code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a91">AudioEchoback/AudioEchoback.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a5985811d04e64c0823ed758fd420591d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5985811d04e64c0823ed758fd420591d">&#9670;&nbsp;</a></span>DefaultThreadPriority</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int nn::os::DefaultThreadPriority = (ThreadPriorityRangeSize / 2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant indicating the default value of thread priority. </p>
<p>It has a value of <code>16</code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a67">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_bcat_practical_2_bcat_practical_8cpp-example.html#a6">BcatPractical/BcatPractical.cpp</a>, <a class="el" href="_g3d_demo_2_parallel_8cpp-example.html#a130">G3dDemo/Parallel.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a63">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_nifm_network_connection_simple_2_nifm_network_connection_simple__main_8cpp-example.html#a5">NifmNetworkConnectionSimple/NifmNetworkConnectionSimple_Main.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_simple_framework_8cpp-example.html#a28">NvnSimple/NvnSimpleSharedLib/SimpleFramework.cpp</a>, <a class="el" href="_nvn_tutorial_2_render_thread_pool_8cpp-example.html#a10">NvnTutorial/RenderThreadPool.cpp</a>, <a class="el" href="_nvn_tutorial04_multi_threaded_asset_file_loading_2_nvn_tutorial04_8cpp-example.html#a36">NvnTutorial04MultiThreadedAssetFileLoading/NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial06_frame_buffering_2_nvn_tutorial06_8cpp-example.html#a40">NvnTutorial06FrameBuffering/NvnTutorial06.cpp</a>, <a class="el" href="_oe_disable_auto_sleep_2_oe_disable_auto_sleep_8cpp-example.html#a10">OeDisableAutoSleep/OeDisableAutoSleep.cpp</a>, <a class="el" href="_oe_idle_policy_2_oe_idle_policy_8cpp-example.html#a14">OeIdlePolicy/OeIdlePolicy.cpp</a>, <a class="el" href="_os_barrier_2_os_barrier_8cpp-example.html#a13">OsBarrier/OsBarrier.cpp</a>, <a class="el" href="_os_condition_variable_2_os_condition_variable_8cpp-example.html#a15">OsConditionVariable/OsConditionVariable.cpp</a>, <a class="el" href="_os_event_2_os_event_8cpp-example.html#a14">OsEvent/OsEvent.cpp</a>, <a class="el" href="_os_message_queue_2_os_message_queue_8cpp-example.html#a11">OsMessageQueue/OsMessageQueue.cpp</a>, <a class="el" href="_os_multi_wait_2_os_multi_wait_8cpp-example.html#a34">OsMultiWait/OsMultiWait.cpp</a>, <a class="el" href="_os_multi_wait_utility_2_os_multi_wait_utility_8cpp-example.html#a24">OsMultiWaitUtility/OsMultiWaitUtility.cpp</a>, <a class="el" href="_os_mutex_2_os_mutex_8cpp-example.html#a10">OsMutex/OsMutex.cpp</a>, <a class="el" href="_os_reader_writer_lock_2_os_reader_writer_lock_8cpp-example.html#a13">OsReaderWriterLock/OsReaderWriterLock.cpp</a>, <a class="el" href="_os_semaphore_2_os_semaphore_8cpp-example.html#a11">OsSemaphore/OsSemaphore.cpp</a>, <a class="el" href="_os_thread_2_os_thread_8cpp-example.html#a13">OsThread/OsThread.cpp</a>, <a class="el" href="_os_thread_local_storage_2_os_thread_local_storage_8cpp-example.html#a10">OsThreadLocalStorage/OsThreadLocalStorage.cpp</a>, <a class="el" href="_os_timer_event_2_os_timer_event_8cpp-example.html#a16">OsTimerEvent/OsTimerEvent.cpp</a>, <a class="el" href="_perf_simple_2_perf_simple_8cpp-example.html#a57">PerfSimple/PerfSimple.cpp</a>, <a class="el" href="_profiler_thread_state_2_profiler_thread_state_8cpp-example.html#a11">ProfilerThreadState/ProfilerThreadState.cpp</a>, <a class="el" href="_socket_event_fd_2_socket_event_fd_8cpp-example.html#a33">SocketEventFd/SocketEventFd.cpp</a>, <a class="el" href="_socket_statistics_overlay_2_socket_statistics_overlay_8cpp-example.html#a66">SocketStatisticsOverlay/SocketStatisticsOverlay.cpp</a>, <a class="el" href="_vi_timestamp_2_vi_timestamp_8cpp-example.html#a29">ViTimestamp/ViTimestamp.cpp</a>, and <a class="el" href="_web_socket_chat_2_web_socket_chat_8cpp-example.html#a24">WebSocketChat/WebSocketChat.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a88510f5f630a16612aa8d479c10b56de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88510f5f630a16612aa8d479c10b56de">&#9670;&nbsp;</a></span>LowestThreadPriority</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int nn::os::LowestThreadPriority = (ThreadPriorityRangeSize - 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant indicating the lowest thread priority. </p>
<p>It has a value of <code>31</code>. </p>

</div>
</div>
<a id="a895eb281cfb4500d6ac462cec6631613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a895eb281cfb4500d6ac462cec6631613">&#9670;&nbsp;</a></span>StackRegionAlignment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t nn::os::StackRegionAlignment = <a class="el" href="namespacenn_1_1os.html#a8b116319f3d483f3805c193661f22150">ThreadStackAlignment</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant indicating the alignment rules for the stack space. </p>
<p>This function is deprecated. Please check the details for usage conditions and substitute functions. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000010">Deprecated:</a></b></dt><dd></dd></dl>
<p> <b>Details</b> <br  />
 This constant has been deprecated and is scheduled for removal. Instead, use <code><a class="el" href="namespacenn_1_1os.html#a8b116319f3d483f3805c193661f22150" title="Constant indicating the alignment rules for a thread stack space.">nn::os::ThreadStackAlignment</a></code>. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
