<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nn::hid Namespace Reference | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenn.html">nn</a></li><li class="navelem"><a class="el" href="namespacenn_1_1hid.html">hid</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">nn::hid Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace for human interface devices.  
<a href="namespacenn_1_1hid.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_analog_stick_state.html">AnalogStickState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing the input state of the control sticks.  <a href="structnn_1_1hid_1_1_analog_stick_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_controller_firmware_update_arg.html">ControllerFirmwareUpdateArg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The startup parameters for calling the controller firmware update UI.  <a href="structnn_1_1hid_1_1_controller_firmware_update_arg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_controller_support_arg.html">ControllerSupportArg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The startup parameters for calling the controller support UI.  <a href="structnn_1_1hid_1_1_controller_support_arg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_controller_support_result_info.html">ControllerSupportResultInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure for storing the result of calling the controller support UI.  <a href="structnn_1_1hid_1_1_controller_support_result_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_debug_pad_attribute.html">DebugPadAttribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute definitions for the DebugPad input state.  <a href="structnn_1_1hid_1_1_debug_pad_attribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_debug_pad_button.html">DebugPadButton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The DebugPad digital button definition.  <a href="structnn_1_1hid_1_1_debug_pad_button.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_debug_pad_state.html">DebugPadState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing the DebugPad input state.  <a href="structnn_1_1hid_1_1_debug_pad_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_digitizer_attribute.html">DigitizerAttribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute definitions for the digitizer input state.  <a href="structnn_1_1hid_1_1_digitizer_attribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_digitizer_button.html">DigitizerButton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Digitizer button definitions.  <a href="structnn_1_1hid_1_1_digitizer_button.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_digitizer_state.html">DigitizerState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure representing the digitizer input state.  <a href="structnn_1_1hid_1_1_digitizer_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_gesture_attribute.html">GestureAttribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gesture attribute definitions.  <a href="structnn_1_1hid_1_1_gesture_attribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_gesture_point.html">GesturePoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure that indicates the points comprising the gesture.  <a href="structnn_1_1hid_1_1_gesture_point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_gesture_state.html">GestureState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that represents the state of the gesture.  <a href="structnn_1_1hid_1_1_gesture_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_keyboard_attribute.html">KeyboardAttribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute definitions for the keyboard input state.  <a href="structnn_1_1hid_1_1_keyboard_attribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_keyboard_key.html">KeyboardKey</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definitions of the keyboard keys.  <a href="structnn_1_1hid_1_1_keyboard_key.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_keyboard_lock_key_event.html">KeyboardLockKeyEvent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for a keyboard's lock key events.  <a href="structnn_1_1hid_1_1_keyboard_lock_key_event.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_keyboard_modifier.html">KeyboardModifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definitions of keyboard modifier information.  <a href="structnn_1_1hid_1_1_keyboard_modifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_keyboard_state.html">KeyboardState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing the keyboard input state.  <a href="structnn_1_1hid_1_1_keyboard_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_mouse_attribute.html">MouseAttribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for mouse input state attributes.  <a href="structnn_1_1hid_1_1_mouse_attribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_mouse_button.html">MouseButton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for mouse buttons.  <a href="structnn_1_1hid_1_1_mouse_button.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_mouse_state.html">MouseState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing <code>Mouse</code> input states.  <a href="structnn_1_1hid_1_1_mouse_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_npad_attribute.html">NpadAttribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Npad state attributes.  <a href="structnn_1_1hid_1_1_npad_attribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_npad_button.html">NpadButton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Npad digital button definitions.  <a href="structnn_1_1hid_1_1_npad_button.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_npad_controller_color.html">NpadControllerColor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing color data for the controller assigned to Npad.  <a href="structnn_1_1hid_1_1_npad_controller_color.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_npad_full_key_state.html">NpadFullKeyState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure representing the input states for the <code>NpadStyleFullKey</code> play style modeled on holding an Npad Switch Pro Controller.  <a href="structnn_1_1hid_1_1_npad_full_key_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_npad_handheld_state.html">NpadHandheldState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure representing the input states for the <code>NpadStyleHandheld</code> play style modeled on holding an Npad handheld controller.  <a href="structnn_1_1hid_1_1_npad_handheld_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_npad_id.html">NpadId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an Npad ID for identifying an Npad.  <a href="structnn_1_1hid_1_1_npad_id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_npad_joy_attribute.html">NpadJoyAttribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute values representing Npad states unique to the Joy-Con.  <a href="structnn_1_1hid_1_1_npad_joy_attribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_npad_joy_button.html">NpadJoyButton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions of Npad digital buttons unique to the Joy-Con.  <a href="structnn_1_1hid_1_1_npad_joy_button.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_npad_joy_dual_state.html">NpadJoyDualState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure representing the input states for the <code>NpadStyleJoyDual</code> play style modeled on holding two Npad Joy-Con controllers.  <a href="structnn_1_1hid_1_1_npad_joy_dual_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_npad_joy_left_state.html">NpadJoyLeftState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure representing the input states for the <code>NpadStyleJoyLeft</code> play style modeled on holding the Npad Joy-Con (L) controller.  <a href="structnn_1_1hid_1_1_npad_joy_left_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_npad_joy_right_state.html">NpadJoyRightState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure representing the input states for the <code>NpadStyleJoyRight</code> play style modeled on holding an Npad Joy-Con (R) controller.  <a href="structnn_1_1hid_1_1_npad_joy_right_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1hid_1_1_result_controller_firmware_update_error.html">ResultControllerFirmwareUpdateError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>hid</code>: Firmware update error.).  <a href="classnn_1_1hid_1_1_result_controller_firmware_update_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1hid_1_1_result_controller_firmware_update_failed.html">ResultControllerFirmwareUpdateFailed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>hid</code>: Firmware update failed.).  <a href="classnn_1_1hid_1_1_result_controller_firmware_update_failed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1hid_1_1_result_controller_support_canceled.html">ResultControllerSupportCanceled</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>hid</code>: Controller support has been canceled.).  <a href="classnn_1_1hid_1_1_result_controller_support_canceled.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1hid_1_1_result_controller_support_error.html">ResultControllerSupportError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>hid</code>: Error related to ControllerSupport.).  <a href="classnn_1_1hid_1_1_result_controller_support_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1hid_1_1_result_controller_support_not_supported_npad_style.html">ResultControllerSupportNotSupportedNpadStyle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>hid</code>: The specified style of operation is not supported by the controller.).  <a href="classnn_1_1hid_1_1_result_controller_support_not_supported_npad_style.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1hid_1_1_result_npad_color_not_available.html">ResultNpadColorNotAvailable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>hid</code>: Could not get Npad color data.).  <a href="classnn_1_1hid_1_1_result_npad_color_not_available.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1hid_1_1_result_npad_controller_not_connected.html">ResultNpadControllerNotConnected</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>hid</code>: No controller is connected for the Npad.).  <a href="classnn_1_1hid_1_1_result_npad_controller_not_connected.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1hid_1_1_result_npad_dual_connected.html">ResultNpadDualConnected</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>hid</code>: Merging is not possible because a specified Npad is connected to a Joy-Con pair.).  <a href="classnn_1_1hid_1_1_result_npad_dual_connected.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1hid_1_1_result_npad_error.html">ResultNpadError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>hid</code>: Npad error.).  <a href="classnn_1_1hid_1_1_result_npad_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1hid_1_1_result_npad_same_joy_type_connected.html">ResultNpadSameJoyTypeConnected</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>hid</code>: Merging is not possible because the two specified Npads are connected to the same kind of single Joy-Con.).  <a href="classnn_1_1hid_1_1_result_npad_same_joy_type_connected.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1hid_1_1_result_vibration_file_invalid.html">ResultVibrationFileInvalid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>hid</code>: Invalid vibration file.).  <a href="classnn_1_1hid_1_1_result_vibration_file_invalid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_attribute.html">SixAxisSensorAttribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for <code>SixAxisSensor</code> input state attributes.  <a href="structnn_1_1hid_1_1_six_axis_sensor_attribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_handle.html">SixAxisSensorHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing the handle for the six-axis sensor.  <a href="structnn_1_1hid_1_1_six_axis_sensor_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_state.html">SixAxisSensorState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing the state obtained from the six-axis sensor.  <a href="structnn_1_1hid_1_1_six_axis_sensor_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_touch_attribute.html">TouchAttribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Touch attribute definitions.  <a href="structnn_1_1hid_1_1_touch_attribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_touch_screen_state.html">TouchScreenState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing the input state of the touch screen.  <a href="structnn_1_1hid_1_1_touch_screen_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_touch_state.html">TouchState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing touches.  <a href="structnn_1_1hid_1_1_touch_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1hid_1_1_vibration_converter.html">VibrationConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class extracts the vibration value from the sound data.  <a href="classnn_1_1hid_1_1_vibration_converter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_vibration_device_handle.html">VibrationDeviceHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vibration motor's handle.  <a href="structnn_1_1hid_1_1_vibration_device_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_vibration_device_info.html">VibrationDeviceInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure that represents vibration motor information.  <a href="structnn_1_1hid_1_1_vibration_device_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_vibration_file_info.html">VibrationFileInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure that represents vibration file information.  <a href="structnn_1_1hid_1_1_vibration_file_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_vibration_file_parser_context.html">VibrationFileParserContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure that represents the parser context of the vibration file.  <a href="structnn_1_1hid_1_1_vibration_file_parser_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1hid_1_1_vibration_mixer.html">VibrationMixer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vibration node that provides the features of a mixer for mixing vibration values.  <a href="classnn_1_1hid_1_1_vibration_mixer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_vibration_modulation.html">VibrationModulation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing vibration value modulation factors.  <a href="structnn_1_1hid_1_1_vibration_modulation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1hid_1_1_vibration_node.html">VibrationNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for the vibration node.  <a href="classnn_1_1hid_1_1_vibration_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1hid_1_1_vibration_node_connection.html">VibrationNodeConnection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class representing connections between vibration nodes.  <a href="classnn_1_1hid_1_1_vibration_node_connection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1hid_1_1_vibration_player.html">VibrationPlayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vibration node that provides functionality as a source for vibration values by playing back vibration files.  <a href="classnn_1_1hid_1_1_vibration_player.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1hid_1_1_vibration_target.html">VibrationTarget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vibration node that functions as the recipient of vibration values.  <a href="classnn_1_1hid_1_1_vibration_target.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_vibration_value.html">VibrationValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing vibration values.  <a href="structnn_1_1hid_1_1_vibration_value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1hid_1_1_vibration_value_array_info.html">VibrationValueArrayInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure that stores the loop settings and vibration value array.  <a href="structnn_1_1hid_1_1_vibration_value_array_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1hid_1_1_vibration_writer.html">VibrationWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vibration node that provides functionality as a source for vibration values by directly writing them.  <a href="classnn_1_1hid_1_1_vibration_writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad3c97c4609b5b5dccd77a590abec7bcd"><td class="memItemLeft" align="right" valign="top"><a id="ad3c97c4609b5b5dccd77a590abec7bcd"></a>
typedef ::<a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">nn::util::BitFlagSet</a>&lt; 32, <a class="el" href="structnn_1_1hid_1_1_debug_pad_attribute.html">DebugPadAttribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#ad3c97c4609b5b5dccd77a590abec7bcd">DebugPadAttributeSet</a></td></tr>
<tr class="memdesc:ad3c97c4609b5b5dccd77a590abec7bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type to handle the DebugPad input state attribute set. <br /></td></tr>
<tr class="separator:ad3c97c4609b5b5dccd77a590abec7bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade05a2fd118fd65a2624ed19a4356922"><td class="memItemLeft" align="right" valign="top"><a id="ade05a2fd118fd65a2624ed19a4356922"></a>
typedef ::<a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">nn::util::BitFlagSet</a>&lt; 32, <a class="el" href="structnn_1_1hid_1_1_debug_pad_button.html">DebugPadButton</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#ade05a2fd118fd65a2624ed19a4356922">DebugPadButtonSet</a></td></tr>
<tr class="memdesc:ade05a2fd118fd65a2624ed19a4356922"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type for handling the DebugPad digital button set. <br /></td></tr>
<tr class="separator:ade05a2fd118fd65a2624ed19a4356922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada843a8fc07aa99588716aa8ef87d6d4"><td class="memItemLeft" align="right" valign="top"><a id="ada843a8fc07aa99588716aa8ef87d6d4"></a>
typedef ::<a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">nn::util::BitFlagSet</a>&lt; 32, <a class="el" href="structnn_1_1hid_1_1_digitizer_attribute.html">DigitizerAttribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#ada843a8fc07aa99588716aa8ef87d6d4">DigitizerAttributeSet</a></td></tr>
<tr class="memdesc:ada843a8fc07aa99588716aa8ef87d6d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type that handles the attribute set for the digitizer input state. <br /></td></tr>
<tr class="separator:ada843a8fc07aa99588716aa8ef87d6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa244409ebff967347721cc0ef9ba5d79"><td class="memItemLeft" align="right" valign="top"><a id="aa244409ebff967347721cc0ef9ba5d79"></a>
typedef ::<a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">nn::util::BitFlagSet</a>&lt; 32, <a class="el" href="structnn_1_1hid_1_1_digitizer_button.html">DigitizerButton</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#aa244409ebff967347721cc0ef9ba5d79">DigitizerButtonSet</a></td></tr>
<tr class="memdesc:aa244409ebff967347721cc0ef9ba5d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type for handling the set of digital buttons for the digitizer. <br /></td></tr>
<tr class="separator:aa244409ebff967347721cc0ef9ba5d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b11884079ef5fd29d53d0b7434db79f"><td class="memItemLeft" align="right" valign="top"><a id="a7b11884079ef5fd29d53d0b7434db79f"></a>
typedef ::<a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">nn::util::BitFlagSet</a>&lt; 32, <a class="el" href="structnn_1_1hid_1_1_gesture_attribute.html">GestureAttribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a7b11884079ef5fd29d53d0b7434db79f">GestureAttributeSet</a></td></tr>
<tr class="memdesc:a7b11884079ef5fd29d53d0b7434db79f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type to handle the gesture attribute set. <br /></td></tr>
<tr class="separator:a7b11884079ef5fd29d53d0b7434db79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b5c0dabdd741b55d715d31b4945c92"><td class="memItemLeft" align="right" valign="top"><a id="a19b5c0dabdd741b55d715d31b4945c92"></a>
typedef ::<a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">nn::util::BitFlagSet</a>&lt; 32, <a class="el" href="structnn_1_1hid_1_1_keyboard_attribute.html">KeyboardAttribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a19b5c0dabdd741b55d715d31b4945c92">KeyboardAttributeSet</a></td></tr>
<tr class="memdesc:a19b5c0dabdd741b55d715d31b4945c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type to handle a keyboard input state attribute set. <br /></td></tr>
<tr class="separator:a19b5c0dabdd741b55d715d31b4945c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82f09ad39b255b43b55f1ac18b405ed"><td class="memItemLeft" align="right" valign="top"><a id="af82f09ad39b255b43b55f1ac18b405ed"></a>
typedef ::<a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">nn::util::BitFlagSet</a>&lt; 256, <a class="el" href="structnn_1_1hid_1_1_keyboard_key.html">KeyboardKey</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#af82f09ad39b255b43b55f1ac18b405ed">KeyboardKeySet</a></td></tr>
<tr class="memdesc:af82f09ad39b255b43b55f1ac18b405ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type for handling the keyboard keys set. <br /></td></tr>
<tr class="separator:af82f09ad39b255b43b55f1ac18b405ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6655b486a08f329709b336f8b60c66"><td class="memItemLeft" align="right" valign="top"><a id="a8a6655b486a08f329709b336f8b60c66"></a>
typedef ::<a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">nn::util::BitFlagSet</a>&lt; 32, <a class="el" href="structnn_1_1hid_1_1_keyboard_lock_key_event.html">KeyboardLockKeyEvent</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a8a6655b486a08f329709b336f8b60c66">KeyboardLockKeyEventSet</a></td></tr>
<tr class="memdesc:a8a6655b486a08f329709b336f8b60c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type for handling sets of lock key events. <br /></td></tr>
<tr class="separator:a8a6655b486a08f329709b336f8b60c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f953afa0aacfb8081e7d7d028bb96c"><td class="memItemLeft" align="right" valign="top"><a id="a93f953afa0aacfb8081e7d7d028bb96c"></a>
typedef ::<a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">nn::util::BitFlagSet</a>&lt; 32, <a class="el" href="structnn_1_1hid_1_1_keyboard_modifier.html">KeyboardModifier</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a93f953afa0aacfb8081e7d7d028bb96c">KeyboardModifierSet</a></td></tr>
<tr class="memdesc:a93f953afa0aacfb8081e7d7d028bb96c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type for handling the keyboard modifier information set. <br /></td></tr>
<tr class="separator:a93f953afa0aacfb8081e7d7d028bb96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4856e47a9febc8226e6a821d735089a"><td class="memItemLeft" align="right" valign="top"><a id="ad4856e47a9febc8226e6a821d735089a"></a>
typedef ::<a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">nn::util::BitFlagSet</a>&lt; 32, <a class="el" href="structnn_1_1hid_1_1_mouse_attribute.html">MouseAttribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#ad4856e47a9febc8226e6a821d735089a">MouseAttributeSet</a></td></tr>
<tr class="memdesc:ad4856e47a9febc8226e6a821d735089a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type to handle a <code>Mouse</code> input state attribute set. <br /></td></tr>
<tr class="separator:ad4856e47a9febc8226e6a821d735089a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330daf840f6f9263b8e084278aed2528"><td class="memItemLeft" align="right" valign="top"><a id="a330daf840f6f9263b8e084278aed2528"></a>
typedef ::<a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">nn::util::BitFlagSet</a>&lt; 32, <a class="el" href="structnn_1_1hid_1_1_mouse_button.html">MouseButton</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a330daf840f6f9263b8e084278aed2528">MouseButtonSet</a></td></tr>
<tr class="memdesc:a330daf840f6f9263b8e084278aed2528"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type for the set of digital mouse buttons. <br /></td></tr>
<tr class="separator:a330daf840f6f9263b8e084278aed2528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0cbaa378f5328cb2ca6a4f1392aaab"><td class="memItemLeft" align="right" valign="top"><a id="afd0cbaa378f5328cb2ca6a4f1392aaab"></a>
typedef ::<a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">nn::util::BitFlagSet</a>&lt; 32, <a class="el" href="structnn_1_1hid_1_1_npad_attribute.html">NpadAttribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#afd0cbaa378f5328cb2ca6a4f1392aaab">NpadAttributesSet</a></td></tr>
<tr class="memdesc:afd0cbaa378f5328cb2ca6a4f1392aaab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type for the set of Npad state attributes. <br /></td></tr>
<tr class="separator:afd0cbaa378f5328cb2ca6a4f1392aaab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf6d42bae90196bf7d3d87cbc0e5e0b"><td class="memItemLeft" align="right" valign="top"><a id="abdf6d42bae90196bf7d3d87cbc0e5e0b"></a>
typedef ::<a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">nn::util::BitFlagSet</a>&lt; 64, <a class="el" href="structnn_1_1hid_1_1_npad_button.html">NpadButton</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#abdf6d42bae90196bf7d3d87cbc0e5e0b">NpadButtonSet</a></td></tr>
<tr class="memdesc:abdf6d42bae90196bf7d3d87cbc0e5e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type for the set of Npad digital buttons. <br /></td></tr>
<tr class="separator:abdf6d42bae90196bf7d3d87cbc0e5e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5923008962b52bf501f91b30013aedd6"><td class="memItemLeft" align="right" valign="top"><a id="a5923008962b52bf501f91b30013aedd6"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a></td></tr>
<tr class="memdesc:a5923008962b52bf501f91b30013aedd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for representing Npad IDs. <br /></td></tr>
<tr class="separator:a5923008962b52bf501f91b30013aedd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594f4eed71a6821bd28283ce0a273fb1"><td class="memItemLeft" align="right" valign="top"><a id="a594f4eed71a6821bd28283ce0a273fb1"></a>
typedef ::<a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">nn::util::BitFlagSet</a>&lt; 32, NpadStyleTag &gt;::Flag&lt; 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a594f4eed71a6821bd28283ce0a273fb1">NpadStyleFullKey</a></td></tr>
<tr class="memdesc:a594f4eed71a6821bd28283ce0a273fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a play style modeled on the Switch Pro Controller. <br /></td></tr>
<tr class="separator:a594f4eed71a6821bd28283ce0a273fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162751ccfcb8408b822ee308ebe7a2c9"><td class="memItemLeft" align="right" valign="top"><a id="a162751ccfcb8408b822ee308ebe7a2c9"></a>
typedef ::<a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">nn::util::BitFlagSet</a>&lt; 32, NpadStyleTag &gt;::Flag&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a162751ccfcb8408b822ee308ebe7a2c9">NpadStyleHandheld</a></td></tr>
<tr class="memdesc:a162751ccfcb8408b822ee308ebe7a2c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a play style modeled on a handheld controller. <br /></td></tr>
<tr class="separator:a162751ccfcb8408b822ee308ebe7a2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1528b4e8a2b39e40f5f76c847c4ccc82"><td class="memItemLeft" align="right" valign="top">typedef ::<a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">nn::util::BitFlagSet</a>&lt; 32, NpadStyleTag &gt;::Flag&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a1528b4e8a2b39e40f5f76c847c4ccc82">NpadStyleJoyDual</a></td></tr>
<tr class="memdesc:a1528b4e8a2b39e40f5f76c847c4ccc82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a play style modeled on holding two Joy-Con controllers.  <a href="namespacenn_1_1hid.html#a1528b4e8a2b39e40f5f76c847c4ccc82">More...</a><br /></td></tr>
<tr class="separator:a1528b4e8a2b39e40f5f76c847c4ccc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f2c921b3f4d3a9b8e02ddc30ea50b8"><td class="memItemLeft" align="right" valign="top">typedef ::<a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">nn::util::BitFlagSet</a>&lt; 32, NpadStyleTag &gt;::Flag&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a93f2c921b3f4d3a9b8e02ddc30ea50b8">NpadStyleJoyLeft</a></td></tr>
<tr class="memdesc:a93f2c921b3f4d3a9b8e02ddc30ea50b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a play style modeled on the Joy-Con (L).  <a href="namespacenn_1_1hid.html#a93f2c921b3f4d3a9b8e02ddc30ea50b8">More...</a><br /></td></tr>
<tr class="separator:a93f2c921b3f4d3a9b8e02ddc30ea50b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09597ee31314ec6782e5f56384ea5b9"><td class="memItemLeft" align="right" valign="top">typedef ::<a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">nn::util::BitFlagSet</a>&lt; 32, NpadStyleTag &gt;::Flag&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#aa09597ee31314ec6782e5f56384ea5b9">NpadStyleJoyRight</a></td></tr>
<tr class="memdesc:aa09597ee31314ec6782e5f56384ea5b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a play style modeled on the Joy-Con (R).  <a href="namespacenn_1_1hid.html#aa09597ee31314ec6782e5f56384ea5b9">More...</a><br /></td></tr>
<tr class="separator:aa09597ee31314ec6782e5f56384ea5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace65233620edda5185ed73112ca9805f"><td class="memItemLeft" align="right" valign="top"><a id="ace65233620edda5185ed73112ca9805f"></a>
typedef ::<a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">nn::util::BitFlagSet</a>&lt; 32, NpadStyleTag &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#ace65233620edda5185ed73112ca9805f">NpadStyleSet</a></td></tr>
<tr class="memdesc:ace65233620edda5185ed73112ca9805f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type for the set of Npad operational styles. <br /></td></tr>
<tr class="separator:ace65233620edda5185ed73112ca9805f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15969cc6abdf3c458483607e2f5ff4c"><td class="memItemLeft" align="right" valign="top"><a id="ab15969cc6abdf3c458483607e2f5ff4c"></a>
typedef ::<a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">nn::util::BitFlagSet</a>&lt; 32, <a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_attribute.html">SixAxisSensorAttribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#ab15969cc6abdf3c458483607e2f5ff4c">SixAxisSensorAttributeSet</a></td></tr>
<tr class="memdesc:ab15969cc6abdf3c458483607e2f5ff4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type to handle a <code>SixAxisSensor</code> input state attribute set. <br /></td></tr>
<tr class="separator:ab15969cc6abdf3c458483607e2f5ff4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0fcdb89d076119be3a69a9b321975e"><td class="memItemLeft" align="right" valign="top"><a id="aef0fcdb89d076119be3a69a9b321975e"></a>
typedef ::<a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">nn::util::BitFlagSet</a>&lt; 32, <a class="el" href="structnn_1_1hid_1_1_touch_attribute.html">TouchAttribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#aef0fcdb89d076119be3a69a9b321975e">TouchAttributeSet</a></td></tr>
<tr class="memdesc:aef0fcdb89d076119be3a69a9b321975e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type to handle the touch attribute set. <br /></td></tr>
<tr class="separator:aef0fcdb89d076119be3a69a9b321975e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae2fae4c1fdc6f4007776b6d58fa68949"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#ae2fae4c1fdc6f4007776b6d58fa68949">GestureDirection</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#ae2fae4c1fdc6f4007776b6d58fa68949a6adf97f83acf6453d4a6a4b1070f3754">None</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#ae2fae4c1fdc6f4007776b6d58fa68949a945d5e233cf7d6240f6b783b36a374ff">Left</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#ae2fae4c1fdc6f4007776b6d58fa68949a258f49887ef8d14ac268c92b02503aaa">Up</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#ae2fae4c1fdc6f4007776b6d58fa68949a92b09c7c48c520c3c55e497875da437c">Right</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#ae2fae4c1fdc6f4007776b6d58fa68949a08a38277b0309070706f6652eeae9a53">Down</a>
<br />
 }</td></tr>
<tr class="memdesc:ae2fae4c1fdc6f4007776b6d58fa68949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated type that specifies the gesture direction.  <a href="namespacenn_1_1hid.html#ae2fae4c1fdc6f4007776b6d58fa68949">More...</a><br /></td></tr>
<tr class="separator:ae2fae4c1fdc6f4007776b6d58fa68949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258b0d78215e9aef289f8d784495159a"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a258b0d78215e9aef289f8d784495159a">GestureType</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#a258b0d78215e9aef289f8d784495159aae599161956d626eda4cb0a5ffb85271c">Idle</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#a258b0d78215e9aef289f8d784495159aaae94f80b3ce82062a5dd7815daa04f9d">Complete</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#a258b0d78215e9aef289f8d784495159aaea4788705e6873b424c65e91c2846b19">Cancel</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#a258b0d78215e9aef289f8d784495159aaf0f31c9700c6b10d8a20dc487b2ae6a8">Touch</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#a258b0d78215e9aef289f8d784495159aa0610123bdd4ffc191a3ea05a847e1307">Press</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#a258b0d78215e9aef289f8d784495159aa73cf2f244bc0cb0d205b99c04fa13978">Tap</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#a258b0d78215e9aef289f8d784495159aaf6d4a17b27da35c2d90ce13801f36782">Pan</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#a258b0d78215e9aef289f8d784495159aa78076ce792c4640bf99c598c92bd69e7">Swipe</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#a258b0d78215e9aef289f8d784495159aa1e4ddf6f135e4c639929b4633c29d4f2">Pinch</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#a258b0d78215e9aef289f8d784495159aa8d2de5368588552fbae54044ac5c7b3d">Rotate</a>
<br />
 }</td></tr>
<tr class="memdesc:a258b0d78215e9aef289f8d784495159a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated type that specifies the gesture type.  <a href="namespacenn_1_1hid.html#a258b0d78215e9aef289f8d784495159a">More...</a><br /></td></tr>
<tr class="separator:a258b0d78215e9aef289f8d784495159a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc5c782bfc4ce2b5982eacb91fdf5e0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#afcc5c782bfc4ce2b5982eacb91fdf5e0">GyroscopeZeroDriftMode</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#afcc5c782bfc4ce2b5982eacb91fdf5e0a41e2117cc90518714b8095619c8b893c">GyroscopeZeroDriftMode_Loose</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#afcc5c782bfc4ce2b5982eacb91fdf5e0af36c04249bcc0b0c46532cde018519fb">GyroscopeZeroDriftMode_Standard</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#afcc5c782bfc4ce2b5982eacb91fdf5e0a67789df4a3bdf76bbd3fb85952d63678">GyroscopeZeroDriftMode_Tight</a>
<br />
 }</td></tr>
<tr class="memdesc:afcc5c782bfc4ce2b5982eacb91fdf5e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition for the zero point correction mode for the gyro sensors.  <a href="namespacenn_1_1hid.html#afcc5c782bfc4ce2b5982eacb91fdf5e0">More...</a><br /></td></tr>
<tr class="separator:afcc5c782bfc4ce2b5982eacb91fdf5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab802029f44fe9e63041973e712793440"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#ab802029f44fe9e63041973e712793440">NpadCommunicationMode</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#ab802029f44fe9e63041973e712793440a0acd94277961918f98c1916c3cc1ece1">NpadCommunicationMode_5ms</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#ab802029f44fe9e63041973e712793440aa50a6fe343a7b2a9aa6370e13e8aea7b">NpadCommunicationMode_10ms</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#ab802029f44fe9e63041973e712793440a01d61a1676fdacbd4df7596c2ac90ab8">NpadCommunicationMode_15ms</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#ab802029f44fe9e63041973e712793440aaeb8c6f9483e7aa69073f901b0b0d44a">NpadCommunicationMode_Default</a>
<br />
 }</td></tr>
<tr class="memdesc:ab802029f44fe9e63041973e712793440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions of Joy-Con communication modes.  <a href="namespacenn_1_1hid.html#ab802029f44fe9e63041973e712793440">More...</a><br /></td></tr>
<tr class="separator:ab802029f44fe9e63041973e712793440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8f966eb92ca5f66ead837bdc6874a2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#afc8f966eb92ca5f66ead837bdc6874a2">NpadHandheldActivationMode</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#afc8f966eb92ca5f66ead837bdc6874a2a96376c5b4f7484f6b53c28ea4f23b5aa">NpadHandheldActivationMode_Dual</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#afc8f966eb92ca5f66ead837bdc6874a2a6284af1badbbf8a81b4d78e804b3978b">NpadHandheldActivationMode_Single</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#afc8f966eb92ca5f66ead837bdc6874a2a24ee66d461e50c6cac7cd755c0e9bc96">NpadHandheldActivationMode_None</a>
<br />
 }</td></tr>
<tr class="memdesc:afc8f966eb92ca5f66ead837bdc6874a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the mode that activates the handheld play style.  <a href="namespacenn_1_1hid.html#afc8f966eb92ca5f66ead837bdc6874a2">More...</a><br /></td></tr>
<tr class="separator:afc8f966eb92ca5f66ead837bdc6874a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4b0ecdaa297bb33e65d46b2f350546"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a6c4b0ecdaa297bb33e65d46b2f350546">NpadJoyAssignmentMode</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#a6c4b0ecdaa297bb33e65d46b2f350546a14b223c9a0a1d5d9eb26a03b68e7c3a8">NpadJoyAssignmentMode_Dual</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#a6c4b0ecdaa297bb33e65d46b2f350546aa5c3821ed1fa09b77fb68d7930b20c08">NpadJoyAssignmentMode_Single</a>
<br />
 }</td></tr>
<tr class="memdesc:a6c4b0ecdaa297bb33e65d46b2f350546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions of Joy-Con assignment modes for Npads.  <a href="namespacenn_1_1hid.html#a6c4b0ecdaa297bb33e65d46b2f350546">More...</a><br /></td></tr>
<tr class="separator:a6c4b0ecdaa297bb33e65d46b2f350546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d96e4c4c5907c24b58ce53a5b39b64"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#ab6d96e4c4c5907c24b58ce53a5b39b64">NpadJoyDeviceType</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#ab6d96e4c4c5907c24b58ce53a5b39b64ac4b51bc01228732adc00f8e31faea71a">NpadJoyDeviceType_Left</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#ab6d96e4c4c5907c24b58ce53a5b39b64a420827cd4ec7d5bc011f0716ec7c0ad7">NpadJoyDeviceType_Right</a>
<br />
 }</td></tr>
<tr class="memdesc:ab6d96e4c4c5907c24b58ce53a5b39b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions of the types of Joy-Cons.  <a href="namespacenn_1_1hid.html#ab6d96e4c4c5907c24b58ce53a5b39b64">More...</a><br /></td></tr>
<tr class="separator:ab6d96e4c4c5907c24b58ce53a5b39b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af526a8dbb614b2703ab26245ec37e15f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#af526a8dbb614b2703ab26245ec37e15f">NpadJoyHoldType</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#af526a8dbb614b2703ab26245ec37e15fa4c6d26496f0de85ce5eca9103caf9f9d">NpadJoyHoldType_Vertical</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#af526a8dbb614b2703ab26245ec37e15fa3408c344165586f68fe1686e042f573a">NpadJoyHoldType_Horizontal</a>
<br />
 }</td></tr>
<tr class="memdesc:af526a8dbb614b2703ab26245ec37e15f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions of the ways of holding the Joy-Con.  <a href="namespacenn_1_1hid.html#af526a8dbb614b2703ab26245ec37e15f">More...</a><br /></td></tr>
<tr class="separator:af526a8dbb614b2703ab26245ec37e15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd1eda256a2981614b26cd038f5c6ec"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a0fd1eda256a2981614b26cd038f5c6ec">VibrationDevicePosition</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#a0fd1eda256a2981614b26cd038f5c6eca0686d7b5ce72b1e00b0c706dca51d99c">VibrationDevicePosition_None</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#a0fd1eda256a2981614b26cd038f5c6eca8a5eede1ab775a61011a111562aef309">VibrationDevicePosition_Left</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#a0fd1eda256a2981614b26cd038f5c6eca6baeddecc61560248160f8fb3334165e">VibrationDevicePosition_Right</a>
<br />
 }</td></tr>
<tr class="memdesc:a0fd1eda256a2981614b26cd038f5c6ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The enumerated type for the physical locations of vibration motors.  <a href="namespacenn_1_1hid.html#a0fd1eda256a2981614b26cd038f5c6ec">More...</a><br /></td></tr>
<tr class="separator:a0fd1eda256a2981614b26cd038f5c6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa410c3c8fb9166daad40d757c065ba"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a9fa410c3c8fb9166daad40d757c065ba">VibrationDeviceType</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#a9fa410c3c8fb9166daad40d757c065baa03e8832fd08192d8a23eaa3159b7e905">VibrationDeviceType_Unknown</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#a9fa410c3c8fb9166daad40d757c065baa9be9b2d2ed0620f35618c4cc66e79dd3">VibrationDeviceType_LinearResonantActuator</a>
<br />
 }</td></tr>
<tr class="memdesc:a9fa410c3c8fb9166daad40d757c065ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The enumerated type for the physical types of vibration motors.  <a href="namespacenn_1_1hid.html#a9fa410c3c8fb9166daad40d757c065ba">More...</a><br /></td></tr>
<tr class="separator:a9fa410c3c8fb9166daad40d757c065ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc165fa9fa37eeefe20379b2998e917d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#adc165fa9fa37eeefe20379b2998e917d">VibrationMixMode</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#adc165fa9fa37eeefe20379b2998e917da19ede5cef759070330d1cf3fd8360569">VibrationMixMode_None</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#adc165fa9fa37eeefe20379b2998e917da1797c669c6e76af275b3b3d2020f9c59">VibrationMixMode_MaxAmplitude</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#adc165fa9fa37eeefe20379b2998e917da3e858457a190e1c444203b8da0d2a6d8">VibrationMixMode_MaxAmplitudePerSubband</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1hid.html#adc165fa9fa37eeefe20379b2998e917da76ca4048abcea197549c5c5d534e7927">VibrationMixMode_AmplitudeSum</a>
<br />
 }</td></tr>
<tr class="memdesc:adc165fa9fa37eeefe20379b2998e917d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The enumerated type for vibration value mixing modes.  <a href="namespacenn_1_1hid.html#adc165fa9fa37eeefe20379b2998e917d">More...</a><br /></td></tr>
<tr class="separator:adc165fa9fa37eeefe20379b2998e917d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9655269c05d48bd56c3e25ee20c99831"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a9655269c05d48bd56c3e25ee20c99831">SetExplainText</a> (<a class="el" href="structnn_1_1hid_1_1_controller_support_arg.html">ControllerSupportArg</a> *pOutControllerSupportArg, const char *pStr, const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;id) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9655269c05d48bd56c3e25ee20c99831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets text with a description for each separate controller number.  <a href="namespacenn_1_1hid.html#a9655269c05d48bd56c3e25ee20c99831">More...</a><br /></td></tr>
<tr class="separator:a9655269c05d48bd56c3e25ee20c99831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7533399b957c748b818b5a2114541ca8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a7533399b957c748b818b5a2114541ca8">ShowControllerFirmwareUpdate</a> (const <a class="el" href="structnn_1_1hid_1_1_controller_firmware_update_arg.html">ControllerFirmwareUpdateArg</a> &amp;showControllerFirmwareUpdateArg) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7533399b957c748b818b5a2114541ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays the UI for updating controller firmware.  <a href="namespacenn_1_1hid.html#a7533399b957c748b818b5a2114541ca8">More...</a><br /></td></tr>
<tr class="separator:a7533399b957c748b818b5a2114541ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab472d47d7e876878e4b434f665de6522"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#ab472d47d7e876878e4b434f665de6522">ShowControllerStrapGuide</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab472d47d7e876878e4b434f665de6522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays the guide for using the controller strap.  <a href="namespacenn_1_1hid.html#ab472d47d7e876878e4b434f665de6522">More...</a><br /></td></tr>
<tr class="separator:ab472d47d7e876878e4b434f665de6522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942c0cad1b2e3d791e7e2cbc730b3041"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a942c0cad1b2e3d791e7e2cbc730b3041">ShowControllerSupport</a> (const <a class="el" href="structnn_1_1hid_1_1_controller_support_arg.html">ControllerSupportArg</a> &amp;showControllerSupportArg) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a942c0cad1b2e3d791e7e2cbc730b3041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays the UI that supports the connection of controllers.  <a href="namespacenn_1_1hid.html#a942c0cad1b2e3d791e7e2cbc730b3041">More...</a><br /></td></tr>
<tr class="separator:a942c0cad1b2e3d791e7e2cbc730b3041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2219b18059d44f1f0400587e71e2b1b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a2219b18059d44f1f0400587e71e2b1b7">ShowControllerSupport</a> (<a class="el" href="structnn_1_1hid_1_1_controller_support_result_info.html">ControllerSupportResultInfo</a> *pOutValue, const <a class="el" href="structnn_1_1hid_1_1_controller_support_arg.html">ControllerSupportArg</a> &amp;showControllerSupportArg) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2219b18059d44f1f0400587e71e2b1b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays the UI that supports the connection of controllers.  <a href="namespacenn_1_1hid.html#a2219b18059d44f1f0400587e71e2b1b7">More...</a><br /></td></tr>
<tr class="separator:a2219b18059d44f1f0400587e71e2b1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">DebugPad API Resources</div></td></tr>
<tr class="memitem:a52f910e37e347a944be54f6860a8ed11"><td class="memItemLeft" align="right" valign="top"><a id="a52f910e37e347a944be54f6860a8ed11"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a52f910e37e347a944be54f6860a8ed11">InitializeDebugPad</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a52f910e37e347a944be54f6860a8ed11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes DebugPad. <br /></td></tr>
<tr class="separator:a52f910e37e347a944be54f6860a8ed11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6819dc9ed7d781a23a0a44cd2a7f86c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#ad6819dc9ed7d781a23a0a44cd2a7f86c">GetDebugPadState</a> (<a class="el" href="structnn_1_1hid_1_1_debug_pad_state.html">DebugPadState</a> *pOutValue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad6819dc9ed7d781a23a0a44cd2a7f86c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the latest DebugPad input state.  <a href="namespacenn_1_1hid.html#ad6819dc9ed7d781a23a0a44cd2a7f86c">More...</a><br /></td></tr>
<tr class="separator:ad6819dc9ed7d781a23a0a44cd2a7f86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391451a9758037697be8138805a832fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a391451a9758037697be8138805a832fd">GetDebugPadStates</a> (<a class="el" href="structnn_1_1hid_1_1_debug_pad_state.html">DebugPadState</a> outValues[], int count) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a391451a9758037697be8138805a832fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads past DebugPad input states.  <a href="namespacenn_1_1hid.html#a391451a9758037697be8138805a832fd">More...</a><br /></td></tr>
<tr class="separator:a391451a9758037697be8138805a832fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Digitizer API Resources</div></td></tr>
<tr class="memitem:a1b77564dd958e68916c1c13bad99546d"><td class="memItemLeft" align="right" valign="top"><a id="a1b77564dd958e68916c1c13bad99546d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a1b77564dd958e68916c1c13bad99546d">InitializeDigitizer</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1b77564dd958e68916c1c13bad99546d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the digitizer. <br /></td></tr>
<tr class="separator:a1b77564dd958e68916c1c13bad99546d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa199f5e0474ad63f3d3ff0f89a80781f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#aa199f5e0474ad63f3d3ff0f89a80781f">GetDigitizerState</a> (<a class="el" href="structnn_1_1hid_1_1_digitizer_state.html">DigitizerState</a> *pOutValue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa199f5e0474ad63f3d3ff0f89a80781f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the latest input state of the digitizer.  <a href="namespacenn_1_1hid.html#aa199f5e0474ad63f3d3ff0f89a80781f">More...</a><br /></td></tr>
<tr class="separator:aa199f5e0474ad63f3d3ff0f89a80781f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15908d2bb614d01e6008d8d742d93270"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a15908d2bb614d01e6008d8d742d93270">GetDigitizerStates</a> (<a class="el" href="structnn_1_1hid_1_1_digitizer_state.html">DigitizerState</a> outValues[], int count) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a15908d2bb614d01e6008d8d742d93270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the past input states of the digitizer.  <a href="namespacenn_1_1hid.html#a15908d2bb614d01e6008d8d742d93270">More...</a><br /></td></tr>
<tr class="separator:a15908d2bb614d01e6008d8d742d93270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Gesture Related Functions</div></td></tr>
<tr class="memitem:ac48d26c15ce9679154f2f16266d167c8"><td class="memItemLeft" align="right" valign="top"><a id="ac48d26c15ce9679154f2f16266d167c8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#ac48d26c15ce9679154f2f16266d167c8">InitializeGesture</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac48d26c15ce9679154f2f16266d167c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the gesture related functions. <br /></td></tr>
<tr class="separator:ac48d26c15ce9679154f2f16266d167c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f5382d841a4e81da4b0dcde9746ca16"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a2f5382d841a4e81da4b0dcde9746ca16">GetGestureStates</a> (<a class="el" href="structnn_1_1hid_1_1_gesture_state.html">GestureState</a> outValues[], int count) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2f5382d841a4e81da4b0dcde9746ca16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads past gesture states.  <a href="namespacenn_1_1hid.html#a2f5382d841a4e81da4b0dcde9746ca16">More...</a><br /></td></tr>
<tr class="separator:a2f5382d841a4e81da4b0dcde9746ca16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Keyboard API Resources</div></td></tr>
<tr class="memitem:a7166575a2fd722e67eb8400828dd4b72"><td class="memItemLeft" align="right" valign="top"><a id="a7166575a2fd722e67eb8400828dd4b72"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a7166575a2fd722e67eb8400828dd4b72">InitializeKeyboard</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7166575a2fd722e67eb8400828dd4b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the keyboard. <br /></td></tr>
<tr class="separator:a7166575a2fd722e67eb8400828dd4b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe32e309493540451e3ada237ba6ee6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#abe32e309493540451e3ada237ba6ee6c">GetKeyboardState</a> (<a class="el" href="structnn_1_1hid_1_1_keyboard_state.html">KeyboardState</a> *pOutValue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:abe32e309493540451e3ada237ba6ee6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the latest keyboard input state.  <a href="namespacenn_1_1hid.html#abe32e309493540451e3ada237ba6ee6c">More...</a><br /></td></tr>
<tr class="separator:abe32e309493540451e3ada237ba6ee6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd47864aa616886e73f16c07b0c1dae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a1dd47864aa616886e73f16c07b0c1dae">GetKeyboardStates</a> (<a class="el" href="structnn_1_1hid_1_1_keyboard_state.html">KeyboardState</a> outValues[], int count) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1dd47864aa616886e73f16c07b0c1dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads past keyboard input states.  <a href="namespacenn_1_1hid.html#a1dd47864aa616886e73f16c07b0c1dae">More...</a><br /></td></tr>
<tr class="separator:a1dd47864aa616886e73f16c07b0c1dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79985581b51a04253790a776580efac2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a79985581b51a04253790a776580efac2">SendKeyboardLockKeyEvent</a> (<a class="el" href="namespacenn_1_1hid.html#a8a6655b486a08f329709b336f8b60c66">KeyboardLockKeyEventSet</a> value) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a79985581b51a04253790a776580efac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends keyboard lock key events.  <a href="namespacenn_1_1hid.html#a79985581b51a04253790a776580efac2">More...</a><br /></td></tr>
<tr class="separator:a79985581b51a04253790a776580efac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mouse API Resources</div></td></tr>
<tr class="memitem:a322597cf6f0cf7641113a59e4cfb3ccb"><td class="memItemLeft" align="right" valign="top"><a id="a322597cf6f0cf7641113a59e4cfb3ccb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a322597cf6f0cf7641113a59e4cfb3ccb">InitializeMouse</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a322597cf6f0cf7641113a59e4cfb3ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the mouse. <br /></td></tr>
<tr class="separator:a322597cf6f0cf7641113a59e4cfb3ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e836e16eaa572da7ccbfc9c3b7de5bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a2e836e16eaa572da7ccbfc9c3b7de5bf">GetMouseState</a> (<a class="el" href="structnn_1_1hid_1_1_mouse_state.html">MouseState</a> *pOutValue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2e836e16eaa572da7ccbfc9c3b7de5bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the latest mouse input state.  <a href="namespacenn_1_1hid.html#a2e836e16eaa572da7ccbfc9c3b7de5bf">More...</a><br /></td></tr>
<tr class="separator:a2e836e16eaa572da7ccbfc9c3b7de5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c19c1a965e1aa4d45f608ed291fe4da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a3c19c1a965e1aa4d45f608ed291fe4da">GetMouseStates</a> (<a class="el" href="structnn_1_1hid_1_1_mouse_state.html">MouseState</a> outValues[], int count) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3c19c1a965e1aa4d45f608ed291fe4da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads past mouse input states.  <a href="namespacenn_1_1hid.html#a3c19c1a965e1aa4d45f608ed291fe4da">More...</a><br /></td></tr>
<tr class="separator:a3c19c1a965e1aa4d45f608ed291fe4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Common Npad API Resources</div></td></tr>
<tr class="memitem:a0dd2297c0b25b9130427dba90523a920"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a0dd2297c0b25b9130427dba90523a920">GetNpadControllerColor</a> (<a class="el" href="structnn_1_1hid_1_1_npad_controller_color.html">NpadControllerColor</a> *pOutValue, const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;id) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0dd2297c0b25b9130427dba90523a920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the color for the controller assigned to Npad.  <a href="namespacenn_1_1hid.html#a0dd2297c0b25b9130427dba90523a920">More...</a><br /></td></tr>
<tr class="separator:a0dd2297c0b25b9130427dba90523a920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a72a048e2aee0005d50597ad1bfb059"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a3a72a048e2aee0005d50597ad1bfb059">GetNpadControllerColor</a> (<a class="el" href="structnn_1_1hid_1_1_npad_controller_color.html">NpadControllerColor</a> *pOutLeftColor, <a class="el" href="structnn_1_1hid_1_1_npad_controller_color.html">NpadControllerColor</a> *pOutRightColor, const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;id) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3a72a048e2aee0005d50597ad1bfb059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the color for the right and left Joy-Con controllers assigned to Npad.  <a href="namespacenn_1_1hid.html#a3a72a048e2aee0005d50597ad1bfb059">More...</a><br /></td></tr>
<tr class="separator:a3a72a048e2aee0005d50597ad1bfb059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ad6953b9cef17b4d79171e819b0048"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a54ad6953b9cef17b4d79171e819b0048">InitializeNpad</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a54ad6953b9cef17b4d79171e819b0048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an Npad.  <a href="namespacenn_1_1hid.html#a54ad6953b9cef17b4d79171e819b0048">More...</a><br /></td></tr>
<tr class="separator:a54ad6953b9cef17b4d79171e819b0048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04a55a989058f9d69c5c3e4e29c4480"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#ac04a55a989058f9d69c5c3e4e29c4480">SetSupportedNpadStyleSet</a> (<a class="el" href="namespacenn_1_1hid.html#ace65233620edda5185ed73112ca9805f">NpadStyleSet</a> style) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac04a55a989058f9d69c5c3e4e29c4480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the play style to enable on the Npad.  <a href="namespacenn_1_1hid.html#ac04a55a989058f9d69c5c3e4e29c4480">More...</a><br /></td></tr>
<tr class="separator:ac04a55a989058f9d69c5c3e4e29c4480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099b8efd2f1145ada76ad1f40f69d6ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1hid.html#ace65233620edda5185ed73112ca9805f">NpadStyleSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a099b8efd2f1145ada76ad1f40f69d6ce">GetSupportedNpadStyleSet</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a099b8efd2f1145ada76ad1f40f69d6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Npad play styles supported by the application.  <a href="namespacenn_1_1hid.html#a099b8efd2f1145ada76ad1f40f69d6ce">More...</a><br /></td></tr>
<tr class="separator:a099b8efd2f1145ada76ad1f40f69d6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82326d8c0d5f888fce443798bb829e97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a82326d8c0d5f888fce443798bb829e97">SetSupportedNpadIdType</a> (const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> *pIds, size_t count) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a82326d8c0d5f888fce443798bb829e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the Npad ID to support with the application.  <a href="namespacenn_1_1hid.html#a82326d8c0d5f888fce443798bb829e97">More...</a><br /></td></tr>
<tr class="separator:a82326d8c0d5f888fce443798bb829e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee99658f6af775470baa85ed17135c5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#aee99658f6af775470baa85ed17135c5b">BindNpadStyleSetUpdateEvent</a> (const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;id, ::<a class="el" href="structnn_1_1os_1_1_system_event_type.html">nn::os::SystemEventType</a> *pEvent, ::<a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452">nn::os::EventClearMode</a> clearMode) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aee99658f6af775470baa85ed17135c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds a notification that is received when the Npad play style is updated.  <a href="namespacenn_1_1hid.html#aee99658f6af775470baa85ed17135c5b">More...</a><br /></td></tr>
<tr class="separator:aee99658f6af775470baa85ed17135c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e56789aa106765d43935bb1838c797"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1hid.html#ace65233620edda5185ed73112ca9805f">NpadStyleSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a50e56789aa106765d43935bb1838c797">GetNpadStyleSet</a> (const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;id) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a50e56789aa106765d43935bb1838c797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the currently enabled play styles for any Npad ID.  <a href="namespacenn_1_1hid.html#a50e56789aa106765d43935bb1838c797">More...</a><br /></td></tr>
<tr class="separator:a50e56789aa106765d43935bb1838c797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090e5d4ee7965fa9bfb2f7737abd8341"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a090e5d4ee7965fa9bfb2f7737abd8341">DisconnectNpad</a> (const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;id) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a090e5d4ee7965fa9bfb2f7737abd8341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects an Npad.  <a href="namespacenn_1_1hid.html#a090e5d4ee7965fa9bfb2f7737abd8341">More...</a><br /></td></tr>
<tr class="separator:a090e5d4ee7965fa9bfb2f7737abd8341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44729652fee8f9b1371e899f21771c0e"><td class="memItemLeft" align="right" valign="top">Bit8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a44729652fee8f9b1371e899f21771c0e">GetPlayerLedPattern</a> (const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;id) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a44729652fee8f9b1371e899f21771c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pattern of lit Npad player LEDs.  <a href="namespacenn_1_1hid.html#a44729652fee8f9b1371e899f21771c0e">More...</a><br /></td></tr>
<tr class="separator:a44729652fee8f9b1371e899f21771c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions for Each Npad Play Style</div></td></tr>
<tr class="memitem:a1ea1131389075ff5c5d5911dd6da9b8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a1ea1131389075ff5c5d5911dd6da9b8f">GetNpadState</a> (<a class="el" href="structnn_1_1hid_1_1_npad_full_key_state.html">NpadFullKeyState</a> *pOutValue, const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;id) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1ea1131389075ff5c5d5911dd6da9b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the input states for the <code>NpadStyleFullKey</code> play style modeled on the Npad Switch Pro Controller.  <a href="namespacenn_1_1hid.html#a1ea1131389075ff5c5d5911dd6da9b8f">More...</a><br /></td></tr>
<tr class="separator:a1ea1131389075ff5c5d5911dd6da9b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce232e78c3098d144e001a546fd0781"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a5ce232e78c3098d144e001a546fd0781">GetNpadStates</a> (<a class="el" href="structnn_1_1hid_1_1_npad_full_key_state.html">NpadFullKeyState</a> *pOutValues, int count, const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;id) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5ce232e78c3098d144e001a546fd0781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the past input states for the <code>NpadStyleFullKey</code> play style, modeled on the use of the Npad Switch Pro Controller.  <a href="namespacenn_1_1hid.html#a5ce232e78c3098d144e001a546fd0781">More...</a><br /></td></tr>
<tr class="separator:a5ce232e78c3098d144e001a546fd0781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c7558a3c94c1eba7af400237f40af7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#ac8c7558a3c94c1eba7af400237f40af7">GetNpadState</a> (<a class="el" href="structnn_1_1hid_1_1_npad_handheld_state.html">NpadHandheldState</a> *pOutValue, const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;id) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac8c7558a3c94c1eba7af400237f40af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the latest input states for the <code>NpadStyleHandheld</code> play style modeled on holding an Npad handheld controller.  <a href="namespacenn_1_1hid.html#ac8c7558a3c94c1eba7af400237f40af7">More...</a><br /></td></tr>
<tr class="separator:ac8c7558a3c94c1eba7af400237f40af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41f8ca9734f504f1475d63f3c20b53f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#ab41f8ca9734f504f1475d63f3c20b53f">GetNpadStates</a> (<a class="el" href="structnn_1_1hid_1_1_npad_handheld_state.html">NpadHandheldState</a> *pOutValues, int count, const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;id) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab41f8ca9734f504f1475d63f3c20b53f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the past input states for the <code>NpadStyleHandheld</code> play style, modeled on Npad handheld controller use.  <a href="namespacenn_1_1hid.html#ab41f8ca9734f504f1475d63f3c20b53f">More...</a><br /></td></tr>
<tr class="separator:ab41f8ca9734f504f1475d63f3c20b53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Npad Joy-Con Controller API</div></td></tr>
<tr class="memitem:ae3197d5100e6e84a467050a6f254b15d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1hid.html#a6c4b0ecdaa297bb33e65d46b2f350546">NpadJoyAssignmentMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#ae3197d5100e6e84a467050a6f254b15d">GetNpadJoyAssignment</a> (const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;id) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae3197d5100e6e84a467050a6f254b15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Npad's Joy-Con assignment mode.  <a href="namespacenn_1_1hid.html#ae3197d5100e6e84a467050a6f254b15d">More...</a><br /></td></tr>
<tr class="separator:ae3197d5100e6e84a467050a6f254b15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617f872f844f16873b925fe0669a898a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a617f872f844f16873b925fe0669a898a">SetNpadJoyAssignmentModeSingle</a> (const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;id) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a617f872f844f16873b925fe0669a898a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the Npad's Joy-Con assignment mode to "Single.".  <a href="namespacenn_1_1hid.html#a617f872f844f16873b925fe0669a898a">More...</a><br /></td></tr>
<tr class="separator:a617f872f844f16873b925fe0669a898a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9be0a07a4b174a523e75c9eb8a94b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a4f9be0a07a4b174a523e75c9eb8a94b8">SetNpadJoyAssignmentModeSingle</a> (const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;id, <a class="el" href="namespacenn_1_1hid.html#ab6d96e4c4c5907c24b58ce53a5b39b64">NpadJoyDeviceType</a> type) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4f9be0a07a4b174a523e75c9eb8a94b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the Npad's Joy-Con assignment mode to "Single.".  <a href="namespacenn_1_1hid.html#a4f9be0a07a4b174a523e75c9eb8a94b8">More...</a><br /></td></tr>
<tr class="separator:a4f9be0a07a4b174a523e75c9eb8a94b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9d19aa87ec9120f17cb93578fa2b9e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a4f9d19aa87ec9120f17cb93578fa2b9e">SetNpadJoyAssignmentModeSingle</a> (<a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> *pOutValue, const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;id, <a class="el" href="namespacenn_1_1hid.html#ab6d96e4c4c5907c24b58ce53a5b39b64">NpadJoyDeviceType</a> type) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4f9d19aa87ec9120f17cb93578fa2b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the Npad's Joy-Con assignment mode to <b>single mode</b>, and gets the newly assigned Npad ID for the other Joy-Con that was assigned to a different Npad.  <a href="namespacenn_1_1hid.html#a4f9d19aa87ec9120f17cb93578fa2b9e">More...</a><br /></td></tr>
<tr class="separator:a4f9d19aa87ec9120f17cb93578fa2b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae113078fec2203ef85f1c92bc9119183"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#ae113078fec2203ef85f1c92bc9119183">SetNpadJoyAssignmentModeDual</a> (const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;id) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae113078fec2203ef85f1c92bc9119183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the Joy-Con assignment mode for the Npad to dual mode.  <a href="namespacenn_1_1hid.html#ae113078fec2203ef85f1c92bc9119183">More...</a><br /></td></tr>
<tr class="separator:ae113078fec2203ef85f1c92bc9119183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015bdbf795f0a31cdecfbe5f0ac7352d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a015bdbf795f0a31cdecfbe5f0ac7352d">MergeSingleJoyAsDualJoy</a> (const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;id1, const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;id2) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a015bdbf795f0a31cdecfbe5f0ac7352d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two Npads with single-mode assignments into one Npad with a dual-mode assignment.  <a href="namespacenn_1_1hid.html#a015bdbf795f0a31cdecfbe5f0ac7352d">More...</a><br /></td></tr>
<tr class="separator:a015bdbf795f0a31cdecfbe5f0ac7352d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de41955f2db9e18f6540bed6f3b817d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a5de41955f2db9e18f6540bed6f3b817d">SwapNpadAssignment</a> (const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;id1, const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;id2) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5de41955f2db9e18f6540bed6f3b817d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the correspondence relationships between physical controllers for the two specified Npads.  <a href="namespacenn_1_1hid.html#a5de41955f2db9e18f6540bed6f3b817d">More...</a><br /></td></tr>
<tr class="separator:a5de41955f2db9e18f6540bed6f3b817d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa86cd44eeb23fb774cb5e02c13f2806"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#afa86cd44eeb23fb774cb5e02c13f2806">SetNpadJoyHoldType</a> (<a class="el" href="namespacenn_1_1hid.html#af526a8dbb614b2703ab26245ec37e15f">NpadJoyHoldType</a> holdType) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:afa86cd44eeb23fb774cb5e02c13f2806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets how the Joy-Con is held.  <a href="namespacenn_1_1hid.html#afa86cd44eeb23fb774cb5e02c13f2806">More...</a><br /></td></tr>
<tr class="separator:afa86cd44eeb23fb774cb5e02c13f2806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6c57b5c5f8ec786e6faa020d78e80f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1hid.html#af526a8dbb614b2703ab26245ec37e15f">NpadJoyHoldType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a1a6c57b5c5f8ec786e6faa020d78e80f">GetNpadJoyHoldType</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1a6c57b5c5f8ec786e6faa020d78e80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets how the Joy-Con is to be held.  <a href="namespacenn_1_1hid.html#a1a6c57b5c5f8ec786e6faa020d78e80f">More...</a><br /></td></tr>
<tr class="separator:a1a6c57b5c5f8ec786e6faa020d78e80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65445d99babe7d9e04edf2549c3566da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a65445d99babe7d9e04edf2549c3566da">StartLrAssignmentMode</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a65445d99babe7d9e04edf2549c3566da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the play style mode assigned by pressing the L/R Buttons on the Joy-Con.  <a href="namespacenn_1_1hid.html#a65445d99babe7d9e04edf2549c3566da">More...</a><br /></td></tr>
<tr class="separator:a65445d99babe7d9e04edf2549c3566da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6126d152a247c33c99eabaa855dfc003"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a6126d152a247c33c99eabaa855dfc003">StopLrAssignmentMode</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6126d152a247c33c99eabaa855dfc003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends the play style mode assigned by pressing the L/R Buttons on the Joy-Con.  <a href="namespacenn_1_1hid.html#a6126d152a247c33c99eabaa855dfc003">More...</a><br /></td></tr>
<tr class="separator:a6126d152a247c33c99eabaa855dfc003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd929ea5f6df5670afdfcfc0526b722"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a7bd929ea5f6df5670afdfcfc0526b722">SetNpadHandheldActivationMode</a> (<a class="el" href="namespacenn_1_1hid.html#afc8f966eb92ca5f66ead837bdc6874a2">NpadHandheldActivationMode</a> mode) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7bd929ea5f6df5670afdfcfc0526b722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the mode that activates the handheld play style.  <a href="namespacenn_1_1hid.html#a7bd929ea5f6df5670afdfcfc0526b722">More...</a><br /></td></tr>
<tr class="separator:a7bd929ea5f6df5670afdfcfc0526b722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d64a58959c22c6eca2ce1bfbbc38ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1hid.html#afc8f966eb92ca5f66ead837bdc6874a2">NpadHandheldActivationMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#ad4d64a58959c22c6eca2ce1bfbbc38ec">GetNpadHandheldActivationMode</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad4d64a58959c22c6eca2ce1bfbbc38ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the mode for recognizing the handheld play style.  <a href="namespacenn_1_1hid.html#ad4d64a58959c22c6eca2ce1bfbbc38ec">More...</a><br /></td></tr>
<tr class="separator:ad4d64a58959c22c6eca2ce1bfbbc38ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d6abc7a61a72700f392ef41147baa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a51d6abc7a61a72700f392ef41147baa6">SetNpadCommunicationMode</a> (<a class="el" href="namespacenn_1_1hid.html#ab802029f44fe9e63041973e712793440">NpadCommunicationMode</a> mode) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a51d6abc7a61a72700f392ef41147baa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Joy-Con communication mode.  <a href="namespacenn_1_1hid.html#a51d6abc7a61a72700f392ef41147baa6">More...</a><br /></td></tr>
<tr class="separator:a51d6abc7a61a72700f392ef41147baa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5bf7e8e7547dd662a4d3c781f38020"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1hid.html#ab802029f44fe9e63041973e712793440">NpadCommunicationMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a2a5bf7e8e7547dd662a4d3c781f38020">GetNpadCommunicationMode</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2a5bf7e8e7547dd662a4d3c781f38020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Joy-Con communication mode.  <a href="namespacenn_1_1hid.html#a2a5bf7e8e7547dd662a4d3c781f38020">More...</a><br /></td></tr>
<tr class="separator:a2a5bf7e8e7547dd662a4d3c781f38020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">API for Each Npad Play Style</div></td></tr>
<tr class="memitem:a72482366735ada22d2f7b9f167795bd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a72482366735ada22d2f7b9f167795bd4">GetNpadState</a> (<a class="el" href="structnn_1_1hid_1_1_npad_joy_dual_state.html">NpadJoyDualState</a> *pOutValue, const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;id) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a72482366735ada22d2f7b9f167795bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the latest input state for the <code>NpadStyleJoyDual</code> Npad Joy-Con dual mode.  <a href="namespacenn_1_1hid.html#a72482366735ada22d2f7b9f167795bd4">More...</a><br /></td></tr>
<tr class="separator:a72482366735ada22d2f7b9f167795bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c0d887c001211eb9f6d4a2467602d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#ae2c0d887c001211eb9f6d4a2467602d8">GetNpadStates</a> (<a class="el" href="structnn_1_1hid_1_1_npad_joy_dual_state.html">NpadJoyDualState</a> *pOutValues, int count, const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;id) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae2c0d887c001211eb9f6d4a2467602d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the past input states of the Npad Joy-Con in dual-control mode, <code>NpadStyleJoyDual</code>.  <a href="namespacenn_1_1hid.html#ae2c0d887c001211eb9f6d4a2467602d8">More...</a><br /></td></tr>
<tr class="separator:ae2c0d887c001211eb9f6d4a2467602d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54af9ad4d0e39210123e80f1f5148f22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a54af9ad4d0e39210123e80f1f5148f22">GetNpadState</a> (<a class="el" href="structnn_1_1hid_1_1_npad_joy_left_state.html">NpadJoyLeftState</a> *pOutValue, const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;id) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a54af9ad4d0e39210123e80f1f5148f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the input states for the <code>NpadStyleJoyLeft</code> play style modeled on the Npad Joy-Con (L) controller.  <a href="namespacenn_1_1hid.html#a54af9ad4d0e39210123e80f1f5148f22">More...</a><br /></td></tr>
<tr class="separator:a54af9ad4d0e39210123e80f1f5148f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10fb0b09f9618c2b1b53cc756e60f3f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a10fb0b09f9618c2b1b53cc756e60f3f3">GetNpadStates</a> (<a class="el" href="structnn_1_1hid_1_1_npad_joy_left_state.html">NpadJoyLeftState</a> *pOutValues, int count, const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;id) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a10fb0b09f9618c2b1b53cc756e60f3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the past input states for the <code>NpadStyleJoyLeft</code> play style, modeled on the use of the Npad Joy-Con (L) controller.  <a href="namespacenn_1_1hid.html#a10fb0b09f9618c2b1b53cc756e60f3f3">More...</a><br /></td></tr>
<tr class="separator:a10fb0b09f9618c2b1b53cc756e60f3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7f1760184c1b250816ba2d7d64d92f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a4b7f1760184c1b250816ba2d7d64d92f">GetNpadState</a> (<a class="el" href="structnn_1_1hid_1_1_npad_joy_right_state.html">NpadJoyRightState</a> *pOutValue, const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;id) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4b7f1760184c1b250816ba2d7d64d92f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the input states for the <code>NpadStyleJoyRight</code> play style modeled on the Npad Joy-Con (R) controller.  <a href="namespacenn_1_1hid.html#a4b7f1760184c1b250816ba2d7d64d92f">More...</a><br /></td></tr>
<tr class="separator:a4b7f1760184c1b250816ba2d7d64d92f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8041ed4f7b45739c40a32f02f3889459"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a8041ed4f7b45739c40a32f02f3889459">GetNpadStates</a> (<a class="el" href="structnn_1_1hid_1_1_npad_joy_right_state.html">NpadJoyRightState</a> *pOutValues, int count, const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;id) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8041ed4f7b45739c40a32f02f3889459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the past input states for the <code>NpadStyleJoyRight</code> play style, modeled on the use of the Npad Joy-Con (R) controller.  <a href="namespacenn_1_1hid.html#a8041ed4f7b45739c40a32f02f3889459">More...</a><br /></td></tr>
<tr class="separator:a8041ed4f7b45739c40a32f02f3889459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">API for the Six-Axis Sensor</div></td></tr>
<tr class="memitem:a1afbbfec7a9390e95451faaaa0c43f0b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a1afbbfec7a9390e95451faaaa0c43f0b">GetSixAxisSensorHandles</a> (<a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_handle.html">SixAxisSensorHandle</a> *pOutValues, int count, const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;id, <a class="el" href="namespacenn_1_1hid.html#ace65233620edda5185ed73112ca9805f">NpadStyleSet</a> style) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1afbbfec7a9390e95451faaaa0c43f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the six-axis sensor's handles.  <a href="namespacenn_1_1hid.html#a1afbbfec7a9390e95451faaaa0c43f0b">More...</a><br /></td></tr>
<tr class="separator:a1afbbfec7a9390e95451faaaa0c43f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9ed9cc3e5b674c40cbf08a93ebdb62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a3a9ed9cc3e5b674c40cbf08a93ebdb62">StartSixAxisSensor</a> (const <a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_handle.html">SixAxisSensorHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3a9ed9cc3e5b674c40cbf08a93ebdb62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts sampling for <code>SixAxisSensor</code>.  <a href="namespacenn_1_1hid.html#a3a9ed9cc3e5b674c40cbf08a93ebdb62">More...</a><br /></td></tr>
<tr class="separator:a3a9ed9cc3e5b674c40cbf08a93ebdb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58870d9163a3be00cefe3ad6bb8e1852"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a58870d9163a3be00cefe3ad6bb8e1852">StopSixAxisSensor</a> (const <a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_handle.html">SixAxisSensorHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a58870d9163a3be00cefe3ad6bb8e1852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops sampling for <code>SixAxisSensor</code>.  <a href="namespacenn_1_1hid.html#a58870d9163a3be00cefe3ad6bb8e1852">More...</a><br /></td></tr>
<tr class="separator:a58870d9163a3be00cefe3ad6bb8e1852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3146b6ef32e7228a5580833a41f4e3fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a3146b6ef32e7228a5580833a41f4e3fd">IsSixAxisSensorAtRest</a> (const <a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_handle.html">SixAxisSensorHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3146b6ef32e7228a5580833a41f4e3fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether <code>SixAxisSensor</code> is in a static state.  <a href="namespacenn_1_1hid.html#a3146b6ef32e7228a5580833a41f4e3fd">More...</a><br /></td></tr>
<tr class="separator:a3146b6ef32e7228a5580833a41f4e3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fb413f442f5c150025765fd6c2cfb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#ae3fb413f442f5c150025765fd6c2cfb8">GetSixAxisSensorState</a> (<a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_state.html">SixAxisSensorState</a> *outValue, const <a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_handle.html">SixAxisSensorHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae3fb413f442f5c150025765fd6c2cfb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the latest input state of <code>SixAxisSensor</code>.  <a href="namespacenn_1_1hid.html#ae3fb413f442f5c150025765fd6c2cfb8">More...</a><br /></td></tr>
<tr class="separator:ae3fb413f442f5c150025765fd6c2cfb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398156ef7f9aa6f9e7478f08260d88ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a398156ef7f9aa6f9e7478f08260d88ff">GetSixAxisSensorStates</a> (<a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_state.html">SixAxisSensorState</a> *outStates, int count, const <a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_handle.html">SixAxisSensorHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a398156ef7f9aa6f9e7478f08260d88ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads past <code>SixAxisSensor</code> input states.  <a href="namespacenn_1_1hid.html#a398156ef7f9aa6f9e7478f08260d88ff">More...</a><br /></td></tr>
<tr class="separator:a398156ef7f9aa6f9e7478f08260d88ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">API Resources for the Six-Axis Sensor Settings</div></td></tr>
<tr class="memitem:a293f527cb0b15c746bccffe5917090c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a293f527cb0b15c746bccffe5917090c4">IsSixAxisSensorFusionEnabled</a> (const <a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_handle.html">SixAxisSensorHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a293f527cb0b15c746bccffe5917090c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the state of acceleration-based attitude correction for <code>SixAxisSensor</code>.  <a href="namespacenn_1_1hid.html#a293f527cb0b15c746bccffe5917090c4">More...</a><br /></td></tr>
<tr class="separator:a293f527cb0b15c746bccffe5917090c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1dda2cd885dd5a7150b9d2af10f981"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a7b1dda2cd885dd5a7150b9d2af10f981">EnableSixAxisSensorFusion</a> (const <a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_handle.html">SixAxisSensorHandle</a> &amp;handle, bool enable) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7b1dda2cd885dd5a7150b9d2af10f981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls the state of acceleration-based attitude correction for <code>SixAxisSensor</code>.  <a href="namespacenn_1_1hid.html#a7b1dda2cd885dd5a7150b9d2af10f981">More...</a><br /></td></tr>
<tr class="separator:a7b1dda2cd885dd5a7150b9d2af10f981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f5322f824e3899b7208971bfc643f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#ac3f5322f824e3899b7208971bfc643f3">SetSixAxisSensorFusionParameters</a> (const <a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_handle.html">SixAxisSensorHandle</a> &amp;handle, float revisePower, float reviseRange) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac3f5322f824e3899b7208971bfc643f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the parameter for acceleration-based attitude correction for <code>SixAxisSensor</code>.  <a href="namespacenn_1_1hid.html#ac3f5322f824e3899b7208971bfc643f3">More...</a><br /></td></tr>
<tr class="separator:ac3f5322f824e3899b7208971bfc643f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde39e3ce70d7cecb4b12a2a2a2c2e4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#acde39e3ce70d7cecb4b12a2a2a2c2e4e">GetSixAxisSensorFusionParameters</a> (float *pOutRevisePower, float *pOutReviseRange, const <a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_handle.html">SixAxisSensorHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acde39e3ce70d7cecb4b12a2a2a2c2e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the parameter for acceleration-based attitude correction for <code>SixAxisSensor</code>.  <a href="namespacenn_1_1hid.html#acde39e3ce70d7cecb4b12a2a2a2c2e4e">More...</a><br /></td></tr>
<tr class="separator:acde39e3ce70d7cecb4b12a2a2a2c2e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4fce71b7b6c3ec2d13006ce130d48f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#acc4fce71b7b6c3ec2d13006ce130d48f">ResetSixAxisSensorFusionParameters</a> (const <a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_handle.html">SixAxisSensorHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acc4fce71b7b6c3ec2d13006ce130d48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the parameter for acceleration-based attitude correction for <code>SixAxisSensor</code>.  <a href="namespacenn_1_1hid.html#acc4fce71b7b6c3ec2d13006ce130d48f">More...</a><br /></td></tr>
<tr class="separator:acc4fce71b7b6c3ec2d13006ce130d48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca693a8a8e3c544c5a21a3dc7c10578"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#abca693a8a8e3c544c5a21a3dc7c10578">SetGyroscopeZeroDriftMode</a> (const <a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_handle.html">SixAxisSensorHandle</a> &amp;handle, const <a class="el" href="namespacenn_1_1hid.html#afcc5c782bfc4ce2b5982eacb91fdf5e0">GyroscopeZeroDriftMode</a> &amp;mode) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:abca693a8a8e3c544c5a21a3dc7c10578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the zero point correction mode for the gyro sensors.  <a href="namespacenn_1_1hid.html#abca693a8a8e3c544c5a21a3dc7c10578">More...</a><br /></td></tr>
<tr class="separator:abca693a8a8e3c544c5a21a3dc7c10578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5af8879cf9c457fa309fd750a6ab03f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1hid.html#afcc5c782bfc4ce2b5982eacb91fdf5e0">GyroscopeZeroDriftMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#ab5af8879cf9c457fa309fd750a6ab03f">GetGyroscopeZeroDriftMode</a> (const <a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_handle.html">SixAxisSensorHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab5af8879cf9c457fa309fd750a6ab03f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the zero point correction mode for the gyro sensors.  <a href="namespacenn_1_1hid.html#ab5af8879cf9c457fa309fd750a6ab03f">More...</a><br /></td></tr>
<tr class="separator:ab5af8879cf9c457fa309fd750a6ab03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0befba6622513777932715e67449a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#acc0befba6622513777932715e67449a3">IsFirmwareUpdateAvailableForSixAxisSensor</a> (const <a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_handle.html">SixAxisSensorHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acc0befba6622513777932715e67449a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether there is a firmware update available to improve the performance of the six-axis sensor.  <a href="namespacenn_1_1hid.html#acc0befba6622513777932715e67449a3">More...</a><br /></td></tr>
<tr class="separator:acc0befba6622513777932715e67449a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">TouchScreen API Resources</div></td></tr>
<tr class="memitem:a1d814d34915eac7cfc9b9f92ac3ccc40"><td class="memItemLeft" align="right" valign="top"><a id="a1d814d34915eac7cfc9b9f92ac3ccc40"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a1d814d34915eac7cfc9b9f92ac3ccc40">InitializeTouchScreen</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1d814d34915eac7cfc9b9f92ac3ccc40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the touch screen. <br /></td></tr>
<tr class="separator:a1d814d34915eac7cfc9b9f92ac3ccc40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8057a5f2f1aacdacc9b51dbaee418847"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:a8057a5f2f1aacdacc9b51dbaee418847"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a8057a5f2f1aacdacc9b51dbaee418847">GetTouchScreenState</a> (<a class="el" href="structnn_1_1hid_1_1_touch_screen_state.html">TouchScreenState</a>&lt; N &gt; *pOutValue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8057a5f2f1aacdacc9b51dbaee418847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the latest touch screen input state.  <a href="namespacenn_1_1hid.html#a8057a5f2f1aacdacc9b51dbaee418847">More...</a><br /></td></tr>
<tr class="separator:a8057a5f2f1aacdacc9b51dbaee418847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c328faac65ac47bec4b4cf6a2e1422"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:a25c328faac65ac47bec4b4cf6a2e1422"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a25c328faac65ac47bec4b4cf6a2e1422">GetTouchScreenStates</a> (<a class="el" href="structnn_1_1hid_1_1_touch_screen_state.html">TouchScreenState</a>&lt; N &gt; *outStates, int count) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a25c328faac65ac47bec4b4cf6a2e1422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads past touch screen input states.  <a href="namespacenn_1_1hid.html#a25c328faac65ac47bec4b4cf6a2e1422">More...</a><br /></td></tr>
<tr class="separator:a25c328faac65ac47bec4b4cf6a2e1422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions for controlling the vibration motor.</div></td></tr>
<tr class="memitem:a2950ca0147b2bbb09a2c34aeaf527ca2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a2950ca0147b2bbb09a2c34aeaf527ca2">GetVibrationDeviceHandles</a> (<a class="el" href="structnn_1_1hid_1_1_vibration_device_handle.html">VibrationDeviceHandle</a> *pOutValues, int count, const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;id, <a class="el" href="namespacenn_1_1hid.html#ace65233620edda5185ed73112ca9805f">NpadStyleSet</a> style) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2950ca0147b2bbb09a2c34aeaf527ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the handles for operating the vibration motor built into the Npads.  <a href="namespacenn_1_1hid.html#a2950ca0147b2bbb09a2c34aeaf527ca2">More...</a><br /></td></tr>
<tr class="separator:a2950ca0147b2bbb09a2c34aeaf527ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51427fb3bfd53f3a8784a868a020f23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#aa51427fb3bfd53f3a8784a868a020f23">GetVibrationDeviceInfo</a> (<a class="el" href="structnn_1_1hid_1_1_vibration_device_info.html">VibrationDeviceInfo</a> *pOutValue, const <a class="el" href="structnn_1_1hid_1_1_vibration_device_handle.html">VibrationDeviceHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa51427fb3bfd53f3a8784a868a020f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets vibration motor information.  <a href="namespacenn_1_1hid.html#aa51427fb3bfd53f3a8784a868a020f23">More...</a><br /></td></tr>
<tr class="separator:aa51427fb3bfd53f3a8784a868a020f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af610eb6d705297bd91c56825b39383bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#af610eb6d705297bd91c56825b39383bf">InitializeVibrationDevice</a> (const <a class="el" href="structnn_1_1hid_1_1_vibration_device_handle.html">VibrationDeviceHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af610eb6d705297bd91c56825b39383bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the vibration motor.  <a href="namespacenn_1_1hid.html#af610eb6d705297bd91c56825b39383bf">More...</a><br /></td></tr>
<tr class="separator:af610eb6d705297bd91c56825b39383bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2935e350eab46cc13a4e9d33c61ef9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#adc2935e350eab46cc13a4e9d33c61ef9">SendVibrationValue</a> (const <a class="el" href="structnn_1_1hid_1_1_vibration_device_handle.html">VibrationDeviceHandle</a> &amp;handle, const <a class="el" href="structnn_1_1hid_1_1_vibration_value.html">VibrationValue</a> &amp;value) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:adc2935e350eab46cc13a4e9d33c61ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the vibration value to the vibration motor.  <a href="namespacenn_1_1hid.html#adc2935e350eab46cc13a4e9d33c61ef9">More...</a><br /></td></tr>
<tr class="separator:adc2935e350eab46cc13a4e9d33c61ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb585205dac5c49b24bf045b8796307"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a2fb585205dac5c49b24bf045b8796307">GetActualVibrationValue</a> (<a class="el" href="structnn_1_1hid_1_1_vibration_value.html">VibrationValue</a> *pOutValue, const <a class="el" href="structnn_1_1hid_1_1_vibration_device_handle.html">VibrationDeviceHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2fb585205dac5c49b24bf045b8796307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the actual vibration values occurring on the vibration motor.  <a href="namespacenn_1_1hid.html#a2fb585205dac5c49b24bf045b8796307">More...</a><br /></td></tr>
<tr class="separator:a2fb585205dac5c49b24bf045b8796307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions for Vibration Feature Settings</div></td></tr>
<tr class="memitem:a19b2160770d0185f4056ef76cac27976"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a19b2160770d0185f4056ef76cac27976">IsVibrationPermitted</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a19b2160770d0185f4056ef76cac27976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the vibration feature is enabled in the system settings.  <a href="namespacenn_1_1hid.html#a19b2160770d0185f4056ef76cac27976">More...</a><br /></td></tr>
<tr class="separator:a19b2160770d0185f4056ef76cac27976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Vibration Files API</div></td></tr>
<tr class="memitem:a7d0be2e26c8283bf479ec142133c81e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a7d0be2e26c8283bf479ec142133c81e2">ParseVibrationFile</a> (<a class="el" href="structnn_1_1hid_1_1_vibration_file_info.html">VibrationFileInfo</a> *pOutInfo, <a class="el" href="structnn_1_1hid_1_1_vibration_file_parser_context.html">VibrationFileParserContext</a> *pOutContext, const void *address, size_t fileSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7d0be2e26c8283bf479ec142133c81e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the vibration file's binary data.  <a href="namespacenn_1_1hid.html#a7d0be2e26c8283bf479ec142133c81e2">More...</a><br /></td></tr>
<tr class="separator:a7d0be2e26c8283bf479ec142133c81e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c97eccdcb915afba12627b52c2e692"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a43c97eccdcb915afba12627b52c2e692">RetrieveVibrationValue</a> (<a class="el" href="structnn_1_1hid_1_1_vibration_value.html">VibrationValue</a> *pOutValue, int position, <a class="el" href="structnn_1_1hid_1_1_vibration_file_parser_context.html">VibrationFileParserContext</a> *pContext) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a43c97eccdcb915afba12627b52c2e692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vibration value from the vibration file.  <a href="namespacenn_1_1hid.html#a43c97eccdcb915afba12627b52c2e692">More...</a><br /></td></tr>
<tr class="separator:a43c97eccdcb915afba12627b52c2e692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2ee8289c45de4b0504d82007454537"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a8d2ee8289c45de4b0504d82007454537">GenerateVibrationFile</a> (size_t *pOutSize, void *outBuffer, size_t bufferSize, const <a class="el" href="structnn_1_1hid_1_1_vibration_value_array_info.html">VibrationValueArrayInfo</a> &amp;info, const <a class="el" href="structnn_1_1hid_1_1_vibration_value.html">VibrationValue</a> *pValues) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8d2ee8289c45de4b0504d82007454537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the vibration file binary data from the vibration value array, and stores it in the specified buffer.  <a href="namespacenn_1_1hid.html#a8d2ee8289c45de4b0504d82007454537">More...</a><br /></td></tr>
<tr class="separator:a8d2ee8289c45de4b0504d82007454537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad2cf3d5355249ec88c2ff3c93611b5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#abad2cf3d5355249ec88c2ff3c93611b5">CalculateVibrationFileSize</a> (const <a class="el" href="structnn_1_1hid_1_1_vibration_value_array_info.html">VibrationValueArrayInfo</a> &amp;info) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:abad2cf3d5355249ec88c2ff3c93611b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the vibration file generated from the vibration value array data.  <a href="namespacenn_1_1hid.html#abad2cf3d5355249ec88c2ff3c93611b5">More...</a><br /></td></tr>
<tr class="separator:abad2cf3d5355249ec88c2ff3c93611b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a87d16cb0d039a8f0f0476acd206adf46"><td class="memItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a87d16cb0d039a8f0f0476acd206adf46">AccelerometerMax</a> = 7.0f</td></tr>
<tr class="memdesc:a87d16cb0d039a8f0f0476acd206adf46"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum absolute value for the accelerometer.  <a href="namespacenn_1_1hid.html#a87d16cb0d039a8f0f0476acd206adf46">More...</a><br /></td></tr>
<tr class="separator:a87d16cb0d039a8f0f0476acd206adf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecbcfd620f445d9e77b0883229761326"><td class="memItemLeft" align="right" valign="top"><a id="aecbcfd620f445d9e77b0883229761326"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#aecbcfd620f445d9e77b0883229761326">AnalogStickMax</a> = 0x7fff</td></tr>
<tr class="memdesc:aecbcfd620f445d9e77b0883229761326"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum value of the control stick. <br /></td></tr>
<tr class="separator:aecbcfd620f445d9e77b0883229761326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9852ed5443cbe820a40b00322455f0"><td class="memItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#aed9852ed5443cbe820a40b00322455f0">AngularVelocityMax</a> = 5.0f</td></tr>
<tr class="memdesc:aed9852ed5443cbe820a40b00322455f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum absolute value for the gyroscope.  <a href="namespacenn_1_1hid.html#aed9852ed5443cbe820a40b00322455f0">More...</a><br /></td></tr>
<tr class="separator:aed9852ed5443cbe820a40b00322455f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab138f06596ba10303a4c339610572764"><td class="memItemLeft" align="right" valign="top"><a id="ab138f06596ba10303a4c339610572764"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#ab138f06596ba10303a4c339610572764">DebugPadStateCountMax</a> = 16</td></tr>
<tr class="memdesc:ab138f06596ba10303a4c339610572764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of DebugPad input states held internally. <br /></td></tr>
<tr class="separator:ab138f06596ba10303a4c339610572764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b962357fe4725eefa5820deab01af5f"><td class="memItemLeft" align="right" valign="top"><a id="a5b962357fe4725eefa5820deab01af5f"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a5b962357fe4725eefa5820deab01af5f">DigitizerStateCountMax</a> = 16</td></tr>
<tr class="memdesc:a5b962357fe4725eefa5820deab01af5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of internally held digitizer input states. <br /></td></tr>
<tr class="separator:a5b962357fe4725eefa5820deab01af5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af6058ea35cfddd9d8fdeaf937a0449"><td class="memItemLeft" align="right" valign="top"><a id="a1af6058ea35cfddd9d8fdeaf937a0449"></a>
constexpr int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a1af6058ea35cfddd9d8fdeaf937a0449">ExplainTextMaxLength</a> = 32</td></tr>
<tr class="memdesc:a1af6058ea35cfddd9d8fdeaf937a0449"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of characters in the explanatory text for the individual controller numbers shown in the controller support UI. <br /></td></tr>
<tr class="separator:a1af6058ea35cfddd9d8fdeaf937a0449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818112c4083bdc1d032b2c00dde1b9fd"><td class="memItemLeft" align="right" valign="top"><a id="a818112c4083bdc1d032b2c00dde1b9fd"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a818112c4083bdc1d032b2c00dde1b9fd">GestureDirection_Down</a> = <a class="el" href="namespacenn_1_1hid.html#ae2fae4c1fdc6f4007776b6d58fa68949a08a38277b0309070706f6652eeae9a53">GestureDirection::Down</a></td></tr>
<tr class="memdesc:a818112c4083bdc1d032b2c00dde1b9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The gesture direction is Down (old format). <br /></td></tr>
<tr class="separator:a818112c4083bdc1d032b2c00dde1b9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000d557296ba30fb8cea2947548bbb25"><td class="memItemLeft" align="right" valign="top"><a id="a000d557296ba30fb8cea2947548bbb25"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a000d557296ba30fb8cea2947548bbb25">GestureDirection_Left</a> = <a class="el" href="namespacenn_1_1hid.html#ae2fae4c1fdc6f4007776b6d58fa68949a945d5e233cf7d6240f6b783b36a374ff">GestureDirection::Left</a></td></tr>
<tr class="memdesc:a000d557296ba30fb8cea2947548bbb25"><td class="mdescLeft">&#160;</td><td class="mdescRight">The gesture direction is Left (old format). <br /></td></tr>
<tr class="separator:a000d557296ba30fb8cea2947548bbb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8982b066c903535ef6f755c69c697f08"><td class="memItemLeft" align="right" valign="top"><a id="a8982b066c903535ef6f755c69c697f08"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a8982b066c903535ef6f755c69c697f08">GestureDirection_None</a> = <a class="el" href="namespacenn_1_1hid.html#ae2fae4c1fdc6f4007776b6d58fa68949a6adf97f83acf6453d4a6a4b1070f3754">GestureDirection::None</a></td></tr>
<tr class="memdesc:a8982b066c903535ef6f755c69c697f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">The gesture direction is None (old format). <br /></td></tr>
<tr class="separator:a8982b066c903535ef6f755c69c697f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d74d74b92133d248ad506067663c4e5"><td class="memItemLeft" align="right" valign="top"><a id="a3d74d74b92133d248ad506067663c4e5"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a3d74d74b92133d248ad506067663c4e5">GestureDirection_Right</a> = <a class="el" href="namespacenn_1_1hid.html#ae2fae4c1fdc6f4007776b6d58fa68949a92b09c7c48c520c3c55e497875da437c">GestureDirection::Right</a></td></tr>
<tr class="memdesc:a3d74d74b92133d248ad506067663c4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The gesture direction is Right (old format). <br /></td></tr>
<tr class="separator:a3d74d74b92133d248ad506067663c4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d3d5ad5af08be5435063921e3d4334"><td class="memItemLeft" align="right" valign="top"><a id="aa0d3d5ad5af08be5435063921e3d4334"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#aa0d3d5ad5af08be5435063921e3d4334">GestureDirection_Up</a> = <a class="el" href="namespacenn_1_1hid.html#ae2fae4c1fdc6f4007776b6d58fa68949a258f49887ef8d14ac268c92b02503aaa">GestureDirection::Up</a></td></tr>
<tr class="memdesc:aa0d3d5ad5af08be5435063921e3d4334"><td class="mdescLeft">&#160;</td><td class="mdescRight">The gesture direction is Up (old format). <br /></td></tr>
<tr class="separator:aa0d3d5ad5af08be5435063921e3d4334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b359fcc8ac54d79d838c14ac813c8d"><td class="memItemLeft" align="right" valign="top"><a id="a18b359fcc8ac54d79d838c14ac813c8d"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a18b359fcc8ac54d79d838c14ac813c8d">GesturePointCountMax</a> = 4</td></tr>
<tr class="memdesc:a18b359fcc8ac54d79d838c14ac813c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of points that comprise one gesture. <br /></td></tr>
<tr class="separator:a18b359fcc8ac54d79d838c14ac813c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b79de093540a8277a268f50c23d9d8"><td class="memItemLeft" align="right" valign="top"><a id="a24b79de093540a8277a268f50c23d9d8"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a24b79de093540a8277a268f50c23d9d8">GestureStateCountMax</a> = 16</td></tr>
<tr class="memdesc:a24b79de093540a8277a268f50c23d9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of gesture states maintained internally. <br /></td></tr>
<tr class="separator:a24b79de093540a8277a268f50c23d9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a947c582509b750ef35e5ab1cce184a"><td class="memItemLeft" align="right" valign="top"><a id="a6a947c582509b750ef35e5ab1cce184a"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a6a947c582509b750ef35e5ab1cce184a">GestureType_Cancel</a> = <a class="el" href="namespacenn_1_1hid.html#a258b0d78215e9aef289f8d784495159aaea4788705e6873b424c65e91c2846b19">GestureType::Cancel</a></td></tr>
<tr class="memdesc:a6a947c582509b750ef35e5ab1cce184a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The gesture type is Cancel (old format). <br /></td></tr>
<tr class="separator:a6a947c582509b750ef35e5ab1cce184a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d9bee96195f521380e35805be06862"><td class="memItemLeft" align="right" valign="top"><a id="a50d9bee96195f521380e35805be06862"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a50d9bee96195f521380e35805be06862">GestureType_Complete</a> = <a class="el" href="namespacenn_1_1hid.html#a258b0d78215e9aef289f8d784495159aaae94f80b3ce82062a5dd7815daa04f9d">GestureType::Complete</a></td></tr>
<tr class="memdesc:a50d9bee96195f521380e35805be06862"><td class="mdescLeft">&#160;</td><td class="mdescRight">The gesture type is Complete (old format). <br /></td></tr>
<tr class="separator:a50d9bee96195f521380e35805be06862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8670d5060f92f4da08f209ec902cfb3"><td class="memItemLeft" align="right" valign="top"><a id="ac8670d5060f92f4da08f209ec902cfb3"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#ac8670d5060f92f4da08f209ec902cfb3">GestureType_Idle</a> = <a class="el" href="namespacenn_1_1hid.html#a258b0d78215e9aef289f8d784495159aae599161956d626eda4cb0a5ffb85271c">GestureType::Idle</a></td></tr>
<tr class="memdesc:ac8670d5060f92f4da08f209ec902cfb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The gesture type is Idle (old format). <br /></td></tr>
<tr class="separator:ac8670d5060f92f4da08f209ec902cfb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c90270017c04d9c070842087315b52"><td class="memItemLeft" align="right" valign="top"><a id="a26c90270017c04d9c070842087315b52"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a26c90270017c04d9c070842087315b52">GestureType_Pan</a> = <a class="el" href="namespacenn_1_1hid.html#a258b0d78215e9aef289f8d784495159aaf6d4a17b27da35c2d90ce13801f36782">GestureType::Pan</a></td></tr>
<tr class="memdesc:a26c90270017c04d9c070842087315b52"><td class="mdescLeft">&#160;</td><td class="mdescRight">The gesture type is Pan (old format). <br /></td></tr>
<tr class="separator:a26c90270017c04d9c070842087315b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b243910d7f1a014b2f791dbd0ad1de"><td class="memItemLeft" align="right" valign="top"><a id="a42b243910d7f1a014b2f791dbd0ad1de"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a42b243910d7f1a014b2f791dbd0ad1de">GestureType_Pinch</a> = <a class="el" href="namespacenn_1_1hid.html#a258b0d78215e9aef289f8d784495159aa1e4ddf6f135e4c639929b4633c29d4f2">GestureType::Pinch</a></td></tr>
<tr class="memdesc:a42b243910d7f1a014b2f791dbd0ad1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">The gesture type is Pinch (old format). <br /></td></tr>
<tr class="separator:a42b243910d7f1a014b2f791dbd0ad1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf21333eaec33d99afb46a398d9787a9"><td class="memItemLeft" align="right" valign="top"><a id="adf21333eaec33d99afb46a398d9787a9"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#adf21333eaec33d99afb46a398d9787a9">GestureType_Press</a> = <a class="el" href="namespacenn_1_1hid.html#a258b0d78215e9aef289f8d784495159aa0610123bdd4ffc191a3ea05a847e1307">GestureType::Press</a></td></tr>
<tr class="memdesc:adf21333eaec33d99afb46a398d9787a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The gesture type is long Press (old format). <br /></td></tr>
<tr class="separator:adf21333eaec33d99afb46a398d9787a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5009a0b0107567e3c5cf3ba9d6a660c"><td class="memItemLeft" align="right" valign="top"><a id="ae5009a0b0107567e3c5cf3ba9d6a660c"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#ae5009a0b0107567e3c5cf3ba9d6a660c">GestureType_Rotate</a> = <a class="el" href="namespacenn_1_1hid.html#a258b0d78215e9aef289f8d784495159aa8d2de5368588552fbae54044ac5c7b3d">GestureType::Rotate</a></td></tr>
<tr class="memdesc:ae5009a0b0107567e3c5cf3ba9d6a660c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The gesture type is Rotate (old format). <br /></td></tr>
<tr class="separator:ae5009a0b0107567e3c5cf3ba9d6a660c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb0fd4f060b8930159d520b9b59ef1b"><td class="memItemLeft" align="right" valign="top"><a id="a5cb0fd4f060b8930159d520b9b59ef1b"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a5cb0fd4f060b8930159d520b9b59ef1b">GestureType_Swipe</a> = <a class="el" href="namespacenn_1_1hid.html#a258b0d78215e9aef289f8d784495159aa78076ce792c4640bf99c598c92bd69e7">GestureType::Swipe</a></td></tr>
<tr class="memdesc:a5cb0fd4f060b8930159d520b9b59ef1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The gesture type is Swipe (old format). <br /></td></tr>
<tr class="separator:a5cb0fd4f060b8930159d520b9b59ef1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15b8e5bc9564ef6314344e2366ca83f"><td class="memItemLeft" align="right" valign="top"><a id="ac15b8e5bc9564ef6314344e2366ca83f"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#ac15b8e5bc9564ef6314344e2366ca83f">GestureType_Tap</a> = <a class="el" href="namespacenn_1_1hid.html#a258b0d78215e9aef289f8d784495159aa73cf2f244bc0cb0d205b99c04fa13978">GestureType::Tap</a></td></tr>
<tr class="memdesc:ac15b8e5bc9564ef6314344e2366ca83f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The gesture type is Tap (old format). <br /></td></tr>
<tr class="separator:ac15b8e5bc9564ef6314344e2366ca83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7230c4480c43a3f283fed3bad8994c14"><td class="memItemLeft" align="right" valign="top"><a id="a7230c4480c43a3f283fed3bad8994c14"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a7230c4480c43a3f283fed3bad8994c14">GestureType_Touch</a> = <a class="el" href="namespacenn_1_1hid.html#a258b0d78215e9aef289f8d784495159aaf0f31c9700c6b10d8a20dc487b2ae6a8">GestureType::Touch</a></td></tr>
<tr class="memdesc:a7230c4480c43a3f283fed3bad8994c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">The gesture type is Touch (old format). <br /></td></tr>
<tr class="separator:a7230c4480c43a3f283fed3bad8994c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6ae8561ca58186c23d31dbc6eb0004"><td class="memItemLeft" align="right" valign="top"><a id="aec6ae8561ca58186c23d31dbc6eb0004"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#aec6ae8561ca58186c23d31dbc6eb0004">KeyboardStateCountMax</a> = 16</td></tr>
<tr class="memdesc:aec6ae8561ca58186c23d31dbc6eb0004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of keyboard input states held internally. <br /></td></tr>
<tr class="separator:aec6ae8561ca58186c23d31dbc6eb0004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadbf2953432220ae3420da5e621d95b"><td class="memItemLeft" align="right" valign="top"><a id="adadbf2953432220ae3420da5e621d95b"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#adadbf2953432220ae3420da5e621d95b">MouseStateCountMax</a> = 16</td></tr>
<tr class="memdesc:adadbf2953432220ae3420da5e621d95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of <code>Mouse</code> input states held internally. <br /></td></tr>
<tr class="separator:adadbf2953432220ae3420da5e621d95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdcd232368e229046b7341c30b0fa6f"><td class="memItemLeft" align="right" valign="top"><a id="a0cdcd232368e229046b7341c30b0fa6f"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a0cdcd232368e229046b7341c30b0fa6f">NpadSixAxisSensorHandleCountMax</a> = 8</td></tr>
<tr class="memdesc:a0cdcd232368e229046b7341c30b0fa6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of <code><a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_handle.html" title="Structure representing the handle for the six-axis sensor.">SixAxisSensorHandle</a></code> handles that can be obtained from the Npad. <br /></td></tr>
<tr class="separator:a0cdcd232368e229046b7341c30b0fa6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80d5949e5e28f82067ae4d9d0e14aca"><td class="memItemLeft" align="right" valign="top"><a id="ae80d5949e5e28f82067ae4d9d0e14aca"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#ae80d5949e5e28f82067ae4d9d0e14aca">NpadStateCountMax</a> = 16</td></tr>
<tr class="memdesc:ae80d5949e5e28f82067ae4d9d0e14aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of Npad input states held internally. <br /></td></tr>
<tr class="separator:ae80d5949e5e28f82067ae4d9d0e14aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a9a791e140caca11257e5a1a33b286"><td class="memItemLeft" align="right" valign="top"><a id="a80a9a791e140caca11257e5a1a33b286"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a80a9a791e140caca11257e5a1a33b286">SixAxisSensorStateCountMax</a> = 16</td></tr>
<tr class="memdesc:a80a9a791e140caca11257e5a1a33b286"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of <code><a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_state.html" title="Structure representing the state obtained from the six-axis sensor.">SixAxisSensorState</a></code> structures maintained internally. <br /></td></tr>
<tr class="separator:a80a9a791e140caca11257e5a1a33b286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db16ac9c181d3161217197457a165a9"><td class="memItemLeft" align="right" valign="top"><a id="a7db16ac9c181d3161217197457a165a9"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a7db16ac9c181d3161217197457a165a9">TouchScreenStateCountMax</a> = 16</td></tr>
<tr class="memdesc:a7db16ac9c181d3161217197457a165a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of touch screen input states held internally. <br /></td></tr>
<tr class="separator:a7db16ac9c181d3161217197457a165a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57dc264ce1e69e6a8b8091ce9e57b6f"><td class="memItemLeft" align="right" valign="top"><a id="aa57dc264ce1e69e6a8b8091ce9e57b6f"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#aa57dc264ce1e69e6a8b8091ce9e57b6f">TouchStateCountMax</a> = 16</td></tr>
<tr class="memdesc:aa57dc264ce1e69e6a8b8091ce9e57b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of touches. <br /></td></tr>
<tr class="separator:aa57dc264ce1e69e6a8b8091ce9e57b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a922d2e30dc5f92ea6fdd0b342852a"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#a91a922d2e30dc5f92ea6fdd0b342852a">VibrationFrequencyHighDefault</a> = 320</td></tr>
<tr class="memdesc:a91a922d2e30dc5f92ea6fdd0b342852a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default frequency for high bandwidths.  <a href="namespacenn_1_1hid.html#a91a922d2e30dc5f92ea6fdd0b342852a">More...</a><br /></td></tr>
<tr class="separator:a91a922d2e30dc5f92ea6fdd0b342852a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bd32faec2ea80f5a64515ae6ebabfd"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1hid.html#ab9bd32faec2ea80f5a64515ae6ebabfd">VibrationFrequencyLowDefault</a> = 160</td></tr>
<tr class="memdesc:ab9bd32faec2ea80f5a64515ae6ebabfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default frequency for low bandwidths.  <a href="namespacenn_1_1hid.html#ab9bd32faec2ea80f5a64515ae6ebabfd">More...</a><br /></td></tr>
<tr class="separator:ab9bd32faec2ea80f5a64515ae6ebabfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for human interface devices. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a1528b4e8a2b39e40f5f76c847c4ccc82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1528b4e8a2b39e40f5f76c847c4ccc82">&#9670;&nbsp;</a></span>NpadStyleJoyDual</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ::<a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">nn::util::BitFlagSet</a>&lt;32, NpadStyleTag&gt;::Flag&lt;2&gt; <a class="el" href="namespacenn_1_1hid.html#a1528b4e8a2b39e40f5f76c847c4ccc82">nn::hid::NpadStyleJoyDual</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition of a play style modeled on holding two Joy-Con controllers. </p>
<p> <b>Details</b> <br  />
 To enable this play style, use the <code><a class="el" href="namespacenn_1_1hid.html#ae113078fec2203ef85f1c92bc9119183" title="Changes the Joy-Con assignment mode for the Npad to dual mode.">nn::hid::SetNpadJoyAssignmentModeDual()</a></code> function to change the Joy-Con assignment to dual-controller grip. If the only play styles that are enabled are those assuming dual-controller grip, such as <code><a class="el" href="namespacenn_1_1hid.html#a1528b4e8a2b39e40f5f76c847c4ccc82" title="Definition of a play style modeled on holding two Joy-Con controllers.">nn::hid::NpadStyleJoyDual</a></code> or <code>nn::hid::NpadStyleFullkey</code>, the Joy-Con assignment state for the Npad will automatically be dual-controller grip (<a class="el" href="namespacenn_1_1hid.html#a6c4b0ecdaa297bb33e65d46b2f350546a14b223c9a0a1d5d9eb26a03b68e7c3a8" title="The Joy-Con pair of controllers are assigned to a single Npad.">nn::hid::NpadJoyAssignmentMode_Dual</a>).</p>
<p>For example, in the state where a Joy-Con is assigned to the Npad as a single-controller grip in the Reconnect screen of the HOME Menu, transitioning to an application that supports dual-controller grip disconnects the single-controller grip Joy-Con.</p>
<p>If you want to prevent the controller from being disconnected in cases like that, enable <code><a class="el" href="namespacenn_1_1hid.html#a93f2c921b3f4d3a9b8e02ddc30ea50b8" title="Definition of a play style modeled on the Joy-Con (L).">nn::hid::NpadStyleJoyLeft</a></code> and <code><a class="el" href="namespacenn_1_1hid.html#aa09597ee31314ec6782e5f56384ea5b9" title="Definition of a play style modeled on the Joy-Con (R).">nn::hid::NpadStyleJoyRight</a></code>, and use the <code><a class="el" href="namespacenn_1_1hid.html#ae113078fec2203ef85f1c92bc9119183" title="Changes the Joy-Con assignment mode for the Npad to dual mode.">nn::hid::SetNpadJoyAssignmentModeDual()</a></code> function to change the single-controller grip Joy-Con to dual-controller grip. </p>

</div>
</div>
<a id="a93f2c921b3f4d3a9b8e02ddc30ea50b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f2c921b3f4d3a9b8e02ddc30ea50b8">&#9670;&nbsp;</a></span>NpadStyleJoyLeft</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ::<a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">nn::util::BitFlagSet</a>&lt;32, NpadStyleTag&gt;::Flag&lt;3&gt; <a class="el" href="namespacenn_1_1hid.html#a93f2c921b3f4d3a9b8e02ddc30ea50b8">nn::hid::NpadStyleJoyLeft</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition of a play style modeled on the Joy-Con (L). </p>
<p> <b>Details</b> <br  />
 This play style is modeled on operations using only the Joy-Con (L). It treats the controller as a single-controller grip play style regardless of whether it is held vertically or horizontally. To enable this play style, use the <code><a class="el" href="namespacenn_1_1hid.html#ae113078fec2203ef85f1c92bc9119183" title="Changes the Joy-Con assignment mode for the Npad to dual mode.">nn::hid::SetNpadJoyAssignmentModeDual()</a></code> function to change the Joy-Con assignment to single-controller grip. If the only play styles that are enabled are those assuming single-controller grip, such as <code><a class="el" href="namespacenn_1_1hid.html#a93f2c921b3f4d3a9b8e02ddc30ea50b8" title="Definition of a play style modeled on the Joy-Con (L).">nn::hid::NpadStyleJoyLeft</a></code> or <code><a class="el" href="namespacenn_1_1hid.html#aa09597ee31314ec6782e5f56384ea5b9" title="Definition of a play style modeled on the Joy-Con (R).">nn::hid::NpadStyleJoyRight</a></code>, the Joy-Con assignment state for the Npad will automatically be single-controller grip (<code><a class="el" href="namespacenn_1_1hid.html#a6c4b0ecdaa297bb33e65d46b2f350546aa5c3821ed1fa09b77fb68d7930b20c08" title="Each Npad is assigned one of the Joy-Con pair of controllers.">nn::hid::NpadJoyAssignmentMode_Single</a></code>).</p>
<p>For the NX, if you only enable play styles that assume single-controller grip, such as <code><a class="el" href="namespacenn_1_1hid.html#a93f2c921b3f4d3a9b8e02ddc30ea50b8" title="Definition of a play style modeled on the Joy-Con (L).">nn::hid::NpadStyleJoyLeft</a></code> or <code><a class="el" href="namespacenn_1_1hid.html#aa09597ee31314ec6782e5f56384ea5b9" title="Definition of a play style modeled on the Joy-Con (R).">nn::hid::NpadStyleJoyRight</a></code>, the Joy-Cons assigned to the Npad in dual-controller grip are automatically disconnected.</p>
<p>For example, the Joy-Con is assigned to the Npad in dual-controller grip at the entrance screen immediately after waking from sleep mode or in the HOME Menu, and will be disconnected when returning to an application that only supports single-controller grip.</p>
<p>If you want to prevent the controller from being disconnected in cases like that, enable <code><a class="el" href="namespacenn_1_1hid.html#a1528b4e8a2b39e40f5f76c847c4ccc82" title="Definition of a play style modeled on holding two Joy-Con controllers.">nn::hid::NpadStyleJoyDual</a></code>, and use the <code><a class="el" href="namespacenn_1_1hid.html#a617f872f844f16873b925fe0669a898a" title="Changes the Npad&#39;s Joy-Con assignment mode to &quot;Single.&quot;.">nn::hid::SetNpadJoyAssignmentModeSingle()</a></code> function to change the dual-controller grip Joy-Con to single-controller grip. </p>

</div>
</div>
<a id="aa09597ee31314ec6782e5f56384ea5b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09597ee31314ec6782e5f56384ea5b9">&#9670;&nbsp;</a></span>NpadStyleJoyRight</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ::<a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">nn::util::BitFlagSet</a>&lt;32, NpadStyleTag&gt;::Flag&lt;4&gt; <a class="el" href="namespacenn_1_1hid.html#aa09597ee31314ec6782e5f56384ea5b9">nn::hid::NpadStyleJoyRight</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition of a play style modeled on the Joy-Con (R). </p>
<p> <b>Details</b> <br  />
 This play style is modeled on operations using only the Joy-Con (R). It treats the controller as a single-controller grip play style regardless of whether it is held vertically or horizontally. To enable this play style, use the <code><a class="el" href="namespacenn_1_1hid.html#ae113078fec2203ef85f1c92bc9119183" title="Changes the Joy-Con assignment mode for the Npad to dual mode.">nn::hid::SetNpadJoyAssignmentModeDual()</a></code> function to change the Joy-Con assignment to single-controller grip. If the only play styles that are enabled are those assuming single-controller grip, such as <code><a class="el" href="namespacenn_1_1hid.html#a93f2c921b3f4d3a9b8e02ddc30ea50b8" title="Definition of a play style modeled on the Joy-Con (L).">nn::hid::NpadStyleJoyLeft</a></code> or <code><a class="el" href="namespacenn_1_1hid.html#aa09597ee31314ec6782e5f56384ea5b9" title="Definition of a play style modeled on the Joy-Con (R).">nn::hid::NpadStyleJoyRight</a></code>, the Joy-Con assignment state for the Npad will automatically be single-controller grip (<code><a class="el" href="namespacenn_1_1hid.html#a6c4b0ecdaa297bb33e65d46b2f350546aa5c3821ed1fa09b77fb68d7930b20c08" title="Each Npad is assigned one of the Joy-Con pair of controllers.">nn::hid::NpadJoyAssignmentMode_Single</a></code>).</p>
<p>For the NX, if you only enable play styles that assume single-controller grip, such as <code><a class="el" href="namespacenn_1_1hid.html#a93f2c921b3f4d3a9b8e02ddc30ea50b8" title="Definition of a play style modeled on the Joy-Con (L).">nn::hid::NpadStyleJoyLeft</a></code> or <code><a class="el" href="namespacenn_1_1hid.html#aa09597ee31314ec6782e5f56384ea5b9" title="Definition of a play style modeled on the Joy-Con (R).">nn::hid::NpadStyleJoyRight</a></code>, the Joy-Cons assigned to the Npad in dual-controller grip are automatically disconnected.</p>
<p>For example, the Joy-Con is assigned to the Npad in dual-controller grip at the entrance screen immediately after waking from sleep mode or in the HOME Menu, and will be disconnected when returning to an application that only supports single-controller grip.</p>
<p>If you want to prevent the controller from being disconnected in cases like that, enable <code><a class="el" href="namespacenn_1_1hid.html#a1528b4e8a2b39e40f5f76c847c4ccc82" title="Definition of a play style modeled on holding two Joy-Con controllers.">nn::hid::NpadStyleJoyDual</a></code>, and use the <code><a class="el" href="namespacenn_1_1hid.html#a617f872f844f16873b925fe0669a898a" title="Changes the Npad&#39;s Joy-Con assignment mode to &quot;Single.&quot;.">nn::hid::SetNpadJoyAssignmentModeSingle()</a></code> function to change the dual-controller grip Joy-Con to single-controller grip. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a258b0d78215e9aef289f8d784495159a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258b0d78215e9aef289f8d784495159a">&#9670;&nbsp;</a></span>GestureType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1hid.html#a258b0d78215e9aef289f8d784495159a">nn::hid::GestureType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerated type that specifies the gesture type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a258b0d78215e9aef289f8d784495159aae599161956d626eda4cb0a5ffb85271c"></a>Idle&#160;</td><td class="fielddoc"><p>Wait. </p>
</td></tr>
<tr><td class="fieldname"><a id="a258b0d78215e9aef289f8d784495159aaae94f80b3ce82062a5dd7815daa04f9d"></a>Complete&#160;</td><td class="fielddoc"><p>Complete. </p>
</td></tr>
<tr><td class="fieldname"><a id="a258b0d78215e9aef289f8d784495159aaea4788705e6873b424c65e91c2846b19"></a>Cancel&#160;</td><td class="fielddoc"><p>Cancel. </p>
</td></tr>
<tr><td class="fieldname"><a id="a258b0d78215e9aef289f8d784495159aaf0f31c9700c6b10d8a20dc487b2ae6a8"></a>Touch&#160;</td><td class="fielddoc"><p>Touch. </p>
</td></tr>
<tr><td class="fieldname"><a id="a258b0d78215e9aef289f8d784495159aa0610123bdd4ffc191a3ea05a847e1307"></a>Press&#160;</td><td class="fielddoc"><p>Long press. </p>
</td></tr>
<tr><td class="fieldname"><a id="a258b0d78215e9aef289f8d784495159aa73cf2f244bc0cb0d205b99c04fa13978"></a>Tap&#160;</td><td class="fielddoc"><p>Tap. </p>
</td></tr>
<tr><td class="fieldname"><a id="a258b0d78215e9aef289f8d784495159aaf6d4a17b27da35c2d90ce13801f36782"></a>Pan&#160;</td><td class="fielddoc"><p>Pan. </p>
</td></tr>
<tr><td class="fieldname"><a id="a258b0d78215e9aef289f8d784495159aa78076ce792c4640bf99c598c92bd69e7"></a>Swipe&#160;</td><td class="fielddoc"><p>Swipe. </p>
</td></tr>
<tr><td class="fieldname"><a id="a258b0d78215e9aef289f8d784495159aa1e4ddf6f135e4c639929b4633c29d4f2"></a>Pinch&#160;</td><td class="fielddoc"><p>Pitch. </p>
</td></tr>
<tr><td class="fieldname"><a id="a258b0d78215e9aef289f8d784495159aa8d2de5368588552fbae54044ac5c7b3d"></a>Rotate&#160;</td><td class="fielddoc"><p>Rotation. </p>
</td></tr>
</table>

</div>
</div>
<a id="ae2fae4c1fdc6f4007776b6d58fa68949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2fae4c1fdc6f4007776b6d58fa68949">&#9670;&nbsp;</a></span>GestureDirection</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1hid.html#ae2fae4c1fdc6f4007776b6d58fa68949">nn::hid::GestureDirection</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerated type that specifies the gesture direction. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae2fae4c1fdc6f4007776b6d58fa68949a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"><p>None. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae2fae4c1fdc6f4007776b6d58fa68949a945d5e233cf7d6240f6b783b36a374ff"></a>Left&#160;</td><td class="fielddoc"><p>Left. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae2fae4c1fdc6f4007776b6d58fa68949a258f49887ef8d14ac268c92b02503aaa"></a>Up&#160;</td><td class="fielddoc"><p>Up. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae2fae4c1fdc6f4007776b6d58fa68949a92b09c7c48c520c3c55e497875da437c"></a>Right&#160;</td><td class="fielddoc"><p>Right. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae2fae4c1fdc6f4007776b6d58fa68949a08a38277b0309070706f6652eeae9a53"></a>Down&#160;</td><td class="fielddoc"><p>Down. </p>
</td></tr>
</table>

</div>
</div>
<a id="a6c4b0ecdaa297bb33e65d46b2f350546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4b0ecdaa297bb33e65d46b2f350546">&#9670;&nbsp;</a></span>NpadJoyAssignmentMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1hid.html#a6c4b0ecdaa297bb33e65d46b2f350546">nn::hid::NpadJoyAssignmentMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definitions of Joy-Con assignment modes for Npads. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6c4b0ecdaa297bb33e65d46b2f350546a14b223c9a0a1d5d9eb26a03b68e7c3a8"></a>NpadJoyAssignmentMode_Dual&#160;</td><td class="fielddoc"><p>The Joy-Con pair of controllers are assigned to a single Npad. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6c4b0ecdaa297bb33e65d46b2f350546aa5c3821ed1fa09b77fb68d7930b20c08"></a>NpadJoyAssignmentMode_Single&#160;</td><td class="fielddoc"><p>Each Npad is assigned one of the Joy-Con pair of controllers. </p>
</td></tr>
</table>

</div>
</div>
<a id="afc8f966eb92ca5f66ead837bdc6874a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8f966eb92ca5f66ead837bdc6874a2">&#9670;&nbsp;</a></span>NpadHandheldActivationMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1hid.html#afc8f966eb92ca5f66ead837bdc6874a2">nn::hid::NpadHandheldActivationMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the mode that activates the handheld play style. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afc8f966eb92ca5f66ead837bdc6874a2a96376c5b4f7484f6b53c28ea4f23b5aa"></a>NpadHandheldActivationMode_Dual&#160;</td><td class="fielddoc"><p>The handheld play style is activated when both the left and right Joy-Con controllers are attached. </p>
</td></tr>
<tr><td class="fieldname"><a id="afc8f966eb92ca5f66ead837bdc6874a2a6284af1badbbf8a81b4d78e804b3978b"></a>NpadHandheldActivationMode_Single&#160;</td><td class="fielddoc"><p>The handheld play style is activated when either the left or right Joy-Con is attached. </p>
</td></tr>
<tr><td class="fieldname"><a id="afc8f966eb92ca5f66ead837bdc6874a2a24ee66d461e50c6cac7cd755c0e9bc96"></a>NpadHandheldActivationMode_None&#160;</td><td class="fielddoc"><p>The handheld play style is still activated even if no Joy-Con controllers are attached. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab6d96e4c4c5907c24b58ce53a5b39b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d96e4c4c5907c24b58ce53a5b39b64">&#9670;&nbsp;</a></span>NpadJoyDeviceType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1hid.html#ab6d96e4c4c5907c24b58ce53a5b39b64">nn::hid::NpadJoyDeviceType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definitions of the types of Joy-Cons. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab6d96e4c4c5907c24b58ce53a5b39b64ac4b51bc01228732adc00f8e31faea71a"></a>NpadJoyDeviceType_Left&#160;</td><td class="fielddoc"><p>The Joy-Con (L). </p>
</td></tr>
<tr><td class="fieldname"><a id="ab6d96e4c4c5907c24b58ce53a5b39b64a420827cd4ec7d5bc011f0716ec7c0ad7"></a>NpadJoyDeviceType_Right&#160;</td><td class="fielddoc"><p>The Joy-Con (R). </p>
</td></tr>
</table>

</div>
</div>
<a id="af526a8dbb614b2703ab26245ec37e15f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af526a8dbb614b2703ab26245ec37e15f">&#9670;&nbsp;</a></span>NpadJoyHoldType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1hid.html#af526a8dbb614b2703ab26245ec37e15f">nn::hid::NpadJoyHoldType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definitions of the ways of holding the Joy-Con. </p>
<p>Valid when the Joy-Con assignment mode is <code>NpadJoyAssignmentMode_Single</code>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af526a8dbb614b2703ab26245ec37e15fa4c6d26496f0de85ce5eca9103caf9f9d"></a>NpadJoyHoldType_Vertical&#160;</td><td class="fielddoc"><p>The Joy-Con held vertically in the solo remote grip. </p>
</td></tr>
<tr><td class="fieldname"><a id="af526a8dbb614b2703ab26245ec37e15fa3408c344165586f68fe1686e042f573a"></a>NpadJoyHoldType_Horizontal&#160;</td><td class="fielddoc"><p>The Joy-Con held in the solo horizontal grip. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab802029f44fe9e63041973e712793440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab802029f44fe9e63041973e712793440">&#9670;&nbsp;</a></span>NpadCommunicationMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1hid.html#ab802029f44fe9e63041973e712793440">nn::hid::NpadCommunicationMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definitions of Joy-Con communication modes. </p>
<p><b>To be deprecated.</b></p>
<p> <b>Details</b> <br  />
 Provisional functionality for testing changes in the communication period and the number of connected units. As soon as a level of functionality is implemented that matches what we are expecting for the retail device, this functionality will be removed from the next SDK. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab802029f44fe9e63041973e712793440a0acd94277961918f98c1916c3cc1ece1"></a>NpadCommunicationMode_5ms&#160;</td><td class="fielddoc"><p>Communication mode with a 5-millisecond period. </p>
<p>Up to two Joy-Cons can be connected. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab802029f44fe9e63041973e712793440aa50a6fe343a7b2a9aa6370e13e8aea7b"></a>NpadCommunicationMode_10ms&#160;</td><td class="fielddoc"><p>Communication mode with a 10-millisecond period. </p>
<p>Up to six Joy-Cons can be connected. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab802029f44fe9e63041973e712793440a01d61a1676fdacbd4df7596c2ac90ab8"></a>NpadCommunicationMode_15ms&#160;</td><td class="fielddoc"><p>Communication mode with a 15-millisecond period. </p>
<p>Up to eight Joy-Cons can be connected. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab802029f44fe9e63041973e712793440aaeb8c6f9483e7aa69073f901b0b0d44a"></a>NpadCommunicationMode_Default&#160;</td><td class="fielddoc"><p>The default communication mode with a 15-millisecond period. </p>
<p>Up to six Joy-Cons can be connected. The IR Motion Camera, NFC, and local communications can be used. </p>
</td></tr>
</table>

</div>
</div>
<a id="afcc5c782bfc4ce2b5982eacb91fdf5e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc5c782bfc4ce2b5982eacb91fdf5e0">&#9670;&nbsp;</a></span>GyroscopeZeroDriftMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1hid.html#afcc5c782bfc4ce2b5982eacb91fdf5e0">nn::hid::GyroscopeZeroDriftMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The definition for the zero point correction mode for the gyro sensors. </p>
<p> <b>Details</b> <br  />
 Sometimes the output value, or zero point, for angular velocity when the controller is at rest may fluctuate. This is a result of things like changing temperatures within the controller. The rest of this documentation calls this effect <em>zero point drift</em>. Within the library, controllers constantly determine whether they are at rest to compensate for the effects of zero point drift. The zero point is corrected for using internal calculations when at rest. To determine whether a controller is at rest, test whether there have been any changes over a specific period of time to the angular velocity for a controller. The determination threshold setting varies for each <code>GyroscopeZeroDriftMode</code>.</p>
<p>The determination for whether a controller is at rest is loosest for <code>GyroscopeZeroDriftMode_Loose</code>. This results in the strongtest setting for zero point fluctuations. There is a risk of receiving unexpected input because zero point correction can also occur when you move the controller very slowly or when operating with a constant angular velocity. In such instances, using a mode with stricter conditions will probably remedy the situation. The default setting is <code>GyroscopeZeroDriftMode_Standard</code>. Use <code>GyroscopeZeroDriftMode_Tight</code> when movement is extremely slow, or when you want to produce finer operations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afcc5c782bfc4ce2b5982eacb91fdf5e0a41e2117cc90518714b8095619c8b893c"></a>GyroscopeZeroDriftMode_Loose&#160;</td><td class="fielddoc"><p>The loose mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="afcc5c782bfc4ce2b5982eacb91fdf5e0af36c04249bcc0b0c46532cde018519fb"></a>GyroscopeZeroDriftMode_Standard&#160;</td><td class="fielddoc"><p>The standard mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="afcc5c782bfc4ce2b5982eacb91fdf5e0a67789df4a3bdf76bbd3fb85952d63678"></a>GyroscopeZeroDriftMode_Tight&#160;</td><td class="fielddoc"><p>The tight mode. </p>
</td></tr>
</table>

</div>
</div>
<a id="a9fa410c3c8fb9166daad40d757c065ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa410c3c8fb9166daad40d757c065ba">&#9670;&nbsp;</a></span>VibrationDeviceType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1hid.html#a9fa410c3c8fb9166daad40d757c065ba">nn::hid::VibrationDeviceType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The enumerated type for the physical types of vibration motors. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9fa410c3c8fb9166daad40d757c065baa03e8832fd08192d8a23eaa3159b7e905"></a>VibrationDeviceType_Unknown&#160;</td><td class="fielddoc"><p>Unknown type. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9fa410c3c8fb9166daad40d757c065baa9be9b2d2ed0620f35618c4cc66e79dd3"></a>VibrationDeviceType_LinearResonantActuator&#160;</td><td class="fielddoc"><p>Linear vibration motor (LRA). </p>
</td></tr>
</table>

</div>
</div>
<a id="a0fd1eda256a2981614b26cd038f5c6ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd1eda256a2981614b26cd038f5c6ec">&#9670;&nbsp;</a></span>VibrationDevicePosition</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1hid.html#a0fd1eda256a2981614b26cd038f5c6ec">nn::hid::VibrationDevicePosition</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The enumerated type for the physical locations of vibration motors. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0fd1eda256a2981614b26cd038f5c6eca0686d7b5ce72b1e00b0c706dca51d99c"></a>VibrationDevicePosition_None&#160;</td><td class="fielddoc"><p>No location information. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0fd1eda256a2981614b26cd038f5c6eca8a5eede1ab775a61011a111562aef309"></a>VibrationDevicePosition_Left&#160;</td><td class="fielddoc"><p>Left. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0fd1eda256a2981614b26cd038f5c6eca6baeddecc61560248160f8fb3334165e"></a>VibrationDevicePosition_Right&#160;</td><td class="fielddoc"><p>Right. </p>
</td></tr>
</table>

</div>
</div>
<a id="adc165fa9fa37eeefe20379b2998e917d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc165fa9fa37eeefe20379b2998e917d">&#9670;&nbsp;</a></span>VibrationMixMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1hid.html#adc165fa9fa37eeefe20379b2998e917d">nn::hid::VibrationMixMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The enumerated type for vibration value mixing modes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adc165fa9fa37eeefe20379b2998e917da19ede5cef759070330d1cf3fd8360569"></a>VibrationMixMode_None&#160;</td><td class="fielddoc"><p>No mixing. </p>
<p>(Always the default vibration value.) </p>
</td></tr>
<tr><td class="fieldname"><a id="adc165fa9fa37eeefe20379b2998e917da1797c669c6e76af275b3b3d2020f9c59"></a>VibrationMixMode_MaxAmplitude&#160;</td><td class="fielddoc"><p>The mode to use when the sum of the amplitudes of the low-frequency band and the high-frequency band is large. </p>
</td></tr>
<tr><td class="fieldname"><a id="adc165fa9fa37eeefe20379b2998e917da3e858457a190e1c444203b8da0d2a6d8"></a>VibrationMixMode_MaxAmplitudePerSubband&#160;</td><td class="fielddoc"><p>The mode to use when the amplitudes of the low-frequency band and the high-frequency band are both large. </p>
</td></tr>
<tr><td class="fieldname"><a id="adc165fa9fa37eeefe20379b2998e917da76ca4048abcea197549c5c5d534e7927"></a>VibrationMixMode_AmplitudeSum&#160;</td><td class="fielddoc"><p>The mode for adding amplitude values, using a weighted average value that weights every frequency input using amplitudes. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a942c0cad1b2e3d791e7e2cbc730b3041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a942c0cad1b2e3d791e7e2cbc730b3041">&#9670;&nbsp;</a></span>ShowControllerSupport() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::hid::ShowControllerSupport </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1hid_1_1_controller_support_arg.html">ControllerSupportArg</a> &amp;&#160;</td>
          <td class="paramname"><em>showControllerSupportArg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays the UI that supports the connection of controllers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">showControllerSupportArg</td><td>This settings parameter is required when showing the software keyboard.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the processing results. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000400">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">nn::ResultSuccess</a></b> Indicates the connection of the controller has ended properly. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1hid_1_1_result_controller_support_canceled.html" title="A class that represents error Result values (hid: Controller support has been canceled....">nn::hid::ResultControllerSupportCanceled</a></b> Indicates the specified conditions have not been satisfied. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1hid_1_1_result_controller_support_not_supported_npad_style.html" title="A class that represents error Result values (hid: The specified style of operation is not supported b...">nn::hid::ResultControllerSupportNotSupportedNpadStyle</a></b> Indicates that a style of operation that is not supported by the controller has been specified.</p>
</dd></dl>
<p> <b>Details</b> <br  />
 This function blocks processing until it is finished. </p>

</div>
</div>
<a id="a2219b18059d44f1f0400587e71e2b1b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2219b18059d44f1f0400587e71e2b1b7">&#9670;&nbsp;</a></span>ShowControllerSupport() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::hid::ShowControllerSupport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_controller_support_result_info.html">ControllerSupportResultInfo</a> *&#160;</td>
          <td class="paramname"><em>pOutValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1hid_1_1_controller_support_arg.html">ControllerSupportArg</a> &amp;&#160;</td>
          <td class="paramname"><em>showControllerSupportArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays the UI that supports the connection of controllers. </p>
<p>You can get additional information about the connection state by specifying where to store the information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValue</td><td>The location for storing additional information about the connection state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">showControllerSupportArg</td><td>This settings parameter is required when showing the software keyboard.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the processing results. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000401">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">nn::ResultSuccess</a></b> Indicates the connection of the controller has ended properly. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1hid_1_1_result_controller_support_canceled.html" title="A class that represents error Result values (hid: Controller support has been canceled....">nn::hid::ResultControllerSupportCanceled</a></b> Indicates the specified conditions have not been satisfied. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1hid_1_1_result_controller_support_not_supported_npad_style.html" title="A class that represents error Result values (hid: The specified style of operation is not supported b...">nn::hid::ResultControllerSupportNotSupportedNpadStyle</a></b> Indicates that a style of operation that is not supported by the controller has been specified.</p>
</dd></dl>
<p> <b>Details</b> <br  />
 This function blocks processing until it is finished. </p>

</div>
</div>
<a id="a9655269c05d48bd56c3e25ee20c99831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9655269c05d48bd56c3e25ee20c99831">&#9670;&nbsp;</a></span>SetExplainText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::SetExplainText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_controller_support_arg.html">ControllerSupportArg</a> *&#160;</td>
          <td class="paramname"><em>pOutControllerSupportArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets text with a description for each separate controller number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pOutControllerSupportArg</td><td>Parameters for the display of controller support. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pStr</td><td>The UTF-8 string to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Whether the description is for the nth controller. (<a class="el" href="structnn_1_1hid_1_1_npad_id.html#aa0b93745c1c6de72c1fd2174f35c8ed9" title="Npad for controller number 1.">NpadId::No1</a> to <a class="el" href="structnn_1_1hid_1_1_npad_id.html#a67fe4452e1380bd82a290ecc0252dd72" title="Npad for controller number 8.">NpadId::No8</a>)</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
 This function blocks processing until it is finished. </p>

</div>
</div>
<a id="ab472d47d7e876878e4b434f665de6522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab472d47d7e876878e4b434f665de6522">&#9670;&nbsp;</a></span>ShowControllerStrapGuide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::ShowControllerStrapGuide </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays the guide for using the controller strap. </p>
<p> <b>Details</b> <br  />
 This function blocks processing until it is finished. </p>

</div>
</div>
<a id="a7533399b957c748b818b5a2114541ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7533399b957c748b818b5a2114541ca8">&#9670;&nbsp;</a></span>ShowControllerFirmwareUpdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::hid::ShowControllerFirmwareUpdate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1hid_1_1_controller_firmware_update_arg.html">ControllerFirmwareUpdateArg</a> &amp;&#160;</td>
          <td class="paramname"><em>showControllerFirmwareUpdateArg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays the UI for updating controller firmware. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">showControllerFirmwareUpdateArg</td><td>This settings parameter is required when showing the software keyboard.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the processing results. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000402">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">nn::ResultSuccess</a></b> The controller firmware was updated correctly. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1hid_1_1_result_controller_firmware_update_failed.html" title="A class that represents error Result values (hid: Firmware update failed.).">nn::hid::ResultControllerFirmwareUpdateFailed</a></b> Firmware update failed. Some controllers might have already finished updating.</p>
</dd></dl>
<p> <b>Details</b> <br  />
 This function blocks processing until it is finished. Updates all of the connected controllers to the latest firmware. Even if the controller firmware was updated successfully and <code><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">nn::ResultSuccess</a></code> is returned, new controllers that have not been updated may be connected after the update processing executed by this function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ir_sensor_adaptive_clustering_basic_2_ir_sensor_adaptive_clustering_basic_8cpp-example.html#a11">IrSensorAdaptiveClusteringBasic/IrSensorAdaptiveClusteringBasic.cpp</a>, <a class="el" href="_ir_sensor_clustering_basic_2_ir_sensor_clustering_basic_8cpp-example.html#a12">IrSensorClusteringBasic/IrSensorClusteringBasic.cpp</a>, <a class="el" href="_ir_sensor_ir_led_basic_2_ir_sensor_ir_led_basic_8cpp-example.html#a11">IrSensorIrLedBasic/IrSensorIrLedBasic.cpp</a>, <a class="el" href="_ir_sensor_moment_basic_2_ir_sensor_moment_basic_8cpp-example.html#a12">IrSensorMomentBasic/IrSensorMomentBasic.cpp</a>, and <a class="el" href="_ir_sensor_pointing_basic_2_ir_sensor_pointing_basic_8cpp-example.html#a12">IrSensorPointingBasic/IrSensorPointingBasic.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad6819dc9ed7d781a23a0a44cd2a7f86c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6819dc9ed7d781a23a0a44cd2a7f86c">&#9670;&nbsp;</a></span>GetDebugPadState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::GetDebugPadState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_debug_pad_state.html">DebugPadState</a> *&#160;</td>
          <td class="paramname"><em>pOutValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the latest DebugPad input state. </p>
<p> <b>Details</b> <br  />
 Returns the same value as reading one input state with the <code><a class="el" href="namespacenn_1_1hid.html#a391451a9758037697be8138805a832fd" title="Reads past DebugPad input states.">GetDebugPadStates()</a></code> function. The input state is always updated at least once, so this function can be used immediately after the call to the <code><a class="el" href="namespacenn_1_1hid.html#a52f910e37e347a944be54f6860a8ed11" title="Initializes DebugPad.">InitializeDebugPad()</a></code> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValue</td><td>Input state readout buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The call to the <code><a class="el" href="namespacenn_1_1hid.html#a52f910e37e347a944be54f6860a8ed11" title="Initializes DebugPad.">InitializeDebugPad()</a></code> function is complete.</li>
<li><code><em>pOutValue</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>! (<code><em>pOutValue</em>-&gt;buttons.Get&lt;DebugPadButton::Left&gt;()</code> &amp;&amp; <code><em>pOutValue</em>-&gt;buttons.Get&lt;DebugPadButton::Right&gt;()</code>)</li>
<li>! (<code><em>pOutValue</em>-&gt;buttons.Get&lt;DebugPadButton::Up&gt;()</code> &amp;&amp; <code><em>pOutValue</em>-&gt;buttons.Get&lt;DebugPadButton::Down&gt;()</code>)</li>
<li>The control stick input states <code><em>pOutValue</em>-&gt;analogStickL</code> and <code><em>pOutValue</em>-&gt;analogStickR</code> are positioned inside a circle, including the boundary, that satisfies the following conditions.<ul>
<li>The origin is (0, 0).</li>
<li>The radius is <code>AnalogStickMax</code>. </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a135">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a54">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a102">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a200">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a162">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a38">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a109">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a80">AudioOut/AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_2_audio_out_with_resampler_8cpp-example.html#a84">AudioOutWithResampler/AudioOutWithResampler.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a130">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a131">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a51">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a57">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a45">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_imgui_demo_2_imgui_demo__user_inputs_8cpp-example.html#a26">ImguiDemo/ImguiDemo_UserInputs.cpp</a>, <a class="el" href="_imgui_simple_2_imgui_simple_8cpp-example.html#a46">ImguiSimple/ImguiSimple.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_access_point_2_ldn_access_point_8cpp-example.html#a97">LdnBasic/LdnAccessPoint/LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_basic_2_ldn_station_2_ldn_station_8cpp-example.html#a96">LdnBasic/LdnStation/LdnStation.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_user_input_8cpp-example.html#a25">NvnSimple/NvnSimpleSharedLib/UserInput.cpp</a>, <a class="el" href="_nvn_tutorial_2_input_manager_8_n_x_8cpp-example.html#a9">NvnTutorial/InputManager.NX.cpp</a>, <a class="el" href="_spy_audio_2_spy_audio_8cpp-example.html#a67">SpyAudio/SpyAudio.cpp</a>, and <a class="el" href="_ui2d_viewer_simple_2main_8cpp-example.html#a72">Ui2dViewerSimple/main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a391451a9758037697be8138805a832fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391451a9758037697be8138805a832fd">&#9670;&nbsp;</a></span>GetDebugPadStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::hid::GetDebugPadStates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_debug_pad_state.html">DebugPadState</a>&#160;</td>
          <td class="paramname"><em>outValues</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads past DebugPad input states. </p>
<p> <b>Details</b> <br  />
 Reads the available past input states, in order, starting with the most recent and going backward. If you specify a buffer (array) that is larger than the number of available input states, nothing is done to the leftover area. The maximum number of input states that can be read is the number specified by <code>DebugPadStateCountMax</code>. The available input states include those that have already been read. For more information about using only the difference, see <code><a class="el" href="structnn_1_1hid_1_1_debug_pad_state.html#a1ae1b69699a16a6abca85a1494e0dcc5" title="A value that increases each time the DebugPad input state is updated.">DebugPadState::samplingNumber</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outValues</td><td>The buffer (array) that stores the input states. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of <code><em>outValues</em></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of input states read.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The call to the <code><a class="el" href="namespacenn_1_1hid.html#a52f910e37e347a944be54f6860a8ed11" title="Initializes DebugPad.">InitializeDebugPad()</a></code> function is complete.</li>
<li><code><em>outValues</em></code> != <code>nullptr</code>.</li>
<li><code><em>count</em></code> &gt;= <code>0</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The return value <code><em>n</em></code> &gt;= <code>0</code>.</li>
<li>The read input state, <code><em>outValues</em>[i]</code>.<ul>
<li>! (outValues[i].buttons.Get&lt;DebugPadButton::Left&gt;() &amp;&amp; outValues[i].buttons.Get&lt;DebugPadButton::Right&gt;())</li>
<li>! (outValues[i].buttons.Get&lt;DebugPadButton::Up&gt;() &amp;&amp; outValues[i].buttons.Get&lt;DebugPadButton::Down&gt;())</li>
</ul>
</li>
<li>The control stick input states <code><em>outValues</em>[i].analogStickL</code> and <code><em>outValues</em>[i].analogStickR</code> are positioned inside a circle, including the boundary, that satisfies the following conditions.<ul>
<li>The origin is (0, 0).</li>
<li>The radius is <code>AnalogStickMax</code>. </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa199f5e0474ad63f3d3ff0f89a80781f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa199f5e0474ad63f3d3ff0f89a80781f">&#9670;&nbsp;</a></span>GetDigitizerState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::GetDigitizerState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_digitizer_state.html">DigitizerState</a> *&#160;</td>
          <td class="paramname"><em>pOutValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the latest input state of the digitizer. </p>
<p> <b>Details</b> <br  />
 This function returns the same value that the <code><a class="el" href="namespacenn_1_1hid.html#a15908d2bb614d01e6008d8d742d93270" title="Reads the past input states of the digitizer.">GetDigitizerStates()</a></code> function returns when it has read one input state. The input state is ensured to be updated at least once, so this function can be used immediately after the call to the <code><a class="el" href="namespacenn_1_1hid.html#a1b77564dd958e68916c1c13bad99546d" title="Initializes the digitizer.">InitializeDigitizer()</a></code> function is completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValue</td><td>Input state readout buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The call to the <code><a class="el" href="namespacenn_1_1hid.html#a1b77564dd958e68916c1c13bad99546d" title="Initializes the digitizer.">InitializeDigitizer()</a></code> function is complete.</li>
<li><code><em>pOutValue</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a15908d2bb614d01e6008d8d742d93270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15908d2bb614d01e6008d8d742d93270">&#9670;&nbsp;</a></span>GetDigitizerStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::hid::GetDigitizerStates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_digitizer_state.html">DigitizerState</a>&#160;</td>
          <td class="paramname"><em>outValues</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the past input states of the digitizer. </p>
<p> <b>Details</b> <br  />
 Reads the number of past input states available in order, starting with the most recent. If you specify a buffer (array) that is larger than the number of available input states, nothing will be done with the leftover area. The maximum number of input states that can be read is <code>DigitizerStateCountMax</code>. The available input states include those that have already been read. If you only want to use what has changed, see <code><a class="el" href="structnn_1_1hid_1_1_digitizer_state.html#a152e3400f9e27273ce91b0384bf1b521" title="This value increments every time the input state of the digitizer is sampled.">DigitizerState::samplingNumber</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outValues</td><td>The buffer (array) to which the input states are output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of <code><em>outValues</em></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of input states read.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The call to the <code><a class="el" href="namespacenn_1_1hid.html#a1b77564dd958e68916c1c13bad99546d" title="Initializes the digitizer.">InitializeDigitizer()</a></code> function is complete.</li>
<li><code><em>outValues</em></code> != <code>nullptr</code>.</li>
<li><code><em>count</em></code> &gt;= <code>0</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The return value <code><em>n</em></code> &gt;= <code>0</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2f5382d841a4e81da4b0dcde9746ca16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f5382d841a4e81da4b0dcde9746ca16">&#9670;&nbsp;</a></span>GetGestureStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::hid::GetGestureStates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_gesture_state.html">GestureState</a>&#160;</td>
          <td class="paramname"><em>outValues</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads past gesture states. </p>
<p> <b>Details</b> <br  />
 Reads the number of past gesture states available in order, starting with the most recent. When you specify a buffer (array) that is larger than the number of available values, nothing will be done with the leftover area. The maximum number of values that can be read is the number specified by <code>GestureStateCountMax</code>. The available values include those that have already been read. If you want to use just the different states, see <code><a class="el" href="structnn_1_1hid_1_1_gesture_state.html#a90083be10b1a6156ce8f0426ecb39de2" title="This value increases each time gesture state is updated.">GestureState::eventNumber</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outValues</td><td>The buffer (array) to which the input states are output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of <code><em>outValues</em></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of input states read.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The call to the <code><a class="el" href="namespacenn_1_1hid.html#ac48d26c15ce9679154f2f16266d167c8" title="Initializes the gesture related functions.">InitializeGesture()</a></code> function is complete.</li>
<li><code><em>outValues</em></code> != <code>nullptr</code>.</li>
<li><code><em>count</em></code> &gt;= <code>0</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The return value <code><em>n</em></code> &gt;= <code>0</code>. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_hid_gesture_2_hid_gesture__main_8cpp-example.html#a8">HidGesture/HidGesture_Main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="abe32e309493540451e3ada237ba6ee6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe32e309493540451e3ada237ba6ee6c">&#9670;&nbsp;</a></span>GetKeyboardState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::GetKeyboardState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_keyboard_state.html">KeyboardState</a> *&#160;</td>
          <td class="paramname"><em>pOutValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the latest keyboard input state. </p>
<p> <b>Details</b> <br  />
 Returns the same value as reading one input state with the <code><a class="el" href="namespacenn_1_1hid.html#a1dd47864aa616886e73f16c07b0c1dae" title="Reads past keyboard input states.">GetKeyboardStates()</a></code> function. The input state is always updated at least once, so this function can be used immediately after the call to the <code><a class="el" href="namespacenn_1_1hid.html#a7166575a2fd722e67eb8400828dd4b72" title="Initializes the keyboard.">InitializeKeyboard()</a></code> function is completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValue</td><td>Input state readout buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The call to the <code><a class="el" href="namespacenn_1_1hid.html#a7166575a2fd722e67eb8400828dd4b72" title="Initializes the keyboard.">InitializeKeyboard()</a></code> function is complete.</li>
<li><code><em>pOutState</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_imgui_demo_2_imgui_demo__user_inputs_8cpp-example.html#a27">ImguiDemo/ImguiDemo_UserInputs.cpp</a>, <a class="el" href="_imgui_simple_2_imgui_simple_8cpp-example.html#a39">ImguiSimple/ImguiSimple.cpp</a>, <a class="el" href="_nvn_tutorial_2_input_manager_8_windows_8cpp-example.html#a4">NvnTutorial/InputManager.Windows.cpp</a>, <a class="el" href="_nvn_tutorial_2_tutorial_base_class_8_windows_8cpp-example.html#a10">NvnTutorial/TutorialBaseClass.Windows.cpp</a>, and <a class="el" href="_ui2d_viewer_simple_2main_8cpp-example.html#a73">Ui2dViewerSimple/main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1dd47864aa616886e73f16c07b0c1dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd47864aa616886e73f16c07b0c1dae">&#9670;&nbsp;</a></span>GetKeyboardStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::hid::GetKeyboardStates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_keyboard_state.html">KeyboardState</a>&#160;</td>
          <td class="paramname"><em>outValues</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads past keyboard input states. </p>
<p> <b>Details</b> <br  />
 Reads the number of past input states available in order, starting with the most recent. If you specify a buffer (array) that is larger than the number of available input states, nothing will be done with the leftover area. The maximum number of input states that can be read is the number specified by <code>KeyboardStateCountMax</code>. The available input states include those that have already been read. If you want to use just the difference, see <code><a class="el" href="structnn_1_1hid_1_1_keyboard_state.html#a3d597433b652365ca0df0025fa3ca3a0" title="A value incremented each time the keyboard input state is sampled.">KeyboardState::samplingNumber</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outValues</td><td>The buffer (array) to which the input states are output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of <code><em>outValues</em></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of input states read.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The call to the <code><a class="el" href="namespacenn_1_1hid.html#a7166575a2fd722e67eb8400828dd4b72" title="Initializes the keyboard.">InitializeKeyboard()</a></code> function is complete.</li>
<li><code><em>outValues</em></code> != <code>nullptr</code>.</li>
<li><code><em>count</em></code> &gt;= <code>0</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The return value <code><em>n</em></code> &gt;= <code>0</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a79985581b51a04253790a776580efac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79985581b51a04253790a776580efac2">&#9670;&nbsp;</a></span>SendKeyboardLockKeyEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::SendKeyboardLockKeyEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1hid.html#a8a6655b486a08f329709b336f8b60c66">KeyboardLockKeyEventSet</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends keyboard lock key events. </p>
<p> <b>Details</b> <br  />
 Events are processed in order starting with the flag that has the smallest index. Note that the lock state after the relevant function has been called is not known, because the input mode can also be changed using the keyboard itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Lock key event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The call to the <code><a class="el" href="namespacenn_1_1hid.html#a7166575a2fd722e67eb8400828dd4b72" title="Initializes the keyboard.">InitializeKeyboard()</a></code> function is complete. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2e836e16eaa572da7ccbfc9c3b7de5bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e836e16eaa572da7ccbfc9c3b7de5bf">&#9670;&nbsp;</a></span>GetMouseState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::GetMouseState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_mouse_state.html">MouseState</a> *&#160;</td>
          <td class="paramname"><em>pOutValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the latest mouse input state. </p>
<p> <b>Details</b> <br  />
 Returns the same value as reading one input state with the <code><a class="el" href="namespacenn_1_1hid.html#a3c19c1a965e1aa4d45f608ed291fe4da" title="Reads past mouse input states.">GetMouseStates()</a></code> function. The input state is ensured to be updated at least once, so this function can be used immediately after the call to the <code><a class="el" href="namespacenn_1_1hid.html#a322597cf6f0cf7641113a59e4cfb3ccb" title="Initializes the mouse.">InitializeMouse()</a></code> function is completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValue</td><td>Input state readout buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The call to the <code><a class="el" href="namespacenn_1_1hid.html#a322597cf6f0cf7641113a59e4cfb3ccb" title="Initializes the mouse.">InitializeMouse()</a></code> function is complete.</li>
<li><code><em>pOutValue</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_imgui_demo_2_imgui_demo__user_inputs_8cpp-example.html#a28">ImguiDemo/ImguiDemo_UserInputs.cpp</a>, <a class="el" href="_imgui_simple_2_imgui_simple_8cpp-example.html#a53">ImguiSimple/ImguiSimple.cpp</a>, <a class="el" href="_nvn_tutorial_2_input_manager_8_windows_8cpp-example.html#a5">NvnTutorial/InputManager.Windows.cpp</a>, and <a class="el" href="_ui2d_viewer_simple_2main_8cpp-example.html#a74">Ui2dViewerSimple/main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3c19c1a965e1aa4d45f608ed291fe4da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c19c1a965e1aa4d45f608ed291fe4da">&#9670;&nbsp;</a></span>GetMouseStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::hid::GetMouseStates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_mouse_state.html">MouseState</a>&#160;</td>
          <td class="paramname"><em>outValues</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads past mouse input states. </p>
<p> <b>Details</b> <br  />
 Reads the number of past input states available in order, starting with the most recent. If you specify a buffer (array) that is larger than the number of available input states, nothing will be done with the leftover area. The maximum number of input states that can be read is the number specified by <code>MouseStateCountMax</code>. The available input states include those that have already been read. If you want to use just the difference, see <code><a class="el" href="structnn_1_1hid_1_1_mouse_state.html#a22e993b51e2abd25fc85019f06cde0b7" title="A value incremented each time the mouse&#39;s input state is sampled.">MouseState::samplingNumber</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outValues</td><td>The buffer (array) to which the input states are output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of <code><em>outValues</em></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of input states read.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The call to the <code><a class="el" href="namespacenn_1_1hid.html#a322597cf6f0cf7641113a59e4cfb3ccb" title="Initializes the mouse.">InitializeMouse()</a></code> function is complete.</li>
<li><code><em>outValues</em></code> != <code>nullptr</code>.</li>
<li><code><em>count</em></code> &gt;= <code>0</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The return value <code><em>n</em></code> &gt;= <code>0</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0dd2297c0b25b9130427dba90523a920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd2297c0b25b9130427dba90523a920">&#9670;&nbsp;</a></span>GetNpadControllerColor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::hid::GetNpadControllerColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_npad_controller_color.html">NpadControllerColor</a> *&#160;</td>
          <td class="paramname"><em>pOutValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the color for the controller assigned to Npad. </p>
<p> <b>Details</b> <br  />
 Gets the color data for the controller for the Npad specified using the Npad ID.</p>
<p>Color data is obtained using <code><a class="el" href="namespacenn_1_1util.html#a79dfd3486048d906ab2ef68bf8f9f3be" title="Expresses a color using an unsigned 8-bit integer for each of the four components.">nn::util::Color4u8Type</a></code>. The alpha value always returns 255 because there is no alpha setting for controller colors.</p>
<p>You can get color data using this function when the currently operational style obtained using <code>GetNpadStyle()</code> for the Npad specified using <code>NpadIdType</code> is one of the following: <code>NpadStyleJoyLeft</code>, <code>NpadStyleJoyRight</code>, or <code>NpadStyleFullKey</code>. Use <code>GetNpadControllerColor(NpadControllerColor* <em>pOutLeftColor</em>, NpadControllerColor* <em>pOutLeftColor</em>, const NpadIdType&amp; <em>id</em>)</code> for an Npad operating with either <code>NpadStyleJoyDual</code> or <code>NpadStyleHandheld</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValue</td><td>Color data for the controller assigned to Npad. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Npad ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The process succeeded.</li>
<li><a class="el" href="classnn_1_1hid_1_1_result_npad_color_not_available.html">nn::hid::ResultNpadColorNotAvailable</a> Could not get color data.</li>
<li><a class="el" href="classnn_1_1hid_1_1_result_npad_controller_not_connected.html">nn::hid::ResultNpadControllerNotConnected</a> No controller connected for the specified Npad.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>id</em></code> is enabled using <code><a class="el" href="namespacenn_1_1hid.html#a82326d8c0d5f888fce443798bb829e97" title="Configures the Npad ID to support with the application.">SetSupportedNpadIdType()</a></code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a3a72a048e2aee0005d50597ad1bfb059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a72a048e2aee0005d50597ad1bfb059">&#9670;&nbsp;</a></span>GetNpadControllerColor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::hid::GetNpadControllerColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_npad_controller_color.html">NpadControllerColor</a> *&#160;</td>
          <td class="paramname"><em>pOutLeftColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_npad_controller_color.html">NpadControllerColor</a> *&#160;</td>
          <td class="paramname"><em>pOutRightColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the color for the right and left Joy-Con controllers assigned to Npad. </p>
<p> <b>Details</b> <br  />
 Gets the color data for the left and right Joy-Con controllers, for the Npad specified using the Npad ID.</p>
<p>Color data is obtained using <code><a class="el" href="namespacenn_1_1util.html#a79dfd3486048d906ab2ef68bf8f9f3be" title="Expresses a color using an unsigned 8-bit integer for each of the four components.">nn::util::Color4u8Type</a></code>. The alpha value always returns 255 because there is no alpha setting for controller colors.</p>
<p>You can get color data using this function when the currently operational style obtained using <code>GetNpadStyle()</code> for the Npad specified using <code>NpadIdType</code> is one of the following: <code>NpadStyleJoyLeft</code>, <code>NpadStyleJoyRight</code>, or <code>NpadStyleHandheld</code>. Use <code>GetNpadControllerColor(NpadControllerColor* <em>pOutValue</em>, const NpadIdType&amp; <em>id</em>)</code> for an Npad operating with <code>NpadStyleFullKey</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutRightColor</td><td>Color data for the right Joy-Con™ assigned to Npad. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutLeftColor</td><td>Color data for the left Joy-Con™ assigned to Npad. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Npad ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The process succeeded.</li>
<li><a class="el" href="classnn_1_1hid_1_1_result_npad_color_not_available.html">nn::hid::ResultNpadColorNotAvailable</a> Could not get color data.</li>
<li><a class="el" href="classnn_1_1hid_1_1_result_npad_controller_not_connected.html">nn::hid::ResultNpadControllerNotConnected</a> No controller connected for the specified Npad.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>id</em></code> is enabled using <code><a class="el" href="namespacenn_1_1hid.html#a82326d8c0d5f888fce443798bb829e97" title="Configures the Npad ID to support with the application.">SetSupportedNpadIdType()</a></code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a54ad6953b9cef17b4d79171e819b0048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ad6953b9cef17b4d79171e819b0048">&#9670;&nbsp;</a></span>InitializeNpad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::InitializeNpad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an Npad. </p>
<p> <b>Details</b> <br  />
 You must call this function before calling any of the Npad functions. You must call <code><a class="el" href="namespacenn_1_1hid.html#ac04a55a989058f9d69c5c3e4e29c4480" title="Configures the play style to enable on the Npad.">SetSupportedNpadStyleSet()</a></code> and <code><a class="el" href="namespacenn_1_1hid.html#a82326d8c0d5f888fce443798bb829e97" title="Configures the Npad ID to support with the application.">SetSupportedNpadIdType()</a></code> after calling this function to use Npad. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a22">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a23">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a3">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a30">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a30">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a10">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a73">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a1">AudioOut/AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_2_audio_out_with_resampler_8cpp-example.html#a1">AudioOutWithResampler/AudioOutWithResampler.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a23">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a22">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a23">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a20">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a7">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_friends_friend_invitation_2_friends_friend_invitation_8cpp-example.html#a28">FriendsFriendInvitation/FriendsFriendInvitation.cpp</a>, <a class="el" href="_hid_npad_integrate_2_hid_npad_integrate__main_8cpp-example.html#a7">HidNpadIntegrate/HidNpadIntegrate_Main.cpp</a>, <a class="el" href="_hid_npad_simple_2_hid_npad_simple_8cpp-example.html#a15">HidNpadSimple/HidNpadSimple.cpp</a>, <a class="el" href="_hid_npad_six_axis_sensor_2_hid_npad_six_axis_sensor__main_8cpp-example.html#a78">HidNpadSixAxisSensor/HidNpadSixAxisSensor_Main.cpp</a>, <a class="el" href="_hid_vibration_basic_2_hid_vibration_basic_8cpp-example.html#a20">HidVibrationBasic/HidVibrationBasic.cpp</a>, <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a31">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>, <a class="el" href="_imgui_demo_2_imgui_demo__user_inputs_8cpp-example.html#a20">ImguiDemo/ImguiDemo_UserInputs.cpp</a>, <a class="el" href="_ir_sensor_adaptive_clustering_basic_2_ir_sensor_adaptive_clustering_basic_8cpp-example.html#a45">IrSensorAdaptiveClusteringBasic/IrSensorAdaptiveClusteringBasic.cpp</a>, <a class="el" href="_ir_sensor_clustering_basic_2_ir_sensor_clustering_basic_8cpp-example.html#a51">IrSensorClusteringBasic/IrSensorClusteringBasic.cpp</a>, <a class="el" href="_ir_sensor_ir_led_basic_2_ir_sensor_ir_led_basic_8cpp-example.html#a42">IrSensorIrLedBasic/IrSensorIrLedBasic.cpp</a>, <a class="el" href="_ir_sensor_moment_basic_2_ir_sensor_moment_basic_8cpp-example.html#a46">IrSensorMomentBasic/IrSensorMomentBasic.cpp</a>, <a class="el" href="_ir_sensor_pointing_basic_2_ir_sensor_pointing_basic_8cpp-example.html#a38">IrSensorPointingBasic/IrSensorPointingBasic.cpp</a>, <a class="el" href="_ir_sensor_viewer_2_ir_sensor_viewer_8cpp-example.html#a11">IrSensorViewer/IrSensorViewer.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_user_input_8cpp-example.html#a22">NvnSimple/NvnSimpleSharedLib/UserInput.cpp</a>, <a class="el" href="_nvn_tutorial_2_input_manager_8_n_x_8cpp-example.html#a0">NvnTutorial/InputManager.NX.cpp</a>, <a class="el" href="_pctl_simple_2_pctl_simple_8cpp-example.html#a39">PctlSimple/PctlSimple.cpp</a>, and <a class="el" href="_spy_audio_2_spy_audio_8cpp-example.html#a26">SpyAudio/SpyAudio.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac04a55a989058f9d69c5c3e4e29c4480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04a55a989058f9d69c5c3e4e29c4480">&#9670;&nbsp;</a></span>SetSupportedNpadStyleSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::SetSupportedNpadStyleSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1hid.html#ace65233620edda5185ed73112ca9805f">NpadStyleSet</a>&#160;</td>
          <td class="paramname"><em>style</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the play style to enable on the Npad. </p>
<p> <b>Details</b> <br  />
 Configures the play style to enable on the Npad. Before using Npad, use this function to configure the play style to be used by the application.</p>
<p>Play styles prescribe how controllers are used, and set their functionality, format, grips, and more. A single play style can support multiple types of controllers. The <code>NpadStyleFullKey</code> play style, for example, is a play style modeled on the use of the Switch Pro Controller. Any and all controllers offering the same functionality and layout as a Switch Pro Controller can be used when an application supports the use of <code>NpadStyleFullKey</code>.</p>
<p>Applications can also support multiple play styles. Applications must enable at least one play style. Get the play styles currently supported by the application using <code><a class="el" href="namespacenn_1_1hid.html#a099b8efd2f1145ada76ad1f40f69d6ce" title="Gets the Npad play styles supported by the application.">GetSupportedNpadStyleSet()</a></code>.</p>
<p>When no controllers are connected, there are no enabled play styles. You can use <code><a class="el" href="namespacenn_1_1hid.html#a50e56789aa106765d43935bb1838c797" title="Gets the currently enabled play styles for any Npad ID.">GetNpadStyleSet()</a></code> to get the enabled Npad play style for each Npad ID when at least one controller is connected and Npad IDs are assigned.</p>
<p>You cannot use a controller if the play style it supports is not enabled for the application. When the supported play style for a wireless controller is disabled, wireless connections are blocked.</p>
<p>For the <code><em>style</em></code> parameter, which specifies which play styles to enable, you cannot pass <code><em>style</em>.<a class="el" href="namespacenn_1_1util_1_1pmr.html#ad29166793e1166eff3040d7a97d7b6b5" title="Declaration of the std::set alias that PolymorphicAllocator will use for the allocator.">Set()</a></code> with all bit flags enabled. Individually enable the flags that are needed to enable different play styles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">style</td><td>The play style for the Npad to enable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The call to <code><a class="el" href="namespacenn_1_1hid.html#a54ad6953b9cef17b4d79171e819b0048" title="Initializes an Npad.">InitializeNpad()</a></code> is complete.</li>
<li><code><em>style</em>.CountPopulation()</code> &gt; <code>0</code>.</li>
<li><code><em>style</em>.IsAllOn()</code> == <code>false</code>. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a25">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a26">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a6">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a33">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a33">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a13">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a76">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a4">AudioOut/AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_2_audio_out_with_resampler_8cpp-example.html#a4">AudioOutWithResampler/AudioOutWithResampler.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a26">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a25">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a26">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a23">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a10">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_friends_friend_invitation_2_friends_friend_invitation_8cpp-example.html#a29">FriendsFriendInvitation/FriendsFriendInvitation.cpp</a>, <a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__main_8cpp-example.html#a16">HidControllerSequence/HidControllerSequence_Main.cpp</a>, <a class="el" href="_hid_npad_integrate_2_hid_npad_integrate__main_8cpp-example.html#a8">HidNpadIntegrate/HidNpadIntegrate_Main.cpp</a>, <a class="el" href="_hid_npad_simple_2_hid_npad_simple_8cpp-example.html#a16">HidNpadSimple/HidNpadSimple.cpp</a>, <a class="el" href="_hid_npad_six_axis_sensor_2_hid_npad_six_axis_sensor__main_8cpp-example.html#a81">HidNpadSixAxisSensor/HidNpadSixAxisSensor_Main.cpp</a>, <a class="el" href="_hid_vibration_basic_2_hid_vibration_basic_8cpp-example.html#a21">HidVibrationBasic/HidVibrationBasic.cpp</a>, <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a32">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>, <a class="el" href="_imgui_demo_2_imgui_demo__user_inputs_8cpp-example.html#a23">ImguiDemo/ImguiDemo_UserInputs.cpp</a>, <a class="el" href="_ir_sensor_adaptive_clustering_basic_2_ir_sensor_adaptive_clustering_basic_8cpp-example.html#a46">IrSensorAdaptiveClusteringBasic/IrSensorAdaptiveClusteringBasic.cpp</a>, <a class="el" href="_ir_sensor_clustering_basic_2_ir_sensor_clustering_basic_8cpp-example.html#a52">IrSensorClusteringBasic/IrSensorClusteringBasic.cpp</a>, <a class="el" href="_ir_sensor_ir_led_basic_2_ir_sensor_ir_led_basic_8cpp-example.html#a43">IrSensorIrLedBasic/IrSensorIrLedBasic.cpp</a>, <a class="el" href="_ir_sensor_moment_basic_2_ir_sensor_moment_basic_8cpp-example.html#a47">IrSensorMomentBasic/IrSensorMomentBasic.cpp</a>, <a class="el" href="_ir_sensor_pointing_basic_2_ir_sensor_pointing_basic_8cpp-example.html#a39">IrSensorPointingBasic/IrSensorPointingBasic.cpp</a>, <a class="el" href="_ir_sensor_viewer_2_ir_sensor_viewer_8cpp-example.html#a12">IrSensorViewer/IrSensorViewer.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_user_input_8cpp-example.html#a23">NvnSimple/NvnSimpleSharedLib/UserInput.cpp</a>, <a class="el" href="_nvn_tutorial_2_input_manager_8_n_x_8cpp-example.html#a1">NvnTutorial/InputManager.NX.cpp</a>, <a class="el" href="_pctl_simple_2_pctl_simple_8cpp-example.html#a42">PctlSimple/PctlSimple.cpp</a>, and <a class="el" href="_spy_audio_2_spy_audio_8cpp-example.html#a27">SpyAudio/SpyAudio.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a099b8efd2f1145ada76ad1f40f69d6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099b8efd2f1145ada76ad1f40f69d6ce">&#9670;&nbsp;</a></span>GetSupportedNpadStyleSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1hid.html#ace65233620edda5185ed73112ca9805f">NpadStyleSet</a> nn::hid::GetSupportedNpadStyleSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the Npad play styles supported by the application. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the Npad play styles supported by the application. <code>r.IsAnyOff()</code> == <code>true</code> results for the <code><em>r</em></code> return value if <code><a class="el" href="namespacenn_1_1hid.html#ac04a55a989058f9d69c5c3e4e29c4480" title="Configures the play style to enable on the Npad.">SetSupportedNpadStyleSet()</a></code> was not called.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The call to <code><a class="el" href="namespacenn_1_1hid.html#a54ad6953b9cef17b4d79171e819b0048" title="Initializes an Npad.">InitializeNpad()</a></code> is complete. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__title_8cpp-example.html#a14">HidControllerSequence/HidControllerSequence_Title.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a82326d8c0d5f888fce443798bb829e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82326d8c0d5f888fce443798bb829e97">&#9670;&nbsp;</a></span>SetSupportedNpadIdType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::SetSupportedNpadIdType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> *&#160;</td>
          <td class="paramname"><em>pIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the Npad ID to support with the application. </p>
<p> <b>Details</b> <br  />
 Configures the Npad ID to support with the application. Before using Npad, use this function to configure the Npad ID to be used by the application.</p>
<p>The application gets inputs from multiple controllers or users at the Npad ID level. To enable use of this function, you must configure at least one Npad ID. To specify multiple Npad IDs at the same time, use this function. The Npad IDs used during the application can be updated.</p>
<p>Any Npad ID not specified with this function is disabled. You cannot connect a wireless controller to the Nintendo Switch when no Npad IDs are available. When an enabled Npad becomes disabled, any controllers that were connected to that Npad are disconnected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pIds</td><td>List of Npad IDs to enable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of Npad to enable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The call to <code><a class="el" href="namespacenn_1_1hid.html#a54ad6953b9cef17b4d79171e819b0048" title="Initializes an Npad.">InitializeNpad()</a></code> is complete. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a26">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a27">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a7">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a34">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a34">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a14">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a77">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a5">AudioOut/AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_2_audio_out_with_resampler_8cpp-example.html#a5">AudioOutWithResampler/AudioOutWithResampler.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a27">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a26">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a27">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a24">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a11">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_friends_friend_invitation_2_friends_friend_invitation_8cpp-example.html#a30">FriendsFriendInvitation/FriendsFriendInvitation.cpp</a>, <a class="el" href="_hid_npad_integrate_2_hid_npad_integrate__main_8cpp-example.html#a9">HidNpadIntegrate/HidNpadIntegrate_Main.cpp</a>, <a class="el" href="_hid_npad_simple_2_hid_npad_simple_8cpp-example.html#a17">HidNpadSimple/HidNpadSimple.cpp</a>, <a class="el" href="_hid_npad_six_axis_sensor_2_hid_npad_six_axis_sensor__main_8cpp-example.html#a79">HidNpadSixAxisSensor/HidNpadSixAxisSensor_Main.cpp</a>, <a class="el" href="_hid_vibration_basic_2_hid_vibration_basic_8cpp-example.html#a28">HidVibrationBasic/HidVibrationBasic.cpp</a>, <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a36">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>, <a class="el" href="_imgui_demo_2_imgui_demo__user_inputs_8cpp-example.html#a24">ImguiDemo/ImguiDemo_UserInputs.cpp</a>, <a class="el" href="_ir_sensor_adaptive_clustering_basic_2_ir_sensor_adaptive_clustering_basic_8cpp-example.html#a47">IrSensorAdaptiveClusteringBasic/IrSensorAdaptiveClusteringBasic.cpp</a>, <a class="el" href="_ir_sensor_clustering_basic_2_ir_sensor_clustering_basic_8cpp-example.html#a53">IrSensorClusteringBasic/IrSensorClusteringBasic.cpp</a>, <a class="el" href="_ir_sensor_ir_led_basic_2_ir_sensor_ir_led_basic_8cpp-example.html#a44">IrSensorIrLedBasic/IrSensorIrLedBasic.cpp</a>, <a class="el" href="_ir_sensor_moment_basic_2_ir_sensor_moment_basic_8cpp-example.html#a48">IrSensorMomentBasic/IrSensorMomentBasic.cpp</a>, <a class="el" href="_ir_sensor_pointing_basic_2_ir_sensor_pointing_basic_8cpp-example.html#a40">IrSensorPointingBasic/IrSensorPointingBasic.cpp</a>, <a class="el" href="_ir_sensor_viewer_2_ir_sensor_viewer_8cpp-example.html#a13">IrSensorViewer/IrSensorViewer.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_user_input_8cpp-example.html#a24">NvnSimple/NvnSimpleSharedLib/UserInput.cpp</a>, <a class="el" href="_nvn_tutorial_2_input_manager_8_n_x_8cpp-example.html#a2">NvnTutorial/InputManager.NX.cpp</a>, <a class="el" href="_pctl_simple_2_pctl_simple_8cpp-example.html#a40">PctlSimple/PctlSimple.cpp</a>, and <a class="el" href="_spy_audio_2_spy_audio_8cpp-example.html#a28">SpyAudio/SpyAudio.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aee99658f6af775470baa85ed17135c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee99658f6af775470baa85ed17135c5b">&#9670;&nbsp;</a></span>BindNpadStyleSetUpdateEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::BindNpadStyleSetUpdateEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="structnn_1_1os_1_1_system_event_type.html">nn::os::SystemEventType</a> *&#160;</td>
          <td class="paramname"><em>pEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452">nn::os::EventClearMode</a>&#160;</td>
          <td class="paramname"><em>clearMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds a notification that is received when the Npad play style is updated. </p>
<p> <b>Details</b> <br  />
 Binds a notification to use when the play style of the Npad with the specified Npad ID is updated to an event object. Play styles change in response to connecting and disconnecting controllers, or in response to system features. You can use this function to receive notifications when controllers connect and disconnect to the registered event object, because play styles always change when controllers connect or disconnect. You cannot bind to multiple event objects simultaneously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Npad ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pEvent</td><td>Pointer to an event object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clearMode</td><td>Clear mode for the event object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The call to <code><a class="el" href="namespacenn_1_1hid.html#a54ad6953b9cef17b4d79171e819b0048" title="Initializes an Npad.">InitializeNpad()</a></code> is complete.</li>
<li><code><em>pEvent</em></code> != <code>nullptr</code>.</li>
<li><code>*<em>pEvent</em></code> is uninitialized. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code>*<em>pEvent</em></code> is initialized.</li>
<li><code>*<em>pEvent</em></code> is signaled. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a50e56789aa106765d43935bb1838c797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50e56789aa106765d43935bb1838c797">&#9670;&nbsp;</a></span>GetNpadStyleSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1hid.html#ace65233620edda5185ed73112ca9805f">NpadStyleSet</a> nn::hid::GetNpadStyleSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the currently enabled play styles for any Npad ID. </p>
<p> <b>Details</b> <br  />
 Enabled play styles are set for the Npad, based on the type of connected controller for each Npad ID and the content specified using <code><a class="el" href="namespacenn_1_1hid.html#ac04a55a989058f9d69c5c3e4e29c4480" title="Configures the play style to enable on the Npad.">SetSupportedNpadStyleSet()</a></code>. You can use this function to get the currently enabled play styles for each Npad ID.</p>
<p>This function returns <code><em>r</em></code>, for which <code>r.IsAllOff()</code> == <code>true</code> when there is no controller with the Npad ID connected. When any controller is connected and a play style is enabled, the value is <code><em>r</em>.IsAnyOn()</code> == <code>true</code>. Confirming the existence of a valid bit flag for the return value enables you to confirm the connection status of a controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Npad ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The play style for the currently enabled Npad.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The call to <code><a class="el" href="namespacenn_1_1hid.html#a54ad6953b9cef17b4d79171e819b0048" title="Initializes an Npad.">InitializeNpad()</a></code> is complete. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a121">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a46">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a94">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a186">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a148">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a30">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a95">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a72">AudioOut/AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_2_audio_out_with_resampler_8cpp-example.html#a76">AudioOutWithResampler/AudioOutWithResampler.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a122">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a117">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a43">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a43">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a31">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_friends_friend_invitation_2_friends_friend_invitation_8cpp-example.html#a34">FriendsFriendInvitation/FriendsFriendInvitation.cpp</a>, <a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__game_8cpp-example.html#a8">HidControllerSequence/HidControllerSequence_Game.cpp</a>, <a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__title_8cpp-example.html#a24">HidControllerSequence/HidControllerSequence_Title.cpp</a>, <a class="el" href="_hid_npad_integrate_2_hid_npad_integrate__main_8cpp-example.html#a17">HidNpadIntegrate/HidNpadIntegrate_Main.cpp</a>, <a class="el" href="_hid_npad_simple_2_hid_npad_simple_8cpp-example.html#a19">HidNpadSimple/HidNpadSimple.cpp</a>, <a class="el" href="_hid_npad_six_axis_sensor_2_hid_npad_six_axis_sensor__main_8cpp-example.html#a55">HidNpadSixAxisSensor/HidNpadSixAxisSensor_Main.cpp</a>, <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a106">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>, <a class="el" href="_imgui_demo_2_imgui_demo__user_inputs_8cpp-example.html#a30">ImguiDemo/ImguiDemo_UserInputs.cpp</a>, <a class="el" href="_ir_sensor_adaptive_clustering_basic_2_ir_sensor_adaptive_clustering_basic_8cpp-example.html#a32">IrSensorAdaptiveClusteringBasic/IrSensorAdaptiveClusteringBasic.cpp</a>, <a class="el" href="_ir_sensor_clustering_basic_2_ir_sensor_clustering_basic_8cpp-example.html#a37">IrSensorClusteringBasic/IrSensorClusteringBasic.cpp</a>, <a class="el" href="_ir_sensor_ir_led_basic_2_ir_sensor_ir_led_basic_8cpp-example.html#a28">IrSensorIrLedBasic/IrSensorIrLedBasic.cpp</a>, <a class="el" href="_ir_sensor_moment_basic_2_ir_sensor_moment_basic_8cpp-example.html#a32">IrSensorMomentBasic/IrSensorMomentBasic.cpp</a>, <a class="el" href="_ir_sensor_pointing_basic_2_ir_sensor_pointing_basic_8cpp-example.html#a24">IrSensorPointingBasic/IrSensorPointingBasic.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_user_input_8cpp-example.html#a27">NvnSimple/NvnSimpleSharedLib/UserInput.cpp</a>, <a class="el" href="_nvn_tutorial_2_input_manager_8_n_x_8cpp-example.html#a5">NvnTutorial/InputManager.NX.cpp</a>, and <a class="el" href="_spy_audio_2_spy_audio_8cpp-example.html#a69">SpyAudio/SpyAudio.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a090e5d4ee7965fa9bfb2f7737abd8341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a090e5d4ee7965fa9bfb2f7737abd8341">&#9670;&nbsp;</a></span>DisconnectNpad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::DisconnectNpad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnects an Npad. </p>
<p> <b>Details</b> <br  />
 Disconnects the controller assigned to the Npad specified using the Npad ID. This function can be used on Npads with Npad IDs from <code><a class="el" href="structnn_1_1hid_1_1_npad_id.html#aa0b93745c1c6de72c1fd2174f35c8ed9" title="Npad for controller number 1.">NpadId::No1</a></code> to <code><a class="el" href="structnn_1_1hid_1_1_npad_id.html#a67fe4452e1380bd82a290ecc0252dd72" title="Npad for controller number 8.">NpadId::No8</a></code>. Nothing happens when you call this function for a different Npad ID. In addition, nothing happens for an Npad with a controller that was not connected in the first place.</p>
<p>If a controller is disconnected, the <code><em>r</em></code> return value is <code><em>r</em>.IsAllOff()</code> == <code>true</code>, using <code><a class="el" href="namespacenn_1_1hid.html#a50e56789aa106765d43935bb1838c797" title="Gets the currently enabled play styles for any Npad ID.">GetNpadStyleSet()</a></code>.</p>
<div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
 This function is only enabled when the application is in focus (<code><a class="el" href="namespacenn_1_1oe.html#adb1de1670f290d1ee4af0cdbe9ea2effa6568ef060bae975fde787c5fd9eff375" title="In-focus state.">nn::oe::FocusState_InFocus</a></code>). Requests are ignored if the application is not in focus.</div><div class="platform_section" data-platform="NX"></div> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Npad ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The call to <code><a class="el" href="namespacenn_1_1hid.html#a54ad6953b9cef17b4d79171e819b0048" title="Initializes an Npad.">InitializeNpad()</a></code> is complete. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a44729652fee8f9b1371e899f21771c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44729652fee8f9b1371e899f21771c0e">&#9670;&nbsp;</a></span>GetPlayerLedPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bit8 nn::hid::GetPlayerLedPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the pattern of lit Npad player LEDs. </p>
<p> <b>Details</b> <br  />
 Gets the pattern of lit Npad player LEDs for the specified Npad ID.</p>
<p>The pattern of lit LEDs is expressed using the lower 4 bits of Bit8. The lowest-order bit represents the lit state of the player LED furthest to the left.</p>
<p><a class="el" href="class_player.html" title="Player.">Player</a> LEDs can be obtained for Npads <code><a class="el" href="structnn_1_1hid_1_1_npad_id.html#aa0b93745c1c6de72c1fd2174f35c8ed9" title="Npad for controller number 1.">NpadId::No1</a></code> through <code><a class="el" href="structnn_1_1hid_1_1_npad_id.html#a67fe4452e1380bd82a290ecc0252dd72" title="Npad for controller number 8.">NpadId::No8</a></code>. This function will return <code>0</code> if it is called on other Npads. The return value is also <code>0</code> when no controller is connected for the Npad.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Npad ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The call to <code><a class="el" href="namespacenn_1_1hid.html#a54ad6953b9cef17b4d79171e819b0048" title="Initializes an Npad.">InitializeNpad()</a></code> is complete. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__title_8cpp-example.html#a30">HidControllerSequence/HidControllerSequence_Title.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1ea1131389075ff5c5d5911dd6da9b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ea1131389075ff5c5d5911dd6da9b8f">&#9670;&nbsp;</a></span>GetNpadState() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::GetNpadState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_npad_full_key_state.html">NpadFullKeyState</a> *&#160;</td>
          <td class="paramname"><em>pOutValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the input states for the <code>NpadStyleFullKey</code> play style modeled on the Npad Switch Pro Controller. </p>
<p> <b>Details</b> <br  />
 Returns the same value as reading one input state from the Npad corresponding to the specified Npad ID using the <code><a class="el" href="namespacenn_1_1hid.html#a5ce232e78c3098d144e001a546fd0781" title="Reads the past input states for the NpadStyleFullKey play style, modeled on the use of the Npad Switc...">GetNpadStates()</a></code> function. The input state is always updated at least once, so this function can be used immediately after the call to <code><a class="el" href="namespacenn_1_1hid.html#a82326d8c0d5f888fce443798bb829e97" title="Configures the Npad ID to support with the application.">SetSupportedNpadIdType()</a></code> has completed.</p>
<p>If <code>NpadStyleFullKey</code> is not enabled for the specified Npad ID, the input state is treated as no input, with no digital buttons pressed and the stick in the neutral position. Enabled play styles for the Npad ID are available using <code><a class="el" href="namespacenn_1_1hid.html#a50e56789aa106765d43935bb1838c797" title="Gets the currently enabled play styles for any Npad ID.">GetNpadStyleSet()</a></code>.</p>
<p>The input state is available using the <code><a class="el" href="structnn_1_1hid_1_1_npad_full_key_state.html" title="The structure representing the input states for the NpadStyleFullKey play style modeled on holding an...">NpadFullKeyState</a></code> structure. For more information about the available input states, see <code><a class="el" href="structnn_1_1hid_1_1_npad_full_key_state.html" title="The structure representing the input states for the NpadStyleFullKey play style modeled on holding an...">NpadFullKeyState</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValue</td><td>Input state readout buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Npad ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The specified Npad ID has been enabled by the <code><a class="el" href="namespacenn_1_1hid.html#a82326d8c0d5f888fce443798bb829e97" title="Configures the Npad ID to support with the application.">SetSupportedNpadIdType()</a></code> function.</li>
<li><code><em>pOutValue</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>! (<code><em>pOutValue</em>-&gt;buttons.Get&lt;NpadButton::Left&gt;()</code> &amp;&amp; <code><em>pOutValue</em>-&gt;buttons.Get&lt;NpadButton::Right&gt;()</code>)</li>
<li>! (<code><em>pOutValue</em>-&gt;buttons.Get&lt;NpadButton::Up&gt;()</code> &amp;&amp; <code><em>pOutValue</em>-&gt;buttons.Get&lt;NpadButton::Down&gt;()</code>)</li>
<li>The control stick input state <code><em>outValue</em>-&gt;analogStickL</code> and <code><em>outValue</em>-&gt;analogStickR</code> is positioned within the circle (including the boundary).<ul>
<li>The origin is (0, 0).</li>
<li>The radius is <code>AnalogStickMax</code>. </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a123">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a48">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_echoback_2_audio_echoback_8cpp-example.html#a96">AudioEchoback/AudioEchoback.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a188">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a150">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a32">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#a97">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a74">AudioOut/AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_2_audio_out_with_resampler_8cpp-example.html#a78">AudioOutWithResampler/AudioOutWithResampler.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a124">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a119">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a45">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a45">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a33">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_friends_friend_invitation_2_friends_friend_invitation_8cpp-example.html#a37">FriendsFriendInvitation/FriendsFriendInvitation.cpp</a>, <a class="el" href="_hid_npad_simple_2_hid_npad_simple_8cpp-example.html#a21">HidNpadSimple/HidNpadSimple.cpp</a>, <a class="el" href="_hid_npad_six_axis_sensor_2_hid_npad_six_axis_sensor__main_8cpp-example.html#a47">HidNpadSixAxisSensor/HidNpadSixAxisSensor_Main.cpp</a>, <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a108">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>, <a class="el" href="_imgui_demo_2_imgui_demo__user_inputs_8cpp-example.html#a31">ImguiDemo/ImguiDemo_UserInputs.cpp</a>, <a class="el" href="_ir_sensor_adaptive_clustering_basic_2_ir_sensor_adaptive_clustering_basic_8cpp-example.html#a35">IrSensorAdaptiveClusteringBasic/IrSensorAdaptiveClusteringBasic.cpp</a>, <a class="el" href="_ir_sensor_clustering_basic_2_ir_sensor_clustering_basic_8cpp-example.html#a41">IrSensorClusteringBasic/IrSensorClusteringBasic.cpp</a>, <a class="el" href="_ir_sensor_ir_led_basic_2_ir_sensor_ir_led_basic_8cpp-example.html#a32">IrSensorIrLedBasic/IrSensorIrLedBasic.cpp</a>, <a class="el" href="_ir_sensor_moment_basic_2_ir_sensor_moment_basic_8cpp-example.html#a36">IrSensorMomentBasic/IrSensorMomentBasic.cpp</a>, <a class="el" href="_ir_sensor_pointing_basic_2_ir_sensor_pointing_basic_8cpp-example.html#a28">IrSensorPointingBasic/IrSensorPointingBasic.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_user_input_8cpp-example.html#a30">NvnSimple/NvnSimpleSharedLib/UserInput.cpp</a>, <a class="el" href="_nvn_tutorial_2_input_manager_8_n_x_8cpp-example.html#a8">NvnTutorial/InputManager.NX.cpp</a>, <a class="el" href="_pctl_simple_2_pctl_simple_8cpp-example.html#a14">PctlSimple/PctlSimple.cpp</a>, and <a class="el" href="_spy_audio_2_spy_audio_8cpp-example.html#a72">SpyAudio/SpyAudio.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a5ce232e78c3098d144e001a546fd0781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce232e78c3098d144e001a546fd0781">&#9670;&nbsp;</a></span>GetNpadStates() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::hid::GetNpadStates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_npad_full_key_state.html">NpadFullKeyState</a> *&#160;</td>
          <td class="paramname"><em>pOutValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the past input states for the <code>NpadStyleFullKey</code> play style, modeled on the use of the Npad Switch Pro Controller. </p>
<p> <b>Details</b> <br  />
 Reads as many past input states of the Npad corresponding to the specified Npad ID as possible in order, starting from the most recent. If you specify a buffer (array) that is larger than the number of available input states, nothing will be done with the leftover area.</p>
<p>The maximum number of input states that can be read is <code>NpadStateCountMax</code>. The available input states include those that have already been read. If you want to use just the different states, see <code><a class="el" href="structnn_1_1hid_1_1_npad_full_key_state.html#a9cb62b115e427081ce25ae4296a2bcea" title="This value increases each time the Npad input state is updated.">NpadFullKeyState::samplingNumber</a></code>.</p>
<p>When the play style modeled on the Switch Pro Controller is not enabled for the specified Npad ID, the input state becomes one of no input, with no digital buttons pressed and the control sticks in a neutral position.</p>
<p>The input state is available using the <code><a class="el" href="structnn_1_1hid_1_1_npad_full_key_state.html" title="The structure representing the input states for the NpadStyleFullKey play style modeled on holding an...">NpadFullKeyState</a></code> structure. For more information about the available input states, see <code><a class="el" href="structnn_1_1hid_1_1_npad_full_key_state.html" title="The structure representing the input states for the NpadStyleFullKey play style modeled on holding an...">NpadFullKeyState</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValues</td><td>The buffer (array) to which the input states are output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of input states to read out. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Npad ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of input states read.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The specified Npad ID has been enabled by the <code><a class="el" href="namespacenn_1_1hid.html#a82326d8c0d5f888fce443798bb829e97" title="Configures the Npad ID to support with the application.">SetSupportedNpadIdType()</a></code> function.</li>
<li><code><em>pOutValues</em></code> != <code>nullptr</code>.</li>
<li><code><em>count</em></code> &gt;= <code>0</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The return value <code><em>n</em></code> &gt;= <code>0</code>.</li>
<li>About the input states <code><em>pOutValues</em>[i]</code> that are output:<ul>
<li>! (<code><em>pOutValues</em>[i].buttons.Get&lt;NpadButton::Left&gt;()</code> &amp;&amp; <code><em>pOutValues</em>[i].buttons.Get&lt;NpadButton::Right&gt;()</code>)</li>
<li>! (<code><em>pOutValues</em>[i].buttons.Get&lt;NpadButton::Up&gt;()</code> &amp;&amp; <code><em>pOutValues</em>[i].buttons.Get&lt;NpadButton::Down&gt;()</code>)</li>
<li>The control stick input state (<code><em>pOutValues</em>[<em>i</em>].analogStickL</code> and <code><em>pOutValues</em>[<em>i</em>].analogStickR</code>) is specified as a position within a circle (or on the boundaries of the circle) that satisfies the following conditions.<ul>
<li>The origin is (0, 0).</li>
<li>The radius is <code>AnalogStickMax</code>. </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac8c7558a3c94c1eba7af400237f40af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c7558a3c94c1eba7af400237f40af7">&#9670;&nbsp;</a></span>GetNpadState() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::GetNpadState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_npad_handheld_state.html">NpadHandheldState</a> *&#160;</td>
          <td class="paramname"><em>pOutValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the latest input states for the <code>NpadStyleHandheld</code> play style modeled on holding an Npad handheld controller. </p>
<p> <b>Details</b> <br  />
 Returns the same value as reading one input state from the Npad corresponding to the specified Npad ID using the <code><a class="el" href="namespacenn_1_1hid.html#a5ce232e78c3098d144e001a546fd0781" title="Reads the past input states for the NpadStyleFullKey play style, modeled on the use of the Npad Switc...">GetNpadStates()</a></code> function. The input state is always updated at least once, so this function can be used immediately after the call to <code><a class="el" href="namespacenn_1_1hid.html#a82326d8c0d5f888fce443798bb829e97" title="Configures the Npad ID to support with the application.">SetSupportedNpadIdType()</a></code> has completed.</p>
<p>The play style modeled on the handheld controller is only enabled for <code><a class="el" href="structnn_1_1hid_1_1_npad_id.html#afc19a9a80ac740645b567fc7e1dc36cf" title="Npad for a handheld controller.">NpadId::Handheld</a></code>. If <code>NpadStyleHandheld</code> is not enabled for the specified Npad ID, the input state is treated as no input, with no digital buttons pressed and the stick in the neutral position. Enabled play styles for the Npad ID are available using <code><a class="el" href="namespacenn_1_1hid.html#a50e56789aa106765d43935bb1838c797" title="Gets the currently enabled play styles for any Npad ID.">GetNpadStyleSet()</a></code>.</p>
<p>The input state is available using the <code><a class="el" href="structnn_1_1hid_1_1_npad_handheld_state.html" title="The structure representing the input states for the NpadStyleHandheld play style modeled on holding a...">NpadHandheldState</a></code> structure. For more information about the available input states, see <code><a class="el" href="structnn_1_1hid_1_1_npad_handheld_state.html" title="The structure representing the input states for the NpadStyleHandheld play style modeled on holding a...">NpadHandheldState</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValue</td><td>Input state readout buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Npad ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The specified Npad ID has been enabled by the <code><a class="el" href="namespacenn_1_1hid.html#a82326d8c0d5f888fce443798bb829e97" title="Configures the Npad ID to support with the application.">SetSupportedNpadIdType()</a></code> function.</li>
<li><code><em>pOutValue</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>! (<code><em>pOutValue</em>-&gt;buttons.Get&lt;NpadButton::Left&gt;()</code> &amp;&amp; <code><em>pOutValue</em>-&gt;buttons.Get&lt;NpadButton::Right&gt;()</code>)</li>
<li>! (<code><em>pOutValue</em>-&gt;buttons.Get&lt;NpadButton::Up&gt;()</code> &amp;&amp; <code><em>pOutValue</em>-&gt;buttons.Get&lt;NpadButton::Down&gt;()</code>)</li>
<li>The control stick input state <code><em>outValue</em>-&gt;analogStickL</code> and <code><em>outValue</em>-&gt;analogStickR</code> is positioned within the circle (including the boundary).<ul>
<li>The origin is (0, 0).</li>
<li>The radius is <code>AnalogStickMax</code>. </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab41f8ca9734f504f1475d63f3c20b53f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41f8ca9734f504f1475d63f3c20b53f">&#9670;&nbsp;</a></span>GetNpadStates() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::hid::GetNpadStates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_npad_handheld_state.html">NpadHandheldState</a> *&#160;</td>
          <td class="paramname"><em>pOutValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the past input states for the <code>NpadStyleHandheld</code> play style, modeled on Npad handheld controller use. </p>
<p> <b>Details</b> <br  />
 Reads as many past input states of the Npad corresponding to the specified Npad ID as possible in order, starting from the most recent. If you specify a buffer (array) that is larger than the number of available input states, nothing will be done with the leftover area.</p>
<p>The maximum number of input states that can be read is <code>NpadStateCountMax</code>. The available input states include those that have already been read. If you want to use just the different states, see <code>NpadState::samplingNumber</code>.</p>
<p>The play style modeled on the handheld controller is only enabled for <code><a class="el" href="structnn_1_1hid_1_1_npad_id.html#afc19a9a80ac740645b567fc7e1dc36cf" title="Npad for a handheld controller.">NpadId::Handheld</a></code>. If <code>NpadStyleHandheld</code> is not enabled for the specified Npad ID, the input state is treated as no input, with no digital buttons pressed and the stick in the neutral position. Enabled play styles for the Npad ID are available using <code><a class="el" href="namespacenn_1_1hid.html#a50e56789aa106765d43935bb1838c797" title="Gets the currently enabled play styles for any Npad ID.">GetNpadStyleSet()</a></code>.</p>
<p>The input state is available using the <code><a class="el" href="structnn_1_1hid_1_1_npad_handheld_state.html" title="The structure representing the input states for the NpadStyleHandheld play style modeled on holding a...">NpadHandheldState</a></code> structure. For more information about the available input states, see <code><a class="el" href="structnn_1_1hid_1_1_npad_handheld_state.html" title="The structure representing the input states for the NpadStyleHandheld play style modeled on holding a...">NpadHandheldState</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValues</td><td>The buffer (array) to which the input states are output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of input states to read out. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Npad ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of input states read.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The specified Npad ID has been enabled by the <code><a class="el" href="namespacenn_1_1hid.html#a82326d8c0d5f888fce443798bb829e97" title="Configures the Npad ID to support with the application.">SetSupportedNpadIdType()</a></code> function.</li>
<li><code><em>pOutValues</em></code> != <code>nullptr</code>.</li>
<li><code><em>count</em></code> &gt;= <code>0</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The return value <code><em>n</em></code> &gt;= <code>0</code>.</li>
<li>About the input states <code><em>pOutValues</em>[i]</code> that are output:<ul>
<li>! (<code><em>pOutValues</em>[i].buttons.Get&lt;NpadButton::Left&gt;()</code> &amp;&amp; <code><em>pOutValues</em>[i].buttons.Get&lt;NpadButton::Right&gt;()</code>)</li>
<li>! (<code><em>pOutValues</em>[i].buttons.Get&lt;NpadButton::Up&gt;()</code> &amp;&amp; <code><em>pOutValues</em>[i].buttons.Get&lt;NpadButton::Down&gt;()</code>)</li>
<li>The control stick input state (<code><em>pOutValues</em>[<em>i</em>].analogStickL</code> and <code><em>pOutValues</em>[<em>i</em>].analogStickR</code>) is specified as a position within a circle (or on the boundaries of the circle) that satisfies the following conditions.<ul>
<li>The origin is (0, 0).</li>
<li>The radius is <code>AnalogStickMax</code>. </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ae3197d5100e6e84a467050a6f254b15d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3197d5100e6e84a467050a6f254b15d">&#9670;&nbsp;</a></span>GetNpadJoyAssignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1hid.html#a6c4b0ecdaa297bb33e65d46b2f350546">NpadJoyAssignmentMode</a> nn::hid::GetNpadJoyAssignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the Npad's Joy-Con assignment mode. </p>
<p> <b>Details</b> <br  />
 There are two assignment modes. In <em>dual mode</em>, the pair of Joy-Con controllers is assigned to one Npad. In <em>single mode</em>, each controller for the Joy-Con is assigned individually to an Npad. </p><pre class="fragment">        - Dual controller assignment mode (&lt;tt&gt;NpadStyleSet_JoyDual&lt;/tt&gt;)
</pre><p> A single Npad is assigned the set of left and right Joy-Con. <a class="el" href="class_player.html" title="Player.">Player</a> LEDs flash on both the right and left Joy-Con controllers, using the same controller number. In dual assignment mode, the <code>NpadStyleSet_JoyDual</code> play style is enabled. Even if only one of the Joy-Con pair is attached, the input is taken to be <code>NpadStyleSet_JoyDual</code> input. </p><pre class="fragment">        - Single controller assignment mode (&lt;tt&gt;NpadJoyAssignmentMode_Single&lt;/tt&gt;)
</pre><p> A single Npad is assigned either Joy-Con (R) or Joy-Con (L). Different player LEDs flash on both the right and left Joy-Con controllers, for different controller numbers. In single assignment mode, either the <code>NpadStyleSet_JoyRight</code> or the <code>NpadStyleSet_JoyLeft</code> play style is enabled. The valid <code>NpadStyleSet</code> varies, depending on the type of Joy-Con that is connected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The Npad ID for which to get the assignment mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the current assignment mode.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The specified <code><em>NpadIdType</em></code> is any of <code>NpadId::No*</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a617f872f844f16873b925fe0669a898a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a617f872f844f16873b925fe0669a898a">&#9670;&nbsp;</a></span>SetNpadJoyAssignmentModeSingle() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::SetNpadJoyAssignmentModeSingle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the Npad's Joy-Con assignment mode to "Single.". </p>
<p> <b>Details</b> <br  />
 There are two assignment modes. In <em>dual mode</em>, the pair of Joy-Con controllers is assigned to one Npad. In <em>single mode</em>, each controller for the Joy-Con is assigned individually to an Npad.</p>
<p>This function assigns a single connected Joy-Con to the specified Npad. Joy-Con (R) and Joy-Con (L) take different <code>NpadIdType</code>, and the left and right Joy-Con take different player numbers.</p>
<p>To change the assignment mode, specify one <code>NpadIdType</code>. If a Joy-Con pair is already connected to one <code>NpadIdType</code>, the Joy-Con (R) is disconnected from the Npad and reconnected to a different Npad to which no Joy-Con is connected.</p>
<p>If only one Joy-Con was connected in the first place, the mode is simply changed to single assignment mode.</p>
<p>The Npad assignment mode can be changed externally by a system feature. Use the <code>GetNpadAssignmentMode()</code> function to get the current assignment mode.</p>
<p>This function is only enabled when the application is in focus (<code><a class="el" href="namespacenn_1_1oe.html#adb1de1670f290d1ee4af0cdbe9ea2effa6568ef060bae975fde787c5fd9eff375" title="In-focus state.">nn::oe::FocusState_InFocus</a></code>). Requests are ignored if the application is not in focus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The Npad ID for which to change the assignment mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The specified <code><em>NpadIdType</em></code> is any of <code>NpadId::No*</code>. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ir_sensor_adaptive_clustering_basic_2_ir_sensor_adaptive_clustering_basic_8cpp-example.html#a48">IrSensorAdaptiveClusteringBasic/IrSensorAdaptiveClusteringBasic.cpp</a>, <a class="el" href="_ir_sensor_clustering_basic_2_ir_sensor_clustering_basic_8cpp-example.html#a54">IrSensorClusteringBasic/IrSensorClusteringBasic.cpp</a>, <a class="el" href="_ir_sensor_ir_led_basic_2_ir_sensor_ir_led_basic_8cpp-example.html#a45">IrSensorIrLedBasic/IrSensorIrLedBasic.cpp</a>, <a class="el" href="_ir_sensor_moment_basic_2_ir_sensor_moment_basic_8cpp-example.html#a49">IrSensorMomentBasic/IrSensorMomentBasic.cpp</a>, and <a class="el" href="_ir_sensor_pointing_basic_2_ir_sensor_pointing_basic_8cpp-example.html#a41">IrSensorPointingBasic/IrSensorPointingBasic.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a4f9be0a07a4b174a523e75c9eb8a94b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f9be0a07a4b174a523e75c9eb8a94b8">&#9670;&nbsp;</a></span>SetNpadJoyAssignmentModeSingle() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::SetNpadJoyAssignmentModeSingle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1hid.html#ab6d96e4c4c5907c24b58ce53a5b39b64">NpadJoyDeviceType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the Npad's Joy-Con assignment mode to "Single.". </p>
<p> <b>Details</b> <br  />
 There are two assignment modes. In <em>dual mode</em>, the pair of Joy-Con controllers is assigned to one Npad. In <em>single mode</em>, each controller for the Joy-Con is assigned individually to an Npad.</p>
<p>This function assigns a single connected Joy-Con to the specified Npad. Joy-Con (R) and Joy-Con (L) take different Npad IDs, and the left and right Joy-Con take different player numbers.</p>
<p>To change the assignment mode, specify one Npad ID. With this function, if a Joy-Con pair is already connected to the Npad ID, you can use <code>NpadJoyDeviceType</code> to specify which of the two to keep connected. The Joy-Con controller that is not specified is disconnected from the Npad and reconnected to a different Npad to which no Joy-Con is connected.</p>
<p>If only one Joy-Con was connected in the first place, the value specified for <code><em>type</em></code> is ignored and the mode is simply changed to single assignment mode.</p>
<p>The Npad assignment mode can be changed externally by a system feature. Use the <code>GetNpadAssignmentMode()</code> function to get the current assignment mode.</p>
<p>This function is only enabled when the application is in focus (<code><a class="el" href="namespacenn_1_1oe.html#adb1de1670f290d1ee4af0cdbe9ea2effa6568ef060bae975fde787c5fd9eff375" title="In-focus state.">nn::oe::FocusState_InFocus</a></code>). Requests are ignored if the application is not in focus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The Npad ID for which to change the assignment mode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>If the pair of controllers is connected, specify whether to keep Joy-Con (R) or Joy-Con (L).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The specified <code><em>NpadIdType</em></code> is any of <code>NpadId::No*</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4f9d19aa87ec9120f17cb93578fa2b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f9d19aa87ec9120f17cb93578fa2b9e">&#9670;&nbsp;</a></span>SetNpadJoyAssignmentModeSingle() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::hid::SetNpadJoyAssignmentModeSingle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> *&#160;</td>
          <td class="paramname"><em>pOutValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1hid.html#ab6d96e4c4c5907c24b58ce53a5b39b64">NpadJoyDeviceType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the Npad's Joy-Con assignment mode to <b>single mode</b>, and gets the newly assigned Npad ID for the other Joy-Con that was assigned to a different Npad. </p>
<p> <b>Details</b> <br  />
 There are two assignment modes. In <em>dual mode</em>, the pair of Joy-Con controllers is assigned to one Npad. In <em>single mode</em>, each controller for the Joy-Con is assigned individually to an Npad.</p>
<p>This function assigns a single connected Joy-Con to the specified Npad. Joy-Con (R) and Joy-Con (L) take different Npad IDs, and the left and right Joy-Con take different player numbers.</p>
<p>To change the assignment mode, specify one Npad ID. With this function, if a Joy-Con pair is already connected to the Npad ID, you can use <code>NpadJoyDeviceType</code> to specify which of the two to keep connected. The Joy-Con controller that is not specified is disconnected from the Npad and reconnected to a different Npad to which no Joy-Con is connected.</p>
<p>When there is a Joy-Con that was reconnected for a different Npad, this function returns <code>true</code> as the return value, and can get the <code>NpadIdType</code> of the newly assigned Npad.</p>
<p>If only one Joy-Con was connected in the first place, the value specified for <code><em>type</em></code> is ignored and the mode is simply changed to single assignment mode. In this case, the return value is <code>false</code>.</p>
<p>The Npad assignment mode can be changed externally by a system feature. Use the <code>GetNpadAssignmentMode()</code> function to get the current assignment mode.</p>
<p>This function is only enabled when the application is in focus (<code><a class="el" href="namespacenn_1_1oe.html#adb1de1670f290d1ee4af0cdbe9ea2effa6568ef060bae975fde787c5fd9eff375" title="In-focus state.">nn::oe::FocusState_InFocus</a></code>). Requests are ignored if the application is not in focus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValue</td><td>If there is a Joy-Con that has been reassigned, the <code>NpadIdType</code> of the Npad, that is the assignment target, is set. If there is no Joy-Con that has been reassigned, there is no change. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The Npad ID for which to change the assignment mode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>If the pair of controllers is connected, specify whether to keep Joy-Con (R) or Joy-Con (L).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The specified <code><em>NpadIdType</em></code> is any of <code>NpadId::No*</code>.</li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if there is a Joy-Con that has been reassigned to a new Npad. Returns <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ae113078fec2203ef85f1c92bc9119183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae113078fec2203ef85f1c92bc9119183">&#9670;&nbsp;</a></span>SetNpadJoyAssignmentModeDual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::SetNpadJoyAssignmentModeDual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the Joy-Con assignment mode for the Npad to dual mode. </p>
<p> <b>Details</b> <br  />
 There are two assignment modes. In <em>dual mode</em>, the pair of Joy-Con controllers is assigned to one Npad. In <em>single mode</em>, each controller for the Joy-Con is assigned individually to an Npad.</p>
<p>This function sets the Joy-Con assignment mode to dual mode for the specified Npad. Joy-Con (R) and Joy-Con (L) take different Npad IDs, and the left and right Joy-Con take different player numbers.</p>
<p>To change the assignment mode, specify one Npad ID. If the assignment mode is set to dual, when a Joy-Con is newly connected it is assigned as the pair of controllers.</p>
<p>The Npad assignment mode can be changed externally by a system feature. Use the <code>GetNpadAssignmentMode()</code> function to get the current assignment mode.</p>
<p>This function is only enabled when the application is in focus (<code><a class="el" href="namespacenn_1_1oe.html#adb1de1670f290d1ee4af0cdbe9ea2effa6568ef060bae975fde787c5fd9eff375" title="In-focus state.">nn::oe::FocusState_InFocus</a></code>). Requests are ignored if the application is not in focus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The Npad ID for which to change the assignment mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The specified <code><em>NpadIdType</em></code> is any of <code>NpadId::No*</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a015bdbf795f0a31cdecfbe5f0ac7352d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015bdbf795f0a31cdecfbe5f0ac7352d">&#9670;&nbsp;</a></span>MergeSingleJoyAsDualJoy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::hid::MergeSingleJoyAsDualJoy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;&#160;</td>
          <td class="paramname"><em>id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;&#160;</td>
          <td class="paramname"><em>id2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges two Npads with single-mode assignments into one Npad with a dual-mode assignment. </p>
<p> <b>Details</b> <br  />
 To change the assignment mode using this function, specify the Npad ID for the two Npad in advance. Merges two Npads with single-mode assignments into one Npad with a dual-mode assignment. The two Npads must be connected respectively to the left and right Joy-Con controllers. The change fails if a Joy-Con controller pair is connected to one of the two Npads, or if a Joy-Con (R) is connected to both Npads.</p>
<p>When the function makes the change, the mode for <code>NpadIdType</code> changes to dual assignment mode.</p>
<p>This function is only enabled when the application is in focus (<code><a class="el" href="namespacenn_1_1oe.html#adb1de1670f290d1ee4af0cdbe9ea2effa6568ef060bae975fde787c5fd9eff375" title="In-focus state.">nn::oe::FocusState_InFocus</a></code>). Requests are ignored if the application is not in focus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id1</td><td>The Npad ID for one of the two Npads with a single-mode assignment to merge. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id2</td><td>The Npad ID for one of the two Npads with a single-mode assignment to merge.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The process succeeded.</li>
<li><a class="el" href="classnn_1_1hid_1_1_result_npad_dual_connected.html">nn::hid::ResultNpadDualConnected</a> Indicates that merging is not possible because a specified Npad is connected to a Joy-Con pair.</li>
<li><a class="el" href="classnn_1_1hid_1_1_result_npad_same_joy_type_connected.html">nn::hid::ResultNpadSameJoyTypeConnected</a> Indicates that merging is not possible because the two specified Npads are connected to the same kind of single Joy-Con.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The specified <code><em>NpadIdType</em></code> is any of <code>NpadId::No*</code>.</li>
<li>Only Joy-Con (R) or Joy-Con (L) is assigned to <code><em>id1</em></code>, and only the other kind is assigned to <code><em>id2</em></code>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>A Joy-Con pair is assigned to <code><em>id1</em></code>, and not even a single Joy-Con is assigned to <code><em>id2</em></code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5de41955f2db9e18f6540bed6f3b817d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5de41955f2db9e18f6540bed6f3b817d">&#9670;&nbsp;</a></span>SwapNpadAssignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::SwapNpadAssignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;&#160;</td>
          <td class="paramname"><em>id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;&#160;</td>
          <td class="paramname"><em>id2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the correspondence relationships between physical controllers for the two specified Npads. </p>
<p> <b>Details</b> <br  />
 Changes the physical controllers corresponding to the two specified Npads. This function will run even if the physical controllers are not mapped. If a controller is mapped to <code><em>id1</em></code> but nothing is mapped to <code><em>id2</em></code>, the controller set to <code><em>id1</em></code> will be mapped to <code><em>id2</em></code>.</p>
<p>This function is only enabled when the application is in focus (<code><a class="el" href="namespacenn_1_1oe.html#adb1de1670f290d1ee4af0cdbe9ea2effa6568ef060bae975fde787c5fd9eff375" title="In-focus state.">nn::oe::FocusState_InFocus</a></code>). Requests are ignored if the application is not in focus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id1</td><td>The first Npad ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id2</td><td>The second Npad ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>- For both <code><em>id1</em></code> and <code><em>id2</em></code>, you can set any Npad between <code><a class="el" href="structnn_1_1hid_1_1_npad_id.html#aa0b93745c1c6de72c1fd2174f35c8ed9" title="Npad for controller number 1.">NpadId::No1</a></code> and <code>NpdaId::No8</code>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__start_8cpp-example.html#a6">HidControllerSequence/HidControllerSequence_Start.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="afa86cd44eeb23fb774cb5e02c13f2806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa86cd44eeb23fb774cb5e02c13f2806">&#9670;&nbsp;</a></span>SetNpadJoyHoldType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::SetNpadJoyHoldType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1hid.html#af526a8dbb614b2703ab26245ec37e15f">NpadJoyHoldType</a>&#160;</td>
          <td class="paramname"><em>holdType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets how the Joy-Con is held. </p>
<p> <b>Details</b> <br  />
 Sets how the Joy-Con is held. By setting how the Joy-Con controllers are held, you can operate the system features according to the play style specified in the application.</p>
<p>The setting for how to hold the Joy-Con is enabled for those Joy-Con for which the assignment mode is <code>NpadJoyAssignmentMode_Single</code>. The setting for how to hold the Joy-Con is shared by all Npads and cannot be configured individually. The default setting is <code>NpadJoyHoldType_Vertical</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">holdType</td><td>The style used to hold the Joy-Con. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__main_8cpp-example.html#a17">HidControllerSequence/HidControllerSequence_Main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1a6c57b5c5f8ec786e6faa020d78e80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a6c57b5c5f8ec786e6faa020d78e80f">&#9670;&nbsp;</a></span>GetNpadJoyHoldType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1hid.html#af526a8dbb614b2703ab26245ec37e15f">NpadJoyHoldType</a> nn::hid::GetNpadJoyHoldType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets how the Joy-Con is to be held. </p>
<p> <b>Details</b> <br  />
 Gets the configured way of holding the Joy-Con. The method for operating the system features is determined by the way the Joy-Con is held.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the configured way of holding the Joy-Con. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__main_8cpp-example.html#a84">HidControllerSequence/HidControllerSequence_Main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a65445d99babe7d9e04edf2549c3566da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65445d99babe7d9e04edf2549c3566da">&#9670;&nbsp;</a></span>StartLrAssignmentMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::StartLrAssignmentMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the play style mode assigned by pressing the L/R Buttons on the Joy-Con. </p>
<p> <b>Details</b> <br  />
 When this function is called, both <code>NpadStyleSet</code> and <code>NpadJoyAssignmentMode</code> are determined based on how the buttons are pressed on the Joy-Con. Enabled until <code><a class="el" href="namespacenn_1_1hid.html#a6126d152a247c33c99eabaa855dfc003" title="Ends the play style mode assigned by pressing the L/R Buttons on the Joy-Con.">StopLrAssignmentMode()</a></code> is called.</p>
<p>If the L Button on the Joy-Con (L) and the R Button on the Joy-Con (R) are pressed simultaneously, the two Joy-Con are assigned to the Npad as a pair. If the Npad is already set to dual mode, nothing changes when the L/R Buttons are pressed.</p>
<p>If either <code>NpadStyleRight</code> or <code>NpadStyleLeft</code> is enabled and <code>NpadJoyHoldType</code> is <code>NpadJoyHoldType_Horizontal</code>, pressing the SL and SR Buttons simultaneously sets <code>NpadStyleSet</code> to either <code>NpadStyleRight</code> or <code>NpadStyleLeft</code>. The assignment for the relevant Npad changes to <code>NpadJoyAssignmentMode_Single</code>. Pressing the SL or SR Button on either Joy-Con of the pair disconnects the other Joy-Con of the pair.</p>
<p>If either <code>NpadStyleRight</code> or <code>NpadStyleLeft</code> is enabled and <code>NpadJoyHoldType</code> is <code>NpadJoyHoldType_Vertical</code>, the Joy-Con is connected preferentially as either <code>NpadStyleRight</code> or <code>NpadStyleLeft</code> and the assignment changes to <code>NpadJoyAssignmentMode_Single</code>.</p>
<p>There is no effect on operations when <code>StartLrAssignmentMode</code> has already been called. </p>

</div>
</div>
<a id="a6126d152a247c33c99eabaa855dfc003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6126d152a247c33c99eabaa855dfc003">&#9670;&nbsp;</a></span>StopLrAssignmentMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::StopLrAssignmentMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ends the play style mode assigned by pressing the L/R Buttons on the Joy-Con. </p>
<p> <b>Details</b> <br  />
 Ends the play style assigned mode based on the L and R Button presses that began using <code><a class="el" href="namespacenn_1_1hid.html#a65445d99babe7d9e04edf2549c3566da" title="Starts the play style mode assigned by pressing the L/R Buttons on the Joy-Con.">StartLrAssignmentMode()</a></code>. This function has no effect on operations if <code><a class="el" href="namespacenn_1_1hid.html#a65445d99babe7d9e04edf2549c3566da" title="Starts the play style mode assigned by pressing the L/R Buttons on the Joy-Con.">StartLrAssignmentMode()</a></code> was not called. </p>

</div>
</div>
<a id="a7bd929ea5f6df5670afdfcfc0526b722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd929ea5f6df5670afdfcfc0526b722">&#9670;&nbsp;</a></span>SetNpadHandheldActivationMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::SetNpadHandheldActivationMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1hid.html#afc8f966eb92ca5f66ead837bdc6874a2">NpadHandheldActivationMode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the mode that activates the handheld play style. </p>
<p> <b>Details</b> <br  />
 There are two different conditional modes for activating the handheld play style. </p><pre class="fragment">        - &lt;tt&gt;NpadHandheldActivationMode_Dual&lt;/tt&gt;
</pre><p> In this mode, the handheld play style is enabled when both the left and right Joy-Con controllers are attached. This mode is set by default. </p><pre class="fragment">        - &lt;tt&gt;NpadHandheldActivationMode_Single&lt;/tt&gt;
</pre><p> In this mode, the handheld play style is enabled when either the left or right Joy-Con controller is attached. When just one of the two controllers is attached to Switch, the input from the unattached controller is treated as no input (as if no digital buttons are being pressed and the control stick is in the neutral position). The input state of the six-axis sensor is obtained from the actually attached Joy-Con. </p><pre class="fragment">        - NpadHandheldActivationMode_None
</pre><p> In this mode, the handheld play style is enabled even if the Joy-Con controllers are not attached to the console. The input from the unattached controller is treated as no input (as if no digital buttons are being pressed and the control stick is in the neutral position). The input state of the six-axis sensor is obtained from the system's six-axis sensor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>The mode to set for recognizing the handheld play style. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4d64a58959c22c6eca2ce1bfbbc38ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d64a58959c22c6eca2ce1bfbbc38ec">&#9670;&nbsp;</a></span>GetNpadHandheldActivationMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1hid.html#afc8f966eb92ca5f66ead837bdc6874a2">NpadHandheldActivationMode</a> nn::hid::GetNpadHandheldActivationMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the mode for recognizing the handheld play style. </p>
<p> <b>Details</b> <br  />
 Gets the mode for recognizing the current handheld play style.</p>
<dl class="section return"><dt>Returns</dt><dd>The mode for recognizing the current handheld play style. </dd></dl>

</div>
</div>
<a id="a51d6abc7a61a72700f392ef41147baa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d6abc7a61a72700f392ef41147baa6">&#9670;&nbsp;</a></span>SetNpadCommunicationMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::SetNpadCommunicationMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1hid.html#ab802029f44fe9e63041973e712793440">NpadCommunicationMode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Joy-Con communication mode. </p>
<p><b>To be deprecated.</b></p>
<p> <b>Details</b> <br  />
 Sets the Joy-Con communication mode. When changing the mode, any connectors that were already connected are all disconnected. This function is a provisional feature for testing changes to the communication period and the number of connected units. As soon as a level of functionality is implemented that matches what we are expecting for the retail device, this functionality will be removed from the next SDK.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>The communication mode to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a5bf7e8e7547dd662a4d3c781f38020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5bf7e8e7547dd662a4d3c781f38020">&#9670;&nbsp;</a></span>GetNpadCommunicationMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1hid.html#ab802029f44fe9e63041973e712793440">NpadCommunicationMode</a> nn::hid::GetNpadCommunicationMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the Joy-Con communication mode. </p>
<p><b>To be deprecated.</b></p>
<p> <b>Details</b> <br  />
 This function gets the configured Joy-Con communication mode. This function is a provisional feature for testing changes to the communication period and the number of connected units. As soon as a level of functionality is implemented that matches what we are expecting for the retail device, this functionality will be removed from the next SDK.</p>
<dl class="section return"><dt>Returns</dt><dd>Gets the current Joy-Con communication mode. </dd></dl>

</div>
</div>
<a id="a72482366735ada22d2f7b9f167795bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72482366735ada22d2f7b9f167795bd4">&#9670;&nbsp;</a></span>GetNpadState() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::GetNpadState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_npad_joy_dual_state.html">NpadJoyDualState</a> *&#160;</td>
          <td class="paramname"><em>pOutValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the latest input state for the <code>NpadStyleJoyDual</code> Npad Joy-Con dual mode. </p>
<p> <b>Details</b> <br  />
 Returns the same value as reading one input state from the Npad corresponding to the specified Npad ID using the <code><a class="el" href="namespacenn_1_1hid.html#a5ce232e78c3098d144e001a546fd0781" title="Reads the past input states for the NpadStyleFullKey play style, modeled on the use of the Npad Switc...">GetNpadStates()</a></code> function. The input state is always updated at least once, so this function can be used immediately after the call to <code><a class="el" href="namespacenn_1_1hid.html#a82326d8c0d5f888fce443798bb829e97" title="Configures the Npad ID to support with the application.">SetSupportedNpadIdType()</a></code> has completed.</p>
<p>If <code>NpadStyleJoyDual</code> is not enabled for the specified Npad ID, the input state is treated as no input, with no digital buttons pressed and the stick in the neutral position. Enabled play styles for the Npad ID are available using <code><a class="el" href="namespacenn_1_1hid.html#a50e56789aa106765d43935bb1838c797" title="Gets the currently enabled play styles for any Npad ID.">GetNpadStyleSet()</a></code>.</p>
<p>The input state is available using the <code><a class="el" href="structnn_1_1hid_1_1_npad_joy_dual_state.html" title="The structure representing the input states for the NpadStyleJoyDual play style modeled on holding tw...">NpadJoyDualState</a></code> structure. For more information about the available input states, see <code><a class="el" href="structnn_1_1hid_1_1_npad_joy_dual_state.html" title="The structure representing the input states for the NpadStyleJoyDual play style modeled on holding tw...">NpadJoyDualState</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValue</td><td>Input state readout buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Npad ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The specified Npad ID has been enabled by the <code><a class="el" href="namespacenn_1_1hid.html#a82326d8c0d5f888fce443798bb829e97" title="Configures the Npad ID to support with the application.">SetSupportedNpadIdType()</a></code> function.</li>
<li><code><em>pOutValue</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The control stick input states <code><em>outValue</em>-&gt;analogStickL</code> and <code><em>outValue</em>-&gt;analogStickR</code> are positioned within a circle (including the boundary) that satisfies the following conditions.<ul>
<li>The origin is (0, 0).</li>
<li>The radius is <code>AnalogStickMax</code>. </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ae2c0d887c001211eb9f6d4a2467602d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c0d887c001211eb9f6d4a2467602d8">&#9670;&nbsp;</a></span>GetNpadStates() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::hid::GetNpadStates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_npad_joy_dual_state.html">NpadJoyDualState</a> *&#160;</td>
          <td class="paramname"><em>pOutValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the past input states of the Npad Joy-Con in dual-control mode, <code>NpadStyleJoyDual</code>. </p>
<p> <b>Details</b> <br  />
 Reads as many past input states of the Npad corresponding to the specified Npad ID as possible in order, starting from the most recent. If you specify a buffer (array) that is larger than the number of available input states, nothing is done to the leftover area.</p>
<p>The maximum number of input states that can be read is <code>NpadStateCountMax</code>. The available input states include those that have already been read. If you want to use just the difference, see <code><a class="el" href="structnn_1_1hid_1_1_npad_joy_dual_state.html" title="The structure representing the input states for the NpadStyleJoyDual play style modeled on holding tw...">NpadJoyDualState</a>::<em>samplingNumber</em></code>.</p>
<p>If <code>NpadStyleJoyDual</code> is not enabled for the specified Npad ID, the input state is treated as no input, with no digital buttons pressed and the stick in the neutral position. Enabled play styles for the Npad ID are available using <code><a class="el" href="namespacenn_1_1hid.html#a50e56789aa106765d43935bb1838c797" title="Gets the currently enabled play styles for any Npad ID.">GetNpadStyleSet()</a></code>.</p>
<p>The input state is available using the <code><a class="el" href="structnn_1_1hid_1_1_npad_joy_dual_state.html" title="The structure representing the input states for the NpadStyleJoyDual play style modeled on holding tw...">NpadJoyDualState</a></code> structure. For more information about the available input states, see <code><a class="el" href="structnn_1_1hid_1_1_npad_joy_dual_state.html" title="The structure representing the input states for the NpadStyleJoyDual play style modeled on holding tw...">NpadJoyDualState</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValues</td><td>The buffer (array) that stores the input states. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of input states to read out. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Npad ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of input states read.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The specified Npad ID has been enabled by the <code><a class="el" href="namespacenn_1_1hid.html#a82326d8c0d5f888fce443798bb829e97" title="Configures the Npad ID to support with the application.">SetSupportedNpadIdType()</a></code> function.</li>
<li><code><em>pOutValues</em></code> != <code>nullptr</code>.</li>
<li><code><em>count</em></code> &gt;= <code>0</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The return value <code><em>n</em></code> &gt;= <code>0</code>.</li>
<li>About the output states <code><em>pOutValues</em>[i]</code>:<ul>
<li>The control stick input states (<code><em>pOutValues</em>[<em>i</em>].analogStickL</code> and <code><em>pOutValues</em>[<em>i</em>].analogStickR</code>) are positioned within a circle (including the boundary) that satisfies the following conditions.<ul>
<li>The origin is (0, 0).</li>
<li>The radius is <code>AnalogStickMax</code>. </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a54af9ad4d0e39210123e80f1f5148f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54af9ad4d0e39210123e80f1f5148f22">&#9670;&nbsp;</a></span>GetNpadState() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::GetNpadState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_npad_joy_left_state.html">NpadJoyLeftState</a> *&#160;</td>
          <td class="paramname"><em>pOutValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the input states for the <code>NpadStyleJoyLeft</code> play style modeled on the Npad Joy-Con (L) controller. </p>
<p> <b>Details</b> <br  />
 Returns the same value as reading one input state from the Npad corresponding to the specified Npad ID using the <code><a class="el" href="namespacenn_1_1hid.html#a5ce232e78c3098d144e001a546fd0781" title="Reads the past input states for the NpadStyleFullKey play style, modeled on the use of the Npad Switc...">GetNpadStates()</a></code> function. The input state is always updated at least once, so this function can be used immediately after the call to <code><a class="el" href="namespacenn_1_1hid.html#a82326d8c0d5f888fce443798bb829e97" title="Configures the Npad ID to support with the application.">SetSupportedNpadIdType()</a></code> has completed.</p>
<p>If <code>NpadStyleJoyLeft</code> is not enabled for the specified Npad ID, the input state is treated as no input, with no digital buttons pressed and the stick in the neutral position. Enabled play styles for the Npad ID are available using <code><a class="el" href="namespacenn_1_1hid.html#a50e56789aa106765d43935bb1838c797" title="Gets the currently enabled play styles for any Npad ID.">GetNpadStyleSet()</a></code>.</p>
<p>The input state is available using the <code><a class="el" href="structnn_1_1hid_1_1_npad_joy_left_state.html" title="The structure representing the input states for the NpadStyleJoyLeft play style modeled on holding th...">NpadJoyLeftState</a></code> structure. For more information about the available input states, see <code><a class="el" href="structnn_1_1hid_1_1_npad_joy_left_state.html" title="The structure representing the input states for the NpadStyleJoyLeft play style modeled on holding th...">NpadJoyLeftState</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValue</td><td>Input state readout buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Npad ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The specified Npad ID has been enabled by the <code><a class="el" href="namespacenn_1_1hid.html#a82326d8c0d5f888fce443798bb829e97" title="Configures the Npad ID to support with the application.">SetSupportedNpadIdType()</a></code> function.</li>
<li><code><em>pOutValue</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The control stick input state <code><em>outValue</em>-&gt;analogStickL</code> and <code><em>outValue</em>-&gt;analogStickR</code> is positioned within the circle (including the boundary).<ul>
<li>The origin is <code>(0, 0)</code>.</li>
<li>The radius is <code>AnalogStickMax</code>. </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a10fb0b09f9618c2b1b53cc756e60f3f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10fb0b09f9618c2b1b53cc756e60f3f3">&#9670;&nbsp;</a></span>GetNpadStates() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::hid::GetNpadStates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_npad_joy_left_state.html">NpadJoyLeftState</a> *&#160;</td>
          <td class="paramname"><em>pOutValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the past input states for the <code>NpadStyleJoyLeft</code> play style, modeled on the use of the Npad Joy-Con (L) controller. </p>
<p> <b>Details</b> <br  />
 Reads as many past input states of the Npad corresponding to the specified Npad ID as possible in order, starting from the most recent. If you specify a buffer (array) that is larger than the number of available input states, nothing is done to the leftover area.</p>
<p>The maximum number of input states that can be read is <code>NpadStateCountMax</code>. The available input states include those that have already been read. If you want to use just the difference, see <code><a class="el" href="structnn_1_1hid_1_1_npad_joy_left_state.html#a5ba8a2afaca167f781e16b8b4c80163c" title="This value increases each time the Npad input state is updated.">NpadJoyLeftState::samplingNumber</a></code>.</p>
<p>If <code>NpadStyleJoyLeft</code> is not enabled for the specified Npad ID, the input state is treated as no input, with no digital buttons pressed and the stick in the neutral position. Enabled play styles for the Npad ID are available using <code><a class="el" href="namespacenn_1_1hid.html#a50e56789aa106765d43935bb1838c797" title="Gets the currently enabled play styles for any Npad ID.">GetNpadStyleSet()</a></code>.</p>
<p>The input state is available using the <code><a class="el" href="structnn_1_1hid_1_1_npad_joy_left_state.html" title="The structure representing the input states for the NpadStyleJoyLeft play style modeled on holding th...">NpadJoyLeftState</a></code> structure. For more information about the available input states, see <code><a class="el" href="structnn_1_1hid_1_1_npad_joy_left_state.html" title="The structure representing the input states for the NpadStyleJoyLeft play style modeled on holding th...">NpadJoyLeftState</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValues</td><td>The buffer (array) that stores the input states. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of input states to read out. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Npad ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of input states read.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The specified Npad ID has been enabled by the <code><a class="el" href="namespacenn_1_1hid.html#a82326d8c0d5f888fce443798bb829e97" title="Configures the Npad ID to support with the application.">SetSupportedNpadIdType()</a></code> function.</li>
<li><code><em>pOutValues</em></code> != <code>nullptr</code>.</li>
<li><code><em>count</em></code> &gt;= <code>0</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The return value <code><em>n</em></code> &gt;= <code>0</code>.</li>
<li>About the input states <code><em>pOutValues</em>[i]</code> that are output:<ul>
<li>The control stick input state (<code><em>pOutValues</em>[<em>i</em>].analogStickL</code> and <code><em>pOutValues</em>[<em>i</em>].analogStickR</code>) is specified as a position within a circle (or on the boundaries of the circle) that satisfies the following conditions.<ul>
<li>The origin is (0, 0).</li>
<li>The radius is <code>AnalogStickMax</code>. </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4b7f1760184c1b250816ba2d7d64d92f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7f1760184c1b250816ba2d7d64d92f">&#9670;&nbsp;</a></span>GetNpadState() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::GetNpadState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_npad_joy_right_state.html">NpadJoyRightState</a> *&#160;</td>
          <td class="paramname"><em>pOutValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the input states for the <code>NpadStyleJoyRight</code> play style modeled on the Npad Joy-Con (R) controller. </p>
<p> <b>Details</b> <br  />
 Returns the same value as reading one input state from the Npad corresponding to the specified Npad ID using the <code><a class="el" href="namespacenn_1_1hid.html#a5ce232e78c3098d144e001a546fd0781" title="Reads the past input states for the NpadStyleFullKey play style, modeled on the use of the Npad Switc...">GetNpadStates()</a></code> function. The input state is always updated at least once, so this function can be used immediately after the call to <code><a class="el" href="namespacenn_1_1hid.html#a82326d8c0d5f888fce443798bb829e97" title="Configures the Npad ID to support with the application.">SetSupportedNpadIdType()</a></code> has completed.</p>
<p>If <code>NpadStyleJoyRight</code> is not enabled for the specified Npad ID, the input state is treated as no input, with no digital buttons pressed and the stick in the neutral position. Enabled play styles for the Npad ID are available using <code><a class="el" href="namespacenn_1_1hid.html#a50e56789aa106765d43935bb1838c797" title="Gets the currently enabled play styles for any Npad ID.">GetNpadStyleSet()</a></code>.</p>
<p>The input state is available using the <code><a class="el" href="structnn_1_1hid_1_1_npad_joy_right_state.html" title="The structure representing the input states for the NpadStyleJoyRight play style modeled on holding a...">NpadJoyRightState</a></code> structure. For more information about the available input states, see <code><a class="el" href="structnn_1_1hid_1_1_npad_joy_right_state.html" title="The structure representing the input states for the NpadStyleJoyRight play style modeled on holding a...">NpadJoyRightState</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValue</td><td>Input state readout buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Npad ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The specified Npad ID has been enabled by the <code><a class="el" href="namespacenn_1_1hid.html#a82326d8c0d5f888fce443798bb829e97" title="Configures the Npad ID to support with the application.">SetSupportedNpadIdType()</a></code> function.</li>
<li><code><em>pOutValue</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The control stick input state <code><em>outValue</em>-&gt;analogStickL</code> and <code><em>outValue</em>-&gt;analogStickR</code> is positioned within the circle (including the boundary).<ul>
<li>The origin is <code>(0, 0)</code>.</li>
<li>The radius is <code>AnalogStickMax</code>. </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a8041ed4f7b45739c40a32f02f3889459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8041ed4f7b45739c40a32f02f3889459">&#9670;&nbsp;</a></span>GetNpadStates() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::hid::GetNpadStates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_npad_joy_right_state.html">NpadJoyRightState</a> *&#160;</td>
          <td class="paramname"><em>pOutValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the past input states for the <code>NpadStyleJoyRight</code> play style, modeled on the use of the Npad Joy-Con (R) controller. </p>
<p> <b>Details</b> <br  />
 Reads as many past input states of the Npad corresponding to the specified Npad ID as possible in order, starting from the most recent. If you specify a buffer (array) that is larger than the number of available input states, nothing is done to the leftover area.</p>
<p>The maximum number of input states that can be read is <code>NpadStateCountMax</code>. The available input states include those that have already been read. If you want to use just the difference, see <code><a class="el" href="structnn_1_1hid_1_1_npad_joy_right_state.html#aad51eb649e344cb0c3035153a7d1da99" title="This value increases each time the Npad input state is updated.">NpadJoyRightState::samplingNumber</a></code>.</p>
<p>If <code>NpadStyleJoyRight</code> is not enabled for the specified Npad ID, the input state is treated as no input, with no digital buttons pressed and the stick in the neutral position. Enabled play styles for the Npad ID are available using <code><a class="el" href="namespacenn_1_1hid.html#a50e56789aa106765d43935bb1838c797" title="Gets the currently enabled play styles for any Npad ID.">GetNpadStyleSet()</a></code>.</p>
<p>The input state is available using the <code><a class="el" href="structnn_1_1hid_1_1_npad_joy_right_state.html" title="The structure representing the input states for the NpadStyleJoyRight play style modeled on holding a...">NpadJoyRightState</a></code> structure. For more information about the available input states, see <code><a class="el" href="structnn_1_1hid_1_1_npad_joy_right_state.html" title="The structure representing the input states for the NpadStyleJoyRight play style modeled on holding a...">NpadJoyRightState</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValues</td><td>The buffer (array) that stores the input states. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of input states to read out. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Npad ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of input states read.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The specified Npad ID has been enabled by the <code><a class="el" href="namespacenn_1_1hid.html#a82326d8c0d5f888fce443798bb829e97" title="Configures the Npad ID to support with the application.">SetSupportedNpadIdType()</a></code> function.</li>
<li><code><em>pOutValues</em></code> != <code>nullptr</code>.</li>
<li><code><em>count</em></code> &gt;= <code>0</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The return value <code><em>n</em></code> &gt;= <code>0</code>.</li>
<li>About the input states <code><em>pOutValues</em>[i]</code> that are output:<ul>
<li>The control stick input state (<code><em>pOutValues</em>[<em>i</em>].analogStickL</code> and <code><em>pOutValues</em>[<em>i</em>].analogStickR</code>) is specified as a position within a circle (or on the boundaries of the circle) that satisfies the following conditions.<ul>
<li>The origin is (0, 0).</li>
<li>The radius is <code>AnalogStickMax</code>. </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1afbbfec7a9390e95451faaaa0c43f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1afbbfec7a9390e95451faaaa0c43f0b">&#9670;&nbsp;</a></span>GetSixAxisSensorHandles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::hid::GetSixAxisSensorHandles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_handle.html">SixAxisSensorHandle</a> *&#160;</td>
          <td class="paramname"><em>pOutValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1hid.html#ace65233620edda5185ed73112ca9805f">NpadStyleSet</a>&#160;</td>
          <td class="paramname"><em>style</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the six-axis sensor's handles. </p>
<p> <b>Details</b> <br  />
 Gets the six-axis sensor handles for the Npad corresponding to the specified Npad ID. The <code>SixAxisSensor</code> handle gets each operational style (the <code>NpadStyle</code>) for the Npad ID. The operational style is specified by <code>NpadStyleSet</code>, but multiple <code>NpadStyle</code> values cannot be specified at the same time. Because the number of obtainable handles varies depending on <code>NpadStyle</code>, the function returns the number of handles that it could get as its return value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValues</td><td>The location where the handle for the six-axis sensor is stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The maximum number of handles that can be obtained in <code><em>pOutValues</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Npad ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">style</td><td>The operational style for the Npad that gets handles.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of handles that were obtained.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>style</em>.IsAnyOn()</code> == <code>true</code>.</li>
<li><code><em>style</em>.CountPopulation()</code> == <code>1</code>.</li>
<li><code>0</code> &lt; <code><em>count</em></code> &amp;&amp; <code><em>count</em></code> &lt;= <code>NpadSixAxisSensorHandleCountMax</code>. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_hid_npad_six_axis_sensor_2_hid_npad_six_axis_sensor__main_8cpp-example.html#a43">HidNpadSixAxisSensor/HidNpadSixAxisSensor_Main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3a9ed9cc3e5b674c40cbf08a93ebdb62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9ed9cc3e5b674c40cbf08a93ebdb62">&#9670;&nbsp;</a></span>StartSixAxisSensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::StartSixAxisSensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_handle.html">SixAxisSensorHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts sampling for <code>SixAxisSensor</code>. </p>
<p> <b>Details</b> <br  />
 Starts sampling the six-axis sensor that corresponds to the specified <code><em>handle</em></code>. Calling this function sets the controller's base attitude. For the base attitude, the z-axis is the gravity vector, and the x-axis and y-axis have as little difference between the base attitude and the controller's attitude at initialization as possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The handle of the six-axis sensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_hid_npad_six_axis_sensor_2_hid_npad_six_axis_sensor__main_8cpp-example.html#a44">HidNpadSixAxisSensor/HidNpadSixAxisSensor_Main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a58870d9163a3be00cefe3ad6bb8e1852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58870d9163a3be00cefe3ad6bb8e1852">&#9670;&nbsp;</a></span>StopSixAxisSensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::StopSixAxisSensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_handle.html">SixAxisSensorHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops sampling for <code>SixAxisSensor</code>. </p>
<p> <b>Details</b> <br  />
 Stops sampling the six-axis sensor that corresponds to the specified <code><em>handle</em></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The handle of the six-axis sensor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3146b6ef32e7228a5580833a41f4e3fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3146b6ef32e7228a5580833a41f4e3fd">&#9670;&nbsp;</a></span>IsSixAxisSensorAtRest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::hid::IsSixAxisSensorAtRest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_handle.html">SixAxisSensorHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether <code>SixAxisSensor</code> is in a static state. </p>
<p> <b>Details</b> <br  />
 Determines whether the six-axis sensor for the specified <code><em>handle</em></code> and corresponding controller is in a static state. In a static state when the following conditions are continuously met for a set time.</p><ul>
<li>The acceleration displacement for each axis is within a certain threshold.</li>
<li>The angular velocity displacement for each axis is within a certain threshold.</li>
</ul>
<p>Because raw values from the six-axis sensor, prior to any processing, are used for the angular velocity that determines a static state, the parameter settings values for play settings (among other things) will not affect the static state determination.</p>
<p>Because you cannot avoid the internal occurrence of noise as a result of the sensor's hardware characteristics, a static state determination with this function uses a threshold for each six-axis sensor type internally. We recommend using this function when determining whether a controller is in a static state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The handle of the six-axis sensor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether <code>SixAxisSensor</code> is in a static state. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_hid_npad_six_axis_sensor_2_hid_npad_six_axis_sensor__main_8cpp-example.html#a45">HidNpadSixAxisSensor/HidNpadSixAxisSensor_Main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae3fb413f442f5c150025765fd6c2cfb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3fb413f442f5c150025765fd6c2cfb8">&#9670;&nbsp;</a></span>GetSixAxisSensorState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::GetSixAxisSensorState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_state.html">SixAxisSensorState</a> *&#160;</td>
          <td class="paramname"><em>outValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_handle.html">SixAxisSensorHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the latest input state of <code>SixAxisSensor</code>. </p>
<p> <b>Details</b> <br  />
 Returns the same value from the six-axis sensor corresponding to the specified <code><em>handle</em></code> that would be obtained by the <code><a class="el" href="namespacenn_1_1hid.html#a398156ef7f9aa6f9e7478f08260d88ff" title="Reads past SixAxisSensor input states.">GetSixAxisSensorStates()</a></code> function reading a single input state.</p>
<p>The input state indicates no input when the <code><a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_attribute.html#a9e32dd74fb365603890df46e126f65e5" title="Specifies whether a supported device is connected to the system.">SixAxisSensorAttribute::IsConnected</a></code> flag, which belongs to the <code><a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_state.html#a3d6799792b20b60f53d0d655d3c6bfa4" title="Attribute of the SixAxisSensor input state.">SixAxisSensorState::attributes</a></code> member, is <code>false</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outValue</td><td>Input state readout buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The handle of the six-axis sensor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>outValue</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_hid_npad_six_axis_sensor_2_hid_npad_six_axis_sensor__main_8cpp-example.html#a48">HidNpadSixAxisSensor/HidNpadSixAxisSensor_Main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a398156ef7f9aa6f9e7478f08260d88ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398156ef7f9aa6f9e7478f08260d88ff">&#9670;&nbsp;</a></span>GetSixAxisSensorStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::hid::GetSixAxisSensorStates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_state.html">SixAxisSensorState</a> *&#160;</td>
          <td class="paramname"><em>outStates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_handle.html">SixAxisSensorHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads past <code>SixAxisSensor</code> input states. </p>
<p> <b>Details</b> <br  />
 Retroactively reads the input states of the six-axis sensor corresponding to the specified <code><em>handle</em></code>, reading as many past states as are available, in order from the most recent. If you specify a buffer (array) that is larger than the number of available input states, nothing is done to the leftover area. The maximum number of input states that can be read is <code>NpadStateCountMax</code>. The available input states include those that have already been read. If you want to use just the difference, see <code><a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_state.html#a6ccf04e3fbe49514265de2bc6f9e2e4d" title="A value that increases each time the six-axis sensor&#39;s input state is sampled.">SixAxisSensorState::samplingNumber</a></code>. The input state for <code>SixAxisSensor</code> is treated as "no input" even when the ID of the controller corresponding to the <code><em>handle</em></code> is no longer in a resolved state due to a reresolve. With null input, the input state for <code><em>accelerometer</em></code> is a value reflecting a base vector of <code>1.0</code> G. All components of <code><em>angularVelocity</em></code> will be zero (<code>0</code>). The <code><em>angle</em></code> and <code><em>direction</em></code> values remain as they were in their prior input states. Upon reading the values, however, they can be reused as is. The direction that is obtained is a combination of the vectors approximating an orthonormal set representing the three-dimensional position of the controller. Along with the changes to the specification for <code><a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_state.html" title="Structure representing the state obtained from the six-axis sensor.">SixAxisSensorState</a></code>, the three-dimensional position obtained using this function will be replaced with a quaternion-based expression of three-dimensional position.</p>
<p>The input state indicates no input when the <code><a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_attribute.html#a9e32dd74fb365603890df46e126f65e5" title="Specifies whether a supported device is connected to the system.">SixAxisSensorAttribute::IsConnected</a></code> flag, which belongs to the <code><a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_state.html#a3d6799792b20b60f53d0d655d3c6bfa4" title="Attribute of the SixAxisSensor input state.">SixAxisSensorState::attributes</a></code> member, is <code>false</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outStates</td><td>The buffer (array) to which the input states are output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of input states to read out. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The handle of the six-axis sensor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of input states read.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>outStates</em></code> != <code>nullptr</code>.</li>
<li><code><em>count</em></code> &gt;= <code>0</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The return value <code><em>n</em></code> &gt;= <code>0</code>.</li>
<li>The maximum absolute value of <code><em>accelerometer</em></code> is <code>AccelerometerMax</code>.</li>
<li>The maximum absolute value of <code><em>angularVelocity</em></code> is <code>AngularVelocityMax</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a293f527cb0b15c746bccffe5917090c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a293f527cb0b15c746bccffe5917090c4">&#9670;&nbsp;</a></span>IsSixAxisSensorFusionEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::hid::IsSixAxisSensorFusionEnabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_handle.html">SixAxisSensorHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the state of acceleration-based attitude correction for <code>SixAxisSensor</code>. </p>
<p> <b>Details</b> <br  />
 Gets the attitude correction state of the six-axis sensor corresponding to the specified <code><em>handle</em></code>. By default, acceleration-based attitude correction is enabled, the weighting factor for acceleration correction is <code>0.030f</code>, and the effective radius of acceleration correction is <code>0.400f</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The handle of the six-axis sensor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the state of acceleration-based attitude correction. </dd></dl>

</div>
</div>
<a id="a7b1dda2cd885dd5a7150b9d2af10f981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1dda2cd885dd5a7150b9d2af10f981">&#9670;&nbsp;</a></span>EnableSixAxisSensorFusion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::EnableSixAxisSensorFusion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_handle.html">SixAxisSensorHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls the state of acceleration-based attitude correction for <code>SixAxisSensor</code>. </p>
<p> <b>Details</b> <br  />
 Controls the attitude correction state of the six-axis sensor corresponding to the specified <code><em>handle</em></code>. By default, acceleration-based attitude correction is enabled and the parameters are set as follows.</p><ul>
<li>The weighting factor of acceleration correction is 0.030f.</li>
<li>The effective radius of acceleration correction is 0.400f.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The handle of the six-axis sensor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>The attitude correction state of the six-axis sensor to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3f5322f824e3899b7208971bfc643f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3f5322f824e3899b7208971bfc643f3">&#9670;&nbsp;</a></span>SetSixAxisSensorFusionParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::SetSixAxisSensorFusionParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_handle.html">SixAxisSensorHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>revisePower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>reviseRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the parameter for acceleration-based attitude correction for <code>SixAxisSensor</code>. </p>
<p> <b>Details</b> <br  />
 Sets the parameter to use for calculating attitude correction for the six-axis sensor corresponding to the specified <code><em>handle</em></code>. The specified parameter is applied to all axes of the sensor. When the amount of acceleration is within the specified range, centered on the value specified for gravitational acceleration (<code>1.0f</code>), the attitude is corrected based on the direction of the input acceleration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">revisePower</td><td>Weight of acceleration correction. The greater the value, the more strongly correction is applied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reviseRange</td><td>Valid range for acceleration correction. Correction calculations use the accelerometer values in this range, which is centered around gravitational acceleration (<code>1.0f</code>). For example, if <code>0.4f</code> is specified, accelerometer values in the range from <code>0.6f</code> to <code>1.4f</code> are used in the correction calculation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The handle of the six-axis sensor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>revisePower</em></code> &gt;= <code>0.0f</code> &amp;&amp; <code><em>revisePower</em></code> &lt;= <code>1.0f</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="acde39e3ce70d7cecb4b12a2a2a2c2e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acde39e3ce70d7cecb4b12a2a2a2c2e4e">&#9670;&nbsp;</a></span>GetSixAxisSensorFusionParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::GetSixAxisSensorFusionParameters </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pOutRevisePower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pOutReviseRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_handle.html">SixAxisSensorHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the parameter for acceleration-based attitude correction for <code>SixAxisSensor</code>. </p>
<p> <b>Details</b> <br  />
 Gets the parameter to use for calculating attitude correction for the six-axis sensor corresponding to the specified <code><em>handle</em></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutRevisePower</td><td>Weight of acceleration correction. The greater the value, the more strongly correction is applied. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutReviseRange</td><td>Valid range for acceleration correction. Correction calculations use the accelerometer values in this range, which is centered around gravitational acceleration (<code>1.0f</code>). For example, if <code>0.4f</code> is specified, accelerometer values in the range from <code>0.6f</code> to <code>1.4f</code> are used in the correction calculation.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The handle of the six-axis sensor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc4fce71b7b6c3ec2d13006ce130d48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4fce71b7b6c3ec2d13006ce130d48f">&#9670;&nbsp;</a></span>ResetSixAxisSensorFusionParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::ResetSixAxisSensorFusionParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_handle.html">SixAxisSensorHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the parameter for acceleration-based attitude correction for <code>SixAxisSensor</code>. </p>
<p> <b>Details</b> <br  />
 Initializes the parameter to use for calculating attitude correction for the six-axis sensor corresponding to the specified <code><em>handle</em></code>. This is the same as calling <code><a class="el" href="namespacenn_1_1hid.html#ac3f5322f824e3899b7208971bfc643f3" title="Sets the parameter for acceleration-based attitude correction for SixAxisSensor.">SetSixAxisSensorFusionParameters()</a></code> with the weighting factor for acceleration correction set to <code>0.030f</code> and the effective radius of acceleration correction set to <code>0.400f</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The handle of the six-axis sensor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abca693a8a8e3c544c5a21a3dc7c10578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca693a8a8e3c544c5a21a3dc7c10578">&#9670;&nbsp;</a></span>SetGyroscopeZeroDriftMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::SetGyroscopeZeroDriftMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_handle.html">SixAxisSensorHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1hid.html#afcc5c782bfc4ce2b5982eacb91fdf5e0">GyroscopeZeroDriftMode</a> &amp;&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the zero point correction mode for the gyro sensors. </p>
<p> <b>Details</b> <br  />
 Configures the specified <code><em>handle</em></code> and the zero point drift correction mode for the corresponding six-axis sensors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The handle of the six-axis sensor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>The zero point drift correction mode to configure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5af8879cf9c457fa309fd750a6ab03f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5af8879cf9c457fa309fd750a6ab03f">&#9670;&nbsp;</a></span>GetGyroscopeZeroDriftMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1hid.html#afcc5c782bfc4ce2b5982eacb91fdf5e0">GyroscopeZeroDriftMode</a> nn::hid::GetGyroscopeZeroDriftMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_handle.html">SixAxisSensorHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the zero point correction mode for the gyro sensors. </p>
<p> <b>Details</b> <br  />
 Gets the specified <code><em>handle</em></code> and the zero point drift correction mode for the corresponding six-axis sensors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The handle of the six-axis sensor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the current zero point drift correction mode for the six-axis sensor. </dd></dl>

</div>
</div>
<a id="acc0befba6622513777932715e67449a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc0befba6622513777932715e67449a3">&#9670;&nbsp;</a></span>IsFirmwareUpdateAvailableForSixAxisSensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::hid::IsFirmwareUpdateAvailableForSixAxisSensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1hid_1_1_six_axis_sensor_handle.html">SixAxisSensorHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether there is a firmware update available to improve the performance of the six-axis sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A six-axis sensor handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value indicating whether a firmware update is available.</dd></dl>
<p> <b>Details</b> <br  />
 Checks whether there is a firmware update available to improve the performance of the six-axis sensor in the controller specified by the handle.</p>
<p>Returns <code>true</code> if the firmware version can be updated to improve the performance of the six-axis sensor. We recommend calling <code><a class="el" href="namespacenn_1_1hid.html#a7533399b957c748b818b5a2114541ca8" title="Displays the UI for updating controller firmware.">nn::hid::ShowControllerFirmwareUpdate</a></code> at this time to update the controller. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_hid_npad_six_axis_sensor_2_hid_npad_six_axis_sensor__main_8cpp-example.html#a49">HidNpadSixAxisSensor/HidNpadSixAxisSensor_Main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a8057a5f2f1aacdacc9b51dbaee418847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8057a5f2f1aacdacc9b51dbaee418847">&#9670;&nbsp;</a></span>GetTouchScreenState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::GetTouchScreenState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_touch_screen_state.html">TouchScreenState</a>&lt; N &gt; *&#160;</td>
          <td class="paramname"><em>pOutValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the latest touch screen input state. </p>
<p> <b>Details</b> <br  />
 Returns the same value as reading one input state with the <code><a class="el" href="namespacenn_1_1hid.html#a25c328faac65ac47bec4b4cf6a2e1422" title="Reads past touch screen input states.">GetTouchScreenStates()</a></code> function. The input state is ensured to be updated at least once, so this function can be used immediately after the call to the <code><a class="el" href="namespacenn_1_1hid.html#a1d814d34915eac7cfc9b9f92ac3ccc40" title="Initializes the touch screen.">InitializeTouchScreen()</a></code> function is completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValue</td><td>Input state readout buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The number of touches to store.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The call to the <code><a class="el" href="namespacenn_1_1hid.html#a1d814d34915eac7cfc9b9f92ac3ccc40" title="Initializes the touch screen.">InitializeTouchScreen()</a></code> function is complete.</li>
<li><code><em>pOutValue</em></code> != <code>nullptr</code>.</li>
<li><code>0</code> &lt; <code>N</code> &amp;&amp; <code>N</code> &lt;= <code>TouchStateCountMax</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>pOutValue</em>-&gt;count</code> &lt;= <code>N</code> </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_imgui_demo_2_imgui_demo__user_inputs_8cpp-example.html#a29">ImguiDemo/ImguiDemo_UserInputs.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a25c328faac65ac47bec4b4cf6a2e1422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c328faac65ac47bec4b4cf6a2e1422">&#9670;&nbsp;</a></span>GetTouchScreenStates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int nn::hid::GetTouchScreenStates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_touch_screen_state.html">TouchScreenState</a>&lt; N &gt; *&#160;</td>
          <td class="paramname"><em>outStates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads past touch screen input states. </p>
<p> <b>Details</b> <br  />
 Reads the number of past input states available in order, starting with the most recent. If you specify a buffer (array) that is larger than the number of available input states, nothing will be done with the leftover area. The maximum number of input states that can be read is the number specified by <code>TouchScreenStateCountMax</code>. The available input states include those that have already been read. If you want to use just the difference, see <code><a class="el" href="structnn_1_1hid_1_1_touch_screen_state.html#a53ffd7b8ff4ae54b8baca962de641a87" title="A value that increases each time the touch screen input state is sampled.">TouchScreenState::samplingNumber</a></code>. Information about <code><a class="el" href="structnn_1_1hid_1_1_touch_screen_state.html#ac4b8fc65076b1bd75607fb477ec9814b" title="The number of touches.">TouchScreenState::count</a></code> (the number of touches) can be referenced from <code><a class="el" href="structnn_1_1hid_1_1_touch_screen_state.html#ac4239123e5c2512df738f130cab7186e" title="Stores touches in order from that of the oldest contact initiation.">TouchScreenState::touches</a></code>. The maximum number of touches that can be read is the number specified by <code>TouchStateCountMax</code>. <code><a class="el" href="structnn_1_1hid_1_1_touch_screen_state.html#ac4239123e5c2512df738f130cab7186e" title="Stores touches in order from that of the oldest contact initiation.">TouchScreenState::touches</a></code> is completely updated, even when there are fewer touches detected than the maximum. Any remaining space is filled with undefined values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outStates</td><td>The buffer (array) to which the input states are output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of <code><em>outStates</em></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The number of touches to store.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of input states read.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The call to the <code><a class="el" href="namespacenn_1_1hid.html#a1d814d34915eac7cfc9b9f92ac3ccc40" title="Initializes the touch screen.">InitializeTouchScreen()</a></code> function is complete.</li>
<li><code><em>outStates</em></code> != <code>nullptr</code>.</li>
<li><code><em>count</em></code> &gt;= <code>0</code>.</li>
<li><code>0</code> &lt; <code>N</code> &amp;&amp; <code>N</code> &lt;= <code>TouchStateCountMax</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The return value <code><em>n</em></code> &gt;= <code>0</code>.</li>
<li>For the read input state <code><em>outStates</em>[<em>i</em>]</code>, <code><em>outStates</em>[<em>i</em>].count</code> &lt;= <code>N</code>. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_gl_simple_2_gl_simple_8cpp-example.html#a15">GlSimple/GlSimple.cpp</a>, <a class="el" href="_gll_simple_2_gll_simple_8cpp-example.html#a11">GllSimple/GllSimple.cpp</a>, <a class="el" href="_nvn_tutorial_2_tutorial_base_class_8_nx_8cpp-example.html#a20">NvnTutorial/TutorialBaseClass.Nx.cpp</a>, and <a class="el" href="_vk_simple_2_vk_simple_8cpp-example.html#a34">VkSimple/VkSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a2950ca0147b2bbb09a2c34aeaf527ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2950ca0147b2bbb09a2c34aeaf527ca2">&#9670;&nbsp;</a></span>GetVibrationDeviceHandles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::hid::GetVibrationDeviceHandles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_vibration_device_handle.html">VibrationDeviceHandle</a> *&#160;</td>
          <td class="paramname"><em>pOutValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1hid.html#a5923008962b52bf501f91b30013aedd6">NpadIdType</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1hid.html#ace65233620edda5185ed73112ca9805f">NpadStyleSet</a>&#160;</td>
          <td class="paramname"><em>style</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the handles for operating the vibration motor built into the Npads. </p>
<p> <b>Details</b> <br  />
 Gets the handles for operating the vibration motor of the Npad corresponding to the specified Npad ID. A vibration motor handle can be obtained for each operational style (<code>NpadStyleSet</code>) for that Npad ID. The operational style is specified by <code>NpadStyleSet</code>, but multiple <code>NpadStyle</code> values cannot be specified at the same time. Because the number of handles you can get varies depending on <code>NpadStyleSet</code>, the function returns the number of handles that it could get as its return value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValues</td><td>The location for storing the vibration motor handles. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The maximum number of handles that can be obtained in <code><em>pOutValues</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Npad ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">style</td><td>The operational style for the Npad that gets handles.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of handles that were obtained.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>style</em>.IsAnyOn()</code> == <code>true</code>.</li>
<li><code><em>style</em>.CountPopulation()</code> == <code>1</code>. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a38">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aa51427fb3bfd53f3a8784a868a020f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51427fb3bfd53f3a8784a868a020f23">&#9670;&nbsp;</a></span>GetVibrationDeviceInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::GetVibrationDeviceInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_vibration_device_info.html">VibrationDeviceInfo</a> *&#160;</td>
          <td class="paramname"><em>pOutValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1hid_1_1_vibration_device_handle.html">VibrationDeviceHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets vibration motor information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValue</td><td>Location where the vibration motor's information is stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The handle of the vibration motor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The specified <code><em>handle</em></code> was obtained by calling <code><a class="el" href="namespacenn_1_1hid.html#a2950ca0147b2bbb09a2c34aeaf527ca2" title="Gets the handles for operating the vibration motor built into the Npads.">GetVibrationDeviceHandles()</a></code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af610eb6d705297bd91c56825b39383bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af610eb6d705297bd91c56825b39383bf">&#9670;&nbsp;</a></span>InitializeVibrationDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::InitializeVibrationDevice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1hid_1_1_vibration_device_handle.html">VibrationDeviceHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the vibration motor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The handle of the vibration motor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The specified <code><em>handle</em></code> was obtained by calling <code><a class="el" href="namespacenn_1_1hid.html#a2950ca0147b2bbb09a2c34aeaf527ca2" title="Gets the handles for operating the vibration motor built into the Npads.">GetVibrationDeviceHandles()</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Initializes the vibration motor. To use the <code><a class="el" href="namespacenn_1_1hid.html#adc2935e350eab46cc13a4e9d33c61ef9" title="Send the vibration value to the vibration motor.">SendVibrationValue()</a></code> and <code><a class="el" href="namespacenn_1_1hid.html#a2fb585205dac5c49b24bf045b8796307" title="Gets the actual vibration values occurring on the vibration motor.">GetActualVibrationValue()</a></code> functions, you must run this function in advance to place the vibration motors in an initialized state.</p>
<p>When the target device is not initialized, initialization within the device begins with this function's calls as a trigger. It can take up to several hundred milliseconds from when initialization within the device begins until the device is in a state that allows vibration. The vibration value that is sent is ignored until the motors are in a state where vibration is possible. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a39">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="adc2935e350eab46cc13a4e9d33c61ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2935e350eab46cc13a4e9d33c61ef9">&#9670;&nbsp;</a></span>SendVibrationValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::SendVibrationValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1hid_1_1_vibration_device_handle.html">VibrationDeviceHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1hid_1_1_vibration_value.html">VibrationValue</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send the vibration value to the vibration motor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The handle of the vibration motor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The vibration value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The call to <code><a class="el" href="namespacenn_1_1hid.html#af610eb6d705297bd91c56825b39383bf" title="Initializes the vibration motor.">InitializeVibrationDevice()</a></code> for the corresponding vibration motor is complete.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Send the vibration value to the vibration motor. The sent vibration value is maintained until it is overwritten. You must explicitly send a vibration value with an amplitude value of zero to stop the vibration. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a119">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a2fb585205dac5c49b24bf045b8796307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb585205dac5c49b24bf045b8796307">&#9670;&nbsp;</a></span>GetActualVibrationValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::GetActualVibrationValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_vibration_value.html">VibrationValue</a> *&#160;</td>
          <td class="paramname"><em>pOutValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1hid_1_1_vibration_device_handle.html">VibrationDeviceHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the actual vibration values occurring on the vibration motor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValue</td><td>The location where the actual vibration value is stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The handle of the vibration motor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The call to <code><a class="el" href="namespacenn_1_1hid.html#af610eb6d705297bd91c56825b39383bf" title="Initializes the vibration motor.">InitializeVibrationDevice()</a></code> for the corresponding vibration motor is complete.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the actual vibration values occurring on the vibration motor.</p>
<p>Because vibration values created by the program are sent to the vibration motor in an encrypted state, those vibration values will not always match the actual vibration values.<br  />
 There may also be instances where, due to system settings, there are adjustments to the system-created vibration values.</p>
<p>It can take dozens of milliseconds until the vibration value specified by the <code><a class="el" href="namespacenn_1_1hid.html#adc2935e350eab46cc13a4e9d33c61ef9" title="Send the vibration value to the vibration motor.">SendVibrationValue()</a></code> function is actually sent to the vibration motor. Conversely, the vibration values obtained by this function are the latest vibration values actually sent to the vibration motor. Consequently, a delay that could last dozens of milliseconds occurs before the vibration value sent by the <code><a class="el" href="namespacenn_1_1hid.html#adc2935e350eab46cc13a4e9d33c61ef9" title="Send the vibration value to the vibration motor.">SendVibrationValue()</a></code> function is applied as the vibration value obtained by this function. </p>

</div>
</div>
<a id="a19b2160770d0185f4056ef76cac27976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b2160770d0185f4056ef76cac27976">&#9670;&nbsp;</a></span>IsVibrationPermitted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::hid::IsVibrationPermitted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the vibration feature is enabled in the system settings. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the vibration features are enabled, and <code>false</code> if they are disabled.</dd></dl>
<p> <b>Details</b> <br  />
 Gets the setting value from the HOME Menu in <b>Settings</b> &gt; <b>Controllers and Sensors</b> &gt; <b>Controller Vibration</b>.</p>
<p>While vibration functions can still be called if the vibration features are disabled, it is not actually possible to vibrate the vibration motor. </p>

</div>
</div>
<a id="a7d0be2e26c8283bf479ec142133c81e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d0be2e26c8283bf479ec142133c81e2">&#9670;&nbsp;</a></span>ParseVibrationFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::hid::ParseVibrationFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_vibration_file_info.html">VibrationFileInfo</a> *&#160;</td>
          <td class="paramname"><em>pOutInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_vibration_file_parser_context.html">VibrationFileParserContext</a> *&#160;</td>
          <td class="paramname"><em>pOutContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>fileSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the vibration file's binary data. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000403">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">nn::ResultSuccess</a></b> Indicates that the process ended normally. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1hid_1_1_result_vibration_file_invalid.html" title="A class that represents error Result values (hid: Invalid vibration file.).">nn::hid::ResultVibrationFileInvalid</a></b> Indicates that vibration file binary data is invalid.</p>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutInfo</td><td>The location to use for storing vibration file information. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutContext</td><td>The location to use for storing the parser context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The starting address of the memory region where the vibration file's binary data is extracted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileSize</td><td>The size of the binary file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutInfo</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutContext</em></code> != <code>nullptr</code>.</li>
<li><code><em>address</em></code> != <code>nullptr</code>.</li>
<li>The valid binary data that has been read from the vibration file is extracted to a contiguous memory region starting from <code><em>address</em></code>.</li>
<li><code><em>fileSize</em></code> is equal to or larger than the loaded vibration file.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Parses the vibration file binary data that has been already extracted in memory, and initializes the parser context at the same time that it gets the file information.<br  />
 To use the <code><a class="el" href="namespacenn_1_1hid.html#a43c97eccdcb915afba12627b52c2e692">nn::hid::RetrieveVibrationValue</a></code> function, you must use this function ahead of time to initialize the parser context.<br  />
 When using an initialized <code><a class="el" href="structnn_1_1hid_1_1_vibration_file_parser_context.html" title="The structure that represents the parser context of the vibration file.">VibrationFileParserContext</a></code> with this function, you must prevent the application from overwriting the <code><em>fileSize</em></code> byte area from the address to which the vibration file binary data has been extracted to. </p>

</div>
</div>
<a id="a43c97eccdcb915afba12627b52c2e692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c97eccdcb915afba12627b52c2e692">&#9670;&nbsp;</a></span>RetrieveVibrationValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::RetrieveVibrationValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_vibration_value.html">VibrationValue</a> *&#160;</td>
          <td class="paramname"><em>pOutValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1hid_1_1_vibration_file_parser_context.html">VibrationFileParserContext</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the vibration value from the vibration file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValue</td><td>The location to use for storing the obtained vibration value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The position (the sample number) of the vibration value you want to get. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pContext</td><td>The parser context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutValue</em></code> != <code>nullptr</code>.</li>
<li><code>0</code> &lt;= <code><em>position</em></code> &lt; The vibration file sample length.</li>
<li><code><em>pContext</em></code> has been already initialized by the <code><a class="el" href="namespacenn_1_1hid.html#a7d0be2e26c8283bf479ec142133c81e2">nn::hid::ParseVibrationFile</a></code> function.</li>
<li>When <code><em>pContext</em></code> is initialized, the binary data of the vibration file is extracted and placed unmodified in the designated memory space.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Parses the vibration file binary data that has been extracted in memory, and gets the vibration value from the specified position in the vibration file.<br  />
 This function gets the vibration value by decoding in order from the position where that last vibration value was obtained.<br  />
 Calculation times are shortest when you get vibration values in order from the start. </p>

</div>
</div>
<a id="a8d2ee8289c45de4b0504d82007454537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d2ee8289c45de4b0504d82007454537">&#9670;&nbsp;</a></span>GenerateVibrationFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::hid::GenerateVibrationFile </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>outBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1hid_1_1_vibration_value_array_info.html">VibrationValueArrayInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1hid_1_1_vibration_value.html">VibrationValue</a> *&#160;</td>
          <td class="paramname"><em>pValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates the vibration file binary data from the vibration value array, and stores it in the specified buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSize</td><td>Size of the generated binary data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outBuffer</td><td>Starting address of the storage buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of the storage buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">info</td><td>Vibration value array information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pValues</td><td>Starting address of the vibration value array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutSize</em></code> != <code>nullptr</code>.</li>
<li><code><em>outBuffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>bufferSize</em></code> &gt; <code>0</code>.</li>
<li><code><em>bufferSize</em></code> is greater than the size required by <code><a class="el" href="namespacenn_1_1hid.html#abad2cf3d5355249ec88c2ff3c93611b5" title="Gets the size of the vibration file generated from the vibration value array data.">CalculateVibrationFileSize()</a></code>.</li>
<li><code><em>info</em>.sampleLength</code> &gt; <code>0</code>.</li>
<li><code><em>info</em>.loopStartPosition</code> &lt;= <code><em>info</em>.loopEndPosition</code>.</li>
<li><code><em>info</em>.loopEndPosition</code> &lt;= <code><em>info</em>.sampleLength</code>.</li>
<li><code><em>info</em>.loopInterval</code> &lt;= <code>0x7FFFFFFF</code>.</li>
<li><code><em>pValues</em></code> != <code>nullptr</code>.</li>
<li>Writes a valid vibration value to the continuous region beginning with <code><em>pValues</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Use the <code><a class="el" href="namespacenn_1_1hid.html#abad2cf3d5355249ec88c2ff3c93611b5" title="Gets the size of the vibration file generated from the vibration value array data.">CalculateVibrationFileSize()</a></code> function to calculate the required size for the storage buffer.</p>
<p>Export the generated binary data with the BNVIB extension to import it into the vibration collection.<br  />
 The binary data can be used to replay vibration using the <code><a class="el" href="namespacenn_1_1hid.html#a7d0be2e26c8283bf479ec142133c81e2" title="Parses the vibration file&#39;s binary data.">ParseVibrationFile()</a></code> function or <a class="el" href="classnn_1_1hid_1_1_vibration_player.html" title="The vibration node that provides functionality as a source for vibration values by playing back vibra...">VibrationPlayer</a>.<br  />
</p>

</div>
</div>
<a id="abad2cf3d5355249ec88c2ff3c93611b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad2cf3d5355249ec88c2ff3c93611b5">&#9670;&nbsp;</a></span>CalculateVibrationFileSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::hid::CalculateVibrationFileSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1hid_1_1_vibration_value_array_info.html">VibrationValueArrayInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of the vibration file generated from the vibration value array data. </p>
<dl class="section return"><dt>Returns</dt><dd>Binary data size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">info</td><td>Vibration value array information.</td></tr>
  </table>
  </dd>
</dl>
<p> <b>Details</b> <br  />
 The size of the binary data generated for the vibration file differs depending on the number of vibration value samples and whether looping is configured.<br  />
 Use the <code><a class="el" href="namespacenn_1_1hid.html#a8d2ee8289c45de4b0504d82007454537" title="Generates the vibration file binary data from the vibration value array, and stores it in the specifi...">GenerateVibrationFile()</a></code> function to calculate the required buffer size from the vibration value array data. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a87d16cb0d039a8f0f0476acd206adf46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87d16cb0d039a8f0f0476acd206adf46">&#9670;&nbsp;</a></span>AccelerometerMax</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float nn::hid::AccelerometerMax = 7.0f</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum absolute value for the accelerometer. </p>
<p>In units of G. </p>

</div>
</div>
<a id="aed9852ed5443cbe820a40b00322455f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed9852ed5443cbe820a40b00322455f0">&#9670;&nbsp;</a></span>AngularVelocityMax</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float nn::hid::AngularVelocityMax = 5.0f</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum absolute value for the gyroscope. </p>
<p>The unit is degrees per second, where 360 dps = 1. </p>

</div>
</div>
<a id="ab9bd32faec2ea80f5a64515ae6ebabfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9bd32faec2ea80f5a64515ae6ebabfd">&#9670;&nbsp;</a></span>VibrationFrequencyLowDefault</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int nn::hid::VibrationFrequencyLowDefault = 160</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default frequency for low bandwidths. </p>
<p>In units of Hertz. </p>

</div>
</div>
<a id="a91a922d2e30dc5f92ea6fdd0b342852a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a922d2e30dc5f92ea6fdd0b342852a">&#9670;&nbsp;</a></span>VibrationFrequencyHighDefault</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int nn::hid::VibrationFrequencyHighDefault = 320</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default frequency for high bandwidths. </p>
<p>In units of Hertz. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
